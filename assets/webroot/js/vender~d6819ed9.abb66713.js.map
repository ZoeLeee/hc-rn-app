{"version":3,"file":"js/vender~d6819ed9.abb66713.js","mappings":"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","sources":["webpack:///../../../node_modules/@babylonjs/core/LensFlares/lensFlare.js","webpack:///../../../node_modules/@babylonjs/core/LensFlares/lensFlareSystem.js","webpack:///../../../node_modules/@babylonjs/core/LensFlares/lensFlareSystemSceneComponent.js","webpack:///../../../node_modules/@babylonjs/core/Lights/Shadows/cascadedShadowGenerator.js","webpack:///../../../node_modules/@babylonjs/core/Lights/Shadows/shadowGeneratorSceneComponent.js","webpack:///../../../node_modules/@babylonjs/core/Lights/Shadows/shadowGenerator.js","webpack:///../../../node_modules/@babylonjs/core/Lights/directionalLight.js","webpack:///../../../node_modules/@babylonjs/core/Lights/hemisphericLight.js","webpack:///../../../node_modules/@babylonjs/core/Lights/light.js","webpack:///../../../node_modules/@babylonjs/core/Lights/lightConstants.js","webpack:///../../../node_modules/@babylonjs/core/Lights/pointLight.js","webpack:///../../../node_modules/@babylonjs/core/Lights/shadowLight.js","webpack:///../../../node_modules/@babylonjs/core/Lights/spotLight.js","webpack:///../../../node_modules/@babylonjs/core/Loading/loadingScreen.js","webpack:///../../../node_modules/@babylonjs/core/Loading/Plugins/babylonFileLoader.js","webpack:///../../../node_modules/@babylonjs/core/Loading/sceneLoader.js","webpack:///../../../node_modules/@babylonjs/core/Loading/sceneLoaderFlags.js","webpack:///../../../node_modules/@babylonjs/core/Materials/Background/backgroundMaterial.js","webpack:///../../../node_modules/@babylonjs/core/Materials/Node/Blocks/Dual/currentScreenBlock.js","webpack:///../../../node_modules/@babylonjs/core/Materials/Node/Blocks/Dual/imageSourceBlock.js","webpack:///../../../node_modules/@babylonjs/core/Materials/Node/Blocks/Dual/fogBlock.js","webpack:///../../../node_modules/@babylonjs/core/Materials/Node/Blocks/Dual/lightBlock.js","webpack:///../../../node_modules/@babylonjs/core/Materials/Node/Blocks/Dual/textureBlock.js","webpack:///../../../node_modules/@babylonjs/core/Materials/Node/Blocks/Dual/reflectionTextureBlock.js","webpack:///../../../node_modules/@babylonjs/core/Materials/Node/Blocks/Dual/sceneDepthBlock.js","webpack:///../../../node_modules/@babylonjs/core/Materials/Node/Blocks/Dual/clipPlanesBlock.js","webpack:///../../../node_modules/@babylonjs/core/Materials/Node/Blocks/Dual/reflectionTextureBaseBlock.js","webpack:///../../../node_modules/@babylonjs/core/Materials/Node/Blocks/Fragment/TBNBlock.js","webpack:///../../../node_modules/@babylonjs/core/Materials/Node/Blocks/Fragment/fragmentOutputBlock.js","webpack:///../../../node_modules/@babylonjs/core/Materials/Node/Blocks/Fragment/imageProcessingBlock.js","webpack:///../../../node_modules/@babylonjs/core/Materials/Node/Blocks/Fragment/perturbNormalBlock.js","webpack:///../../../node_modules/@babylonjs/core/Materials/Node/Blocks/Fragment/discardBlock.js","webpack:///../../../node_modules/@babylonjs/core/Materials/Node/Blocks/Fragment/frontFacingBlock.js","webpack:///../../../node_modules/@babylonjs/core/Materials/Node/Blocks/Fragment/derivativeBlock.js","webpack:///../../../node_modules/@babylonjs/core/Materials/Node/Blocks/Fragment/fragCoordBlock.js","webpack:///../../../node_modules/@babylonjs/core/Materials/Node/Blocks/Fragment/screenSizeBlock.js","webpack:///../../../node_modules/@babylonjs/core/Materials/Node/Blocks/Fragment/screenSpaceBlock.js","webpack:///../../../node_modules/@babylonjs/core/Materials/Node/Blocks/Fragment/twirlBlock.js","webpack:///../../../node_modules/@babylonjs/core/Materials/Node/Blocks/Fragment/heightToNormalBlock.js","webpack:///../../../node_modules/@babylonjs/core/Materials/Node/Blocks/Fragment/fragDepthBlock.js","webpack:///../../../node_modules/@babylonjs/core/Materials/Node/Blocks/Fragment/shadowMapBlock.js","webpack:///../../../node_modules/@babylonjs/core/Materials/Node/Blocks/Input/animatedInputBlockTypes.js","webpack:///../../../node_modules/@babylonjs/core/Materials/Node/Blocks/Input/inputBlock.js","webpack:///../../../node_modules/@babylonjs/core/Materials/Node/Blocks/PBR/anisotropyBlock.js","webpack:///../../../node_modules/@babylonjs/core/Materials/Node/Blocks/PBR/clearCoatBlock.js"],"sourcesContent":["import { Color3 } from \"../Maths/math.color.js\";\nimport { Texture } from \"../Materials/Textures/texture.js\";\n\nimport { DrawWrapper } from \"../Materials/drawWrapper.js\";\nimport { VertexBuffer } from \"../Buffers/buffer.js\";\n/**\n * This represents one of the lens effect in a `lensFlareSystem`.\n * It controls one of the individual texture used in the effect.\n * @see https://doc.babylonjs.com/features/featuresDeepDive/environment/lenseFlare\n */\nexport class LensFlare {\n    /**\n     * Creates a new Lens Flare.\n     * This represents one of the lens effect in a `lensFlareSystem`.\n     * It controls one of the individual texture used in the effect.\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/environment/lenseFlare\n     * @param size Define the size of the lens flare (a floating value between 0 and 1)\n     * @param position Define the position of the lens flare in the system. (a floating value between -1 and 1). A value of 0 is located on the emitter. A value greater than 0 is beyond the emitter and a value lesser than 0 is behind.\n     * @param color Define the lens color\n     * @param imgUrl Define the lens texture url\n     * @param system Define the `lensFlareSystem` this flare is part of\n     * @returns The newly created Lens Flare\n     */\n    static AddFlare(size, position, color, imgUrl, system) {\n        return new LensFlare(size, position, color, imgUrl, system);\n    }\n    /**\n     * Instantiates a new Lens Flare.\n     * This represents one of the lens effect in a `lensFlareSystem`.\n     * It controls one of the individual texture used in the effect.\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/environment/lenseFlare\n     * @param size Define the size of the lens flare in the system (a floating value between 0 and 1)\n     * @param position Define the position of the lens flare in the system. (a floating value between -1 and 1). A value of 0 is located on the emitter. A value greater than 0 is beyond the emitter and a value lesser than 0 is behind.\n     * @param color Define the lens color\n     * @param imgUrl Define the lens texture url\n     * @param system Define the `lensFlareSystem` this flare is part of\n     */\n    constructor(\n    /**\n     * Define the size of the lens flare in the system (a floating value between 0 and 1)\n     */\n    size, \n    /**\n     * Define the position of the lens flare in the system. (a floating value between -1 and 1). A value of 0 is located on the emitter. A value greater than 0 is beyond the emitter and a value lesser than 0 is behind.\n     */\n    position, color, imgUrl, system) {\n        this.size = size;\n        this.position = position;\n        /**\n         * Define the alpha mode to render this particular lens.\n         */\n        this.alphaMode = 6;\n        this.color = color || new Color3(1, 1, 1);\n        this.texture = imgUrl ? new Texture(imgUrl, system.getScene(), true) : null;\n        this._system = system;\n        const engine = system.scene.getEngine();\n        this._drawWrapper = new DrawWrapper(engine);\n        this._drawWrapper.effect = engine.createEffect(\"lensFlare\", [VertexBuffer.PositionKind], [\"color\", \"viewportMatrix\"], [\"textureSampler\"], \"\");\n        system.lensFlares.push(this);\n    }\n    /**\n     * Dispose and release the lens flare with its associated resources.\n     */\n    dispose() {\n        if (this.texture) {\n            this.texture.dispose();\n        }\n        // Remove from scene\n        const index = this._system.lensFlares.indexOf(this);\n        this._system.lensFlares.splice(index, 1);\n    }\n}\n//# sourceMappingURL=lensFlare.js.map","import { Tools } from \"../Misc/tools.js\";\nimport { Matrix, Vector3 } from \"../Maths/math.vector.js\";\nimport { Scalar } from \"../Maths/math.scalar.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\nimport { VertexBuffer } from \"../Buffers/buffer.js\";\nimport { Ray } from \"../Culling/ray.js\";\nimport { Material } from \"../Materials/material.js\";\nimport { LensFlare } from \"./lensFlare.js\";\n\nimport \"../Shaders/lensFlare.fragment.js\";\nimport \"../Shaders/lensFlare.vertex.js\";\nimport { _WarnImport } from \"../Misc/devTools.js\";\nimport { Color3 } from \"../Maths/math.color.js\";\n/**\n * This represents a Lens Flare System or the shiny effect created by the light reflection on the  camera lenses.\n * It is usually composed of several `lensFlare`.\n * @see https://doc.babylonjs.com/features/featuresDeepDive/environment/lenseFlare\n */\nexport class LensFlareSystem {\n    /** Gets the scene */\n    get scene() {\n        return this._scene;\n    }\n    /**\n     * Instantiates a lens flare system.\n     * This represents a Lens Flare System or the shiny effect created by the light reflection on the  camera lenses.\n     * It is usually composed of several `lensFlare`.\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/environment/lenseFlare\n     * @param name Define the name of the lens flare system in the scene\n     * @param emitter Define the source (the emitter) of the lens flares (it can be a camera, a light or a mesh).\n     * @param scene Define the scene the lens flare system belongs to\n     */\n    constructor(\n    /**\n     * Define the name of the lens flare system\n     */\n    name, emitter, scene) {\n        this.name = name;\n        /**\n         * List of lens flares used in this system.\n         */\n        this.lensFlares = new Array();\n        /**\n         * Define a limit from the border the lens flare can be visible.\n         */\n        this.borderLimit = 300;\n        /**\n         * Define a viewport border we do not want to see the lens flare in.\n         */\n        this.viewportBorder = 0;\n        /**\n         * Restricts the rendering of the effect to only the camera rendering this layer mask.\n         */\n        this.layerMask = 0x0fffffff;\n        this._vertexBuffers = {};\n        this._isEnabled = true;\n        this._scene = scene || EngineStore.LastCreatedScene;\n        LensFlareSystem._SceneComponentInitialization(this._scene);\n        this._emitter = emitter;\n        this.id = name;\n        scene.lensFlareSystems.push(this);\n        this.meshesSelectionPredicate = (m) => (scene.activeCamera && m.material && m.isVisible && m.isEnabled() && m.isBlocker && (m.layerMask & scene.activeCamera.layerMask) != 0);\n        const engine = scene.getEngine();\n        // VBO\n        const vertices = [];\n        vertices.push(1, 1);\n        vertices.push(-1, 1);\n        vertices.push(-1, -1);\n        vertices.push(1, -1);\n        this._vertexBuffers[VertexBuffer.PositionKind] = new VertexBuffer(engine, vertices, VertexBuffer.PositionKind, false, false, 2);\n        // Indices\n        this._createIndexBuffer();\n    }\n    _createIndexBuffer() {\n        const indices = [];\n        indices.push(0);\n        indices.push(1);\n        indices.push(2);\n        indices.push(0);\n        indices.push(2);\n        indices.push(3);\n        this._indexBuffer = this._scene.getEngine().createIndexBuffer(indices);\n    }\n    /**\n     * Define if the lens flare system is enabled.\n     */\n    get isEnabled() {\n        return this._isEnabled;\n    }\n    set isEnabled(value) {\n        this._isEnabled = value;\n    }\n    /**\n     * Get the scene the effects belongs to.\n     * @returns the scene holding the lens flare system\n     */\n    getScene() {\n        return this._scene;\n    }\n    /**\n     * Get the emitter of the lens flare system.\n     * It defines the source of the lens flares (it can be a camera, a light or a mesh).\n     * @returns the emitter of the lens flare system\n     */\n    getEmitter() {\n        return this._emitter;\n    }\n    /**\n     * Set the emitter of the lens flare system.\n     * It defines the source of the lens flares (it can be a camera, a light or a mesh).\n     * @param newEmitter Define the new emitter of the system\n     */\n    setEmitter(newEmitter) {\n        this._emitter = newEmitter;\n    }\n    /**\n     * Get the lens flare system emitter position.\n     * The emitter defines the source of the lens flares (it can be a camera, a light or a mesh).\n     * @returns the position\n     */\n    getEmitterPosition() {\n        return this._emitter.getAbsolutePosition ? this._emitter.getAbsolutePosition() : this._emitter.position;\n    }\n    /**\n     * @internal\n     */\n    computeEffectivePosition(globalViewport) {\n        let position = this.getEmitterPosition();\n        position = Vector3.Project(position, Matrix.Identity(), this._scene.getTransformMatrix(), globalViewport);\n        this._positionX = position.x;\n        this._positionY = position.y;\n        position = Vector3.TransformCoordinates(this.getEmitterPosition(), this._scene.getViewMatrix());\n        if (this.viewportBorder > 0) {\n            globalViewport.x -= this.viewportBorder;\n            globalViewport.y -= this.viewportBorder;\n            globalViewport.width += this.viewportBorder * 2;\n            globalViewport.height += this.viewportBorder * 2;\n            position.x += this.viewportBorder;\n            position.y += this.viewportBorder;\n            this._positionX += this.viewportBorder;\n            this._positionY += this.viewportBorder;\n        }\n        const rhs = this._scene.useRightHandedSystem;\n        const okZ = (position.z > 0 && !rhs) || (position.z < 0 && rhs);\n        if (okZ) {\n            if (this._positionX > globalViewport.x && this._positionX < globalViewport.x + globalViewport.width) {\n                if (this._positionY > globalViewport.y && this._positionY < globalViewport.y + globalViewport.height) {\n                    return true;\n                }\n            }\n            return true;\n        }\n        return false;\n    }\n    /** @internal */\n    _isVisible() {\n        if (!this._isEnabled || !this._scene.activeCamera) {\n            return false;\n        }\n        const emitterPosition = this.getEmitterPosition();\n        const direction = emitterPosition.subtract(this._scene.activeCamera.globalPosition);\n        const distance = direction.length();\n        direction.normalize();\n        const ray = new Ray(this._scene.activeCamera.globalPosition, direction);\n        const pickInfo = this._scene.pickWithRay(ray, this.meshesSelectionPredicate, true);\n        return !pickInfo || !pickInfo.hit || pickInfo.distance > distance;\n    }\n    /**\n     * @internal\n     */\n    render() {\n        if (!this._scene.activeCamera) {\n            return false;\n        }\n        const engine = this._scene.getEngine();\n        const viewport = this._scene.activeCamera.viewport;\n        const globalViewport = viewport.toGlobal(engine.getRenderWidth(true), engine.getRenderHeight(true));\n        // Position\n        if (!this.computeEffectivePosition(globalViewport)) {\n            return false;\n        }\n        // Visibility\n        if (!this._isVisible()) {\n            return false;\n        }\n        // Intensity\n        let awayX;\n        let awayY;\n        if (this._positionX < this.borderLimit + globalViewport.x) {\n            awayX = this.borderLimit + globalViewport.x - this._positionX;\n        }\n        else if (this._positionX > globalViewport.x + globalViewport.width - this.borderLimit) {\n            awayX = this._positionX - globalViewport.x - globalViewport.width + this.borderLimit;\n        }\n        else {\n            awayX = 0;\n        }\n        if (this._positionY < this.borderLimit + globalViewport.y) {\n            awayY = this.borderLimit + globalViewport.y - this._positionY;\n        }\n        else if (this._positionY > globalViewport.y + globalViewport.height - this.borderLimit) {\n            awayY = this._positionY - globalViewport.y - globalViewport.height + this.borderLimit;\n        }\n        else {\n            awayY = 0;\n        }\n        let away = awayX > awayY ? awayX : awayY;\n        away -= this.viewportBorder;\n        if (away > this.borderLimit) {\n            away = this.borderLimit;\n        }\n        let intensity = 1.0 - Scalar.Clamp(away / this.borderLimit, 0, 1);\n        if (intensity < 0) {\n            return false;\n        }\n        if (intensity > 1.0) {\n            intensity = 1.0;\n        }\n        if (this.viewportBorder > 0) {\n            globalViewport.x += this.viewportBorder;\n            globalViewport.y += this.viewportBorder;\n            globalViewport.width -= this.viewportBorder * 2;\n            globalViewport.height -= this.viewportBorder * 2;\n            this._positionX -= this.viewportBorder;\n            this._positionY -= this.viewportBorder;\n        }\n        // Position\n        const centerX = globalViewport.x + globalViewport.width / 2;\n        const centerY = globalViewport.y + globalViewport.height / 2;\n        const distX = centerX - this._positionX;\n        const distY = centerY - this._positionY;\n        // Effects\n        engine.setState(false);\n        engine.setDepthBuffer(false);\n        // Flares\n        for (let index = 0; index < this.lensFlares.length; index++) {\n            const flare = this.lensFlares[index];\n            if (!flare._drawWrapper.effect.isReady() || (flare.texture && !flare.texture.isReady())) {\n                continue;\n            }\n            engine.enableEffect(flare._drawWrapper);\n            engine.bindBuffers(this._vertexBuffers, this._indexBuffer, flare._drawWrapper.effect);\n            engine.setAlphaMode(flare.alphaMode);\n            const x = centerX - distX * flare.position;\n            const y = centerY - distY * flare.position;\n            const cw = flare.size;\n            const ch = flare.size * engine.getAspectRatio(this._scene.activeCamera, true);\n            const cx = 2 * (x / (globalViewport.width + globalViewport.x * 2)) - 1.0;\n            const cy = 1.0 - 2 * (y / (globalViewport.height + globalViewport.y * 2));\n            const viewportMatrix = Matrix.FromValues(cw / 2, 0, 0, 0, 0, ch / 2, 0, 0, 0, 0, 1, 0, cx, cy, 0, 1);\n            flare._drawWrapper.effect.setMatrix(\"viewportMatrix\", viewportMatrix);\n            // Texture\n            flare._drawWrapper.effect.setTexture(\"textureSampler\", flare.texture);\n            // Color\n            flare._drawWrapper.effect.setFloat4(\"color\", flare.color.r * intensity, flare.color.g * intensity, flare.color.b * intensity, 1.0);\n            // Draw order\n            engine.drawElementsType(Material.TriangleFillMode, 0, 6);\n        }\n        engine.setDepthBuffer(true);\n        engine.setAlphaMode(0);\n        return true;\n    }\n    /**\n     * Rebuilds the lens flare system\n     */\n    rebuild() {\n        var _a;\n        this._createIndexBuffer();\n        for (const key in this._vertexBuffers) {\n            (_a = this._vertexBuffers[key]) === null || _a === void 0 ? void 0 : _a._rebuild();\n        }\n    }\n    /**\n     * Dispose and release the lens flare with its associated resources.\n     */\n    dispose() {\n        const vertexBuffer = this._vertexBuffers[VertexBuffer.PositionKind];\n        if (vertexBuffer) {\n            vertexBuffer.dispose();\n            this._vertexBuffers[VertexBuffer.PositionKind] = null;\n        }\n        if (this._indexBuffer) {\n            this._scene.getEngine()._releaseBuffer(this._indexBuffer);\n            this._indexBuffer = null;\n        }\n        while (this.lensFlares.length) {\n            this.lensFlares[0].dispose();\n        }\n        // Remove from scene\n        const index = this._scene.lensFlareSystems.indexOf(this);\n        this._scene.lensFlareSystems.splice(index, 1);\n    }\n    /**\n     * Parse a lens flare system from a JSON representation\n     * @param parsedLensFlareSystem Define the JSON to parse\n     * @param scene Define the scene the parsed system should be instantiated in\n     * @param rootUrl Define the rootUrl of the load sequence to easily find a load relative dependencies such as textures\n     * @returns the parsed system\n     */\n    static Parse(parsedLensFlareSystem, scene, rootUrl) {\n        const emitter = scene.getLastEntryById(parsedLensFlareSystem.emitterId);\n        const name = parsedLensFlareSystem.name || \"lensFlareSystem#\" + parsedLensFlareSystem.emitterId;\n        const lensFlareSystem = new LensFlareSystem(name, emitter, scene);\n        lensFlareSystem.id = parsedLensFlareSystem.id || name;\n        lensFlareSystem.borderLimit = parsedLensFlareSystem.borderLimit;\n        for (let index = 0; index < parsedLensFlareSystem.flares.length; index++) {\n            const parsedFlare = parsedLensFlareSystem.flares[index];\n            LensFlare.AddFlare(parsedFlare.size, parsedFlare.position, Color3.FromArray(parsedFlare.color), parsedFlare.textureName ? rootUrl + parsedFlare.textureName : \"\", lensFlareSystem);\n        }\n        return lensFlareSystem;\n    }\n    /**\n     * Serialize the current Lens Flare System into a JSON representation.\n     * @returns the serialized JSON\n     */\n    serialize() {\n        const serializationObject = {};\n        serializationObject.id = this.id;\n        serializationObject.name = this.name;\n        serializationObject.emitterId = this.getEmitter().id;\n        serializationObject.borderLimit = this.borderLimit;\n        serializationObject.flares = [];\n        for (let index = 0; index < this.lensFlares.length; index++) {\n            const flare = this.lensFlares[index];\n            serializationObject.flares.push({\n                size: flare.size,\n                position: flare.position,\n                color: flare.color.asArray(),\n                textureName: Tools.GetFilename(flare.texture ? flare.texture.name : \"\"),\n            });\n        }\n        return serializationObject;\n    }\n}\n/**\n * @internal\n */\nLensFlareSystem._SceneComponentInitialization = (_) => {\n    throw _WarnImport(\"LensFlareSystemSceneComponent\");\n};\n//# sourceMappingURL=lensFlareSystem.js.map","import { Tools } from \"../Misc/tools.js\";\nimport { SceneComponentConstants } from \"../sceneComponent.js\";\nimport { AbstractScene } from \"../abstractScene.js\";\nimport { LensFlareSystem } from \"./lensFlareSystem.js\";\n// Adds the parser to the scene parsers.\nAbstractScene.AddParser(SceneComponentConstants.NAME_LENSFLARESYSTEM, (parsedData, scene, container, rootUrl) => {\n    // Lens flares\n    if (parsedData.lensFlareSystems !== undefined && parsedData.lensFlareSystems !== null) {\n        if (!container.lensFlareSystems) {\n            container.lensFlareSystems = new Array();\n        }\n        for (let index = 0, cache = parsedData.lensFlareSystems.length; index < cache; index++) {\n            const parsedLensFlareSystem = parsedData.lensFlareSystems[index];\n            const lf = LensFlareSystem.Parse(parsedLensFlareSystem, scene, rootUrl);\n            container.lensFlareSystems.push(lf);\n        }\n    }\n});\nAbstractScene.prototype.getLensFlareSystemByName = function (name) {\n    for (let index = 0; index < this.lensFlareSystems.length; index++) {\n        if (this.lensFlareSystems[index].name === name) {\n            return this.lensFlareSystems[index];\n        }\n    }\n    return null;\n};\nAbstractScene.prototype.getLensFlareSystemById = function (id) {\n    for (let index = 0; index < this.lensFlareSystems.length; index++) {\n        if (this.lensFlareSystems[index].id === id) {\n            return this.lensFlareSystems[index];\n        }\n    }\n    return null;\n};\nAbstractScene.prototype.getLensFlareSystemByID = function (id) {\n    return this.getLensFlareSystemById(id);\n};\nAbstractScene.prototype.removeLensFlareSystem = function (toRemove) {\n    const index = this.lensFlareSystems.indexOf(toRemove);\n    if (index !== -1) {\n        this.lensFlareSystems.splice(index, 1);\n    }\n    return index;\n};\nAbstractScene.prototype.addLensFlareSystem = function (newLensFlareSystem) {\n    this.lensFlareSystems.push(newLensFlareSystem);\n};\n/**\n * Defines the lens flare scene component responsible to manage any lens flares\n * in a given scene.\n */\nexport class LensFlareSystemSceneComponent {\n    /**\n     * Creates a new instance of the component for the given scene\n     * @param scene Defines the scene to register the component in\n     */\n    constructor(scene) {\n        /**\n         * The component name helpful to identify the component in the list of scene components.\n         */\n        this.name = SceneComponentConstants.NAME_LENSFLARESYSTEM;\n        this.scene = scene;\n        scene.lensFlareSystems = new Array();\n    }\n    /**\n     * Registers the component in a given scene\n     */\n    register() {\n        this.scene._afterCameraDrawStage.registerStep(SceneComponentConstants.STEP_AFTERCAMERADRAW_LENSFLARESYSTEM, this, this._draw);\n    }\n    /**\n     * Rebuilds the elements related to this component in case of\n     * context lost for instance.\n     */\n    rebuild() {\n        for (let index = 0; index < this.scene.lensFlareSystems.length; index++) {\n            this.scene.lensFlareSystems[index].rebuild();\n        }\n    }\n    /**\n     * Adds all the elements from the container to the scene\n     * @param container the container holding the elements\n     */\n    addFromContainer(container) {\n        if (!container.lensFlareSystems) {\n            return;\n        }\n        container.lensFlareSystems.forEach((o) => {\n            this.scene.addLensFlareSystem(o);\n        });\n    }\n    /**\n     * Removes all the elements in the container from the scene\n     * @param container contains the elements to remove\n     * @param dispose if the removed element should be disposed (default: false)\n     */\n    removeFromContainer(container, dispose) {\n        if (!container.lensFlareSystems) {\n            return;\n        }\n        container.lensFlareSystems.forEach((o) => {\n            this.scene.removeLensFlareSystem(o);\n            if (dispose) {\n                o.dispose();\n            }\n        });\n    }\n    /**\n     * Serializes the component data to the specified json object\n     * @param serializationObject The object to serialize to\n     */\n    serialize(serializationObject) {\n        // Lens flares\n        serializationObject.lensFlareSystems = [];\n        const lensFlareSystems = this.scene.lensFlareSystems;\n        for (const lensFlareSystem of lensFlareSystems) {\n            serializationObject.lensFlareSystems.push(lensFlareSystem.serialize());\n        }\n    }\n    /**\n     * Disposes the component and the associated resources.\n     */\n    dispose() {\n        const lensFlareSystems = this.scene.lensFlareSystems;\n        while (lensFlareSystems.length) {\n            lensFlareSystems[0].dispose();\n        }\n    }\n    _draw(camera) {\n        // Lens flares\n        if (this.scene.lensFlaresEnabled) {\n            const lensFlareSystems = this.scene.lensFlareSystems;\n            Tools.StartPerformanceCounter(\"Lens flares\", lensFlareSystems.length > 0);\n            for (const lensFlareSystem of lensFlareSystems) {\n                if ((camera.layerMask & lensFlareSystem.layerMask) !== 0) {\n                    lensFlareSystem.render();\n                }\n            }\n            Tools.EndPerformanceCounter(\"Lens flares\", lensFlareSystems.length > 0);\n        }\n    }\n}\nLensFlareSystem._SceneComponentInitialization = (scene) => {\n    let component = scene._getComponent(SceneComponentConstants.NAME_LENSFLARESYSTEM);\n    if (!component) {\n        component = new LensFlareSystemSceneComponent(scene);\n        scene._addComponent(component);\n    }\n};\n//# sourceMappingURL=lensFlareSystemSceneComponent.js.map","import { Matrix, Vector3 } from \"../../Maths/math.vector.js\";\nimport { RenderTargetTexture } from \"../../Materials/Textures/renderTargetTexture.js\";\n\nimport \"../../Shaders/shadowMap.fragment.js\";\nimport \"../../Shaders/shadowMap.vertex.js\";\nimport \"../../Shaders/depthBoxBlur.fragment.js\";\nimport { _WarnImport } from \"../../Misc/devTools.js\";\nimport { ShadowGenerator } from \"./shadowGenerator.js\";\nimport { BoundingInfo } from \"../../Culling/boundingInfo.js\";\nimport { DepthReducer } from \"../../Misc/depthReducer.js\";\nimport { Logger } from \"../../Misc/logger.js\";\nimport { EngineStore } from \"../../Engines/engineStore.js\";\n// eslint-disable-next-line @typescript-eslint/naming-convention\nconst UpDir = Vector3.Up();\n// eslint-disable-next-line @typescript-eslint/naming-convention\nconst ZeroVec = Vector3.Zero();\nconst tmpv1 = new Vector3(), tmpv2 = new Vector3(), tmpMatrix = new Matrix();\n/**\n * A CSM implementation allowing casting shadows on large scenes.\n * Documentation : https://doc.babylonjs.com/babylon101/cascadedShadows\n * Based on: https://github.com/TheRealMJP/Shadows and https://johanmedestrom.wordpress.com/2016/03/18/opengl-cascaded-shadow-maps/\n */\nexport class CascadedShadowGenerator extends ShadowGenerator {\n    _validateFilter(filter) {\n        if (filter === ShadowGenerator.FILTER_NONE || filter === ShadowGenerator.FILTER_PCF || filter === ShadowGenerator.FILTER_PCSS) {\n            return filter;\n        }\n        console.error('Unsupported filter \"' + filter + '\"!');\n        return ShadowGenerator.FILTER_NONE;\n    }\n    /**\n     * Gets or set the number of cascades used by the CSM.\n     */\n    get numCascades() {\n        return this._numCascades;\n    }\n    set numCascades(value) {\n        value = Math.min(Math.max(value, CascadedShadowGenerator.MIN_CASCADES_COUNT), CascadedShadowGenerator.MAX_CASCADES_COUNT);\n        if (value === this._numCascades) {\n            return;\n        }\n        this._numCascades = value;\n        this.recreateShadowMap();\n        this._recreateSceneUBOs();\n    }\n    /**\n     * Enables or disables the shadow casters bounding info computation.\n     * If your shadow casters don't move, you can disable this feature.\n     * If it is enabled, the bounding box computation is done every frame.\n     */\n    get freezeShadowCastersBoundingInfo() {\n        return this._freezeShadowCastersBoundingInfo;\n    }\n    set freezeShadowCastersBoundingInfo(freeze) {\n        if (this._freezeShadowCastersBoundingInfoObservable && freeze) {\n            this._scene.onBeforeRenderObservable.remove(this._freezeShadowCastersBoundingInfoObservable);\n            this._freezeShadowCastersBoundingInfoObservable = null;\n        }\n        if (!this._freezeShadowCastersBoundingInfoObservable && !freeze) {\n            this._freezeShadowCastersBoundingInfoObservable = this._scene.onBeforeRenderObservable.add(this._computeShadowCastersBoundingInfo.bind(this));\n        }\n        this._freezeShadowCastersBoundingInfo = freeze;\n        if (freeze) {\n            this._computeShadowCastersBoundingInfo();\n        }\n    }\n    _computeShadowCastersBoundingInfo() {\n        this._scbiMin.copyFromFloats(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\n        this._scbiMax.copyFromFloats(Number.MIN_VALUE, Number.MIN_VALUE, Number.MIN_VALUE);\n        if (this._shadowMap && this._shadowMap.renderList) {\n            const renderList = this._shadowMap.renderList;\n            for (let meshIndex = 0; meshIndex < renderList.length; meshIndex++) {\n                const mesh = renderList[meshIndex];\n                if (!mesh) {\n                    continue;\n                }\n                const boundingInfo = mesh.getBoundingInfo(), boundingBox = boundingInfo.boundingBox;\n                this._scbiMin.minimizeInPlace(boundingBox.minimumWorld);\n                this._scbiMax.maximizeInPlace(boundingBox.maximumWorld);\n            }\n            const meshes = this._scene.meshes;\n            for (let meshIndex = 0; meshIndex < meshes.length; meshIndex++) {\n                const mesh = meshes[meshIndex];\n                if (!mesh || !mesh.isVisible || !mesh.isEnabled || !mesh.receiveShadows) {\n                    continue;\n                }\n                const boundingInfo = mesh.getBoundingInfo(), boundingBox = boundingInfo.boundingBox;\n                this._scbiMin.minimizeInPlace(boundingBox.minimumWorld);\n                this._scbiMax.maximizeInPlace(boundingBox.maximumWorld);\n            }\n        }\n        this._shadowCastersBoundingInfo.reConstruct(this._scbiMin, this._scbiMax);\n    }\n    /**\n     * Gets or sets the shadow casters bounding info.\n     * If you provide your own shadow casters bounding info, first enable freezeShadowCastersBoundingInfo\n     * so that the system won't overwrite the bounds you provide\n     */\n    get shadowCastersBoundingInfo() {\n        return this._shadowCastersBoundingInfo;\n    }\n    set shadowCastersBoundingInfo(boundingInfo) {\n        this._shadowCastersBoundingInfo = boundingInfo;\n    }\n    /**\n     * Sets the minimal and maximal distances to use when computing the cascade breaks.\n     *\n     * The values of min / max are typically the depth zmin and zmax values of your scene, for a given frame.\n     * If you don't know these values, simply leave them to their defaults and don't call this function.\n     * @param min minimal distance for the breaks (default to 0.)\n     * @param max maximal distance for the breaks (default to 1.)\n     */\n    setMinMaxDistance(min, max) {\n        if (this._minDistance === min && this._maxDistance === max) {\n            return;\n        }\n        if (min > max) {\n            min = 0;\n            max = 1;\n        }\n        if (min < 0) {\n            min = 0;\n        }\n        if (max > 1) {\n            max = 1;\n        }\n        this._minDistance = min;\n        this._maxDistance = max;\n        this._breaksAreDirty = true;\n    }\n    /** Gets the minimal distance used in the cascade break computation */\n    get minDistance() {\n        return this._minDistance;\n    }\n    /** Gets the maximal distance used in the cascade break computation */\n    get maxDistance() {\n        return this._maxDistance;\n    }\n    /**\n     * Gets the class name of that object\n     * @returns \"CascadedShadowGenerator\"\n     */\n    getClassName() {\n        return CascadedShadowGenerator.CLASSNAME;\n    }\n    /**\n     * Gets a cascade minimum extents\n     * @param cascadeIndex index of the cascade\n     * @returns the minimum cascade extents\n     */\n    getCascadeMinExtents(cascadeIndex) {\n        return cascadeIndex >= 0 && cascadeIndex < this._numCascades ? this._cascadeMinExtents[cascadeIndex] : null;\n    }\n    /**\n     * Gets a cascade maximum extents\n     * @param cascadeIndex index of the cascade\n     * @returns the maximum cascade extents\n     */\n    getCascadeMaxExtents(cascadeIndex) {\n        return cascadeIndex >= 0 && cascadeIndex < this._numCascades ? this._cascadeMaxExtents[cascadeIndex] : null;\n    }\n    /**\n     * Gets the shadow max z distance. It's the limit beyond which shadows are not displayed.\n     * It defaults to camera.maxZ\n     */\n    get shadowMaxZ() {\n        if (!this._getCamera()) {\n            return 0;\n        }\n        return this._shadowMaxZ;\n    }\n    /**\n     * Sets the shadow max z distance.\n     */\n    set shadowMaxZ(value) {\n        const camera = this._getCamera();\n        if (!camera) {\n            this._shadowMaxZ = value;\n            return;\n        }\n        if (this._shadowMaxZ === value || value < camera.minZ || value > camera.maxZ) {\n            return;\n        }\n        this._shadowMaxZ = value;\n        this._light._markMeshesAsLightDirty();\n        this._breaksAreDirty = true;\n    }\n    /**\n     * Gets or sets the debug flag.\n     * When enabled, the cascades are materialized by different colors on the screen.\n     */\n    get debug() {\n        return this._debug;\n    }\n    set debug(dbg) {\n        this._debug = dbg;\n        this._light._markMeshesAsLightDirty();\n    }\n    /**\n     * Gets or sets the depth clamping value.\n     *\n     * When enabled, it improves the shadow quality because the near z plane of the light frustum don't need to be adjusted\n     * to account for the shadow casters far away.\n     *\n     * Note that this property is incompatible with PCSS filtering, so it won't be used in that case.\n     */\n    get depthClamp() {\n        return this._depthClamp;\n    }\n    set depthClamp(value) {\n        this._depthClamp = value;\n    }\n    /**\n     * Gets or sets the percentage of blending between two cascades (value between 0. and 1.).\n     * It defaults to 0.1 (10% blending).\n     */\n    get cascadeBlendPercentage() {\n        return this._cascadeBlendPercentage;\n    }\n    set cascadeBlendPercentage(value) {\n        this._cascadeBlendPercentage = value;\n        this._light._markMeshesAsLightDirty();\n    }\n    /**\n     * Gets or set the lambda parameter.\n     * This parameter is used to split the camera frustum and create the cascades.\n     * It's a value between 0. and 1.: If 0, the split is a uniform split of the frustum, if 1 it is a logarithmic split.\n     * For all values in-between, it's a linear combination of the uniform and logarithm split algorithm.\n     */\n    get lambda() {\n        return this._lambda;\n    }\n    set lambda(value) {\n        const lambda = Math.min(Math.max(value, 0), 1);\n        if (this._lambda == lambda) {\n            return;\n        }\n        this._lambda = lambda;\n        this._breaksAreDirty = true;\n    }\n    /**\n     * Gets the view matrix corresponding to a given cascade\n     * @param cascadeNum cascade to retrieve the view matrix from\n     * @returns the cascade view matrix\n     */\n    getCascadeViewMatrix(cascadeNum) {\n        return cascadeNum >= 0 && cascadeNum < this._numCascades ? this._viewMatrices[cascadeNum] : null;\n    }\n    /**\n     * Gets the projection matrix corresponding to a given cascade\n     * @param cascadeNum cascade to retrieve the projection matrix from\n     * @returns the cascade projection matrix\n     */\n    getCascadeProjectionMatrix(cascadeNum) {\n        return cascadeNum >= 0 && cascadeNum < this._numCascades ? this._projectionMatrices[cascadeNum] : null;\n    }\n    /**\n     * Gets the transformation matrix corresponding to a given cascade\n     * @param cascadeNum cascade to retrieve the transformation matrix from\n     * @returns the cascade transformation matrix\n     */\n    getCascadeTransformMatrix(cascadeNum) {\n        return cascadeNum >= 0 && cascadeNum < this._numCascades ? this._transformMatrices[cascadeNum] : null;\n    }\n    /**\n     * Sets the depth renderer to use when autoCalcDepthBounds is enabled.\n     *\n     * Note that if no depth renderer is set, a new one will be automatically created internally when necessary.\n     *\n     * You should call this function if you already have a depth renderer enabled in your scene, to avoid\n     * doing multiple depth rendering each frame. If you provide your own depth renderer, make sure it stores linear depth!\n     * @param depthRenderer The depth renderer to use when autoCalcDepthBounds is enabled. If you pass null or don't call this function at all, a depth renderer will be automatically created\n     */\n    setDepthRenderer(depthRenderer) {\n        this._depthRenderer = depthRenderer;\n        if (this._depthReducer) {\n            this._depthReducer.setDepthRenderer(this._depthRenderer);\n        }\n    }\n    /**\n     * Gets or sets the autoCalcDepthBounds property.\n     *\n     * When enabled, a depth rendering pass is first performed (with an internally created depth renderer or with the one\n     * you provide by calling setDepthRenderer). Then, a min/max reducing is applied on the depth map to compute the\n     * minimal and maximal depth of the map and those values are used as inputs for the setMinMaxDistance() function.\n     * It can greatly enhance the shadow quality, at the expense of more GPU works.\n     * When using this option, you should increase the value of the lambda parameter, and even set it to 1 for best results.\n     */\n    get autoCalcDepthBounds() {\n        return this._autoCalcDepthBounds;\n    }\n    set autoCalcDepthBounds(value) {\n        const camera = this._getCamera();\n        if (!camera) {\n            return;\n        }\n        this._autoCalcDepthBounds = value;\n        if (!value) {\n            if (this._depthReducer) {\n                this._depthReducer.deactivate();\n            }\n            this.setMinMaxDistance(0, 1);\n            return;\n        }\n        if (!this._depthReducer) {\n            this._depthReducer = new DepthReducer(camera);\n            this._depthReducer.onAfterReductionPerformed.add((minmax) => {\n                let min = minmax.min, max = minmax.max;\n                if (min >= max) {\n                    min = 0;\n                    max = 1;\n                }\n                if (min != this._minDistance || max != this._maxDistance) {\n                    this.setMinMaxDistance(min, max);\n                }\n            });\n            this._depthReducer.setDepthRenderer(this._depthRenderer);\n        }\n        this._depthReducer.activate();\n    }\n    /**\n     * Defines the refresh rate of the min/max computation used when autoCalcDepthBounds is set to true\n     * Use 0 to compute just once, 1 to compute on every frame, 2 to compute every two frames and so on...\n     * Note that if you provided your own depth renderer through a call to setDepthRenderer, you are responsible\n     * for setting the refresh rate on the renderer yourself!\n     */\n    get autoCalcDepthBoundsRefreshRate() {\n        var _a, _b, _c;\n        return (_c = (_b = (_a = this._depthReducer) === null || _a === void 0 ? void 0 : _a.depthRenderer) === null || _b === void 0 ? void 0 : _b.getDepthMap().refreshRate) !== null && _c !== void 0 ? _c : -1;\n    }\n    set autoCalcDepthBoundsRefreshRate(value) {\n        var _a;\n        if ((_a = this._depthReducer) === null || _a === void 0 ? void 0 : _a.depthRenderer) {\n            this._depthReducer.depthRenderer.getDepthMap().refreshRate = value;\n        }\n    }\n    /**\n     * Create the cascade breaks according to the lambda, shadowMaxZ and min/max distance properties, as well as the camera near and far planes.\n     * This function is automatically called when updating lambda, shadowMaxZ and min/max distances, however you should call it yourself if\n     * you change the camera near/far planes!\n     */\n    splitFrustum() {\n        this._breaksAreDirty = true;\n    }\n    _splitFrustum() {\n        const camera = this._getCamera();\n        if (!camera) {\n            return;\n        }\n        const near = camera.minZ, far = camera.maxZ, cameraRange = far - near, minDistance = this._minDistance, maxDistance = this._shadowMaxZ < far && this._shadowMaxZ >= near ? Math.min((this._shadowMaxZ - near) / (far - near), this._maxDistance) : this._maxDistance;\n        const minZ = near + minDistance * cameraRange, maxZ = near + maxDistance * cameraRange;\n        const range = maxZ - minZ, ratio = maxZ / minZ;\n        for (let cascadeIndex = 0; cascadeIndex < this._cascades.length; ++cascadeIndex) {\n            const p = (cascadeIndex + 1) / this._numCascades, log = minZ * ratio ** p, uniform = minZ + range * p;\n            const d = this._lambda * (log - uniform) + uniform;\n            this._cascades[cascadeIndex].prevBreakDistance = cascadeIndex === 0 ? minDistance : this._cascades[cascadeIndex - 1].breakDistance;\n            this._cascades[cascadeIndex].breakDistance = (d - near) / cameraRange;\n            this._viewSpaceFrustumsZ[cascadeIndex] = d;\n            this._frustumLengths[cascadeIndex] = (this._cascades[cascadeIndex].breakDistance - this._cascades[cascadeIndex].prevBreakDistance) * cameraRange;\n        }\n        this._breaksAreDirty = false;\n    }\n    _computeMatrices() {\n        const scene = this._scene;\n        const camera = this._getCamera();\n        if (!camera) {\n            return;\n        }\n        Vector3.NormalizeToRef(this._light.getShadowDirection(0), this._lightDirection);\n        if (Math.abs(Vector3.Dot(this._lightDirection, Vector3.Up())) === 1.0) {\n            this._lightDirection.z = 0.0000000000001; // Required to avoid perfectly perpendicular light\n        }\n        this._cachedDirection.copyFrom(this._lightDirection);\n        const useReverseDepthBuffer = scene.getEngine().useReverseDepthBuffer;\n        for (let cascadeIndex = 0; cascadeIndex < this._numCascades; ++cascadeIndex) {\n            this._computeFrustumInWorldSpace(cascadeIndex);\n            this._computeCascadeFrustum(cascadeIndex);\n            this._cascadeMaxExtents[cascadeIndex].subtractToRef(this._cascadeMinExtents[cascadeIndex], tmpv1); // tmpv1 = cascadeExtents\n            // Get position of the shadow camera\n            this._frustumCenter[cascadeIndex].addToRef(this._lightDirection.scale(this._cascadeMinExtents[cascadeIndex].z), this._shadowCameraPos[cascadeIndex]);\n            // Come up with a new orthographic camera for the shadow caster\n            Matrix.LookAtLHToRef(this._shadowCameraPos[cascadeIndex], this._frustumCenter[cascadeIndex], UpDir, this._viewMatrices[cascadeIndex]);\n            let minZ = 0, maxZ = tmpv1.z;\n            // Try to tighten minZ and maxZ based on the bounding box of the shadow casters\n            const boundingInfo = this._shadowCastersBoundingInfo;\n            boundingInfo.update(this._viewMatrices[cascadeIndex]);\n            maxZ = Math.min(maxZ, boundingInfo.boundingBox.maximumWorld.z);\n            if (!this._depthClamp || this.filter === ShadowGenerator.FILTER_PCSS) {\n                // If we don't use depth clamping, we must set minZ so that all shadow casters are in the light frustum\n                minZ = Math.min(minZ, boundingInfo.boundingBox.minimumWorld.z);\n            }\n            else {\n                // If using depth clamping, we can adjust minZ to reduce the [minZ, maxZ] range (and get some additional precision in the shadow map)\n                minZ = Math.max(minZ, boundingInfo.boundingBox.minimumWorld.z);\n            }\n            Matrix.OrthoOffCenterLHToRef(this._cascadeMinExtents[cascadeIndex].x, this._cascadeMaxExtents[cascadeIndex].x, this._cascadeMinExtents[cascadeIndex].y, this._cascadeMaxExtents[cascadeIndex].y, useReverseDepthBuffer ? maxZ : minZ, useReverseDepthBuffer ? minZ : maxZ, this._projectionMatrices[cascadeIndex], scene.getEngine().isNDCHalfZRange);\n            this._cascadeMinExtents[cascadeIndex].z = minZ;\n            this._cascadeMaxExtents[cascadeIndex].z = maxZ;\n            this._viewMatrices[cascadeIndex].multiplyToRef(this._projectionMatrices[cascadeIndex], this._transformMatrices[cascadeIndex]);\n            // Create the rounding matrix, by projecting the world-space origin and determining\n            // the fractional offset in texel space\n            Vector3.TransformCoordinatesToRef(ZeroVec, this._transformMatrices[cascadeIndex], tmpv1); // tmpv1 = shadowOrigin\n            tmpv1.scaleInPlace(this._mapSize / 2);\n            tmpv2.copyFromFloats(Math.round(tmpv1.x), Math.round(tmpv1.y), Math.round(tmpv1.z)); // tmpv2 = roundedOrigin\n            tmpv2.subtractInPlace(tmpv1).scaleInPlace(2 / this._mapSize); // tmpv2 = roundOffset\n            Matrix.TranslationToRef(tmpv2.x, tmpv2.y, 0.0, tmpMatrix);\n            this._projectionMatrices[cascadeIndex].multiplyToRef(tmpMatrix, this._projectionMatrices[cascadeIndex]);\n            this._viewMatrices[cascadeIndex].multiplyToRef(this._projectionMatrices[cascadeIndex], this._transformMatrices[cascadeIndex]);\n            this._transformMatrices[cascadeIndex].copyToArray(this._transformMatricesAsArray, cascadeIndex * 16);\n        }\n    }\n    // Get the 8 points of the view frustum in world space\n    _computeFrustumInWorldSpace(cascadeIndex) {\n        const camera = this._getCamera();\n        if (!camera) {\n            return;\n        }\n        const prevSplitDist = this._cascades[cascadeIndex].prevBreakDistance, splitDist = this._cascades[cascadeIndex].breakDistance;\n        const isNDCHalfZRange = this._scene.getEngine().isNDCHalfZRange;\n        camera.getViewMatrix(); // make sure the transformation matrix we get when calling 'getTransformationMatrix()' is calculated with an up to date view matrix\n        const invViewProj = Matrix.Invert(camera.getTransformationMatrix());\n        const cornerIndexOffset = this._scene.getEngine().useReverseDepthBuffer ? 4 : 0;\n        for (let cornerIndex = 0; cornerIndex < CascadedShadowGenerator._FrustumCornersNDCSpace.length; ++cornerIndex) {\n            tmpv1.copyFrom(CascadedShadowGenerator._FrustumCornersNDCSpace[(cornerIndex + cornerIndexOffset) % CascadedShadowGenerator._FrustumCornersNDCSpace.length]);\n            if (isNDCHalfZRange && tmpv1.z === -1) {\n                tmpv1.z = 0;\n            }\n            Vector3.TransformCoordinatesToRef(tmpv1, invViewProj, this._frustumCornersWorldSpace[cascadeIndex][cornerIndex]);\n        }\n        // Get the corners of the current cascade slice of the view frustum\n        for (let cornerIndex = 0; cornerIndex < CascadedShadowGenerator._FrustumCornersNDCSpace.length / 2; ++cornerIndex) {\n            tmpv1.copyFrom(this._frustumCornersWorldSpace[cascadeIndex][cornerIndex + 4]).subtractInPlace(this._frustumCornersWorldSpace[cascadeIndex][cornerIndex]);\n            tmpv2.copyFrom(tmpv1).scaleInPlace(prevSplitDist); // near corner ray\n            tmpv1.scaleInPlace(splitDist); // far corner ray\n            tmpv1.addInPlace(this._frustumCornersWorldSpace[cascadeIndex][cornerIndex]);\n            this._frustumCornersWorldSpace[cascadeIndex][cornerIndex + 4].copyFrom(tmpv1);\n            this._frustumCornersWorldSpace[cascadeIndex][cornerIndex].addInPlace(tmpv2);\n        }\n    }\n    _computeCascadeFrustum(cascadeIndex) {\n        this._cascadeMinExtents[cascadeIndex].copyFromFloats(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\n        this._cascadeMaxExtents[cascadeIndex].copyFromFloats(Number.MIN_VALUE, Number.MIN_VALUE, Number.MIN_VALUE);\n        this._frustumCenter[cascadeIndex].copyFromFloats(0, 0, 0);\n        const camera = this._getCamera();\n        if (!camera) {\n            return;\n        }\n        // Calculate the centroid of the view frustum slice\n        for (let cornerIndex = 0; cornerIndex < this._frustumCornersWorldSpace[cascadeIndex].length; ++cornerIndex) {\n            this._frustumCenter[cascadeIndex].addInPlace(this._frustumCornersWorldSpace[cascadeIndex][cornerIndex]);\n        }\n        this._frustumCenter[cascadeIndex].scaleInPlace(1 / this._frustumCornersWorldSpace[cascadeIndex].length);\n        if (this.stabilizeCascades) {\n            // Calculate the radius of a bounding sphere surrounding the frustum corners\n            let sphereRadius = 0;\n            for (let cornerIndex = 0; cornerIndex < this._frustumCornersWorldSpace[cascadeIndex].length; ++cornerIndex) {\n                const dist = this._frustumCornersWorldSpace[cascadeIndex][cornerIndex].subtractToRef(this._frustumCenter[cascadeIndex], tmpv1).length();\n                sphereRadius = Math.max(sphereRadius, dist);\n            }\n            sphereRadius = Math.ceil(sphereRadius * 16) / 16;\n            this._cascadeMaxExtents[cascadeIndex].copyFromFloats(sphereRadius, sphereRadius, sphereRadius);\n            this._cascadeMinExtents[cascadeIndex].copyFromFloats(-sphereRadius, -sphereRadius, -sphereRadius);\n        }\n        else {\n            // Create a temporary view matrix for the light\n            const lightCameraPos = this._frustumCenter[cascadeIndex];\n            this._frustumCenter[cascadeIndex].addToRef(this._lightDirection, tmpv1); // tmpv1 = look at\n            Matrix.LookAtLHToRef(lightCameraPos, tmpv1, UpDir, tmpMatrix); // matrix = lightView\n            // Calculate an AABB around the frustum corners\n            for (let cornerIndex = 0; cornerIndex < this._frustumCornersWorldSpace[cascadeIndex].length; ++cornerIndex) {\n                Vector3.TransformCoordinatesToRef(this._frustumCornersWorldSpace[cascadeIndex][cornerIndex], tmpMatrix, tmpv1);\n                this._cascadeMinExtents[cascadeIndex].minimizeInPlace(tmpv1);\n                this._cascadeMaxExtents[cascadeIndex].maximizeInPlace(tmpv1);\n            }\n        }\n    }\n    _recreateSceneUBOs() {\n        this._disposeSceneUBOs();\n        if (this._sceneUBOs) {\n            for (let i = 0; i < this._numCascades; ++i) {\n                this._sceneUBOs.push(this._scene.createSceneUniformBuffer(`Scene for CSM Shadow Generator (light \"${this._light.name}\" cascade #${i})`));\n            }\n        }\n    }\n    /**\n     *  Support test.\n     */\n    static get IsSupported() {\n        const engine = EngineStore.LastCreatedEngine;\n        if (!engine) {\n            return false;\n        }\n        return engine._features.supportCSM;\n    }\n    /**\n     * Creates a Cascaded Shadow Generator object.\n     * A ShadowGenerator is the required tool to use the shadows.\n     * Each directional light casting shadows needs to use its own ShadowGenerator.\n     * Documentation : https://doc.babylonjs.com/babylon101/cascadedShadows\n     * @param mapSize The size of the texture what stores the shadows. Example : 1024.\n     * @param light The directional light object generating the shadows.\n     * @param usefulFloatFirst By default the generator will try to use half float textures but if you need precision (for self shadowing for instance), you can use this option to enforce full float texture.\n     * @param camera Camera associated with this shadow generator (default: null). If null, takes the scene active camera at the time we need to access it\n     */\n    constructor(mapSize, light, usefulFloatFirst, camera) {\n        if (!CascadedShadowGenerator.IsSupported) {\n            Logger.Error(\"CascadedShadowMap is not supported by the current engine.\");\n            return;\n        }\n        super(mapSize, light, usefulFloatFirst, camera);\n        this.usePercentageCloserFiltering = true;\n    }\n    _initializeGenerator() {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v;\n        this.penumbraDarkness = (_a = this.penumbraDarkness) !== null && _a !== void 0 ? _a : 1.0;\n        this._numCascades = (_b = this._numCascades) !== null && _b !== void 0 ? _b : CascadedShadowGenerator.DEFAULT_CASCADES_COUNT;\n        this.stabilizeCascades = (_c = this.stabilizeCascades) !== null && _c !== void 0 ? _c : false;\n        this._freezeShadowCastersBoundingInfoObservable = (_d = this._freezeShadowCastersBoundingInfoObservable) !== null && _d !== void 0 ? _d : null;\n        this.freezeShadowCastersBoundingInfo = (_e = this.freezeShadowCastersBoundingInfo) !== null && _e !== void 0 ? _e : false;\n        this._scbiMin = (_f = this._scbiMin) !== null && _f !== void 0 ? _f : new Vector3(0, 0, 0);\n        this._scbiMax = (_g = this._scbiMax) !== null && _g !== void 0 ? _g : new Vector3(0, 0, 0);\n        this._shadowCastersBoundingInfo = (_h = this._shadowCastersBoundingInfo) !== null && _h !== void 0 ? _h : new BoundingInfo(new Vector3(0, 0, 0), new Vector3(0, 0, 0));\n        this._breaksAreDirty = (_j = this._breaksAreDirty) !== null && _j !== void 0 ? _j : true;\n        this._minDistance = (_k = this._minDistance) !== null && _k !== void 0 ? _k : 0;\n        this._maxDistance = (_l = this._maxDistance) !== null && _l !== void 0 ? _l : 1;\n        this._currentLayer = (_m = this._currentLayer) !== null && _m !== void 0 ? _m : 0;\n        this._shadowMaxZ = (_q = (_o = this._shadowMaxZ) !== null && _o !== void 0 ? _o : (_p = this._getCamera()) === null || _p === void 0 ? void 0 : _p.maxZ) !== null && _q !== void 0 ? _q : 10000;\n        this._debug = (_r = this._debug) !== null && _r !== void 0 ? _r : false;\n        this._depthClamp = (_s = this._depthClamp) !== null && _s !== void 0 ? _s : true;\n        this._cascadeBlendPercentage = (_t = this._cascadeBlendPercentage) !== null && _t !== void 0 ? _t : 0.1;\n        this._lambda = (_u = this._lambda) !== null && _u !== void 0 ? _u : 0.5;\n        this._autoCalcDepthBounds = (_v = this._autoCalcDepthBounds) !== null && _v !== void 0 ? _v : false;\n        this._recreateSceneUBOs();\n        super._initializeGenerator();\n    }\n    _createTargetRenderTexture() {\n        const engine = this._scene.getEngine();\n        const size = { width: this._mapSize, height: this._mapSize, layers: this.numCascades };\n        this._shadowMap = new RenderTargetTexture(this._light.name + \"_CSMShadowMap\", size, this._scene, false, true, this._textureType, false, undefined, false, false, undefined /*, 6*/);\n        this._shadowMap.createDepthStencilTexture(engine.useReverseDepthBuffer ? 516 : 513, true);\n    }\n    _initializeShadowMap() {\n        super._initializeShadowMap();\n        if (this._shadowMap === null) {\n            return;\n        }\n        this._transformMatricesAsArray = new Float32Array(this._numCascades * 16);\n        this._viewSpaceFrustumsZ = new Array(this._numCascades);\n        this._frustumLengths = new Array(this._numCascades);\n        this._lightSizeUVCorrection = new Array(this._numCascades * 2);\n        this._depthCorrection = new Array(this._numCascades);\n        this._cascades = [];\n        this._viewMatrices = [];\n        this._projectionMatrices = [];\n        this._transformMatrices = [];\n        this._cascadeMinExtents = [];\n        this._cascadeMaxExtents = [];\n        this._frustumCenter = [];\n        this._shadowCameraPos = [];\n        this._frustumCornersWorldSpace = [];\n        for (let cascadeIndex = 0; cascadeIndex < this._numCascades; ++cascadeIndex) {\n            this._cascades[cascadeIndex] = {\n                prevBreakDistance: 0,\n                breakDistance: 0,\n            };\n            this._viewMatrices[cascadeIndex] = Matrix.Zero();\n            this._projectionMatrices[cascadeIndex] = Matrix.Zero();\n            this._transformMatrices[cascadeIndex] = Matrix.Zero();\n            this._cascadeMinExtents[cascadeIndex] = new Vector3();\n            this._cascadeMaxExtents[cascadeIndex] = new Vector3();\n            this._frustumCenter[cascadeIndex] = new Vector3();\n            this._shadowCameraPos[cascadeIndex] = new Vector3();\n            this._frustumCornersWorldSpace[cascadeIndex] = new Array(CascadedShadowGenerator._FrustumCornersNDCSpace.length);\n            for (let i = 0; i < CascadedShadowGenerator._FrustumCornersNDCSpace.length; ++i) {\n                this._frustumCornersWorldSpace[cascadeIndex][i] = new Vector3();\n            }\n        }\n        const engine = this._scene.getEngine();\n        this._shadowMap.onBeforeBindObservable.clear();\n        this._shadowMap.onBeforeRenderObservable.clear();\n        this._shadowMap.onBeforeRenderObservable.add((layer) => {\n            if (this._sceneUBOs) {\n                this._scene.setSceneUniformBuffer(this._sceneUBOs[layer]);\n            }\n            this._currentLayer = layer;\n            if (this._filter === ShadowGenerator.FILTER_PCF) {\n                engine.setColorWrite(false);\n            }\n            this._scene.setTransformMatrix(this.getCascadeViewMatrix(layer), this.getCascadeProjectionMatrix(layer));\n            if (this._useUBO) {\n                this._scene.getSceneUniformBuffer().unbindEffect();\n                this._scene.finalizeSceneUbo();\n            }\n        });\n        this._shadowMap.onBeforeBindObservable.add(() => {\n            var _a;\n            this._currentSceneUBO = this._scene.getSceneUniformBuffer();\n            (_a = engine._debugPushGroup) === null || _a === void 0 ? void 0 : _a.call(engine, `cascaded shadow map generation for pass id ${engine.currentRenderPassId}`, 1);\n            if (this._breaksAreDirty) {\n                this._splitFrustum();\n            }\n            this._computeMatrices();\n        });\n        this._splitFrustum();\n    }\n    _bindCustomEffectForRenderSubMeshForShadowMap(subMesh, effect) {\n        effect.setMatrix(\"viewProjection\", this.getCascadeTransformMatrix(this._currentLayer));\n    }\n    _isReadyCustomDefines(defines) {\n        defines.push(\"#define SM_DEPTHCLAMP \" + (this._depthClamp && this._filter !== ShadowGenerator.FILTER_PCSS ? \"1\" : \"0\"));\n    }\n    /**\n     * Prepare all the defines in a material relying on a shadow map at the specified light index.\n     * @param defines Defines of the material we want to update\n     * @param lightIndex Index of the light in the enabled light list of the material\n     */\n    prepareDefines(defines, lightIndex) {\n        super.prepareDefines(defines, lightIndex);\n        const scene = this._scene;\n        const light = this._light;\n        if (!scene.shadowsEnabled || !light.shadowEnabled) {\n            return;\n        }\n        defines[\"SHADOWCSM\" + lightIndex] = true;\n        defines[\"SHADOWCSMDEBUG\" + lightIndex] = this.debug;\n        defines[\"SHADOWCSMNUM_CASCADES\" + lightIndex] = this.numCascades;\n        defines[\"SHADOWCSM_RIGHTHANDED\" + lightIndex] = scene.useRightHandedSystem;\n        const camera = this._getCamera();\n        if (camera && this._shadowMaxZ < camera.maxZ) {\n            defines[\"SHADOWCSMUSESHADOWMAXZ\" + lightIndex] = true;\n        }\n        if (this.cascadeBlendPercentage === 0) {\n            defines[\"SHADOWCSMNOBLEND\" + lightIndex] = true;\n        }\n    }\n    /**\n     * Binds the shadow related information inside of an effect (information like near, far, darkness...\n     * defined in the generator but impacting the effect).\n     * @param lightIndex Index of the light in the enabled light list of the material owning the effect\n     * @param effect The effect we are binfing the information for\n     */\n    bindShadowLight(lightIndex, effect) {\n        const light = this._light;\n        const scene = this._scene;\n        if (!scene.shadowsEnabled || !light.shadowEnabled) {\n            return;\n        }\n        const camera = this._getCamera();\n        if (!camera) {\n            return;\n        }\n        const shadowMap = this.getShadowMap();\n        if (!shadowMap) {\n            return;\n        }\n        const width = shadowMap.getSize().width;\n        effect.setMatrices(\"lightMatrix\" + lightIndex, this._transformMatricesAsArray);\n        effect.setArray(\"viewFrustumZ\" + lightIndex, this._viewSpaceFrustumsZ);\n        effect.setFloat(\"cascadeBlendFactor\" + lightIndex, this.cascadeBlendPercentage === 0 ? 10000 : 1 / this.cascadeBlendPercentage);\n        effect.setArray(\"frustumLengths\" + lightIndex, this._frustumLengths);\n        // Only PCF uses depth stencil texture.\n        if (this._filter === ShadowGenerator.FILTER_PCF) {\n            effect.setDepthStencilTexture(\"shadowSampler\" + lightIndex, shadowMap);\n            light._uniformBuffer.updateFloat4(\"shadowsInfo\", this.getDarkness(), width, 1 / width, this.frustumEdgeFalloff, lightIndex);\n        }\n        else if (this._filter === ShadowGenerator.FILTER_PCSS) {\n            for (let cascadeIndex = 0; cascadeIndex < this._numCascades; ++cascadeIndex) {\n                this._lightSizeUVCorrection[cascadeIndex * 2 + 0] =\n                    cascadeIndex === 0\n                        ? 1\n                        : (this._cascadeMaxExtents[0].x - this._cascadeMinExtents[0].x) / (this._cascadeMaxExtents[cascadeIndex].x - this._cascadeMinExtents[cascadeIndex].x); // x correction\n                this._lightSizeUVCorrection[cascadeIndex * 2 + 1] =\n                    cascadeIndex === 0\n                        ? 1\n                        : (this._cascadeMaxExtents[0].y - this._cascadeMinExtents[0].y) / (this._cascadeMaxExtents[cascadeIndex].y - this._cascadeMinExtents[cascadeIndex].y); // y correction\n                this._depthCorrection[cascadeIndex] =\n                    cascadeIndex === 0\n                        ? 1\n                        : (this._cascadeMaxExtents[cascadeIndex].z - this._cascadeMinExtents[cascadeIndex].z) / (this._cascadeMaxExtents[0].z - this._cascadeMinExtents[0].z);\n            }\n            effect.setDepthStencilTexture(\"shadowSampler\" + lightIndex, shadowMap);\n            effect.setTexture(\"depthSampler\" + lightIndex, shadowMap);\n            effect.setArray2(\"lightSizeUVCorrection\" + lightIndex, this._lightSizeUVCorrection);\n            effect.setArray(\"depthCorrection\" + lightIndex, this._depthCorrection);\n            effect.setFloat(\"penumbraDarkness\" + lightIndex, this.penumbraDarkness);\n            light._uniformBuffer.updateFloat4(\"shadowsInfo\", this.getDarkness(), 1 / width, this._contactHardeningLightSizeUVRatio * width, this.frustumEdgeFalloff, lightIndex);\n        }\n        else {\n            effect.setTexture(\"shadowSampler\" + lightIndex, shadowMap);\n            light._uniformBuffer.updateFloat4(\"shadowsInfo\", this.getDarkness(), width, 1 / width, this.frustumEdgeFalloff, lightIndex);\n        }\n        light._uniformBuffer.updateFloat2(\"depthValues\", this.getLight().getDepthMinZ(camera), this.getLight().getDepthMinZ(camera) + this.getLight().getDepthMaxZ(camera), lightIndex);\n    }\n    /**\n     * Gets the transformation matrix of the first cascade used to project the meshes into the map from the light point of view.\n     * (eq to view projection * shadow projection matrices)\n     * @returns The transform matrix used to create the shadow map\n     */\n    getTransformMatrix() {\n        return this.getCascadeTransformMatrix(0);\n    }\n    /**\n     * Disposes the ShadowGenerator.\n     * Returns nothing.\n     */\n    dispose() {\n        super.dispose();\n        if (this._freezeShadowCastersBoundingInfoObservable) {\n            this._scene.onBeforeRenderObservable.remove(this._freezeShadowCastersBoundingInfoObservable);\n            this._freezeShadowCastersBoundingInfoObservable = null;\n        }\n        if (this._depthReducer) {\n            this._depthReducer.dispose();\n            this._depthReducer = null;\n        }\n    }\n    /**\n     * Serializes the shadow generator setup to a json object.\n     * @returns The serialized JSON object\n     */\n    serialize() {\n        const serializationObject = super.serialize();\n        const shadowMap = this.getShadowMap();\n        if (!shadowMap) {\n            return serializationObject;\n        }\n        serializationObject.numCascades = this._numCascades;\n        serializationObject.debug = this._debug;\n        serializationObject.stabilizeCascades = this.stabilizeCascades;\n        serializationObject.lambda = this._lambda;\n        serializationObject.cascadeBlendPercentage = this.cascadeBlendPercentage;\n        serializationObject.depthClamp = this._depthClamp;\n        serializationObject.autoCalcDepthBounds = this.autoCalcDepthBounds;\n        serializationObject.shadowMaxZ = this._shadowMaxZ;\n        serializationObject.penumbraDarkness = this.penumbraDarkness;\n        serializationObject.freezeShadowCastersBoundingInfo = this._freezeShadowCastersBoundingInfo;\n        serializationObject.minDistance = this.minDistance;\n        serializationObject.maxDistance = this.maxDistance;\n        serializationObject.renderList = [];\n        if (shadowMap.renderList) {\n            for (let meshIndex = 0; meshIndex < shadowMap.renderList.length; meshIndex++) {\n                const mesh = shadowMap.renderList[meshIndex];\n                serializationObject.renderList.push(mesh.id);\n            }\n        }\n        return serializationObject;\n    }\n    /**\n     * Parses a serialized ShadowGenerator and returns a new ShadowGenerator.\n     * @param parsedShadowGenerator The JSON object to parse\n     * @param scene The scene to create the shadow map for\n     * @returns The parsed shadow generator\n     */\n    static Parse(parsedShadowGenerator, scene) {\n        const shadowGenerator = ShadowGenerator.Parse(parsedShadowGenerator, scene, (mapSize, light, camera) => new CascadedShadowGenerator(mapSize, light, undefined, camera));\n        if (parsedShadowGenerator.numCascades !== undefined) {\n            shadowGenerator.numCascades = parsedShadowGenerator.numCascades;\n        }\n        if (parsedShadowGenerator.debug !== undefined) {\n            shadowGenerator.debug = parsedShadowGenerator.debug;\n        }\n        if (parsedShadowGenerator.stabilizeCascades !== undefined) {\n            shadowGenerator.stabilizeCascades = parsedShadowGenerator.stabilizeCascades;\n        }\n        if (parsedShadowGenerator.lambda !== undefined) {\n            shadowGenerator.lambda = parsedShadowGenerator.lambda;\n        }\n        if (parsedShadowGenerator.cascadeBlendPercentage !== undefined) {\n            shadowGenerator.cascadeBlendPercentage = parsedShadowGenerator.cascadeBlendPercentage;\n        }\n        if (parsedShadowGenerator.depthClamp !== undefined) {\n            shadowGenerator.depthClamp = parsedShadowGenerator.depthClamp;\n        }\n        if (parsedShadowGenerator.autoCalcDepthBounds !== undefined) {\n            shadowGenerator.autoCalcDepthBounds = parsedShadowGenerator.autoCalcDepthBounds;\n        }\n        if (parsedShadowGenerator.shadowMaxZ !== undefined) {\n            shadowGenerator.shadowMaxZ = parsedShadowGenerator.shadowMaxZ;\n        }\n        if (parsedShadowGenerator.penumbraDarkness !== undefined) {\n            shadowGenerator.penumbraDarkness = parsedShadowGenerator.penumbraDarkness;\n        }\n        if (parsedShadowGenerator.freezeShadowCastersBoundingInfo !== undefined) {\n            shadowGenerator.freezeShadowCastersBoundingInfo = parsedShadowGenerator.freezeShadowCastersBoundingInfo;\n        }\n        if (parsedShadowGenerator.minDistance !== undefined && parsedShadowGenerator.maxDistance !== undefined) {\n            shadowGenerator.setMinMaxDistance(parsedShadowGenerator.minDistance, parsedShadowGenerator.maxDistance);\n        }\n        return shadowGenerator;\n    }\n}\nCascadedShadowGenerator._FrustumCornersNDCSpace = [\n    new Vector3(-1.0, +1.0, -1.0),\n    new Vector3(+1.0, +1.0, -1.0),\n    new Vector3(+1.0, -1.0, -1.0),\n    new Vector3(-1.0, -1.0, -1.0),\n    new Vector3(-1.0, +1.0, +1.0),\n    new Vector3(+1.0, +1.0, +1.0),\n    new Vector3(+1.0, -1.0, +1.0),\n    new Vector3(-1.0, -1.0, +1.0),\n];\n/**\n * Name of the CSM class\n */\nCascadedShadowGenerator.CLASSNAME = \"CascadedShadowGenerator\";\n/**\n * Defines the default number of cascades used by the CSM.\n */\nCascadedShadowGenerator.DEFAULT_CASCADES_COUNT = 4;\n/**\n * Defines the minimum number of cascades used by the CSM.\n */\nCascadedShadowGenerator.MIN_CASCADES_COUNT = 2;\n/**\n * Defines the maximum number of cascades used by the CSM.\n */\nCascadedShadowGenerator.MAX_CASCADES_COUNT = 4;\n/**\n * @internal\n */\nCascadedShadowGenerator._SceneComponentInitialization = (_) => {\n    throw _WarnImport(\"ShadowGeneratorSceneComponent\");\n};\n//# sourceMappingURL=cascadedShadowGenerator.js.map","import { ShadowGenerator } from \"./shadowGenerator.js\";\nimport { CascadedShadowGenerator } from \"./cascadedShadowGenerator.js\";\nimport { SceneComponentConstants } from \"../../sceneComponent.js\";\nimport { AbstractScene } from \"../../abstractScene.js\";\n// Adds the parser to the scene parsers.\nAbstractScene.AddParser(SceneComponentConstants.NAME_SHADOWGENERATOR, (parsedData, scene) => {\n    // Shadows\n    if (parsedData.shadowGenerators !== undefined && parsedData.shadowGenerators !== null) {\n        for (let index = 0, cache = parsedData.shadowGenerators.length; index < cache; index++) {\n            const parsedShadowGenerator = parsedData.shadowGenerators[index];\n            if (parsedShadowGenerator.className === CascadedShadowGenerator.CLASSNAME) {\n                CascadedShadowGenerator.Parse(parsedShadowGenerator, scene);\n            }\n            else {\n                ShadowGenerator.Parse(parsedShadowGenerator, scene);\n            }\n            // SG would be available on their associated lights\n        }\n    }\n});\n/**\n * Defines the shadow generator component responsible to manage any shadow generators\n * in a given scene.\n */\nexport class ShadowGeneratorSceneComponent {\n    /**\n     * Creates a new instance of the component for the given scene\n     * @param scene Defines the scene to register the component in\n     */\n    constructor(scene) {\n        /**\n         * The component name helpful to identify the component in the list of scene components.\n         */\n        this.name = SceneComponentConstants.NAME_SHADOWGENERATOR;\n        this.scene = scene;\n    }\n    /**\n     * Registers the component in a given scene\n     */\n    register() {\n        this.scene._gatherRenderTargetsStage.registerStep(SceneComponentConstants.STEP_GATHERRENDERTARGETS_SHADOWGENERATOR, this, this._gatherRenderTargets);\n    }\n    /**\n     * Rebuilds the elements related to this component in case of\n     * context lost for instance.\n     */\n    rebuild() {\n        // Nothing To Do Here.\n    }\n    /**\n     * Serializes the component data to the specified json object\n     * @param serializationObject The object to serialize to\n     */\n    serialize(serializationObject) {\n        // Shadows\n        serializationObject.shadowGenerators = [];\n        const lights = this.scene.lights;\n        for (const light of lights) {\n            const shadowGenerators = light.getShadowGenerators();\n            if (shadowGenerators) {\n                const iterator = shadowGenerators.values();\n                for (let key = iterator.next(); key.done !== true; key = iterator.next()) {\n                    const shadowGenerator = key.value;\n                    serializationObject.shadowGenerators.push(shadowGenerator.serialize());\n                }\n            }\n        }\n    }\n    /**\n     * Adds all the elements from the container to the scene\n     * @param container the container holding the elements\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    addFromContainer(container) {\n        // Nothing To Do Here. (directly attached to a light)\n    }\n    /**\n     * Removes all the elements in the container from the scene\n     * @param container contains the elements to remove\n     * @param dispose if the removed element should be disposed (default: false)\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    removeFromContainer(container, dispose) {\n        // Nothing To Do Here. (directly attached to a light)\n    }\n    /**\n     * Rebuilds the elements related to this component in case of\n     * context lost for instance.\n     */\n    dispose() {\n        // Nothing To Do Here.\n    }\n    _gatherRenderTargets(renderTargets) {\n        // Shadows\n        const scene = this.scene;\n        if (this.scene.shadowsEnabled) {\n            for (let lightIndex = 0; lightIndex < scene.lights.length; lightIndex++) {\n                const light = scene.lights[lightIndex];\n                const shadowGenerators = light.getShadowGenerators();\n                if (light.isEnabled() && light.shadowEnabled && shadowGenerators) {\n                    const iterator = shadowGenerators.values();\n                    for (let key = iterator.next(); key.done !== true; key = iterator.next()) {\n                        const shadowGenerator = key.value;\n                        const shadowMap = shadowGenerator.getShadowMap();\n                        if (scene.textures.indexOf(shadowMap) !== -1) {\n                            renderTargets.push(shadowMap);\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\nShadowGenerator._SceneComponentInitialization = (scene) => {\n    let component = scene._getComponent(SceneComponentConstants.NAME_SHADOWGENERATOR);\n    if (!component) {\n        component = new ShadowGeneratorSceneComponent(scene);\n        scene._addComponent(component);\n    }\n};\n//# sourceMappingURL=shadowGeneratorSceneComponent.js.map","import { Matrix, Vector3, Vector2 } from \"../../Maths/math.vector.js\";\nimport { Color4 } from \"../../Maths/math.color.js\";\nimport { VertexBuffer } from \"../../Buffers/buffer.js\";\nimport { Light } from \"../../Lights/light.js\";\nimport { MaterialHelper } from \"../../Materials/materialHelper.js\";\nimport { Texture } from \"../../Materials/Textures/texture.js\";\nimport { RenderTargetTexture } from \"../../Materials/Textures/renderTargetTexture.js\";\nimport { PostProcess } from \"../../PostProcesses/postProcess.js\";\nimport { BlurPostProcess } from \"../../PostProcesses/blurPostProcess.js\";\n\nimport { Observable } from \"../../Misc/observable.js\";\nimport { _WarnImport } from \"../../Misc/devTools.js\";\nimport { EffectFallbacks } from \"../../Materials/effectFallbacks.js\";\nimport { RenderingManager } from \"../../Rendering/renderingManager.js\";\nimport { DrawWrapper } from \"../../Materials/drawWrapper.js\";\nimport \"../../Shaders/shadowMap.fragment.js\";\nimport \"../../Shaders/shadowMap.vertex.js\";\nimport \"../../Shaders/depthBoxBlur.fragment.js\";\nimport \"../../Shaders/ShadersInclude/shadowMapFragmentSoftTransparentShadow.js\";\nimport { addClipPlaneUniforms, bindClipPlane, prepareDefinesForClipPlanes } from \"../../Materials/clipPlaneMaterialHelper.js\";\n/**\n * Default implementation IShadowGenerator.\n * This is the main object responsible of generating shadows in the framework.\n * Documentation: https://doc.babylonjs.com/features/featuresDeepDive/lights/shadows\n */\nexport class ShadowGenerator {\n    /**\n     * Gets the bias: offset applied on the depth preventing acnea (in light direction).\n     */\n    get bias() {\n        return this._bias;\n    }\n    /**\n     * Sets the bias: offset applied on the depth preventing acnea (in light direction).\n     */\n    set bias(bias) {\n        this._bias = bias;\n    }\n    /**\n     * Gets the normalBias: offset applied on the depth preventing acnea (along side the normal direction and proportional to the light/normal angle).\n     */\n    get normalBias() {\n        return this._normalBias;\n    }\n    /**\n     * Sets the normalBias: offset applied on the depth preventing acnea (along side the normal direction and proportional to the light/normal angle).\n     */\n    set normalBias(normalBias) {\n        this._normalBias = normalBias;\n    }\n    /**\n     * Gets the blur box offset: offset applied during the blur pass.\n     * Only useful if useKernelBlur = false\n     */\n    get blurBoxOffset() {\n        return this._blurBoxOffset;\n    }\n    /**\n     * Sets the blur box offset: offset applied during the blur pass.\n     * Only useful if useKernelBlur = false\n     */\n    set blurBoxOffset(value) {\n        if (this._blurBoxOffset === value) {\n            return;\n        }\n        this._blurBoxOffset = value;\n        this._disposeBlurPostProcesses();\n    }\n    /**\n     * Gets the blur scale: scale of the blurred texture compared to the main shadow map.\n     * 2 means half of the size.\n     */\n    get blurScale() {\n        return this._blurScale;\n    }\n    /**\n     * Sets the blur scale: scale of the blurred texture compared to the main shadow map.\n     * 2 means half of the size.\n     */\n    set blurScale(value) {\n        if (this._blurScale === value) {\n            return;\n        }\n        this._blurScale = value;\n        this._disposeBlurPostProcesses();\n    }\n    /**\n     * Gets the blur kernel: kernel size of the blur pass.\n     * Only useful if useKernelBlur = true\n     */\n    get blurKernel() {\n        return this._blurKernel;\n    }\n    /**\n     * Sets the blur kernel: kernel size of the blur pass.\n     * Only useful if useKernelBlur = true\n     */\n    set blurKernel(value) {\n        if (this._blurKernel === value) {\n            return;\n        }\n        this._blurKernel = value;\n        this._disposeBlurPostProcesses();\n    }\n    /**\n     * Gets whether the blur pass is a kernel blur (if true) or box blur.\n     * Only useful in filtered mode (useBlurExponentialShadowMap...)\n     */\n    get useKernelBlur() {\n        return this._useKernelBlur;\n    }\n    /**\n     * Sets whether the blur pass is a kernel blur (if true) or box blur.\n     * Only useful in filtered mode (useBlurExponentialShadowMap...)\n     */\n    set useKernelBlur(value) {\n        if (this._useKernelBlur === value) {\n            return;\n        }\n        this._useKernelBlur = value;\n        this._disposeBlurPostProcesses();\n    }\n    /**\n     * Gets the depth scale used in ESM mode.\n     */\n    get depthScale() {\n        return this._depthScale !== undefined ? this._depthScale : this._light.getDepthScale();\n    }\n    /**\n     * Sets the depth scale used in ESM mode.\n     * This can override the scale stored on the light.\n     */\n    set depthScale(value) {\n        this._depthScale = value;\n    }\n    _validateFilter(filter) {\n        return filter;\n    }\n    /**\n     * Gets the current mode of the shadow generator (normal, PCF, ESM...).\n     * The returned value is a number equal to one of the available mode defined in ShadowMap.FILTER_x like _FILTER_NONE\n     */\n    get filter() {\n        return this._filter;\n    }\n    /**\n     * Sets the current mode of the shadow generator (normal, PCF, ESM...).\n     * The returned value is a number equal to one of the available mode defined in ShadowMap.FILTER_x like _FILTER_NONE\n     */\n    set filter(value) {\n        value = this._validateFilter(value);\n        // Blurring the cubemap is going to be too expensive. Reverting to unblurred version\n        if (this._light.needCube()) {\n            if (value === ShadowGenerator.FILTER_BLUREXPONENTIALSHADOWMAP) {\n                this.useExponentialShadowMap = true;\n                return;\n            }\n            else if (value === ShadowGenerator.FILTER_BLURCLOSEEXPONENTIALSHADOWMAP) {\n                this.useCloseExponentialShadowMap = true;\n                return;\n            }\n            // PCF on cubemap would also be expensive\n            else if (value === ShadowGenerator.FILTER_PCF || value === ShadowGenerator.FILTER_PCSS) {\n                this.usePoissonSampling = true;\n                return;\n            }\n        }\n        // Weblg1 fallback for PCF.\n        if (value === ShadowGenerator.FILTER_PCF || value === ShadowGenerator.FILTER_PCSS) {\n            if (!this._scene.getEngine()._features.supportShadowSamplers) {\n                this.usePoissonSampling = true;\n                return;\n            }\n        }\n        if (this._filter === value) {\n            return;\n        }\n        this._filter = value;\n        this._disposeBlurPostProcesses();\n        this._applyFilterValues();\n        this._light._markMeshesAsLightDirty();\n    }\n    /**\n     * Gets if the current filter is set to Poisson Sampling.\n     */\n    get usePoissonSampling() {\n        return this.filter === ShadowGenerator.FILTER_POISSONSAMPLING;\n    }\n    /**\n     * Sets the current filter to Poisson Sampling.\n     */\n    set usePoissonSampling(value) {\n        const filter = this._validateFilter(ShadowGenerator.FILTER_POISSONSAMPLING);\n        if (!value && this.filter !== ShadowGenerator.FILTER_POISSONSAMPLING) {\n            return;\n        }\n        this.filter = value ? filter : ShadowGenerator.FILTER_NONE;\n    }\n    /**\n     * Gets if the current filter is set to ESM.\n     */\n    get useExponentialShadowMap() {\n        return this.filter === ShadowGenerator.FILTER_EXPONENTIALSHADOWMAP;\n    }\n    /**\n     * Sets the current filter is to ESM.\n     */\n    set useExponentialShadowMap(value) {\n        const filter = this._validateFilter(ShadowGenerator.FILTER_EXPONENTIALSHADOWMAP);\n        if (!value && this.filter !== ShadowGenerator.FILTER_EXPONENTIALSHADOWMAP) {\n            return;\n        }\n        this.filter = value ? filter : ShadowGenerator.FILTER_NONE;\n    }\n    /**\n     * Gets if the current filter is set to filtered ESM.\n     */\n    get useBlurExponentialShadowMap() {\n        return this.filter === ShadowGenerator.FILTER_BLUREXPONENTIALSHADOWMAP;\n    }\n    /**\n     * Gets if the current filter is set to filtered  ESM.\n     */\n    set useBlurExponentialShadowMap(value) {\n        const filter = this._validateFilter(ShadowGenerator.FILTER_BLUREXPONENTIALSHADOWMAP);\n        if (!value && this.filter !== ShadowGenerator.FILTER_BLUREXPONENTIALSHADOWMAP) {\n            return;\n        }\n        this.filter = value ? filter : ShadowGenerator.FILTER_NONE;\n    }\n    /**\n     * Gets if the current filter is set to \"close ESM\" (using the inverse of the\n     * exponential to prevent steep falloff artifacts).\n     */\n    get useCloseExponentialShadowMap() {\n        return this.filter === ShadowGenerator.FILTER_CLOSEEXPONENTIALSHADOWMAP;\n    }\n    /**\n     * Sets the current filter to \"close ESM\" (using the inverse of the\n     * exponential to prevent steep falloff artifacts).\n     */\n    set useCloseExponentialShadowMap(value) {\n        const filter = this._validateFilter(ShadowGenerator.FILTER_CLOSEEXPONENTIALSHADOWMAP);\n        if (!value && this.filter !== ShadowGenerator.FILTER_CLOSEEXPONENTIALSHADOWMAP) {\n            return;\n        }\n        this.filter = value ? filter : ShadowGenerator.FILTER_NONE;\n    }\n    /**\n     * Gets if the current filter is set to filtered \"close ESM\" (using the inverse of the\n     * exponential to prevent steep falloff artifacts).\n     */\n    get useBlurCloseExponentialShadowMap() {\n        return this.filter === ShadowGenerator.FILTER_BLURCLOSEEXPONENTIALSHADOWMAP;\n    }\n    /**\n     * Sets the current filter to filtered \"close ESM\" (using the inverse of the\n     * exponential to prevent steep falloff artifacts).\n     */\n    set useBlurCloseExponentialShadowMap(value) {\n        const filter = this._validateFilter(ShadowGenerator.FILTER_BLURCLOSEEXPONENTIALSHADOWMAP);\n        if (!value && this.filter !== ShadowGenerator.FILTER_BLURCLOSEEXPONENTIALSHADOWMAP) {\n            return;\n        }\n        this.filter = value ? filter : ShadowGenerator.FILTER_NONE;\n    }\n    /**\n     * Gets if the current filter is set to \"PCF\" (percentage closer filtering).\n     */\n    get usePercentageCloserFiltering() {\n        return this.filter === ShadowGenerator.FILTER_PCF;\n    }\n    /**\n     * Sets the current filter to \"PCF\" (percentage closer filtering).\n     */\n    set usePercentageCloserFiltering(value) {\n        const filter = this._validateFilter(ShadowGenerator.FILTER_PCF);\n        if (!value && this.filter !== ShadowGenerator.FILTER_PCF) {\n            return;\n        }\n        this.filter = value ? filter : ShadowGenerator.FILTER_NONE;\n    }\n    /**\n     * Gets the PCF or PCSS Quality.\n     * Only valid if usePercentageCloserFiltering or usePercentageCloserFiltering is true.\n     */\n    get filteringQuality() {\n        return this._filteringQuality;\n    }\n    /**\n     * Sets the PCF or PCSS Quality.\n     * Only valid if usePercentageCloserFiltering or usePercentageCloserFiltering is true.\n     */\n    set filteringQuality(filteringQuality) {\n        if (this._filteringQuality === filteringQuality) {\n            return;\n        }\n        this._filteringQuality = filteringQuality;\n        this._disposeBlurPostProcesses();\n        this._applyFilterValues();\n        this._light._markMeshesAsLightDirty();\n    }\n    /**\n     * Gets if the current filter is set to \"PCSS\" (contact hardening).\n     */\n    get useContactHardeningShadow() {\n        return this.filter === ShadowGenerator.FILTER_PCSS;\n    }\n    /**\n     * Sets the current filter to \"PCSS\" (contact hardening).\n     */\n    set useContactHardeningShadow(value) {\n        const filter = this._validateFilter(ShadowGenerator.FILTER_PCSS);\n        if (!value && this.filter !== ShadowGenerator.FILTER_PCSS) {\n            return;\n        }\n        this.filter = value ? filter : ShadowGenerator.FILTER_NONE;\n    }\n    /**\n     * Gets the Light Size (in shadow map uv unit) used in PCSS to determine the blocker search area and the penumbra size.\n     * Using a ratio helps keeping shape stability independently of the map size.\n     *\n     * It does not account for the light projection as it was having too much\n     * instability during the light setup or during light position changes.\n     *\n     * Only valid if useContactHardeningShadow is true.\n     */\n    get contactHardeningLightSizeUVRatio() {\n        return this._contactHardeningLightSizeUVRatio;\n    }\n    /**\n     * Sets the Light Size (in shadow map uv unit) used in PCSS to determine the blocker search area and the penumbra size.\n     * Using a ratio helps keeping shape stability independently of the map size.\n     *\n     * It does not account for the light projection as it was having too much\n     * instability during the light setup or during light position changes.\n     *\n     * Only valid if useContactHardeningShadow is true.\n     */\n    set contactHardeningLightSizeUVRatio(contactHardeningLightSizeUVRatio) {\n        this._contactHardeningLightSizeUVRatio = contactHardeningLightSizeUVRatio;\n    }\n    /** Gets or sets the actual darkness of a shadow */\n    get darkness() {\n        return this._darkness;\n    }\n    set darkness(value) {\n        this.setDarkness(value);\n    }\n    /**\n     * Returns the darkness value (float). This can only decrease the actual darkness of a shadow.\n     * 0 means strongest and 1 would means no shadow.\n     * @returns the darkness.\n     */\n    getDarkness() {\n        return this._darkness;\n    }\n    /**\n     * Sets the darkness value (float). This can only decrease the actual darkness of a shadow.\n     * @param darkness The darkness value 0 means strongest and 1 would means no shadow.\n     * @returns the shadow generator allowing fluent coding.\n     */\n    setDarkness(darkness) {\n        if (darkness >= 1.0) {\n            this._darkness = 1.0;\n        }\n        else if (darkness <= 0.0) {\n            this._darkness = 0.0;\n        }\n        else {\n            this._darkness = darkness;\n        }\n        return this;\n    }\n    /** Gets or sets the ability to have transparent shadow  */\n    get transparencyShadow() {\n        return this._transparencyShadow;\n    }\n    set transparencyShadow(value) {\n        this.setTransparencyShadow(value);\n    }\n    /**\n     * Sets the ability to have transparent shadow (boolean).\n     * @param transparent True if transparent else False\n     * @returns the shadow generator allowing fluent coding\n     */\n    setTransparencyShadow(transparent) {\n        this._transparencyShadow = transparent;\n        return this;\n    }\n    /**\n     * Gets the main RTT containing the shadow map (usually storing depth from the light point of view).\n     * @returns The render target texture if present otherwise, null\n     */\n    getShadowMap() {\n        return this._shadowMap;\n    }\n    /**\n     * Gets the RTT used during rendering (can be a blurred version of the shadow map or the shadow map itself).\n     * @returns The render target texture if the shadow map is present otherwise, null\n     */\n    getShadowMapForRendering() {\n        if (this._shadowMap2) {\n            return this._shadowMap2;\n        }\n        return this._shadowMap;\n    }\n    /**\n     * Gets the class name of that object\n     * @returns \"ShadowGenerator\"\n     */\n    getClassName() {\n        return ShadowGenerator.CLASSNAME;\n    }\n    /**\n     * Helper function to add a mesh and its descendants to the list of shadow casters.\n     * @param mesh Mesh to add\n     * @param includeDescendants boolean indicating if the descendants should be added. Default to true\n     * @returns the Shadow Generator itself\n     */\n    addShadowCaster(mesh, includeDescendants = true) {\n        if (!this._shadowMap) {\n            return this;\n        }\n        if (!this._shadowMap.renderList) {\n            this._shadowMap.renderList = [];\n        }\n        if (this._shadowMap.renderList.indexOf(mesh) === -1) {\n            this._shadowMap.renderList.push(mesh);\n        }\n        if (includeDescendants) {\n            for (const childMesh of mesh.getChildMeshes()) {\n                if (this._shadowMap.renderList.indexOf(childMesh) === -1) {\n                    this._shadowMap.renderList.push(childMesh);\n                }\n            }\n        }\n        return this;\n    }\n    /**\n     * Helper function to remove a mesh and its descendants from the list of shadow casters\n     * @param mesh Mesh to remove\n     * @param includeDescendants boolean indicating if the descendants should be removed. Default to true\n     * @returns the Shadow Generator itself\n     */\n    removeShadowCaster(mesh, includeDescendants = true) {\n        if (!this._shadowMap || !this._shadowMap.renderList) {\n            return this;\n        }\n        const index = this._shadowMap.renderList.indexOf(mesh);\n        if (index !== -1) {\n            this._shadowMap.renderList.splice(index, 1);\n        }\n        if (includeDescendants) {\n            for (const child of mesh.getChildren()) {\n                this.removeShadowCaster(child);\n            }\n        }\n        return this;\n    }\n    /**\n     * Returns the associated light object.\n     * @returns the light generating the shadow\n     */\n    getLight() {\n        return this._light;\n    }\n    _getCamera() {\n        var _a;\n        return (_a = this._camera) !== null && _a !== void 0 ? _a : this._scene.activeCamera;\n    }\n    /**\n     * Gets or sets the size of the texture what stores the shadows\n     */\n    get mapSize() {\n        return this._mapSize;\n    }\n    set mapSize(size) {\n        this._mapSize = size;\n        this._light._markMeshesAsLightDirty();\n        this.recreateShadowMap();\n    }\n    /**\n     * Creates a ShadowGenerator object.\n     * A ShadowGenerator is the required tool to use the shadows.\n     * Each light casting shadows needs to use its own ShadowGenerator.\n     * Documentation : https://doc.babylonjs.com/features/featuresDeepDive/lights/shadows\n     * @param mapSize The size of the texture what stores the shadows. Example : 1024.\n     * @param light The light object generating the shadows.\n     * @param usefullFloatFirst By default the generator will try to use half float textures but if you need precision (for self shadowing for instance), you can use this option to enforce full float texture.\n     * @param camera Camera associated with this shadow generator (default: null). If null, takes the scene active camera at the time we need to access it\n     */\n    constructor(mapSize, light, usefullFloatFirst, camera) {\n        /**\n         * Observable triggered before the shadow is rendered. Can be used to update internal effect state\n         */\n        this.onBeforeShadowMapRenderObservable = new Observable();\n        /**\n         * Observable triggered after the shadow is rendered. Can be used to restore internal effect state\n         */\n        this.onAfterShadowMapRenderObservable = new Observable();\n        /**\n         * Observable triggered before a mesh is rendered in the shadow map.\n         * Can be used to update internal effect state (that you can get from the onBeforeShadowMapRenderObservable)\n         */\n        this.onBeforeShadowMapRenderMeshObservable = new Observable();\n        /**\n         * Observable triggered after a mesh is rendered in the shadow map.\n         * Can be used to update internal effect state (that you can get from the onAfterShadowMapRenderObservable)\n         */\n        this.onAfterShadowMapRenderMeshObservable = new Observable();\n        this._bias = 0.00005;\n        this._normalBias = 0;\n        this._blurBoxOffset = 1;\n        this._blurScale = 2;\n        this._blurKernel = 1;\n        this._useKernelBlur = false;\n        this._filter = ShadowGenerator.FILTER_NONE;\n        this._filteringQuality = ShadowGenerator.QUALITY_HIGH;\n        this._contactHardeningLightSizeUVRatio = 0.1;\n        this._darkness = 0;\n        this._transparencyShadow = false;\n        /**\n         * Enables or disables shadows with varying strength based on the transparency\n         * When it is enabled, the strength of the shadow is taken equal to mesh.visibility\n         * If you enabled an alpha texture on your material, the alpha value red from the texture is also combined to compute the strength:\n         *          mesh.visibility * alphaTexture.a\n         * The texture used is the diffuse by default, but it can be set to the opacity by setting useOpacityTextureForTransparentShadow\n         * Note that by definition transparencyShadow must be set to true for enableSoftTransparentShadow to work!\n         */\n        this.enableSoftTransparentShadow = false;\n        /**\n         * If this is true, use the opacity texture's alpha channel for transparent shadows instead of the diffuse one\n         */\n        this.useOpacityTextureForTransparentShadow = false;\n        /**\n         * Controls the extent to which the shadows fade out at the edge of the frustum\n         */\n        this.frustumEdgeFalloff = 0;\n        /**\n         * If true the shadow map is generated by rendering the back face of the mesh instead of the front face.\n         * This can help with self-shadowing as the geometry making up the back of objects is slightly offset.\n         * It might on the other hand introduce peter panning.\n         */\n        this.forceBackFacesOnly = false;\n        this._lightDirection = Vector3.Zero();\n        this._viewMatrix = Matrix.Zero();\n        this._projectionMatrix = Matrix.Zero();\n        this._transformMatrix = Matrix.Zero();\n        this._cachedPosition = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\n        this._cachedDirection = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\n        this._currentFaceIndex = 0;\n        this._currentFaceIndexCache = 0;\n        this._defaultTextureMatrix = Matrix.Identity();\n        this._mapSize = mapSize;\n        this._light = light;\n        this._scene = light.getScene();\n        this._camera = camera !== null && camera !== void 0 ? camera : null;\n        let shadowGenerators = light._shadowGenerators;\n        if (!shadowGenerators) {\n            shadowGenerators = light._shadowGenerators = new Map();\n        }\n        shadowGenerators.set(this._camera, this);\n        this.id = light.id;\n        this._useUBO = this._scene.getEngine().supportsUniformBuffers;\n        if (this._useUBO) {\n            this._sceneUBOs = [];\n            this._sceneUBOs.push(this._scene.createSceneUniformBuffer(`Scene for Shadow Generator (light \"${this._light.name}\")`));\n        }\n        ShadowGenerator._SceneComponentInitialization(this._scene);\n        // Texture type fallback from float to int if not supported.\n        const caps = this._scene.getEngine().getCaps();\n        if (!usefullFloatFirst) {\n            if (caps.textureHalfFloatRender && caps.textureHalfFloatLinearFiltering) {\n                this._textureType = 2;\n            }\n            else if (caps.textureFloatRender && caps.textureFloatLinearFiltering) {\n                this._textureType = 1;\n            }\n            else {\n                this._textureType = 0;\n            }\n        }\n        else {\n            if (caps.textureFloatRender && caps.textureFloatLinearFiltering) {\n                this._textureType = 1;\n            }\n            else if (caps.textureHalfFloatRender && caps.textureHalfFloatLinearFiltering) {\n                this._textureType = 2;\n            }\n            else {\n                this._textureType = 0;\n            }\n        }\n        this._initializeGenerator();\n        this._applyFilterValues();\n    }\n    _initializeGenerator() {\n        this._light._markMeshesAsLightDirty();\n        this._initializeShadowMap();\n    }\n    _createTargetRenderTexture() {\n        const engine = this._scene.getEngine();\n        if (engine._features.supportDepthStencilTexture) {\n            this._shadowMap = new RenderTargetTexture(this._light.name + \"_shadowMap\", this._mapSize, this._scene, false, true, this._textureType, this._light.needCube(), undefined, false, false);\n            this._shadowMap.createDepthStencilTexture(engine.useReverseDepthBuffer ? 516 : 513, true);\n        }\n        else {\n            this._shadowMap = new RenderTargetTexture(this._light.name + \"_shadowMap\", this._mapSize, this._scene, false, true, this._textureType, this._light.needCube());\n        }\n    }\n    _initializeShadowMap() {\n        this._createTargetRenderTexture();\n        if (this._shadowMap === null) {\n            return;\n        }\n        this._shadowMap.wrapU = Texture.CLAMP_ADDRESSMODE;\n        this._shadowMap.wrapV = Texture.CLAMP_ADDRESSMODE;\n        this._shadowMap.anisotropicFilteringLevel = 1;\n        this._shadowMap.updateSamplingMode(Texture.BILINEAR_SAMPLINGMODE);\n        this._shadowMap.renderParticles = false;\n        this._shadowMap.ignoreCameraViewport = true;\n        if (this._storedUniqueId) {\n            this._shadowMap.uniqueId = this._storedUniqueId;\n        }\n        // Custom render function.\n        this._shadowMap.customRenderFunction = this._renderForShadowMap.bind(this);\n        // Force the mesh is ready function to true as we are double checking it\n        // in the custom render function. Also it prevents side effects and useless\n        // shader variations in DEPTHPREPASS mode.\n        this._shadowMap.customIsReadyFunction = () => {\n            return true;\n        };\n        const engine = this._scene.getEngine();\n        this._shadowMap.onBeforeBindObservable.add(() => {\n            var _a;\n            this._currentSceneUBO = this._scene.getSceneUniformBuffer();\n            (_a = engine._debugPushGroup) === null || _a === void 0 ? void 0 : _a.call(engine, `shadow map generation for pass id ${engine.currentRenderPassId}`, 1);\n        });\n        // Record Face Index before render.\n        this._shadowMap.onBeforeRenderObservable.add((faceIndex) => {\n            if (this._sceneUBOs) {\n                this._scene.setSceneUniformBuffer(this._sceneUBOs[0]);\n            }\n            this._currentFaceIndex = faceIndex;\n            if (this._filter === ShadowGenerator.FILTER_PCF) {\n                engine.setColorWrite(false);\n            }\n            this.getTransformMatrix(); // generate the view/projection matrix\n            this._scene.setTransformMatrix(this._viewMatrix, this._projectionMatrix);\n            if (this._useUBO) {\n                this._scene.getSceneUniformBuffer().unbindEffect();\n                this._scene.finalizeSceneUbo();\n            }\n        });\n        // Blur if required after render.\n        this._shadowMap.onAfterUnbindObservable.add(() => {\n            var _a, _b;\n            if (this._sceneUBOs) {\n                this._scene.setSceneUniformBuffer(this._currentSceneUBO);\n            }\n            this._scene.updateTransformMatrix(); // restore the view/projection matrices of the active camera\n            if (this._filter === ShadowGenerator.FILTER_PCF) {\n                engine.setColorWrite(true);\n            }\n            if (!this.useBlurExponentialShadowMap && !this.useBlurCloseExponentialShadowMap) {\n                (_a = engine._debugPopGroup) === null || _a === void 0 ? void 0 : _a.call(engine, 1);\n                return;\n            }\n            const shadowMap = this.getShadowMapForRendering();\n            if (shadowMap) {\n                this._scene.postProcessManager.directRender(this._blurPostProcesses, shadowMap.renderTarget, true);\n                engine.unBindFramebuffer(shadowMap.renderTarget, true);\n                (_b = engine._debugPopGroup) === null || _b === void 0 ? void 0 : _b.call(engine, 1);\n            }\n        });\n        // Clear according to the chosen filter.\n        const clearZero = new Color4(0, 0, 0, 0);\n        const clearOne = new Color4(1.0, 1.0, 1.0, 1.0);\n        this._shadowMap.onClearObservable.add((engine) => {\n            if (this._filter === ShadowGenerator.FILTER_PCF) {\n                engine.clear(clearOne, false, true, false);\n            }\n            else if (this.useExponentialShadowMap || this.useBlurExponentialShadowMap) {\n                engine.clear(clearZero, true, true, false);\n            }\n            else {\n                engine.clear(clearOne, true, true, false);\n            }\n        });\n        // Recreate on resize.\n        this._shadowMap.onResizeObservable.add((rtt) => {\n            this._storedUniqueId = this._shadowMap.uniqueId;\n            this._mapSize = rtt.getRenderSize();\n            this._light._markMeshesAsLightDirty();\n            this.recreateShadowMap();\n        });\n        // Ensures rendering groupids do not erase the depth buffer\n        // or we would lose the shadows information.\n        for (let i = RenderingManager.MIN_RENDERINGGROUPS; i < RenderingManager.MAX_RENDERINGGROUPS; i++) {\n            this._shadowMap.setRenderingAutoClearDepthStencil(i, false);\n        }\n    }\n    _initializeBlurRTTAndPostProcesses() {\n        const engine = this._scene.getEngine();\n        const targetSize = this._mapSize / this.blurScale;\n        if (!this.useKernelBlur || this.blurScale !== 1.0) {\n            this._shadowMap2 = new RenderTargetTexture(this._light.name + \"_shadowMap2\", targetSize, this._scene, false, true, this._textureType, undefined, undefined, false);\n            this._shadowMap2.wrapU = Texture.CLAMP_ADDRESSMODE;\n            this._shadowMap2.wrapV = Texture.CLAMP_ADDRESSMODE;\n            this._shadowMap2.updateSamplingMode(Texture.BILINEAR_SAMPLINGMODE);\n        }\n        if (this.useKernelBlur) {\n            this._kernelBlurXPostprocess = new BlurPostProcess(this._light.name + \"KernelBlurX\", new Vector2(1, 0), this.blurKernel, 1.0, null, Texture.BILINEAR_SAMPLINGMODE, engine, false, this._textureType);\n            this._kernelBlurXPostprocess.width = targetSize;\n            this._kernelBlurXPostprocess.height = targetSize;\n            this._kernelBlurXPostprocess.externalTextureSamplerBinding = true;\n            this._kernelBlurXPostprocess.onApplyObservable.add((effect) => {\n                effect.setTexture(\"textureSampler\", this._shadowMap);\n            });\n            this._kernelBlurYPostprocess = new BlurPostProcess(this._light.name + \"KernelBlurY\", new Vector2(0, 1), this.blurKernel, 1.0, null, Texture.BILINEAR_SAMPLINGMODE, engine, false, this._textureType);\n            this._kernelBlurXPostprocess.autoClear = false;\n            this._kernelBlurYPostprocess.autoClear = false;\n            if (this._textureType === 0) {\n                this._kernelBlurXPostprocess.packedFloat = true;\n                this._kernelBlurYPostprocess.packedFloat = true;\n            }\n            this._blurPostProcesses = [this._kernelBlurXPostprocess, this._kernelBlurYPostprocess];\n        }\n        else {\n            this._boxBlurPostprocess = new PostProcess(this._light.name + \"DepthBoxBlur\", \"depthBoxBlur\", [\"screenSize\", \"boxOffset\"], [], 1.0, null, Texture.BILINEAR_SAMPLINGMODE, engine, false, \"#define OFFSET \" + this._blurBoxOffset, this._textureType);\n            this._boxBlurPostprocess.externalTextureSamplerBinding = true;\n            this._boxBlurPostprocess.onApplyObservable.add((effect) => {\n                effect.setFloat2(\"screenSize\", targetSize, targetSize);\n                effect.setTexture(\"textureSampler\", this._shadowMap);\n            });\n            this._boxBlurPostprocess.autoClear = false;\n            this._blurPostProcesses = [this._boxBlurPostprocess];\n        }\n    }\n    _renderForShadowMap(opaqueSubMeshes, alphaTestSubMeshes, transparentSubMeshes, depthOnlySubMeshes) {\n        let index;\n        if (depthOnlySubMeshes.length) {\n            for (index = 0; index < depthOnlySubMeshes.length; index++) {\n                this._renderSubMeshForShadowMap(depthOnlySubMeshes.data[index]);\n            }\n        }\n        for (index = 0; index < opaqueSubMeshes.length; index++) {\n            this._renderSubMeshForShadowMap(opaqueSubMeshes.data[index]);\n        }\n        for (index = 0; index < alphaTestSubMeshes.length; index++) {\n            this._renderSubMeshForShadowMap(alphaTestSubMeshes.data[index]);\n        }\n        if (this._transparencyShadow) {\n            for (index = 0; index < transparentSubMeshes.length; index++) {\n                this._renderSubMeshForShadowMap(transparentSubMeshes.data[index], true);\n            }\n        }\n        else {\n            for (index = 0; index < transparentSubMeshes.length; index++) {\n                transparentSubMeshes.data[index].getEffectiveMesh()._internalAbstractMeshDataInfo._isActiveIntermediate = false;\n            }\n        }\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _bindCustomEffectForRenderSubMeshForShadowMap(subMesh, effect, mesh) {\n        effect.setMatrix(\"viewProjection\", this.getTransformMatrix());\n    }\n    _renderSubMeshForShadowMap(subMesh, isTransparent = false) {\n        var _a, _b;\n        const renderingMesh = subMesh.getRenderingMesh();\n        const effectiveMesh = subMesh.getEffectiveMesh();\n        const scene = this._scene;\n        const engine = scene.getEngine();\n        const material = subMesh.getMaterial();\n        effectiveMesh._internalAbstractMeshDataInfo._isActiveIntermediate = false;\n        if (!material || subMesh.verticesCount === 0 || subMesh._renderId === scene.getRenderId()) {\n            return;\n        }\n        // Culling\n        const detNeg = effectiveMesh._getWorldMatrixDeterminant() < 0;\n        let sideOrientation = (_a = renderingMesh.overrideMaterialSideOrientation) !== null && _a !== void 0 ? _a : material.sideOrientation;\n        if (detNeg) {\n            sideOrientation =\n                sideOrientation === 0 ? 1 : 0;\n        }\n        const reverseSideOrientation = sideOrientation === 0;\n        engine.setState(material.backFaceCulling, undefined, undefined, reverseSideOrientation, material.cullBackFaces);\n        // Managing instances\n        const batch = renderingMesh._getInstancesRenderList(subMesh._id, !!subMesh.getReplacementMesh());\n        if (batch.mustReturn) {\n            return;\n        }\n        const hardwareInstancedRendering = engine.getCaps().instancedArrays &&\n            ((batch.visibleInstances[subMesh._id] !== null && batch.visibleInstances[subMesh._id] !== undefined) || renderingMesh.hasThinInstances);\n        if (this.customAllowRendering && !this.customAllowRendering(subMesh)) {\n            return;\n        }\n        if (this.isReady(subMesh, hardwareInstancedRendering, isTransparent)) {\n            subMesh._renderId = scene.getRenderId();\n            const shadowDepthWrapper = material.shadowDepthWrapper;\n            const drawWrapper = (_b = shadowDepthWrapper === null || shadowDepthWrapper === void 0 ? void 0 : shadowDepthWrapper.getEffect(subMesh, this, engine.currentRenderPassId)) !== null && _b !== void 0 ? _b : subMesh._getDrawWrapper();\n            const effect = DrawWrapper.GetEffect(drawWrapper);\n            engine.enableEffect(drawWrapper);\n            if (!hardwareInstancedRendering) {\n                renderingMesh._bind(subMesh, effect, material.fillMode);\n            }\n            this.getTransformMatrix(); // make sure _cachedDirection et _cachedPosition are up to date\n            effect.setFloat3(\"biasAndScaleSM\", this.bias, this.normalBias, this.depthScale);\n            if (this.getLight().getTypeID() === Light.LIGHTTYPEID_DIRECTIONALLIGHT) {\n                effect.setVector3(\"lightDataSM\", this._cachedDirection);\n            }\n            else {\n                effect.setVector3(\"lightDataSM\", this._cachedPosition);\n            }\n            const camera = this._getCamera();\n            if (camera) {\n                effect.setFloat2(\"depthValuesSM\", this.getLight().getDepthMinZ(camera), this.getLight().getDepthMinZ(camera) + this.getLight().getDepthMaxZ(camera));\n            }\n            if (isTransparent && this.enableSoftTransparentShadow) {\n                effect.setFloat(\"softTransparentShadowSM\", effectiveMesh.visibility * material.alpha);\n            }\n            if (shadowDepthWrapper) {\n                subMesh._setMainDrawWrapperOverride(drawWrapper);\n                if (shadowDepthWrapper.standalone) {\n                    shadowDepthWrapper.baseMaterial.bindForSubMesh(effectiveMesh.getWorldMatrix(), renderingMesh, subMesh);\n                }\n                else {\n                    material.bindForSubMesh(effectiveMesh.getWorldMatrix(), renderingMesh, subMesh);\n                }\n                subMesh._setMainDrawWrapperOverride(null);\n            }\n            else {\n                // Alpha test\n                if (this.useOpacityTextureForTransparentShadow) {\n                    const opacityTexture = material.opacityTexture;\n                    if (opacityTexture) {\n                        effect.setTexture(\"diffuseSampler\", opacityTexture);\n                        effect.setMatrix(\"diffuseMatrix\", opacityTexture.getTextureMatrix() || this._defaultTextureMatrix);\n                    }\n                }\n                else if (material.needAlphaTesting() || material.needAlphaBlending()) {\n                    const alphaTexture = material.getAlphaTestTexture();\n                    if (alphaTexture) {\n                        effect.setTexture(\"diffuseSampler\", alphaTexture);\n                        effect.setMatrix(\"diffuseMatrix\", alphaTexture.getTextureMatrix() || this._defaultTextureMatrix);\n                    }\n                }\n                // Bones\n                if (renderingMesh.useBones && renderingMesh.computeBonesUsingShaders && renderingMesh.skeleton) {\n                    const skeleton = renderingMesh.skeleton;\n                    if (skeleton.isUsingTextureForMatrices) {\n                        const boneTexture = skeleton.getTransformMatrixTexture(renderingMesh);\n                        if (!boneTexture) {\n                            return;\n                        }\n                        effect.setTexture(\"boneSampler\", boneTexture);\n                        effect.setFloat(\"boneTextureWidth\", 4.0 * (skeleton.bones.length + 1));\n                    }\n                    else {\n                        effect.setMatrices(\"mBones\", skeleton.getTransformMatrices(renderingMesh));\n                    }\n                }\n                // Morph targets\n                MaterialHelper.BindMorphTargetParameters(renderingMesh, effect);\n                if (renderingMesh.morphTargetManager && renderingMesh.morphTargetManager.isUsingTextureForTargets) {\n                    renderingMesh.morphTargetManager._bind(effect);\n                }\n                // Clip planes\n                bindClipPlane(effect, material, scene);\n            }\n            if (!this._useUBO && !shadowDepthWrapper) {\n                this._bindCustomEffectForRenderSubMeshForShadowMap(subMesh, effect, effectiveMesh);\n            }\n            MaterialHelper.BindSceneUniformBuffer(effect, this._scene.getSceneUniformBuffer());\n            this._scene.getSceneUniformBuffer().bindUniformBuffer();\n            const world = effectiveMesh.getWorldMatrix();\n            // In the non hardware instanced mode, the Mesh ubo update is done by the callback passed to renderingMesh._processRendering (see below)\n            if (hardwareInstancedRendering) {\n                effectiveMesh.getMeshUniformBuffer().bindToEffect(effect, \"Mesh\");\n                effectiveMesh.transferToEffect(world);\n            }\n            if (this.forceBackFacesOnly) {\n                engine.setState(true, 0, false, true, material.cullBackFaces);\n            }\n            // Observables\n            this.onBeforeShadowMapRenderMeshObservable.notifyObservers(renderingMesh);\n            this.onBeforeShadowMapRenderObservable.notifyObservers(effect);\n            // Draw\n            renderingMesh._processRendering(effectiveMesh, subMesh, effect, material.fillMode, batch, hardwareInstancedRendering, (isInstance, worldOverride) => {\n                if (effectiveMesh !== renderingMesh && !isInstance) {\n                    renderingMesh.getMeshUniformBuffer().bindToEffect(effect, \"Mesh\");\n                    renderingMesh.transferToEffect(worldOverride);\n                }\n                else {\n                    effectiveMesh.getMeshUniformBuffer().bindToEffect(effect, \"Mesh\");\n                    effectiveMesh.transferToEffect(isInstance ? worldOverride : world);\n                }\n            });\n            if (this.forceBackFacesOnly) {\n                engine.setState(true, 0, false, false, material.cullBackFaces);\n            }\n            // Observables\n            this.onAfterShadowMapRenderObservable.notifyObservers(effect);\n            this.onAfterShadowMapRenderMeshObservable.notifyObservers(renderingMesh);\n        }\n        else {\n            // Need to reset refresh rate of the shadowMap\n            if (this._shadowMap) {\n                this._shadowMap.resetRefreshCounter();\n            }\n        }\n    }\n    _applyFilterValues() {\n        if (!this._shadowMap) {\n            return;\n        }\n        if (this.filter === ShadowGenerator.FILTER_NONE || this.filter === ShadowGenerator.FILTER_PCSS) {\n            this._shadowMap.updateSamplingMode(Texture.NEAREST_SAMPLINGMODE);\n        }\n        else {\n            this._shadowMap.updateSamplingMode(Texture.BILINEAR_SAMPLINGMODE);\n        }\n    }\n    /**\n     * Forces all the attached effect to compile to enable rendering only once ready vs. lazily compiling effects.\n     * @param onCompiled Callback triggered at the and of the effects compilation\n     * @param options Sets of optional options forcing the compilation with different modes\n     */\n    forceCompilation(onCompiled, options) {\n        const localOptions = {\n            useInstances: false,\n            ...options,\n        };\n        const shadowMap = this.getShadowMap();\n        if (!shadowMap) {\n            if (onCompiled) {\n                onCompiled(this);\n            }\n            return;\n        }\n        const renderList = shadowMap.renderList;\n        if (!renderList) {\n            if (onCompiled) {\n                onCompiled(this);\n            }\n            return;\n        }\n        const subMeshes = new Array();\n        for (const mesh of renderList) {\n            subMeshes.push(...mesh.subMeshes);\n        }\n        if (subMeshes.length === 0) {\n            if (onCompiled) {\n                onCompiled(this);\n            }\n            return;\n        }\n        let currentIndex = 0;\n        const checkReady = () => {\n            var _a, _b;\n            if (!this._scene || !this._scene.getEngine()) {\n                return;\n            }\n            while (this.isReady(subMeshes[currentIndex], localOptions.useInstances, (_b = (_a = subMeshes[currentIndex].getMaterial()) === null || _a === void 0 ? void 0 : _a.needAlphaBlendingForMesh(subMeshes[currentIndex].getMesh())) !== null && _b !== void 0 ? _b : false)) {\n                currentIndex++;\n                if (currentIndex >= subMeshes.length) {\n                    if (onCompiled) {\n                        onCompiled(this);\n                    }\n                    return;\n                }\n            }\n            setTimeout(checkReady, 16);\n        };\n        checkReady();\n    }\n    /**\n     * Forces all the attached effect to compile to enable rendering only once ready vs. lazily compiling effects.\n     * @param options Sets of optional options forcing the compilation with different modes\n     * @returns A promise that resolves when the compilation completes\n     */\n    forceCompilationAsync(options) {\n        return new Promise((resolve) => {\n            this.forceCompilation(() => {\n                resolve();\n            }, options);\n        });\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _isReadyCustomDefines(defines, subMesh, useInstances) { }\n    _prepareShadowDefines(subMesh, useInstances, defines, isTransparent) {\n        defines.push(\"#define SM_LIGHTTYPE_\" + this._light.getClassName().toUpperCase());\n        defines.push(\"#define SM_FLOAT \" + (this._textureType !== 0 ? \"1\" : \"0\"));\n        defines.push(\"#define SM_ESM \" + (this.useExponentialShadowMap || this.useBlurExponentialShadowMap ? \"1\" : \"0\"));\n        defines.push(\"#define SM_DEPTHTEXTURE \" + (this.usePercentageCloserFiltering || this.useContactHardeningShadow ? \"1\" : \"0\"));\n        const mesh = subMesh.getMesh();\n        // Normal bias.\n        defines.push(\"#define SM_NORMALBIAS \" + (this.normalBias && mesh.isVerticesDataPresent(VertexBuffer.NormalKind) ? \"1\" : \"0\"));\n        defines.push(\"#define SM_DIRECTIONINLIGHTDATA \" + (this.getLight().getTypeID() === Light.LIGHTTYPEID_DIRECTIONALLIGHT ? \"1\" : \"0\"));\n        // Point light\n        defines.push(\"#define SM_USEDISTANCE \" + (this._light.needCube() ? \"1\" : \"0\"));\n        // Soft transparent shadows\n        defines.push(\"#define SM_SOFTTRANSPARENTSHADOW \" + (this.enableSoftTransparentShadow && isTransparent ? \"1\" : \"0\"));\n        this._isReadyCustomDefines(defines, subMesh, useInstances);\n        return defines;\n    }\n    /**\n     * Determine whether the shadow generator is ready or not (mainly all effects and related post processes needs to be ready).\n     * @param subMesh The submesh we want to render in the shadow map\n     * @param useInstances Defines whether will draw in the map using instances\n     * @param isTransparent Indicates that isReady is called for a transparent subMesh\n     * @returns true if ready otherwise, false\n     */\n    isReady(subMesh, useInstances, isTransparent) {\n        var _a;\n        const material = subMesh.getMaterial(), shadowDepthWrapper = material === null || material === void 0 ? void 0 : material.shadowDepthWrapper;\n        if (!material) {\n            return false;\n        }\n        const defines = [];\n        this._prepareShadowDefines(subMesh, useInstances, defines, isTransparent);\n        if (shadowDepthWrapper) {\n            if (!shadowDepthWrapper.isReadyForSubMesh(subMesh, defines, this, useInstances, this._scene.getEngine().currentRenderPassId)) {\n                return false;\n            }\n        }\n        else {\n            const subMeshEffect = subMesh._getDrawWrapper(undefined, true);\n            let effect = subMeshEffect.effect;\n            let cachedDefines = subMeshEffect.defines;\n            const attribs = [VertexBuffer.PositionKind];\n            const mesh = subMesh.getMesh();\n            // Normal bias.\n            if (this.normalBias && mesh.isVerticesDataPresent(VertexBuffer.NormalKind)) {\n                attribs.push(VertexBuffer.NormalKind);\n                defines.push(\"#define NORMAL\");\n                if (mesh.nonUniformScaling) {\n                    defines.push(\"#define NONUNIFORMSCALING\");\n                }\n            }\n            // Alpha test\n            const needAlphaTesting = material === null || material === void 0 ? void 0 : material.needAlphaTesting();\n            const needAlphaBlending = material === null || material === void 0 ? void 0 : material.needAlphaBlending();\n            if (material && (needAlphaTesting || needAlphaBlending)) {\n                let alphaTexture = null;\n                if (this.useOpacityTextureForTransparentShadow) {\n                    alphaTexture = material.opacityTexture;\n                }\n                else {\n                    alphaTexture = material.getAlphaTestTexture();\n                }\n                if (alphaTexture) {\n                    if (!alphaTexture.isReady()) {\n                        return false;\n                    }\n                    const alphaCutOff = (_a = material.alphaCutOff) !== null && _a !== void 0 ? _a : ShadowGenerator.DEFAULT_ALPHA_CUTOFF;\n                    defines.push(\"#define ALPHATEXTURE\");\n                    if (needAlphaTesting) {\n                        defines.push(`#define ALPHATESTVALUE ${alphaCutOff}${alphaCutOff % 1 === 0 ? \".\" : \"\"}`);\n                    }\n                    if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {\n                        attribs.push(VertexBuffer.UVKind);\n                        defines.push(\"#define UV1\");\n                    }\n                    if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind)) {\n                        if (alphaTexture.coordinatesIndex === 1) {\n                            attribs.push(VertexBuffer.UV2Kind);\n                            defines.push(\"#define UV2\");\n                        }\n                    }\n                }\n            }\n            // Bones\n            const fallbacks = new EffectFallbacks();\n            if (mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {\n                attribs.push(VertexBuffer.MatricesIndicesKind);\n                attribs.push(VertexBuffer.MatricesWeightsKind);\n                if (mesh.numBoneInfluencers > 4) {\n                    attribs.push(VertexBuffer.MatricesIndicesExtraKind);\n                    attribs.push(VertexBuffer.MatricesWeightsExtraKind);\n                }\n                const skeleton = mesh.skeleton;\n                defines.push(\"#define NUM_BONE_INFLUENCERS \" + mesh.numBoneInfluencers);\n                if (mesh.numBoneInfluencers > 0) {\n                    fallbacks.addCPUSkinningFallback(0, mesh);\n                }\n                if (skeleton.isUsingTextureForMatrices) {\n                    defines.push(\"#define BONETEXTURE\");\n                }\n                else {\n                    defines.push(\"#define BonesPerMesh \" + (skeleton.bones.length + 1));\n                }\n            }\n            else {\n                defines.push(\"#define NUM_BONE_INFLUENCERS 0\");\n            }\n            // Morph targets\n            const manager = mesh.morphTargetManager;\n            let morphInfluencers = 0;\n            if (manager) {\n                if (manager.numInfluencers > 0) {\n                    defines.push(\"#define MORPHTARGETS\");\n                    morphInfluencers = manager.numInfluencers;\n                    defines.push(\"#define NUM_MORPH_INFLUENCERS \" + morphInfluencers);\n                    if (manager.isUsingTextureForTargets) {\n                        defines.push(\"#define MORPHTARGETS_TEXTURE\");\n                    }\n                    MaterialHelper.PrepareAttributesForMorphTargetsInfluencers(attribs, mesh, morphInfluencers);\n                }\n            }\n            // ClipPlanes\n            prepareDefinesForClipPlanes(material, this._scene, defines);\n            // Instances\n            if (useInstances) {\n                defines.push(\"#define INSTANCES\");\n                MaterialHelper.PushAttributesForInstances(attribs);\n                if (subMesh.getRenderingMesh().hasThinInstances) {\n                    defines.push(\"#define THIN_INSTANCES\");\n                }\n            }\n            if (this.customShaderOptions) {\n                if (this.customShaderOptions.defines) {\n                    for (const define of this.customShaderOptions.defines) {\n                        if (defines.indexOf(define) === -1) {\n                            defines.push(define);\n                        }\n                    }\n                }\n            }\n            // Get correct effect\n            const join = defines.join(\"\\n\");\n            if (cachedDefines !== join) {\n                cachedDefines = join;\n                let shaderName = \"shadowMap\";\n                const uniforms = [\n                    \"world\",\n                    \"mBones\",\n                    \"viewProjection\",\n                    \"diffuseMatrix\",\n                    \"lightDataSM\",\n                    \"depthValuesSM\",\n                    \"biasAndScaleSM\",\n                    \"morphTargetInfluences\",\n                    \"boneTextureWidth\",\n                    \"softTransparentShadowSM\",\n                    \"morphTargetTextureInfo\",\n                    \"morphTargetTextureIndices\",\n                ];\n                const samplers = [\"diffuseSampler\", \"boneSampler\", \"morphTargets\"];\n                const uniformBuffers = [\"Scene\", \"Mesh\"];\n                addClipPlaneUniforms(uniforms);\n                // Custom shader?\n                if (this.customShaderOptions) {\n                    shaderName = this.customShaderOptions.shaderName;\n                    if (this.customShaderOptions.attributes) {\n                        for (const attrib of this.customShaderOptions.attributes) {\n                            if (attribs.indexOf(attrib) === -1) {\n                                attribs.push(attrib);\n                            }\n                        }\n                    }\n                    if (this.customShaderOptions.uniforms) {\n                        for (const uniform of this.customShaderOptions.uniforms) {\n                            if (uniforms.indexOf(uniform) === -1) {\n                                uniforms.push(uniform);\n                            }\n                        }\n                    }\n                    if (this.customShaderOptions.samplers) {\n                        for (const sampler of this.customShaderOptions.samplers) {\n                            if (samplers.indexOf(sampler) === -1) {\n                                samplers.push(sampler);\n                            }\n                        }\n                    }\n                }\n                const engine = this._scene.getEngine();\n                effect = engine.createEffect(shaderName, {\n                    attributes: attribs,\n                    uniformsNames: uniforms,\n                    uniformBuffersNames: uniformBuffers,\n                    samplers: samplers,\n                    defines: join,\n                    fallbacks: fallbacks,\n                    onCompiled: null,\n                    onError: null,\n                    indexParameters: { maxSimultaneousMorphTargets: morphInfluencers },\n                }, engine);\n                subMeshEffect.setEffect(effect, cachedDefines);\n            }\n            if (!effect.isReady()) {\n                return false;\n            }\n        }\n        if (this.useBlurExponentialShadowMap || this.useBlurCloseExponentialShadowMap) {\n            if (!this._blurPostProcesses || !this._blurPostProcesses.length) {\n                this._initializeBlurRTTAndPostProcesses();\n            }\n        }\n        if (this._kernelBlurXPostprocess && !this._kernelBlurXPostprocess.isReady()) {\n            return false;\n        }\n        if (this._kernelBlurYPostprocess && !this._kernelBlurYPostprocess.isReady()) {\n            return false;\n        }\n        if (this._boxBlurPostprocess && !this._boxBlurPostprocess.isReady()) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Prepare all the defines in a material relying on a shadow map at the specified light index.\n     * @param defines Defines of the material we want to update\n     * @param lightIndex Index of the light in the enabled light list of the material\n     */\n    prepareDefines(defines, lightIndex) {\n        const scene = this._scene;\n        const light = this._light;\n        if (!scene.shadowsEnabled || !light.shadowEnabled) {\n            return;\n        }\n        defines[\"SHADOW\" + lightIndex] = true;\n        if (this.useContactHardeningShadow) {\n            defines[\"SHADOWPCSS\" + lightIndex] = true;\n            if (this._filteringQuality === ShadowGenerator.QUALITY_LOW) {\n                defines[\"SHADOWLOWQUALITY\" + lightIndex] = true;\n            }\n            else if (this._filteringQuality === ShadowGenerator.QUALITY_MEDIUM) {\n                defines[\"SHADOWMEDIUMQUALITY\" + lightIndex] = true;\n            }\n            // else default to high.\n        }\n        else if (this.usePercentageCloserFiltering) {\n            defines[\"SHADOWPCF\" + lightIndex] = true;\n            if (this._filteringQuality === ShadowGenerator.QUALITY_LOW) {\n                defines[\"SHADOWLOWQUALITY\" + lightIndex] = true;\n            }\n            else if (this._filteringQuality === ShadowGenerator.QUALITY_MEDIUM) {\n                defines[\"SHADOWMEDIUMQUALITY\" + lightIndex] = true;\n            }\n            // else default to high.\n        }\n        else if (this.usePoissonSampling) {\n            defines[\"SHADOWPOISSON\" + lightIndex] = true;\n        }\n        else if (this.useExponentialShadowMap || this.useBlurExponentialShadowMap) {\n            defines[\"SHADOWESM\" + lightIndex] = true;\n        }\n        else if (this.useCloseExponentialShadowMap || this.useBlurCloseExponentialShadowMap) {\n            defines[\"SHADOWCLOSEESM\" + lightIndex] = true;\n        }\n        if (light.needCube()) {\n            defines[\"SHADOWCUBE\" + lightIndex] = true;\n        }\n    }\n    /**\n     * Binds the shadow related information inside of an effect (information like near, far, darkness...\n     * defined in the generator but impacting the effect).\n     * @param lightIndex Index of the light in the enabled light list of the material owning the effect\n     * @param effect The effect we are binding the information for\n     */\n    bindShadowLight(lightIndex, effect) {\n        const light = this._light;\n        const scene = this._scene;\n        if (!scene.shadowsEnabled || !light.shadowEnabled) {\n            return;\n        }\n        const camera = this._getCamera();\n        if (!camera) {\n            return;\n        }\n        const shadowMap = this.getShadowMap();\n        if (!shadowMap) {\n            return;\n        }\n        if (!light.needCube()) {\n            effect.setMatrix(\"lightMatrix\" + lightIndex, this.getTransformMatrix());\n        }\n        // Only PCF uses depth stencil texture.\n        if (this._filter === ShadowGenerator.FILTER_PCF) {\n            effect.setDepthStencilTexture(\"shadowSampler\" + lightIndex, this.getShadowMapForRendering());\n            light._uniformBuffer.updateFloat4(\"shadowsInfo\", this.getDarkness(), shadowMap.getSize().width, 1 / shadowMap.getSize().width, this.frustumEdgeFalloff, lightIndex);\n        }\n        else if (this._filter === ShadowGenerator.FILTER_PCSS) {\n            effect.setDepthStencilTexture(\"shadowSampler\" + lightIndex, this.getShadowMapForRendering());\n            effect.setTexture(\"depthSampler\" + lightIndex, this.getShadowMapForRendering());\n            light._uniformBuffer.updateFloat4(\"shadowsInfo\", this.getDarkness(), 1 / shadowMap.getSize().width, this._contactHardeningLightSizeUVRatio * shadowMap.getSize().width, this.frustumEdgeFalloff, lightIndex);\n        }\n        else {\n            effect.setTexture(\"shadowSampler\" + lightIndex, this.getShadowMapForRendering());\n            light._uniformBuffer.updateFloat4(\"shadowsInfo\", this.getDarkness(), this.blurScale / shadowMap.getSize().width, this.depthScale, this.frustumEdgeFalloff, lightIndex);\n        }\n        light._uniformBuffer.updateFloat2(\"depthValues\", this.getLight().getDepthMinZ(camera), this.getLight().getDepthMinZ(camera) + this.getLight().getDepthMaxZ(camera), lightIndex);\n    }\n    /**\n     * Gets the transformation matrix used to project the meshes into the map from the light point of view.\n     * (eq to shadow projection matrix * light transform matrix)\n     * @returns The transform matrix used to create the shadow map\n     */\n    getTransformMatrix() {\n        const scene = this._scene;\n        if (this._currentRenderId === scene.getRenderId() && this._currentFaceIndexCache === this._currentFaceIndex) {\n            return this._transformMatrix;\n        }\n        this._currentRenderId = scene.getRenderId();\n        this._currentFaceIndexCache = this._currentFaceIndex;\n        let lightPosition = this._light.position;\n        if (this._light.computeTransformedInformation()) {\n            lightPosition = this._light.transformedPosition;\n        }\n        Vector3.NormalizeToRef(this._light.getShadowDirection(this._currentFaceIndex), this._lightDirection);\n        if (Math.abs(Vector3.Dot(this._lightDirection, Vector3.Up())) === 1.0) {\n            this._lightDirection.z = 0.0000000000001; // Required to avoid perfectly perpendicular light\n        }\n        if (this._light.needProjectionMatrixCompute() ||\n            !this._cachedPosition ||\n            !this._cachedDirection ||\n            !lightPosition.equals(this._cachedPosition) ||\n            !this._lightDirection.equals(this._cachedDirection)) {\n            this._cachedPosition.copyFrom(lightPosition);\n            this._cachedDirection.copyFrom(this._lightDirection);\n            Matrix.LookAtLHToRef(lightPosition, lightPosition.add(this._lightDirection), Vector3.Up(), this._viewMatrix);\n            const shadowMap = this.getShadowMap();\n            if (shadowMap) {\n                const renderList = shadowMap.renderList;\n                if (renderList) {\n                    this._light.setShadowProjectionMatrix(this._projectionMatrix, this._viewMatrix, renderList);\n                }\n            }\n            this._viewMatrix.multiplyToRef(this._projectionMatrix, this._transformMatrix);\n        }\n        return this._transformMatrix;\n    }\n    /**\n     * Recreates the shadow map dependencies like RTT and post processes. This can be used during the switch between\n     * Cube and 2D textures for instance.\n     */\n    recreateShadowMap() {\n        const shadowMap = this._shadowMap;\n        if (!shadowMap) {\n            return;\n        }\n        // Track render list.\n        const renderList = shadowMap.renderList;\n        // Clean up existing data.\n        this._disposeRTTandPostProcesses();\n        // Reinitializes.\n        this._initializeGenerator();\n        // Reaffect the filter to ensure a correct fallback if necessary.\n        this.filter = this._filter;\n        // Reaffect the filter.\n        this._applyFilterValues();\n        // Reaffect Render List.\n        if (renderList) {\n            // Note: don't do this._shadowMap!.renderList = renderList;\n            // The renderList hooked array is accessing the old RenderTargetTexture (see RenderTargetTexture._hookArray), which is disposed at this point (by the call to _disposeRTTandPostProcesses)\n            if (!this._shadowMap.renderList) {\n                this._shadowMap.renderList = [];\n            }\n            for (const mesh of renderList) {\n                this._shadowMap.renderList.push(mesh);\n            }\n        }\n        else {\n            this._shadowMap.renderList = null;\n        }\n    }\n    _disposeBlurPostProcesses() {\n        if (this._shadowMap2) {\n            this._shadowMap2.dispose();\n            this._shadowMap2 = null;\n        }\n        if (this._boxBlurPostprocess) {\n            this._boxBlurPostprocess.dispose();\n            this._boxBlurPostprocess = null;\n        }\n        if (this._kernelBlurXPostprocess) {\n            this._kernelBlurXPostprocess.dispose();\n            this._kernelBlurXPostprocess = null;\n        }\n        if (this._kernelBlurYPostprocess) {\n            this._kernelBlurYPostprocess.dispose();\n            this._kernelBlurYPostprocess = null;\n        }\n        this._blurPostProcesses = [];\n    }\n    _disposeRTTandPostProcesses() {\n        if (this._shadowMap) {\n            this._shadowMap.dispose();\n            this._shadowMap = null;\n        }\n        this._disposeBlurPostProcesses();\n    }\n    _disposeSceneUBOs() {\n        if (this._sceneUBOs) {\n            for (const ubo of this._sceneUBOs) {\n                ubo.dispose();\n            }\n            this._sceneUBOs = [];\n        }\n    }\n    /**\n     * Disposes the ShadowGenerator.\n     * Returns nothing.\n     */\n    dispose() {\n        this._disposeRTTandPostProcesses();\n        this._disposeSceneUBOs();\n        if (this._light) {\n            if (this._light._shadowGenerators) {\n                const iterator = this._light._shadowGenerators.entries();\n                for (let entry = iterator.next(); entry.done !== true; entry = iterator.next()) {\n                    const [camera, shadowGenerator] = entry.value;\n                    if (shadowGenerator === this) {\n                        this._light._shadowGenerators.delete(camera);\n                    }\n                }\n                if (this._light._shadowGenerators.size === 0) {\n                    this._light._shadowGenerators = null;\n                }\n            }\n            this._light._markMeshesAsLightDirty();\n        }\n        this.onBeforeShadowMapRenderMeshObservable.clear();\n        this.onBeforeShadowMapRenderObservable.clear();\n        this.onAfterShadowMapRenderMeshObservable.clear();\n        this.onAfterShadowMapRenderObservable.clear();\n    }\n    /**\n     * Serializes the shadow generator setup to a json object.\n     * @returns The serialized JSON object\n     */\n    serialize() {\n        var _a;\n        const serializationObject = {};\n        const shadowMap = this.getShadowMap();\n        if (!shadowMap) {\n            return serializationObject;\n        }\n        serializationObject.className = this.getClassName();\n        serializationObject.lightId = this._light.id;\n        serializationObject.cameraId = (_a = this._camera) === null || _a === void 0 ? void 0 : _a.id;\n        serializationObject.id = this.id;\n        serializationObject.mapSize = shadowMap.getRenderSize();\n        serializationObject.forceBackFacesOnly = this.forceBackFacesOnly;\n        serializationObject.darkness = this.getDarkness();\n        serializationObject.transparencyShadow = this._transparencyShadow;\n        serializationObject.frustumEdgeFalloff = this.frustumEdgeFalloff;\n        serializationObject.bias = this.bias;\n        serializationObject.normalBias = this.normalBias;\n        serializationObject.usePercentageCloserFiltering = this.usePercentageCloserFiltering;\n        serializationObject.useContactHardeningShadow = this.useContactHardeningShadow;\n        serializationObject.contactHardeningLightSizeUVRatio = this.contactHardeningLightSizeUVRatio;\n        serializationObject.filteringQuality = this.filteringQuality;\n        serializationObject.useExponentialShadowMap = this.useExponentialShadowMap;\n        serializationObject.useBlurExponentialShadowMap = this.useBlurExponentialShadowMap;\n        serializationObject.useCloseExponentialShadowMap = this.useBlurExponentialShadowMap;\n        serializationObject.useBlurCloseExponentialShadowMap = this.useBlurExponentialShadowMap;\n        serializationObject.usePoissonSampling = this.usePoissonSampling;\n        serializationObject.depthScale = this.depthScale;\n        serializationObject.blurBoxOffset = this.blurBoxOffset;\n        serializationObject.blurKernel = this.blurKernel;\n        serializationObject.blurScale = this.blurScale;\n        serializationObject.useKernelBlur = this.useKernelBlur;\n        serializationObject.renderList = [];\n        if (shadowMap.renderList) {\n            for (let meshIndex = 0; meshIndex < shadowMap.renderList.length; meshIndex++) {\n                const mesh = shadowMap.renderList[meshIndex];\n                serializationObject.renderList.push(mesh.id);\n            }\n        }\n        return serializationObject;\n    }\n    /**\n     * Parses a serialized ShadowGenerator and returns a new ShadowGenerator.\n     * @param parsedShadowGenerator The JSON object to parse\n     * @param scene The scene to create the shadow map for\n     * @param constr A function that builds a shadow generator or undefined to create an instance of the default shadow generator\n     * @returns The parsed shadow generator\n     */\n    static Parse(parsedShadowGenerator, scene, constr) {\n        const light = scene.getLightById(parsedShadowGenerator.lightId);\n        const camera = parsedShadowGenerator.cameraId !== undefined ? scene.getCameraById(parsedShadowGenerator.cameraId) : null;\n        const shadowGenerator = constr ? constr(parsedShadowGenerator.mapSize, light, camera) : new ShadowGenerator(parsedShadowGenerator.mapSize, light, undefined, camera);\n        const shadowMap = shadowGenerator.getShadowMap();\n        for (let meshIndex = 0; meshIndex < parsedShadowGenerator.renderList.length; meshIndex++) {\n            const meshes = scene.getMeshesById(parsedShadowGenerator.renderList[meshIndex]);\n            meshes.forEach(function (mesh) {\n                if (!shadowMap) {\n                    return;\n                }\n                if (!shadowMap.renderList) {\n                    shadowMap.renderList = [];\n                }\n                shadowMap.renderList.push(mesh);\n            });\n        }\n        if (parsedShadowGenerator.id !== undefined) {\n            shadowGenerator.id = parsedShadowGenerator.id;\n        }\n        shadowGenerator.forceBackFacesOnly = !!parsedShadowGenerator.forceBackFacesOnly;\n        if (parsedShadowGenerator.darkness !== undefined) {\n            shadowGenerator.setDarkness(parsedShadowGenerator.darkness);\n        }\n        if (parsedShadowGenerator.transparencyShadow) {\n            shadowGenerator.setTransparencyShadow(true);\n        }\n        if (parsedShadowGenerator.frustumEdgeFalloff !== undefined) {\n            shadowGenerator.frustumEdgeFalloff = parsedShadowGenerator.frustumEdgeFalloff;\n        }\n        if (parsedShadowGenerator.bias !== undefined) {\n            shadowGenerator.bias = parsedShadowGenerator.bias;\n        }\n        if (parsedShadowGenerator.normalBias !== undefined) {\n            shadowGenerator.normalBias = parsedShadowGenerator.normalBias;\n        }\n        if (parsedShadowGenerator.usePercentageCloserFiltering) {\n            shadowGenerator.usePercentageCloserFiltering = true;\n        }\n        else if (parsedShadowGenerator.useContactHardeningShadow) {\n            shadowGenerator.useContactHardeningShadow = true;\n        }\n        else if (parsedShadowGenerator.usePoissonSampling) {\n            shadowGenerator.usePoissonSampling = true;\n        }\n        else if (parsedShadowGenerator.useExponentialShadowMap) {\n            shadowGenerator.useExponentialShadowMap = true;\n        }\n        else if (parsedShadowGenerator.useBlurExponentialShadowMap) {\n            shadowGenerator.useBlurExponentialShadowMap = true;\n        }\n        else if (parsedShadowGenerator.useCloseExponentialShadowMap) {\n            shadowGenerator.useCloseExponentialShadowMap = true;\n        }\n        else if (parsedShadowGenerator.useBlurCloseExponentialShadowMap) {\n            shadowGenerator.useBlurCloseExponentialShadowMap = true;\n        }\n        // Backward compat\n        else if (parsedShadowGenerator.useVarianceShadowMap) {\n            shadowGenerator.useExponentialShadowMap = true;\n        }\n        else if (parsedShadowGenerator.useBlurVarianceShadowMap) {\n            shadowGenerator.useBlurExponentialShadowMap = true;\n        }\n        if (parsedShadowGenerator.contactHardeningLightSizeUVRatio !== undefined) {\n            shadowGenerator.contactHardeningLightSizeUVRatio = parsedShadowGenerator.contactHardeningLightSizeUVRatio;\n        }\n        if (parsedShadowGenerator.filteringQuality !== undefined) {\n            shadowGenerator.filteringQuality = parsedShadowGenerator.filteringQuality;\n        }\n        if (parsedShadowGenerator.depthScale) {\n            shadowGenerator.depthScale = parsedShadowGenerator.depthScale;\n        }\n        if (parsedShadowGenerator.blurScale) {\n            shadowGenerator.blurScale = parsedShadowGenerator.blurScale;\n        }\n        if (parsedShadowGenerator.blurBoxOffset) {\n            shadowGenerator.blurBoxOffset = parsedShadowGenerator.blurBoxOffset;\n        }\n        if (parsedShadowGenerator.useKernelBlur) {\n            shadowGenerator.useKernelBlur = parsedShadowGenerator.useKernelBlur;\n        }\n        if (parsedShadowGenerator.blurKernel) {\n            shadowGenerator.blurKernel = parsedShadowGenerator.blurKernel;\n        }\n        return shadowGenerator;\n    }\n}\n/**\n * Name of the shadow generator class\n */\nShadowGenerator.CLASSNAME = \"ShadowGenerator\";\n/**\n * Shadow generator mode None: no filtering applied.\n */\nShadowGenerator.FILTER_NONE = 0;\n/**\n * Shadow generator mode ESM: Exponential Shadow Mapping.\n * (http://developer.download.nvidia.com/presentations/2008/GDC/GDC08_SoftShadowMapping.pdf)\n */\nShadowGenerator.FILTER_EXPONENTIALSHADOWMAP = 1;\n/**\n * Shadow generator mode Poisson Sampling: Percentage Closer Filtering.\n * (Multiple Tap around evenly distributed around the pixel are used to evaluate the shadow strength)\n */\nShadowGenerator.FILTER_POISSONSAMPLING = 2;\n/**\n * Shadow generator mode ESM: Blurred Exponential Shadow Mapping.\n * (http://developer.download.nvidia.com/presentations/2008/GDC/GDC08_SoftShadowMapping.pdf)\n */\nShadowGenerator.FILTER_BLUREXPONENTIALSHADOWMAP = 3;\n/**\n * Shadow generator mode ESM: Exponential Shadow Mapping using the inverse of the exponential preventing\n * edge artifacts on steep falloff.\n * (http://developer.download.nvidia.com/presentations/2008/GDC/GDC08_SoftShadowMapping.pdf)\n */\nShadowGenerator.FILTER_CLOSEEXPONENTIALSHADOWMAP = 4;\n/**\n * Shadow generator mode ESM: Blurred Exponential Shadow Mapping using the inverse of the exponential preventing\n * edge artifacts on steep falloff.\n * (http://developer.download.nvidia.com/presentations/2008/GDC/GDC08_SoftShadowMapping.pdf)\n */\nShadowGenerator.FILTER_BLURCLOSEEXPONENTIALSHADOWMAP = 5;\n/**\n * Shadow generator mode PCF: Percentage Closer Filtering\n * benefits from Webgl 2 shadow samplers. Fallback to Poisson Sampling in Webgl 1\n * (https://developer.nvidia.com/gpugems/GPUGems/gpugems_ch11.html)\n */\nShadowGenerator.FILTER_PCF = 6;\n/**\n * Shadow generator mode PCSS: Percentage Closering Soft Shadow.\n * benefits from Webgl 2 shadow samplers. Fallback to Poisson Sampling in Webgl 1\n * Contact Hardening\n */\nShadowGenerator.FILTER_PCSS = 7;\n/**\n * Reserved for PCF and PCSS\n * Highest Quality.\n *\n * Execute PCF on a 5*5 kernel improving a lot the shadow aliasing artifacts.\n *\n * Execute PCSS with 32 taps blocker search and 64 taps PCF.\n */\nShadowGenerator.QUALITY_HIGH = 0;\n/**\n * Reserved for PCF and PCSS\n * Good tradeoff for quality/perf cross devices\n *\n * Execute PCF on a 3*3 kernel.\n *\n * Execute PCSS with 16 taps blocker search and 32 taps PCF.\n */\nShadowGenerator.QUALITY_MEDIUM = 1;\n/**\n * Reserved for PCF and PCSS\n * The lowest quality but the fastest.\n *\n * Execute PCF on a 1*1 kernel.\n *\n * Execute PCSS with 16 taps blocker search and 16 taps PCF.\n */\nShadowGenerator.QUALITY_LOW = 2;\n/**\n * Defines the default alpha cutoff value used for transparent alpha tested materials.\n */\nShadowGenerator.DEFAULT_ALPHA_CUTOFF = 0.5;\n/**\n * @internal\n */\nShadowGenerator._SceneComponentInitialization = (_) => {\n    throw _WarnImport(\"ShadowGeneratorSceneComponent\");\n};\n//# sourceMappingURL=shadowGenerator.js.map","import { __decorate } from \"../tslib.es6.js\";\nimport { serialize } from \"../Misc/decorators.js\";\nimport { Matrix, Vector3 } from \"../Maths/math.vector.js\";\nimport { Node } from \"../node.js\";\nimport { Light } from \"./light.js\";\nimport { ShadowLight } from \"./shadowLight.js\";\nNode.AddNodeConstructor(\"Light_Type_1\", (name, scene) => {\n    return () => new DirectionalLight(name, Vector3.Zero(), scene);\n});\n/**\n * A directional light is defined by a direction (what a surprise!).\n * The light is emitted from everywhere in the specified direction, and has an infinite range.\n * An example of a directional light is when a distance planet is lit by the apparently parallel lines of light from its sun. Light in a downward direction will light the top of an object.\n * Documentation: https://doc.babylonjs.com/features/featuresDeepDive/lights/lights_introduction\n */\nexport class DirectionalLight extends ShadowLight {\n    /**\n     * Fix frustum size for the shadow generation. This is disabled if the value is 0.\n     */\n    get shadowFrustumSize() {\n        return this._shadowFrustumSize;\n    }\n    /**\n     * Specifies a fix frustum size for the shadow generation.\n     */\n    set shadowFrustumSize(value) {\n        this._shadowFrustumSize = value;\n        this.forceProjectionMatrixCompute();\n    }\n    /**\n     * Gets the shadow projection scale against the optimal computed one.\n     * 0.1 by default which means that the projection window is increase by 10% from the optimal size.\n     * This does not impact in fixed frustum size (shadowFrustumSize being set)\n     */\n    get shadowOrthoScale() {\n        return this._shadowOrthoScale;\n    }\n    /**\n     * Sets the shadow projection scale against the optimal computed one.\n     * 0.1 by default which means that the projection window is increase by 10% from the optimal size.\n     * This does not impact in fixed frustum size (shadowFrustumSize being set)\n     */\n    set shadowOrthoScale(value) {\n        this._shadowOrthoScale = value;\n        this.forceProjectionMatrixCompute();\n    }\n    /**\n     * Gets or sets the orthoLeft property used to build the light frustum\n     */\n    get orthoLeft() {\n        return this._orthoLeft;\n    }\n    set orthoLeft(left) {\n        this._orthoLeft = left;\n    }\n    /**\n     * Gets or sets the orthoRight property used to build the light frustum\n     */\n    get orthoRight() {\n        return this._orthoRight;\n    }\n    set orthoRight(right) {\n        this._orthoRight = right;\n    }\n    /**\n     * Gets or sets the orthoTop property used to build the light frustum\n     */\n    get orthoTop() {\n        return this._orthoTop;\n    }\n    set orthoTop(top) {\n        this._orthoTop = top;\n    }\n    /**\n     * Gets or sets the orthoBottom property used to build the light frustum\n     */\n    get orthoBottom() {\n        return this._orthoBottom;\n    }\n    set orthoBottom(bottom) {\n        this._orthoBottom = bottom;\n    }\n    /**\n     * Creates a DirectionalLight object in the scene, oriented towards the passed direction (Vector3).\n     * The directional light is emitted from everywhere in the given direction.\n     * It can cast shadows.\n     * Documentation : https://doc.babylonjs.com/features/featuresDeepDive/lights/lights_introduction\n     * @param name The friendly name of the light\n     * @param direction The direction of the light\n     * @param scene The scene the light belongs to\n     */\n    constructor(name, direction, scene) {\n        super(name, scene);\n        this._shadowFrustumSize = 0;\n        this._shadowOrthoScale = 0.1;\n        /**\n         * Automatically compute the projection matrix to best fit (including all the casters)\n         * on each frame.\n         */\n        this.autoUpdateExtends = true;\n        /**\n         * Automatically compute the shadowMinZ and shadowMaxZ for the projection matrix to best fit (including all the casters)\n         * on each frame. autoUpdateExtends must be set to true for this to work\n         */\n        this.autoCalcShadowZBounds = false;\n        // Cache\n        this._orthoLeft = Number.MAX_VALUE;\n        this._orthoRight = Number.MIN_VALUE;\n        this._orthoTop = Number.MIN_VALUE;\n        this._orthoBottom = Number.MAX_VALUE;\n        this.position = direction.scale(-1.0);\n        this.direction = direction;\n    }\n    /**\n     * Returns the string \"DirectionalLight\".\n     * @returns The class name\n     */\n    getClassName() {\n        return \"DirectionalLight\";\n    }\n    /**\n     * Returns the integer 1.\n     * @returns The light Type id as a constant defines in Light.LIGHTTYPEID_x\n     */\n    getTypeID() {\n        return Light.LIGHTTYPEID_DIRECTIONALLIGHT;\n    }\n    /**\n     * Sets the passed matrix \"matrix\" as projection matrix for the shadows cast by the light according to the passed view matrix.\n     * Returns the DirectionalLight Shadow projection matrix.\n     * @param matrix\n     * @param viewMatrix\n     * @param renderList\n     */\n    _setDefaultShadowProjectionMatrix(matrix, viewMatrix, renderList) {\n        if (this.shadowFrustumSize > 0) {\n            this._setDefaultFixedFrustumShadowProjectionMatrix(matrix);\n        }\n        else {\n            this._setDefaultAutoExtendShadowProjectionMatrix(matrix, viewMatrix, renderList);\n        }\n    }\n    /**\n     * Sets the passed matrix \"matrix\" as fixed frustum projection matrix for the shadows cast by the light according to the passed view matrix.\n     * Returns the DirectionalLight Shadow projection matrix.\n     * @param matrix\n     */\n    _setDefaultFixedFrustumShadowProjectionMatrix(matrix) {\n        const activeCamera = this.getScene().activeCamera;\n        if (!activeCamera) {\n            return;\n        }\n        Matrix.OrthoLHToRef(this.shadowFrustumSize, this.shadowFrustumSize, this.shadowMinZ !== undefined ? this.shadowMinZ : activeCamera.minZ, this.shadowMaxZ !== undefined ? this.shadowMaxZ : activeCamera.maxZ, matrix, this.getScene().getEngine().isNDCHalfZRange);\n    }\n    /**\n     * Sets the passed matrix \"matrix\" as auto extend projection matrix for the shadows cast by the light according to the passed view matrix.\n     * Returns the DirectionalLight Shadow projection matrix.\n     * @param matrix\n     * @param viewMatrix\n     * @param renderList\n     */\n    _setDefaultAutoExtendShadowProjectionMatrix(matrix, viewMatrix, renderList) {\n        const activeCamera = this.getScene().activeCamera;\n        if (!activeCamera) {\n            return;\n        }\n        // Check extends\n        if (this.autoUpdateExtends || this._orthoLeft === Number.MAX_VALUE) {\n            const tempVector3 = Vector3.Zero();\n            this._orthoLeft = Number.MAX_VALUE;\n            this._orthoRight = Number.MIN_VALUE;\n            this._orthoTop = Number.MIN_VALUE;\n            this._orthoBottom = Number.MAX_VALUE;\n            let shadowMinZ = Number.MAX_VALUE;\n            let shadowMaxZ = Number.MIN_VALUE;\n            for (let meshIndex = 0; meshIndex < renderList.length; meshIndex++) {\n                const mesh = renderList[meshIndex];\n                if (!mesh) {\n                    continue;\n                }\n                const boundingInfo = mesh.getBoundingInfo();\n                const boundingBox = boundingInfo.boundingBox;\n                for (let index = 0; index < boundingBox.vectorsWorld.length; index++) {\n                    Vector3.TransformCoordinatesToRef(boundingBox.vectorsWorld[index], viewMatrix, tempVector3);\n                    if (tempVector3.x < this._orthoLeft) {\n                        this._orthoLeft = tempVector3.x;\n                    }\n                    if (tempVector3.y < this._orthoBottom) {\n                        this._orthoBottom = tempVector3.y;\n                    }\n                    if (tempVector3.x > this._orthoRight) {\n                        this._orthoRight = tempVector3.x;\n                    }\n                    if (tempVector3.y > this._orthoTop) {\n                        this._orthoTop = tempVector3.y;\n                    }\n                    if (this.autoCalcShadowZBounds) {\n                        if (tempVector3.z < shadowMinZ) {\n                            shadowMinZ = tempVector3.z;\n                        }\n                        if (tempVector3.z > shadowMaxZ) {\n                            shadowMaxZ = tempVector3.z;\n                        }\n                    }\n                }\n            }\n            if (this.autoCalcShadowZBounds) {\n                this._shadowMinZ = shadowMinZ;\n                this._shadowMaxZ = shadowMaxZ;\n            }\n        }\n        const xOffset = this._orthoRight - this._orthoLeft;\n        const yOffset = this._orthoTop - this._orthoBottom;\n        const minZ = this.shadowMinZ !== undefined ? this.shadowMinZ : activeCamera.minZ;\n        const maxZ = this.shadowMaxZ !== undefined ? this.shadowMaxZ : activeCamera.maxZ;\n        const useReverseDepthBuffer = this.getScene().getEngine().useReverseDepthBuffer;\n        Matrix.OrthoOffCenterLHToRef(this._orthoLeft - xOffset * this.shadowOrthoScale, this._orthoRight + xOffset * this.shadowOrthoScale, this._orthoBottom - yOffset * this.shadowOrthoScale, this._orthoTop + yOffset * this.shadowOrthoScale, useReverseDepthBuffer ? maxZ : minZ, useReverseDepthBuffer ? minZ : maxZ, matrix, this.getScene().getEngine().isNDCHalfZRange);\n    }\n    _buildUniformLayout() {\n        this._uniformBuffer.addUniform(\"vLightData\", 4);\n        this._uniformBuffer.addUniform(\"vLightDiffuse\", 4);\n        this._uniformBuffer.addUniform(\"vLightSpecular\", 4);\n        this._uniformBuffer.addUniform(\"shadowsInfo\", 3);\n        this._uniformBuffer.addUniform(\"depthValues\", 2);\n        this._uniformBuffer.create();\n    }\n    /**\n     * Sets the passed Effect object with the DirectionalLight transformed position (or position if not parented) and the passed name.\n     * @param effect The effect to update\n     * @param lightIndex The index of the light in the effect to update\n     * @returns The directional light\n     */\n    transferToEffect(effect, lightIndex) {\n        if (this.computeTransformedInformation()) {\n            this._uniformBuffer.updateFloat4(\"vLightData\", this.transformedDirection.x, this.transformedDirection.y, this.transformedDirection.z, 1, lightIndex);\n            return this;\n        }\n        this._uniformBuffer.updateFloat4(\"vLightData\", this.direction.x, this.direction.y, this.direction.z, 1, lightIndex);\n        return this;\n    }\n    transferToNodeMaterialEffect(effect, lightDataUniformName) {\n        if (this.computeTransformedInformation()) {\n            effect.setFloat3(lightDataUniformName, this.transformedDirection.x, this.transformedDirection.y, this.transformedDirection.z);\n            return this;\n        }\n        effect.setFloat3(lightDataUniformName, this.direction.x, this.direction.y, this.direction.z);\n        return this;\n    }\n    /**\n     * Gets the minZ used for shadow according to both the scene and the light.\n     *\n     * Values are fixed on directional lights as it relies on an ortho projection hence the need to convert being\n     * -1 and 1 to 0 and 1 doing (depth + min) / (min + max) -> (depth + 1) / (1 + 1) -> (depth * 0.5) + 0.5.\n     * (when not using reverse depth buffer / NDC half Z range)\n     * @param activeCamera The camera we are returning the min for\n     * @returns the depth min z\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    getDepthMinZ(activeCamera) {\n        const engine = this._scene.getEngine();\n        return !engine.useReverseDepthBuffer && engine.isNDCHalfZRange ? 0 : 1;\n    }\n    /**\n     * Gets the maxZ used for shadow according to both the scene and the light.\n     *\n     * Values are fixed on directional lights as it relies on an ortho projection hence the need to convert being\n     * -1 and 1 to 0 and 1 doing (depth + min) / (min + max) -> (depth + 1) / (1 + 1) -> (depth * 0.5) + 0.5.\n     * (when not using reverse depth buffer / NDC half Z range)\n     * @param activeCamera The camera we are returning the max for\n     * @returns the depth max z\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    getDepthMaxZ(activeCamera) {\n        const engine = this._scene.getEngine();\n        return engine.useReverseDepthBuffer && engine.isNDCHalfZRange ? 0 : 1;\n    }\n    /**\n     * Prepares the list of defines specific to the light type.\n     * @param defines the list of defines\n     * @param lightIndex defines the index of the light for the effect\n     */\n    prepareLightSpecificDefines(defines, lightIndex) {\n        defines[\"DIRLIGHT\" + lightIndex] = true;\n    }\n}\n__decorate([\n    serialize()\n], DirectionalLight.prototype, \"shadowFrustumSize\", null);\n__decorate([\n    serialize()\n], DirectionalLight.prototype, \"shadowOrthoScale\", null);\n__decorate([\n    serialize()\n], DirectionalLight.prototype, \"autoUpdateExtends\", void 0);\n__decorate([\n    serialize()\n], DirectionalLight.prototype, \"autoCalcShadowZBounds\", void 0);\n__decorate([\n    serialize(\"orthoLeft\")\n], DirectionalLight.prototype, \"_orthoLeft\", void 0);\n__decorate([\n    serialize(\"orthoRight\")\n], DirectionalLight.prototype, \"_orthoRight\", void 0);\n__decorate([\n    serialize(\"orthoTop\")\n], DirectionalLight.prototype, \"_orthoTop\", void 0);\n__decorate([\n    serialize(\"orthoBottom\")\n], DirectionalLight.prototype, \"_orthoBottom\", void 0);\n//# sourceMappingURL=directionalLight.js.map","import { __decorate } from \"../tslib.es6.js\";\nimport { serializeAsColor3, serializeAsVector3 } from \"../Misc/decorators.js\";\nimport { Matrix, Vector3 } from \"../Maths/math.vector.js\";\nimport { Color3 } from \"../Maths/math.color.js\";\nimport { Node } from \"../node.js\";\nimport { Light } from \"./light.js\";\nNode.AddNodeConstructor(\"Light_Type_3\", (name, scene) => {\n    return () => new HemisphericLight(name, Vector3.Zero(), scene);\n});\n/**\n * The HemisphericLight simulates the ambient environment light,\n * so the passed direction is the light reflection direction, not the incoming direction.\n */\nexport class HemisphericLight extends Light {\n    /**\n     * Creates a HemisphericLight object in the scene according to the passed direction (Vector3).\n     * The HemisphericLight simulates the ambient environment light, so the passed direction is the light reflection direction, not the incoming direction.\n     * The HemisphericLight can't cast shadows.\n     * Documentation : https://doc.babylonjs.com/features/featuresDeepDive/lights/lights_introduction\n     * @param name The friendly name of the light\n     * @param direction The direction of the light reflection\n     * @param scene The scene the light belongs to\n     */\n    constructor(name, direction, scene) {\n        super(name, scene);\n        /**\n         * The groundColor is the light in the opposite direction to the one specified during creation.\n         * You can think of the diffuse and specular light as coming from the centre of the object in the given direction and the groundColor light in the opposite direction.\n         */\n        this.groundColor = new Color3(0.0, 0.0, 0.0);\n        this.direction = direction || Vector3.Up();\n    }\n    _buildUniformLayout() {\n        this._uniformBuffer.addUniform(\"vLightData\", 4);\n        this._uniformBuffer.addUniform(\"vLightDiffuse\", 4);\n        this._uniformBuffer.addUniform(\"vLightSpecular\", 4);\n        this._uniformBuffer.addUniform(\"vLightGround\", 3);\n        this._uniformBuffer.addUniform(\"shadowsInfo\", 3);\n        this._uniformBuffer.addUniform(\"depthValues\", 2);\n        this._uniformBuffer.create();\n    }\n    /**\n     * Returns the string \"HemisphericLight\".\n     * @returns The class name\n     */\n    getClassName() {\n        return \"HemisphericLight\";\n    }\n    /**\n     * Sets the HemisphericLight direction towards the passed target (Vector3).\n     * Returns the updated direction.\n     * @param target The target the direction should point to\n     * @returns The computed direction\n     */\n    setDirectionToTarget(target) {\n        this.direction = Vector3.Normalize(target.subtract(Vector3.Zero()));\n        return this.direction;\n    }\n    /**\n     * Returns the shadow generator associated to the light.\n     * @returns Always null for hemispheric lights because it does not support shadows.\n     */\n    getShadowGenerator() {\n        return null;\n    }\n    /**\n     * Sets the passed Effect object with the HemisphericLight normalized direction and color and the passed name (string).\n     * @param _effect The effect to update\n     * @param lightIndex The index of the light in the effect to update\n     * @returns The hemispheric light\n     */\n    transferToEffect(_effect, lightIndex) {\n        const normalizeDirection = Vector3.Normalize(this.direction);\n        this._uniformBuffer.updateFloat4(\"vLightData\", normalizeDirection.x, normalizeDirection.y, normalizeDirection.z, 0.0, lightIndex);\n        this._uniformBuffer.updateColor3(\"vLightGround\", this.groundColor.scale(this.intensity), lightIndex);\n        return this;\n    }\n    transferToNodeMaterialEffect(effect, lightDataUniformName) {\n        const normalizeDirection = Vector3.Normalize(this.direction);\n        effect.setFloat3(lightDataUniformName, normalizeDirection.x, normalizeDirection.y, normalizeDirection.z);\n        return this;\n    }\n    /**\n     * Computes the world matrix of the node\n     * @returns the world matrix\n     */\n    computeWorldMatrix() {\n        if (!this._worldMatrix) {\n            this._worldMatrix = Matrix.Identity();\n        }\n        return this._worldMatrix;\n    }\n    /**\n     * Returns the integer 3.\n     * @returns The light Type id as a constant defines in Light.LIGHTTYPEID_x\n     */\n    getTypeID() {\n        return Light.LIGHTTYPEID_HEMISPHERICLIGHT;\n    }\n    /**\n     * Prepares the list of defines specific to the light type.\n     * @param defines the list of defines\n     * @param lightIndex defines the index of the light for the effect\n     */\n    prepareLightSpecificDefines(defines, lightIndex) {\n        defines[\"HEMILIGHT\" + lightIndex] = true;\n    }\n}\n__decorate([\n    serializeAsColor3()\n], HemisphericLight.prototype, \"groundColor\", void 0);\n__decorate([\n    serializeAsVector3()\n], HemisphericLight.prototype, \"direction\", void 0);\n//# sourceMappingURL=hemisphericLight.js.map","import { __decorate } from \"../tslib.es6.js\";\nimport { serialize, SerializationHelper, serializeAsColor3, expandToProperty } from \"../Misc/decorators.js\";\nimport { Vector3 } from \"../Maths/math.vector.js\";\nimport { Color3, TmpColors } from \"../Maths/math.color.js\";\nimport { Node } from \"../node.js\";\nimport { UniformBuffer } from \"../Materials/uniformBuffer.js\";\nimport { GetClass } from \"../Misc/typeStore.js\";\nimport { LightConstants } from \"./lightConstants.js\";\n/**\n * Base class of all the lights in Babylon. It groups all the generic information about lights.\n * Lights are used, as you would expect, to affect how meshes are seen, in terms of both illumination and colour.\n * All meshes allow light to pass through them unless shadow generation is activated. The default number of lights allowed is four but this can be increased.\n */\nexport class Light extends Node {\n    /**\n     * Defines how far from the source the light is impacting in scene units.\n     * Note: Unused in PBR material as the distance light falloff is defined following the inverse squared falloff.\n     */\n    get range() {\n        return this._range;\n    }\n    /**\n     * Defines how far from the source the light is impacting in scene units.\n     * Note: Unused in PBR material as the distance light falloff is defined following the inverse squared falloff.\n     */\n    set range(value) {\n        this._range = value;\n        this._inverseSquaredRange = 1.0 / (this.range * this.range);\n    }\n    /**\n     * Gets the photometric scale used to interpret the intensity.\n     * This is only relevant with PBR Materials where the light intensity can be defined in a physical way.\n     */\n    get intensityMode() {\n        return this._intensityMode;\n    }\n    /**\n     * Sets the photometric scale used to interpret the intensity.\n     * This is only relevant with PBR Materials where the light intensity can be defined in a physical way.\n     */\n    set intensityMode(value) {\n        this._intensityMode = value;\n        this._computePhotometricScale();\n    }\n    /**\n     * Gets the light radius used by PBR Materials to simulate soft area lights.\n     */\n    get radius() {\n        return this._radius;\n    }\n    /**\n     * sets the light radius used by PBR Materials to simulate soft area lights.\n     */\n    set radius(value) {\n        this._radius = value;\n        this._computePhotometricScale();\n    }\n    /**\n     * Gets whether or not the shadows are enabled for this light. This can help turning off/on shadow without detaching\n     * the current shadow generator.\n     */\n    get shadowEnabled() {\n        return this._shadowEnabled;\n    }\n    /**\n     * Sets whether or not the shadows are enabled for this light. This can help turning off/on shadow without detaching\n     * the current shadow generator.\n     */\n    set shadowEnabled(value) {\n        if (this._shadowEnabled === value) {\n            return;\n        }\n        this._shadowEnabled = value;\n        this._markMeshesAsLightDirty();\n    }\n    /**\n     * Gets the only meshes impacted by this light.\n     */\n    get includedOnlyMeshes() {\n        return this._includedOnlyMeshes;\n    }\n    /**\n     * Sets the only meshes impacted by this light.\n     */\n    set includedOnlyMeshes(value) {\n        this._includedOnlyMeshes = value;\n        this._hookArrayForIncludedOnly(value);\n    }\n    /**\n     * Gets the meshes not impacted by this light.\n     */\n    get excludedMeshes() {\n        return this._excludedMeshes;\n    }\n    /**\n     * Sets the meshes not impacted by this light.\n     */\n    set excludedMeshes(value) {\n        this._excludedMeshes = value;\n        this._hookArrayForExcluded(value);\n    }\n    /**\n     * Gets the layer id use to find what meshes are not impacted by the light.\n     * Inactive if 0\n     */\n    get excludeWithLayerMask() {\n        return this._excludeWithLayerMask;\n    }\n    /**\n     * Sets the layer id use to find what meshes are not impacted by the light.\n     * Inactive if 0\n     */\n    set excludeWithLayerMask(value) {\n        this._excludeWithLayerMask = value;\n        this._resyncMeshes();\n    }\n    /**\n     * Gets the layer id use to find what meshes are impacted by the light.\n     * Inactive if 0\n     */\n    get includeOnlyWithLayerMask() {\n        return this._includeOnlyWithLayerMask;\n    }\n    /**\n     * Sets the layer id use to find what meshes are impacted by the light.\n     * Inactive if 0\n     */\n    set includeOnlyWithLayerMask(value) {\n        this._includeOnlyWithLayerMask = value;\n        this._resyncMeshes();\n    }\n    /**\n     * Gets the lightmap mode of this light (should be one of the constants defined by Light.LIGHTMAP_x)\n     */\n    get lightmapMode() {\n        return this._lightmapMode;\n    }\n    /**\n     * Sets the lightmap mode of this light (should be one of the constants defined by Light.LIGHTMAP_x)\n     */\n    set lightmapMode(value) {\n        if (this._lightmapMode === value) {\n            return;\n        }\n        this._lightmapMode = value;\n        this._markMeshesAsLightDirty();\n    }\n    /**\n     * Creates a Light object in the scene.\n     * Documentation : https://doc.babylonjs.com/features/featuresDeepDive/lights/lights_introduction\n     * @param name The friendly name of the light\n     * @param scene The scene the light belongs too\n     */\n    constructor(name, scene) {\n        super(name, scene);\n        /**\n         * Diffuse gives the basic color to an object.\n         */\n        this.diffuse = new Color3(1.0, 1.0, 1.0);\n        /**\n         * Specular produces a highlight color on an object.\n         * Note: This is not affecting PBR materials.\n         */\n        this.specular = new Color3(1.0, 1.0, 1.0);\n        /**\n         * Defines the falloff type for this light. This lets overriding how punctual light are\n         * falling off base on range or angle.\n         * This can be set to any values in Light.FALLOFF_x.\n         *\n         * Note: This is only useful for PBR Materials at the moment. This could be extended if required to\n         * other types of materials.\n         */\n        this.falloffType = Light.FALLOFF_DEFAULT;\n        /**\n         * Strength of the light.\n         * Note: By default it is define in the framework own unit.\n         * Note: In PBR materials the intensityMode can be use to chose what unit the intensity is defined in.\n         */\n        this.intensity = 1.0;\n        this._range = Number.MAX_VALUE;\n        this._inverseSquaredRange = 0;\n        /**\n         * Cached photometric scale default to 1.0 as the automatic intensity mode defaults to 1.0 for every type\n         * of light.\n         */\n        this._photometricScale = 1.0;\n        this._intensityMode = Light.INTENSITYMODE_AUTOMATIC;\n        this._radius = 0.00001;\n        /**\n         * Defines the rendering priority of the lights. It can help in case of fallback or number of lights\n         * exceeding the number allowed of the materials.\n         */\n        this.renderPriority = 0;\n        this._shadowEnabled = true;\n        this._excludeWithLayerMask = 0;\n        this._includeOnlyWithLayerMask = 0;\n        this._lightmapMode = 0;\n        /**\n         * Shadow generators associated to the light.\n         * @internal Internal use only.\n         */\n        this._shadowGenerators = null;\n        /**\n         * @internal Internal use only.\n         */\n        this._excludedMeshesIds = new Array();\n        /**\n         * @internal Internal use only.\n         */\n        this._includedOnlyMeshesIds = new Array();\n        /** @internal */\n        this._isLight = true;\n        this.getScene().addLight(this);\n        this._uniformBuffer = new UniformBuffer(this.getScene().getEngine(), undefined, undefined, name);\n        this._buildUniformLayout();\n        this.includedOnlyMeshes = new Array();\n        this.excludedMeshes = new Array();\n        this._resyncMeshes();\n    }\n    /**\n     * Sets the passed Effect \"effect\" with the Light textures.\n     * @param effect The effect to update\n     * @param lightIndex The index of the light in the effect to update\n     * @returns The light\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    transferTexturesToEffect(effect, lightIndex) {\n        // Do nothing by default.\n        return this;\n    }\n    /**\n     * Binds the lights information from the scene to the effect for the given mesh.\n     * @param lightIndex Light index\n     * @param scene The scene where the light belongs to\n     * @param effect The effect we are binding the data to\n     * @param useSpecular Defines if specular is supported\n     * @param receiveShadows Defines if the effect (mesh) we bind the light for receives shadows\n     */\n    _bindLight(lightIndex, scene, effect, useSpecular, receiveShadows = true) {\n        var _a;\n        const iAsString = lightIndex.toString();\n        let needUpdate = false;\n        this._uniformBuffer.bindToEffect(effect, \"Light\" + iAsString);\n        if (this._renderId !== scene.getRenderId() || this._lastUseSpecular !== useSpecular || !this._uniformBuffer.useUbo) {\n            this._renderId = scene.getRenderId();\n            this._lastUseSpecular = useSpecular;\n            const scaledIntensity = this.getScaledIntensity();\n            this.transferToEffect(effect, iAsString);\n            this.diffuse.scaleToRef(scaledIntensity, TmpColors.Color3[0]);\n            this._uniformBuffer.updateColor4(\"vLightDiffuse\", TmpColors.Color3[0], this.range, iAsString);\n            if (useSpecular) {\n                this.specular.scaleToRef(scaledIntensity, TmpColors.Color3[1]);\n                this._uniformBuffer.updateColor4(\"vLightSpecular\", TmpColors.Color3[1], this.radius, iAsString);\n            }\n            needUpdate = true;\n        }\n        // Textures might still need to be rebound.\n        this.transferTexturesToEffect(effect, iAsString);\n        // Shadows\n        if (scene.shadowsEnabled && this.shadowEnabled && receiveShadows) {\n            const shadowGenerator = (_a = this.getShadowGenerator(scene.activeCamera)) !== null && _a !== void 0 ? _a : this.getShadowGenerator();\n            if (shadowGenerator) {\n                shadowGenerator.bindShadowLight(iAsString, effect);\n                needUpdate = true;\n            }\n        }\n        if (needUpdate) {\n            this._uniformBuffer.update();\n        }\n        else {\n            this._uniformBuffer.bindUniformBuffer();\n        }\n    }\n    /**\n     * Returns the string \"Light\".\n     * @returns the class name\n     */\n    getClassName() {\n        return \"Light\";\n    }\n    /**\n     * Converts the light information to a readable string for debug purpose.\n     * @param fullDetails Supports for multiple levels of logging within scene loading\n     * @returns the human readable light info\n     */\n    toString(fullDetails) {\n        let ret = \"Name: \" + this.name;\n        ret += \", type: \" + [\"Point\", \"Directional\", \"Spot\", \"Hemispheric\"][this.getTypeID()];\n        if (this.animations) {\n            for (let i = 0; i < this.animations.length; i++) {\n                ret += \", animation[0]: \" + this.animations[i].toString(fullDetails);\n            }\n        }\n        return ret;\n    }\n    /** @internal */\n    _syncParentEnabledState() {\n        super._syncParentEnabledState();\n        if (!this.isDisposed()) {\n            this._resyncMeshes();\n        }\n    }\n    /**\n     * Set the enabled state of this node.\n     * @param value - the new enabled state\n     */\n    setEnabled(value) {\n        super.setEnabled(value);\n        this._resyncMeshes();\n    }\n    /**\n     * Returns the Light associated shadow generator if any.\n     * @param camera Camera for which the shadow generator should be retrieved (default: null). If null, retrieves the default shadow generator\n     * @returns the associated shadow generator.\n     */\n    getShadowGenerator(camera = null) {\n        var _a;\n        if (this._shadowGenerators === null) {\n            return null;\n        }\n        return (_a = this._shadowGenerators.get(camera)) !== null && _a !== void 0 ? _a : null;\n    }\n    /**\n     * Returns all the shadow generators associated to this light\n     * @returns\n     */\n    getShadowGenerators() {\n        return this._shadowGenerators;\n    }\n    /**\n     * Returns a Vector3, the absolute light position in the World.\n     * @returns the world space position of the light\n     */\n    getAbsolutePosition() {\n        return Vector3.Zero();\n    }\n    /**\n     * Specifies if the light will affect the passed mesh.\n     * @param mesh The mesh to test against the light\n     * @returns true the mesh is affected otherwise, false.\n     */\n    canAffectMesh(mesh) {\n        if (!mesh) {\n            return true;\n        }\n        if (this.includedOnlyMeshes && this.includedOnlyMeshes.length > 0 && this.includedOnlyMeshes.indexOf(mesh) === -1) {\n            return false;\n        }\n        if (this.excludedMeshes && this.excludedMeshes.length > 0 && this.excludedMeshes.indexOf(mesh) !== -1) {\n            return false;\n        }\n        if (this.includeOnlyWithLayerMask !== 0 && (this.includeOnlyWithLayerMask & mesh.layerMask) === 0) {\n            return false;\n        }\n        if (this.excludeWithLayerMask !== 0 && this.excludeWithLayerMask & mesh.layerMask) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Releases resources associated with this node.\n     * @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)\n     * @param disposeMaterialAndTextures Set to true to also dispose referenced materials and textures (false by default)\n     */\n    dispose(doNotRecurse, disposeMaterialAndTextures = false) {\n        if (this._shadowGenerators) {\n            const iterator = this._shadowGenerators.values();\n            for (let key = iterator.next(); key.done !== true; key = iterator.next()) {\n                const shadowGenerator = key.value;\n                shadowGenerator.dispose();\n            }\n            this._shadowGenerators = null;\n        }\n        // Animations\n        this.getScene().stopAnimation(this);\n        if (this._parentContainer) {\n            const index = this._parentContainer.lights.indexOf(this);\n            if (index > -1) {\n                this._parentContainer.lights.splice(index, 1);\n            }\n            this._parentContainer = null;\n        }\n        // Remove from meshes\n        for (const mesh of this.getScene().meshes) {\n            mesh._removeLightSource(this, true);\n        }\n        this._uniformBuffer.dispose();\n        // Remove from scene\n        this.getScene().removeLight(this);\n        super.dispose(doNotRecurse, disposeMaterialAndTextures);\n    }\n    /**\n     * Returns the light type ID (integer).\n     * @returns The light Type id as a constant defines in Light.LIGHTTYPEID_x\n     */\n    getTypeID() {\n        return 0;\n    }\n    /**\n     * Returns the intensity scaled by the Photometric Scale according to the light type and intensity mode.\n     * @returns the scaled intensity in intensity mode unit\n     */\n    getScaledIntensity() {\n        return this._photometricScale * this.intensity;\n    }\n    /**\n     * Returns a new Light object, named \"name\", from the current one.\n     * @param name The name of the cloned light\n     * @param newParent The parent of this light, if it has one\n     * @returns the new created light\n     */\n    clone(name, newParent = null) {\n        const constructor = Light.GetConstructorFromName(this.getTypeID(), name, this.getScene());\n        if (!constructor) {\n            return null;\n        }\n        const clonedLight = SerializationHelper.Clone(constructor, this);\n        if (name) {\n            clonedLight.name = name;\n        }\n        if (newParent) {\n            clonedLight.parent = newParent;\n        }\n        clonedLight.setEnabled(this.isEnabled());\n        this.onClonedObservable.notifyObservers(clonedLight);\n        return clonedLight;\n    }\n    /**\n     * Serializes the current light into a Serialization object.\n     * @returns the serialized object.\n     */\n    serialize() {\n        const serializationObject = SerializationHelper.Serialize(this);\n        serializationObject.uniqueId = this.uniqueId;\n        // Type\n        serializationObject.type = this.getTypeID();\n        // Parent\n        if (this.parent) {\n            this.parent._serializeAsParent(serializationObject);\n        }\n        // Inclusion / exclusions\n        if (this.excludedMeshes.length > 0) {\n            serializationObject.excludedMeshesIds = [];\n            this.excludedMeshes.forEach((mesh) => {\n                serializationObject.excludedMeshesIds.push(mesh.id);\n            });\n        }\n        if (this.includedOnlyMeshes.length > 0) {\n            serializationObject.includedOnlyMeshesIds = [];\n            this.includedOnlyMeshes.forEach((mesh) => {\n                serializationObject.includedOnlyMeshesIds.push(mesh.id);\n            });\n        }\n        // Animations\n        SerializationHelper.AppendSerializedAnimations(this, serializationObject);\n        serializationObject.ranges = this.serializeAnimationRanges();\n        serializationObject.isEnabled = this.isEnabled();\n        return serializationObject;\n    }\n    /**\n     * Creates a new typed light from the passed type (integer) : point light = 0, directional light = 1, spot light = 2, hemispheric light = 3.\n     * This new light is named \"name\" and added to the passed scene.\n     * @param type Type according to the types available in Light.LIGHTTYPEID_x\n     * @param name The friendly name of the light\n     * @param scene The scene the new light will belong to\n     * @returns the constructor function\n     */\n    static GetConstructorFromName(type, name, scene) {\n        const constructorFunc = Node.Construct(\"Light_Type_\" + type, name, scene);\n        if (constructorFunc) {\n            return constructorFunc;\n        }\n        // Default to no light for none present once.\n        return null;\n    }\n    /**\n     * Parses the passed \"parsedLight\" and returns a new instanced Light from this parsing.\n     * @param parsedLight The JSON representation of the light\n     * @param scene The scene to create the parsed light in\n     * @returns the created light after parsing\n     */\n    static Parse(parsedLight, scene) {\n        const constructor = Light.GetConstructorFromName(parsedLight.type, parsedLight.name, scene);\n        if (!constructor) {\n            return null;\n        }\n        const light = SerializationHelper.Parse(constructor, parsedLight, scene);\n        // Inclusion / exclusions\n        if (parsedLight.excludedMeshesIds) {\n            light._excludedMeshesIds = parsedLight.excludedMeshesIds;\n        }\n        if (parsedLight.includedOnlyMeshesIds) {\n            light._includedOnlyMeshesIds = parsedLight.includedOnlyMeshesIds;\n        }\n        // Parent\n        if (parsedLight.parentId !== undefined) {\n            light._waitingParentId = parsedLight.parentId;\n        }\n        if (parsedLight.parentInstanceIndex !== undefined) {\n            light._waitingParentInstanceIndex = parsedLight.parentInstanceIndex;\n        }\n        // Falloff\n        if (parsedLight.falloffType !== undefined) {\n            light.falloffType = parsedLight.falloffType;\n        }\n        // Lightmaps\n        if (parsedLight.lightmapMode !== undefined) {\n            light.lightmapMode = parsedLight.lightmapMode;\n        }\n        // Animations\n        if (parsedLight.animations) {\n            for (let animationIndex = 0; animationIndex < parsedLight.animations.length; animationIndex++) {\n                const parsedAnimation = parsedLight.animations[animationIndex];\n                const internalClass = GetClass(\"BABYLON.Animation\");\n                if (internalClass) {\n                    light.animations.push(internalClass.Parse(parsedAnimation));\n                }\n            }\n            Node.ParseAnimationRanges(light, parsedLight, scene);\n        }\n        if (parsedLight.autoAnimate) {\n            scene.beginAnimation(light, parsedLight.autoAnimateFrom, parsedLight.autoAnimateTo, parsedLight.autoAnimateLoop, parsedLight.autoAnimateSpeed || 1.0);\n        }\n        // Check if isEnabled is defined to be back compatible with prior serialized versions.\n        if (parsedLight.isEnabled !== undefined) {\n            light.setEnabled(parsedLight.isEnabled);\n        }\n        return light;\n    }\n    _hookArrayForExcluded(array) {\n        const oldPush = array.push;\n        array.push = (...items) => {\n            const result = oldPush.apply(array, items);\n            for (const item of items) {\n                item._resyncLightSource(this);\n            }\n            return result;\n        };\n        const oldSplice = array.splice;\n        array.splice = (index, deleteCount) => {\n            const deleted = oldSplice.apply(array, [index, deleteCount]);\n            for (const item of deleted) {\n                item._resyncLightSource(this);\n            }\n            return deleted;\n        };\n        for (const item of array) {\n            item._resyncLightSource(this);\n        }\n    }\n    _hookArrayForIncludedOnly(array) {\n        const oldPush = array.push;\n        array.push = (...items) => {\n            const result = oldPush.apply(array, items);\n            this._resyncMeshes();\n            return result;\n        };\n        const oldSplice = array.splice;\n        array.splice = (index, deleteCount) => {\n            const deleted = oldSplice.apply(array, [index, deleteCount]);\n            this._resyncMeshes();\n            return deleted;\n        };\n        this._resyncMeshes();\n    }\n    _resyncMeshes() {\n        for (const mesh of this.getScene().meshes) {\n            mesh._resyncLightSource(this);\n        }\n    }\n    /**\n     * Forces the meshes to update their light related information in their rendering used effects\n     * @internal Internal Use Only\n     */\n    _markMeshesAsLightDirty() {\n        for (const mesh of this.getScene().meshes) {\n            if (mesh.lightSources.indexOf(this) !== -1) {\n                mesh._markSubMeshesAsLightDirty();\n            }\n        }\n    }\n    /**\n     * Recomputes the cached photometric scale if needed.\n     */\n    _computePhotometricScale() {\n        this._photometricScale = this._getPhotometricScale();\n        this.getScene().resetCachedMaterial();\n    }\n    /**\n     * Returns the Photometric Scale according to the light type and intensity mode.\n     */\n    _getPhotometricScale() {\n        let photometricScale = 0.0;\n        const lightTypeID = this.getTypeID();\n        //get photometric mode\n        let photometricMode = this.intensityMode;\n        if (photometricMode === Light.INTENSITYMODE_AUTOMATIC) {\n            if (lightTypeID === Light.LIGHTTYPEID_DIRECTIONALLIGHT) {\n                photometricMode = Light.INTENSITYMODE_ILLUMINANCE;\n            }\n            else {\n                photometricMode = Light.INTENSITYMODE_LUMINOUSINTENSITY;\n            }\n        }\n        //compute photometric scale\n        switch (lightTypeID) {\n            case Light.LIGHTTYPEID_POINTLIGHT:\n            case Light.LIGHTTYPEID_SPOTLIGHT:\n                switch (photometricMode) {\n                    case Light.INTENSITYMODE_LUMINOUSPOWER:\n                        photometricScale = 1.0 / (4.0 * Math.PI);\n                        break;\n                    case Light.INTENSITYMODE_LUMINOUSINTENSITY:\n                        photometricScale = 1.0;\n                        break;\n                    case Light.INTENSITYMODE_LUMINANCE:\n                        photometricScale = this.radius * this.radius;\n                        break;\n                }\n                break;\n            case Light.LIGHTTYPEID_DIRECTIONALLIGHT:\n                switch (photometricMode) {\n                    case Light.INTENSITYMODE_ILLUMINANCE:\n                        photometricScale = 1.0;\n                        break;\n                    case Light.INTENSITYMODE_LUMINANCE: {\n                        // When radius (and therefore solid angle) is non-zero a directional lights brightness can be specified via central (peak) luminance.\n                        // For a directional light the 'radius' defines the angular radius (in radians) rather than world-space radius (e.g. in metres).\n                        let apexAngleRadians = this.radius;\n                        // Impose a minimum light angular size to avoid the light becoming an infinitely small angular light source (i.e. a dirac delta function).\n                        apexAngleRadians = Math.max(apexAngleRadians, 0.001);\n                        const solidAngle = 2.0 * Math.PI * (1.0 - Math.cos(apexAngleRadians));\n                        photometricScale = solidAngle;\n                        break;\n                    }\n                }\n                break;\n            case Light.LIGHTTYPEID_HEMISPHERICLIGHT:\n                // No fall off in hemispheric light.\n                photometricScale = 1.0;\n                break;\n        }\n        return photometricScale;\n    }\n    /**\n     * Reorder the light in the scene according to their defined priority.\n     * @internal Internal Use Only\n     */\n    _reorderLightsInScene() {\n        const scene = this.getScene();\n        if (this._renderPriority != 0) {\n            scene.requireLightSorting = true;\n        }\n        this.getScene().sortLightsByPriority();\n    }\n}\n/**\n * Falloff Default: light is falling off following the material specification:\n * standard material is using standard falloff whereas pbr material can request special falloff per materials.\n */\nLight.FALLOFF_DEFAULT = LightConstants.FALLOFF_DEFAULT;\n/**\n * Falloff Physical: light is falling off following the inverse squared distance law.\n */\nLight.FALLOFF_PHYSICAL = LightConstants.FALLOFF_PHYSICAL;\n/**\n * Falloff gltf: light is falling off as described in the gltf moving to PBR document\n * to enhance interoperability with other engines.\n */\nLight.FALLOFF_GLTF = LightConstants.FALLOFF_GLTF;\n/**\n * Falloff Standard: light is falling off like in the standard material\n * to enhance interoperability with other materials.\n */\nLight.FALLOFF_STANDARD = LightConstants.FALLOFF_STANDARD;\n//lightmapMode Consts\n/**\n * If every light affecting the material is in this lightmapMode,\n * material.lightmapTexture adds or multiplies\n * (depends on material.useLightmapAsShadowmap)\n * after every other light calculations.\n */\nLight.LIGHTMAP_DEFAULT = LightConstants.LIGHTMAP_DEFAULT;\n/**\n * material.lightmapTexture as only diffuse lighting from this light\n * adds only specular lighting from this light\n * adds dynamic shadows\n */\nLight.LIGHTMAP_SPECULAR = LightConstants.LIGHTMAP_SPECULAR;\n/**\n * material.lightmapTexture as only lighting\n * no light calculation from this light\n * only adds dynamic shadows from this light\n */\nLight.LIGHTMAP_SHADOWSONLY = LightConstants.LIGHTMAP_SHADOWSONLY;\n// Intensity Mode Consts\n/**\n * Each light type uses the default quantity according to its type:\n *      point/spot lights use luminous intensity\n *      directional lights use illuminance\n */\nLight.INTENSITYMODE_AUTOMATIC = LightConstants.INTENSITYMODE_AUTOMATIC;\n/**\n * lumen (lm)\n */\nLight.INTENSITYMODE_LUMINOUSPOWER = LightConstants.INTENSITYMODE_LUMINOUSPOWER;\n/**\n * candela (lm/sr)\n */\nLight.INTENSITYMODE_LUMINOUSINTENSITY = LightConstants.INTENSITYMODE_LUMINOUSINTENSITY;\n/**\n * lux (lm/m^2)\n */\nLight.INTENSITYMODE_ILLUMINANCE = LightConstants.INTENSITYMODE_ILLUMINANCE;\n/**\n * nit (cd/m^2)\n */\nLight.INTENSITYMODE_LUMINANCE = LightConstants.INTENSITYMODE_LUMINANCE;\n// Light types ids const.\n/**\n * Light type const id of the point light.\n */\nLight.LIGHTTYPEID_POINTLIGHT = LightConstants.LIGHTTYPEID_POINTLIGHT;\n/**\n * Light type const id of the directional light.\n */\nLight.LIGHTTYPEID_DIRECTIONALLIGHT = LightConstants.LIGHTTYPEID_DIRECTIONALLIGHT;\n/**\n * Light type const id of the spot light.\n */\nLight.LIGHTTYPEID_SPOTLIGHT = LightConstants.LIGHTTYPEID_SPOTLIGHT;\n/**\n * Light type const id of the hemispheric light.\n */\nLight.LIGHTTYPEID_HEMISPHERICLIGHT = LightConstants.LIGHTTYPEID_HEMISPHERICLIGHT;\n__decorate([\n    serializeAsColor3()\n], Light.prototype, \"diffuse\", void 0);\n__decorate([\n    serializeAsColor3()\n], Light.prototype, \"specular\", void 0);\n__decorate([\n    serialize()\n], Light.prototype, \"falloffType\", void 0);\n__decorate([\n    serialize()\n], Light.prototype, \"intensity\", void 0);\n__decorate([\n    serialize()\n], Light.prototype, \"range\", null);\n__decorate([\n    serialize()\n], Light.prototype, \"intensityMode\", null);\n__decorate([\n    serialize()\n], Light.prototype, \"radius\", null);\n__decorate([\n    serialize()\n], Light.prototype, \"_renderPriority\", void 0);\n__decorate([\n    expandToProperty(\"_reorderLightsInScene\")\n], Light.prototype, \"renderPriority\", void 0);\n__decorate([\n    serialize(\"shadowEnabled\")\n], Light.prototype, \"_shadowEnabled\", void 0);\n__decorate([\n    serialize(\"excludeWithLayerMask\")\n], Light.prototype, \"_excludeWithLayerMask\", void 0);\n__decorate([\n    serialize(\"includeOnlyWithLayerMask\")\n], Light.prototype, \"_includeOnlyWithLayerMask\", void 0);\n__decorate([\n    serialize(\"lightmapMode\")\n], Light.prototype, \"_lightmapMode\", void 0);\n//# sourceMappingURL=light.js.map","/** Defines the cross module constantsused by lights to avoid circular dependencies */\nexport class LightConstants {\n    /**\n     * Sort function to order lights for rendering.\n     * @param a First Light object to compare to second.\n     * @param b Second Light object to compare first.\n     * @returns -1 to reduce's a's index relative to be, 0 for no change, 1 to increase a's index relative to b.\n     */\n    static CompareLightsPriority(a, b) {\n        //shadow-casting lights have priority over non-shadow-casting lights\n        //the renderPriority is a secondary sort criterion\n        if (a.shadowEnabled !== b.shadowEnabled) {\n            return (b.shadowEnabled ? 1 : 0) - (a.shadowEnabled ? 1 : 0);\n        }\n        return b.renderPriority - a.renderPriority;\n    }\n}\n/**\n * Falloff Default: light is falling off following the material specification:\n * standard material is using standard falloff whereas pbr material can request special falloff per materials.\n */\nLightConstants.FALLOFF_DEFAULT = 0;\n/**\n * Falloff Physical: light is falling off following the inverse squared distance law.\n */\nLightConstants.FALLOFF_PHYSICAL = 1;\n/**\n * Falloff gltf: light is falling off as described in the gltf moving to PBR document\n * to enhance interoperability with other engines.\n */\nLightConstants.FALLOFF_GLTF = 2;\n/**\n * Falloff Standard: light is falling off like in the standard material\n * to enhance interoperability with other materials.\n */\nLightConstants.FALLOFF_STANDARD = 3;\n//lightmapMode Consts\n/**\n * If every light affecting the material is in this lightmapMode,\n * material.lightmapTexture adds or multiplies\n * (depends on material.useLightmapAsShadowmap)\n * after every other light calculations.\n */\nLightConstants.LIGHTMAP_DEFAULT = 0;\n/**\n * material.lightmapTexture as only diffuse lighting from this light\n * adds only specular lighting from this light\n * adds dynamic shadows\n */\nLightConstants.LIGHTMAP_SPECULAR = 1;\n/**\n * material.lightmapTexture as only lighting\n * no light calculation from this light\n * only adds dynamic shadows from this light\n */\nLightConstants.LIGHTMAP_SHADOWSONLY = 2;\n// Intensity Mode Consts\n/**\n * Each light type uses the default quantity according to its type:\n *      point/spot lights use luminous intensity\n *      directional lights use illuminance\n */\nLightConstants.INTENSITYMODE_AUTOMATIC = 0;\n/**\n * lumen (lm)\n */\nLightConstants.INTENSITYMODE_LUMINOUSPOWER = 1;\n/**\n * candela (lm/sr)\n */\nLightConstants.INTENSITYMODE_LUMINOUSINTENSITY = 2;\n/**\n * lux (lm/m^2)\n */\nLightConstants.INTENSITYMODE_ILLUMINANCE = 3;\n/**\n * nit (cd/m^2)\n */\nLightConstants.INTENSITYMODE_LUMINANCE = 4;\n// Light types ids const.\n/**\n * Light type const id of the point light.\n */\nLightConstants.LIGHTTYPEID_POINTLIGHT = 0;\n/**\n * Light type const id of the directional light.\n */\nLightConstants.LIGHTTYPEID_DIRECTIONALLIGHT = 1;\n/**\n * Light type const id of the spot light.\n */\nLightConstants.LIGHTTYPEID_SPOTLIGHT = 2;\n/**\n * Light type const id of the hemispheric light.\n */\nLightConstants.LIGHTTYPEID_HEMISPHERICLIGHT = 3;\n//# sourceMappingURL=lightConstants.js.map","import { __decorate } from \"../tslib.es6.js\";\nimport { serialize } from \"../Misc/decorators.js\";\nimport { Matrix, Vector3 } from \"../Maths/math.vector.js\";\nimport { Node } from \"../node.js\";\nimport { Light } from \"./light.js\";\nimport { ShadowLight } from \"./shadowLight.js\";\nNode.AddNodeConstructor(\"Light_Type_0\", (name, scene) => {\n    return () => new PointLight(name, Vector3.Zero(), scene);\n});\n/**\n * A point light is a light defined by an unique point in world space.\n * The light is emitted in every direction from this point.\n * A good example of a point light is a standard light bulb.\n * Documentation: https://doc.babylonjs.com/features/featuresDeepDive/lights/lights_introduction\n */\nexport class PointLight extends ShadowLight {\n    /**\n     * Getter: In case of direction provided, the shadow will not use a cube texture but simulate a spot shadow as a fallback\n     * This specifies what angle the shadow will use to be created.\n     *\n     * It default to 90 degrees to work nicely with the cube texture generation for point lights shadow maps.\n     */\n    get shadowAngle() {\n        return this._shadowAngle;\n    }\n    /**\n     * Setter: In case of direction provided, the shadow will not use a cube texture but simulate a spot shadow as a fallback\n     * This specifies what angle the shadow will use to be created.\n     *\n     * It default to 90 degrees to work nicely with the cube texture generation for point lights shadow maps.\n     */\n    set shadowAngle(value) {\n        this._shadowAngle = value;\n        this.forceProjectionMatrixCompute();\n    }\n    /**\n     * Gets the direction if it has been set.\n     * In case of direction provided, the shadow will not use a cube texture but simulate a spot shadow as a fallback\n     */\n    get direction() {\n        return this._direction;\n    }\n    /**\n     * In case of direction provided, the shadow will not use a cube texture but simulate a spot shadow as a fallback\n     */\n    set direction(value) {\n        const previousNeedCube = this.needCube();\n        this._direction = value;\n        if (this.needCube() !== previousNeedCube && this._shadowGenerators) {\n            const iterator = this._shadowGenerators.values();\n            for (let key = iterator.next(); key.done !== true; key = iterator.next()) {\n                const shadowGenerator = key.value;\n                shadowGenerator.recreateShadowMap();\n            }\n        }\n    }\n    /**\n     * Creates a PointLight object from the passed name and position (Vector3) and adds it in the scene.\n     * A PointLight emits the light in every direction.\n     * It can cast shadows.\n     * If the scene camera is already defined and you want to set your PointLight at the camera position, just set it :\n     * ```javascript\n     * var pointLight = new PointLight(\"pl\", camera.position, scene);\n     * ```\n     * Documentation : https://doc.babylonjs.com/features/featuresDeepDive/lights/lights_introduction\n     * @param name The light friendly name\n     * @param position The position of the point light in the scene\n     * @param scene The scene the lights belongs to\n     */\n    constructor(name, position, scene) {\n        super(name, scene);\n        this._shadowAngle = Math.PI / 2;\n        this.position = position;\n    }\n    /**\n     * Returns the string \"PointLight\"\n     * @returns the class name\n     */\n    getClassName() {\n        return \"PointLight\";\n    }\n    /**\n     * Returns the integer 0.\n     * @returns The light Type id as a constant defines in Light.LIGHTTYPEID_x\n     */\n    getTypeID() {\n        return Light.LIGHTTYPEID_POINTLIGHT;\n    }\n    /**\n     * Specifies whether or not the shadowmap should be a cube texture.\n     * @returns true if the shadowmap needs to be a cube texture.\n     */\n    needCube() {\n        return !this.direction;\n    }\n    /**\n     * Returns a new Vector3 aligned with the PointLight cube system according to the passed cube face index (integer).\n     * @param faceIndex The index of the face we are computed the direction to generate shadow\n     * @returns The set direction in 2d mode otherwise the direction to the cubemap face if needCube() is true\n     */\n    getShadowDirection(faceIndex) {\n        if (this.direction) {\n            return super.getShadowDirection(faceIndex);\n        }\n        else {\n            switch (faceIndex) {\n                case 0:\n                    return new Vector3(1.0, 0.0, 0.0);\n                case 1:\n                    return new Vector3(-1.0, 0.0, 0.0);\n                case 2:\n                    return new Vector3(0.0, -1.0, 0.0);\n                case 3:\n                    return new Vector3(0.0, 1.0, 0.0);\n                case 4:\n                    return new Vector3(0.0, 0.0, 1.0);\n                case 5:\n                    return new Vector3(0.0, 0.0, -1.0);\n            }\n        }\n        return Vector3.Zero();\n    }\n    /**\n     * Sets the passed matrix \"matrix\" as a left-handed perspective projection matrix with the following settings :\n     * - fov = PI / 2\n     * - aspect ratio : 1.0\n     * - z-near and far equal to the active camera minZ and maxZ.\n     * Returns the PointLight.\n     * @param matrix\n     * @param viewMatrix\n     * @param renderList\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _setDefaultShadowProjectionMatrix(matrix, viewMatrix, renderList) {\n        const activeCamera = this.getScene().activeCamera;\n        if (!activeCamera) {\n            return;\n        }\n        const minZ = this.shadowMinZ !== undefined ? this.shadowMinZ : activeCamera.minZ;\n        const maxZ = this.shadowMaxZ !== undefined ? this.shadowMaxZ : activeCamera.maxZ;\n        const useReverseDepthBuffer = this.getScene().getEngine().useReverseDepthBuffer;\n        Matrix.PerspectiveFovLHToRef(this.shadowAngle, 1.0, useReverseDepthBuffer ? maxZ : minZ, useReverseDepthBuffer ? minZ : maxZ, matrix, true, this._scene.getEngine().isNDCHalfZRange, undefined, useReverseDepthBuffer);\n    }\n    _buildUniformLayout() {\n        this._uniformBuffer.addUniform(\"vLightData\", 4);\n        this._uniformBuffer.addUniform(\"vLightDiffuse\", 4);\n        this._uniformBuffer.addUniform(\"vLightSpecular\", 4);\n        this._uniformBuffer.addUniform(\"vLightFalloff\", 4);\n        this._uniformBuffer.addUniform(\"shadowsInfo\", 3);\n        this._uniformBuffer.addUniform(\"depthValues\", 2);\n        this._uniformBuffer.create();\n    }\n    /**\n     * Sets the passed Effect \"effect\" with the PointLight transformed position (or position, if none) and passed name (string).\n     * @param effect The effect to update\n     * @param lightIndex The index of the light in the effect to update\n     * @returns The point light\n     */\n    transferToEffect(effect, lightIndex) {\n        if (this.computeTransformedInformation()) {\n            this._uniformBuffer.updateFloat4(\"vLightData\", this.transformedPosition.x, this.transformedPosition.y, this.transformedPosition.z, 0.0, lightIndex);\n        }\n        else {\n            this._uniformBuffer.updateFloat4(\"vLightData\", this.position.x, this.position.y, this.position.z, 0, lightIndex);\n        }\n        this._uniformBuffer.updateFloat4(\"vLightFalloff\", this.range, this._inverseSquaredRange, 0, 0, lightIndex);\n        return this;\n    }\n    transferToNodeMaterialEffect(effect, lightDataUniformName) {\n        if (this.computeTransformedInformation()) {\n            effect.setFloat3(lightDataUniformName, this.transformedPosition.x, this.transformedPosition.y, this.transformedPosition.z);\n        }\n        else {\n            effect.setFloat3(lightDataUniformName, this.position.x, this.position.y, this.position.z);\n        }\n        return this;\n    }\n    /**\n     * Prepares the list of defines specific to the light type.\n     * @param defines the list of defines\n     * @param lightIndex defines the index of the light for the effect\n     */\n    prepareLightSpecificDefines(defines, lightIndex) {\n        defines[\"POINTLIGHT\" + lightIndex] = true;\n    }\n}\n__decorate([\n    serialize()\n], PointLight.prototype, \"shadowAngle\", null);\n//# sourceMappingURL=pointLight.js.map","import { __decorate } from \"../tslib.es6.js\";\nimport { serialize, serializeAsVector3 } from \"../Misc/decorators.js\";\nimport { Matrix, Vector3 } from \"../Maths/math.vector.js\";\nimport { Light } from \"./light.js\";\nimport { Axis } from \"../Maths/math.axis.js\";\n/**\n * Base implementation IShadowLight\n * It groups all the common behaviour in order to reduce duplication and better follow the DRY pattern.\n */\nexport class ShadowLight extends Light {\n    constructor() {\n        super(...arguments);\n        this._needProjectionMatrixCompute = true;\n    }\n    _setPosition(value) {\n        this._position = value;\n    }\n    /**\n     * Sets the position the shadow will be casted from. Also use as the light position for both\n     * point and spot lights.\n     */\n    get position() {\n        return this._position;\n    }\n    /**\n     * Sets the position the shadow will be casted from. Also use as the light position for both\n     * point and spot lights.\n     */\n    set position(value) {\n        this._setPosition(value);\n    }\n    _setDirection(value) {\n        this._direction = value;\n    }\n    /**\n     * In 2d mode (needCube being false), gets the direction used to cast the shadow.\n     * Also use as the light direction on spot and directional lights.\n     */\n    get direction() {\n        return this._direction;\n    }\n    /**\n     * In 2d mode (needCube being false), sets the direction used to cast the shadow.\n     * Also use as the light direction on spot and directional lights.\n     */\n    set direction(value) {\n        this._setDirection(value);\n    }\n    /**\n     * Gets the shadow projection clipping minimum z value.\n     */\n    get shadowMinZ() {\n        return this._shadowMinZ;\n    }\n    /**\n     * Sets the shadow projection clipping minimum z value.\n     */\n    set shadowMinZ(value) {\n        this._shadowMinZ = value;\n        this.forceProjectionMatrixCompute();\n    }\n    /**\n     * Sets the shadow projection clipping maximum z value.\n     */\n    get shadowMaxZ() {\n        return this._shadowMaxZ;\n    }\n    /**\n     * Gets the shadow projection clipping maximum z value.\n     */\n    set shadowMaxZ(value) {\n        this._shadowMaxZ = value;\n        this.forceProjectionMatrixCompute();\n    }\n    /**\n     * Computes the transformed information (transformedPosition and transformedDirection in World space) of the current light\n     * @returns true if the information has been computed, false if it does not need to (no parenting)\n     */\n    computeTransformedInformation() {\n        if (this.parent && this.parent.getWorldMatrix) {\n            if (!this.transformedPosition) {\n                this.transformedPosition = Vector3.Zero();\n            }\n            Vector3.TransformCoordinatesToRef(this.position, this.parent.getWorldMatrix(), this.transformedPosition);\n            // In case the direction is present.\n            if (this.direction) {\n                if (!this.transformedDirection) {\n                    this.transformedDirection = Vector3.Zero();\n                }\n                Vector3.TransformNormalToRef(this.direction, this.parent.getWorldMatrix(), this.transformedDirection);\n            }\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Return the depth scale used for the shadow map.\n     * @returns the depth scale.\n     */\n    getDepthScale() {\n        return 50.0;\n    }\n    /**\n     * Get the direction to use to render the shadow map. In case of cube texture, the face index can be passed.\n     * @param faceIndex The index of the face we are computed the direction to generate shadow\n     * @returns The set direction in 2d mode otherwise the direction to the cubemap face if needCube() is true\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    getShadowDirection(faceIndex) {\n        return this.transformedDirection ? this.transformedDirection : this.direction;\n    }\n    /**\n     * Returns the ShadowLight absolute position in the World.\n     * @returns the position vector in world space\n     */\n    getAbsolutePosition() {\n        return this.transformedPosition ? this.transformedPosition : this.position;\n    }\n    /**\n     * Sets the ShadowLight direction toward the passed target.\n     * @param target The point to target in local space\n     * @returns the updated ShadowLight direction\n     */\n    setDirectionToTarget(target) {\n        this.direction = Vector3.Normalize(target.subtract(this.position));\n        return this.direction;\n    }\n    /**\n     * Returns the light rotation in euler definition.\n     * @returns the x y z rotation in local space.\n     */\n    getRotation() {\n        this.direction.normalize();\n        const xaxis = Vector3.Cross(this.direction, Axis.Y);\n        const yaxis = Vector3.Cross(xaxis, this.direction);\n        return Vector3.RotationFromAxis(xaxis, yaxis, this.direction);\n    }\n    /**\n     * Returns whether or not the shadow generation require a cube texture or a 2d texture.\n     * @returns true if a cube texture needs to be use\n     */\n    needCube() {\n        return false;\n    }\n    /**\n     * Detects if the projection matrix requires to be recomputed this frame.\n     * @returns true if it requires to be recomputed otherwise, false.\n     */\n    needProjectionMatrixCompute() {\n        return this._needProjectionMatrixCompute;\n    }\n    /**\n     * Forces the shadow generator to recompute the projection matrix even if position and direction did not changed.\n     */\n    forceProjectionMatrixCompute() {\n        this._needProjectionMatrixCompute = true;\n    }\n    /** @internal */\n    _initCache() {\n        super._initCache();\n        this._cache.position = Vector3.Zero();\n    }\n    /** @internal */\n    _isSynchronized() {\n        if (!this._cache.position.equals(this.position)) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Computes the world matrix of the node\n     * @param force defines if the cache version should be invalidated forcing the world matrix to be created from scratch\n     * @returns the world matrix\n     */\n    computeWorldMatrix(force) {\n        if (!force && this.isSynchronized()) {\n            this._currentRenderId = this.getScene().getRenderId();\n            return this._worldMatrix;\n        }\n        this._updateCache();\n        this._cache.position.copyFrom(this.position);\n        if (!this._worldMatrix) {\n            this._worldMatrix = Matrix.Identity();\n        }\n        Matrix.TranslationToRef(this.position.x, this.position.y, this.position.z, this._worldMatrix);\n        if (this.parent && this.parent.getWorldMatrix) {\n            this._worldMatrix.multiplyToRef(this.parent.getWorldMatrix(), this._worldMatrix);\n            this._markSyncedWithParent();\n        }\n        // Cache the determinant\n        this._worldMatrixDeterminantIsDirty = true;\n        return this._worldMatrix;\n    }\n    /**\n     * Gets the minZ used for shadow according to both the scene and the light.\n     * @param activeCamera The camera we are returning the min for\n     * @returns the depth min z\n     */\n    getDepthMinZ(activeCamera) {\n        return this.shadowMinZ !== undefined ? this.shadowMinZ : activeCamera.minZ;\n    }\n    /**\n     * Gets the maxZ used for shadow according to both the scene and the light.\n     * @param activeCamera The camera we are returning the max for\n     * @returns the depth max z\n     */\n    getDepthMaxZ(activeCamera) {\n        return this.shadowMaxZ !== undefined ? this.shadowMaxZ : activeCamera.maxZ;\n    }\n    /**\n     * Sets the shadow projection matrix in parameter to the generated projection matrix.\n     * @param matrix The matrix to updated with the projection information\n     * @param viewMatrix The transform matrix of the light\n     * @param renderList The list of mesh to render in the map\n     * @returns The current light\n     */\n    setShadowProjectionMatrix(matrix, viewMatrix, renderList) {\n        if (this.customProjectionMatrixBuilder) {\n            this.customProjectionMatrixBuilder(viewMatrix, renderList, matrix);\n        }\n        else {\n            this._setDefaultShadowProjectionMatrix(matrix, viewMatrix, renderList);\n        }\n        return this;\n    }\n    /** @internal */\n    _syncParentEnabledState() {\n        super._syncParentEnabledState();\n        if (!this.parent || !this.parent.getWorldMatrix) {\n            this.transformedPosition = null;\n            this.transformedDirection = null;\n        }\n    }\n}\n__decorate([\n    serializeAsVector3()\n], ShadowLight.prototype, \"position\", null);\n__decorate([\n    serializeAsVector3()\n], ShadowLight.prototype, \"direction\", null);\n__decorate([\n    serialize()\n], ShadowLight.prototype, \"shadowMinZ\", null);\n__decorate([\n    serialize()\n], ShadowLight.prototype, \"shadowMaxZ\", null);\n//# sourceMappingURL=shadowLight.js.map","import { __decorate } from \"../tslib.es6.js\";\nimport { serialize, serializeAsTexture } from \"../Misc/decorators.js\";\nimport { Matrix, Vector3 } from \"../Maths/math.vector.js\";\nimport { Node } from \"../node.js\";\nimport { Light } from \"./light.js\";\nimport { ShadowLight } from \"./shadowLight.js\";\nimport { Texture } from \"../Materials/Textures/texture.js\";\nNode.AddNodeConstructor(\"Light_Type_2\", (name, scene) => {\n    return () => new SpotLight(name, Vector3.Zero(), Vector3.Zero(), 0, 0, scene);\n});\n/**\n * A spot light is defined by a position, a direction, an angle, and an exponent.\n * These values define a cone of light starting from the position, emitting toward the direction.\n * The angle, in radians, defines the size (field of illumination) of the spotlight's conical beam,\n * and the exponent defines the speed of the decay of the light with distance (reach).\n * Documentation: https://doc.babylonjs.com/features/featuresDeepDive/lights/lights_introduction\n */\nexport class SpotLight extends ShadowLight {\n    /**\n     * Gets the cone angle of the spot light in Radians.\n     */\n    get angle() {\n        return this._angle;\n    }\n    /**\n     * Sets the cone angle of the spot light in Radians.\n     */\n    set angle(value) {\n        this._angle = value;\n        this._cosHalfAngle = Math.cos(value * 0.5);\n        this._projectionTextureProjectionLightDirty = true;\n        this.forceProjectionMatrixCompute();\n        this._computeAngleValues();\n    }\n    /**\n     * Only used in gltf falloff mode, this defines the angle where\n     * the directional falloff will start before cutting at angle which could be seen\n     * as outer angle.\n     */\n    get innerAngle() {\n        return this._innerAngle;\n    }\n    /**\n     * Only used in gltf falloff mode, this defines the angle where\n     * the directional falloff will start before cutting at angle which could be seen\n     * as outer angle.\n     */\n    set innerAngle(value) {\n        this._innerAngle = value;\n        this._computeAngleValues();\n    }\n    /**\n     * Allows scaling the angle of the light for shadow generation only.\n     */\n    get shadowAngleScale() {\n        return this._shadowAngleScale;\n    }\n    /**\n     * Allows scaling the angle of the light for shadow generation only.\n     */\n    set shadowAngleScale(value) {\n        this._shadowAngleScale = value;\n        this.forceProjectionMatrixCompute();\n    }\n    /**\n     * Allows reading the projection texture\n     */\n    get projectionTextureMatrix() {\n        return this._projectionTextureMatrix;\n    }\n    /**\n     * Gets the near clip of the Spotlight for texture projection.\n     */\n    get projectionTextureLightNear() {\n        return this._projectionTextureLightNear;\n    }\n    /**\n     * Sets the near clip of the Spotlight for texture projection.\n     */\n    set projectionTextureLightNear(value) {\n        this._projectionTextureLightNear = value;\n        this._projectionTextureProjectionLightDirty = true;\n    }\n    /**\n     * Gets the far clip of the Spotlight for texture projection.\n     */\n    get projectionTextureLightFar() {\n        return this._projectionTextureLightFar;\n    }\n    /**\n     * Sets the far clip of the Spotlight for texture projection.\n     */\n    set projectionTextureLightFar(value) {\n        this._projectionTextureLightFar = value;\n        this._projectionTextureProjectionLightDirty = true;\n    }\n    /**\n     * Gets the Up vector of the Spotlight for texture projection.\n     */\n    get projectionTextureUpDirection() {\n        return this._projectionTextureUpDirection;\n    }\n    /**\n     * Sets the Up vector of the Spotlight for texture projection.\n     */\n    set projectionTextureUpDirection(value) {\n        this._projectionTextureUpDirection = value;\n        this._projectionTextureProjectionLightDirty = true;\n    }\n    /**\n     * Gets the projection texture of the light.\n     */\n    get projectionTexture() {\n        return this._projectionTexture;\n    }\n    /**\n     * Sets the projection texture of the light.\n     */\n    set projectionTexture(value) {\n        if (this._projectionTexture === value) {\n            return;\n        }\n        this._projectionTexture = value;\n        this._projectionTextureDirty = true;\n        if (this._projectionTexture && !this._projectionTexture.isReady()) {\n            if (SpotLight._IsProceduralTexture(this._projectionTexture)) {\n                this._projectionTexture.getEffect().executeWhenCompiled(() => {\n                    this._markMeshesAsLightDirty();\n                });\n            }\n            else if (SpotLight._IsTexture(this._projectionTexture)) {\n                this._projectionTexture.onLoadObservable.addOnce(() => {\n                    this._markMeshesAsLightDirty();\n                });\n            }\n        }\n    }\n    static _IsProceduralTexture(texture) {\n        return texture.onGeneratedObservable !== undefined;\n    }\n    static _IsTexture(texture) {\n        return texture.onLoadObservable !== undefined;\n    }\n    /**\n     * Gets or sets the light projection matrix as used by the projection texture\n     */\n    get projectionTextureProjectionLightMatrix() {\n        return this._projectionTextureProjectionLightMatrix;\n    }\n    set projectionTextureProjectionLightMatrix(projection) {\n        this._projectionTextureProjectionLightMatrix = projection;\n        this._projectionTextureProjectionLightDirty = false;\n        this._projectionTextureDirty = true;\n    }\n    /**\n     * Creates a SpotLight object in the scene. A spot light is a simply light oriented cone.\n     * It can cast shadows.\n     * Documentation : https://doc.babylonjs.com/features/featuresDeepDive/lights/lights_introduction\n     * @param name The light friendly name\n     * @param position The position of the spot light in the scene\n     * @param direction The direction of the light in the scene\n     * @param angle The cone angle of the light in Radians\n     * @param exponent The light decay speed with the distance from the emission spot\n     * @param scene The scene the lights belongs to\n     */\n    constructor(name, position, direction, angle, exponent, scene) {\n        super(name, scene);\n        this._innerAngle = 0;\n        this._projectionTextureMatrix = Matrix.Zero();\n        this._projectionTextureLightNear = 1e-6;\n        this._projectionTextureLightFar = 1000.0;\n        this._projectionTextureUpDirection = Vector3.Up();\n        this._projectionTextureViewLightDirty = true;\n        this._projectionTextureProjectionLightDirty = true;\n        this._projectionTextureDirty = true;\n        this._projectionTextureViewTargetVector = Vector3.Zero();\n        this._projectionTextureViewLightMatrix = Matrix.Zero();\n        this._projectionTextureProjectionLightMatrix = Matrix.Zero();\n        this._projectionTextureScalingMatrix = Matrix.FromValues(0.5, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.5, 0.5, 0.5, 1.0);\n        this.position = position;\n        this.direction = direction;\n        this.angle = angle;\n        this.exponent = exponent;\n    }\n    /**\n     * Returns the string \"SpotLight\".\n     * @returns the class name\n     */\n    getClassName() {\n        return \"SpotLight\";\n    }\n    /**\n     * Returns the integer 2.\n     * @returns The light Type id as a constant defines in Light.LIGHTTYPEID_x\n     */\n    getTypeID() {\n        return Light.LIGHTTYPEID_SPOTLIGHT;\n    }\n    /**\n     * Overrides the direction setter to recompute the projection texture view light Matrix.\n     * @param value\n     */\n    _setDirection(value) {\n        super._setDirection(value);\n        this._projectionTextureViewLightDirty = true;\n    }\n    /**\n     * Overrides the position setter to recompute the projection texture view light Matrix.\n     * @param value\n     */\n    _setPosition(value) {\n        super._setPosition(value);\n        this._projectionTextureViewLightDirty = true;\n    }\n    /**\n     * Sets the passed matrix \"matrix\" as perspective projection matrix for the shadows and the passed view matrix with the fov equal to the SpotLight angle and and aspect ratio of 1.0.\n     * Returns the SpotLight.\n     * @param matrix\n     * @param viewMatrix\n     * @param renderList\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _setDefaultShadowProjectionMatrix(matrix, viewMatrix, renderList) {\n        const activeCamera = this.getScene().activeCamera;\n        if (!activeCamera) {\n            return;\n        }\n        this._shadowAngleScale = this._shadowAngleScale || 1;\n        const angle = this._shadowAngleScale * this._angle;\n        const minZ = this.shadowMinZ !== undefined ? this.shadowMinZ : activeCamera.minZ;\n        const maxZ = this.shadowMaxZ !== undefined ? this.shadowMaxZ : activeCamera.maxZ;\n        const useReverseDepthBuffer = this.getScene().getEngine().useReverseDepthBuffer;\n        Matrix.PerspectiveFovLHToRef(angle, 1.0, useReverseDepthBuffer ? maxZ : minZ, useReverseDepthBuffer ? minZ : maxZ, matrix, true, this._scene.getEngine().isNDCHalfZRange, undefined, useReverseDepthBuffer);\n    }\n    _computeProjectionTextureViewLightMatrix() {\n        this._projectionTextureViewLightDirty = false;\n        this._projectionTextureDirty = true;\n        this.position.addToRef(this.direction, this._projectionTextureViewTargetVector);\n        Matrix.LookAtLHToRef(this.position, this._projectionTextureViewTargetVector, this._projectionTextureUpDirection, this._projectionTextureViewLightMatrix);\n    }\n    _computeProjectionTextureProjectionLightMatrix() {\n        this._projectionTextureProjectionLightDirty = false;\n        this._projectionTextureDirty = true;\n        const lightFar = this.projectionTextureLightFar;\n        const lightNear = this.projectionTextureLightNear;\n        const P = lightFar / (lightFar - lightNear);\n        const Q = -P * lightNear;\n        const S = 1.0 / Math.tan(this._angle / 2.0);\n        const A = 1.0;\n        Matrix.FromValuesToRef(S / A, 0.0, 0.0, 0.0, 0.0, S, 0.0, 0.0, 0.0, 0.0, P, 1.0, 0.0, 0.0, Q, 0.0, this._projectionTextureProjectionLightMatrix);\n    }\n    /**\n     * Main function for light texture projection matrix computing.\n     */\n    _computeProjectionTextureMatrix() {\n        this._projectionTextureDirty = false;\n        this._projectionTextureViewLightMatrix.multiplyToRef(this._projectionTextureProjectionLightMatrix, this._projectionTextureMatrix);\n        if (this._projectionTexture instanceof Texture) {\n            const u = this._projectionTexture.uScale / 2.0;\n            const v = this._projectionTexture.vScale / 2.0;\n            Matrix.FromValuesToRef(u, 0.0, 0.0, 0.0, 0.0, v, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.5, 0.5, 0.5, 1.0, this._projectionTextureScalingMatrix);\n        }\n        this._projectionTextureMatrix.multiplyToRef(this._projectionTextureScalingMatrix, this._projectionTextureMatrix);\n    }\n    _buildUniformLayout() {\n        this._uniformBuffer.addUniform(\"vLightData\", 4);\n        this._uniformBuffer.addUniform(\"vLightDiffuse\", 4);\n        this._uniformBuffer.addUniform(\"vLightSpecular\", 4);\n        this._uniformBuffer.addUniform(\"vLightDirection\", 3);\n        this._uniformBuffer.addUniform(\"vLightFalloff\", 4);\n        this._uniformBuffer.addUniform(\"shadowsInfo\", 3);\n        this._uniformBuffer.addUniform(\"depthValues\", 2);\n        this._uniformBuffer.create();\n    }\n    _computeAngleValues() {\n        this._lightAngleScale = 1.0 / Math.max(0.001, Math.cos(this._innerAngle * 0.5) - this._cosHalfAngle);\n        this._lightAngleOffset = -this._cosHalfAngle * this._lightAngleScale;\n    }\n    /**\n     * Sets the passed Effect \"effect\" with the Light textures.\n     * @param effect The effect to update\n     * @param lightIndex The index of the light in the effect to update\n     * @returns The light\n     */\n    transferTexturesToEffect(effect, lightIndex) {\n        if (this.projectionTexture && this.projectionTexture.isReady()) {\n            if (this._projectionTextureViewLightDirty) {\n                this._computeProjectionTextureViewLightMatrix();\n            }\n            if (this._projectionTextureProjectionLightDirty) {\n                this._computeProjectionTextureProjectionLightMatrix();\n            }\n            if (this._projectionTextureDirty) {\n                this._computeProjectionTextureMatrix();\n            }\n            effect.setMatrix(\"textureProjectionMatrix\" + lightIndex, this._projectionTextureMatrix);\n            effect.setTexture(\"projectionLightSampler\" + lightIndex, this.projectionTexture);\n        }\n        return this;\n    }\n    /**\n     * Sets the passed Effect object with the SpotLight transformed position (or position if not parented) and normalized direction.\n     * @param effect The effect to update\n     * @param lightIndex The index of the light in the effect to update\n     * @returns The spot light\n     */\n    transferToEffect(effect, lightIndex) {\n        let normalizeDirection;\n        if (this.computeTransformedInformation()) {\n            this._uniformBuffer.updateFloat4(\"vLightData\", this.transformedPosition.x, this.transformedPosition.y, this.transformedPosition.z, this.exponent, lightIndex);\n            normalizeDirection = Vector3.Normalize(this.transformedDirection);\n        }\n        else {\n            this._uniformBuffer.updateFloat4(\"vLightData\", this.position.x, this.position.y, this.position.z, this.exponent, lightIndex);\n            normalizeDirection = Vector3.Normalize(this.direction);\n        }\n        this._uniformBuffer.updateFloat4(\"vLightDirection\", normalizeDirection.x, normalizeDirection.y, normalizeDirection.z, this._cosHalfAngle, lightIndex);\n        this._uniformBuffer.updateFloat4(\"vLightFalloff\", this.range, this._inverseSquaredRange, this._lightAngleScale, this._lightAngleOffset, lightIndex);\n        return this;\n    }\n    transferToNodeMaterialEffect(effect, lightDataUniformName) {\n        let normalizeDirection;\n        if (this.computeTransformedInformation()) {\n            normalizeDirection = Vector3.Normalize(this.transformedDirection);\n        }\n        else {\n            normalizeDirection = Vector3.Normalize(this.direction);\n        }\n        if (this.getScene().useRightHandedSystem) {\n            effect.setFloat3(lightDataUniformName, -normalizeDirection.x, -normalizeDirection.y, -normalizeDirection.z);\n        }\n        else {\n            effect.setFloat3(lightDataUniformName, normalizeDirection.x, normalizeDirection.y, normalizeDirection.z);\n        }\n        return this;\n    }\n    /**\n     * Disposes the light and the associated resources.\n     */\n    dispose() {\n        super.dispose();\n        if (this._projectionTexture) {\n            this._projectionTexture.dispose();\n        }\n    }\n    /**\n     * Gets the minZ used for shadow according to both the scene and the light.\n     * @param activeCamera The camera we are returning the min for\n     * @returns the depth min z\n     */\n    getDepthMinZ(activeCamera) {\n        const engine = this._scene.getEngine();\n        const minZ = this.shadowMinZ !== undefined ? this.shadowMinZ : activeCamera.minZ;\n        return engine.useReverseDepthBuffer && engine.isNDCHalfZRange ? minZ : this._scene.getEngine().isNDCHalfZRange ? 0 : minZ;\n    }\n    /**\n     * Gets the maxZ used for shadow according to both the scene and the light.\n     * @param activeCamera The camera we are returning the max for\n     * @returns the depth max z\n     */\n    getDepthMaxZ(activeCamera) {\n        const engine = this._scene.getEngine();\n        const maxZ = this.shadowMaxZ !== undefined ? this.shadowMaxZ : activeCamera.maxZ;\n        return engine.useReverseDepthBuffer && engine.isNDCHalfZRange ? 0 : maxZ;\n    }\n    /**\n     * Prepares the list of defines specific to the light type.\n     * @param defines the list of defines\n     * @param lightIndex defines the index of the light for the effect\n     */\n    prepareLightSpecificDefines(defines, lightIndex) {\n        defines[\"SPOTLIGHT\" + lightIndex] = true;\n        defines[\"PROJECTEDLIGHTTEXTURE\" + lightIndex] = this.projectionTexture && this.projectionTexture.isReady() ? true : false;\n    }\n}\n__decorate([\n    serialize()\n], SpotLight.prototype, \"angle\", null);\n__decorate([\n    serialize()\n], SpotLight.prototype, \"innerAngle\", null);\n__decorate([\n    serialize()\n], SpotLight.prototype, \"shadowAngleScale\", null);\n__decorate([\n    serialize()\n], SpotLight.prototype, \"exponent\", void 0);\n__decorate([\n    serialize()\n], SpotLight.prototype, \"projectionTextureLightNear\", null);\n__decorate([\n    serialize()\n], SpotLight.prototype, \"projectionTextureLightFar\", null);\n__decorate([\n    serialize()\n], SpotLight.prototype, \"projectionTextureUpDirection\", null);\n__decorate([\n    serializeAsTexture(\"projectedLightTexture\")\n], SpotLight.prototype, \"_projectionTexture\", void 0);\n//# sourceMappingURL=spotLight.js.map","import { Engine } from \"../Engines/engine.js\";\n/**\n * Class used for the default loading screen\n * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/customLoadingScreen\n */\nexport class DefaultLoadingScreen {\n    /**\n     * Creates a new default loading screen\n     * @param _renderingCanvas defines the canvas used to render the scene\n     * @param _loadingText defines the default text to display\n     * @param _loadingDivBackgroundColor defines the default background color\n     */\n    constructor(_renderingCanvas, _loadingText = \"\", _loadingDivBackgroundColor = \"black\") {\n        this._renderingCanvas = _renderingCanvas;\n        this._loadingText = _loadingText;\n        this._loadingDivBackgroundColor = _loadingDivBackgroundColor;\n        // Resize\n        this._resizeLoadingUI = () => {\n            const canvasRect = this._renderingCanvas.getBoundingClientRect();\n            const canvasPositioning = window.getComputedStyle(this._renderingCanvas).position;\n            if (!this._loadingDiv) {\n                return;\n            }\n            this._loadingDiv.style.position = canvasPositioning === \"fixed\" ? \"fixed\" : \"absolute\";\n            this._loadingDiv.style.left = canvasRect.left + \"px\";\n            this._loadingDiv.style.top = canvasRect.top + \"px\";\n            this._loadingDiv.style.width = canvasRect.width + \"px\";\n            this._loadingDiv.style.height = canvasRect.height + \"px\";\n        };\n    }\n    /**\n     * Function called to display the loading screen\n     */\n    displayLoadingUI() {\n        if (this._loadingDiv) {\n            // Do not add a loading screen if there is already one\n            return;\n        }\n        this._loadingDiv = document.createElement(\"div\");\n        this._loadingDiv.id = \"babylonjsLoadingDiv\";\n        this._loadingDiv.style.opacity = \"0\";\n        this._loadingDiv.style.transition = \"opacity 1.5s ease\";\n        this._loadingDiv.style.pointerEvents = \"none\";\n        this._loadingDiv.style.display = \"grid\";\n        this._loadingDiv.style.gridTemplateRows = \"100%\";\n        this._loadingDiv.style.gridTemplateColumns = \"100%\";\n        this._loadingDiv.style.justifyItems = \"center\";\n        this._loadingDiv.style.alignItems = \"center\";\n        // Loading text\n        this._loadingTextDiv = document.createElement(\"div\");\n        this._loadingTextDiv.style.position = \"absolute\";\n        this._loadingTextDiv.style.left = \"0\";\n        this._loadingTextDiv.style.top = \"50%\";\n        this._loadingTextDiv.style.marginTop = \"80px\";\n        this._loadingTextDiv.style.width = \"100%\";\n        this._loadingTextDiv.style.height = \"20px\";\n        this._loadingTextDiv.style.fontFamily = \"Arial\";\n        this._loadingTextDiv.style.fontSize = \"14px\";\n        this._loadingTextDiv.style.color = \"white\";\n        this._loadingTextDiv.style.textAlign = \"center\";\n        this._loadingTextDiv.style.zIndex = \"1\";\n        this._loadingTextDiv.innerHTML = \"Loading\";\n        this._loadingDiv.appendChild(this._loadingTextDiv);\n        //set the predefined text\n        this._loadingTextDiv.innerHTML = this._loadingText;\n        // Generating keyframes\n        this._style = document.createElement(\"style\");\n        this._style.type = \"text/css\";\n        const keyFrames = `@-webkit-keyframes spin1 {\\\r\n                    0% { -webkit-transform: rotate(0deg);}\r\n                    100% { -webkit-transform: rotate(360deg);}\r\n                }\\\r\n                @keyframes spin1 {\\\r\n                    0% { transform: rotate(0deg);}\r\n                    100% { transform: rotate(360deg);}\r\n                }`;\n        this._style.innerHTML = keyFrames;\n        document.getElementsByTagName(\"head\")[0].appendChild(this._style);\n        const svgSupport = !!window.SVGSVGElement;\n        // Loading img\n        const imgBack = new Image();\n        if (!DefaultLoadingScreen.DefaultLogoUrl) {\n            imgBack.src = !svgSupport\n                ? \"https://cdn.babylonjs.com/Assets/babylonLogo.png\"\n                : `data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxODAuMTcgMjA4LjA0Ij48ZGVmcz48c3R5bGU+LmNscy0xe2ZpbGw6I2ZmZjt9LmNscy0ye2ZpbGw6I2UwNjg0Yjt9LmNscy0ze2ZpbGw6I2JiNDY0Yjt9LmNscy00e2ZpbGw6I2UwZGVkODt9LmNscy01e2ZpbGw6I2Q1ZDJjYTt9PC9zdHlsZT48L2RlZnM+PHRpdGxlPkJhYnlsb25Mb2dvPC90aXRsZT48ZyBpZD0iTGF5ZXJfMiIgZGF0YS1uYW1lPSJMYXllciAyIj48ZyBpZD0iUGFnZV9FbGVtZW50cyIgZGF0YS1uYW1lPSJQYWdlIEVsZW1lbnRzIj48cGF0aCBjbGFzcz0iY2xzLTEiIGQ9Ik05MC4wOSwwLDAsNTJWMTU2bDkwLjA5LDUyLDkwLjA4LTUyVjUyWiIvPjxwb2x5Z29uIGNsYXNzPSJjbHMtMiIgcG9pbnRzPSIxODAuMTcgNTIuMDEgMTUxLjk3IDM1LjczIDEyNC44NSA1MS4zOSAxNTMuMDUgNjcuNjcgMTgwLjE3IDUyLjAxIi8+PHBvbHlnb24gY2xhc3M9ImNscy0yIiBwb2ludHM9IjI3LjEyIDY3LjY3IDExNy4yMSAxNS42NiA5MC4wOCAwIDAgNTIuMDEgMjcuMTIgNjcuNjciLz48cG9seWdvbiBjbGFzcz0iY2xzLTIiIHBvaW50cz0iNjEuODkgMTIwLjMgOTAuMDggMTM2LjU4IDExOC4yOCAxMjAuMyA5MC4wOCAxMDQuMDIgNjEuODkgMTIwLjMiLz48cG9seWdvbiBjbGFzcz0iY2xzLTMiIHBvaW50cz0iMTUzLjA1IDY3LjY3IDE1My4wNSAxNDAuMzcgOTAuMDggMTc2LjcyIDI3LjEyIDE0MC4zNyAyNy4xMiA2Ny42NyAwIDUyLjAxIDAgMTU2LjAzIDkwLjA4IDIwOC4wNCAxODAuMTcgMTU2LjAzIDE4MC4xNyA1Mi4wMSAxNTMuMDUgNjcuNjciLz48cG9seWdvbiBjbGFzcz0iY2xzLTMiIHBvaW50cz0iOTAuMDggNzEuNDYgNjEuODkgODcuNzQgNjEuODkgMTIwLjMgOTAuMDggMTA0LjAyIDExOC4yOCAxMjAuMyAxMTguMjggODcuNzQgOTAuMDggNzEuNDYiLz48cG9seWdvbiBjbGFzcz0iY2xzLTQiIHBvaW50cz0iMTUzLjA1IDY3LjY3IDExOC4yOCA4Ny43NCAxMTguMjggMTIwLjMgOTAuMDggMTM2LjU4IDkwLjA4IDE3Ni43MiAxNTMuMDUgMTQwLjM3IDE1My4wNSA2Ny42NyIvPjxwb2x5Z29uIGNsYXNzPSJjbHMtNSIgcG9pbnRzPSIyNy4xMiA2Ny42NyA2MS44OSA4Ny43NCA2MS44OSAxMjAuMyA5MC4wOCAxMzYuNTggOTAuMDggMTc2LjcyIDI3LjEyIDE0MC4zNyAyNy4xMiA2Ny42NyIvPjwvZz48L2c+PC9zdmc+`;\n        }\n        else {\n            imgBack.src = DefaultLoadingScreen.DefaultLogoUrl;\n        }\n        imgBack.style.width = \"150px\";\n        imgBack.style.gridColumn = \"1\";\n        imgBack.style.gridRow = \"1\";\n        imgBack.style.top = \"50%\";\n        imgBack.style.left = \"50%\";\n        imgBack.style.transform = \"translate(-50%, -50%)\";\n        imgBack.style.position = \"absolute\";\n        const imageSpinnerContainer = document.createElement(\"div\");\n        imageSpinnerContainer.style.width = \"300px\";\n        imageSpinnerContainer.style.gridColumn = \"1\";\n        imageSpinnerContainer.style.gridRow = \"1\";\n        imageSpinnerContainer.style.top = \"50%\";\n        imageSpinnerContainer.style.left = \"50%\";\n        imageSpinnerContainer.style.transform = \"translate(-50%, -50%)\";\n        imageSpinnerContainer.style.position = \"absolute\";\n        // Loading spinner\n        const imgSpinner = new Image();\n        if (!DefaultLoadingScreen.DefaultSpinnerUrl) {\n            imgSpinner.src = !svgSupport\n                ? \"https://cdn.babylonjs.com/Assets/loadingIcon.png\"\n                : `data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAzOTIgMzkyIj48ZGVmcz48c3R5bGU+LmNscy0xe2ZpbGw6I2UwNjg0Yjt9LmNscy0ye2ZpbGw6bm9uZTt9PC9zdHlsZT48L2RlZnM+PHRpdGxlPlNwaW5uZXJJY29uPC90aXRsZT48ZyBpZD0iTGF5ZXJfMiIgZGF0YS1uYW1lPSJMYXllciAyIj48ZyBpZD0iU3Bpbm5lciI+PHBhdGggY2xhc3M9ImNscy0xIiBkPSJNNDAuMjEsMTI2LjQzYzMuNy03LjMxLDcuNjctMTQuNDQsMTItMjEuMzJsMy4zNi01LjEsMy41Mi01YzEuMjMtMS42MywyLjQxLTMuMjksMy42NS00LjkxczIuNTMtMy4yMSwzLjgyLTQuNzlBMTg1LjIsMTg1LjIsMCwwLDEsODMuNCw2Ny40M2EyMDgsMjA4LDAsMCwxLDE5LTE1LjY2YzMuMzUtMi40MSw2Ljc0LTQuNzgsMTAuMjUtN3M3LjExLTQuMjgsMTAuNzUtNi4zMmM3LjI5LTQsMTQuNzMtOCwyMi41My0xMS40OSwzLjktMS43Miw3Ljg4LTMuMywxMi00LjY0YTEwNC4yMiwxMDQuMjIsMCwwLDEsMTIuNDQtMy4yMyw2Mi40NCw2Mi40NCwwLDAsMSwxMi43OC0xLjM5QTI1LjkyLDI1LjkyLDAsMCwxLDE5NiwyMS40NGE2LjU1LDYuNTUsMCwwLDEsMi4wNSw5LDYuNjYsNi42NiwwLDAsMS0xLjY0LDEuNzhsLS40MS4yOWEyMi4wNywyMi4wNywwLDAsMS01Ljc4LDMsMzAuNDIsMzAuNDIsMCwwLDEtNS42NywxLjYyLDM3LjgyLDM3LjgyLDAsMCwxLTUuNjkuNzFjLTEsMC0xLjkuMTgtMi44NS4yNmwtMi44NS4yNHEtNS43Mi41MS0xMS40OCwxLjFjLTMuODQuNC03LjcxLjgyLTExLjU4LDEuNGExMTIuMzQsMTEyLjM0LDAsMCwwLTIyLjk0LDUuNjFjLTMuNzIsMS4zNS03LjM0LDMtMTAuOTQsNC42NHMtNy4xNCwzLjUxLTEwLjYsNS41MUExNTEuNiwxNTEuNiwwLDAsMCw2OC41Niw4N0M2Ny4yMyw4OC40OCw2Niw5MCw2NC42NCw5MS41NnMtMi41MSwzLjE1LTMuNzUsNC43M2wtMy41NCw0LjljLTEuMTMsMS42Ni0yLjIzLDMuMzUtMy4zMyw1YTEyNywxMjcsMCwwLDAtMTAuOTMsMjEuNDksMS41OCwxLjU4LDAsMSwxLTMtMS4xNVM0MC4xOSwxMjYuNDcsNDAuMjEsMTI2LjQzWiIvPjxyZWN0IGNsYXNzPSJjbHMtMiIgd2lkdGg9IjM5MiIgaGVpZ2h0PSIzOTIiLz48L2c+PC9nPjwvc3ZnPg==`;\n        }\n        else {\n            imgSpinner.src = DefaultLoadingScreen.DefaultSpinnerUrl;\n        }\n        imgSpinner.style.animation = \"spin1 0.75s infinite linear\";\n        imgSpinner.style.webkitAnimation = \"spin1 0.75s infinite linear\";\n        imgSpinner.style.transformOrigin = \"50% 50%\";\n        imgSpinner.style.webkitTransformOrigin = \"50% 50%\";\n        if (!svgSupport) {\n            const logoSize = { w: 16, h: 18.5 };\n            const loadingSize = { w: 30, h: 30 };\n            // set styling correctly\n            imgBack.style.width = `${logoSize.w}vh`;\n            imgBack.style.height = `${logoSize.h}vh`;\n            imgBack.style.left = `calc(50% - ${logoSize.w / 2}vh)`;\n            imgBack.style.top = `calc(50% - ${logoSize.h / 2}vh)`;\n            imgSpinner.style.width = `${loadingSize.w}vh`;\n            imgSpinner.style.height = `${loadingSize.h}vh`;\n            imgSpinner.style.left = `calc(50% - ${loadingSize.w / 2}vh)`;\n            imgSpinner.style.top = `calc(50% - ${loadingSize.h / 2}vh)`;\n        }\n        imageSpinnerContainer.appendChild(imgSpinner);\n        this._loadingDiv.appendChild(imgBack);\n        this._loadingDiv.appendChild(imageSpinnerContainer);\n        this._resizeLoadingUI();\n        window.addEventListener(\"resize\", this._resizeLoadingUI);\n        this._loadingDiv.style.backgroundColor = this._loadingDivBackgroundColor;\n        document.body.appendChild(this._loadingDiv);\n        this._loadingDiv.style.opacity = \"1\";\n    }\n    /**\n     * Function called to hide the loading screen\n     */\n    hideLoadingUI() {\n        if (!this._loadingDiv) {\n            return;\n        }\n        const onTransitionEnd = () => {\n            if (this._loadingTextDiv) {\n                this._loadingTextDiv.remove();\n                this._loadingTextDiv = null;\n            }\n            if (this._loadingDiv) {\n                this._loadingDiv.remove();\n                this._loadingDiv = null;\n            }\n            if (this._style) {\n                this._style.remove();\n                this._style = null;\n            }\n            window.removeEventListener(\"resize\", this._resizeLoadingUI);\n        };\n        this._loadingDiv.style.opacity = \"0\";\n        this._loadingDiv.addEventListener(\"transitionend\", onTransitionEnd);\n    }\n    /**\n     * Gets or sets the text to display while loading\n     */\n    set loadingUIText(text) {\n        this._loadingText = text;\n        if (this._loadingTextDiv) {\n            this._loadingTextDiv.innerHTML = this._loadingText;\n        }\n    }\n    get loadingUIText() {\n        return this._loadingText;\n    }\n    /**\n     * Gets or sets the color to use for the background\n     */\n    get loadingUIBackgroundColor() {\n        return this._loadingDivBackgroundColor;\n    }\n    set loadingUIBackgroundColor(color) {\n        this._loadingDivBackgroundColor = color;\n        if (!this._loadingDiv) {\n            return;\n        }\n        this._loadingDiv.style.backgroundColor = this._loadingDivBackgroundColor;\n    }\n}\n/** Gets or sets the logo url to use for the default loading screen */\nDefaultLoadingScreen.DefaultLogoUrl = \"\";\n/** Gets or sets the spinner url to use for the default loading screen */\nDefaultLoadingScreen.DefaultSpinnerUrl = \"\";\nEngine.DefaultLoadingScreenFactory = (canvas) => {\n    return new DefaultLoadingScreen(canvas);\n};\n//# sourceMappingURL=loadingScreen.js.map","import { Logger } from \"../../Misc/logger.js\";\nimport { Camera } from \"../../Cameras/camera.js\";\nimport { Vector3 } from \"../../Maths/math.vector.js\";\nimport { Color3, Color4 } from \"../../Maths/math.color.js\";\nimport { Mesh } from \"../../Meshes/mesh.js\";\nimport { Geometry } from \"../../Meshes/geometry.js\";\nimport { TransformNode } from \"../../Meshes/transformNode.js\";\nimport { Material } from \"../../Materials/material.js\";\nimport { MultiMaterial } from \"../../Materials/multiMaterial.js\";\nimport { CubeTexture } from \"../../Materials/Textures/cubeTexture.js\";\nimport { HDRCubeTexture } from \"../../Materials/Textures/hdrCubeTexture.js\";\nimport { AnimationGroup } from \"../../Animations/animationGroup.js\";\nimport { Light } from \"../../Lights/light.js\";\nimport { SceneComponentConstants } from \"../../sceneComponent.js\";\nimport { SceneLoader } from \"../../Loading/sceneLoader.js\";\nimport { AbstractScene } from \"../../abstractScene.js\";\nimport { AssetContainer } from \"../../assetContainer.js\";\nimport { ActionManager } from \"../../Actions/actionManager.js\";\nimport { Skeleton } from \"../../Bones/skeleton.js\";\nimport { MorphTargetManager } from \"../../Morph/morphTargetManager.js\";\nimport { CannonJSPlugin } from \"../../Physics/v1/Plugins/cannonJSPlugin.js\";\nimport { OimoJSPlugin } from \"../../Physics/v1/Plugins/oimoJSPlugin.js\";\nimport { AmmoJSPlugin } from \"../../Physics/v1/Plugins/ammoJSPlugin.js\";\nimport { ReflectionProbe } from \"../../Probes/reflectionProbe.js\";\nimport { GetClass } from \"../../Misc/typeStore.js\";\nimport { Tools } from \"../../Misc/tools.js\";\nimport { PostProcess } from \"../../PostProcesses/postProcess.js\";\n/** @internal */\n// eslint-disable-next-line @typescript-eslint/naming-convention, no-var\nexport var _BabylonLoaderRegistered = true;\n/**\n * Helps setting up some configuration for the babylon file loader.\n */\nexport class BabylonFileLoaderConfiguration {\n}\n/**\n * The loader does not allow injecting custom physics engine into the plugins.\n * Unfortunately in ES6, we need to manually inject them into the plugin.\n * So you could set this variable to your engine import to make it work.\n */\nBabylonFileLoaderConfiguration.LoaderInjectedPhysicsEngine = undefined;\nlet tempIndexContainer = {};\nlet tempMaterialIndexContainer = {};\nconst parseMaterialByPredicate = (predicate, parsedData, scene, rootUrl) => {\n    if (!parsedData.materials) {\n        return null;\n    }\n    for (let index = 0, cache = parsedData.materials.length; index < cache; index++) {\n        const parsedMaterial = parsedData.materials[index];\n        if (predicate(parsedMaterial)) {\n            return { parsedMaterial, material: Material.Parse(parsedMaterial, scene, rootUrl) };\n        }\n    }\n    return null;\n};\nconst isDescendantOf = (mesh, names, hierarchyIds) => {\n    for (const i in names) {\n        if (mesh.name === names[i]) {\n            hierarchyIds.push(mesh.id);\n            return true;\n        }\n    }\n    if (mesh.parentId !== undefined && hierarchyIds.indexOf(mesh.parentId) !== -1) {\n        hierarchyIds.push(mesh.id);\n        return true;\n    }\n    return false;\n};\n// eslint-disable-next-line @typescript-eslint/naming-convention\nconst logOperation = (operation, producer) => {\n    return (operation +\n        \" of \" +\n        (producer ? producer.file + \" from \" + producer.name + \" version: \" + producer.version + \", exporter version: \" + producer.exporter_version : \"unknown\"));\n};\nconst loadDetailLevels = (scene, mesh) => {\n    const mastermesh = mesh;\n    // Every value specified in the ids array of the lod data points to another mesh which should be used as the lower LOD level.\n    // The distances (or coverages) array values specified are used along with the lod mesh ids as a hint to determine the switching threshold for the various LODs.\n    if (mesh._waitingData.lods) {\n        if (mesh._waitingData.lods.ids && mesh._waitingData.lods.ids.length > 0) {\n            const lodmeshes = mesh._waitingData.lods.ids;\n            const wasenabled = mastermesh.isEnabled(false);\n            if (mesh._waitingData.lods.distances) {\n                const distances = mesh._waitingData.lods.distances;\n                if (distances.length >= lodmeshes.length) {\n                    const culling = distances.length > lodmeshes.length ? distances[distances.length - 1] : 0;\n                    mastermesh.setEnabled(false);\n                    for (let index = 0; index < lodmeshes.length; index++) {\n                        const lodid = lodmeshes[index];\n                        const lodmesh = scene.getMeshById(lodid);\n                        if (lodmesh != null) {\n                            mastermesh.addLODLevel(distances[index], lodmesh);\n                        }\n                    }\n                    if (culling > 0) {\n                        mastermesh.addLODLevel(culling, null);\n                    }\n                    if (wasenabled === true) {\n                        mastermesh.setEnabled(true);\n                    }\n                }\n                else {\n                    Tools.Warn(\"Invalid level of detail distances for \" + mesh.name);\n                }\n            }\n        }\n        mesh._waitingData.lods = null;\n    }\n};\nconst findParent = (parentId, parentInstanceIndex, scene) => {\n    if (typeof parentId !== \"number\") {\n        const parentEntry = scene.getLastEntryById(parentId);\n        if (parentEntry && parentInstanceIndex !== undefined && parentInstanceIndex !== null) {\n            const instance = parentEntry.instances[parseInt(parentInstanceIndex)];\n            return instance;\n        }\n        return parentEntry;\n    }\n    const parent = tempIndexContainer[parentId];\n    if (parent && parentInstanceIndex !== undefined && parentInstanceIndex !== null) {\n        const instance = parent.instances[parseInt(parentInstanceIndex)];\n        return instance;\n    }\n    return parent;\n};\nconst findMaterial = (materialId, scene) => {\n    if (typeof materialId !== \"number\") {\n        return scene.getLastMaterialById(materialId, true);\n    }\n    return tempMaterialIndexContainer[materialId];\n};\nconst loadAssetContainer = (scene, data, rootUrl, onError, addToScene = false) => {\n    const container = new AssetContainer(scene);\n    // Entire method running in try block, so ALWAYS logs as far as it got, only actually writes details\n    // when SceneLoader.debugLogging = true (default), or exception encountered.\n    // Everything stored in var log instead of writing separate lines to support only writing in exception,\n    // and avoid problems with multiple concurrent .babylon loads.\n    let log = \"importScene has failed JSON parse\";\n    try {\n        // eslint-disable-next-line no-var\n        var parsedData = JSON.parse(data);\n        log = \"\";\n        const fullDetails = SceneLoader.loggingLevel === SceneLoader.DETAILED_LOGGING;\n        let index;\n        let cache;\n        // Environment texture\n        if (parsedData.environmentTexture !== undefined && parsedData.environmentTexture !== null) {\n            // PBR needed for both HDR texture (gamma space) & a sky box\n            const isPBR = parsedData.isPBR !== undefined ? parsedData.isPBR : true;\n            if (parsedData.environmentTextureType && parsedData.environmentTextureType === \"BABYLON.HDRCubeTexture\") {\n                const hdrSize = parsedData.environmentTextureSize ? parsedData.environmentTextureSize : 128;\n                const hdrTexture = new HDRCubeTexture((parsedData.environmentTexture.match(/https?:\\/\\//g) ? \"\" : rootUrl) + parsedData.environmentTexture, scene, hdrSize, true, !isPBR, undefined, parsedData.environmentTexturePrefilterOnLoad);\n                if (parsedData.environmentTextureRotationY) {\n                    hdrTexture.rotationY = parsedData.environmentTextureRotationY;\n                }\n                scene.environmentTexture = hdrTexture;\n            }\n            else {\n                if (typeof parsedData.environmentTexture === \"object\") {\n                    const environmentTexture = CubeTexture.Parse(parsedData.environmentTexture, scene, rootUrl);\n                    scene.environmentTexture = environmentTexture;\n                }\n                else if (parsedData.environmentTexture.endsWith(\".env\")) {\n                    const compressedTexture = new CubeTexture((parsedData.environmentTexture.match(/https?:\\/\\//g) ? \"\" : rootUrl) + parsedData.environmentTexture, scene, parsedData.environmentTextureForcedExtension);\n                    if (parsedData.environmentTextureRotationY) {\n                        compressedTexture.rotationY = parsedData.environmentTextureRotationY;\n                    }\n                    scene.environmentTexture = compressedTexture;\n                }\n                else {\n                    const cubeTexture = CubeTexture.CreateFromPrefilteredData((parsedData.environmentTexture.match(/https?:\\/\\//g) ? \"\" : rootUrl) + parsedData.environmentTexture, scene, parsedData.environmentTextureForcedExtension);\n                    if (parsedData.environmentTextureRotationY) {\n                        cubeTexture.rotationY = parsedData.environmentTextureRotationY;\n                    }\n                    scene.environmentTexture = cubeTexture;\n                }\n            }\n            if (parsedData.createDefaultSkybox === true) {\n                const skyboxScale = scene.activeCamera !== undefined && scene.activeCamera !== null ? (scene.activeCamera.maxZ - scene.activeCamera.minZ) / 2 : 1000;\n                const skyboxBlurLevel = parsedData.skyboxBlurLevel || 0;\n                scene.createDefaultSkybox(scene.environmentTexture, isPBR, skyboxScale, skyboxBlurLevel);\n            }\n            container.environmentTexture = scene.environmentTexture;\n        }\n        // Environment Intensity\n        if (parsedData.environmentIntensity !== undefined && parsedData.environmentIntensity !== null) {\n            scene.environmentIntensity = parsedData.environmentIntensity;\n        }\n        // Lights\n        if (parsedData.lights !== undefined && parsedData.lights !== null) {\n            for (index = 0, cache = parsedData.lights.length; index < cache; index++) {\n                const parsedLight = parsedData.lights[index];\n                const light = Light.Parse(parsedLight, scene);\n                if (light) {\n                    tempIndexContainer[parsedLight.uniqueId] = light;\n                    container.lights.push(light);\n                    light._parentContainer = container;\n                    log += index === 0 ? \"\\n\\tLights:\" : \"\";\n                    log += \"\\n\\t\\t\" + light.toString(fullDetails);\n                }\n            }\n        }\n        // Reflection probes\n        if (parsedData.reflectionProbes !== undefined && parsedData.reflectionProbes !== null) {\n            for (index = 0, cache = parsedData.reflectionProbes.length; index < cache; index++) {\n                const parsedReflectionProbe = parsedData.reflectionProbes[index];\n                const reflectionProbe = ReflectionProbe.Parse(parsedReflectionProbe, scene, rootUrl);\n                if (reflectionProbe) {\n                    container.reflectionProbes.push(reflectionProbe);\n                    reflectionProbe._parentContainer = container;\n                    log += index === 0 ? \"\\n\\tReflection Probes:\" : \"\";\n                    log += \"\\n\\t\\t\" + reflectionProbe.toString(fullDetails);\n                }\n            }\n        }\n        // Animations\n        if (parsedData.animations !== undefined && parsedData.animations !== null) {\n            for (index = 0, cache = parsedData.animations.length; index < cache; index++) {\n                const parsedAnimation = parsedData.animations[index];\n                const internalClass = GetClass(\"BABYLON.Animation\");\n                if (internalClass) {\n                    const animation = internalClass.Parse(parsedAnimation);\n                    scene.animations.push(animation);\n                    container.animations.push(animation);\n                    log += index === 0 ? \"\\n\\tAnimations:\" : \"\";\n                    log += \"\\n\\t\\t\" + animation.toString(fullDetails);\n                }\n            }\n        }\n        // Materials\n        if (parsedData.materials !== undefined && parsedData.materials !== null) {\n            for (index = 0, cache = parsedData.materials.length; index < cache; index++) {\n                const parsedMaterial = parsedData.materials[index];\n                const mat = Material.Parse(parsedMaterial, scene, rootUrl);\n                if (mat) {\n                    tempMaterialIndexContainer[parsedMaterial.uniqueId || parsedMaterial.id] = mat;\n                    container.materials.push(mat);\n                    mat._parentContainer = container;\n                    log += index === 0 ? \"\\n\\tMaterials:\" : \"\";\n                    log += \"\\n\\t\\t\" + mat.toString(fullDetails);\n                    // Textures\n                    const textures = mat.getActiveTextures();\n                    textures.forEach((t) => {\n                        if (container.textures.indexOf(t) == -1) {\n                            container.textures.push(t);\n                            t._parentContainer = container;\n                        }\n                    });\n                }\n            }\n        }\n        if (parsedData.multiMaterials !== undefined && parsedData.multiMaterials !== null) {\n            for (index = 0, cache = parsedData.multiMaterials.length; index < cache; index++) {\n                const parsedMultiMaterial = parsedData.multiMaterials[index];\n                const mmat = MultiMaterial.ParseMultiMaterial(parsedMultiMaterial, scene);\n                tempMaterialIndexContainer[parsedMultiMaterial.uniqueId || parsedMultiMaterial.id] = mmat;\n                container.multiMaterials.push(mmat);\n                mmat._parentContainer = container;\n                log += index === 0 ? \"\\n\\tMultiMaterials:\" : \"\";\n                log += \"\\n\\t\\t\" + mmat.toString(fullDetails);\n                // Textures\n                const textures = mmat.getActiveTextures();\n                textures.forEach((t) => {\n                    if (container.textures.indexOf(t) == -1) {\n                        container.textures.push(t);\n                        t._parentContainer = container;\n                    }\n                });\n            }\n        }\n        // Morph targets\n        if (parsedData.morphTargetManagers !== undefined && parsedData.morphTargetManagers !== null) {\n            for (const managerData of parsedData.morphTargetManagers) {\n                const manager = MorphTargetManager.Parse(managerData, scene);\n                container.morphTargetManagers.push(manager);\n                manager._parentContainer = container;\n            }\n        }\n        // Skeletons\n        if (parsedData.skeletons !== undefined && parsedData.skeletons !== null) {\n            for (index = 0, cache = parsedData.skeletons.length; index < cache; index++) {\n                const parsedSkeleton = parsedData.skeletons[index];\n                const skeleton = Skeleton.Parse(parsedSkeleton, scene);\n                container.skeletons.push(skeleton);\n                skeleton._parentContainer = container;\n                log += index === 0 ? \"\\n\\tSkeletons:\" : \"\";\n                log += \"\\n\\t\\t\" + skeleton.toString(fullDetails);\n            }\n        }\n        // Geometries\n        const geometries = parsedData.geometries;\n        if (geometries !== undefined && geometries !== null) {\n            const addedGeometry = new Array();\n            // VertexData\n            const vertexData = geometries.vertexData;\n            if (vertexData !== undefined && vertexData !== null) {\n                for (index = 0, cache = vertexData.length; index < cache; index++) {\n                    const parsedVertexData = vertexData[index];\n                    addedGeometry.push(Geometry.Parse(parsedVertexData, scene, rootUrl));\n                }\n            }\n            addedGeometry.forEach((g) => {\n                if (g) {\n                    container.geometries.push(g);\n                    g._parentContainer = container;\n                }\n            });\n        }\n        // Transform nodes\n        if (parsedData.transformNodes !== undefined && parsedData.transformNodes !== null) {\n            for (index = 0, cache = parsedData.transformNodes.length; index < cache; index++) {\n                const parsedTransformNode = parsedData.transformNodes[index];\n                const node = TransformNode.Parse(parsedTransformNode, scene, rootUrl);\n                tempIndexContainer[parsedTransformNode.uniqueId] = node;\n                container.transformNodes.push(node);\n                node._parentContainer = container;\n            }\n        }\n        // Meshes\n        if (parsedData.meshes !== undefined && parsedData.meshes !== null) {\n            for (index = 0, cache = parsedData.meshes.length; index < cache; index++) {\n                const parsedMesh = parsedData.meshes[index];\n                const mesh = Mesh.Parse(parsedMesh, scene, rootUrl);\n                tempIndexContainer[parsedMesh.uniqueId] = mesh;\n                container.meshes.push(mesh);\n                mesh._parentContainer = container;\n                if (mesh.hasInstances) {\n                    for (const instance of mesh.instances) {\n                        container.meshes.push(instance);\n                        instance._parentContainer = container;\n                    }\n                }\n                log += index === 0 ? \"\\n\\tMeshes:\" : \"\";\n                log += \"\\n\\t\\t\" + mesh.toString(fullDetails);\n            }\n        }\n        // Cameras\n        if (parsedData.cameras !== undefined && parsedData.cameras !== null) {\n            for (index = 0, cache = parsedData.cameras.length; index < cache; index++) {\n                const parsedCamera = parsedData.cameras[index];\n                const camera = Camera.Parse(parsedCamera, scene);\n                tempIndexContainer[parsedCamera.uniqueId] = camera;\n                container.cameras.push(camera);\n                camera._parentContainer = container;\n                log += index === 0 ? \"\\n\\tCameras:\" : \"\";\n                log += \"\\n\\t\\t\" + camera.toString(fullDetails);\n            }\n        }\n        // Postprocesses\n        if (parsedData.postProcesses !== undefined && parsedData.postProcesses !== null) {\n            for (index = 0, cache = parsedData.postProcesses.length; index < cache; index++) {\n                const parsedPostProcess = parsedData.postProcesses[index];\n                const postProcess = PostProcess.Parse(parsedPostProcess, scene, rootUrl);\n                if (postProcess) {\n                    container.postProcesses.push(postProcess);\n                    postProcess._parentContainer = container;\n                    log += index === 0 ? \"\\nPostprocesses:\" : \"\";\n                    log += \"\\n\\t\\t\" + postProcess.toString();\n                }\n            }\n        }\n        // Animation Groups\n        if (parsedData.animationGroups !== undefined && parsedData.animationGroups !== null) {\n            for (index = 0, cache = parsedData.animationGroups.length; index < cache; index++) {\n                const parsedAnimationGroup = parsedData.animationGroups[index];\n                const animationGroup = AnimationGroup.Parse(parsedAnimationGroup, scene);\n                container.animationGroups.push(animationGroup);\n                animationGroup._parentContainer = container;\n                log += index === 0 ? \"\\n\\tAnimationGroups:\" : \"\";\n                log += \"\\n\\t\\t\" + animationGroup.toString(fullDetails);\n            }\n        }\n        // Browsing all the graph to connect the dots\n        for (index = 0, cache = scene.cameras.length; index < cache; index++) {\n            const camera = scene.cameras[index];\n            if (camera._waitingParentId !== null) {\n                camera.parent = findParent(camera._waitingParentId, camera._waitingParentInstanceIndex, scene);\n                camera._waitingParentId = null;\n                camera._waitingParentInstanceIndex = null;\n            }\n        }\n        for (index = 0, cache = scene.lights.length; index < cache; index++) {\n            const light = scene.lights[index];\n            if (light && light._waitingParentId !== null) {\n                light.parent = findParent(light._waitingParentId, light._waitingParentInstanceIndex, scene);\n                light._waitingParentId = null;\n                light._waitingParentInstanceIndex = null;\n            }\n        }\n        // Connect parents & children and parse actions and lods\n        for (index = 0, cache = scene.transformNodes.length; index < cache; index++) {\n            const transformNode = scene.transformNodes[index];\n            if (transformNode._waitingParentId !== null) {\n                transformNode.parent = findParent(transformNode._waitingParentId, transformNode._waitingParentInstanceIndex, scene);\n                transformNode._waitingParentId = null;\n                transformNode._waitingParentInstanceIndex = null;\n            }\n        }\n        for (index = 0, cache = scene.meshes.length; index < cache; index++) {\n            const mesh = scene.meshes[index];\n            if (mesh._waitingParentId !== null) {\n                mesh.parent = findParent(mesh._waitingParentId, mesh._waitingParentInstanceIndex, scene);\n                mesh._waitingParentId = null;\n                mesh._waitingParentInstanceIndex = null;\n            }\n            if (mesh._waitingData.lods) {\n                loadDetailLevels(scene, mesh);\n            }\n        }\n        // link multimats with materials\n        scene.multiMaterials.forEach((multimat) => {\n            multimat._waitingSubMaterialsUniqueIds.forEach((subMaterial) => {\n                multimat.subMaterials.push(findMaterial(subMaterial, scene));\n            });\n            multimat._waitingSubMaterialsUniqueIds = [];\n        });\n        // link meshes with materials\n        scene.meshes.forEach((mesh) => {\n            if (mesh._waitingMaterialId !== null) {\n                mesh.material = findMaterial(mesh._waitingMaterialId, scene);\n                mesh._waitingMaterialId = null;\n            }\n        });\n        // link skeleton transform nodes\n        for (index = 0, cache = scene.skeletons.length; index < cache; index++) {\n            const skeleton = scene.skeletons[index];\n            if (skeleton._hasWaitingData) {\n                if (skeleton.bones != null) {\n                    skeleton.bones.forEach((bone) => {\n                        if (bone._waitingTransformNodeId) {\n                            const linkTransformNode = scene.getLastEntryById(bone._waitingTransformNodeId);\n                            if (linkTransformNode) {\n                                bone.linkTransformNode(linkTransformNode);\n                            }\n                            bone._waitingTransformNodeId = null;\n                        }\n                    });\n                }\n                skeleton._hasWaitingData = null;\n            }\n        }\n        // freeze world matrix application\n        for (index = 0, cache = scene.meshes.length; index < cache; index++) {\n            const currentMesh = scene.meshes[index];\n            if (currentMesh._waitingData.freezeWorldMatrix) {\n                currentMesh.freezeWorldMatrix();\n                currentMesh._waitingData.freezeWorldMatrix = null;\n            }\n            else {\n                currentMesh.computeWorldMatrix(true);\n            }\n        }\n        // Lights exclusions / inclusions\n        for (index = 0, cache = scene.lights.length; index < cache; index++) {\n            const light = scene.lights[index];\n            // Excluded check\n            if (light._excludedMeshesIds.length > 0) {\n                for (let excludedIndex = 0; excludedIndex < light._excludedMeshesIds.length; excludedIndex++) {\n                    const excludedMesh = scene.getMeshById(light._excludedMeshesIds[excludedIndex]);\n                    if (excludedMesh) {\n                        light.excludedMeshes.push(excludedMesh);\n                    }\n                }\n                light._excludedMeshesIds = [];\n            }\n            // Included check\n            if (light._includedOnlyMeshesIds.length > 0) {\n                for (let includedOnlyIndex = 0; includedOnlyIndex < light._includedOnlyMeshesIds.length; includedOnlyIndex++) {\n                    const includedOnlyMesh = scene.getMeshById(light._includedOnlyMeshesIds[includedOnlyIndex]);\n                    if (includedOnlyMesh) {\n                        light.includedOnlyMeshes.push(includedOnlyMesh);\n                    }\n                }\n                light._includedOnlyMeshesIds = [];\n            }\n        }\n        scene.geometries.forEach((g) => {\n            g._loadedUniqueId = \"\";\n        });\n        AbstractScene.Parse(parsedData, scene, container, rootUrl);\n        // Actions (scene) Done last as it can access other objects.\n        for (index = 0, cache = scene.meshes.length; index < cache; index++) {\n            const mesh = scene.meshes[index];\n            if (mesh._waitingData.actions) {\n                ActionManager.Parse(mesh._waitingData.actions, mesh, scene);\n                mesh._waitingData.actions = null;\n            }\n        }\n        if (parsedData.actions !== undefined && parsedData.actions !== null) {\n            ActionManager.Parse(parsedData.actions, null, scene);\n        }\n    }\n    catch (err) {\n        const msg = logOperation(\"loadAssets\", parsedData ? parsedData.producer : \"Unknown\") + log;\n        if (onError) {\n            onError(msg, err);\n        }\n        else {\n            Logger.Log(msg);\n            throw err;\n        }\n    }\n    finally {\n        tempIndexContainer = {};\n        tempMaterialIndexContainer = {};\n        if (!addToScene) {\n            container.removeAllFromScene();\n        }\n        if (log !== null && SceneLoader.loggingLevel !== SceneLoader.NO_LOGGING) {\n            Logger.Log(logOperation(\"loadAssets\", parsedData ? parsedData.producer : \"Unknown\") + (SceneLoader.loggingLevel !== SceneLoader.MINIMAL_LOGGING ? log : \"\"));\n        }\n    }\n    return container;\n};\nSceneLoader.RegisterPlugin({\n    name: \"babylon.js\",\n    extensions: \".babylon\",\n    canDirectLoad: (data) => {\n        if (data.indexOf(\"babylon\") !== -1) {\n            // We consider that the producer string is filled\n            return true;\n        }\n        return false;\n    },\n    importMesh: (meshesNames, scene, data, rootUrl, meshes, particleSystems, skeletons, onError) => {\n        var _a;\n        // Entire method running in try block, so ALWAYS logs as far as it got, only actually writes details\n        // when SceneLoader.debugLogging = true (default), or exception encountered.\n        // Everything stored in var log instead of writing separate lines to support only writing in exception,\n        // and avoid problems with multiple concurrent .babylon loads.\n        let log = \"importMesh has failed JSON parse\";\n        try {\n            // eslint-disable-next-line no-var\n            var parsedData = JSON.parse(data);\n            log = \"\";\n            const fullDetails = SceneLoader.loggingLevel === SceneLoader.DETAILED_LOGGING;\n            if (!meshesNames) {\n                meshesNames = null;\n            }\n            else if (!Array.isArray(meshesNames)) {\n                meshesNames = [meshesNames];\n            }\n            const hierarchyIds = new Array();\n            const parsedIdToNodeMap = new Map();\n            // Transform nodes (the overall idea is to load all of them as this is super fast and then get rid of the ones we don't need)\n            const loadedTransformNodes = [];\n            if (parsedData.transformNodes !== undefined && parsedData.transformNodes !== null) {\n                for (let index = 0, cache = parsedData.transformNodes.length; index < cache; index++) {\n                    const parsedJSONTransformNode = parsedData.transformNodes[index];\n                    const parsedTransformNode = TransformNode.Parse(parsedJSONTransformNode, scene, rootUrl);\n                    loadedTransformNodes.push(parsedTransformNode);\n                    parsedIdToNodeMap.set(parsedTransformNode._waitingParsedUniqueId, parsedTransformNode);\n                    parsedTransformNode._waitingParsedUniqueId = null;\n                }\n            }\n            if (parsedData.meshes !== undefined && parsedData.meshes !== null) {\n                const loadedSkeletonsIds = [];\n                const loadedMaterialsIds = [];\n                const loadedMaterialsUniqueIds = [];\n                const loadedMorphTargetsIds = [];\n                for (let index = 0, cache = parsedData.meshes.length; index < cache; index++) {\n                    const parsedMesh = parsedData.meshes[index];\n                    if (meshesNames === null || isDescendantOf(parsedMesh, meshesNames, hierarchyIds)) {\n                        if (meshesNames !== null) {\n                            // Remove found mesh name from list.\n                            delete meshesNames[meshesNames.indexOf(parsedMesh.name)];\n                        }\n                        //Geometry?\n                        if (parsedMesh.geometryId !== undefined && parsedMesh.geometryId !== null) {\n                            //does the file contain geometries?\n                            if (parsedData.geometries !== undefined && parsedData.geometries !== null) {\n                                //find the correct geometry and add it to the scene\n                                let found = false;\n                                [\"boxes\", \"spheres\", \"cylinders\", \"toruses\", \"grounds\", \"planes\", \"torusKnots\", \"vertexData\"].forEach((geometryType) => {\n                                    if (found === true || !parsedData.geometries[geometryType] || !Array.isArray(parsedData.geometries[geometryType])) {\n                                        return;\n                                    }\n                                    else {\n                                        parsedData.geometries[geometryType].forEach((parsedGeometryData) => {\n                                            if (parsedGeometryData.id === parsedMesh.geometryId) {\n                                                switch (geometryType) {\n                                                    case \"vertexData\":\n                                                        Geometry.Parse(parsedGeometryData, scene, rootUrl);\n                                                        break;\n                                                }\n                                                found = true;\n                                            }\n                                        });\n                                    }\n                                });\n                                if (found === false) {\n                                    Logger.Warn(\"Geometry not found for mesh \" + parsedMesh.id);\n                                }\n                            }\n                        }\n                        // Material ?\n                        if (parsedMesh.materialUniqueId || parsedMesh.materialId) {\n                            // if we have a unique ID, look up and store in loadedMaterialsUniqueIds, else use loadedMaterialsIds\n                            const materialArray = parsedMesh.materialUniqueId ? loadedMaterialsUniqueIds : loadedMaterialsIds;\n                            let materialFound = materialArray.indexOf(parsedMesh.materialUniqueId || parsedMesh.materialId) !== -1;\n                            if (materialFound === false && parsedData.multiMaterials !== undefined && parsedData.multiMaterials !== null) {\n                                // Loads a submaterial of a multimaterial\n                                const loadSubMaterial = (subMatId, predicate) => {\n                                    materialArray.push(subMatId);\n                                    const mat = parseMaterialByPredicate(predicate, parsedData, scene, rootUrl);\n                                    if (mat && mat.material) {\n                                        tempMaterialIndexContainer[mat.parsedMaterial.uniqueId || mat.parsedMaterial.id] = mat.material;\n                                        log += \"\\n\\tMaterial \" + mat.material.toString(fullDetails);\n                                    }\n                                };\n                                for (let multimatIndex = 0, multimatCache = parsedData.multiMaterials.length; multimatIndex < multimatCache; multimatIndex++) {\n                                    const parsedMultiMaterial = parsedData.multiMaterials[multimatIndex];\n                                    if ((parsedMesh.materialUniqueId && parsedMultiMaterial.uniqueId === parsedMesh.materialUniqueId) ||\n                                        parsedMultiMaterial.id === parsedMesh.materialId) {\n                                        if (parsedMultiMaterial.materialsUniqueIds) {\n                                            // if the materials inside the multimat are stored by unique id\n                                            parsedMultiMaterial.materialsUniqueIds.forEach((subMatId) => loadSubMaterial(subMatId, (parsedMaterial) => parsedMaterial.uniqueId === subMatId));\n                                        }\n                                        else {\n                                            // if the mats are stored by id instead\n                                            parsedMultiMaterial.materials.forEach((subMatId) => loadSubMaterial(subMatId, (parsedMaterial) => parsedMaterial.id === subMatId));\n                                        }\n                                        materialArray.push(parsedMultiMaterial.uniqueId || parsedMultiMaterial.id);\n                                        const mmat = MultiMaterial.ParseMultiMaterial(parsedMultiMaterial, scene);\n                                        tempMaterialIndexContainer[parsedMultiMaterial.uniqueId || parsedMultiMaterial.id] = mmat;\n                                        if (mmat) {\n                                            materialFound = true;\n                                            log += \"\\n\\tMulti-Material \" + mmat.toString(fullDetails);\n                                        }\n                                        break;\n                                    }\n                                }\n                            }\n                            if (materialFound === false) {\n                                materialArray.push(parsedMesh.materialUniqueId || parsedMesh.materialId);\n                                const mat = parseMaterialByPredicate((parsedMaterial) => (parsedMesh.materialUniqueId && parsedMaterial.uniqueId === parsedMesh.materialUniqueId) || parsedMaterial.id === parsedMesh.materialId, parsedData, scene, rootUrl);\n                                if (!mat || !mat.material) {\n                                    Logger.Warn(\"Material not found for mesh \" + parsedMesh.id);\n                                }\n                                else {\n                                    tempMaterialIndexContainer[mat.parsedMaterial.uniqueId || mat.parsedMaterial.id] = mat.material;\n                                    log += \"\\n\\tMaterial \" + mat.material.toString(fullDetails);\n                                }\n                            }\n                        }\n                        // Skeleton ?\n                        if (parsedMesh.skeletonId > -1 && parsedData.skeletons !== undefined && parsedData.skeletons !== null) {\n                            const skeletonAlreadyLoaded = loadedSkeletonsIds.indexOf(parsedMesh.skeletonId) > -1;\n                            if (!skeletonAlreadyLoaded) {\n                                for (let skeletonIndex = 0, skeletonCache = parsedData.skeletons.length; skeletonIndex < skeletonCache; skeletonIndex++) {\n                                    const parsedSkeleton = parsedData.skeletons[skeletonIndex];\n                                    if (parsedSkeleton.id === parsedMesh.skeletonId) {\n                                        const skeleton = Skeleton.Parse(parsedSkeleton, scene);\n                                        skeletons.push(skeleton);\n                                        loadedSkeletonsIds.push(parsedSkeleton.id);\n                                        log += \"\\n\\tSkeleton \" + skeleton.toString(fullDetails);\n                                    }\n                                }\n                            }\n                        }\n                        // Morph targets ?\n                        if (parsedMesh.morphTargetManagerId > -1 && parsedData.morphTargetManagers !== undefined && parsedData.morphTargetManagers !== null) {\n                            const morphTargetAlreadyLoaded = loadedMorphTargetsIds.indexOf(parsedMesh.morphTargetManagerId) > -1;\n                            if (!morphTargetAlreadyLoaded) {\n                                for (let morphTargetIndex = 0, morphTargetCache = parsedData.morphTargetManagers.length; morphTargetIndex < morphTargetCache; morphTargetIndex++) {\n                                    const parsedMorphTarget = parsedData.morphTargetManagers[morphTargetIndex];\n                                    if (parsedMorphTarget.id === parsedMesh.morphTargetManagerId) {\n                                        const morphTarget = MorphTargetManager.Parse(parsedMorphTarget, scene);\n                                        loadedMorphTargetsIds.push(morphTarget.uniqueId);\n                                        log += \"\\nMorph target \" + morphTarget.toString();\n                                    }\n                                }\n                            }\n                        }\n                        const mesh = Mesh.Parse(parsedMesh, scene, rootUrl);\n                        meshes.push(mesh);\n                        parsedIdToNodeMap.set(mesh._waitingParsedUniqueId, mesh);\n                        mesh._waitingParsedUniqueId = null;\n                        log += \"\\n\\tMesh \" + mesh.toString(fullDetails);\n                    }\n                }\n                // link multimats with materials\n                scene.multiMaterials.forEach((multimat) => {\n                    multimat._waitingSubMaterialsUniqueIds.forEach((subMaterial) => {\n                        multimat.subMaterials.push(findMaterial(subMaterial, scene));\n                    });\n                    multimat._waitingSubMaterialsUniqueIds = [];\n                });\n                // link meshes with materials\n                scene.meshes.forEach((mesh) => {\n                    if (mesh._waitingMaterialId !== null) {\n                        mesh.material = findMaterial(mesh._waitingMaterialId, scene);\n                        mesh._waitingMaterialId = null;\n                    }\n                });\n                // Connecting parents and lods\n                for (let index = 0, cache = scene.transformNodes.length; index < cache; index++) {\n                    const transformNode = scene.transformNodes[index];\n                    if (transformNode._waitingParentId !== null) {\n                        let parent = parsedIdToNodeMap.get(parseInt(transformNode._waitingParentId)) || null;\n                        if (parent === null) {\n                            parent = scene.getLastEntryById(transformNode._waitingParentId);\n                        }\n                        let parentNode = parent;\n                        if (transformNode._waitingParentInstanceIndex) {\n                            parentNode = parent.instances[parseInt(transformNode._waitingParentInstanceIndex)];\n                            transformNode._waitingParentInstanceIndex = null;\n                        }\n                        transformNode.parent = parentNode;\n                        transformNode._waitingParentId = null;\n                    }\n                }\n                let currentMesh;\n                for (let index = 0, cache = scene.meshes.length; index < cache; index++) {\n                    currentMesh = scene.meshes[index];\n                    if (currentMesh._waitingParentId) {\n                        let parent = parsedIdToNodeMap.get(parseInt(currentMesh._waitingParentId)) || null;\n                        if (parent === null) {\n                            parent = scene.getLastEntryById(currentMesh._waitingParentId);\n                        }\n                        let parentNode = parent;\n                        if (currentMesh._waitingParentInstanceIndex) {\n                            parentNode = parent.instances[parseInt(currentMesh._waitingParentInstanceIndex)];\n                            currentMesh._waitingParentInstanceIndex = null;\n                        }\n                        currentMesh.parent = parentNode;\n                        if (((_a = currentMesh.parent) === null || _a === void 0 ? void 0 : _a.getClassName()) === \"TransformNode\") {\n                            const loadedTransformNodeIndex = loadedTransformNodes.indexOf(currentMesh.parent);\n                            if (loadedTransformNodeIndex > -1) {\n                                loadedTransformNodes.splice(loadedTransformNodeIndex, 1);\n                            }\n                        }\n                        currentMesh._waitingParentId = null;\n                    }\n                    if (currentMesh._waitingData.lods) {\n                        loadDetailLevels(scene, currentMesh);\n                    }\n                }\n                // Remove unused transform nodes\n                for (const transformNode of loadedTransformNodes) {\n                    transformNode.dispose();\n                }\n                // link skeleton transform nodes\n                for (let index = 0, cache = scene.skeletons.length; index < cache; index++) {\n                    const skeleton = scene.skeletons[index];\n                    if (skeleton._hasWaitingData) {\n                        if (skeleton.bones != null) {\n                            skeleton.bones.forEach((bone) => {\n                                if (bone._waitingTransformNodeId) {\n                                    const linkTransformNode = scene.getLastEntryById(bone._waitingTransformNodeId);\n                                    if (linkTransformNode) {\n                                        bone.linkTransformNode(linkTransformNode);\n                                    }\n                                    bone._waitingTransformNodeId = null;\n                                }\n                            });\n                        }\n                        skeleton._hasWaitingData = null;\n                    }\n                }\n                // freeze and compute world matrix application\n                for (let index = 0, cache = scene.meshes.length; index < cache; index++) {\n                    currentMesh = scene.meshes[index];\n                    if (currentMesh._waitingData.freezeWorldMatrix) {\n                        currentMesh.freezeWorldMatrix();\n                        currentMesh._waitingData.freezeWorldMatrix = null;\n                    }\n                    else {\n                        currentMesh.computeWorldMatrix(true);\n                    }\n                }\n            }\n            // Particles\n            if (parsedData.particleSystems !== undefined && parsedData.particleSystems !== null) {\n                const parser = AbstractScene.GetIndividualParser(SceneComponentConstants.NAME_PARTICLESYSTEM);\n                if (parser) {\n                    for (let index = 0, cache = parsedData.particleSystems.length; index < cache; index++) {\n                        const parsedParticleSystem = parsedData.particleSystems[index];\n                        if (hierarchyIds.indexOf(parsedParticleSystem.emitterId) !== -1) {\n                            particleSystems.push(parser(parsedParticleSystem, scene, rootUrl));\n                        }\n                    }\n                }\n            }\n            scene.geometries.forEach((g) => {\n                g._loadedUniqueId = \"\";\n            });\n            return true;\n        }\n        catch (err) {\n            const msg = logOperation(\"importMesh\", parsedData ? parsedData.producer : \"Unknown\") + log;\n            if (onError) {\n                onError(msg, err);\n            }\n            else {\n                Logger.Log(msg);\n                throw err;\n            }\n        }\n        finally {\n            if (log !== null && SceneLoader.loggingLevel !== SceneLoader.NO_LOGGING) {\n                Logger.Log(logOperation(\"importMesh\", parsedData ? parsedData.producer : \"Unknown\") + (SceneLoader.loggingLevel !== SceneLoader.MINIMAL_LOGGING ? log : \"\"));\n            }\n        }\n        return false;\n    },\n    load: (scene, data, rootUrl, onError) => {\n        // Entire method running in try block, so ALWAYS logs as far as it got, only actually writes details\n        // when SceneLoader.debugLogging = true (default), or exception encountered.\n        // Everything stored in var log instead of writing separate lines to support only writing in exception,\n        // and avoid problems with multiple concurrent .babylon loads.\n        let log = \"importScene has failed JSON parse\";\n        try {\n            // eslint-disable-next-line no-var\n            var parsedData = JSON.parse(data);\n            log = \"\";\n            // Scene\n            if (parsedData.useDelayedTextureLoading !== undefined && parsedData.useDelayedTextureLoading !== null) {\n                scene.useDelayedTextureLoading = parsedData.useDelayedTextureLoading && !SceneLoader.ForceFullSceneLoadingForIncremental;\n            }\n            if (parsedData.autoClear !== undefined && parsedData.autoClear !== null) {\n                scene.autoClear = parsedData.autoClear;\n            }\n            if (parsedData.clearColor !== undefined && parsedData.clearColor !== null) {\n                scene.clearColor = Color4.FromArray(parsedData.clearColor);\n            }\n            if (parsedData.ambientColor !== undefined && parsedData.ambientColor !== null) {\n                scene.ambientColor = Color3.FromArray(parsedData.ambientColor);\n            }\n            if (parsedData.gravity !== undefined && parsedData.gravity !== null) {\n                scene.gravity = Vector3.FromArray(parsedData.gravity);\n            }\n            if (parsedData.useRightHandedSystem !== undefined) {\n                scene.useRightHandedSystem = !!parsedData.useRightHandedSystem;\n            }\n            // Fog\n            if (parsedData.fogMode && parsedData.fogMode !== 0) {\n                scene.fogMode = parsedData.fogMode;\n                scene.fogColor = Color3.FromArray(parsedData.fogColor);\n                scene.fogStart = parsedData.fogStart;\n                scene.fogEnd = parsedData.fogEnd;\n                scene.fogDensity = parsedData.fogDensity;\n                log += \"\\tFog mode for scene:  \";\n                switch (scene.fogMode) {\n                    // getters not compiling, so using hardcoded\n                    case 1:\n                        log += \"exp\\n\";\n                        break;\n                    case 2:\n                        log += \"exp2\\n\";\n                        break;\n                    case 3:\n                        log += \"linear\\n\";\n                        break;\n                }\n            }\n            //Physics\n            if (parsedData.physicsEnabled) {\n                let physicsPlugin;\n                if (parsedData.physicsEngine === \"cannon\" || parsedData.physicsEngine === CannonJSPlugin.name) {\n                    physicsPlugin = new CannonJSPlugin(undefined, undefined, BabylonFileLoaderConfiguration.LoaderInjectedPhysicsEngine);\n                }\n                else if (parsedData.physicsEngine === \"oimo\" || parsedData.physicsEngine === OimoJSPlugin.name) {\n                    physicsPlugin = new OimoJSPlugin(undefined, BabylonFileLoaderConfiguration.LoaderInjectedPhysicsEngine);\n                }\n                else if (parsedData.physicsEngine === \"ammo\" || parsedData.physicsEngine === AmmoJSPlugin.name) {\n                    physicsPlugin = new AmmoJSPlugin(undefined, BabylonFileLoaderConfiguration.LoaderInjectedPhysicsEngine, undefined);\n                }\n                log = \"\\tPhysics engine \" + (parsedData.physicsEngine ? parsedData.physicsEngine : \"oimo\") + \" enabled\\n\";\n                //else - default engine, which is currently oimo\n                const physicsGravity = parsedData.physicsGravity ? Vector3.FromArray(parsedData.physicsGravity) : null;\n                scene.enablePhysics(physicsGravity, physicsPlugin);\n            }\n            // Metadata\n            if (parsedData.metadata !== undefined && parsedData.metadata !== null) {\n                scene.metadata = parsedData.metadata;\n            }\n            //collisions, if defined. otherwise, default is true\n            if (parsedData.collisionsEnabled !== undefined && parsedData.collisionsEnabled !== null) {\n                scene.collisionsEnabled = parsedData.collisionsEnabled;\n            }\n            const container = loadAssetContainer(scene, data, rootUrl, onError, true);\n            if (!container) {\n                return false;\n            }\n            if (parsedData.autoAnimate) {\n                scene.beginAnimation(scene, parsedData.autoAnimateFrom, parsedData.autoAnimateTo, parsedData.autoAnimateLoop, parsedData.autoAnimateSpeed || 1.0);\n            }\n            if (parsedData.activeCameraID !== undefined && parsedData.activeCameraID !== null) {\n                scene.setActiveCameraById(parsedData.activeCameraID);\n            }\n            // Finish\n            return true;\n        }\n        catch (err) {\n            const msg = logOperation(\"importScene\", parsedData ? parsedData.producer : \"Unknown\") + log;\n            if (onError) {\n                onError(msg, err);\n            }\n            else {\n                Logger.Log(msg);\n                throw err;\n            }\n        }\n        finally {\n            if (log !== null && SceneLoader.loggingLevel !== SceneLoader.NO_LOGGING) {\n                Logger.Log(logOperation(\"importScene\", parsedData ? parsedData.producer : \"Unknown\") + (SceneLoader.loggingLevel !== SceneLoader.MINIMAL_LOGGING ? log : \"\"));\n            }\n        }\n        return false;\n    },\n    loadAssetContainer: (scene, data, rootUrl, onError) => {\n        const container = loadAssetContainer(scene, data, rootUrl, onError);\n        return container;\n    },\n});\n//# sourceMappingURL=babylonFileLoader.js.map","import { Tools } from \"../Misc/tools.js\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { Scene } from \"../scene.js\";\nimport { Engine } from \"../Engines/engine.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\nimport { Logger } from \"../Misc/logger.js\";\n\nimport { SceneLoaderFlags } from \"./sceneLoaderFlags.js\";\nimport { IsBase64DataUrl } from \"../Misc/fileTools.js\";\nimport { RuntimeError, ErrorCodes } from \"../Misc/error.js\";\n/**\n * Mode that determines how to handle old animation groups before loading new ones.\n */\nexport var SceneLoaderAnimationGroupLoadingMode;\n(function (SceneLoaderAnimationGroupLoadingMode) {\n    /**\n     * Reset all old animations to initial state then dispose them.\n     */\n    SceneLoaderAnimationGroupLoadingMode[SceneLoaderAnimationGroupLoadingMode[\"Clean\"] = 0] = \"Clean\";\n    /**\n     * Stop all old animations.\n     */\n    SceneLoaderAnimationGroupLoadingMode[SceneLoaderAnimationGroupLoadingMode[\"Stop\"] = 1] = \"Stop\";\n    /**\n     * Restart old animations from first frame.\n     */\n    SceneLoaderAnimationGroupLoadingMode[SceneLoaderAnimationGroupLoadingMode[\"Sync\"] = 2] = \"Sync\";\n    /**\n     * Old animations remains untouched.\n     */\n    SceneLoaderAnimationGroupLoadingMode[SceneLoaderAnimationGroupLoadingMode[\"NoSync\"] = 3] = \"NoSync\";\n})(SceneLoaderAnimationGroupLoadingMode || (SceneLoaderAnimationGroupLoadingMode = {}));\n/**\n * Class used to load scene from various file formats using registered plugins\n * @see https://doc.babylonjs.com/features/featuresDeepDive/importers/loadingFileTypes\n */\nexport class SceneLoader {\n    /**\n     * Gets or sets a boolean indicating if entire scene must be loaded even if scene contains incremental data\n     */\n    static get ForceFullSceneLoadingForIncremental() {\n        return SceneLoaderFlags.ForceFullSceneLoadingForIncremental;\n    }\n    static set ForceFullSceneLoadingForIncremental(value) {\n        SceneLoaderFlags.ForceFullSceneLoadingForIncremental = value;\n    }\n    /**\n     * Gets or sets a boolean indicating if loading screen must be displayed while loading a scene\n     */\n    static get ShowLoadingScreen() {\n        return SceneLoaderFlags.ShowLoadingScreen;\n    }\n    static set ShowLoadingScreen(value) {\n        SceneLoaderFlags.ShowLoadingScreen = value;\n    }\n    /**\n     * Defines the current logging level (while loading the scene)\n     * @ignorenaming\n     */\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    static get loggingLevel() {\n        return SceneLoaderFlags.loggingLevel;\n    }\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    static set loggingLevel(value) {\n        SceneLoaderFlags.loggingLevel = value;\n    }\n    /**\n     * Gets or set a boolean indicating if matrix weights must be cleaned upon loading\n     */\n    static get CleanBoneMatrixWeights() {\n        return SceneLoaderFlags.CleanBoneMatrixWeights;\n    }\n    static set CleanBoneMatrixWeights(value) {\n        SceneLoaderFlags.CleanBoneMatrixWeights = value;\n    }\n    /**\n     * Gets the default plugin (used to load Babylon files)\n     * @returns the .babylon plugin\n     */\n    static GetDefaultPlugin() {\n        return SceneLoader._RegisteredPlugins[\".babylon\"];\n    }\n    static _GetPluginForExtension(extension) {\n        const registeredPlugin = SceneLoader._RegisteredPlugins[extension];\n        if (registeredPlugin) {\n            return registeredPlugin;\n        }\n        Logger.Warn(\"Unable to find a plugin to load \" +\n            extension +\n            \" files. Trying to use .babylon default plugin. To load from a specific filetype (eg. gltf) see: https://doc.babylonjs.com/features/featuresDeepDive/importers/loadingFileTypes\");\n        return SceneLoader.GetDefaultPlugin();\n    }\n    static _GetPluginForDirectLoad(data) {\n        for (const extension in SceneLoader._RegisteredPlugins) {\n            const plugin = SceneLoader._RegisteredPlugins[extension].plugin;\n            if (plugin.canDirectLoad && plugin.canDirectLoad(data)) {\n                return SceneLoader._RegisteredPlugins[extension];\n            }\n        }\n        return SceneLoader.GetDefaultPlugin();\n    }\n    static _GetPluginForFilename(sceneFilename) {\n        const queryStringPosition = sceneFilename.indexOf(\"?\");\n        if (queryStringPosition !== -1) {\n            sceneFilename = sceneFilename.substring(0, queryStringPosition);\n        }\n        const dotPosition = sceneFilename.lastIndexOf(\".\");\n        const extension = sceneFilename.substring(dotPosition, sceneFilename.length).toLowerCase();\n        return SceneLoader._GetPluginForExtension(extension);\n    }\n    static _GetDirectLoad(sceneFilename) {\n        if (sceneFilename.substr(0, 5) === \"data:\") {\n            return sceneFilename.substr(5);\n        }\n        return null;\n    }\n    static _FormatErrorMessage(fileInfo, message, exception) {\n        let errorMessage = \"Unable to load from \" + fileInfo.url;\n        if (message) {\n            errorMessage += `: ${message}`;\n        }\n        else if (exception) {\n            errorMessage += `: ${exception}`;\n        }\n        return errorMessage;\n    }\n    static _LoadData(fileInfo, scene, onSuccess, onProgress, onError, onDispose, pluginExtension) {\n        const directLoad = SceneLoader._GetDirectLoad(fileInfo.url);\n        const registeredPlugin = pluginExtension\n            ? SceneLoader._GetPluginForExtension(pluginExtension)\n            : directLoad\n                ? SceneLoader._GetPluginForDirectLoad(fileInfo.url)\n                : SceneLoader._GetPluginForFilename(fileInfo.url);\n        let plugin;\n        if (registeredPlugin.plugin.createPlugin !== undefined) {\n            plugin = registeredPlugin.plugin.createPlugin();\n        }\n        else {\n            plugin = registeredPlugin.plugin;\n        }\n        if (!plugin) {\n            throw \"The loader plugin corresponding to the file type you are trying to load has not been found. If using es6, please import the plugin you wish to use before.\";\n        }\n        SceneLoader.OnPluginActivatedObservable.notifyObservers(plugin);\n        // Check if we have a direct load url. If the plugin is registered to handle\n        // it or it's not a base64 data url, then pass it through the direct load path.\n        if (directLoad && ((plugin.canDirectLoad && plugin.canDirectLoad(fileInfo.url)) || !IsBase64DataUrl(fileInfo.url))) {\n            if (plugin.directLoad) {\n                const result = plugin.directLoad(scene, directLoad);\n                if (result.then) {\n                    result\n                        .then((data) => {\n                        onSuccess(plugin, data);\n                    })\n                        .catch((error) => {\n                        onError(\"Error in directLoad of _loadData: \" + error, error);\n                    });\n                }\n                else {\n                    onSuccess(plugin, result);\n                }\n            }\n            else {\n                onSuccess(plugin, directLoad);\n            }\n            return plugin;\n        }\n        const useArrayBuffer = registeredPlugin.isBinary;\n        const dataCallback = (data, responseURL) => {\n            if (scene.isDisposed) {\n                onError(\"Scene has been disposed\");\n                return;\n            }\n            onSuccess(plugin, data, responseURL);\n        };\n        let request = null;\n        let pluginDisposed = false;\n        const onDisposeObservable = plugin.onDisposeObservable;\n        if (onDisposeObservable) {\n            onDisposeObservable.add(() => {\n                pluginDisposed = true;\n                if (request) {\n                    request.abort();\n                    request = null;\n                }\n                onDispose();\n            });\n        }\n        const manifestChecked = () => {\n            if (pluginDisposed) {\n                return;\n            }\n            const errorCallback = (request, exception) => {\n                onError(request === null || request === void 0 ? void 0 : request.statusText, exception);\n            };\n            const fileOrUrl = fileInfo.file || fileInfo.url;\n            request = plugin.loadFile\n                ? plugin.loadFile(scene, fileOrUrl, dataCallback, onProgress, useArrayBuffer, errorCallback)\n                : scene._loadFile(fileOrUrl, dataCallback, onProgress, true, useArrayBuffer, errorCallback);\n        };\n        const engine = scene.getEngine();\n        let canUseOfflineSupport = engine.enableOfflineSupport;\n        if (canUseOfflineSupport) {\n            // Also check for exceptions\n            let exceptionFound = false;\n            for (const regex of scene.disableOfflineSupportExceptionRules) {\n                if (regex.test(fileInfo.url)) {\n                    exceptionFound = true;\n                    break;\n                }\n            }\n            canUseOfflineSupport = !exceptionFound;\n        }\n        if (canUseOfflineSupport && Engine.OfflineProviderFactory) {\n            // Checking if a manifest file has been set for this scene and if offline mode has been requested\n            scene.offlineProvider = Engine.OfflineProviderFactory(fileInfo.url, manifestChecked, engine.disableManifestCheck);\n        }\n        else {\n            manifestChecked();\n        }\n        return plugin;\n    }\n    static _GetFileInfo(rootUrl, sceneFilename) {\n        let url;\n        let name;\n        let file = null;\n        if (!sceneFilename) {\n            url = rootUrl;\n            name = Tools.GetFilename(rootUrl);\n            rootUrl = Tools.GetFolderPath(rootUrl);\n        }\n        else if (sceneFilename.name) {\n            const sceneFile = sceneFilename;\n            url = `file:${sceneFile.name}`;\n            name = sceneFile.name;\n            file = sceneFile;\n        }\n        else if (typeof sceneFilename === \"string\" && sceneFilename.startsWith(\"data:\")) {\n            url = sceneFilename;\n            name = \"\";\n        }\n        else {\n            const filename = sceneFilename;\n            if (filename.substr(0, 1) === \"/\") {\n                Tools.Error(\"Wrong sceneFilename parameter\");\n                return null;\n            }\n            url = rootUrl + filename;\n            name = filename;\n        }\n        return {\n            url: url,\n            rootUrl: rootUrl,\n            name: name,\n            file: file,\n        };\n    }\n    // Public functions\n    /**\n     * Gets a plugin that can load the given extension\n     * @param extension defines the extension to load\n     * @returns a plugin or null if none works\n     */\n    static GetPluginForExtension(extension) {\n        return SceneLoader._GetPluginForExtension(extension).plugin;\n    }\n    /**\n     * Gets a boolean indicating that the given extension can be loaded\n     * @param extension defines the extension to load\n     * @returns true if the extension is supported\n     */\n    static IsPluginForExtensionAvailable(extension) {\n        return !!SceneLoader._RegisteredPlugins[extension];\n    }\n    /**\n     * Adds a new plugin to the list of registered plugins\n     * @param plugin defines the plugin to add\n     */\n    static RegisterPlugin(plugin) {\n        if (typeof plugin.extensions === \"string\") {\n            const extension = plugin.extensions;\n            SceneLoader._RegisteredPlugins[extension.toLowerCase()] = {\n                plugin: plugin,\n                isBinary: false,\n            };\n        }\n        else {\n            const extensions = plugin.extensions;\n            Object.keys(extensions).forEach((extension) => {\n                SceneLoader._RegisteredPlugins[extension.toLowerCase()] = {\n                    plugin: plugin,\n                    isBinary: extensions[extension].isBinary,\n                };\n            });\n        }\n    }\n    /**\n     * Import meshes into a scene\n     * @param meshNames an array of mesh names, a single mesh name, or empty string for all meshes that filter what meshes are imported\n     * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\n     * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\n     * @param scene the instance of BABYLON.Scene to append to\n     * @param onSuccess a callback with a list of imported meshes, particleSystems, skeletons, and animationGroups when import succeeds\n     * @param onProgress a callback with a progress event for each file being loaded\n     * @param onError a callback with the scene, a message, and possibly an exception when import fails\n     * @param pluginExtension the extension used to determine the plugin\n     * @returns The loaded plugin\n     */\n    static ImportMesh(meshNames, rootUrl, sceneFilename = \"\", scene = EngineStore.LastCreatedScene, onSuccess = null, onProgress = null, onError = null, pluginExtension = null) {\n        if (!scene) {\n            Logger.Error(\"No scene available to import mesh to\");\n            return null;\n        }\n        const fileInfo = SceneLoader._GetFileInfo(rootUrl, sceneFilename);\n        if (!fileInfo) {\n            return null;\n        }\n        const loadingToken = {};\n        scene.addPendingData(loadingToken);\n        const disposeHandler = () => {\n            scene.removePendingData(loadingToken);\n        };\n        const errorHandler = (message, exception) => {\n            const errorMessage = SceneLoader._FormatErrorMessage(fileInfo, message, exception);\n            if (onError) {\n                onError(scene, errorMessage, new RuntimeError(errorMessage, ErrorCodes.SceneLoaderError, exception));\n            }\n            else {\n                Logger.Error(errorMessage);\n                // should the exception be thrown?\n            }\n            disposeHandler();\n        };\n        const progressHandler = onProgress\n            ? (event) => {\n                try {\n                    onProgress(event);\n                }\n                catch (e) {\n                    errorHandler(\"Error in onProgress callback: \" + e, e);\n                }\n            }\n            : undefined;\n        const successHandler = (meshes, particleSystems, skeletons, animationGroups, transformNodes, geometries, lights) => {\n            scene.importedMeshesFiles.push(fileInfo.url);\n            if (onSuccess) {\n                try {\n                    onSuccess(meshes, particleSystems, skeletons, animationGroups, transformNodes, geometries, lights);\n                }\n                catch (e) {\n                    errorHandler(\"Error in onSuccess callback: \" + e, e);\n                }\n            }\n            scene.removePendingData(loadingToken);\n        };\n        return SceneLoader._LoadData(fileInfo, scene, (plugin, data, responseURL) => {\n            if (plugin.rewriteRootURL) {\n                fileInfo.rootUrl = plugin.rewriteRootURL(fileInfo.rootUrl, responseURL);\n            }\n            if (plugin.importMesh) {\n                const syncedPlugin = plugin;\n                const meshes = new Array();\n                const particleSystems = new Array();\n                const skeletons = new Array();\n                if (!syncedPlugin.importMesh(meshNames, scene, data, fileInfo.rootUrl, meshes, particleSystems, skeletons, errorHandler)) {\n                    return;\n                }\n                scene.loadingPluginName = plugin.name;\n                successHandler(meshes, particleSystems, skeletons, [], [], [], []);\n            }\n            else {\n                const asyncedPlugin = plugin;\n                asyncedPlugin\n                    .importMeshAsync(meshNames, scene, data, fileInfo.rootUrl, progressHandler, fileInfo.name)\n                    .then((result) => {\n                    scene.loadingPluginName = plugin.name;\n                    successHandler(result.meshes, result.particleSystems, result.skeletons, result.animationGroups, result.transformNodes, result.geometries, result.lights);\n                })\n                    .catch((error) => {\n                    errorHandler(error.message, error);\n                });\n            }\n        }, progressHandler, errorHandler, disposeHandler, pluginExtension);\n    }\n    /**\n     * Import meshes into a scene\n     * @param meshNames an array of mesh names, a single mesh name, or empty string for all meshes that filter what meshes are imported\n     * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\n     * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\n     * @param scene the instance of BABYLON.Scene to append to\n     * @param onProgress a callback with a progress event for each file being loaded\n     * @param pluginExtension the extension used to determine the plugin\n     * @returns The loaded list of imported meshes, particle systems, skeletons, and animation groups\n     */\n    static ImportMeshAsync(meshNames, rootUrl, sceneFilename = \"\", scene = EngineStore.LastCreatedScene, onProgress = null, pluginExtension = null) {\n        return new Promise((resolve, reject) => {\n            SceneLoader.ImportMesh(meshNames, rootUrl, sceneFilename, scene, (meshes, particleSystems, skeletons, animationGroups, transformNodes, geometries, lights) => {\n                resolve({\n                    meshes: meshes,\n                    particleSystems: particleSystems,\n                    skeletons: skeletons,\n                    animationGroups: animationGroups,\n                    transformNodes: transformNodes,\n                    geometries: geometries,\n                    lights: lights,\n                });\n            }, onProgress, (scene, message, exception) => {\n                reject(exception || new Error(message));\n            }, pluginExtension);\n        });\n    }\n    /**\n     * Load a scene\n     * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\n     * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\n     * @param engine is the instance of BABYLON.Engine to use to create the scene\n     * @param onSuccess a callback with the scene when import succeeds\n     * @param onProgress a callback with a progress event for each file being loaded\n     * @param onError a callback with the scene, a message, and possibly an exception when import fails\n     * @param pluginExtension the extension used to determine the plugin\n     * @returns The loaded plugin\n     */\n    static Load(rootUrl, sceneFilename = \"\", engine = EngineStore.LastCreatedEngine, onSuccess = null, onProgress = null, onError = null, pluginExtension = null) {\n        if (!engine) {\n            Tools.Error(\"No engine available\");\n            return null;\n        }\n        return SceneLoader.Append(rootUrl, sceneFilename, new Scene(engine), onSuccess, onProgress, onError, pluginExtension);\n    }\n    /**\n     * Load a scene\n     * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\n     * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\n     * @param engine is the instance of BABYLON.Engine to use to create the scene\n     * @param onProgress a callback with a progress event for each file being loaded\n     * @param pluginExtension the extension used to determine the plugin\n     * @returns The loaded scene\n     */\n    static LoadAsync(rootUrl, sceneFilename = \"\", engine = EngineStore.LastCreatedEngine, onProgress = null, pluginExtension = null) {\n        return new Promise((resolve, reject) => {\n            SceneLoader.Load(rootUrl, sceneFilename, engine, (scene) => {\n                resolve(scene);\n            }, onProgress, (scene, message, exception) => {\n                reject(exception || new Error(message));\n            }, pluginExtension);\n        });\n    }\n    /**\n     * Append a scene\n     * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\n     * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\n     * @param scene is the instance of BABYLON.Scene to append to\n     * @param onSuccess a callback with the scene when import succeeds\n     * @param onProgress a callback with a progress event for each file being loaded\n     * @param onError a callback with the scene, a message, and possibly an exception when import fails\n     * @param pluginExtension the extension used to determine the plugin\n     * @returns The loaded plugin\n     */\n    static Append(rootUrl, sceneFilename = \"\", scene = EngineStore.LastCreatedScene, onSuccess = null, onProgress = null, onError = null, pluginExtension = null) {\n        if (!scene) {\n            Logger.Error(\"No scene available to append to\");\n            return null;\n        }\n        const fileInfo = SceneLoader._GetFileInfo(rootUrl, sceneFilename);\n        if (!fileInfo) {\n            return null;\n        }\n        const loadingToken = {};\n        scene.addPendingData(loadingToken);\n        const disposeHandler = () => {\n            scene.removePendingData(loadingToken);\n        };\n        if (SceneLoader.ShowLoadingScreen && !this._ShowingLoadingScreen) {\n            this._ShowingLoadingScreen = true;\n            scene.getEngine().displayLoadingUI();\n            scene.executeWhenReady(() => {\n                scene.getEngine().hideLoadingUI();\n                this._ShowingLoadingScreen = false;\n            });\n        }\n        const errorHandler = (message, exception) => {\n            const errorMessage = SceneLoader._FormatErrorMessage(fileInfo, message, exception);\n            if (onError) {\n                onError(scene, errorMessage, new RuntimeError(errorMessage, ErrorCodes.SceneLoaderError, exception));\n            }\n            else {\n                Logger.Error(errorMessage);\n                // should the exception be thrown?\n            }\n            disposeHandler();\n        };\n        const progressHandler = onProgress\n            ? (event) => {\n                try {\n                    onProgress(event);\n                }\n                catch (e) {\n                    errorHandler(\"Error in onProgress callback\", e);\n                }\n            }\n            : undefined;\n        const successHandler = () => {\n            if (onSuccess) {\n                try {\n                    onSuccess(scene);\n                }\n                catch (e) {\n                    errorHandler(\"Error in onSuccess callback\", e);\n                }\n            }\n            scene.removePendingData(loadingToken);\n        };\n        return SceneLoader._LoadData(fileInfo, scene, (plugin, data) => {\n            if (plugin.load) {\n                const syncedPlugin = plugin;\n                if (!syncedPlugin.load(scene, data, fileInfo.rootUrl, errorHandler)) {\n                    return;\n                }\n                scene.loadingPluginName = plugin.name;\n                successHandler();\n            }\n            else {\n                const asyncedPlugin = plugin;\n                asyncedPlugin\n                    .loadAsync(scene, data, fileInfo.rootUrl, progressHandler, fileInfo.name)\n                    .then(() => {\n                    scene.loadingPluginName = plugin.name;\n                    successHandler();\n                })\n                    .catch((error) => {\n                    errorHandler(error.message, error);\n                });\n            }\n        }, progressHandler, errorHandler, disposeHandler, pluginExtension);\n    }\n    /**\n     * Append a scene\n     * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\n     * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\n     * @param scene is the instance of BABYLON.Scene to append to\n     * @param onProgress a callback with a progress event for each file being loaded\n     * @param pluginExtension the extension used to determine the plugin\n     * @returns The given scene\n     */\n    static AppendAsync(rootUrl, sceneFilename = \"\", scene = EngineStore.LastCreatedScene, onProgress = null, pluginExtension = null) {\n        return new Promise((resolve, reject) => {\n            SceneLoader.Append(rootUrl, sceneFilename, scene, (scene) => {\n                resolve(scene);\n            }, onProgress, (scene, message, exception) => {\n                reject(exception || new Error(message));\n            }, pluginExtension);\n        });\n    }\n    /**\n     * Load a scene into an asset container\n     * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\n     * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\n     * @param scene is the instance of BABYLON.Scene to append to (default: last created scene)\n     * @param onSuccess a callback with the scene when import succeeds\n     * @param onProgress a callback with a progress event for each file being loaded\n     * @param onError a callback with the scene, a message, and possibly an exception when import fails\n     * @param pluginExtension the extension used to determine the plugin\n     * @returns The loaded plugin\n     */\n    static LoadAssetContainer(rootUrl, sceneFilename = \"\", scene = EngineStore.LastCreatedScene, onSuccess = null, onProgress = null, onError = null, pluginExtension = null) {\n        if (!scene) {\n            Logger.Error(\"No scene available to load asset container to\");\n            return null;\n        }\n        const fileInfo = SceneLoader._GetFileInfo(rootUrl, sceneFilename);\n        if (!fileInfo) {\n            return null;\n        }\n        const loadingToken = {};\n        scene.addPendingData(loadingToken);\n        const disposeHandler = () => {\n            scene.removePendingData(loadingToken);\n        };\n        const errorHandler = (message, exception) => {\n            const errorMessage = SceneLoader._FormatErrorMessage(fileInfo, message, exception);\n            if (onError) {\n                onError(scene, errorMessage, new RuntimeError(errorMessage, ErrorCodes.SceneLoaderError, exception));\n            }\n            else {\n                Logger.Error(errorMessage);\n                // should the exception be thrown?\n            }\n            disposeHandler();\n        };\n        const progressHandler = onProgress\n            ? (event) => {\n                try {\n                    onProgress(event);\n                }\n                catch (e) {\n                    errorHandler(\"Error in onProgress callback\", e);\n                }\n            }\n            : undefined;\n        const successHandler = (assets) => {\n            if (onSuccess) {\n                try {\n                    onSuccess(assets);\n                }\n                catch (e) {\n                    errorHandler(\"Error in onSuccess callback\", e);\n                }\n            }\n            scene.removePendingData(loadingToken);\n        };\n        return SceneLoader._LoadData(fileInfo, scene, (plugin, data) => {\n            if (plugin.loadAssetContainer) {\n                const syncedPlugin = plugin;\n                const assetContainer = syncedPlugin.loadAssetContainer(scene, data, fileInfo.rootUrl, errorHandler);\n                if (!assetContainer) {\n                    return;\n                }\n                scene.loadingPluginName = plugin.name;\n                successHandler(assetContainer);\n            }\n            else if (plugin.loadAssetContainerAsync) {\n                const asyncedPlugin = plugin;\n                asyncedPlugin\n                    .loadAssetContainerAsync(scene, data, fileInfo.rootUrl, progressHandler, fileInfo.name)\n                    .then((assetContainer) => {\n                    scene.loadingPluginName = plugin.name;\n                    successHandler(assetContainer);\n                })\n                    .catch((error) => {\n                    errorHandler(error.message, error);\n                });\n            }\n            else {\n                errorHandler(\"LoadAssetContainer is not supported by this plugin. Plugin did not provide a loadAssetContainer or loadAssetContainerAsync method.\");\n            }\n        }, progressHandler, errorHandler, disposeHandler, pluginExtension);\n    }\n    /**\n     * Load a scene into an asset container\n     * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\n     * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene (default: empty string)\n     * @param scene is the instance of Scene to append to\n     * @param onProgress a callback with a progress event for each file being loaded\n     * @param pluginExtension the extension used to determine the plugin\n     * @returns The loaded asset container\n     */\n    static LoadAssetContainerAsync(rootUrl, sceneFilename = \"\", scene = EngineStore.LastCreatedScene, onProgress = null, pluginExtension = null) {\n        return new Promise((resolve, reject) => {\n            SceneLoader.LoadAssetContainer(rootUrl, sceneFilename, scene, (assetContainer) => {\n                resolve(assetContainer);\n            }, onProgress, (scene, message, exception) => {\n                reject(exception || new Error(message));\n            }, pluginExtension);\n        });\n    }\n    /**\n     * Import animations from a file into a scene\n     * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\n     * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\n     * @param scene is the instance of BABYLON.Scene to append to (default: last created scene)\n     * @param overwriteAnimations when true, animations are cleaned before importing new ones. Animations are appended otherwise\n     * @param animationGroupLoadingMode defines how to handle old animations groups before importing new ones\n     * @param targetConverter defines a function used to convert animation targets from loaded scene to current scene (default: search node by name)\n     * @param onSuccess a callback with the scene when import succeeds\n     * @param onProgress a callback with a progress event for each file being loaded\n     * @param onError a callback with the scene, a message, and possibly an exception when import fails\n     * @param pluginExtension the extension used to determine the plugin\n     */\n    static ImportAnimations(rootUrl, sceneFilename = \"\", scene = EngineStore.LastCreatedScene, overwriteAnimations = true, animationGroupLoadingMode = SceneLoaderAnimationGroupLoadingMode.Clean, targetConverter = null, onSuccess = null, onProgress = null, onError = null, pluginExtension = null) {\n        if (!scene) {\n            Logger.Error(\"No scene available to load animations to\");\n            return;\n        }\n        if (overwriteAnimations) {\n            // Reset, stop and dispose all animations before loading new ones\n            for (const animatable of scene.animatables) {\n                animatable.reset();\n            }\n            scene.stopAllAnimations();\n            scene.animationGroups.slice().forEach((animationGroup) => {\n                animationGroup.dispose();\n            });\n            const nodes = scene.getNodes();\n            nodes.forEach((node) => {\n                if (node.animations) {\n                    node.animations = [];\n                }\n            });\n        }\n        else {\n            switch (animationGroupLoadingMode) {\n                case SceneLoaderAnimationGroupLoadingMode.Clean:\n                    scene.animationGroups.slice().forEach((animationGroup) => {\n                        animationGroup.dispose();\n                    });\n                    break;\n                case SceneLoaderAnimationGroupLoadingMode.Stop:\n                    scene.animationGroups.forEach((animationGroup) => {\n                        animationGroup.stop();\n                    });\n                    break;\n                case SceneLoaderAnimationGroupLoadingMode.Sync:\n                    scene.animationGroups.forEach((animationGroup) => {\n                        animationGroup.reset();\n                        animationGroup.restart();\n                    });\n                    break;\n                case SceneLoaderAnimationGroupLoadingMode.NoSync:\n                    // nothing to do\n                    break;\n                default:\n                    Logger.Error(\"Unknown animation group loading mode value '\" + animationGroupLoadingMode + \"'\");\n                    return;\n            }\n        }\n        const startingIndexForNewAnimatables = scene.animatables.length;\n        const onAssetContainerLoaded = (container) => {\n            container.mergeAnimationsTo(scene, scene.animatables.slice(startingIndexForNewAnimatables), targetConverter);\n            container.dispose();\n            scene.onAnimationFileImportedObservable.notifyObservers(scene);\n            if (onSuccess) {\n                onSuccess(scene);\n            }\n        };\n        this.LoadAssetContainer(rootUrl, sceneFilename, scene, onAssetContainerLoaded, onProgress, onError, pluginExtension);\n    }\n    /**\n     * Import animations from a file into a scene\n     * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\n     * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\n     * @param scene is the instance of BABYLON.Scene to append to (default: last created scene)\n     * @param overwriteAnimations when true, animations are cleaned before importing new ones. Animations are appended otherwise\n     * @param animationGroupLoadingMode defines how to handle old animations groups before importing new ones\n     * @param targetConverter defines a function used to convert animation targets from loaded scene to current scene (default: search node by name)\n     * @param onSuccess a callback with the scene when import succeeds\n     * @param onProgress a callback with a progress event for each file being loaded\n     * @param onError a callback with the scene, a message, and possibly an exception when import fails\n     * @param pluginExtension the extension used to determine the plugin\n     * @returns the updated scene with imported animations\n     */\n    static ImportAnimationsAsync(rootUrl, sceneFilename = \"\", scene = EngineStore.LastCreatedScene, overwriteAnimations = true, animationGroupLoadingMode = SceneLoaderAnimationGroupLoadingMode.Clean, targetConverter = null, \n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    onSuccess = null, onProgress = null, \n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    onError = null, pluginExtension = null) {\n        return new Promise((resolve, reject) => {\n            SceneLoader.ImportAnimations(rootUrl, sceneFilename, scene, overwriteAnimations, animationGroupLoadingMode, targetConverter, (_scene) => {\n                resolve(_scene);\n            }, onProgress, (_scene, message, exception) => {\n                reject(exception || new Error(message));\n            }, pluginExtension);\n        });\n    }\n}\n/**\n * No logging while loading\n */\nSceneLoader.NO_LOGGING = 0;\n/**\n * Minimal logging while loading\n */\nSceneLoader.MINIMAL_LOGGING = 1;\n/**\n * Summary logging while loading\n */\nSceneLoader.SUMMARY_LOGGING = 2;\n/**\n * Detailed logging while loading\n */\nSceneLoader.DETAILED_LOGGING = 3;\n// Members\n/**\n * Event raised when a plugin is used to load a scene\n */\nSceneLoader.OnPluginActivatedObservable = new Observable();\nSceneLoader._RegisteredPlugins = {};\nSceneLoader._ShowingLoadingScreen = false;\n//# sourceMappingURL=sceneLoader.js.map","\n/**\n * Class used to represent data loading progression\n */\nexport class SceneLoaderFlags {\n    /**\n     * Gets or sets a boolean indicating if entire scene must be loaded even if scene contains incremental data\n     */\n    static get ForceFullSceneLoadingForIncremental() {\n        return SceneLoaderFlags._ForceFullSceneLoadingForIncremental;\n    }\n    static set ForceFullSceneLoadingForIncremental(value) {\n        SceneLoaderFlags._ForceFullSceneLoadingForIncremental = value;\n    }\n    /**\n     * Gets or sets a boolean indicating if loading screen must be displayed while loading a scene\n     */\n    static get ShowLoadingScreen() {\n        return SceneLoaderFlags._ShowLoadingScreen;\n    }\n    static set ShowLoadingScreen(value) {\n        SceneLoaderFlags._ShowLoadingScreen = value;\n    }\n    /**\n     * Defines the current logging level (while loading the scene)\n     * @ignorenaming\n     */\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    static get loggingLevel() {\n        return SceneLoaderFlags._LoggingLevel;\n    }\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    static set loggingLevel(value) {\n        SceneLoaderFlags._LoggingLevel = value;\n    }\n    /**\n     * Gets or set a boolean indicating if matrix weights must be cleaned upon loading\n     */\n    static get CleanBoneMatrixWeights() {\n        return SceneLoaderFlags._CleanBoneMatrixWeights;\n    }\n    static set CleanBoneMatrixWeights(value) {\n        SceneLoaderFlags._CleanBoneMatrixWeights = value;\n    }\n}\n// Flags\nSceneLoaderFlags._ForceFullSceneLoadingForIncremental = false;\nSceneLoaderFlags._ShowLoadingScreen = true;\nSceneLoaderFlags._CleanBoneMatrixWeights = false;\nSceneLoaderFlags._LoggingLevel = 0;\n//# sourceMappingURL=sceneLoaderFlags.js.map","import { __decorate } from \"../../tslib.es6.js\";\n/* eslint-disable @typescript-eslint/naming-convention */\nimport { SerializationHelper, serialize, serializeAsColor3, expandToProperty, serializeAsTexture, serializeAsVector3, serializeAsImageProcessingConfiguration, } from \"../../Misc/decorators.js\";\nimport { SmartArray } from \"../../Misc/smartArray.js\";\nimport { Logger } from \"../../Misc/logger.js\";\nimport { ScenePerformancePriority } from \"../../scene.js\";\nimport { Vector3, Vector4 } from \"../../Maths/math.vector.js\";\nimport { VertexBuffer } from \"../../Buffers/buffer.js\";\nimport { MaterialHelper } from \"../../Materials/materialHelper.js\";\nimport { MaterialDefines } from \"../../Materials/materialDefines.js\";\nimport { PushMaterial } from \"../../Materials/pushMaterial.js\";\nimport { ImageProcessingConfiguration } from \"../../Materials/imageProcessingConfiguration.js\";\nimport { Texture } from \"../../Materials/Textures/texture.js\";\n\nimport { RegisterClass } from \"../../Misc/typeStore.js\";\nimport { MaterialFlags } from \"../materialFlags.js\";\nimport { Color3 } from \"../../Maths/math.color.js\";\nimport \"../../Shaders/background.fragment.js\";\nimport \"../../Shaders/background.vertex.js\";\nimport { EffectFallbacks } from \"../effectFallbacks.js\";\nimport { addClipPlaneUniforms, bindClipPlane } from \"../clipPlaneMaterialHelper.js\";\n/**\n * Background material defines definition.\n * @internal Mainly internal Use\n */\nclass BackgroundMaterialDefines extends MaterialDefines {\n    /**\n     * Constructor of the defines.\n     */\n    constructor() {\n        super();\n        /**\n         * True if the diffuse texture is in use.\n         */\n        this.DIFFUSE = false;\n        /**\n         * The direct UV channel to use.\n         */\n        this.DIFFUSEDIRECTUV = 0;\n        /**\n         * True if the diffuse texture is in gamma space.\n         */\n        this.GAMMADIFFUSE = false;\n        /**\n         * True if the diffuse texture has opacity in the alpha channel.\n         */\n        this.DIFFUSEHASALPHA = false;\n        /**\n         * True if you want the material to fade to transparent at grazing angle.\n         */\n        this.OPACITYFRESNEL = false;\n        /**\n         * True if an extra blur needs to be added in the reflection.\n         */\n        this.REFLECTIONBLUR = false;\n        /**\n         * True if you want the material to fade to reflection at grazing angle.\n         */\n        this.REFLECTIONFRESNEL = false;\n        /**\n         * True if you want the material to falloff as far as you move away from the scene center.\n         */\n        this.REFLECTIONFALLOFF = false;\n        /**\n         * False if the current Webgl implementation does not support the texture lod extension.\n         */\n        this.TEXTURELODSUPPORT = false;\n        /**\n         * True to ensure the data are premultiplied.\n         */\n        this.PREMULTIPLYALPHA = false;\n        /**\n         * True if the texture contains cooked RGB values and not gray scaled multipliers.\n         */\n        this.USERGBCOLOR = false;\n        /**\n         * True if highlight and shadow levels have been specified. It can help ensuring the main perceived color\n         * stays aligned with the desired configuration.\n         */\n        this.USEHIGHLIGHTANDSHADOWCOLORS = false;\n        /**\n         * True if only shadows must be rendered\n         */\n        this.BACKMAT_SHADOWONLY = false;\n        /**\n         * True to add noise in order to reduce the banding effect.\n         */\n        this.NOISE = false;\n        /**\n         * is the reflection texture in BGR color scheme?\n         * Mainly used to solve a bug in ios10 video tag\n         */\n        this.REFLECTIONBGR = false;\n        this.IMAGEPROCESSING = false;\n        this.VIGNETTE = false;\n        this.VIGNETTEBLENDMODEMULTIPLY = false;\n        this.VIGNETTEBLENDMODEOPAQUE = false;\n        this.TONEMAPPING = false;\n        this.TONEMAPPING_ACES = false;\n        this.CONTRAST = false;\n        this.COLORCURVES = false;\n        this.COLORGRADING = false;\n        this.COLORGRADING3D = false;\n        this.SAMPLER3DGREENDEPTH = false;\n        this.SAMPLER3DBGRMAP = false;\n        this.DITHER = false;\n        this.IMAGEPROCESSINGPOSTPROCESS = false;\n        this.SKIPFINALCOLORCLAMP = false;\n        this.EXPOSURE = false;\n        this.MULTIVIEW = false;\n        // Reflection.\n        this.REFLECTION = false;\n        this.REFLECTIONMAP_3D = false;\n        this.REFLECTIONMAP_SPHERICAL = false;\n        this.REFLECTIONMAP_PLANAR = false;\n        this.REFLECTIONMAP_CUBIC = false;\n        this.REFLECTIONMAP_PROJECTION = false;\n        this.REFLECTIONMAP_SKYBOX = false;\n        this.REFLECTIONMAP_EXPLICIT = false;\n        this.REFLECTIONMAP_EQUIRECTANGULAR = false;\n        this.REFLECTIONMAP_EQUIRECTANGULAR_FIXED = false;\n        this.REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED = false;\n        this.INVERTCUBICMAP = false;\n        this.REFLECTIONMAP_OPPOSITEZ = false;\n        this.LODINREFLECTIONALPHA = false;\n        this.GAMMAREFLECTION = false;\n        this.RGBDREFLECTION = false;\n        this.EQUIRECTANGULAR_RELFECTION_FOV = false;\n        // Default BJS.\n        this.MAINUV1 = false;\n        this.MAINUV2 = false;\n        this.UV1 = false;\n        this.UV2 = false;\n        this.CLIPPLANE = false;\n        this.CLIPPLANE2 = false;\n        this.CLIPPLANE3 = false;\n        this.CLIPPLANE4 = false;\n        this.CLIPPLANE5 = false;\n        this.CLIPPLANE6 = false;\n        this.POINTSIZE = false;\n        this.FOG = false;\n        this.NORMAL = false;\n        this.NUM_BONE_INFLUENCERS = 0;\n        this.BonesPerMesh = 0;\n        this.INSTANCES = false;\n        this.SHADOWFLOAT = false;\n        this.LOGARITHMICDEPTH = false;\n        this.NONUNIFORMSCALING = false;\n        this.ALPHATEST = false;\n        this.rebuild();\n    }\n}\n/**\n * Background material used to create an efficient environment around your scene.\n */\nexport class BackgroundMaterial extends PushMaterial {\n    /**\n     * Experimental Internal Use Only.\n     *\n     * Key light Color in \"perceptual value\" meaning the color you would like to see on screen.\n     * This acts as a helper to set the primary color to a more \"human friendly\" value.\n     * Conversion to linear space as well as exposure and tone mapping correction will be applied to keep the\n     * output color as close as possible from the chosen value.\n     * (This does not account for contrast color grading and color curves as they are considered post effect and not directly\n     * part of lighting setup.)\n     */\n    get _perceptualColor() {\n        return this.__perceptualColor;\n    }\n    set _perceptualColor(value) {\n        this.__perceptualColor = value;\n        this._computePrimaryColorFromPerceptualColor();\n        this._markAllSubMeshesAsLightsDirty();\n    }\n    /**\n     * Defines the level of the shadows (dark area of the reflection map) in order to help scaling the colors.\n     * The color opposite to the primary color is used at the level chosen to define what the black area would look.\n     */\n    get primaryColorShadowLevel() {\n        return this._primaryColorShadowLevel;\n    }\n    set primaryColorShadowLevel(value) {\n        this._primaryColorShadowLevel = value;\n        this._computePrimaryColors();\n        this._markAllSubMeshesAsLightsDirty();\n    }\n    /**\n     * Defines the level of the highlights (highlight area of the reflection map) in order to help scaling the colors.\n     * The primary color is used at the level chosen to define what the white area would look.\n     */\n    get primaryColorHighlightLevel() {\n        return this._primaryColorHighlightLevel;\n    }\n    set primaryColorHighlightLevel(value) {\n        this._primaryColorHighlightLevel = value;\n        this._computePrimaryColors();\n        this._markAllSubMeshesAsLightsDirty();\n    }\n    /**\n     * Sets the reflection reflectance fresnel values according to the default standard\n     * empirically know to work well :-)\n     */\n    set reflectionStandardFresnelWeight(value) {\n        let reflectionWeight = value;\n        if (reflectionWeight < 0.5) {\n            reflectionWeight = reflectionWeight * 2.0;\n            this.reflectionReflectance0 = BackgroundMaterial.StandardReflectance0 * reflectionWeight;\n            this.reflectionReflectance90 = BackgroundMaterial.StandardReflectance90 * reflectionWeight;\n        }\n        else {\n            reflectionWeight = reflectionWeight * 2.0 - 1.0;\n            this.reflectionReflectance0 = BackgroundMaterial.StandardReflectance0 + (1.0 - BackgroundMaterial.StandardReflectance0) * reflectionWeight;\n            this.reflectionReflectance90 = BackgroundMaterial.StandardReflectance90 + (1.0 - BackgroundMaterial.StandardReflectance90) * reflectionWeight;\n        }\n    }\n    /**\n     * The current fov(field of view) multiplier, 0.0 - 2.0. Defaults to 1.0. Lower values \"zoom in\" and higher values \"zoom out\".\n     * Best used when trying to implement visual zoom effects like fish-eye or binoculars while not adjusting camera fov.\n     * Recommended to be keep at 1.0 except for special cases.\n     */\n    get fovMultiplier() {\n        return this._fovMultiplier;\n    }\n    set fovMultiplier(value) {\n        if (isNaN(value)) {\n            value = 1.0;\n        }\n        this._fovMultiplier = Math.max(0.0, Math.min(2.0, value));\n    }\n    /**\n     * Attaches a new image processing configuration to the PBR Material.\n     * @param configuration (if null the scene configuration will be use)\n     */\n    _attachImageProcessingConfiguration(configuration) {\n        if (configuration === this._imageProcessingConfiguration) {\n            return;\n        }\n        // Detaches observer.\n        if (this._imageProcessingConfiguration && this._imageProcessingObserver) {\n            this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);\n        }\n        // Pick the scene configuration if needed.\n        if (!configuration) {\n            this._imageProcessingConfiguration = this.getScene().imageProcessingConfiguration;\n        }\n        else {\n            this._imageProcessingConfiguration = configuration;\n        }\n        // Attaches observer.\n        if (this._imageProcessingConfiguration) {\n            this._imageProcessingObserver = this._imageProcessingConfiguration.onUpdateParameters.add(() => {\n                this._computePrimaryColorFromPerceptualColor();\n                this._markAllSubMeshesAsImageProcessingDirty();\n            });\n        }\n    }\n    /**\n     * Gets the image processing configuration used either in this material.\n     */\n    get imageProcessingConfiguration() {\n        return this._imageProcessingConfiguration;\n    }\n    /**\n     * Sets the Default image processing configuration used either in the this material.\n     *\n     * If sets to null, the scene one is in use.\n     */\n    set imageProcessingConfiguration(value) {\n        this._attachImageProcessingConfiguration(value);\n        // Ensure the effect will be rebuilt.\n        this._markAllSubMeshesAsTexturesDirty();\n    }\n    /**\n     * Gets whether the color curves effect is enabled.\n     */\n    get cameraColorCurvesEnabled() {\n        return this.imageProcessingConfiguration.colorCurvesEnabled;\n    }\n    /**\n     * Sets whether the color curves effect is enabled.\n     */\n    set cameraColorCurvesEnabled(value) {\n        this.imageProcessingConfiguration.colorCurvesEnabled = value;\n    }\n    /**\n     * Gets whether the color grading effect is enabled.\n     */\n    get cameraColorGradingEnabled() {\n        return this.imageProcessingConfiguration.colorGradingEnabled;\n    }\n    /**\n     * Gets whether the color grading effect is enabled.\n     */\n    set cameraColorGradingEnabled(value) {\n        this.imageProcessingConfiguration.colorGradingEnabled = value;\n    }\n    /**\n     * Gets whether tonemapping is enabled or not.\n     */\n    get cameraToneMappingEnabled() {\n        return this._imageProcessingConfiguration.toneMappingEnabled;\n    }\n    /**\n     * Sets whether tonemapping is enabled or not\n     */\n    set cameraToneMappingEnabled(value) {\n        this._imageProcessingConfiguration.toneMappingEnabled = value;\n    }\n    /**\n     * The camera exposure used on this material.\n     * This property is here and not in the camera to allow controlling exposure without full screen post process.\n     * This corresponds to a photographic exposure.\n     */\n    get cameraExposure() {\n        return this._imageProcessingConfiguration.exposure;\n    }\n    /**\n     * The camera exposure used on this material.\n     * This property is here and not in the camera to allow controlling exposure without full screen post process.\n     * This corresponds to a photographic exposure.\n     */\n    set cameraExposure(value) {\n        this._imageProcessingConfiguration.exposure = value;\n    }\n    /**\n     * Gets The camera contrast used on this material.\n     */\n    get cameraContrast() {\n        return this._imageProcessingConfiguration.contrast;\n    }\n    /**\n     * Sets The camera contrast used on this material.\n     */\n    set cameraContrast(value) {\n        this._imageProcessingConfiguration.contrast = value;\n    }\n    /**\n     * Gets the Color Grading 2D Lookup Texture.\n     */\n    get cameraColorGradingTexture() {\n        return this._imageProcessingConfiguration.colorGradingTexture;\n    }\n    /**\n     * Sets the Color Grading 2D Lookup Texture.\n     */\n    set cameraColorGradingTexture(value) {\n        this.imageProcessingConfiguration.colorGradingTexture = value;\n    }\n    /**\n     * The color grading curves provide additional color adjustment that is applied after any color grading transform (3D LUT).\n     * They allow basic adjustment of saturation and small exposure adjustments, along with color filter tinting to provide white balance adjustment or more stylistic effects.\n     * These are similar to controls found in many professional imaging or colorist software. The global controls are applied to the entire image. For advanced tuning, extra controls are provided to adjust the shadow, midtone and highlight areas of the image;\n     * corresponding to low luminance, medium luminance, and high luminance areas respectively.\n     */\n    get cameraColorCurves() {\n        return this.imageProcessingConfiguration.colorCurves;\n    }\n    /**\n     * The color grading curves provide additional color adjustment that is applied after any color grading transform (3D LUT).\n     * They allow basic adjustment of saturation and small exposure adjustments, along with color filter tinting to provide white balance adjustment or more stylistic effects.\n     * These are similar to controls found in many professional imaging or colorist software. The global controls are applied to the entire image. For advanced tuning, extra controls are provided to adjust the shadow, midtone and highlight areas of the image;\n     * corresponding to low luminance, medium luminance, and high luminance areas respectively.\n     */\n    set cameraColorCurves(value) {\n        this.imageProcessingConfiguration.colorCurves = value;\n    }\n    /**\n     * Instantiates a Background Material in the given scene\n     * @param name The friendly name of the material\n     * @param scene The scene to add the material to\n     */\n    constructor(name, scene) {\n        super(name, scene);\n        /**\n         * Key light Color (multiply against the environment texture)\n         */\n        this.primaryColor = Color3.White();\n        this._primaryColorShadowLevel = 0;\n        this._primaryColorHighlightLevel = 0;\n        /**\n         * Reflection Texture used in the material.\n         * Should be author in a specific way for the best result (refer to the documentation).\n         */\n        this.reflectionTexture = null;\n        /**\n         * Reflection Texture level of blur.\n         *\n         * Can be use to reuse an existing HDR Texture and target a specific LOD to prevent authoring the\n         * texture twice.\n         */\n        this.reflectionBlur = 0;\n        /**\n         * Diffuse Texture used in the material.\n         * Should be author in a specific way for the best result (refer to the documentation).\n         */\n        this.diffuseTexture = null;\n        this._shadowLights = null;\n        /**\n         * Specify the list of lights casting shadow on the material.\n         * All scene shadow lights will be included if null.\n         */\n        this.shadowLights = null;\n        /**\n         * Helps adjusting the shadow to a softer level if required.\n         * 0 means black shadows and 1 means no shadows.\n         */\n        this.shadowLevel = 0;\n        /**\n         * In case of opacity Fresnel or reflection falloff, this is use as a scene center.\n         * It is usually zero but might be interesting to modify according to your setup.\n         */\n        this.sceneCenter = Vector3.Zero();\n        /**\n         * This helps specifying that the material is falling off to the sky box at grazing angle.\n         * This helps ensuring a nice transition when the camera goes under the ground.\n         */\n        this.opacityFresnel = true;\n        /**\n         * This helps specifying that the material is falling off from diffuse to the reflection texture at grazing angle.\n         * This helps adding a mirror texture on the ground.\n         */\n        this.reflectionFresnel = false;\n        /**\n         * This helps specifying the falloff radius off the reflection texture from the sceneCenter.\n         * This helps adding a nice falloff effect to the reflection if used as a mirror for instance.\n         */\n        this.reflectionFalloffDistance = 0.0;\n        /**\n         * This specifies the weight of the reflection against the background in case of reflection Fresnel.\n         */\n        this.reflectionAmount = 1.0;\n        /**\n         * This specifies the weight of the reflection at grazing angle.\n         */\n        this.reflectionReflectance0 = 0.05;\n        /**\n         * This specifies the weight of the reflection at a perpendicular point of view.\n         */\n        this.reflectionReflectance90 = 0.5;\n        /**\n         * Helps to directly use the maps channels instead of their level.\n         */\n        this.useRGBColor = true;\n        /**\n         * This helps reducing the banding effect that could occur on the background.\n         */\n        this.enableNoise = false;\n        this._fovMultiplier = 1.0;\n        /**\n         * Enable the FOV adjustment feature controlled by fovMultiplier.\n         */\n        this.useEquirectangularFOV = false;\n        this._maxSimultaneousLights = 4;\n        /**\n         * Number of Simultaneous lights allowed on the material.\n         */\n        this.maxSimultaneousLights = 4;\n        this._shadowOnly = false;\n        /**\n         * Make the material only render shadows\n         */\n        this.shadowOnly = false;\n        /**\n         * Keep track of the image processing observer to allow dispose and replace.\n         */\n        this._imageProcessingObserver = null;\n        /**\n         * Due to a bug in iOS10, video tags (which are using the background material) are in BGR and not RGB.\n         * Setting this flag to true (not done automatically!) will convert it back to RGB.\n         */\n        this.switchToBGR = false;\n        // Temp values kept as cache in the material.\n        this._renderTargets = new SmartArray(16);\n        this._reflectionControls = Vector4.Zero();\n        this._white = Color3.White();\n        this._primaryShadowColor = Color3.Black();\n        this._primaryHighlightColor = Color3.Black();\n        // Setup the default processing configuration to the scene.\n        this._attachImageProcessingConfiguration(null);\n        this.getRenderTargetTextures = () => {\n            this._renderTargets.reset();\n            if (this._diffuseTexture && this._diffuseTexture.isRenderTarget) {\n                this._renderTargets.push(this._diffuseTexture);\n            }\n            if (this._reflectionTexture && this._reflectionTexture.isRenderTarget) {\n                this._renderTargets.push(this._reflectionTexture);\n            }\n            return this._renderTargets;\n        };\n    }\n    /**\n     * Gets a boolean indicating that current material needs to register RTT\n     */\n    get hasRenderTargetTextures() {\n        if (this._diffuseTexture && this._diffuseTexture.isRenderTarget) {\n            return true;\n        }\n        if (this._reflectionTexture && this._reflectionTexture.isRenderTarget) {\n            return true;\n        }\n        return false;\n    }\n    /**\n     * The entire material has been created in order to prevent overdraw.\n     * @returns false\n     */\n    needAlphaTesting() {\n        return true;\n    }\n    /**\n     * The entire material has been created in order to prevent overdraw.\n     * @returns true if blending is enable\n     */\n    needAlphaBlending() {\n        return this.alpha < 1 || (this._diffuseTexture != null && this._diffuseTexture.hasAlpha) || this._shadowOnly;\n    }\n    /**\n     * Checks whether the material is ready to be rendered for a given mesh.\n     * @param mesh The mesh to render\n     * @param subMesh The submesh to check against\n     * @param useInstances Specify wether or not the material is used with instances\n     * @returns true if all the dependencies are ready (Textures, Effects...)\n     */\n    isReadyForSubMesh(mesh, subMesh, useInstances = false) {\n        if (subMesh.effect && this.isFrozen) {\n            if (subMesh.effect._wasPreviouslyReady && subMesh.effect._wasPreviouslyUsingInstances === useInstances) {\n                return true;\n            }\n        }\n        if (!subMesh.materialDefines) {\n            subMesh.materialDefines = new BackgroundMaterialDefines();\n        }\n        const scene = this.getScene();\n        const defines = subMesh.materialDefines;\n        if (this._isReadyForSubMesh(subMesh)) {\n            return true;\n        }\n        const engine = scene.getEngine();\n        // Lights\n        MaterialHelper.PrepareDefinesForLights(scene, mesh, defines, false, this._maxSimultaneousLights);\n        defines._needNormals = true;\n        // Multiview\n        MaterialHelper.PrepareDefinesForMultiview(scene, defines);\n        // Textures\n        if (defines._areTexturesDirty) {\n            defines._needUVs = false;\n            if (scene.texturesEnabled) {\n                if (scene.getEngine().getCaps().textureLOD) {\n                    defines.TEXTURELODSUPPORT = true;\n                }\n                if (this._diffuseTexture && MaterialFlags.DiffuseTextureEnabled) {\n                    if (!this._diffuseTexture.isReadyOrNotBlocking()) {\n                        return false;\n                    }\n                    MaterialHelper.PrepareDefinesForMergedUV(this._diffuseTexture, defines, \"DIFFUSE\");\n                    defines.DIFFUSEHASALPHA = this._diffuseTexture.hasAlpha;\n                    defines.GAMMADIFFUSE = this._diffuseTexture.gammaSpace;\n                    defines.OPACITYFRESNEL = this._opacityFresnel;\n                }\n                else {\n                    defines.DIFFUSE = false;\n                    defines.DIFFUSEDIRECTUV = 0;\n                    defines.DIFFUSEHASALPHA = false;\n                    defines.GAMMADIFFUSE = false;\n                    defines.OPACITYFRESNEL = false;\n                }\n                const reflectionTexture = this._reflectionTexture;\n                if (reflectionTexture && MaterialFlags.ReflectionTextureEnabled) {\n                    if (!reflectionTexture.isReadyOrNotBlocking()) {\n                        return false;\n                    }\n                    defines.REFLECTION = true;\n                    defines.GAMMAREFLECTION = reflectionTexture.gammaSpace;\n                    defines.RGBDREFLECTION = reflectionTexture.isRGBD;\n                    defines.REFLECTIONBLUR = this._reflectionBlur > 0;\n                    defines.LODINREFLECTIONALPHA = reflectionTexture.lodLevelInAlpha;\n                    defines.EQUIRECTANGULAR_RELFECTION_FOV = this.useEquirectangularFOV;\n                    defines.REFLECTIONBGR = this.switchToBGR;\n                    if (reflectionTexture.coordinatesMode === Texture.INVCUBIC_MODE) {\n                        defines.INVERTCUBICMAP = true;\n                    }\n                    defines.REFLECTIONMAP_3D = reflectionTexture.isCube;\n                    defines.REFLECTIONMAP_OPPOSITEZ = defines.REFLECTIONMAP_3D && this.getScene().useRightHandedSystem ? !reflectionTexture.invertZ : reflectionTexture.invertZ;\n                    switch (reflectionTexture.coordinatesMode) {\n                        case Texture.EXPLICIT_MODE:\n                            defines.REFLECTIONMAP_EXPLICIT = true;\n                            break;\n                        case Texture.PLANAR_MODE:\n                            defines.REFLECTIONMAP_PLANAR = true;\n                            break;\n                        case Texture.PROJECTION_MODE:\n                            defines.REFLECTIONMAP_PROJECTION = true;\n                            break;\n                        case Texture.SKYBOX_MODE:\n                            defines.REFLECTIONMAP_SKYBOX = true;\n                            break;\n                        case Texture.SPHERICAL_MODE:\n                            defines.REFLECTIONMAP_SPHERICAL = true;\n                            break;\n                        case Texture.EQUIRECTANGULAR_MODE:\n                            defines.REFLECTIONMAP_EQUIRECTANGULAR = true;\n                            break;\n                        case Texture.FIXED_EQUIRECTANGULAR_MODE:\n                            defines.REFLECTIONMAP_EQUIRECTANGULAR_FIXED = true;\n                            break;\n                        case Texture.FIXED_EQUIRECTANGULAR_MIRRORED_MODE:\n                            defines.REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED = true;\n                            break;\n                        case Texture.CUBIC_MODE:\n                        case Texture.INVCUBIC_MODE:\n                        default:\n                            defines.REFLECTIONMAP_CUBIC = true;\n                            break;\n                    }\n                    if (this.reflectionFresnel) {\n                        defines.REFLECTIONFRESNEL = true;\n                        defines.REFLECTIONFALLOFF = this.reflectionFalloffDistance > 0;\n                        this._reflectionControls.x = this.reflectionAmount;\n                        this._reflectionControls.y = this.reflectionReflectance0;\n                        this._reflectionControls.z = this.reflectionReflectance90;\n                        this._reflectionControls.w = 1 / this.reflectionFalloffDistance;\n                    }\n                    else {\n                        defines.REFLECTIONFRESNEL = false;\n                        defines.REFLECTIONFALLOFF = false;\n                    }\n                }\n                else {\n                    defines.REFLECTION = false;\n                    defines.REFLECTIONFRESNEL = false;\n                    defines.REFLECTIONFALLOFF = false;\n                    defines.REFLECTIONBLUR = false;\n                    defines.REFLECTIONMAP_3D = false;\n                    defines.REFLECTIONMAP_SPHERICAL = false;\n                    defines.REFLECTIONMAP_PLANAR = false;\n                    defines.REFLECTIONMAP_CUBIC = false;\n                    defines.REFLECTIONMAP_PROJECTION = false;\n                    defines.REFLECTIONMAP_SKYBOX = false;\n                    defines.REFLECTIONMAP_EXPLICIT = false;\n                    defines.REFLECTIONMAP_EQUIRECTANGULAR = false;\n                    defines.REFLECTIONMAP_EQUIRECTANGULAR_FIXED = false;\n                    defines.REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED = false;\n                    defines.INVERTCUBICMAP = false;\n                    defines.REFLECTIONMAP_OPPOSITEZ = false;\n                    defines.LODINREFLECTIONALPHA = false;\n                    defines.GAMMAREFLECTION = false;\n                    defines.RGBDREFLECTION = false;\n                }\n            }\n            defines.PREMULTIPLYALPHA = this.alphaMode === 7 || this.alphaMode === 8;\n            defines.USERGBCOLOR = this._useRGBColor;\n            defines.NOISE = this._enableNoise;\n        }\n        if (defines._areLightsDirty) {\n            defines.USEHIGHLIGHTANDSHADOWCOLORS = !this._useRGBColor && (this._primaryColorShadowLevel !== 0 || this._primaryColorHighlightLevel !== 0);\n            defines.BACKMAT_SHADOWONLY = this._shadowOnly;\n        }\n        if (defines._areImageProcessingDirty && this._imageProcessingConfiguration) {\n            if (!this._imageProcessingConfiguration.isReady()) {\n                return false;\n            }\n            this._imageProcessingConfiguration.prepareDefines(defines);\n        }\n        // Misc.\n        MaterialHelper.PrepareDefinesForMisc(mesh, scene, false, this.pointsCloud, this.fogEnabled, this._shouldTurnAlphaTestOn(mesh), defines);\n        // Values that need to be evaluated on every frame\n        MaterialHelper.PrepareDefinesForFrameBoundValues(scene, engine, this, defines, useInstances, null, subMesh.getRenderingMesh().hasThinInstances);\n        // Attribs\n        if (MaterialHelper.PrepareDefinesForAttributes(mesh, defines, false, true, false)) {\n            if (mesh) {\n                if (!scene.getEngine().getCaps().standardDerivatives && !mesh.isVerticesDataPresent(VertexBuffer.NormalKind)) {\n                    mesh.createNormals(true);\n                    Logger.Warn(\"BackgroundMaterial: Normals have been created for the mesh: \" + mesh.name);\n                }\n            }\n        }\n        // Get correct effect\n        if (defines.isDirty) {\n            defines.markAsProcessed();\n            scene.resetCachedMaterial();\n            // Fallbacks\n            const fallbacks = new EffectFallbacks();\n            if (defines.FOG) {\n                fallbacks.addFallback(0, \"FOG\");\n            }\n            if (defines.POINTSIZE) {\n                fallbacks.addFallback(1, \"POINTSIZE\");\n            }\n            if (defines.MULTIVIEW) {\n                fallbacks.addFallback(0, \"MULTIVIEW\");\n            }\n            MaterialHelper.HandleFallbacksForShadows(defines, fallbacks, this._maxSimultaneousLights);\n            //Attributes\n            const attribs = [VertexBuffer.PositionKind];\n            if (defines.NORMAL) {\n                attribs.push(VertexBuffer.NormalKind);\n            }\n            if (defines.UV1) {\n                attribs.push(VertexBuffer.UVKind);\n            }\n            if (defines.UV2) {\n                attribs.push(VertexBuffer.UV2Kind);\n            }\n            MaterialHelper.PrepareAttributesForBones(attribs, mesh, defines, fallbacks);\n            MaterialHelper.PrepareAttributesForInstances(attribs, defines);\n            const uniforms = [\n                \"world\",\n                \"view\",\n                \"viewProjection\",\n                \"vEyePosition\",\n                \"vLightsType\",\n                \"vFogInfos\",\n                \"vFogColor\",\n                \"pointSize\",\n                \"mBones\",\n                \"vPrimaryColor\",\n                \"vPrimaryColorShadow\",\n                \"vReflectionInfos\",\n                \"reflectionMatrix\",\n                \"vReflectionMicrosurfaceInfos\",\n                \"fFovMultiplier\",\n                \"shadowLevel\",\n                \"alpha\",\n                \"vBackgroundCenter\",\n                \"vReflectionControl\",\n                \"vDiffuseInfos\",\n                \"diffuseMatrix\",\n            ];\n            addClipPlaneUniforms(uniforms);\n            const samplers = [\"diffuseSampler\", \"reflectionSampler\", \"reflectionSamplerLow\", \"reflectionSamplerHigh\"];\n            const uniformBuffers = [\"Material\", \"Scene\"];\n            if (ImageProcessingConfiguration) {\n                ImageProcessingConfiguration.PrepareUniforms(uniforms, defines);\n                ImageProcessingConfiguration.PrepareSamplers(samplers, defines);\n            }\n            MaterialHelper.PrepareUniformsAndSamplersList({\n                uniformsNames: uniforms,\n                uniformBuffersNames: uniformBuffers,\n                samplers: samplers,\n                defines: defines,\n                maxSimultaneousLights: this._maxSimultaneousLights,\n            });\n            const join = defines.toString();\n            const effect = scene.getEngine().createEffect(\"background\", {\n                attributes: attribs,\n                uniformsNames: uniforms,\n                uniformBuffersNames: uniformBuffers,\n                samplers: samplers,\n                defines: join,\n                fallbacks: fallbacks,\n                onCompiled: this.onCompiled,\n                onError: this.onError,\n                indexParameters: { maxSimultaneousLights: this._maxSimultaneousLights },\n            }, engine);\n            subMesh.setEffect(effect, defines, this._materialContext);\n            this.buildUniformLayout();\n        }\n        if (!subMesh.effect || !subMesh.effect.isReady()) {\n            return false;\n        }\n        defines._renderId = scene.getRenderId();\n        subMesh.effect._wasPreviouslyReady = true;\n        subMesh.effect._wasPreviouslyUsingInstances = useInstances;\n        if (scene.performancePriority !== ScenePerformancePriority.BackwardCompatible) {\n            this.checkReadyOnlyOnce = true;\n        }\n        return true;\n    }\n    /**\n     * Compute the primary color according to the chosen perceptual color.\n     */\n    _computePrimaryColorFromPerceptualColor() {\n        if (!this.__perceptualColor) {\n            return;\n        }\n        this._primaryColor.copyFrom(this.__perceptualColor);\n        // Revert gamma space.\n        this._primaryColor.toLinearSpaceToRef(this._primaryColor);\n        // Revert image processing configuration.\n        if (this._imageProcessingConfiguration) {\n            // Revert Exposure.\n            this._primaryColor.scaleToRef(1 / this._imageProcessingConfiguration.exposure, this._primaryColor);\n        }\n        this._computePrimaryColors();\n    }\n    /**\n     * Compute the highlights and shadow colors according to their chosen levels.\n     */\n    _computePrimaryColors() {\n        if (this._primaryColorShadowLevel === 0 && this._primaryColorHighlightLevel === 0) {\n            return;\n        }\n        // Find the highlight color based on the configuration.\n        this._primaryColor.scaleToRef(this._primaryColorShadowLevel, this._primaryShadowColor);\n        this._primaryColor.subtractToRef(this._primaryShadowColor, this._primaryShadowColor);\n        // Find the shadow color based on the configuration.\n        this._white.subtractToRef(this._primaryColor, this._primaryHighlightColor);\n        this._primaryHighlightColor.scaleToRef(this._primaryColorHighlightLevel, this._primaryHighlightColor);\n        this._primaryColor.addToRef(this._primaryHighlightColor, this._primaryHighlightColor);\n    }\n    /**\n     * Build the uniform buffer used in the material.\n     */\n    buildUniformLayout() {\n        // Order is important !\n        this._uniformBuffer.addUniform(\"vPrimaryColor\", 4);\n        this._uniformBuffer.addUniform(\"vPrimaryColorShadow\", 4);\n        this._uniformBuffer.addUniform(\"vDiffuseInfos\", 2);\n        this._uniformBuffer.addUniform(\"vReflectionInfos\", 2);\n        this._uniformBuffer.addUniform(\"diffuseMatrix\", 16);\n        this._uniformBuffer.addUniform(\"reflectionMatrix\", 16);\n        this._uniformBuffer.addUniform(\"vReflectionMicrosurfaceInfos\", 3);\n        this._uniformBuffer.addUniform(\"fFovMultiplier\", 1);\n        this._uniformBuffer.addUniform(\"pointSize\", 1);\n        this._uniformBuffer.addUniform(\"shadowLevel\", 1);\n        this._uniformBuffer.addUniform(\"alpha\", 1);\n        this._uniformBuffer.addUniform(\"vBackgroundCenter\", 3);\n        this._uniformBuffer.addUniform(\"vReflectionControl\", 4);\n        this._uniformBuffer.create();\n    }\n    /**\n     * Unbind the material.\n     */\n    unbind() {\n        if (this._diffuseTexture && this._diffuseTexture.isRenderTarget) {\n            this._uniformBuffer.setTexture(\"diffuseSampler\", null);\n        }\n        if (this._reflectionTexture && this._reflectionTexture.isRenderTarget) {\n            this._uniformBuffer.setTexture(\"reflectionSampler\", null);\n        }\n        super.unbind();\n    }\n    /**\n     * Bind only the world matrix to the material.\n     * @param world The world matrix to bind.\n     */\n    bindOnlyWorldMatrix(world) {\n        this._activeEffect.setMatrix(\"world\", world);\n    }\n    /**\n     * Bind the material for a dedicated submeh (every used meshes will be considered opaque).\n     * @param world The world matrix to bind.\n     * @param mesh\n     * @param subMesh The submesh to bind for.\n     */\n    bindForSubMesh(world, mesh, subMesh) {\n        const scene = this.getScene();\n        const defines = subMesh.materialDefines;\n        if (!defines) {\n            return;\n        }\n        const effect = subMesh.effect;\n        if (!effect) {\n            return;\n        }\n        this._activeEffect = effect;\n        // Matrices\n        this.bindOnlyWorldMatrix(world);\n        // Bones\n        MaterialHelper.BindBonesParameters(mesh, this._activeEffect);\n        const mustRebind = this._mustRebind(scene, effect, mesh.visibility);\n        if (mustRebind) {\n            this._uniformBuffer.bindToEffect(effect, \"Material\");\n            this.bindViewProjection(effect);\n            const reflectionTexture = this._reflectionTexture;\n            if (!this._uniformBuffer.useUbo || !this.isFrozen || !this._uniformBuffer.isSync) {\n                // Texture uniforms\n                if (scene.texturesEnabled) {\n                    if (this._diffuseTexture && MaterialFlags.DiffuseTextureEnabled) {\n                        this._uniformBuffer.updateFloat2(\"vDiffuseInfos\", this._diffuseTexture.coordinatesIndex, this._diffuseTexture.level);\n                        MaterialHelper.BindTextureMatrix(this._diffuseTexture, this._uniformBuffer, \"diffuse\");\n                    }\n                    if (reflectionTexture && MaterialFlags.ReflectionTextureEnabled) {\n                        this._uniformBuffer.updateMatrix(\"reflectionMatrix\", reflectionTexture.getReflectionTextureMatrix());\n                        this._uniformBuffer.updateFloat2(\"vReflectionInfos\", reflectionTexture.level, this._reflectionBlur);\n                        this._uniformBuffer.updateFloat3(\"vReflectionMicrosurfaceInfos\", reflectionTexture.getSize().width, reflectionTexture.lodGenerationScale, reflectionTexture.lodGenerationOffset);\n                    }\n                }\n                if (this.shadowLevel > 0) {\n                    this._uniformBuffer.updateFloat(\"shadowLevel\", this.shadowLevel);\n                }\n                this._uniformBuffer.updateFloat(\"alpha\", this.alpha);\n                // Point size\n                if (this.pointsCloud) {\n                    this._uniformBuffer.updateFloat(\"pointSize\", this.pointSize);\n                }\n                if (defines.USEHIGHLIGHTANDSHADOWCOLORS) {\n                    this._uniformBuffer.updateColor4(\"vPrimaryColor\", this._primaryHighlightColor, 1.0);\n                    this._uniformBuffer.updateColor4(\"vPrimaryColorShadow\", this._primaryShadowColor, 1.0);\n                }\n                else {\n                    this._uniformBuffer.updateColor4(\"vPrimaryColor\", this._primaryColor, 1.0);\n                }\n            }\n            this._uniformBuffer.updateFloat(\"fFovMultiplier\", this._fovMultiplier);\n            // Textures\n            if (scene.texturesEnabled) {\n                if (this._diffuseTexture && MaterialFlags.DiffuseTextureEnabled) {\n                    this._uniformBuffer.setTexture(\"diffuseSampler\", this._diffuseTexture);\n                }\n                if (reflectionTexture && MaterialFlags.ReflectionTextureEnabled) {\n                    if (defines.REFLECTIONBLUR && defines.TEXTURELODSUPPORT) {\n                        this._uniformBuffer.setTexture(\"reflectionSampler\", reflectionTexture);\n                    }\n                    else if (!defines.REFLECTIONBLUR) {\n                        this._uniformBuffer.setTexture(\"reflectionSampler\", reflectionTexture);\n                    }\n                    else {\n                        this._uniformBuffer.setTexture(\"reflectionSampler\", reflectionTexture._lodTextureMid || reflectionTexture);\n                        this._uniformBuffer.setTexture(\"reflectionSamplerLow\", reflectionTexture._lodTextureLow || reflectionTexture);\n                        this._uniformBuffer.setTexture(\"reflectionSamplerHigh\", reflectionTexture._lodTextureHigh || reflectionTexture);\n                    }\n                    if (defines.REFLECTIONFRESNEL) {\n                        this._uniformBuffer.updateFloat3(\"vBackgroundCenter\", this.sceneCenter.x, this.sceneCenter.y, this.sceneCenter.z);\n                        this._uniformBuffer.updateFloat4(\"vReflectionControl\", this._reflectionControls.x, this._reflectionControls.y, this._reflectionControls.z, this._reflectionControls.w);\n                    }\n                }\n            }\n            // Clip plane\n            bindClipPlane(this._activeEffect, this, scene);\n            scene.bindEyePosition(effect);\n        }\n        else if (scene.getEngine()._features.needToAlwaysBindUniformBuffers) {\n            this._uniformBuffer.bindToEffect(effect, \"Material\");\n            this._needToBindSceneUbo = true;\n        }\n        if (mustRebind || !this.isFrozen) {\n            if (scene.lightsEnabled) {\n                MaterialHelper.BindLights(scene, mesh, this._activeEffect, defines, this._maxSimultaneousLights);\n            }\n            // View\n            this.bindView(effect);\n            // Fog\n            MaterialHelper.BindFogParameters(scene, mesh, this._activeEffect, true);\n            // image processing\n            if (this._imageProcessingConfiguration) {\n                this._imageProcessingConfiguration.bind(this._activeEffect);\n            }\n        }\n        this._afterBind(mesh, this._activeEffect);\n        this._uniformBuffer.update();\n    }\n    /**\n     * Checks to see if a texture is used in the material.\n     * @param texture - Base texture to use.\n     * @returns - Boolean specifying if a texture is used in the material.\n     */\n    hasTexture(texture) {\n        if (super.hasTexture(texture)) {\n            return true;\n        }\n        if (this._reflectionTexture === texture) {\n            return true;\n        }\n        if (this._diffuseTexture === texture) {\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Dispose the material.\n     * @param forceDisposeEffect Force disposal of the associated effect.\n     * @param forceDisposeTextures Force disposal of the associated textures.\n     */\n    dispose(forceDisposeEffect = false, forceDisposeTextures = false) {\n        if (forceDisposeTextures) {\n            if (this.diffuseTexture) {\n                this.diffuseTexture.dispose();\n            }\n            if (this.reflectionTexture) {\n                this.reflectionTexture.dispose();\n            }\n        }\n        this._renderTargets.dispose();\n        if (this._imageProcessingConfiguration && this._imageProcessingObserver) {\n            this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);\n        }\n        super.dispose(forceDisposeEffect);\n    }\n    /**\n     * Clones the material.\n     * @param name The cloned name.\n     * @returns The cloned material.\n     */\n    clone(name) {\n        return SerializationHelper.Clone(() => new BackgroundMaterial(name, this.getScene()), this);\n    }\n    /**\n     * Serializes the current material to its JSON representation.\n     * @returns The JSON representation.\n     */\n    serialize() {\n        const serializationObject = super.serialize();\n        serializationObject.customType = \"BABYLON.BackgroundMaterial\";\n        return serializationObject;\n    }\n    /**\n     * Gets the class name of the material\n     * @returns \"BackgroundMaterial\"\n     */\n    getClassName() {\n        return \"BackgroundMaterial\";\n    }\n    /**\n     * Parse a JSON input to create back a background material.\n     * @param source The JSON data to parse\n     * @param scene The scene to create the parsed material in\n     * @param rootUrl The root url of the assets the material depends upon\n     * @returns the instantiated BackgroundMaterial.\n     */\n    static Parse(source, scene, rootUrl) {\n        return SerializationHelper.Parse(() => new BackgroundMaterial(source.name, scene), source, scene, rootUrl);\n    }\n}\n/**\n * Standard reflectance value at parallel view angle.\n */\nBackgroundMaterial.StandardReflectance0 = 0.05;\n/**\n * Standard reflectance value at grazing angle.\n */\nBackgroundMaterial.StandardReflectance90 = 0.5;\n__decorate([\n    serializeAsColor3()\n], BackgroundMaterial.prototype, \"_primaryColor\", void 0);\n__decorate([\n    expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\n], BackgroundMaterial.prototype, \"primaryColor\", void 0);\n__decorate([\n    serializeAsColor3()\n], BackgroundMaterial.prototype, \"__perceptualColor\", void 0);\n__decorate([\n    serialize()\n], BackgroundMaterial.prototype, \"_primaryColorShadowLevel\", void 0);\n__decorate([\n    serialize()\n], BackgroundMaterial.prototype, \"_primaryColorHighlightLevel\", void 0);\n__decorate([\n    expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\n], BackgroundMaterial.prototype, \"primaryColorHighlightLevel\", null);\n__decorate([\n    serializeAsTexture()\n], BackgroundMaterial.prototype, \"_reflectionTexture\", void 0);\n__decorate([\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], BackgroundMaterial.prototype, \"reflectionTexture\", void 0);\n__decorate([\n    serialize()\n], BackgroundMaterial.prototype, \"_reflectionBlur\", void 0);\n__decorate([\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], BackgroundMaterial.prototype, \"reflectionBlur\", void 0);\n__decorate([\n    serializeAsTexture()\n], BackgroundMaterial.prototype, \"_diffuseTexture\", void 0);\n__decorate([\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], BackgroundMaterial.prototype, \"diffuseTexture\", void 0);\n__decorate([\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], BackgroundMaterial.prototype, \"shadowLights\", void 0);\n__decorate([\n    serialize()\n], BackgroundMaterial.prototype, \"_shadowLevel\", void 0);\n__decorate([\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], BackgroundMaterial.prototype, \"shadowLevel\", void 0);\n__decorate([\n    serializeAsVector3()\n], BackgroundMaterial.prototype, \"_sceneCenter\", void 0);\n__decorate([\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], BackgroundMaterial.prototype, \"sceneCenter\", void 0);\n__decorate([\n    serialize()\n], BackgroundMaterial.prototype, \"_opacityFresnel\", void 0);\n__decorate([\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], BackgroundMaterial.prototype, \"opacityFresnel\", void 0);\n__decorate([\n    serialize()\n], BackgroundMaterial.prototype, \"_reflectionFresnel\", void 0);\n__decorate([\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], BackgroundMaterial.prototype, \"reflectionFresnel\", void 0);\n__decorate([\n    serialize()\n], BackgroundMaterial.prototype, \"_reflectionFalloffDistance\", void 0);\n__decorate([\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], BackgroundMaterial.prototype, \"reflectionFalloffDistance\", void 0);\n__decorate([\n    serialize()\n], BackgroundMaterial.prototype, \"_reflectionAmount\", void 0);\n__decorate([\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], BackgroundMaterial.prototype, \"reflectionAmount\", void 0);\n__decorate([\n    serialize()\n], BackgroundMaterial.prototype, \"_reflectionReflectance0\", void 0);\n__decorate([\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], BackgroundMaterial.prototype, \"reflectionReflectance0\", void 0);\n__decorate([\n    serialize()\n], BackgroundMaterial.prototype, \"_reflectionReflectance90\", void 0);\n__decorate([\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], BackgroundMaterial.prototype, \"reflectionReflectance90\", void 0);\n__decorate([\n    serialize()\n], BackgroundMaterial.prototype, \"_useRGBColor\", void 0);\n__decorate([\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], BackgroundMaterial.prototype, \"useRGBColor\", void 0);\n__decorate([\n    serialize()\n], BackgroundMaterial.prototype, \"_enableNoise\", void 0);\n__decorate([\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], BackgroundMaterial.prototype, \"enableNoise\", void 0);\n__decorate([\n    serialize()\n], BackgroundMaterial.prototype, \"_maxSimultaneousLights\", void 0);\n__decorate([\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], BackgroundMaterial.prototype, \"maxSimultaneousLights\", void 0);\n__decorate([\n    serialize()\n], BackgroundMaterial.prototype, \"_shadowOnly\", void 0);\n__decorate([\n    expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\n], BackgroundMaterial.prototype, \"shadowOnly\", void 0);\n__decorate([\n    serializeAsImageProcessingConfiguration()\n], BackgroundMaterial.prototype, \"_imageProcessingConfiguration\", void 0);\nRegisterClass(\"BABYLON.BackgroundMaterial\", BackgroundMaterial);\n//# sourceMappingURL=backgroundMaterial.js.map","import { NodeMaterialBlock } from \"../../nodeMaterialBlock.js\";\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes.js\";\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets.js\";\nimport { RegisterClass } from \"../../../../Misc/typeStore.js\";\nimport { Texture } from \"../../../Textures/texture.js\";\n/**\n * Base block used as input for post process\n */\nexport class CurrentScreenBlock extends NodeMaterialBlock {\n    /**\n     * Create a new CurrentScreenBlock\n     * @param name defines the block name\n     */\n    constructor(name) {\n        super(name, NodeMaterialBlockTargets.VertexAndFragment);\n        this._samplerName = \"textureSampler\";\n        /**\n         * Gets or sets a boolean indicating if content needs to be converted to gamma space\n         */\n        this.convertToGammaSpace = false;\n        /**\n         * Gets or sets a boolean indicating if content needs to be converted to linear space\n         */\n        this.convertToLinearSpace = false;\n        this._isUnique = false;\n        this.registerInput(\"uv\", NodeMaterialBlockConnectionPointTypes.AutoDetect, false, NodeMaterialBlockTargets.VertexAndFragment);\n        this.registerOutput(\"rgba\", NodeMaterialBlockConnectionPointTypes.Color4, NodeMaterialBlockTargets.Neutral);\n        this.registerOutput(\"rgb\", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Neutral);\n        this.registerOutput(\"r\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\n        this.registerOutput(\"g\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\n        this.registerOutput(\"b\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\n        this.registerOutput(\"a\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\n        this._inputs[0].addExcludedConnectionPointFromAllowedTypes(NodeMaterialBlockConnectionPointTypes.Vector2 | NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Vector4);\n        this._inputs[0]._prioritizeVertex = false;\n    }\n    /**\n     * Gets the current class name\n     * @returns the class name\n     */\n    getClassName() {\n        return \"CurrentScreenBlock\";\n    }\n    /**\n     * Gets the uv input component\n     */\n    get uv() {\n        return this._inputs[0];\n    }\n    /**\n     * Gets the rgba output component\n     */\n    get rgba() {\n        return this._outputs[0];\n    }\n    /**\n     * Gets the rgb output component\n     */\n    get rgb() {\n        return this._outputs[1];\n    }\n    /**\n     * Gets the r output component\n     */\n    get r() {\n        return this._outputs[2];\n    }\n    /**\n     * Gets the g output component\n     */\n    get g() {\n        return this._outputs[3];\n    }\n    /**\n     * Gets the b output component\n     */\n    get b() {\n        return this._outputs[4];\n    }\n    /**\n     * Gets the a output component\n     */\n    get a() {\n        return this._outputs[5];\n    }\n    /**\n     * Initialize the block and prepare the context for build\n     * @param state defines the state that will be used for the build\n     */\n    initialize(state) {\n        state._excludeVariableName(\"textureSampler\");\n    }\n    get target() {\n        if (!this.uv.isConnected) {\n            return NodeMaterialBlockTargets.VertexAndFragment;\n        }\n        if (this.uv.sourceBlock.isInput) {\n            return NodeMaterialBlockTargets.VertexAndFragment;\n        }\n        return NodeMaterialBlockTargets.Fragment;\n    }\n    prepareDefines(mesh, nodeMaterial, defines) {\n        defines.setValue(this._linearDefineName, this.convertToGammaSpace, true);\n        defines.setValue(this._gammaDefineName, this.convertToLinearSpace, true);\n    }\n    isReady() {\n        if (this.texture && !this.texture.isReadyOrNotBlocking()) {\n            return false;\n        }\n        return true;\n    }\n    _injectVertexCode(state) {\n        const uvInput = this.uv;\n        if (uvInput.connectedPoint.ownerBlock.isInput) {\n            const uvInputOwnerBlock = uvInput.connectedPoint.ownerBlock;\n            if (!uvInputOwnerBlock.isAttribute) {\n                state._emitUniformFromString(uvInput.associatedVariableName, \"vec2\");\n            }\n        }\n        this._mainUVName = \"vMain\" + uvInput.associatedVariableName;\n        state._emitVaryingFromString(this._mainUVName, \"vec2\");\n        state.compilationString += `${this._mainUVName} = ${uvInput.associatedVariableName}.xy;\\r\\n`;\n        if (!this._outputs.some((o) => o.isConnectedInVertexShader)) {\n            return;\n        }\n        this._writeTextureRead(state, true);\n        for (const output of this._outputs) {\n            if (output.hasEndpoints) {\n                this._writeOutput(state, output, output.name, true);\n            }\n        }\n    }\n    _writeTextureRead(state, vertexMode = false) {\n        const uvInput = this.uv;\n        if (vertexMode) {\n            if (state.target === NodeMaterialBlockTargets.Fragment) {\n                return;\n            }\n            state.compilationString += `vec4 ${this._tempTextureRead} = texture2D(${this._samplerName}, ${uvInput.associatedVariableName});\\r\\n`;\n            return;\n        }\n        if (this.uv.ownerBlock.target === NodeMaterialBlockTargets.Fragment) {\n            state.compilationString += `vec4 ${this._tempTextureRead} = texture2D(${this._samplerName}, ${uvInput.associatedVariableName});\\r\\n`;\n            return;\n        }\n        state.compilationString += `vec4 ${this._tempTextureRead} = texture2D(${this._samplerName}, ${this._mainUVName});\\r\\n`;\n    }\n    _writeOutput(state, output, swizzle, vertexMode = false) {\n        if (vertexMode) {\n            if (state.target === NodeMaterialBlockTargets.Fragment) {\n                return;\n            }\n            state.compilationString += `${this._declareOutput(output, state)} = ${this._tempTextureRead}.${swizzle};\\r\\n`;\n            return;\n        }\n        if (this.uv.ownerBlock.target === NodeMaterialBlockTargets.Fragment) {\n            state.compilationString += `${this._declareOutput(output, state)} = ${this._tempTextureRead}.${swizzle};\\r\\n`;\n            return;\n        }\n        state.compilationString += `${this._declareOutput(output, state)} = ${this._tempTextureRead}.${swizzle};\\r\\n`;\n        state.compilationString += `#ifdef ${this._linearDefineName}\\r\\n`;\n        state.compilationString += `${output.associatedVariableName} = toGammaSpace(${output.associatedVariableName});\\r\\n`;\n        state.compilationString += `#endif\\r\\n`;\n        state.compilationString += `#ifdef ${this._gammaDefineName}\\r\\n`;\n        state.compilationString += `${output.associatedVariableName} = toLinearSpace(${output.associatedVariableName});\\r\\n`;\n        state.compilationString += `#endif\\r\\n`;\n    }\n    _buildBlock(state) {\n        super._buildBlock(state);\n        this._tempTextureRead = state._getFreeVariableName(\"tempTextureRead\");\n        if (state.sharedData.blockingBlocks.indexOf(this) < 0) {\n            state.sharedData.blockingBlocks.push(this);\n        }\n        if (state.sharedData.textureBlocks.indexOf(this) < 0) {\n            state.sharedData.textureBlocks.push(this);\n        }\n        if (state.sharedData.blocksWithDefines.indexOf(this) < 0) {\n            state.sharedData.blocksWithDefines.push(this);\n        }\n        if (state.target !== NodeMaterialBlockTargets.Fragment) {\n            // Vertex\n            state._emit2DSampler(this._samplerName);\n            this._injectVertexCode(state);\n            return;\n        }\n        // Fragment\n        if (!this._outputs.some((o) => o.isConnectedInFragmentShader)) {\n            return;\n        }\n        state._emit2DSampler(this._samplerName);\n        this._linearDefineName = state._getFreeDefineName(\"ISLINEAR\");\n        this._gammaDefineName = state._getFreeDefineName(\"ISGAMMA\");\n        const comments = `//${this.name}`;\n        state._emitFunctionFromInclude(\"helperFunctions\", comments);\n        this._writeTextureRead(state);\n        for (const output of this._outputs) {\n            if (output.hasEndpoints) {\n                this._writeOutput(state, output, output.name);\n            }\n        }\n        return this;\n    }\n    serialize() {\n        const serializationObject = super.serialize();\n        serializationObject.convertToGammaSpace = this.convertToGammaSpace;\n        serializationObject.convertToLinearSpace = this.convertToLinearSpace;\n        if (this.texture && !this.texture.isRenderTarget) {\n            serializationObject.texture = this.texture.serialize();\n        }\n        return serializationObject;\n    }\n    _deserialize(serializationObject, scene, rootUrl) {\n        super._deserialize(serializationObject, scene, rootUrl);\n        this.convertToGammaSpace = serializationObject.convertToGammaSpace;\n        this.convertToLinearSpace = !!serializationObject.convertToLinearSpace;\n        if (serializationObject.texture) {\n            rootUrl = serializationObject.texture.url.indexOf(\"data:\") === 0 ? \"\" : rootUrl;\n            this.texture = Texture.Parse(serializationObject.texture, scene, rootUrl);\n        }\n    }\n}\nRegisterClass(\"BABYLON.CurrentScreenBlock\", CurrentScreenBlock);\n//# sourceMappingURL=currentScreenBlock.js.map","import { NodeMaterialBlock } from \"../../nodeMaterialBlock.js\";\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes.js\";\nimport { NodeMaterialConnectionPointDirection } from \"../../nodeMaterialBlockConnectionPoint.js\";\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets.js\";\nimport { RegisterClass } from \"../../../../Misc/typeStore.js\";\nimport { Texture } from \"../../../Textures/texture.js\";\n\nimport { NodeMaterial } from \"../../nodeMaterial.js\";\nimport { NodeMaterialConnectionPointCustomObject } from \"../../nodeMaterialConnectionPointCustomObject.js\";\nimport { EngineStore } from \"../../../../Engines/engineStore.js\";\n/**\n * Block used to provide an image for a TextureBlock\n */\nexport class ImageSourceBlock extends NodeMaterialBlock {\n    /**\n     * Gets or sets the texture associated with the node\n     */\n    get texture() {\n        return this._texture;\n    }\n    set texture(texture) {\n        var _a;\n        if (this._texture === texture) {\n            return;\n        }\n        const scene = (_a = texture === null || texture === void 0 ? void 0 : texture.getScene()) !== null && _a !== void 0 ? _a : EngineStore.LastCreatedScene;\n        if (!texture && scene) {\n            scene.markAllMaterialsAsDirty(1, (mat) => {\n                return mat.hasTexture(this._texture);\n            });\n        }\n        this._texture = texture;\n        if (texture && scene) {\n            scene.markAllMaterialsAsDirty(1, (mat) => {\n                return mat.hasTexture(texture);\n            });\n        }\n    }\n    /**\n     * Gets the sampler name associated with this image source\n     */\n    get samplerName() {\n        return this._samplerName;\n    }\n    /**\n     * Creates a new ImageSourceBlock\n     * @param name defines the block name\n     */\n    constructor(name) {\n        super(name, NodeMaterialBlockTargets.VertexAndFragment);\n        this.registerOutput(\"source\", NodeMaterialBlockConnectionPointTypes.Object, NodeMaterialBlockTargets.VertexAndFragment, new NodeMaterialConnectionPointCustomObject(\"source\", this, NodeMaterialConnectionPointDirection.Output, ImageSourceBlock, \"ImageSourceBlock\"));\n    }\n    bind(effect) {\n        if (!this.texture) {\n            return;\n        }\n        effect.setTexture(this._samplerName, this.texture);\n    }\n    isReady() {\n        if (this.texture && !this.texture.isReadyOrNotBlocking()) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Gets the current class name\n     * @returns the class name\n     */\n    getClassName() {\n        return \"ImageSourceBlock\";\n    }\n    /**\n     * Gets the output component\n     */\n    get source() {\n        return this._outputs[0];\n    }\n    _buildBlock(state) {\n        super._buildBlock(state);\n        if (state.target === NodeMaterialBlockTargets.Vertex) {\n            this._samplerName = state._getFreeVariableName(this.name + \"Sampler\");\n            // Declarations\n            state.sharedData.blockingBlocks.push(this);\n            state.sharedData.textureBlocks.push(this);\n            state.sharedData.bindableBlocks.push(this);\n        }\n        state._emit2DSampler(this._samplerName);\n        return this;\n    }\n    _dumpPropertiesCode() {\n        let codeString = super._dumpPropertiesCode();\n        if (!this.texture) {\n            return codeString;\n        }\n        codeString += `${this._codeVariableName}.texture = new BABYLON.Texture(\"${this.texture.name}\", null, ${this.texture.noMipmap}, ${this.texture.invertY}, ${this.texture.samplingMode});\\r\\n`;\n        codeString += `${this._codeVariableName}.texture.wrapU = ${this.texture.wrapU};\\r\\n`;\n        codeString += `${this._codeVariableName}.texture.wrapV = ${this.texture.wrapV};\\r\\n`;\n        codeString += `${this._codeVariableName}.texture.uAng = ${this.texture.uAng};\\r\\n`;\n        codeString += `${this._codeVariableName}.texture.vAng = ${this.texture.vAng};\\r\\n`;\n        codeString += `${this._codeVariableName}.texture.wAng = ${this.texture.wAng};\\r\\n`;\n        codeString += `${this._codeVariableName}.texture.uOffset = ${this.texture.uOffset};\\r\\n`;\n        codeString += `${this._codeVariableName}.texture.vOffset = ${this.texture.vOffset};\\r\\n`;\n        codeString += `${this._codeVariableName}.texture.uScale = ${this.texture.uScale};\\r\\n`;\n        codeString += `${this._codeVariableName}.texture.vScale = ${this.texture.vScale};\\r\\n`;\n        codeString += `${this._codeVariableName}.texture.coordinatesMode = ${this.texture.coordinatesMode};\\r\\n`;\n        return codeString;\n    }\n    serialize() {\n        const serializationObject = super.serialize();\n        if (this.texture && !this.texture.isRenderTarget && this.texture.getClassName() !== \"VideoTexture\") {\n            serializationObject.texture = this.texture.serialize();\n        }\n        return serializationObject;\n    }\n    _deserialize(serializationObject, scene, rootUrl) {\n        super._deserialize(serializationObject, scene, rootUrl);\n        if (serializationObject.texture && !NodeMaterial.IgnoreTexturesAtLoadTime && serializationObject.texture.url !== undefined) {\n            rootUrl = serializationObject.texture.url.indexOf(\"data:\") === 0 ? \"\" : rootUrl;\n            this.texture = Texture.Parse(serializationObject.texture, scene, rootUrl);\n        }\n    }\n}\nRegisterClass(\"BABYLON.ImageSourceBlock\", ImageSourceBlock);\n//# sourceMappingURL=imageSourceBlock.js.map","import { NodeMaterialBlock } from \"../../nodeMaterialBlock.js\";\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes.js\";\nimport { NodeMaterialSystemValues } from \"../../Enums/nodeMaterialSystemValues.js\";\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets.js\";\nimport { MaterialHelper } from \"../../../materialHelper.js\";\nimport { InputBlock } from \"../Input/inputBlock.js\";\nimport { RegisterClass } from \"../../../../Misc/typeStore.js\";\nimport \"../../../../Shaders/ShadersInclude/fogFragmentDeclaration.js\";\n/**\n * Block used to add support for scene fog\n */\nexport class FogBlock extends NodeMaterialBlock {\n    /**\n     * Create a new FogBlock\n     * @param name defines the block name\n     */\n    constructor(name) {\n        super(name, NodeMaterialBlockTargets.VertexAndFragment, false);\n        // Vertex\n        this.registerInput(\"worldPosition\", NodeMaterialBlockConnectionPointTypes.Vector4, false, NodeMaterialBlockTargets.Vertex);\n        this.registerInput(\"view\", NodeMaterialBlockConnectionPointTypes.Matrix, false, NodeMaterialBlockTargets.Vertex);\n        // Fragment\n        this.registerInput(\"input\", NodeMaterialBlockConnectionPointTypes.AutoDetect, false, NodeMaterialBlockTargets.Fragment);\n        this.registerInput(\"fogColor\", NodeMaterialBlockConnectionPointTypes.AutoDetect, false, NodeMaterialBlockTargets.Fragment);\n        this.registerOutput(\"output\", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Fragment);\n        this.input.addExcludedConnectionPointFromAllowedTypes(NodeMaterialBlockConnectionPointTypes.Color3 | NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Color4);\n        this.fogColor.addExcludedConnectionPointFromAllowedTypes(NodeMaterialBlockConnectionPointTypes.Color3 | NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Color4);\n    }\n    /**\n     * Gets the current class name\n     * @returns the class name\n     */\n    getClassName() {\n        return \"FogBlock\";\n    }\n    /**\n     * Gets the world position input component\n     */\n    get worldPosition() {\n        return this._inputs[0];\n    }\n    /**\n     * Gets the view input component\n     */\n    get view() {\n        return this._inputs[1];\n    }\n    /**\n     * Gets the color input component\n     */\n    get input() {\n        return this._inputs[2];\n    }\n    /**\n     * Gets the fog color input component\n     */\n    get fogColor() {\n        return this._inputs[3];\n    }\n    /**\n     * Gets the output component\n     */\n    get output() {\n        return this._outputs[0];\n    }\n    autoConfigure(material) {\n        if (!this.view.isConnected) {\n            let viewInput = material.getInputBlockByPredicate((b) => b.systemValue === NodeMaterialSystemValues.View);\n            if (!viewInput) {\n                viewInput = new InputBlock(\"view\");\n                viewInput.setAsSystemValue(NodeMaterialSystemValues.View);\n            }\n            viewInput.output.connectTo(this.view);\n        }\n        if (!this.fogColor.isConnected) {\n            let fogColorInput = material.getInputBlockByPredicate((b) => b.systemValue === NodeMaterialSystemValues.FogColor);\n            if (!fogColorInput) {\n                fogColorInput = new InputBlock(\"fogColor\", undefined, NodeMaterialBlockConnectionPointTypes.Color3);\n                fogColorInput.setAsSystemValue(NodeMaterialSystemValues.FogColor);\n            }\n            fogColorInput.output.connectTo(this.fogColor);\n        }\n    }\n    prepareDefines(mesh, nodeMaterial, defines) {\n        const scene = mesh.getScene();\n        defines.setValue(\"FOG\", nodeMaterial.fogEnabled && MaterialHelper.GetFogState(mesh, scene));\n    }\n    bind(effect, nodeMaterial, mesh) {\n        if (!mesh) {\n            return;\n        }\n        const scene = mesh.getScene();\n        effect.setFloat4(this._fogParameters, scene.fogMode, scene.fogStart, scene.fogEnd, scene.fogDensity);\n    }\n    _buildBlock(state) {\n        super._buildBlock(state);\n        if (state.target === NodeMaterialBlockTargets.Fragment) {\n            state.sharedData.blocksWithDefines.push(this);\n            state.sharedData.bindableBlocks.push(this);\n            state._emitFunctionFromInclude(\"fogFragmentDeclaration\", `//${this.name}`, {\n                removeUniforms: true,\n                removeVaryings: true,\n                removeIfDef: false,\n                replaceStrings: [{ search: /float CalcFogFactor\\(\\)/, replace: \"float CalcFogFactor(vec3 vFogDistance, vec4 vFogInfos)\" }],\n            });\n            const tempFogVariablename = state._getFreeVariableName(\"fog\");\n            const color = this.input;\n            const fogColor = this.fogColor;\n            this._fogParameters = state._getFreeVariableName(\"fogParameters\");\n            const output = this._outputs[0];\n            state._emitUniformFromString(this._fogParameters, \"vec4\");\n            state.compilationString += `#ifdef FOG\\r\\n`;\n            state.compilationString += `float ${tempFogVariablename} = CalcFogFactor(${this._fogDistanceName}, ${this._fogParameters});\\r\\n`;\n            state.compilationString +=\n                this._declareOutput(output, state) +\n                    ` = ${tempFogVariablename} * ${color.associatedVariableName}.rgb + (1.0 - ${tempFogVariablename}) * ${fogColor.associatedVariableName}.rgb;\\r\\n`;\n            state.compilationString += `#else\\r\\n${this._declareOutput(output, state)} =  ${color.associatedVariableName}.rgb;\\r\\n`;\n            state.compilationString += `#endif\\r\\n`;\n        }\n        else {\n            const worldPos = this.worldPosition;\n            const view = this.view;\n            this._fogDistanceName = state._getFreeVariableName(\"vFogDistance\");\n            state._emitVaryingFromString(this._fogDistanceName, \"vec3\");\n            state.compilationString += `${this._fogDistanceName} = (${view.associatedVariableName} * ${worldPos.associatedVariableName}).xyz;\\r\\n`;\n        }\n        return this;\n    }\n}\nRegisterClass(\"BABYLON.FogBlock\", FogBlock);\n//# sourceMappingURL=fogBlock.js.map","import { __decorate } from \"../../../../tslib.es6.js\";\nimport { NodeMaterialBlock } from \"../../nodeMaterialBlock.js\";\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets.js\";\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes.js\";\nimport { MaterialHelper } from \"../../../materialHelper.js\";\nimport { NodeMaterialSystemValues } from \"../../Enums/nodeMaterialSystemValues.js\";\nimport { InputBlock } from \"../Input/inputBlock.js\";\nimport { RegisterClass } from \"../../../../Misc/typeStore.js\";\nimport { editableInPropertyPage, PropertyTypeForEdition } from \"../../nodeMaterialDecorator.js\";\nimport \"../../../../Shaders/ShadersInclude/lightFragmentDeclaration.js\";\nimport \"../../../../Shaders/ShadersInclude/lightVxFragmentDeclaration.js\";\nimport \"../../../../Shaders/ShadersInclude/lightUboDeclaration.js\";\nimport \"../../../../Shaders/ShadersInclude/lightVxUboDeclaration.js\";\nimport \"../../../../Shaders/ShadersInclude/lightFragment.js\";\nimport \"../../../../Shaders/ShadersInclude/helperFunctions.js\";\nimport \"../../../../Shaders/ShadersInclude/lightsFragmentFunctions.js\";\nimport \"../../../../Shaders/ShadersInclude/shadowsFragmentFunctions.js\";\nimport \"../../../../Shaders/ShadersInclude/shadowsVertex.js\";\n/**\n * Block used to add light in the fragment shader\n */\nexport class LightBlock extends NodeMaterialBlock {\n    static _OnGenerateOnlyFragmentCodeChanged(block, _propertyName) {\n        const that = block;\n        if (that.worldPosition.isConnected) {\n            that.generateOnlyFragmentCode = !that.generateOnlyFragmentCode;\n            console.error(\"The worldPosition input must not be connected to be able to switch!\");\n            return false;\n        }\n        that._setTarget();\n        return true;\n    }\n    _setTarget() {\n        this._setInitialTarget(this.generateOnlyFragmentCode ? NodeMaterialBlockTargets.Fragment : NodeMaterialBlockTargets.VertexAndFragment);\n        this.getInputByName(\"worldPosition\").target = this.generateOnlyFragmentCode ? NodeMaterialBlockTargets.Fragment : NodeMaterialBlockTargets.Vertex;\n    }\n    /**\n     * Create a new LightBlock\n     * @param name defines the block name\n     */\n    constructor(name) {\n        super(name, NodeMaterialBlockTargets.VertexAndFragment);\n        this._lightId = 0;\n        /** Indicates that no code should be generated in the vertex shader. Can be useful in some specific circumstances (like when doing ray marching for eg) */\n        this.generateOnlyFragmentCode = false;\n        this._isUnique = true;\n        this.registerInput(\"worldPosition\", NodeMaterialBlockConnectionPointTypes.Vector4, false, NodeMaterialBlockTargets.Vertex);\n        this.registerInput(\"worldNormal\", NodeMaterialBlockConnectionPointTypes.Vector4, false, NodeMaterialBlockTargets.Fragment);\n        this.registerInput(\"cameraPosition\", NodeMaterialBlockConnectionPointTypes.Vector3, false, NodeMaterialBlockTargets.Fragment);\n        this.registerInput(\"glossiness\", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);\n        this.registerInput(\"glossPower\", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);\n        this.registerInput(\"diffuseColor\", NodeMaterialBlockConnectionPointTypes.Color3, true, NodeMaterialBlockTargets.Fragment);\n        this.registerInput(\"specularColor\", NodeMaterialBlockConnectionPointTypes.Color3, true, NodeMaterialBlockTargets.Fragment);\n        this.registerInput(\"view\", NodeMaterialBlockConnectionPointTypes.Matrix, true);\n        this.registerOutput(\"diffuseOutput\", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Fragment);\n        this.registerOutput(\"specularOutput\", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Fragment);\n        this.registerOutput(\"shadow\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Fragment);\n    }\n    /**\n     * Gets the current class name\n     * @returns the class name\n     */\n    getClassName() {\n        return \"LightBlock\";\n    }\n    /**\n     * Gets the world position input component\n     */\n    get worldPosition() {\n        return this._inputs[0];\n    }\n    /**\n     * Gets the world normal input component\n     */\n    get worldNormal() {\n        return this._inputs[1];\n    }\n    /**\n     * Gets the camera (or eye) position component\n     */\n    get cameraPosition() {\n        return this._inputs[2];\n    }\n    /**\n     * Gets the glossiness component\n     */\n    get glossiness() {\n        return this._inputs[3];\n    }\n    /**\n     * Gets the glossiness power component\n     */\n    get glossPower() {\n        return this._inputs[4];\n    }\n    /**\n     * Gets the diffuse color component\n     */\n    get diffuseColor() {\n        return this._inputs[5];\n    }\n    /**\n     * Gets the specular color component\n     */\n    get specularColor() {\n        return this._inputs[6];\n    }\n    /**\n     * Gets the view matrix component\n     */\n    get view() {\n        return this._inputs[7];\n    }\n    /**\n     * Gets the diffuse output component\n     */\n    get diffuseOutput() {\n        return this._outputs[0];\n    }\n    /**\n     * Gets the specular output component\n     */\n    get specularOutput() {\n        return this._outputs[1];\n    }\n    /**\n     * Gets the shadow output component\n     */\n    get shadow() {\n        return this._outputs[2];\n    }\n    autoConfigure(material) {\n        if (!this.cameraPosition.isConnected) {\n            let cameraPositionInput = material.getInputBlockByPredicate((b) => b.systemValue === NodeMaterialSystemValues.CameraPosition);\n            if (!cameraPositionInput) {\n                cameraPositionInput = new InputBlock(\"cameraPosition\");\n                cameraPositionInput.setAsSystemValue(NodeMaterialSystemValues.CameraPosition);\n            }\n            cameraPositionInput.output.connectTo(this.cameraPosition);\n        }\n    }\n    prepareDefines(mesh, nodeMaterial, defines) {\n        if (!defines._areLightsDirty) {\n            return;\n        }\n        const scene = mesh.getScene();\n        if (!this.light) {\n            MaterialHelper.PrepareDefinesForLights(scene, mesh, defines, true, nodeMaterial.maxSimultaneousLights);\n        }\n        else {\n            const state = {\n                needNormals: false,\n                needRebuild: false,\n                lightmapMode: false,\n                shadowEnabled: false,\n                specularEnabled: false,\n            };\n            MaterialHelper.PrepareDefinesForLight(scene, mesh, this.light, this._lightId, defines, true, state);\n            if (state.needRebuild) {\n                defines.rebuild();\n            }\n        }\n    }\n    updateUniformsAndSamples(state, nodeMaterial, defines, uniformBuffers) {\n        for (let lightIndex = 0; lightIndex < nodeMaterial.maxSimultaneousLights; lightIndex++) {\n            if (!defines[\"LIGHT\" + lightIndex]) {\n                break;\n            }\n            const onlyUpdateBuffersList = state.uniforms.indexOf(\"vLightData\" + lightIndex) >= 0;\n            MaterialHelper.PrepareUniformsAndSamplersForLight(lightIndex, state.uniforms, state.samplers, defines[\"PROJECTEDLIGHTTEXTURE\" + lightIndex], uniformBuffers, onlyUpdateBuffersList);\n        }\n    }\n    bind(effect, nodeMaterial, mesh) {\n        if (!mesh) {\n            return;\n        }\n        const scene = mesh.getScene();\n        if (!this.light) {\n            MaterialHelper.BindLights(scene, mesh, effect, true, nodeMaterial.maxSimultaneousLights);\n        }\n        else {\n            MaterialHelper.BindLight(this.light, this._lightId, scene, effect, true);\n        }\n    }\n    _injectVertexCode(state) {\n        const worldPos = this.worldPosition;\n        const comments = `//${this.name}`;\n        // Declaration\n        if (!this.light) {\n            // Emit for all lights\n            state._emitFunctionFromInclude(state.supportUniformBuffers ? \"lightVxUboDeclaration\" : \"lightVxFragmentDeclaration\", comments, {\n                repeatKey: \"maxSimultaneousLights\",\n            });\n            this._lightId = 0;\n            state.sharedData.dynamicUniformBlocks.push(this);\n        }\n        else {\n            this._lightId = (state.counters[\"lightCounter\"] !== undefined ? state.counters[\"lightCounter\"] : -1) + 1;\n            state.counters[\"lightCounter\"] = this._lightId;\n            state._emitFunctionFromInclude(state.supportUniformBuffers ? \"lightVxUboDeclaration\" : \"lightVxFragmentDeclaration\", comments, {\n                replaceStrings: [{ search: /{X}/g, replace: this._lightId.toString() }],\n            }, this._lightId.toString());\n        }\n        // Inject code in vertex\n        const worldPosVaryingName = \"v_\" + worldPos.associatedVariableName;\n        if (state._emitVaryingFromString(worldPosVaryingName, \"vec4\")) {\n            state.compilationString += `${worldPosVaryingName} = ${worldPos.associatedVariableName};\\r\\n`;\n        }\n        if (this.light) {\n            state.compilationString += state._emitCodeFromInclude(\"shadowsVertex\", comments, {\n                replaceStrings: [\n                    { search: /{X}/g, replace: this._lightId.toString() },\n                    { search: /worldPos/g, replace: worldPos.associatedVariableName },\n                ],\n            });\n        }\n        else {\n            state.compilationString += `vec4 worldPos = ${worldPos.associatedVariableName};\\r\\n`;\n            if (this.view.isConnected) {\n                state.compilationString += `mat4 view = ${this.view.associatedVariableName};\\r\\n`;\n            }\n            state.compilationString += state._emitCodeFromInclude(\"shadowsVertex\", comments, {\n                repeatKey: \"maxSimultaneousLights\",\n            });\n        }\n    }\n    _buildBlock(state) {\n        super._buildBlock(state);\n        if (state.target !== NodeMaterialBlockTargets.Fragment) {\n            // Vertex\n            this._injectVertexCode(state);\n            return;\n        }\n        if (this.generateOnlyFragmentCode) {\n            state.sharedData.dynamicUniformBlocks.push(this);\n        }\n        // Fragment\n        state.sharedData.forcedBindableBlocks.push(this);\n        state.sharedData.blocksWithDefines.push(this);\n        const comments = `//${this.name}`;\n        const worldPos = this.worldPosition;\n        let worldPosVariableName = worldPos.associatedVariableName;\n        if (this.generateOnlyFragmentCode) {\n            worldPosVariableName = state._getFreeVariableName(\"globalWorldPos\");\n            state._emitFunction(\"light_globalworldpos\", `vec3 ${worldPosVariableName};\\r\\n`, comments);\n            state.compilationString += `${worldPosVariableName} = ${worldPos.associatedVariableName}.xyz;\\r\\n`;\n            state.compilationString += state._emitCodeFromInclude(\"shadowsVertex\", comments, {\n                repeatKey: \"maxSimultaneousLights\",\n                substitutionVars: this.generateOnlyFragmentCode ? `worldPos,${worldPos.associatedVariableName}` : undefined,\n            });\n        }\n        else {\n            worldPosVariableName = \"v_\" + worldPosVariableName + \".xyz\";\n        }\n        state._emitFunctionFromInclude(\"helperFunctions\", comments);\n        state._emitFunctionFromInclude(\"lightsFragmentFunctions\", comments, {\n            replaceStrings: [{ search: /vPositionW/g, replace: worldPosVariableName }],\n        });\n        state._emitFunctionFromInclude(\"shadowsFragmentFunctions\", comments, {\n            replaceStrings: [{ search: /vPositionW/g, replace: worldPosVariableName }],\n        });\n        if (!this.light) {\n            // Emit for all lights\n            state._emitFunctionFromInclude(state.supportUniformBuffers ? \"lightUboDeclaration\" : \"lightFragmentDeclaration\", comments, {\n                repeatKey: \"maxSimultaneousLights\",\n                substitutionVars: this.generateOnlyFragmentCode ? \"varying,\" : undefined,\n            });\n        }\n        else {\n            state._emitFunctionFromInclude(state.supportUniformBuffers ? \"lightUboDeclaration\" : \"lightFragmentDeclaration\", comments, {\n                replaceStrings: [{ search: /{X}/g, replace: this._lightId.toString() }],\n            }, this._lightId.toString());\n        }\n        // Code\n        if (this._lightId === 0) {\n            if (state._registerTempVariable(\"viewDirectionW\")) {\n                state.compilationString += `vec3 viewDirectionW = normalize(${this.cameraPosition.associatedVariableName} - ${worldPosVariableName});\\r\\n`;\n            }\n            state.compilationString += `lightingInfo info;\\r\\n`;\n            state.compilationString += `float shadow = 1.;\\r\\n`;\n            state.compilationString += `float glossiness = ${this.glossiness.isConnected ? this.glossiness.associatedVariableName : \"1.0\"} * ${this.glossPower.isConnected ? this.glossPower.associatedVariableName : \"1024.0\"};\\r\\n`;\n            state.compilationString += `vec3 diffuseBase = vec3(0., 0., 0.);\\r\\n`;\n            state.compilationString += `vec3 specularBase = vec3(0., 0., 0.);\\r\\n`;\n            state.compilationString += `vec3 normalW = ${this.worldNormal.associatedVariableName}.xyz;\\r\\n`;\n        }\n        if (this.light) {\n            state.compilationString += state._emitCodeFromInclude(\"lightFragment\", comments, {\n                replaceStrings: [{ search: /{X}/g, replace: this._lightId.toString() }],\n            });\n        }\n        else {\n            state.compilationString += state._emitCodeFromInclude(\"lightFragment\", comments, {\n                repeatKey: \"maxSimultaneousLights\",\n            });\n        }\n        const diffuseOutput = this.diffuseOutput;\n        const specularOutput = this.specularOutput;\n        state.compilationString +=\n            this._declareOutput(diffuseOutput, state) + ` = diffuseBase${this.diffuseColor.isConnected ? \" * \" + this.diffuseColor.associatedVariableName : \"\"};\\r\\n`;\n        if (specularOutput.hasEndpoints) {\n            state.compilationString +=\n                this._declareOutput(specularOutput, state) + ` = specularBase${this.specularColor.isConnected ? \" * \" + this.specularColor.associatedVariableName : \"\"};\\r\\n`;\n        }\n        if (this.shadow.hasEndpoints) {\n            state.compilationString += this._declareOutput(this.shadow, state) + ` = shadow;\\r\\n`;\n        }\n        return this;\n    }\n    serialize() {\n        const serializationObject = super.serialize();\n        serializationObject.generateOnlyFragmentCode = this.generateOnlyFragmentCode;\n        if (this.light) {\n            serializationObject.lightId = this.light.id;\n        }\n        return serializationObject;\n    }\n    _deserialize(serializationObject, scene, rootUrl) {\n        super._deserialize(serializationObject, scene, rootUrl);\n        if (serializationObject.lightId) {\n            this.light = scene.getLightById(serializationObject.lightId);\n        }\n        this.generateOnlyFragmentCode = serializationObject.generateOnlyFragmentCode;\n        this._setTarget();\n    }\n}\n__decorate([\n    editableInPropertyPage(\"Generate only fragment code\", PropertyTypeForEdition.Boolean, \"ADVANCED\", {\n        notifiers: { rebuild: true, update: true, onValidation: LightBlock._OnGenerateOnlyFragmentCodeChanged },\n    })\n], LightBlock.prototype, \"generateOnlyFragmentCode\", void 0);\nRegisterClass(\"BABYLON.LightBlock\", LightBlock);\n//# sourceMappingURL=lightBlock.js.map","import { NodeMaterialBlock } from \"../../nodeMaterialBlock.js\";\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes.js\";\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets.js\";\nimport { NodeMaterialConnectionPointDirection } from \"../../nodeMaterialBlockConnectionPoint.js\";\nimport { NodeMaterial } from \"../../nodeMaterial.js\";\nimport { InputBlock } from \"../Input/inputBlock.js\";\nimport { RegisterClass } from \"../../../../Misc/typeStore.js\";\nimport { Texture } from \"../../../Textures/texture.js\";\nimport { NodeMaterialModes } from \"../../Enums/nodeMaterialModes.js\";\n\nimport \"../../../../Shaders/ShadersInclude/helperFunctions.js\";\nimport { ImageSourceBlock } from \"./imageSourceBlock.js\";\nimport { NodeMaterialConnectionPointCustomObject } from \"../../nodeMaterialConnectionPointCustomObject.js\";\nimport { EngineStore } from \"../../../../Engines/engineStore.js\";\n/**\n * Block used to read a texture from a sampler\n */\nexport class TextureBlock extends NodeMaterialBlock {\n    /**\n     * Gets or sets the texture associated with the node\n     */\n    get texture() {\n        var _a;\n        if (this.source.isConnected) {\n            return ((_a = this.source.connectedPoint) === null || _a === void 0 ? void 0 : _a.ownerBlock).texture;\n        }\n        return this._texture;\n    }\n    set texture(texture) {\n        var _a;\n        if (this._texture === texture) {\n            return;\n        }\n        const scene = (_a = texture === null || texture === void 0 ? void 0 : texture.getScene()) !== null && _a !== void 0 ? _a : EngineStore.LastCreatedScene;\n        if (!texture && scene) {\n            scene.markAllMaterialsAsDirty(1, (mat) => {\n                return mat.hasTexture(this._texture);\n            });\n        }\n        this._texture = texture;\n        if (texture && scene) {\n            scene.markAllMaterialsAsDirty(1, (mat) => {\n                return mat.hasTexture(texture);\n            });\n        }\n    }\n    /**\n     * Gets the sampler name associated with this texture\n     */\n    get samplerName() {\n        if (this._imageSource) {\n            return this._imageSource.samplerName;\n        }\n        return this._samplerName;\n    }\n    /**\n     * Gets a boolean indicating that this block is linked to an ImageSourceBlock\n     */\n    get hasImageSource() {\n        return this.source.isConnected;\n    }\n    /**\n     * Gets or sets a boolean indicating if content needs to be converted to gamma space\n     */\n    set convertToGammaSpace(value) {\n        var _a;\n        if (value === this._convertToGammaSpace) {\n            return;\n        }\n        this._convertToGammaSpace = value;\n        if (this.texture) {\n            const scene = (_a = this.texture.getScene()) !== null && _a !== void 0 ? _a : EngineStore.LastCreatedScene;\n            scene === null || scene === void 0 ? void 0 : scene.markAllMaterialsAsDirty(1, (mat) => {\n                return mat.hasTexture(this.texture);\n            });\n        }\n    }\n    get convertToGammaSpace() {\n        return this._convertToGammaSpace;\n    }\n    /**\n     * Gets or sets a boolean indicating if content needs to be converted to linear space\n     */\n    set convertToLinearSpace(value) {\n        var _a;\n        if (value === this._convertToLinearSpace) {\n            return;\n        }\n        this._convertToLinearSpace = value;\n        if (this.texture) {\n            const scene = (_a = this.texture.getScene()) !== null && _a !== void 0 ? _a : EngineStore.LastCreatedScene;\n            scene === null || scene === void 0 ? void 0 : scene.markAllMaterialsAsDirty(1, (mat) => {\n                return mat.hasTexture(this.texture);\n            });\n        }\n    }\n    get convertToLinearSpace() {\n        return this._convertToLinearSpace;\n    }\n    /**\n     * Create a new TextureBlock\n     * @param name defines the block name\n     * @param fragmentOnly\n     */\n    constructor(name, fragmentOnly = false) {\n        super(name, fragmentOnly ? NodeMaterialBlockTargets.Fragment : NodeMaterialBlockTargets.VertexAndFragment);\n        this._convertToGammaSpace = false;\n        this._convertToLinearSpace = false;\n        /**\n         * Gets or sets a boolean indicating if multiplication of texture with level should be disabled\n         */\n        this.disableLevelMultiplication = false;\n        this._fragmentOnly = fragmentOnly;\n        this.registerInput(\"uv\", NodeMaterialBlockConnectionPointTypes.AutoDetect, false, NodeMaterialBlockTargets.VertexAndFragment);\n        this.registerInput(\"source\", NodeMaterialBlockConnectionPointTypes.Object, true, NodeMaterialBlockTargets.VertexAndFragment, new NodeMaterialConnectionPointCustomObject(\"source\", this, NodeMaterialConnectionPointDirection.Input, ImageSourceBlock, \"ImageSourceBlock\"));\n        this.registerOutput(\"rgba\", NodeMaterialBlockConnectionPointTypes.Color4, NodeMaterialBlockTargets.Neutral);\n        this.registerOutput(\"rgb\", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Neutral);\n        this.registerOutput(\"r\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\n        this.registerOutput(\"g\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\n        this.registerOutput(\"b\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\n        this.registerOutput(\"a\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\n        this.registerOutput(\"level\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\n        this._inputs[0].addExcludedConnectionPointFromAllowedTypes(NodeMaterialBlockConnectionPointTypes.Vector2 | NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Vector4);\n        this._inputs[0]._prioritizeVertex = !fragmentOnly;\n    }\n    /**\n     * Gets the current class name\n     * @returns the class name\n     */\n    getClassName() {\n        return \"TextureBlock\";\n    }\n    /**\n     * Gets the uv input component\n     */\n    get uv() {\n        return this._inputs[0];\n    }\n    /**\n     * Gets the source input component\n     */\n    get source() {\n        return this._inputs[1];\n    }\n    /**\n     * Gets the rgba output component\n     */\n    get rgba() {\n        return this._outputs[0];\n    }\n    /**\n     * Gets the rgb output component\n     */\n    get rgb() {\n        return this._outputs[1];\n    }\n    /**\n     * Gets the r output component\n     */\n    get r() {\n        return this._outputs[2];\n    }\n    /**\n     * Gets the g output component\n     */\n    get g() {\n        return this._outputs[3];\n    }\n    /**\n     * Gets the b output component\n     */\n    get b() {\n        return this._outputs[4];\n    }\n    /**\n     * Gets the a output component\n     */\n    get a() {\n        return this._outputs[5];\n    }\n    /**\n     * Gets the level output component\n     */\n    get level() {\n        return this._outputs[6];\n    }\n    get target() {\n        if (this._fragmentOnly) {\n            return NodeMaterialBlockTargets.Fragment;\n        }\n        // TextureBlock has a special optimizations for uvs that come from the vertex shaders as they can be packed into a single varyings.\n        // But we need to detect uvs coming from fragment then\n        if (!this.uv.isConnected) {\n            return NodeMaterialBlockTargets.VertexAndFragment;\n        }\n        if (this.uv.sourceBlock.isInput) {\n            return NodeMaterialBlockTargets.VertexAndFragment;\n        }\n        let parent = this.uv.connectedPoint;\n        while (parent) {\n            if (parent.target === NodeMaterialBlockTargets.Fragment) {\n                return NodeMaterialBlockTargets.Fragment;\n            }\n            if (parent.target === NodeMaterialBlockTargets.Vertex) {\n                return NodeMaterialBlockTargets.VertexAndFragment;\n            }\n            if (parent.target === NodeMaterialBlockTargets.Neutral || parent.target === NodeMaterialBlockTargets.VertexAndFragment) {\n                const parentBlock = parent.ownerBlock;\n                if (parentBlock.target === NodeMaterialBlockTargets.Fragment) {\n                    return NodeMaterialBlockTargets.Fragment;\n                }\n                parent = null;\n                for (const input of parentBlock.inputs) {\n                    if (input.connectedPoint) {\n                        parent = input.connectedPoint;\n                        break;\n                    }\n                }\n            }\n        }\n        return NodeMaterialBlockTargets.VertexAndFragment;\n    }\n    set target(value) { }\n    autoConfigure(material) {\n        if (!this.uv.isConnected) {\n            if (material.mode === NodeMaterialModes.PostProcess) {\n                const uvInput = material.getBlockByPredicate((b) => b.name === \"uv\");\n                if (uvInput) {\n                    uvInput.connectTo(this);\n                }\n            }\n            else {\n                const attributeName = material.mode === NodeMaterialModes.Particle ? \"particle_uv\" : \"uv\";\n                let uvInput = material.getInputBlockByPredicate((b) => b.isAttribute && b.name === attributeName);\n                if (!uvInput) {\n                    uvInput = new InputBlock(\"uv\");\n                    uvInput.setAsAttribute(attributeName);\n                }\n                uvInput.output.connectTo(this.uv);\n            }\n        }\n    }\n    initializeDefines(mesh, nodeMaterial, defines) {\n        if (!defines._areTexturesDirty) {\n            return;\n        }\n        if (this._mainUVDefineName !== undefined) {\n            defines.setValue(this._mainUVDefineName, false, true);\n        }\n    }\n    prepareDefines(mesh, nodeMaterial, defines) {\n        if (!defines._areTexturesDirty) {\n            return;\n        }\n        if (!this.texture || !this.texture.getTextureMatrix) {\n            if (this._isMixed) {\n                defines.setValue(this._defineName, false, true);\n                defines.setValue(this._mainUVDefineName, true, true);\n            }\n            return;\n        }\n        const toGamma = this.convertToGammaSpace && this.texture && !this.texture.gammaSpace;\n        const toLinear = this.convertToLinearSpace && this.texture && this.texture.gammaSpace;\n        // Not a bug... Name defines the texture space not the required conversion\n        defines.setValue(this._linearDefineName, toGamma, true);\n        defines.setValue(this._gammaDefineName, toLinear, true);\n        if (this._isMixed) {\n            if (!this.texture.getTextureMatrix().isIdentityAs3x2()) {\n                defines.setValue(this._defineName, true);\n                if (defines[this._mainUVDefineName] == undefined) {\n                    defines.setValue(this._mainUVDefineName, false, true);\n                }\n            }\n            else {\n                defines.setValue(this._defineName, false, true);\n                defines.setValue(this._mainUVDefineName, true, true);\n            }\n        }\n    }\n    isReady() {\n        if (this.texture && !this.texture.isReadyOrNotBlocking()) {\n            return false;\n        }\n        return true;\n    }\n    bind(effect) {\n        if (!this.texture) {\n            return;\n        }\n        if (this._isMixed) {\n            effect.setFloat(this._textureInfoName, this.texture.level);\n            effect.setMatrix(this._textureTransformName, this.texture.getTextureMatrix());\n        }\n        if (!this._imageSource) {\n            effect.setTexture(this._samplerName, this.texture);\n        }\n    }\n    get _isMixed() {\n        return this.target !== NodeMaterialBlockTargets.Fragment;\n    }\n    _injectVertexCode(state) {\n        const uvInput = this.uv;\n        // Inject code in vertex\n        this._defineName = state._getFreeDefineName(\"UVTRANSFORM\");\n        this._mainUVDefineName = \"VMAIN\" + uvInput.associatedVariableName.toUpperCase();\n        this._mainUVName = \"vMain\" + uvInput.associatedVariableName;\n        this._transformedUVName = state._getFreeVariableName(\"transformedUV\");\n        this._textureTransformName = state._getFreeVariableName(\"textureTransform\");\n        this._textureInfoName = state._getFreeVariableName(\"textureInfoName\");\n        this.level.associatedVariableName = this._textureInfoName;\n        state._emitVaryingFromString(this._transformedUVName, \"vec2\", this._defineName);\n        state._emitVaryingFromString(this._mainUVName, \"vec2\", this._mainUVDefineName);\n        state._emitUniformFromString(this._textureTransformName, \"mat4\", this._defineName);\n        state.compilationString += `#ifdef ${this._defineName}\\r\\n`;\n        state.compilationString += `${this._transformedUVName} = vec2(${this._textureTransformName} * vec4(${uvInput.associatedVariableName}.xy, 1.0, 0.0));\\r\\n`;\n        state.compilationString += `#elif defined(${this._mainUVDefineName})\\r\\n`;\n        state.compilationString += `${this._mainUVName} = ${uvInput.associatedVariableName}.xy;\\r\\n`;\n        state.compilationString += `#endif\\r\\n`;\n        if (!this._outputs.some((o) => o.isConnectedInVertexShader)) {\n            return;\n        }\n        this._writeTextureRead(state, true);\n        for (const output of this._outputs) {\n            if (output.hasEndpoints && output.name !== \"level\") {\n                this._writeOutput(state, output, output.name, true);\n            }\n        }\n    }\n    _generateTextureLookup(state) {\n        const samplerName = this.samplerName;\n        state.compilationString += `#ifdef ${this._defineName}\\r\\n`;\n        state.compilationString += `vec4 ${this._tempTextureRead} = texture2D(${samplerName}, ${this._transformedUVName});\\r\\n`;\n        state.compilationString += `#elif defined(${this._mainUVDefineName})\\r\\n`;\n        state.compilationString += `vec4 ${this._tempTextureRead} = texture2D(${samplerName}, ${this._mainUVName ? this._mainUVName : this.uv.associatedVariableName});\\r\\n`;\n        state.compilationString += `#endif\\r\\n`;\n    }\n    _writeTextureRead(state, vertexMode = false) {\n        const uvInput = this.uv;\n        if (vertexMode) {\n            if (state.target === NodeMaterialBlockTargets.Fragment) {\n                return;\n            }\n            this._generateTextureLookup(state);\n            return;\n        }\n        if (this.uv.ownerBlock.target === NodeMaterialBlockTargets.Fragment) {\n            state.compilationString += `vec4 ${this._tempTextureRead} = texture2D(${this.samplerName}, ${uvInput.associatedVariableName});\\r\\n`;\n            return;\n        }\n        this._generateTextureLookup(state);\n    }\n    _generateConversionCode(state, output, swizzle) {\n        if (swizzle !== \"a\") {\n            // no conversion if the output is \"a\" (alpha)\n            if (!this.texture || !this.texture.gammaSpace) {\n                state.compilationString += `#ifdef ${this._linearDefineName}\r\n                    ${output.associatedVariableName} = toGammaSpace(${output.associatedVariableName});\r\n                    #endif\r\n                `;\n            }\n            state.compilationString += `#ifdef ${this._gammaDefineName}\r\n                ${output.associatedVariableName} = toLinearSpace(${output.associatedVariableName});\r\n                #endif\r\n            `;\n        }\n    }\n    _writeOutput(state, output, swizzle, vertexMode = false) {\n        if (vertexMode) {\n            if (state.target === NodeMaterialBlockTargets.Fragment) {\n                return;\n            }\n            state.compilationString += `${this._declareOutput(output, state)} = ${this._tempTextureRead}.${swizzle};\\r\\n`;\n            this._generateConversionCode(state, output, swizzle);\n            return;\n        }\n        if (this.uv.ownerBlock.target === NodeMaterialBlockTargets.Fragment) {\n            state.compilationString += `${this._declareOutput(output, state)} = ${this._tempTextureRead}.${swizzle};\\r\\n`;\n            this._generateConversionCode(state, output, swizzle);\n            return;\n        }\n        let complement = \"\";\n        if (!this.disableLevelMultiplication) {\n            complement = ` * ${this._textureInfoName}`;\n        }\n        state.compilationString += `${this._declareOutput(output, state)} = ${this._tempTextureRead}.${swizzle}${complement};\\r\\n`;\n        this._generateConversionCode(state, output, swizzle);\n    }\n    _buildBlock(state) {\n        super._buildBlock(state);\n        if (this.source.isConnected) {\n            this._imageSource = this.source.connectedPoint.ownerBlock;\n        }\n        else {\n            this._imageSource = null;\n        }\n        if (state.target === NodeMaterialBlockTargets.Vertex || this._fragmentOnly || state.target === NodeMaterialBlockTargets.Fragment) {\n            this._tempTextureRead = state._getFreeVariableName(\"tempTextureRead\");\n            this._linearDefineName = state._getFreeDefineName(\"ISLINEAR\");\n            this._gammaDefineName = state._getFreeDefineName(\"ISGAMMA\");\n        }\n        if ((!this._isMixed && state.target === NodeMaterialBlockTargets.Fragment) || (this._isMixed && state.target === NodeMaterialBlockTargets.Vertex)) {\n            if (!this._imageSource) {\n                this._samplerName = state._getFreeVariableName(this.name + \"Sampler\");\n                state._emit2DSampler(this._samplerName);\n            }\n            // Declarations\n            state.sharedData.blockingBlocks.push(this);\n            state.sharedData.textureBlocks.push(this);\n            state.sharedData.blocksWithDefines.push(this);\n            state.sharedData.bindableBlocks.push(this);\n        }\n        if (state.target !== NodeMaterialBlockTargets.Fragment) {\n            // Vertex\n            this._injectVertexCode(state);\n            return;\n        }\n        // Fragment\n        if (!this._outputs.some((o) => o.isConnectedInFragmentShader)) {\n            return;\n        }\n        if (this._isMixed && !this._imageSource) {\n            // Reexport the sampler\n            state._emit2DSampler(this._samplerName);\n        }\n        const comments = `//${this.name}`;\n        state._emitFunctionFromInclude(\"helperFunctions\", comments);\n        if (this._isMixed) {\n            state._emitUniformFromString(this._textureInfoName, \"float\");\n        }\n        this._writeTextureRead(state);\n        for (const output of this._outputs) {\n            if (output.hasEndpoints && output.name !== \"level\") {\n                this._writeOutput(state, output, output.name);\n            }\n        }\n        return this;\n    }\n    _dumpPropertiesCode() {\n        let codeString = super._dumpPropertiesCode();\n        codeString += `${this._codeVariableName}.convertToGammaSpace = ${this.convertToGammaSpace};\\r\\n`;\n        codeString += `${this._codeVariableName}.convertToLinearSpace = ${this.convertToLinearSpace};\\r\\n`;\n        codeString += `${this._codeVariableName}.disableLevelMultiplication = ${this.disableLevelMultiplication};\\r\\n`;\n        if (!this.texture) {\n            return codeString;\n        }\n        codeString += `${this._codeVariableName}.texture = new BABYLON.Texture(\"${this.texture.name}\", null, ${this.texture.noMipmap}, ${this.texture.invertY}, ${this.texture.samplingMode});\\r\\n`;\n        codeString += `${this._codeVariableName}.texture.wrapU = ${this.texture.wrapU};\\r\\n`;\n        codeString += `${this._codeVariableName}.texture.wrapV = ${this.texture.wrapV};\\r\\n`;\n        codeString += `${this._codeVariableName}.texture.uAng = ${this.texture.uAng};\\r\\n`;\n        codeString += `${this._codeVariableName}.texture.vAng = ${this.texture.vAng};\\r\\n`;\n        codeString += `${this._codeVariableName}.texture.wAng = ${this.texture.wAng};\\r\\n`;\n        codeString += `${this._codeVariableName}.texture.uOffset = ${this.texture.uOffset};\\r\\n`;\n        codeString += `${this._codeVariableName}.texture.vOffset = ${this.texture.vOffset};\\r\\n`;\n        codeString += `${this._codeVariableName}.texture.uScale = ${this.texture.uScale};\\r\\n`;\n        codeString += `${this._codeVariableName}.texture.vScale = ${this.texture.vScale};\\r\\n`;\n        codeString += `${this._codeVariableName}.texture.coordinatesMode = ${this.texture.coordinatesMode};\\r\\n`;\n        return codeString;\n    }\n    serialize() {\n        const serializationObject = super.serialize();\n        serializationObject.convertToGammaSpace = this.convertToGammaSpace;\n        serializationObject.convertToLinearSpace = this.convertToLinearSpace;\n        serializationObject.fragmentOnly = this._fragmentOnly;\n        serializationObject.disableLevelMultiplication = this.disableLevelMultiplication;\n        if (!this.hasImageSource && this.texture && !this.texture.isRenderTarget && this.texture.getClassName() !== \"VideoTexture\") {\n            serializationObject.texture = this.texture.serialize();\n        }\n        return serializationObject;\n    }\n    _deserialize(serializationObject, scene, rootUrl) {\n        super._deserialize(serializationObject, scene, rootUrl);\n        this.convertToGammaSpace = serializationObject.convertToGammaSpace;\n        this.convertToLinearSpace = !!serializationObject.convertToLinearSpace;\n        this._fragmentOnly = !!serializationObject.fragmentOnly;\n        this.disableLevelMultiplication = !!serializationObject.disableLevelMultiplication;\n        if (serializationObject.texture && !NodeMaterial.IgnoreTexturesAtLoadTime && serializationObject.texture.url !== undefined) {\n            rootUrl = serializationObject.texture.url.indexOf(\"data:\") === 0 ? \"\" : rootUrl;\n            this.texture = Texture.Parse(serializationObject.texture, scene, rootUrl);\n        }\n    }\n}\nRegisterClass(\"BABYLON.TextureBlock\", TextureBlock);\n//# sourceMappingURL=textureBlock.js.map","import { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes.js\";\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets.js\";\nimport { RegisterClass } from \"../../../../Misc/typeStore.js\";\nimport { InputBlock } from \"../Input/inputBlock.js\";\nimport { NodeMaterialSystemValues } from \"../../Enums/nodeMaterialSystemValues.js\";\nimport { ReflectionTextureBaseBlock } from \"./reflectionTextureBaseBlock.js\";\n/**\n * Block used to read a reflection texture from a sampler\n */\nexport class ReflectionTextureBlock extends ReflectionTextureBaseBlock {\n    _onGenerateOnlyFragmentCodeChanged() {\n        if (this.position.isConnected) {\n            this.generateOnlyFragmentCode = !this.generateOnlyFragmentCode;\n            console.error(\"The position input must not be connected to be able to switch!\");\n            return false;\n        }\n        if (this.worldPosition.isConnected) {\n            this.generateOnlyFragmentCode = !this.generateOnlyFragmentCode;\n            console.error(\"The worldPosition input must not be connected to be able to switch!\");\n            return false;\n        }\n        this._setTarget();\n        return true;\n    }\n    _setTarget() {\n        super._setTarget();\n        this.getInputByName(\"position\").target = this.generateOnlyFragmentCode ? NodeMaterialBlockTargets.Fragment : NodeMaterialBlockTargets.Vertex;\n        this.getInputByName(\"worldPosition\").target = this.generateOnlyFragmentCode ? NodeMaterialBlockTargets.Fragment : NodeMaterialBlockTargets.Vertex;\n    }\n    /**\n     * Create a new ReflectionTextureBlock\n     * @param name defines the block name\n     */\n    constructor(name) {\n        super(name);\n        this.registerInput(\"position\", NodeMaterialBlockConnectionPointTypes.AutoDetect, false, NodeMaterialBlockTargets.Vertex);\n        this.registerInput(\"worldPosition\", NodeMaterialBlockConnectionPointTypes.Vector4, false, NodeMaterialBlockTargets.Vertex);\n        this.registerInput(\"worldNormal\", NodeMaterialBlockConnectionPointTypes.Vector4, false, NodeMaterialBlockTargets.Fragment); // Flagging as fragment as the normal can be changed by fragment code\n        this.registerInput(\"world\", NodeMaterialBlockConnectionPointTypes.Matrix, false, NodeMaterialBlockTargets.Vertex);\n        this.registerInput(\"cameraPosition\", NodeMaterialBlockConnectionPointTypes.Vector3, false, NodeMaterialBlockTargets.Fragment);\n        this.registerInput(\"view\", NodeMaterialBlockConnectionPointTypes.Matrix, false, NodeMaterialBlockTargets.Fragment);\n        this.registerOutput(\"rgb\", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Fragment);\n        this.registerOutput(\"rgba\", NodeMaterialBlockConnectionPointTypes.Color4, NodeMaterialBlockTargets.Fragment);\n        this.registerOutput(\"r\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Fragment);\n        this.registerOutput(\"g\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Fragment);\n        this.registerOutput(\"b\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Fragment);\n        this.registerOutput(\"a\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Fragment);\n        this._inputs[0].addExcludedConnectionPointFromAllowedTypes(NodeMaterialBlockConnectionPointTypes.Color3 | NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Vector4);\n    }\n    /**\n     * Gets the current class name\n     * @returns the class name\n     */\n    getClassName() {\n        return \"ReflectionTextureBlock\";\n    }\n    /**\n     * Gets the world position input component\n     */\n    get position() {\n        return this._inputs[0];\n    }\n    /**\n     * Gets the world position input component\n     */\n    get worldPosition() {\n        return this._inputs[1];\n    }\n    /**\n     * Gets the world normal input component\n     */\n    get worldNormal() {\n        return this._inputs[2];\n    }\n    /**\n     * Gets the world input component\n     */\n    get world() {\n        return this._inputs[3];\n    }\n    /**\n     * Gets the camera (or eye) position component\n     */\n    get cameraPosition() {\n        return this._inputs[4];\n    }\n    /**\n     * Gets the view input component\n     */\n    get view() {\n        return this._inputs[5];\n    }\n    /**\n     * Gets the rgb output component\n     */\n    get rgb() {\n        return this._outputs[0];\n    }\n    /**\n     * Gets the rgba output component\n     */\n    get rgba() {\n        return this._outputs[1];\n    }\n    /**\n     * Gets the r output component\n     */\n    get r() {\n        return this._outputs[2];\n    }\n    /**\n     * Gets the g output component\n     */\n    get g() {\n        return this._outputs[3];\n    }\n    /**\n     * Gets the b output component\n     */\n    get b() {\n        return this._outputs[4];\n    }\n    /**\n     * Gets the a output component\n     */\n    get a() {\n        return this._outputs[5];\n    }\n    autoConfigure(material) {\n        super.autoConfigure(material);\n        if (!this.cameraPosition.isConnected) {\n            let cameraPositionInput = material.getInputBlockByPredicate((b) => b.systemValue === NodeMaterialSystemValues.CameraPosition);\n            if (!cameraPositionInput) {\n                cameraPositionInput = new InputBlock(\"cameraPosition\");\n                cameraPositionInput.setAsSystemValue(NodeMaterialSystemValues.CameraPosition);\n            }\n            cameraPositionInput.output.connectTo(this.cameraPosition);\n        }\n    }\n    _buildBlock(state) {\n        super._buildBlock(state);\n        if (!this.texture) {\n            state.compilationString += this.writeOutputs(state, \"vec4(0.)\");\n            return this;\n        }\n        if (state.target !== NodeMaterialBlockTargets.Fragment) {\n            state.compilationString += this.handleVertexSide(state);\n            return this;\n        }\n        if (this.generateOnlyFragmentCode) {\n            state.compilationString += this.handleVertexSide(state);\n        }\n        this.handleFragmentSideInits(state);\n        const normalWUnit = state._getFreeVariableName(\"normalWUnit\");\n        state.compilationString += `vec4 ${normalWUnit} = normalize(${this.worldNormal.associatedVariableName});\\r\\n`;\n        state.compilationString += this.handleFragmentSideCodeReflectionCoords(normalWUnit);\n        state.compilationString += this.handleFragmentSideCodeReflectionColor(undefined, \"\");\n        state.compilationString += this.writeOutputs(state, this._reflectionColorName);\n        return this;\n    }\n}\nRegisterClass(\"BABYLON.ReflectionTextureBlock\", ReflectionTextureBlock);\n//# sourceMappingURL=reflectionTextureBlock.js.map","import { __decorate } from \"../../../../tslib.es6.js\";\nimport { NodeMaterialBlock } from \"../../nodeMaterialBlock.js\";\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes.js\";\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets.js\";\nimport { RegisterClass } from \"../../../../Misc/typeStore.js\";\nimport { editableInPropertyPage, PropertyTypeForEdition } from \"../../nodeMaterialDecorator.js\";\n/**\n * Block used to retrieve the depth (zbuffer) of the scene\n * @since 5.0.0\n */\nexport class SceneDepthBlock extends NodeMaterialBlock {\n    /**\n     * Create a new SceneDepthBlock\n     * @param name defines the block name\n     */\n    constructor(name) {\n        super(name, NodeMaterialBlockTargets.VertexAndFragment);\n        /**\n         * Defines if the depth renderer should be setup in non linear mode\n         */\n        this.useNonLinearDepth = false;\n        /**\n         * Defines if the depth renderer should be setup in full 32 bits float mode\n         */\n        this.force32itsFloat = false;\n        this._isUnique = true;\n        this.registerInput(\"uv\", NodeMaterialBlockConnectionPointTypes.AutoDetect, false, NodeMaterialBlockTargets.VertexAndFragment);\n        this.registerOutput(\"depth\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\n        this._inputs[0].addExcludedConnectionPointFromAllowedTypes(NodeMaterialBlockConnectionPointTypes.Vector2 | NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Vector4);\n        this._inputs[0]._prioritizeVertex = false;\n    }\n    /**\n     * Gets the current class name\n     * @returns the class name\n     */\n    getClassName() {\n        return \"SceneDepthBlock\";\n    }\n    /**\n     * Gets the uv input component\n     */\n    get uv() {\n        return this._inputs[0];\n    }\n    /**\n     * Gets the depth output component\n     */\n    get depth() {\n        return this._outputs[0];\n    }\n    /**\n     * Initialize the block and prepare the context for build\n     * @param state defines the state that will be used for the build\n     */\n    initialize(state) {\n        state._excludeVariableName(\"textureSampler\");\n    }\n    get target() {\n        if (!this.uv.isConnected) {\n            return NodeMaterialBlockTargets.VertexAndFragment;\n        }\n        if (this.uv.sourceBlock.isInput) {\n            return NodeMaterialBlockTargets.VertexAndFragment;\n        }\n        return NodeMaterialBlockTargets.Fragment;\n    }\n    _getTexture(scene) {\n        const depthRenderer = scene.enableDepthRenderer(undefined, this.useNonLinearDepth, this.force32itsFloat);\n        return depthRenderer.getDepthMap();\n    }\n    bind(effect, nodeMaterial) {\n        const texture = this._getTexture(nodeMaterial.getScene());\n        effect.setTexture(this._samplerName, texture);\n    }\n    _injectVertexCode(state) {\n        const uvInput = this.uv;\n        if (uvInput.connectedPoint.ownerBlock.isInput) {\n            const uvInputOwnerBlock = uvInput.connectedPoint.ownerBlock;\n            if (!uvInputOwnerBlock.isAttribute) {\n                state._emitUniformFromString(uvInput.associatedVariableName, \"vec\" + (uvInput.type === NodeMaterialBlockConnectionPointTypes.Vector3 ? \"3\" : uvInput.type === NodeMaterialBlockConnectionPointTypes.Vector4 ? \"4\" : \"2\"));\n            }\n        }\n        this._mainUVName = \"vMain\" + uvInput.associatedVariableName;\n        state._emitVaryingFromString(this._mainUVName, \"vec2\");\n        state.compilationString += `${this._mainUVName} = ${uvInput.associatedVariableName}.xy;\\r\\n`;\n        if (!this._outputs.some((o) => o.isConnectedInVertexShader)) {\n            return;\n        }\n        this._writeTextureRead(state, true);\n        for (const output of this._outputs) {\n            if (output.hasEndpoints) {\n                this._writeOutput(state, output, \"r\", true);\n            }\n        }\n    }\n    _writeTextureRead(state, vertexMode = false) {\n        const uvInput = this.uv;\n        if (vertexMode) {\n            if (state.target === NodeMaterialBlockTargets.Fragment) {\n                return;\n            }\n            state.compilationString += `vec4 ${this._tempTextureRead} = texture2D(${this._samplerName}, ${uvInput.associatedVariableName}.xy);\\r\\n`;\n            return;\n        }\n        if (this.uv.ownerBlock.target === NodeMaterialBlockTargets.Fragment) {\n            state.compilationString += `vec4 ${this._tempTextureRead} = texture2D(${this._samplerName}, ${uvInput.associatedVariableName}.xy);\\r\\n`;\n            return;\n        }\n        state.compilationString += `vec4 ${this._tempTextureRead} = texture2D(${this._samplerName}, ${this._mainUVName});\\r\\n`;\n    }\n    _writeOutput(state, output, swizzle, vertexMode = false) {\n        if (vertexMode) {\n            if (state.target === NodeMaterialBlockTargets.Fragment) {\n                return;\n            }\n            state.compilationString += `${this._declareOutput(output, state)} = ${this._tempTextureRead}.${swizzle};\\r\\n`;\n            return;\n        }\n        if (this.uv.ownerBlock.target === NodeMaterialBlockTargets.Fragment) {\n            state.compilationString += `${this._declareOutput(output, state)} = ${this._tempTextureRead}.${swizzle};\\r\\n`;\n            return;\n        }\n        state.compilationString += `${this._declareOutput(output, state)} = ${this._tempTextureRead}.${swizzle};\\r\\n`;\n    }\n    _buildBlock(state) {\n        super._buildBlock(state);\n        this._samplerName = state._getFreeVariableName(this.name + \"Sampler\");\n        this._tempTextureRead = state._getFreeVariableName(\"tempTextureRead\");\n        if (state.sharedData.bindableBlocks.indexOf(this) < 0) {\n            state.sharedData.bindableBlocks.push(this);\n        }\n        if (state.target !== NodeMaterialBlockTargets.Fragment) {\n            // Vertex\n            state._emit2DSampler(this._samplerName);\n            this._injectVertexCode(state);\n            return;\n        }\n        // Fragment\n        if (!this._outputs.some((o) => o.isConnectedInFragmentShader)) {\n            return;\n        }\n        state._emit2DSampler(this._samplerName);\n        this._writeTextureRead(state);\n        for (const output of this._outputs) {\n            if (output.hasEndpoints) {\n                this._writeOutput(state, output, \"r\");\n            }\n        }\n        return this;\n    }\n    serialize() {\n        const serializationObject = super.serialize();\n        serializationObject.useNonLinearDepth = this.useNonLinearDepth;\n        serializationObject.force32itsFloat = this.force32itsFloat;\n        return serializationObject;\n    }\n    _deserialize(serializationObject, scene, rootUrl) {\n        super._deserialize(serializationObject, scene, rootUrl);\n        this.useNonLinearDepth = serializationObject.useNonLinearDepth;\n        this.force32itsFloat = serializationObject.force32itsFloat;\n    }\n}\n__decorate([\n    editableInPropertyPage(\"Use non linear depth\", PropertyTypeForEdition.Boolean, \"ADVANCED\", {\n        notifiers: { activatePreviewCommand: true, callback: (scene) => scene.disableDepthRenderer() },\n    })\n], SceneDepthBlock.prototype, \"useNonLinearDepth\", void 0);\n__decorate([\n    editableInPropertyPage(\"Force 32 bits float\", PropertyTypeForEdition.Boolean, \"ADVANCED\", {\n        notifiers: { activatePreviewCommand: true, callback: (scene) => scene.disableDepthRenderer() },\n    })\n], SceneDepthBlock.prototype, \"force32itsFloat\", void 0);\nRegisterClass(\"BABYLON.SceneDepthBlock\", SceneDepthBlock);\n//# sourceMappingURL=sceneDepthBlock.js.map","import { NodeMaterialBlock } from \"../../nodeMaterialBlock.js\";\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes.js\";\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets.js\";\nimport { RegisterClass } from \"../../../../Misc/typeStore.js\";\nimport { bindClipPlane } from \"../../../../Materials/clipPlaneMaterialHelper.js\";\n/**\n * Block used to implement clip planes\n */\nexport class ClipPlanesBlock extends NodeMaterialBlock {\n    /**\n     * Create a new ClipPlanesBlock\n     * @param name defines the block name\n     */\n    constructor(name) {\n        super(name, NodeMaterialBlockTargets.VertexAndFragment, true);\n        this.registerInput(\"worldPosition\", NodeMaterialBlockConnectionPointTypes.Vector4, false);\n    }\n    /**\n     * Gets the current class name\n     * @returns the class name\n     */\n    getClassName() {\n        return \"ClipPlanesBlock\";\n    }\n    /**\n     * Initialize the block and prepare the context for build\n     * @param state defines the state that will be used for the build\n     */\n    initialize(state) {\n        state._excludeVariableName(\"vClipPlane\");\n        state._excludeVariableName(\"fClipDistance\");\n        state._excludeVariableName(\"vClipPlane2\");\n        state._excludeVariableName(\"fClipDistance2\");\n        state._excludeVariableName(\"vClipPlane3\");\n        state._excludeVariableName(\"fClipDistance3\");\n        state._excludeVariableName(\"vClipPlane4\");\n        state._excludeVariableName(\"fClipDistance4\");\n        state._excludeVariableName(\"vClipPlane5\");\n        state._excludeVariableName(\"fClipDistance5\");\n        state._excludeVariableName(\"vClipPlane6\");\n        state._excludeVariableName(\"fClipDistance6\");\n    }\n    /**\n     * Gets the worldPosition input component\n     */\n    get worldPosition() {\n        return this._inputs[0];\n    }\n    get target() {\n        return NodeMaterialBlockTargets.VertexAndFragment;\n    }\n    set target(value) { }\n    prepareDefines(mesh, nodeMaterial, defines) {\n        var _a, _b, _c, _d, _e, _f;\n        const scene = mesh.getScene();\n        const useClipPlane1 = ((_a = nodeMaterial.clipPlane) !== null && _a !== void 0 ? _a : scene.clipPlane) ? true : false;\n        const useClipPlane2 = ((_b = nodeMaterial.clipPlane2) !== null && _b !== void 0 ? _b : scene.clipPlane2) ? true : false;\n        const useClipPlane3 = ((_c = nodeMaterial.clipPlane3) !== null && _c !== void 0 ? _c : scene.clipPlane3) ? true : false;\n        const useClipPlane4 = ((_d = nodeMaterial.clipPlane4) !== null && _d !== void 0 ? _d : scene.clipPlane4) ? true : false;\n        const useClipPlane5 = ((_e = nodeMaterial.clipPlane5) !== null && _e !== void 0 ? _e : scene.clipPlane5) ? true : false;\n        const useClipPlane6 = ((_f = nodeMaterial.clipPlane6) !== null && _f !== void 0 ? _f : scene.clipPlane6) ? true : false;\n        defines.setValue(\"CLIPPLANE\", useClipPlane1, true);\n        defines.setValue(\"CLIPPLANE2\", useClipPlane2, true);\n        defines.setValue(\"CLIPPLANE3\", useClipPlane3, true);\n        defines.setValue(\"CLIPPLANE4\", useClipPlane4, true);\n        defines.setValue(\"CLIPPLANE5\", useClipPlane5, true);\n        defines.setValue(\"CLIPPLANE6\", useClipPlane6, true);\n    }\n    bind(effect, nodeMaterial, mesh) {\n        if (!mesh) {\n            return;\n        }\n        const scene = mesh.getScene();\n        bindClipPlane(effect, nodeMaterial, scene);\n    }\n    _buildBlock(state) {\n        super._buildBlock(state);\n        const comments = `//${this.name}`;\n        if (state.target !== NodeMaterialBlockTargets.Fragment) {\n            // Vertex\n            const worldPos = this.worldPosition;\n            state._emitFunctionFromInclude(\"clipPlaneVertexDeclaration\", comments, {\n                replaceStrings: [{ search: /uniform vec4 vClipPlane\\d*;/g, replace: \"\" }],\n            });\n            state.compilationString += state._emitCodeFromInclude(\"clipPlaneVertex\", comments, {\n                replaceStrings: [{ search: /worldPos/g, replace: worldPos.associatedVariableName }],\n            });\n            state._emitUniformFromString(\"vClipPlane\", \"vec4\");\n            state._emitUniformFromString(\"vClipPlane2\", \"vec4\");\n            state._emitUniformFromString(\"vClipPlane3\", \"vec4\");\n            state._emitUniformFromString(\"vClipPlane4\", \"vec4\");\n            state._emitUniformFromString(\"vClipPlane5\", \"vec4\");\n            state._emitUniformFromString(\"vClipPlane6\", \"vec4\");\n            return;\n        }\n        // Fragment\n        state.sharedData.bindableBlocks.push(this);\n        state.sharedData.blocksWithDefines.push(this);\n        state._emitFunctionFromInclude(\"clipPlaneFragmentDeclaration\", comments);\n        state.compilationString += state._emitCodeFromInclude(\"clipPlaneFragment\", comments);\n        return this;\n    }\n}\nRegisterClass(\"BABYLON.ClipPlanesBlock\", ClipPlanesBlock);\n//# sourceMappingURL=clipPlanesBlock.js.map","import { __decorate } from \"../../../../tslib.es6.js\";\nimport { NodeMaterialBlock } from \"../../nodeMaterialBlock.js\";\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets.js\";\nimport { NodeMaterial } from \"../../nodeMaterial.js\";\nimport { RegisterClass } from \"../../../../Misc/typeStore.js\";\nimport { InputBlock } from \"../Input/inputBlock.js\";\nimport { NodeMaterialSystemValues } from \"../../Enums/nodeMaterialSystemValues.js\";\n\nimport \"../../../../Shaders/ShadersInclude/reflectionFunction.js\";\nimport { CubeTexture } from \"../../../Textures/cubeTexture.js\";\nimport { Texture } from \"../../../Textures/texture.js\";\nimport { EngineStore } from \"../../../../Engines/engineStore.js\";\nimport { editableInPropertyPage, PropertyTypeForEdition } from \"../../nodeMaterialDecorator.js\";\n/**\n * Base block used to read a reflection texture from a sampler\n */\nexport class ReflectionTextureBaseBlock extends NodeMaterialBlock {\n    /**\n     * Gets or sets the texture associated with the node\n     */\n    get texture() {\n        return this._texture;\n    }\n    set texture(texture) {\n        var _a;\n        if (this._texture === texture) {\n            return;\n        }\n        const scene = (_a = texture === null || texture === void 0 ? void 0 : texture.getScene()) !== null && _a !== void 0 ? _a : EngineStore.LastCreatedScene;\n        if (!texture && scene) {\n            scene.markAllMaterialsAsDirty(1, (mat) => {\n                return mat.hasTexture(this._texture);\n            });\n        }\n        this._texture = texture;\n        if (texture && scene) {\n            scene.markAllMaterialsAsDirty(1, (mat) => {\n                return mat.hasTexture(texture);\n            });\n        }\n    }\n    static _OnGenerateOnlyFragmentCodeChanged(block, _propertyName) {\n        const that = block;\n        return that._onGenerateOnlyFragmentCodeChanged();\n    }\n    _onGenerateOnlyFragmentCodeChanged() {\n        this._setTarget();\n        return true;\n    }\n    _setTarget() {\n        this._setInitialTarget(this.generateOnlyFragmentCode ? NodeMaterialBlockTargets.Fragment : NodeMaterialBlockTargets.VertexAndFragment);\n    }\n    /**\n     * Create a new ReflectionTextureBaseBlock\n     * @param name defines the block name\n     */\n    constructor(name) {\n        super(name, NodeMaterialBlockTargets.VertexAndFragment);\n        /** Indicates that no code should be generated in the vertex shader. Can be useful in some specific circumstances (like when doing ray marching for eg) */\n        this.generateOnlyFragmentCode = false;\n    }\n    /**\n     * Gets the current class name\n     * @returns the class name\n     */\n    getClassName() {\n        return \"ReflectionTextureBaseBlock\";\n    }\n    _getTexture() {\n        return this.texture;\n    }\n    autoConfigure(material) {\n        if (!this.position.isConnected) {\n            let positionInput = material.getInputBlockByPredicate((b) => b.isAttribute && b.name === \"position\");\n            if (!positionInput) {\n                positionInput = new InputBlock(\"position\");\n                positionInput.setAsAttribute();\n            }\n            positionInput.output.connectTo(this.position);\n        }\n        if (!this.world.isConnected) {\n            let worldInput = material.getInputBlockByPredicate((b) => b.systemValue === NodeMaterialSystemValues.World);\n            if (!worldInput) {\n                worldInput = new InputBlock(\"world\");\n                worldInput.setAsSystemValue(NodeMaterialSystemValues.World);\n            }\n            worldInput.output.connectTo(this.world);\n        }\n        if (this.view && !this.view.isConnected) {\n            let viewInput = material.getInputBlockByPredicate((b) => b.systemValue === NodeMaterialSystemValues.View);\n            if (!viewInput) {\n                viewInput = new InputBlock(\"view\");\n                viewInput.setAsSystemValue(NodeMaterialSystemValues.View);\n            }\n            viewInput.output.connectTo(this.view);\n        }\n    }\n    prepareDefines(mesh, nodeMaterial, defines) {\n        if (!defines._areTexturesDirty) {\n            return;\n        }\n        const texture = this._getTexture();\n        if (!texture || !texture.getTextureMatrix) {\n            return;\n        }\n        defines.setValue(this._define3DName, texture.isCube, true);\n        defines.setValue(this._defineLocalCubicName, texture.boundingBoxSize ? true : false, true);\n        defines.setValue(this._defineExplicitName, texture.coordinatesMode === 0, true);\n        defines.setValue(this._defineSkyboxName, texture.coordinatesMode === 5, true);\n        defines.setValue(this._defineCubicName, texture.coordinatesMode === 3 || texture.coordinatesMode === 6, true);\n        defines.setValue(\"INVERTCUBICMAP\", texture.coordinatesMode === 6, true);\n        defines.setValue(this._defineSphericalName, texture.coordinatesMode === 1, true);\n        defines.setValue(this._definePlanarName, texture.coordinatesMode === 2, true);\n        defines.setValue(this._defineProjectionName, texture.coordinatesMode === 4, true);\n        defines.setValue(this._defineEquirectangularName, texture.coordinatesMode === 7, true);\n        defines.setValue(this._defineEquirectangularFixedName, texture.coordinatesMode === 8, true);\n        defines.setValue(this._defineMirroredEquirectangularFixedName, texture.coordinatesMode === 9, true);\n    }\n    isReady() {\n        const texture = this._getTexture();\n        if (texture && !texture.isReadyOrNotBlocking()) {\n            return false;\n        }\n        return true;\n    }\n    bind(effect, nodeMaterial, mesh) {\n        const texture = this._getTexture();\n        if (!mesh || !texture) {\n            return;\n        }\n        effect.setMatrix(this._reflectionMatrixName, texture.getReflectionTextureMatrix());\n        if (texture.isCube) {\n            effect.setTexture(this._cubeSamplerName, texture);\n        }\n        else {\n            effect.setTexture(this._2DSamplerName, texture);\n        }\n        if (texture.boundingBoxSize) {\n            const cubeTexture = texture;\n            effect.setVector3(this._reflectionPositionName, cubeTexture.boundingBoxPosition);\n            effect.setVector3(this._reflectionSizeName, cubeTexture.boundingBoxSize);\n        }\n    }\n    /**\n     * Gets the code to inject in the vertex shader\n     * @param state current state of the node material building\n     * @returns the shader code\n     */\n    handleVertexSide(state) {\n        if (this.generateOnlyFragmentCode && state.target === NodeMaterialBlockTargets.Vertex) {\n            return \"\";\n        }\n        this._define3DName = state._getFreeDefineName(\"REFLECTIONMAP_3D\");\n        this._defineCubicName = state._getFreeDefineName(\"REFLECTIONMAP_CUBIC\");\n        this._defineSphericalName = state._getFreeDefineName(\"REFLECTIONMAP_SPHERICAL\");\n        this._definePlanarName = state._getFreeDefineName(\"REFLECTIONMAP_PLANAR\");\n        this._defineProjectionName = state._getFreeDefineName(\"REFLECTIONMAP_PROJECTION\");\n        this._defineExplicitName = state._getFreeDefineName(\"REFLECTIONMAP_EXPLICIT\");\n        this._defineEquirectangularName = state._getFreeDefineName(\"REFLECTIONMAP_EQUIRECTANGULAR\");\n        this._defineLocalCubicName = state._getFreeDefineName(\"USE_LOCAL_REFLECTIONMAP_CUBIC\");\n        this._defineMirroredEquirectangularFixedName = state._getFreeDefineName(\"REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED\");\n        this._defineEquirectangularFixedName = state._getFreeDefineName(\"REFLECTIONMAP_EQUIRECTANGULAR_FIXED\");\n        this._defineSkyboxName = state._getFreeDefineName(\"REFLECTIONMAP_SKYBOX\");\n        this._defineOppositeZ = state._getFreeDefineName(\"REFLECTIONMAP_OPPOSITEZ\");\n        this._reflectionMatrixName = state._getFreeVariableName(\"reflectionMatrix\");\n        state._emitUniformFromString(this._reflectionMatrixName, \"mat4\");\n        let code = \"\";\n        this._worldPositionNameInFragmentOnlyMode = state._getFreeVariableName(\"worldPosition\");\n        const worldPosVaryingName = this.generateOnlyFragmentCode ? this._worldPositionNameInFragmentOnlyMode : \"v_\" + this.worldPosition.associatedVariableName;\n        if (this.generateOnlyFragmentCode || state._emitVaryingFromString(worldPosVaryingName, \"vec4\")) {\n            code += `${this.generateOnlyFragmentCode ? \"vec4 \" : \"\"}${worldPosVaryingName} = ${this.worldPosition.associatedVariableName};\\r\\n`;\n        }\n        this._positionUVWName = state._getFreeVariableName(\"positionUVW\");\n        this._directionWName = state._getFreeVariableName(\"directionW\");\n        if (this.generateOnlyFragmentCode || state._emitVaryingFromString(this._positionUVWName, \"vec3\", this._defineSkyboxName)) {\n            code += `#ifdef ${this._defineSkyboxName}\\r\\n`;\n            code += `${this.generateOnlyFragmentCode ? \"vec3 \" : \"\"}${this._positionUVWName} = ${this.position.associatedVariableName}.xyz;\\r\\n`;\n            code += `#endif\\r\\n`;\n        }\n        if (this.generateOnlyFragmentCode ||\n            state._emitVaryingFromString(this._directionWName, \"vec3\", `defined(${this._defineEquirectangularFixedName}) || defined(${this._defineMirroredEquirectangularFixedName})`)) {\n            code += `#if defined(${this._defineEquirectangularFixedName}) || defined(${this._defineMirroredEquirectangularFixedName})\\r\\n`;\n            code += `${this.generateOnlyFragmentCode ? \"vec3 \" : \"\"}${this._directionWName} = normalize(vec3(${this.world.associatedVariableName} * vec4(${this.position.associatedVariableName}.xyz, 0.0)));\\r\\n`;\n            code += `#endif\\r\\n`;\n        }\n        return code;\n    }\n    /**\n     * Handles the inits for the fragment code path\n     * @param state node material build state\n     */\n    handleFragmentSideInits(state) {\n        state.sharedData.blockingBlocks.push(this);\n        state.sharedData.textureBlocks.push(this);\n        // Samplers\n        this._cubeSamplerName = state._getFreeVariableName(this.name + \"CubeSampler\");\n        state.samplers.push(this._cubeSamplerName);\n        this._2DSamplerName = state._getFreeVariableName(this.name + \"2DSampler\");\n        state.samplers.push(this._2DSamplerName);\n        state._samplerDeclaration += `#ifdef ${this._define3DName}\\r\\n`;\n        state._samplerDeclaration += `uniform samplerCube ${this._cubeSamplerName};\\r\\n`;\n        state._samplerDeclaration += `#else\\r\\n`;\n        state._samplerDeclaration += `uniform sampler2D ${this._2DSamplerName};\\r\\n`;\n        state._samplerDeclaration += `#endif\\r\\n`;\n        // Fragment\n        state.sharedData.blocksWithDefines.push(this);\n        state.sharedData.bindableBlocks.push(this);\n        const comments = `//${this.name}`;\n        state._emitFunction(\"ReciprocalPI\", \"#define RECIPROCAL_PI2 0.15915494\", \"\");\n        state._emitFunctionFromInclude(\"helperFunctions\", comments);\n        state._emitFunctionFromInclude(\"reflectionFunction\", comments, {\n            replaceStrings: [{ search: /vec3 computeReflectionCoords/g, replace: \"void DUMMYFUNC\" }],\n        });\n        this._reflectionColorName = state._getFreeVariableName(\"reflectionColor\");\n        this._reflectionVectorName = state._getFreeVariableName(\"reflectionUVW\");\n        this._reflectionCoordsName = state._getFreeVariableName(\"reflectionCoords\");\n        this._reflectionPositionName = state._getFreeVariableName(\"vReflectionPosition\");\n        state._emitUniformFromString(this._reflectionPositionName, \"vec3\");\n        this._reflectionSizeName = state._getFreeVariableName(\"vReflectionPosition\");\n        state._emitUniformFromString(this._reflectionSizeName, \"vec3\");\n    }\n    /**\n     * Generates the reflection coords code for the fragment code path\n     * @param worldNormalVarName name of the world normal variable\n     * @param worldPos name of the world position variable. If not provided, will use the world position connected to this block\n     * @param onlyReflectionVector if true, generates code only for the reflection vector computation, not for the reflection coordinates\n     * @param doNotEmitInvertZ if true, does not emit the invertZ code\n     * @returns the shader code\n     */\n    handleFragmentSideCodeReflectionCoords(worldNormalVarName, worldPos, onlyReflectionVector = false, doNotEmitInvertZ = false) {\n        if (!worldPos) {\n            worldPos = this.generateOnlyFragmentCode ? this._worldPositionNameInFragmentOnlyMode : `v_${this.worldPosition.associatedVariableName}`;\n        }\n        const reflectionMatrix = this._reflectionMatrixName;\n        const direction = `normalize(${this._directionWName})`;\n        const positionUVW = `${this._positionUVWName}`;\n        const vEyePosition = `${this.cameraPosition.associatedVariableName}`;\n        const view = `${this.view.associatedVariableName}`;\n        worldNormalVarName += \".xyz\";\n        let code = `\r\n            #ifdef ${this._defineMirroredEquirectangularFixedName}\r\n                vec3 ${this._reflectionVectorName} = computeMirroredFixedEquirectangularCoords(${worldPos}, ${worldNormalVarName}, ${direction});\r\n            #endif\r\n\r\n            #ifdef ${this._defineEquirectangularFixedName}\r\n                vec3 ${this._reflectionVectorName} = computeFixedEquirectangularCoords(${worldPos}, ${worldNormalVarName}, ${direction});\r\n            #endif\r\n\r\n            #ifdef ${this._defineEquirectangularName}\r\n                vec3 ${this._reflectionVectorName} = computeEquirectangularCoords(${worldPos}, ${worldNormalVarName}, ${vEyePosition}.xyz, ${reflectionMatrix});\r\n            #endif\r\n\r\n            #ifdef ${this._defineSphericalName}\r\n                vec3 ${this._reflectionVectorName} = computeSphericalCoords(${worldPos}, ${worldNormalVarName}, ${view}, ${reflectionMatrix});\r\n            #endif\r\n\r\n            #ifdef ${this._definePlanarName}\r\n                vec3 ${this._reflectionVectorName} = computePlanarCoords(${worldPos}, ${worldNormalVarName}, ${vEyePosition}.xyz, ${reflectionMatrix});\r\n            #endif\r\n\r\n            #ifdef ${this._defineCubicName}\r\n                #ifdef ${this._defineLocalCubicName}\r\n                    vec3 ${this._reflectionVectorName} = computeCubicLocalCoords(${worldPos}, ${worldNormalVarName}, ${vEyePosition}.xyz, ${reflectionMatrix}, ${this._reflectionSizeName}, ${this._reflectionPositionName});\r\n                #else\r\n                vec3 ${this._reflectionVectorName} = computeCubicCoords(${worldPos}, ${worldNormalVarName}, ${vEyePosition}.xyz, ${reflectionMatrix});\r\n                #endif\r\n            #endif\r\n\r\n            #ifdef ${this._defineProjectionName}\r\n                vec3 ${this._reflectionVectorName} = computeProjectionCoords(${worldPos}, ${view}, ${reflectionMatrix});\r\n            #endif\r\n\r\n            #ifdef ${this._defineSkyboxName}\r\n                vec3 ${this._reflectionVectorName} = computeSkyBoxCoords(${positionUVW}, ${reflectionMatrix});\r\n            #endif\r\n\r\n            #ifdef ${this._defineExplicitName}\r\n                vec3 ${this._reflectionVectorName} = vec3(0, 0, 0);\r\n            #endif\\r\\n`;\n        if (!doNotEmitInvertZ) {\n            code += `#ifdef ${this._defineOppositeZ}\r\n                ${this._reflectionVectorName}.z *= -1.0;\r\n            #endif\\r\\n`;\n        }\n        if (!onlyReflectionVector) {\n            code += `\r\n                #ifdef ${this._define3DName}\r\n                    vec3 ${this._reflectionCoordsName} = ${this._reflectionVectorName};\r\n                #else\r\n                    vec2 ${this._reflectionCoordsName} = ${this._reflectionVectorName}.xy;\r\n                    #ifdef ${this._defineProjectionName}\r\n                        ${this._reflectionCoordsName} /= ${this._reflectionVectorName}.z;\r\n                    #endif\r\n                    ${this._reflectionCoordsName}.y = 1.0 - ${this._reflectionCoordsName}.y;\r\n                #endif\\r\\n`;\n        }\n        return code;\n    }\n    /**\n     * Generates the reflection color code for the fragment code path\n     * @param lodVarName name of the lod variable\n     * @param swizzleLookupTexture swizzle to use for the final color variable\n     * @returns the shader code\n     */\n    handleFragmentSideCodeReflectionColor(lodVarName, swizzleLookupTexture = \".rgb\") {\n        const colorType = \"vec\" + (swizzleLookupTexture.length === 0 ? \"4\" : swizzleLookupTexture.length - 1);\n        let code = `${colorType} ${this._reflectionColorName};\r\n            #ifdef ${this._define3DName}\\r\\n`;\n        if (lodVarName) {\n            code += `${this._reflectionColorName} = textureCubeLodEXT(${this._cubeSamplerName}, ${this._reflectionVectorName}, ${lodVarName})${swizzleLookupTexture};\\r\\n`;\n        }\n        else {\n            code += `${this._reflectionColorName} = textureCube(${this._cubeSamplerName}, ${this._reflectionVectorName})${swizzleLookupTexture};\\r\\n`;\n        }\n        code += `\r\n            #else\\r\\n`;\n        if (lodVarName) {\n            code += `${this._reflectionColorName} = texture2DLodEXT(${this._2DSamplerName}, ${this._reflectionCoordsName}, ${lodVarName})${swizzleLookupTexture};\\r\\n`;\n        }\n        else {\n            code += `${this._reflectionColorName} = texture2D(${this._2DSamplerName}, ${this._reflectionCoordsName})${swizzleLookupTexture};\\r\\n`;\n        }\n        code += `#endif\\r\\n`;\n        return code;\n    }\n    /**\n     * Generates the code corresponding to the connected output points\n     * @param state node material build state\n     * @param varName name of the variable to output\n     * @returns the shader code\n     */\n    writeOutputs(state, varName) {\n        let code = \"\";\n        if (state.target === NodeMaterialBlockTargets.Fragment) {\n            for (const output of this._outputs) {\n                if (output.hasEndpoints) {\n                    code += `${this._declareOutput(output, state)} = ${varName}.${output.name};\\r\\n`;\n                }\n            }\n        }\n        return code;\n    }\n    _buildBlock(state) {\n        super._buildBlock(state);\n        return this;\n    }\n    _dumpPropertiesCode() {\n        let codeString = super._dumpPropertiesCode();\n        if (!this.texture) {\n            return codeString;\n        }\n        if (this.texture.isCube) {\n            const forcedExtension = this.texture.forcedExtension;\n            codeString += `${this._codeVariableName}.texture = new BABYLON.CubeTexture(\"${this.texture.name}\", undefined, undefined, ${this.texture.noMipmap}, null, undefined, undefined, undefined, ${this.texture._prefiltered}, ${forcedExtension ? '\"' + forcedExtension + '\"' : \"null\"});\\r\\n`;\n        }\n        else {\n            codeString += `${this._codeVariableName}.texture = new BABYLON.Texture(\"${this.texture.name}\", null);\\r\\n`;\n        }\n        codeString += `${this._codeVariableName}.texture.coordinatesMode = ${this.texture.coordinatesMode};\\r\\n`;\n        return codeString;\n    }\n    serialize() {\n        const serializationObject = super.serialize();\n        if (this.texture && !this.texture.isRenderTarget) {\n            serializationObject.texture = this.texture.serialize();\n        }\n        serializationObject.generateOnlyFragmentCode = this.generateOnlyFragmentCode;\n        return serializationObject;\n    }\n    _deserialize(serializationObject, scene, rootUrl) {\n        super._deserialize(serializationObject, scene, rootUrl);\n        if (serializationObject.texture && !NodeMaterial.IgnoreTexturesAtLoadTime) {\n            rootUrl = serializationObject.texture.url.indexOf(\"data:\") === 0 ? \"\" : rootUrl;\n            if (serializationObject.texture.isCube) {\n                this.texture = CubeTexture.Parse(serializationObject.texture, scene, rootUrl);\n            }\n            else {\n                this.texture = Texture.Parse(serializationObject.texture, scene, rootUrl);\n            }\n        }\n        this.generateOnlyFragmentCode = serializationObject.generateOnlyFragmentCode;\n        this._setTarget();\n    }\n}\n__decorate([\n    editableInPropertyPage(\"Generate only fragment code\", PropertyTypeForEdition.Boolean, \"ADVANCED\", {\n        notifiers: { rebuild: true, update: true, onValidation: ReflectionTextureBaseBlock._OnGenerateOnlyFragmentCodeChanged },\n    })\n], ReflectionTextureBaseBlock.prototype, \"generateOnlyFragmentCode\", void 0);\nRegisterClass(\"BABYLON.ReflectionTextureBaseBlock\", ReflectionTextureBaseBlock);\n//# sourceMappingURL=reflectionTextureBaseBlock.js.map","import { NodeMaterialBlock } from \"../../nodeMaterialBlock.js\";\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes.js\";\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets.js\";\nimport { NodeMaterialConnectionPointDirection } from \"../../nodeMaterialBlockConnectionPoint.js\";\nimport { RegisterClass } from \"../../../../Misc/typeStore.js\";\nimport { NodeMaterialConnectionPointCustomObject } from \"../../nodeMaterialConnectionPointCustomObject.js\";\nimport { NodeMaterialSystemValues } from \"../../Enums/nodeMaterialSystemValues.js\";\nimport { InputBlock } from \"../Input/inputBlock.js\";\n/**\n * Block used to implement TBN matrix\n */\nexport class TBNBlock extends NodeMaterialBlock {\n    /**\n     * Create a new TBNBlock\n     * @param name defines the block name\n     */\n    constructor(name) {\n        super(name, NodeMaterialBlockTargets.Fragment, true);\n        this.registerInput(\"normal\", NodeMaterialBlockConnectionPointTypes.AutoDetect, false);\n        this.normal.addExcludedConnectionPointFromAllowedTypes(NodeMaterialBlockConnectionPointTypes.Color4 | NodeMaterialBlockConnectionPointTypes.Vector4 | NodeMaterialBlockConnectionPointTypes.Vector3);\n        this.registerInput(\"tangent\", NodeMaterialBlockConnectionPointTypes.Vector4, false);\n        this.registerInput(\"world\", NodeMaterialBlockConnectionPointTypes.Matrix, false);\n        this.registerOutput(\"TBN\", NodeMaterialBlockConnectionPointTypes.Object, NodeMaterialBlockTargets.Fragment, new NodeMaterialConnectionPointCustomObject(\"TBN\", this, NodeMaterialConnectionPointDirection.Output, TBNBlock, \"TBNBlock\"));\n        this.registerOutput(\"row0\", NodeMaterialBlockConnectionPointTypes.Vector3, NodeMaterialBlockTargets.Fragment);\n        this.registerOutput(\"row1\", NodeMaterialBlockConnectionPointTypes.Vector3, NodeMaterialBlockTargets.Fragment);\n        this.registerOutput(\"row2\", NodeMaterialBlockConnectionPointTypes.Vector3, NodeMaterialBlockTargets.Fragment);\n    }\n    /**\n     * Gets the current class name\n     * @returns the class name\n     */\n    getClassName() {\n        return \"TBNBlock\";\n    }\n    /**\n     * Initialize the block and prepare the context for build\n     * @param state defines the state that will be used for the build\n     */\n    initialize(state) {\n        state._excludeVariableName(\"tbnNormal\");\n        state._excludeVariableName(\"tbnTangent\");\n        state._excludeVariableName(\"tbnBitangent\");\n        state._excludeVariableName(\"TBN\");\n    }\n    /**\n     * Gets the normal input component\n     */\n    get normal() {\n        return this._inputs[0];\n    }\n    /**\n     * Gets the tangent input component\n     */\n    get tangent() {\n        return this._inputs[1];\n    }\n    /**\n     * Gets the world matrix input component\n     */\n    get world() {\n        return this._inputs[2];\n    }\n    /**\n     * Gets the TBN output component\n     */\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    get TBN() {\n        return this._outputs[0];\n    }\n    /**\n     * Gets the row0 of the output matrix\n     */\n    get row0() {\n        return this._outputs[1];\n    }\n    /**\n     * Gets the row1 of the output matrix\n     */\n    get row1() {\n        return this._outputs[2];\n    }\n    /**\n     * Gets the row2 of the output matrix\n     */\n    get row2() {\n        return this._outputs[3];\n    }\n    get target() {\n        return NodeMaterialBlockTargets.Fragment;\n    }\n    set target(value) { }\n    autoConfigure(material) {\n        if (!this.world.isConnected) {\n            let worldInput = material.getInputBlockByPredicate((b) => b.isSystemValue && b.systemValue === NodeMaterialSystemValues.World);\n            if (!worldInput) {\n                worldInput = new InputBlock(\"world\");\n                worldInput.setAsSystemValue(NodeMaterialSystemValues.World);\n            }\n            worldInput.output.connectTo(this.world);\n        }\n        if (!this.normal.isConnected) {\n            let normalInput = material.getInputBlockByPredicate((b) => b.isAttribute && b.name === \"normal\");\n            if (!normalInput) {\n                normalInput = new InputBlock(\"normal\");\n                normalInput.setAsAttribute(\"normal\");\n            }\n            normalInput.output.connectTo(this.normal);\n        }\n        if (!this.tangent.isConnected) {\n            let tangentInput = material.getInputBlockByPredicate((b) => b.isAttribute && b.name === \"tangent\" && b.type === NodeMaterialBlockConnectionPointTypes.Vector4);\n            if (!tangentInput) {\n                tangentInput = new InputBlock(\"tangent\");\n                tangentInput.setAsAttribute(\"tangent\");\n            }\n            tangentInput.output.connectTo(this.tangent);\n        }\n    }\n    prepareDefines(mesh, nodeMaterial, defines) {\n        var _a, _b, _c, _d;\n        const normal = this.normal;\n        const tangent = this.tangent;\n        let normalAvailable = normal.isConnected;\n        if (((_a = normal.connectInputBlock) === null || _a === void 0 ? void 0 : _a.isAttribute) && !mesh.isVerticesDataPresent((_b = normal.connectInputBlock) === null || _b === void 0 ? void 0 : _b.name)) {\n            normalAvailable = false;\n        }\n        let tangentAvailable = tangent.isConnected;\n        if (((_c = tangent.connectInputBlock) === null || _c === void 0 ? void 0 : _c.isAttribute) && !mesh.isVerticesDataPresent((_d = tangent.connectInputBlock) === null || _d === void 0 ? void 0 : _d.name)) {\n            tangentAvailable = false;\n        }\n        const useTBNBlock = normalAvailable && tangentAvailable;\n        defines.setValue(\"TBNBLOCK\", useTBNBlock, true);\n    }\n    _buildBlock(state) {\n        super._buildBlock(state);\n        const normal = this.normal;\n        const tangent = this.tangent;\n        const world = this.world;\n        const TBN = this.TBN;\n        const row0 = this.row0;\n        const row1 = this.row1;\n        const row2 = this.row2;\n        // Fragment\n        if (state.target === NodeMaterialBlockTargets.Fragment) {\n            state.compilationString += `\r\n                // ${this.name}\r\n                vec3 tbnNormal = normalize(${normal.associatedVariableName}).xyz;\r\n                vec3 tbnTangent = normalize(${tangent.associatedVariableName}.xyz);\r\n                vec3 tbnBitangent = cross(tbnNormal, tbnTangent) * ${tangent.associatedVariableName}.w;\r\n                mat3 ${TBN.associatedVariableName} = mat3(${world.associatedVariableName}) * mat3(tbnTangent, tbnBitangent, tbnNormal);\r\n            `;\n            if (row0.hasEndpoints) {\n                state.compilationString +=\n                    this._declareOutput(row0, state) +\n                        ` = vec3(${TBN.associatedVariableName}[0][0], ${TBN.associatedVariableName}[0][1], ${TBN.associatedVariableName}[0][2]);\\r\\n`;\n            }\n            if (row1.hasEndpoints) {\n                state.compilationString +=\n                    this._declareOutput(row1, state) + ` = vec3(${TBN.associatedVariableName}[1[0], ${TBN.associatedVariableName}[1][1], ${TBN.associatedVariableName}[1][2]);\\r\\n`;\n            }\n            if (row2.hasEndpoints) {\n                state.compilationString +=\n                    this._declareOutput(row2, state) +\n                        ` = vec3(${TBN.associatedVariableName}[2][0], ${TBN.associatedVariableName}[2][1], ${TBN.associatedVariableName}[2][2]);\\r\\n`;\n            }\n            state.sharedData.blocksWithDefines.push(this);\n        }\n        return this;\n    }\n}\nRegisterClass(\"BABYLON.TBNBlock\", TBNBlock);\n//# sourceMappingURL=TBNBlock.js.map","import { __decorate } from \"../../../../tslib.es6.js\";\nimport { NodeMaterialBlock } from \"../../nodeMaterialBlock.js\";\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes.js\";\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets.js\";\nimport { RegisterClass } from \"../../../../Misc/typeStore.js\";\nimport { editableInPropertyPage, PropertyTypeForEdition } from \"../../nodeMaterialDecorator.js\";\nimport { MaterialHelper } from \"../../../materialHelper.js\";\n/**\n * Block used to output the final color\n */\nexport class FragmentOutputBlock extends NodeMaterialBlock {\n    /**\n     * Create a new FragmentOutputBlock\n     * @param name defines the block name\n     */\n    constructor(name) {\n        super(name, NodeMaterialBlockTargets.Fragment, true);\n        /** Gets or sets a boolean indicating if content needs to be converted to gamma space */\n        this.convertToGammaSpace = false;\n        /** Gets or sets a boolean indicating if content needs to be converted to linear space */\n        this.convertToLinearSpace = false;\n        /** Gets or sets a boolean indicating if logarithmic depth should be used */\n        this.useLogarithmicDepth = false;\n        this.registerInput(\"rgba\", NodeMaterialBlockConnectionPointTypes.Color4, true);\n        this.registerInput(\"rgb\", NodeMaterialBlockConnectionPointTypes.AutoDetect, true);\n        this.registerInput(\"a\", NodeMaterialBlockConnectionPointTypes.Float, true);\n        this.rgb.addExcludedConnectionPointFromAllowedTypes(NodeMaterialBlockConnectionPointTypes.Color3 | NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Float);\n    }\n    /**\n     * Gets the current class name\n     * @returns the class name\n     */\n    getClassName() {\n        return \"FragmentOutputBlock\";\n    }\n    /**\n     * Initialize the block and prepare the context for build\n     * @param state defines the state that will be used for the build\n     */\n    initialize(state) {\n        state._excludeVariableName(\"logarithmicDepthConstant\");\n        state._excludeVariableName(\"vFragmentDepth\");\n    }\n    /**\n     * Gets the rgba input component\n     */\n    get rgba() {\n        return this._inputs[0];\n    }\n    /**\n     * Gets the rgb input component\n     */\n    get rgb() {\n        return this._inputs[1];\n    }\n    /**\n     * Gets the a input component\n     */\n    get a() {\n        return this._inputs[2];\n    }\n    prepareDefines(mesh, nodeMaterial, defines) {\n        defines.setValue(this._linearDefineName, this.convertToLinearSpace, true);\n        defines.setValue(this._gammaDefineName, this.convertToGammaSpace, true);\n    }\n    bind(effect, nodeMaterial, mesh) {\n        if (this.useLogarithmicDepth && mesh) {\n            MaterialHelper.BindLogDepth(undefined, effect, mesh.getScene());\n        }\n    }\n    _buildBlock(state) {\n        super._buildBlock(state);\n        const rgba = this.rgba;\n        const rgb = this.rgb;\n        const a = this.a;\n        state.sharedData.hints.needAlphaBlending = rgba.isConnected || a.isConnected;\n        state.sharedData.blocksWithDefines.push(this);\n        if (this.useLogarithmicDepth) {\n            state._emitUniformFromString(\"logarithmicDepthConstant\", \"float\");\n            state._emitVaryingFromString(\"vFragmentDepth\", \"float\");\n            state.sharedData.bindableBlocks.push(this);\n        }\n        this._linearDefineName = state._getFreeDefineName(\"CONVERTTOLINEAR\");\n        this._gammaDefineName = state._getFreeDefineName(\"CONVERTTOGAMMA\");\n        const comments = `//${this.name}`;\n        state._emitFunctionFromInclude(\"helperFunctions\", comments);\n        if (rgba.connectedPoint) {\n            if (a.isConnected) {\n                state.compilationString += `gl_FragColor = vec4(${rgba.associatedVariableName}.rgb, ${a.associatedVariableName});\\r\\n`;\n            }\n            else {\n                state.compilationString += `gl_FragColor = ${rgba.associatedVariableName};\\r\\n`;\n            }\n        }\n        else if (rgb.connectedPoint) {\n            let aValue = \"1.0\";\n            if (a.connectedPoint) {\n                aValue = a.associatedVariableName;\n            }\n            if (rgb.connectedPoint.type === NodeMaterialBlockConnectionPointTypes.Float) {\n                state.compilationString += `gl_FragColor = vec4(${rgb.associatedVariableName}, ${rgb.associatedVariableName}, ${rgb.associatedVariableName}, ${aValue});\\r\\n`;\n            }\n            else {\n                state.compilationString += `gl_FragColor = vec4(${rgb.associatedVariableName}, ${aValue});\\r\\n`;\n            }\n        }\n        else {\n            state.sharedData.checks.notConnectedNonOptionalInputs.push(rgba);\n        }\n        state.compilationString += `#ifdef ${this._linearDefineName}\\r\\n`;\n        state.compilationString += `gl_FragColor = toLinearSpace(gl_FragColor);\\r\\n`;\n        state.compilationString += `#endif\\r\\n`;\n        state.compilationString += `#ifdef ${this._gammaDefineName}\\r\\n`;\n        state.compilationString += `gl_FragColor = toGammaSpace(gl_FragColor);\\r\\n`;\n        state.compilationString += `#endif\\r\\n`;\n        if (this.useLogarithmicDepth) {\n            state.compilationString += `gl_FragDepthEXT = log2(vFragmentDepth) * logarithmicDepthConstant * 0.5;\\r\\n`;\n        }\n        return this;\n    }\n    _dumpPropertiesCode() {\n        let codeString = super._dumpPropertiesCode();\n        codeString += `${this._codeVariableName}.convertToGammaSpace = ${this.convertToGammaSpace};\\r\\n`;\n        codeString += `${this._codeVariableName}.convertToLinearSpace = ${this.convertToLinearSpace};\\r\\n`;\n        codeString += `${this._codeVariableName}.useLogarithmicDepth = ${this.useLogarithmicDepth};\\r\\n`;\n        return codeString;\n    }\n    serialize() {\n        const serializationObject = super.serialize();\n        serializationObject.convertToGammaSpace = this.convertToGammaSpace;\n        serializationObject.convertToLinearSpace = this.convertToLinearSpace;\n        serializationObject.useLogarithmicDepth = this.useLogarithmicDepth;\n        return serializationObject;\n    }\n    _deserialize(serializationObject, scene, rootUrl) {\n        var _a;\n        super._deserialize(serializationObject, scene, rootUrl);\n        this.convertToGammaSpace = serializationObject.convertToGammaSpace;\n        this.convertToLinearSpace = serializationObject.convertToLinearSpace;\n        this.useLogarithmicDepth = (_a = serializationObject.useLogarithmicDepth) !== null && _a !== void 0 ? _a : false;\n    }\n}\n__decorate([\n    editableInPropertyPage(\"Convert to gamma space\", PropertyTypeForEdition.Boolean, \"PROPERTIES\", { notifiers: { update: true } })\n], FragmentOutputBlock.prototype, \"convertToGammaSpace\", void 0);\n__decorate([\n    editableInPropertyPage(\"Convert to linear space\", PropertyTypeForEdition.Boolean, \"PROPERTIES\", { notifiers: { update: true } })\n], FragmentOutputBlock.prototype, \"convertToLinearSpace\", void 0);\n__decorate([\n    editableInPropertyPage(\"Use logarithmic depth\", PropertyTypeForEdition.Boolean, \"PROPERTIES\")\n], FragmentOutputBlock.prototype, \"useLogarithmicDepth\", void 0);\nRegisterClass(\"BABYLON.FragmentOutputBlock\", FragmentOutputBlock);\n//# sourceMappingURL=fragmentOutputBlock.js.map","import { __decorate } from \"../../../../tslib.es6.js\";\nimport { NodeMaterialBlock } from \"../../nodeMaterialBlock.js\";\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes.js\";\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets.js\";\nimport { RegisterClass } from \"../../../../Misc/typeStore.js\";\nimport { editableInPropertyPage, PropertyTypeForEdition } from \"../../nodeMaterialDecorator.js\";\nimport \"../../../../Shaders/ShadersInclude/helperFunctions.js\";\nimport \"../../../../Shaders/ShadersInclude/imageProcessingDeclaration.js\";\nimport \"../../../../Shaders/ShadersInclude/imageProcessingFunctions.js\";\n/**\n * Block used to add image processing support to fragment shader\n */\nexport class ImageProcessingBlock extends NodeMaterialBlock {\n    /**\n     * Create a new ImageProcessingBlock\n     * @param name defines the block name\n     */\n    constructor(name) {\n        super(name, NodeMaterialBlockTargets.Fragment);\n        /**\n         * Defines if the input should be converted to linear space (default: true)\n         */\n        this.convertInputToLinearSpace = true;\n        this.registerInput(\"color\", NodeMaterialBlockConnectionPointTypes.AutoDetect);\n        this.registerOutput(\"output\", NodeMaterialBlockConnectionPointTypes.Color4);\n        this.registerOutput(\"rgb\", NodeMaterialBlockConnectionPointTypes.Color3);\n        this._inputs[0].addExcludedConnectionPointFromAllowedTypes(NodeMaterialBlockConnectionPointTypes.Color3 |\n            NodeMaterialBlockConnectionPointTypes.Color4 |\n            NodeMaterialBlockConnectionPointTypes.Vector3 |\n            NodeMaterialBlockConnectionPointTypes.Vector4);\n    }\n    /**\n     * Gets the current class name\n     * @returns the class name\n     */\n    getClassName() {\n        return \"ImageProcessingBlock\";\n    }\n    /**\n     * Gets the color input component\n     */\n    get color() {\n        return this._inputs[0];\n    }\n    /**\n     * Gets the output component\n     */\n    get output() {\n        return this._outputs[0];\n    }\n    /**\n     * Gets the rgb component\n     */\n    get rgb() {\n        return this._outputs[1];\n    }\n    /**\n     * Initialize the block and prepare the context for build\n     * @param state defines the state that will be used for the build\n     */\n    initialize(state) {\n        state._excludeVariableName(\"exposureLinear\");\n        state._excludeVariableName(\"contrast\");\n        state._excludeVariableName(\"vInverseScreenSize\");\n        state._excludeVariableName(\"vignetteSettings1\");\n        state._excludeVariableName(\"vignetteSettings2\");\n        state._excludeVariableName(\"vCameraColorCurveNegative\");\n        state._excludeVariableName(\"vCameraColorCurveNeutral\");\n        state._excludeVariableName(\"vCameraColorCurvePositive\");\n        state._excludeVariableName(\"txColorTransform\");\n        state._excludeVariableName(\"colorTransformSettings\");\n        state._excludeVariableName(\"ditherIntensity\");\n    }\n    isReady(mesh, nodeMaterial, defines) {\n        if (defines._areImageProcessingDirty && nodeMaterial.imageProcessingConfiguration) {\n            if (!nodeMaterial.imageProcessingConfiguration.isReady()) {\n                return false;\n            }\n        }\n        return true;\n    }\n    prepareDefines(mesh, nodeMaterial, defines) {\n        if (defines._areImageProcessingDirty && nodeMaterial.imageProcessingConfiguration) {\n            nodeMaterial.imageProcessingConfiguration.prepareDefines(defines);\n        }\n    }\n    bind(effect, nodeMaterial, mesh) {\n        if (!mesh) {\n            return;\n        }\n        if (!nodeMaterial.imageProcessingConfiguration) {\n            return;\n        }\n        nodeMaterial.imageProcessingConfiguration.bind(effect);\n    }\n    _buildBlock(state) {\n        var _a;\n        super._buildBlock(state);\n        // Register for defines\n        state.sharedData.blocksWithDefines.push(this);\n        // Register for blocking\n        state.sharedData.blockingBlocks.push(this);\n        // Register for binding\n        state.sharedData.bindableBlocks.push(this);\n        // Uniforms\n        state.uniforms.push(\"exposureLinear\");\n        state.uniforms.push(\"contrast\");\n        state.uniforms.push(\"vInverseScreenSize\");\n        state.uniforms.push(\"vignetteSettings1\");\n        state.uniforms.push(\"vignetteSettings2\");\n        state.uniforms.push(\"vCameraColorCurveNegative\");\n        state.uniforms.push(\"vCameraColorCurveNeutral\");\n        state.uniforms.push(\"vCameraColorCurvePositive\");\n        state.uniforms.push(\"txColorTransform\");\n        state.uniforms.push(\"colorTransformSettings\");\n        state.uniforms.push(\"ditherIntensity\");\n        // Emit code\n        const color = this.color;\n        const output = this._outputs[0];\n        const comments = `//${this.name}`;\n        state._emitFunctionFromInclude(\"helperFunctions\", comments);\n        state._emitFunctionFromInclude(\"imageProcessingDeclaration\", comments);\n        state._emitFunctionFromInclude(\"imageProcessingFunctions\", comments);\n        if ((_a = color.connectedPoint) === null || _a === void 0 ? void 0 : _a.isConnected) {\n            if (color.connectedPoint.type === NodeMaterialBlockConnectionPointTypes.Color4 || color.connectedPoint.type === NodeMaterialBlockConnectionPointTypes.Vector4) {\n                state.compilationString += `${this._declareOutput(output, state)} = ${color.associatedVariableName};\\r\\n`;\n            }\n            else {\n                state.compilationString += `${this._declareOutput(output, state)} = vec4(${color.associatedVariableName}, 1.0);\\r\\n`;\n            }\n            state.compilationString += `#ifdef IMAGEPROCESSINGPOSTPROCESS\\r\\n`;\n            if (this.convertInputToLinearSpace) {\n                state.compilationString += `${output.associatedVariableName}.rgb = toLinearSpace(${color.associatedVariableName}.rgb);\\r\\n`;\n            }\n            state.compilationString += `#else\\r\\n`;\n            state.compilationString += `#ifdef IMAGEPROCESSING\\r\\n`;\n            if (this.convertInputToLinearSpace) {\n                state.compilationString += `${output.associatedVariableName}.rgb = toLinearSpace(${color.associatedVariableName}.rgb);\\r\\n`;\n            }\n            state.compilationString += `${output.associatedVariableName} = applyImageProcessing(${output.associatedVariableName});\\r\\n`;\n            state.compilationString += `#endif\\r\\n`;\n            state.compilationString += `#endif\\r\\n`;\n            if (this.rgb.hasEndpoints) {\n                state.compilationString += this._declareOutput(this.rgb, state) + ` = ${this.output.associatedVariableName}.xyz;\\r\\n`;\n            }\n        }\n        return this;\n    }\n    _dumpPropertiesCode() {\n        let codeString = super._dumpPropertiesCode();\n        codeString += `${this._codeVariableName}.convertInputToLinearSpace = ${this.convertInputToLinearSpace};\\r\\n`;\n        return codeString;\n    }\n    serialize() {\n        const serializationObject = super.serialize();\n        serializationObject.convertInputToLinearSpace = this.convertInputToLinearSpace;\n        return serializationObject;\n    }\n    _deserialize(serializationObject, scene, rootUrl) {\n        var _a;\n        super._deserialize(serializationObject, scene, rootUrl);\n        this.convertInputToLinearSpace = (_a = serializationObject.convertInputToLinearSpace) !== null && _a !== void 0 ? _a : true;\n    }\n}\n__decorate([\n    editableInPropertyPage(\"Convert input to linear space\", PropertyTypeForEdition.Boolean, \"ADVANCED\")\n], ImageProcessingBlock.prototype, \"convertInputToLinearSpace\", void 0);\nRegisterClass(\"BABYLON.ImageProcessingBlock\", ImageProcessingBlock);\n//# sourceMappingURL=imageProcessingBlock.js.map","import { __decorate } from \"../../../../tslib.es6.js\";\nimport { NodeMaterialBlock } from \"../../nodeMaterialBlock.js\";\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes.js\";\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets.js\";\nimport { NodeMaterialConnectionPointDirection } from \"../../nodeMaterialBlockConnectionPoint.js\";\nimport { RegisterClass } from \"../../../../Misc/typeStore.js\";\nimport { InputBlock } from \"../Input/inputBlock.js\";\nimport { editableInPropertyPage, PropertyTypeForEdition } from \"../../nodeMaterialDecorator.js\";\nimport { NodeMaterialConnectionPointCustomObject } from \"../../nodeMaterialConnectionPointCustomObject.js\";\nimport { TBNBlock } from \"./TBNBlock.js\";\nimport \"../../../../Shaders/ShadersInclude/bumpFragmentMainFunctions.js\";\nimport \"../../../../Shaders/ShadersInclude/bumpFragmentFunctions.js\";\nimport \"../../../../Shaders/ShadersInclude/bumpFragment.js\";\n/**\n * Block used to perturb normals based on a normal map\n */\nexport class PerturbNormalBlock extends NodeMaterialBlock {\n    /**\n     * Create a new PerturbNormalBlock\n     * @param name defines the block name\n     */\n    constructor(name) {\n        super(name, NodeMaterialBlockTargets.Fragment);\n        this._tangentSpaceParameterName = \"\";\n        this._tangentCorrectionFactorName = \"\";\n        this._worldMatrixName = \"\";\n        /** Gets or sets a boolean indicating that normal should be inverted on X axis */\n        this.invertX = false;\n        /** Gets or sets a boolean indicating that normal should be inverted on Y axis */\n        this.invertY = false;\n        /** Gets or sets a boolean indicating that parallax occlusion should be enabled */\n        this.useParallaxOcclusion = false;\n        /** Gets or sets a boolean indicating that sampling mode is in Object space */\n        this.useObjectSpaceNormalMap = false;\n        this._isUnique = true;\n        // Vertex\n        this.registerInput(\"worldPosition\", NodeMaterialBlockConnectionPointTypes.Vector4, false);\n        this.registerInput(\"worldNormal\", NodeMaterialBlockConnectionPointTypes.Vector4, false);\n        this.registerInput(\"worldTangent\", NodeMaterialBlockConnectionPointTypes.Vector4, true);\n        this.registerInput(\"uv\", NodeMaterialBlockConnectionPointTypes.Vector2, false);\n        this.registerInput(\"normalMapColor\", NodeMaterialBlockConnectionPointTypes.Color3, false);\n        this.registerInput(\"strength\", NodeMaterialBlockConnectionPointTypes.Float, false);\n        this.registerInput(\"viewDirection\", NodeMaterialBlockConnectionPointTypes.Vector3, true);\n        this.registerInput(\"parallaxScale\", NodeMaterialBlockConnectionPointTypes.Float, true);\n        this.registerInput(\"parallaxHeight\", NodeMaterialBlockConnectionPointTypes.Float, true);\n        this.registerInput(\"TBN\", NodeMaterialBlockConnectionPointTypes.Object, true, NodeMaterialBlockTargets.VertexAndFragment, new NodeMaterialConnectionPointCustomObject(\"TBN\", this, NodeMaterialConnectionPointDirection.Input, TBNBlock, \"TBNBlock\"));\n        this.registerInput(\"world\", NodeMaterialBlockConnectionPointTypes.Matrix, true);\n        // Fragment\n        this.registerOutput(\"output\", NodeMaterialBlockConnectionPointTypes.Vector4);\n        this.registerOutput(\"uvOffset\", NodeMaterialBlockConnectionPointTypes.Vector2);\n    }\n    /**\n     * Gets the current class name\n     * @returns the class name\n     */\n    getClassName() {\n        return \"PerturbNormalBlock\";\n    }\n    /**\n     * Gets the world position input component\n     */\n    get worldPosition() {\n        return this._inputs[0];\n    }\n    /**\n     * Gets the world normal input component\n     */\n    get worldNormal() {\n        return this._inputs[1];\n    }\n    /**\n     * Gets the world tangent input component\n     */\n    get worldTangent() {\n        return this._inputs[2];\n    }\n    /**\n     * Gets the uv input component\n     */\n    get uv() {\n        return this._inputs[3];\n    }\n    /**\n     * Gets the normal map color input component\n     */\n    get normalMapColor() {\n        return this._inputs[4];\n    }\n    /**\n     * Gets the strength input component\n     */\n    get strength() {\n        return this._inputs[5];\n    }\n    /**\n     * Gets the view direction input component\n     */\n    get viewDirection() {\n        return this._inputs[6];\n    }\n    /**\n     * Gets the parallax scale input component\n     */\n    get parallaxScale() {\n        return this._inputs[7];\n    }\n    /**\n     * Gets the parallax height input component\n     */\n    get parallaxHeight() {\n        return this._inputs[8];\n    }\n    /**\n     * Gets the TBN input component\n     */\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    get TBN() {\n        return this._inputs[9];\n    }\n    /**\n     * Gets the World input component\n     */\n    get world() {\n        return this._inputs[10];\n    }\n    /**\n     * Gets the output component\n     */\n    get output() {\n        return this._outputs[0];\n    }\n    /**\n     * Gets the uv offset output component\n     */\n    get uvOffset() {\n        return this._outputs[1];\n    }\n    prepareDefines(mesh, nodeMaterial, defines) {\n        const normalSamplerName = this.normalMapColor.connectedPoint._ownerBlock.samplerName;\n        const useParallax = this.viewDirection.isConnected && ((this.useParallaxOcclusion && normalSamplerName) || (!this.useParallaxOcclusion && this.parallaxHeight.isConnected));\n        defines.setValue(\"BUMP\", true);\n        defines.setValue(\"PARALLAX\", useParallax, true);\n        defines.setValue(\"PARALLAXOCCLUSION\", this.useParallaxOcclusion, true);\n        defines.setValue(\"OBJECTSPACE_NORMALMAP\", this.useObjectSpaceNormalMap, true);\n    }\n    bind(effect, nodeMaterial, mesh) {\n        if (nodeMaterial.getScene()._mirroredCameraPosition) {\n            effect.setFloat2(this._tangentSpaceParameterName, this.invertX ? 1.0 : -1.0, this.invertY ? 1.0 : -1.0);\n        }\n        else {\n            effect.setFloat2(this._tangentSpaceParameterName, this.invertX ? -1.0 : 1.0, this.invertY ? -1.0 : 1.0);\n        }\n        if (mesh) {\n            effect.setFloat(this._tangentCorrectionFactorName, mesh.getWorldMatrix().determinant() < 0 ? -1 : 1);\n            if (this.useObjectSpaceNormalMap && !this.world.isConnected) {\n                // World default to the mesh world matrix\n                effect.setMatrix(this._worldMatrixName, mesh.getWorldMatrix());\n            }\n        }\n    }\n    autoConfigure(material) {\n        if (!this.uv.isConnected) {\n            let uvInput = material.getInputBlockByPredicate((b) => b.isAttribute && b.name === \"uv\");\n            if (!uvInput) {\n                uvInput = new InputBlock(\"uv\");\n                uvInput.setAsAttribute();\n            }\n            uvInput.output.connectTo(this.uv);\n        }\n        if (!this.strength.isConnected) {\n            const strengthInput = new InputBlock(\"strength\");\n            strengthInput.value = 1.0;\n            strengthInput.output.connectTo(this.strength);\n        }\n    }\n    _buildBlock(state) {\n        super._buildBlock(state);\n        const comments = `//${this.name}`;\n        const uv = this.uv;\n        const worldPosition = this.worldPosition;\n        const worldNormal = this.worldNormal;\n        const worldTangent = this.worldTangent;\n        state.sharedData.blocksWithDefines.push(this);\n        state.sharedData.bindableBlocks.push(this);\n        this._tangentSpaceParameterName = state._getFreeDefineName(\"tangentSpaceParameter\");\n        state._emitUniformFromString(this._tangentSpaceParameterName, \"vec2\");\n        this._tangentCorrectionFactorName = state._getFreeDefineName(\"tangentCorrectionFactor\");\n        state._emitUniformFromString(this._tangentCorrectionFactorName, \"float\");\n        this._worldMatrixName = state._getFreeDefineName(\"perturbNormalWorldMatrix\");\n        state._emitUniformFromString(this._worldMatrixName, \"mat4\");\n        let normalSamplerName = null;\n        if (this.normalMapColor.connectedPoint) {\n            normalSamplerName = this.normalMapColor.connectedPoint._ownerBlock.samplerName;\n        }\n        const useParallax = this.viewDirection.isConnected && ((this.useParallaxOcclusion && normalSamplerName) || (!this.useParallaxOcclusion && this.parallaxHeight.isConnected));\n        const replaceForParallaxInfos = !this.parallaxScale.isConnectedToInputBlock\n            ? \"0.05\"\n            : this.parallaxScale.connectInputBlock.isConstant\n                ? state._emitFloat(this.parallaxScale.connectInputBlock.value)\n                : this.parallaxScale.associatedVariableName;\n        const replaceForBumpInfos = this.strength.isConnectedToInputBlock && this.strength.connectInputBlock.isConstant\n            ? `\\r\\n#if !defined(NORMALXYSCALE)\\r\\n1.0/\\r\\n#endif\\r\\n${state._emitFloat(this.strength.connectInputBlock.value)}`\n            : `\\r\\n#if !defined(NORMALXYSCALE)\\r\\n1.0/\\r\\n#endif\\r\\n${this.strength.associatedVariableName}`;\n        state._emitExtension(\"derivatives\", \"#extension GL_OES_standard_derivatives : enable\");\n        const tangentReplaceString = { search: /defined\\(TANGENT\\)/g, replace: worldTangent.isConnected ? \"defined(TANGENT)\" : \"defined(IGNORE)\" };\n        const tbnVarying = { search: /varying mat3 vTBN/g, replace: \"\" };\n        const normalMatrixReplaceString = { search: /uniform mat4 normalMatrix;/g, replace: \"\" };\n        const TBN = this.TBN;\n        if (TBN.isConnected) {\n            state.compilationString += `\r\n            #ifdef TBNBLOCK\r\n            mat3 vTBN = ${TBN.associatedVariableName};\r\n            #endif\r\n            `;\n        }\n        else if (worldTangent.isConnected) {\n            state.compilationString += `vec3 tbnNormal = normalize(${worldNormal.associatedVariableName}.xyz);\\r\\n`;\n            state.compilationString += `vec3 tbnTangent = normalize(${worldTangent.associatedVariableName}.xyz);\\r\\n`;\n            state.compilationString += `vec3 tbnBitangent = cross(tbnNormal, tbnTangent) * ${this._tangentCorrectionFactorName};\\r\\n`;\n            state.compilationString += `mat3 vTBN = mat3(tbnTangent, tbnBitangent, tbnNormal);\\r\\n`;\n        }\n        state._emitFunctionFromInclude(\"bumpFragmentMainFunctions\", comments, {\n            replaceStrings: [tangentReplaceString, tbnVarying, normalMatrixReplaceString],\n        });\n        state._emitFunctionFromInclude(\"bumpFragmentFunctions\", comments, {\n            replaceStrings: [\n                { search: /#include<samplerFragmentDeclaration>\\(_DEFINENAME_,BUMP,_VARYINGNAME_,Bump,_SAMPLERNAME_,bump\\)/g, replace: \"\" },\n                { search: /uniform sampler2D bumpSampler;/g, replace: \"\" },\n                {\n                    search: /vec2 parallaxOcclusion\\(vec3 vViewDirCoT,vec3 vNormalCoT,vec2 texCoord,float parallaxScale\\)/g,\n                    replace: \"#define inline\\r\\nvec2 parallaxOcclusion(vec3 vViewDirCoT, vec3 vNormalCoT, vec2 texCoord, float parallaxScale, sampler2D bumpSampler)\",\n                },\n                { search: /vec2 parallaxOffset\\(vec3 viewDir,float heightScale\\)/g, replace: \"vec2 parallaxOffset(vec3 viewDir, float heightScale, float height_)\" },\n                { search: /texture2D\\(bumpSampler,vBumpUV\\)\\.w/g, replace: \"height_\" },\n            ],\n        });\n        const uvForPerturbNormal = !useParallax || !normalSamplerName ? this.normalMapColor.associatedVariableName : `texture2D(${normalSamplerName}, ${uv.associatedVariableName} + uvOffset).xyz`;\n        state.compilationString += this._declareOutput(this.output, state) + \" = vec4(0.);\\r\\n\";\n        state.compilationString += state._emitCodeFromInclude(\"bumpFragment\", comments, {\n            replaceStrings: [\n                { search: /texture2D\\(bumpSampler,vBumpUV\\)/g, replace: `${uvForPerturbNormal}` },\n                {\n                    search: /#define CUSTOM_FRAGMENT_BUMP_FRAGMENT/g,\n                    replace: `mat4 normalMatrix = toNormalMatrix(${this.world.isConnected ? this.world.associatedVariableName : this._worldMatrixName});`,\n                },\n                { search: /perturbNormal\\(TBN,texture2D\\(bumpSampler,vBumpUV\\+uvOffset\\).xyz,vBumpInfos.y\\)/g, replace: `perturbNormal(TBN, ${uvForPerturbNormal}, vBumpInfos.y)` },\n                {\n                    search: /parallaxOcclusion\\(invTBN\\*-viewDirectionW,invTBN\\*normalW,vBumpUV,vBumpInfos.z\\)/g,\n                    replace: `parallaxOcclusion((invTBN * -viewDirectionW), (invTBN * normalW), vBumpUV, vBumpInfos.z, ${useParallax && this.useParallaxOcclusion ? normalSamplerName : \"bumpSampler\"})`,\n                },\n                {\n                    search: /parallaxOffset\\(invTBN\\*viewDirectionW,vBumpInfos\\.z\\)/g,\n                    replace: `parallaxOffset(invTBN * viewDirectionW, vBumpInfos.z, ${useParallax ? this.parallaxHeight.associatedVariableName : \"0.\"})`,\n                },\n                { search: /vTangentSpaceParams/g, replace: this._tangentSpaceParameterName },\n                { search: /vBumpInfos.y/g, replace: replaceForBumpInfos },\n                { search: /vBumpInfos.z/g, replace: replaceForParallaxInfos },\n                { search: /vBumpUV/g, replace: uv.associatedVariableName },\n                { search: /vPositionW/g, replace: worldPosition.associatedVariableName + \".xyz\" },\n                { search: /normalW=/g, replace: this.output.associatedVariableName + \".xyz = \" },\n                { search: /mat3\\(normalMatrix\\)\\*normalW/g, replace: \"mat3(normalMatrix) * \" + this.output.associatedVariableName + \".xyz\" },\n                { search: /normalW/g, replace: worldNormal.associatedVariableName + \".xyz\" },\n                { search: /viewDirectionW/g, replace: useParallax ? this.viewDirection.associatedVariableName : \"vec3(0.)\" },\n                tangentReplaceString,\n            ],\n        });\n        return this;\n    }\n    _dumpPropertiesCode() {\n        let codeString = super._dumpPropertiesCode() + `${this._codeVariableName}.invertX = ${this.invertX};\\r\\n`;\n        codeString += `${this._codeVariableName}.invertY = ${this.invertY};\\r\\n`;\n        codeString += `${this._codeVariableName}.useParallaxOcclusion = ${this.useParallaxOcclusion};\\r\\n`;\n        codeString += `${this._codeVariableName}.useObjectSpaceNormalMap = ${this.useObjectSpaceNormalMap};\\r\\n`;\n        return codeString;\n    }\n    serialize() {\n        const serializationObject = super.serialize();\n        serializationObject.invertX = this.invertX;\n        serializationObject.invertY = this.invertY;\n        serializationObject.useParallaxOcclusion = this.useParallaxOcclusion;\n        serializationObject.useObjectSpaceNormalMap = this.useObjectSpaceNormalMap;\n        return serializationObject;\n    }\n    _deserialize(serializationObject, scene, rootUrl) {\n        super._deserialize(serializationObject, scene, rootUrl);\n        this.invertX = serializationObject.invertX;\n        this.invertY = serializationObject.invertY;\n        this.useParallaxOcclusion = !!serializationObject.useParallaxOcclusion;\n        this.useObjectSpaceNormalMap = !!serializationObject.useObjectSpaceNormalMap;\n    }\n}\n__decorate([\n    editableInPropertyPage(\"Invert X axis\", PropertyTypeForEdition.Boolean, \"PROPERTIES\", { notifiers: { update: false } })\n], PerturbNormalBlock.prototype, \"invertX\", void 0);\n__decorate([\n    editableInPropertyPage(\"Invert Y axis\", PropertyTypeForEdition.Boolean, \"PROPERTIES\", { notifiers: { update: false } })\n], PerturbNormalBlock.prototype, \"invertY\", void 0);\n__decorate([\n    editableInPropertyPage(\"Use parallax occlusion\", PropertyTypeForEdition.Boolean)\n], PerturbNormalBlock.prototype, \"useParallaxOcclusion\", void 0);\n__decorate([\n    editableInPropertyPage(\"Object Space Mode\", PropertyTypeForEdition.Boolean, \"PROPERTIES\", { notifiers: { update: false } })\n], PerturbNormalBlock.prototype, \"useObjectSpaceNormalMap\", void 0);\nRegisterClass(\"BABYLON.PerturbNormalBlock\", PerturbNormalBlock);\n//# sourceMappingURL=perturbNormalBlock.js.map","import { NodeMaterialBlock } from \"../../nodeMaterialBlock.js\";\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes.js\";\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets.js\";\nimport { RegisterClass } from \"../../../../Misc/typeStore.js\";\n/**\n * Block used to discard a pixel if a value is smaller than a cutoff\n */\nexport class DiscardBlock extends NodeMaterialBlock {\n    /**\n     * Create a new DiscardBlock\n     * @param name defines the block name\n     */\n    constructor(name) {\n        super(name, NodeMaterialBlockTargets.Fragment, true);\n        this.registerInput(\"value\", NodeMaterialBlockConnectionPointTypes.Float, true);\n        this.registerInput(\"cutoff\", NodeMaterialBlockConnectionPointTypes.Float, true);\n    }\n    /**\n     * Gets the current class name\n     * @returns the class name\n     */\n    getClassName() {\n        return \"DiscardBlock\";\n    }\n    /**\n     * Gets the color input component\n     */\n    get value() {\n        return this._inputs[0];\n    }\n    /**\n     * Gets the cutoff input component\n     */\n    get cutoff() {\n        return this._inputs[1];\n    }\n    _buildBlock(state) {\n        super._buildBlock(state);\n        state.sharedData.hints.needAlphaTesting = true;\n        if (!this.cutoff.isConnected || !this.value.isConnected) {\n            return;\n        }\n        state.compilationString += `if (${this.value.associatedVariableName} < ${this.cutoff.associatedVariableName}) discard;\\r\\n`;\n        return this;\n    }\n}\nRegisterClass(\"BABYLON.DiscardBlock\", DiscardBlock);\n//# sourceMappingURL=discardBlock.js.map","import { NodeMaterialBlock } from \"../../nodeMaterialBlock.js\";\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes.js\";\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets.js\";\nimport { RegisterClass } from \"../../../../Misc/typeStore.js\";\n/**\n * Block used to test if the fragment shader is front facing\n */\nexport class FrontFacingBlock extends NodeMaterialBlock {\n    /**\n     * Creates a new FrontFacingBlock\n     * @param name defines the block name\n     */\n    constructor(name) {\n        super(name, NodeMaterialBlockTargets.Fragment);\n        this.registerOutput(\"output\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Fragment);\n    }\n    /**\n     * Gets the current class name\n     * @returns the class name\n     */\n    getClassName() {\n        return \"FrontFacingBlock\";\n    }\n    /**\n     * Gets the output component\n     */\n    get output() {\n        return this._outputs[0];\n    }\n    _buildBlock(state) {\n        super._buildBlock(state);\n        if (state.target === NodeMaterialBlockTargets.Vertex) {\n            throw \"FrontFacingBlock must only be used in a fragment shader\";\n        }\n        const output = this._outputs[0];\n        state.compilationString += this._declareOutput(output, state) + ` = gl_FrontFacing ? 1.0 : 0.0;\\r\\n`;\n        return this;\n    }\n}\nRegisterClass(\"BABYLON.FrontFacingBlock\", FrontFacingBlock);\n//# sourceMappingURL=frontFacingBlock.js.map","import { NodeMaterialBlock } from \"../../nodeMaterialBlock.js\";\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes.js\";\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets.js\";\nimport { RegisterClass } from \"../../../../Misc/typeStore.js\";\n/**\n * Block used to get the derivative value on x and y of a given input\n */\nexport class DerivativeBlock extends NodeMaterialBlock {\n    /**\n     * Create a new DerivativeBlock\n     * @param name defines the block name\n     */\n    constructor(name) {\n        super(name, NodeMaterialBlockTargets.Fragment);\n        this.registerInput(\"input\", NodeMaterialBlockConnectionPointTypes.AutoDetect, false);\n        this.registerOutput(\"dx\", NodeMaterialBlockConnectionPointTypes.BasedOnInput);\n        this.registerOutput(\"dy\", NodeMaterialBlockConnectionPointTypes.BasedOnInput);\n        this._outputs[0]._typeConnectionSource = this._inputs[0];\n        this._outputs[1]._typeConnectionSource = this._inputs[0];\n    }\n    /**\n     * Gets the current class name\n     * @returns the class name\n     */\n    getClassName() {\n        return \"DerivativeBlock\";\n    }\n    /**\n     * Gets the input component\n     */\n    get input() {\n        return this._inputs[0];\n    }\n    /**\n     * Gets the derivative output on x\n     */\n    get dx() {\n        return this._outputs[0];\n    }\n    /**\n     * Gets the derivative output on y\n     */\n    get dy() {\n        return this._outputs[1];\n    }\n    _buildBlock(state) {\n        super._buildBlock(state);\n        const dx = this._outputs[0];\n        const dy = this._outputs[1];\n        state._emitExtension(\"derivatives\", \"#extension GL_OES_standard_derivatives : enable\");\n        if (dx.hasEndpoints) {\n            state.compilationString += this._declareOutput(dx, state) + ` = dFdx(${this.input.associatedVariableName});\\r\\n`;\n        }\n        if (dy.hasEndpoints) {\n            state.compilationString += this._declareOutput(dy, state) + ` = dFdy(${this.input.associatedVariableName});\\r\\n`;\n        }\n        return this;\n    }\n}\nRegisterClass(\"BABYLON.DerivativeBlock\", DerivativeBlock);\n//# sourceMappingURL=derivativeBlock.js.map","import { NodeMaterialBlock } from \"../../nodeMaterialBlock.js\";\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes.js\";\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets.js\";\nimport { RegisterClass } from \"../../../../Misc/typeStore.js\";\n/**\n * Block used to make gl_FragCoord available\n */\nexport class FragCoordBlock extends NodeMaterialBlock {\n    /**\n     * Creates a new FragCoordBlock\n     * @param name defines the block name\n     */\n    constructor(name) {\n        super(name, NodeMaterialBlockTargets.Fragment);\n        this.registerOutput(\"xy\", NodeMaterialBlockConnectionPointTypes.Vector2, NodeMaterialBlockTargets.Fragment);\n        this.registerOutput(\"xyz\", NodeMaterialBlockConnectionPointTypes.Vector3, NodeMaterialBlockTargets.Fragment);\n        this.registerOutput(\"xyzw\", NodeMaterialBlockConnectionPointTypes.Vector4, NodeMaterialBlockTargets.Fragment);\n        this.registerOutput(\"x\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Fragment);\n        this.registerOutput(\"y\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Fragment);\n        this.registerOutput(\"z\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Fragment);\n        this.registerOutput(\"w\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Fragment);\n    }\n    /**\n     * Gets the current class name\n     * @returns the class name\n     */\n    getClassName() {\n        return \"FragCoordBlock\";\n    }\n    /**\n     * Gets the xy component\n     */\n    get xy() {\n        return this._outputs[0];\n    }\n    /**\n     * Gets the xyz component\n     */\n    get xyz() {\n        return this._outputs[1];\n    }\n    /**\n     * Gets the xyzw component\n     */\n    get xyzw() {\n        return this._outputs[2];\n    }\n    /**\n     * Gets the x component\n     */\n    get x() {\n        return this._outputs[3];\n    }\n    /**\n     * Gets the y component\n     */\n    get y() {\n        return this._outputs[4];\n    }\n    /**\n     * Gets the z component\n     */\n    get z() {\n        return this._outputs[5];\n    }\n    /**\n     * Gets the w component\n     */\n    get output() {\n        return this._outputs[6];\n    }\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    writeOutputs(state) {\n        let code = \"\";\n        for (const output of this._outputs) {\n            if (output.hasEndpoints) {\n                code += `${this._declareOutput(output, state)} = gl_FragCoord.${output.name};\\r\\n`;\n            }\n        }\n        return code;\n    }\n    _buildBlock(state) {\n        super._buildBlock(state);\n        if (state.target === NodeMaterialBlockTargets.Vertex) {\n            throw \"FragCoordBlock must only be used in a fragment shader\";\n        }\n        state.compilationString += this.writeOutputs(state);\n        return this;\n    }\n}\nRegisterClass(\"BABYLON.FragCoordBlock\", FragCoordBlock);\n//# sourceMappingURL=fragCoordBlock.js.map","import { NodeMaterialBlock } from \"../../nodeMaterialBlock.js\";\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes.js\";\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets.js\";\nimport { RegisterClass } from \"../../../../Misc/typeStore.js\";\n/**\n * Block used to get the screen sizes\n */\nexport class ScreenSizeBlock extends NodeMaterialBlock {\n    /**\n     * Creates a new ScreenSizeBlock\n     * @param name defines the block name\n     */\n    constructor(name) {\n        super(name, NodeMaterialBlockTargets.Fragment);\n        this.registerOutput(\"xy\", NodeMaterialBlockConnectionPointTypes.Vector2, NodeMaterialBlockTargets.Fragment);\n        this.registerOutput(\"x\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Fragment);\n        this.registerOutput(\"y\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Fragment);\n    }\n    /**\n     * Gets the current class name\n     * @returns the class name\n     */\n    getClassName() {\n        return \"ScreenSizeBlock\";\n    }\n    /**\n     * Gets the xy component\n     */\n    get xy() {\n        return this._outputs[0];\n    }\n    /**\n     * Gets the x component\n     */\n    get x() {\n        return this._outputs[1];\n    }\n    /**\n     * Gets the y component\n     */\n    get y() {\n        return this._outputs[2];\n    }\n    bind(effect) {\n        const engine = this._scene.getEngine();\n        effect.setFloat2(this._varName, engine.getRenderWidth(), engine.getRenderHeight());\n    }\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    writeOutputs(state, varName) {\n        let code = \"\";\n        for (const output of this._outputs) {\n            if (output.hasEndpoints) {\n                code += `${this._declareOutput(output, state)} = ${varName}.${output.name};\\r\\n`;\n            }\n        }\n        return code;\n    }\n    _buildBlock(state) {\n        super._buildBlock(state);\n        this._scene = state.sharedData.scene;\n        if (state.target === NodeMaterialBlockTargets.Vertex) {\n            throw \"ScreenSizeBlock must only be used in a fragment shader\";\n        }\n        state.sharedData.bindableBlocks.push(this);\n        this._varName = state._getFreeVariableName(\"screenSize\");\n        state._emitUniformFromString(this._varName, \"vec2\");\n        state.compilationString += this.writeOutputs(state, this._varName);\n        return this;\n    }\n}\nRegisterClass(\"BABYLON.ScreenSizeBlock\", ScreenSizeBlock);\n//# sourceMappingURL=screenSizeBlock.js.map","import { NodeMaterialBlock } from \"../../nodeMaterialBlock.js\";\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes.js\";\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets.js\";\nimport { RegisterClass } from \"../../../../Misc/typeStore.js\";\nimport { NodeMaterialSystemValues } from \"../../Enums/nodeMaterialSystemValues.js\";\nimport { InputBlock } from \"../Input/inputBlock.js\";\n/**\n * Block used to transform a vector3 or a vector4 into screen space\n */\nexport class ScreenSpaceBlock extends NodeMaterialBlock {\n    /**\n     * Creates a new ScreenSpaceBlock\n     * @param name defines the block name\n     */\n    constructor(name) {\n        super(name, NodeMaterialBlockTargets.Fragment);\n        this.registerInput(\"vector\", NodeMaterialBlockConnectionPointTypes.AutoDetect);\n        this.registerInput(\"worldViewProjection\", NodeMaterialBlockConnectionPointTypes.Matrix);\n        this.registerOutput(\"output\", NodeMaterialBlockConnectionPointTypes.Vector2);\n        this.registerOutput(\"x\", NodeMaterialBlockConnectionPointTypes.Float);\n        this.registerOutput(\"y\", NodeMaterialBlockConnectionPointTypes.Float);\n        this.inputs[0].addExcludedConnectionPointFromAllowedTypes(NodeMaterialBlockConnectionPointTypes.Color3 | NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Vector4);\n    }\n    /**\n     * Gets the current class name\n     * @returns the class name\n     */\n    getClassName() {\n        return \"ScreenSpaceBlock\";\n    }\n    /**\n     * Gets the vector input\n     */\n    get vector() {\n        return this._inputs[0];\n    }\n    /**\n     * Gets the worldViewProjection transform input\n     */\n    get worldViewProjection() {\n        return this._inputs[1];\n    }\n    /**\n     * Gets the output component\n     */\n    get output() {\n        return this._outputs[0];\n    }\n    /**\n     * Gets the x output component\n     */\n    get x() {\n        return this._outputs[1];\n    }\n    /**\n     * Gets the y output component\n     */\n    get y() {\n        return this._outputs[2];\n    }\n    autoConfigure(material) {\n        if (!this.worldViewProjection.isConnected) {\n            let worldViewProjectionInput = material.getInputBlockByPredicate((b) => b.systemValue === NodeMaterialSystemValues.WorldViewProjection);\n            if (!worldViewProjectionInput) {\n                worldViewProjectionInput = new InputBlock(\"worldViewProjection\");\n                worldViewProjectionInput.setAsSystemValue(NodeMaterialSystemValues.WorldViewProjection);\n            }\n            worldViewProjectionInput.output.connectTo(this.worldViewProjection);\n        }\n    }\n    _buildBlock(state) {\n        super._buildBlock(state);\n        const vector = this.vector;\n        const worldViewProjection = this.worldViewProjection;\n        if (!vector.connectedPoint) {\n            return;\n        }\n        const worldViewProjectionName = worldViewProjection.associatedVariableName;\n        const tempVariableName = state._getFreeVariableName(\"screenSpaceTemp\");\n        switch (vector.connectedPoint.type) {\n            case NodeMaterialBlockConnectionPointTypes.Vector3:\n                state.compilationString += `vec4 ${tempVariableName} = ${worldViewProjectionName} * vec4(${vector.associatedVariableName}, 1.0);\\r\\n`;\n                break;\n            case NodeMaterialBlockConnectionPointTypes.Vector4:\n                state.compilationString += `vec4 ${tempVariableName} = ${worldViewProjectionName} * ${vector.associatedVariableName};\\r\\n`;\n                break;\n        }\n        state.compilationString += `${tempVariableName}.xy /= ${tempVariableName}.w;`;\n        state.compilationString += `${tempVariableName}.xy = ${tempVariableName}.xy * 0.5 + vec2(0.5, 0.5);`;\n        if (this.output.hasEndpoints) {\n            state.compilationString += this._declareOutput(this.output, state) + ` = ${tempVariableName}.xy;\\r\\n`;\n        }\n        if (this.x.hasEndpoints) {\n            state.compilationString += this._declareOutput(this.x, state) + ` = ${tempVariableName}.x;\\r\\n`;\n        }\n        if (this.y.hasEndpoints) {\n            state.compilationString += this._declareOutput(this.y, state) + ` = ${tempVariableName}.y;\\r\\n`;\n        }\n        return this;\n    }\n}\nRegisterClass(\"BABYLON.ScreenSpaceBlock\", ScreenSpaceBlock);\n//# sourceMappingURL=screenSpaceBlock.js.map","import { NodeMaterialBlock } from \"../../nodeMaterialBlock.js\";\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes.js\";\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets.js\";\nimport { RegisterClass } from \"../../../../Misc/typeStore.js\";\nimport { InputBlock } from \"../Input/inputBlock.js\";\nimport { Vector2 } from \"../../../../Maths/math.vector.js\";\n/**\n * Block used to generate a twirl\n */\nexport class TwirlBlock extends NodeMaterialBlock {\n    /**\n     * Creates a new TwirlBlock\n     * @param name defines the block name\n     */\n    constructor(name) {\n        super(name, NodeMaterialBlockTargets.Fragment);\n        this.registerInput(\"input\", NodeMaterialBlockConnectionPointTypes.Vector2);\n        this.registerInput(\"strength\", NodeMaterialBlockConnectionPointTypes.Float);\n        this.registerInput(\"center\", NodeMaterialBlockConnectionPointTypes.Vector2);\n        this.registerInput(\"offset\", NodeMaterialBlockConnectionPointTypes.Vector2);\n        this.registerOutput(\"output\", NodeMaterialBlockConnectionPointTypes.Vector2);\n        this.registerOutput(\"x\", NodeMaterialBlockConnectionPointTypes.Float);\n        this.registerOutput(\"y\", NodeMaterialBlockConnectionPointTypes.Float);\n    }\n    /**\n     * Gets the current class name\n     * @returns the class name\n     */\n    getClassName() {\n        return \"TwirlBlock\";\n    }\n    /**\n     * Gets the input component\n     */\n    get input() {\n        return this._inputs[0];\n    }\n    /**\n     * Gets the strength component\n     */\n    get strength() {\n        return this._inputs[1];\n    }\n    /**\n     * Gets the center component\n     */\n    get center() {\n        return this._inputs[2];\n    }\n    /**\n     * Gets the offset component\n     */\n    get offset() {\n        return this._inputs[3];\n    }\n    /**\n     * Gets the output component\n     */\n    get output() {\n        return this._outputs[0];\n    }\n    /**\n     * Gets the x output component\n     */\n    get x() {\n        return this._outputs[1];\n    }\n    /**\n     * Gets the y output component\n     */\n    get y() {\n        return this._outputs[2];\n    }\n    autoConfigure() {\n        if (!this.center.isConnected) {\n            const centerInput = new InputBlock(\"center\");\n            centerInput.value = new Vector2(0.5, 0.5);\n            centerInput.output.connectTo(this.center);\n        }\n        if (!this.strength.isConnected) {\n            const strengthInput = new InputBlock(\"strength\");\n            strengthInput.value = 1.0;\n            strengthInput.output.connectTo(this.strength);\n        }\n        if (!this.offset.isConnected) {\n            const offsetInput = new InputBlock(\"offset\");\n            offsetInput.value = new Vector2(0, 0);\n            offsetInput.output.connectTo(this.offset);\n        }\n    }\n    _buildBlock(state) {\n        super._buildBlock(state);\n        const tempDelta = state._getFreeVariableName(\"delta\");\n        const tempAngle = state._getFreeVariableName(\"angle\");\n        const tempX = state._getFreeVariableName(\"x\");\n        const tempY = state._getFreeVariableName(\"y\");\n        const tempResult = state._getFreeVariableName(\"result\");\n        state.compilationString += `\r\n            vec2 ${tempDelta} = ${this.input.associatedVariableName} - ${this.center.associatedVariableName};\r\n            float ${tempAngle} = ${this.strength.associatedVariableName} * length(${tempDelta});\r\n            float ${tempX} = cos(${tempAngle}) * ${tempDelta}.x - sin(${tempAngle}) * ${tempDelta}.y;\r\n            float ${tempY} = sin(${tempAngle}) * ${tempDelta}.x + cos(${tempAngle}) * ${tempDelta}.y;\r\n            vec2 ${tempResult} = vec2(${tempX} + ${this.center.associatedVariableName}.x + ${this.offset.associatedVariableName}.x, ${tempY} + ${this.center.associatedVariableName}.y + ${this.offset.associatedVariableName}.y);\r\n        `;\n        if (this.output.hasEndpoints) {\n            state.compilationString += this._declareOutput(this.output, state) + ` = ${tempResult};\\r\\n`;\n        }\n        if (this.x.hasEndpoints) {\n            state.compilationString += this._declareOutput(this.x, state) + ` = ${tempResult}.x;\\r\\n`;\n        }\n        if (this.y.hasEndpoints) {\n            state.compilationString += this._declareOutput(this.y, state) + ` = ${tempResult}.y;\\r\\n`;\n        }\n        return this;\n    }\n}\nRegisterClass(\"BABYLON.TwirlBlock\", TwirlBlock);\n//# sourceMappingURL=twirlBlock.js.map","import { __decorate } from \"../../../../tslib.es6.js\";\nimport { NodeMaterialBlock } from \"../../nodeMaterialBlock.js\";\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes.js\";\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets.js\";\nimport { RegisterClass } from \"../../../../Misc/typeStore.js\";\nimport { editableInPropertyPage, PropertyTypeForEdition } from \"../../nodeMaterialDecorator.js\";\n/**\n * Block used to convert a height vector to a normal\n */\nexport class HeightToNormalBlock extends NodeMaterialBlock {\n    /**\n     * Creates a new HeightToNormalBlock\n     * @param name defines the block name\n     */\n    constructor(name) {\n        super(name, NodeMaterialBlockTargets.Fragment);\n        /**\n         * Defines if the output should be generated in world or tangent space.\n         * Note that in tangent space the result is also scaled by 0.5 and offsetted by 0.5 so that it can directly be used as a PerturbNormal.normalMapColor input\n         */\n        this.generateInWorldSpace = false;\n        /**\n         * Defines that the worldNormal input will be normalized by the HeightToNormal block before being used\n         */\n        this.automaticNormalizationNormal = true;\n        /**\n         * Defines that the worldTangent input will be normalized by the HeightToNormal block before being used\n         */\n        this.automaticNormalizationTangent = true;\n        this.registerInput(\"input\", NodeMaterialBlockConnectionPointTypes.Float);\n        this.registerInput(\"worldPosition\", NodeMaterialBlockConnectionPointTypes.Vector3);\n        this.registerInput(\"worldNormal\", NodeMaterialBlockConnectionPointTypes.Vector3);\n        this.registerInput(\"worldTangent\", NodeMaterialBlockConnectionPointTypes.AutoDetect, true);\n        this.registerOutput(\"output\", NodeMaterialBlockConnectionPointTypes.Vector4);\n        this.registerOutput(\"xyz\", NodeMaterialBlockConnectionPointTypes.Vector3);\n        this._inputs[3].addExcludedConnectionPointFromAllowedTypes(NodeMaterialBlockConnectionPointTypes.Color3 | NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Vector4);\n    }\n    /**\n     * Gets the current class name\n     * @returns the class name\n     */\n    getClassName() {\n        return \"HeightToNormalBlock\";\n    }\n    /**\n     * Gets the input component\n     */\n    get input() {\n        return this._inputs[0];\n    }\n    /**\n     * Gets the position component\n     */\n    get worldPosition() {\n        return this._inputs[1];\n    }\n    /**\n     * Gets the normal component\n     */\n    get worldNormal() {\n        return this._inputs[2];\n    }\n    /**\n     * Gets the tangent component\n     */\n    get worldTangent() {\n        return this._inputs[3];\n    }\n    /**\n     * Gets the output component\n     */\n    get output() {\n        return this._outputs[0];\n    }\n    /**\n     * Gets the xyz component\n     */\n    get xyz() {\n        return this._outputs[1];\n    }\n    _buildBlock(state) {\n        super._buildBlock(state);\n        const output = this._outputs[0];\n        if (!this.generateInWorldSpace && !this.worldTangent.isConnected) {\n            console.error(`You must connect the 'worldTangent' input of the ${this.name} block!`);\n        }\n        const startCode = this.generateInWorldSpace\n            ? \"\"\n            : `\r\n            vec3 biTangent = cross(normal, tangent);\r\n            mat3 TBN = mat3(tangent, biTangent, normal);\r\n            `;\n        const endCode = this.generateInWorldSpace\n            ? \"\"\n            : `\r\n            result = TBN * result;\r\n            result = result * vec3(0.5) + vec3(0.5);\r\n            `;\n        const heightToNormal = `\r\n            vec4 heightToNormal(in float height, in vec3 position, in vec3 tangent, in vec3 normal) {\r\n                ${startCode}\r\n                ${this.automaticNormalizationTangent ? \"tangent = normalize(tangent);\" : \"\"}\r\n                ${this.automaticNormalizationNormal ? \"normal = normalize(normal);\" : \"\"}\r\n                vec3 worlddX = dFdx(position);\r\n                vec3 worlddY = dFdy(position);\r\n                vec3 crossX = cross(normal, worlddX);\r\n                vec3 crossY = cross(normal, worlddY);\r\n                float d = abs(dot(crossY, worlddX));\r\n                vec3 inToNormal = vec3(((((height + dFdx(height)) - height) * crossY) + (((height + dFdy(height)) - height) * crossX)) * sign(d));\r\n                inToNormal.y *= -1.0;\r\n                vec3 result = normalize((d * normal) - inToNormal);\r\n                ${endCode}\r\n                return vec4(result, 0.);\r\n            }`;\n        state._emitExtension(\"derivatives\", \"#extension GL_OES_standard_derivatives : enable\");\n        state._emitFunction(\"heightToNormal\", heightToNormal, \"// heightToNormal\");\n        state.compilationString +=\n            this._declareOutput(output, state) +\n                ` = heightToNormal(${this.input.associatedVariableName}, ${this.worldPosition.associatedVariableName}, ${this.worldTangent.isConnected ? this.worldTangent.associatedVariableName : \"vec3(0.)\"}.xyz, ${this.worldNormal.associatedVariableName});\\r\\n`;\n        if (this.xyz.hasEndpoints) {\n            state.compilationString += this._declareOutput(this.xyz, state) + ` = ${this.output.associatedVariableName}.xyz;\\r\\n`;\n        }\n        return this;\n    }\n    _dumpPropertiesCode() {\n        let codeString = super._dumpPropertiesCode();\n        codeString += `${this._codeVariableName}.generateInWorldSpace = ${this.generateInWorldSpace};\\r\\n`;\n        codeString += `${this._codeVariableName}.automaticNormalizationNormal = ${this.automaticNormalizationNormal};\\r\\n`;\n        codeString += `${this._codeVariableName}.automaticNormalizationTangent = ${this.automaticNormalizationTangent};\\r\\n`;\n        return codeString;\n    }\n    serialize() {\n        const serializationObject = super.serialize();\n        serializationObject.generateInWorldSpace = this.generateInWorldSpace;\n        serializationObject.automaticNormalizationNormal = this.automaticNormalizationNormal;\n        serializationObject.automaticNormalizationTangent = this.automaticNormalizationTangent;\n        return serializationObject;\n    }\n    _deserialize(serializationObject, scene, rootUrl) {\n        super._deserialize(serializationObject, scene, rootUrl);\n        this.generateInWorldSpace = serializationObject.generateInWorldSpace;\n        this.automaticNormalizationNormal = serializationObject.automaticNormalizationNormal;\n        this.automaticNormalizationTangent = serializationObject.automaticNormalizationTangent;\n    }\n}\n__decorate([\n    editableInPropertyPage(\"Generate in world space instead of tangent space\", PropertyTypeForEdition.Boolean, \"PROPERTIES\", { notifiers: { update: true } })\n], HeightToNormalBlock.prototype, \"generateInWorldSpace\", void 0);\n__decorate([\n    editableInPropertyPage(\"Force normalization for the worldNormal input\", PropertyTypeForEdition.Boolean, \"PROPERTIES\", { notifiers: { update: true } })\n], HeightToNormalBlock.prototype, \"automaticNormalizationNormal\", void 0);\n__decorate([\n    editableInPropertyPage(\"Force normalization for the worldTangent input\", PropertyTypeForEdition.Boolean, \"PROPERTIES\", { notifiers: { update: true } })\n], HeightToNormalBlock.prototype, \"automaticNormalizationTangent\", void 0);\nRegisterClass(\"BABYLON.HeightToNormalBlock\", HeightToNormalBlock);\n//# sourceMappingURL=heightToNormalBlock.js.map","import { NodeMaterialBlock } from \"../../nodeMaterialBlock.js\";\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes.js\";\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets.js\";\nimport { RegisterClass } from \"../../../../Misc/typeStore.js\";\n/**\n * Block used to write the fragment depth\n */\nexport class FragDepthBlock extends NodeMaterialBlock {\n    /**\n     * Create a new FragDepthBlock\n     * @param name defines the block name\n     */\n    constructor(name) {\n        super(name, NodeMaterialBlockTargets.Fragment, true);\n        this.registerInput(\"depth\", NodeMaterialBlockConnectionPointTypes.Float, true);\n        this.registerInput(\"worldPos\", NodeMaterialBlockConnectionPointTypes.Vector4, true);\n        this.registerInput(\"viewProjection\", NodeMaterialBlockConnectionPointTypes.Matrix, true);\n    }\n    /**\n     * Gets the current class name\n     * @returns the class name\n     */\n    getClassName() {\n        return \"FragDepthBlock\";\n    }\n    /**\n     * Gets the depth input component\n     */\n    get depth() {\n        return this._inputs[0];\n    }\n    /**\n     * Gets the worldPos input component\n     */\n    get worldPos() {\n        return this._inputs[1];\n    }\n    /**\n     * Gets the viewProjection input component\n     */\n    get viewProjection() {\n        return this._inputs[2];\n    }\n    _buildBlock(state) {\n        super._buildBlock(state);\n        if (this.depth.isConnected) {\n            state.compilationString += `gl_FragDepth = ${this.depth.associatedVariableName};\\r\\n`;\n        }\n        else if (this.worldPos.isConnected && this.viewProjection.isConnected) {\n            state.compilationString += `\r\n                vec4 p = ${this.viewProjection.associatedVariableName} * ${this.worldPos.associatedVariableName};\r\n                float v = p.z / p.w;\r\n                #ifndef IS_NDC_HALF_ZRANGE\r\n                    v = v * 0.5 + 0.5;\r\n                #endif\r\n                gl_FragDepth = v;\r\n    \r\n            `;\n        }\n        else {\n            console.warn(\"FragDepthBlock: either the depth input or both the worldPos and viewProjection inputs must be connected!\");\n        }\n        return this;\n    }\n}\nRegisterClass(\"BABYLON.FragDepthBlock\", FragDepthBlock);\n//# sourceMappingURL=fragDepthBlock.js.map","import { NodeMaterialBlock } from \"../../nodeMaterialBlock.js\";\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes.js\";\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets.js\";\nimport { RegisterClass } from \"../../../../Misc/typeStore.js\";\n/**\n * Block used to output the depth to a shadow map\n */\nexport class ShadowMapBlock extends NodeMaterialBlock {\n    /**\n     * Create a new ShadowMapBlock\n     * @param name defines the block name\n     */\n    constructor(name) {\n        super(name, NodeMaterialBlockTargets.Fragment);\n        this.registerInput(\"worldPosition\", NodeMaterialBlockConnectionPointTypes.Vector4, false);\n        this.registerInput(\"viewProjection\", NodeMaterialBlockConnectionPointTypes.Matrix, false);\n        this.registerInput(\"worldNormal\", NodeMaterialBlockConnectionPointTypes.AutoDetect, true);\n        this.registerOutput(\"depth\", NodeMaterialBlockConnectionPointTypes.Vector3);\n        this.worldNormal.addExcludedConnectionPointFromAllowedTypes(NodeMaterialBlockConnectionPointTypes.Color3 | NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Vector4);\n    }\n    /**\n     * Gets the current class name\n     * @returns the class name\n     */\n    getClassName() {\n        return \"ShadowMapBlock\";\n    }\n    /**\n     * Initialize the block and prepare the context for build\n     * @param state defines the state that will be used for the build\n     */\n    initialize(state) {\n        state._excludeVariableName(\"vPositionWSM\");\n        state._excludeVariableName(\"lightDataSM\");\n        state._excludeVariableName(\"biasAndScaleSM\");\n        state._excludeVariableName(\"depthValuesSM\");\n        state._excludeVariableName(\"clipPos\");\n        state._excludeVariableName(\"worldPos\");\n        state._excludeVariableName(\"zSM\");\n    }\n    /**\n     * Gets the world position input component\n     */\n    get worldPosition() {\n        return this._inputs[0];\n    }\n    /**\n     * Gets the view x projection input component\n     */\n    get viewProjection() {\n        return this._inputs[1];\n    }\n    /**\n     * Gets the world normal input component\n     */\n    get worldNormal() {\n        return this._inputs[2];\n    }\n    /**\n     * Gets the depth output component\n     */\n    get depth() {\n        return this._outputs[0];\n    }\n    _buildBlock(state) {\n        super._buildBlock(state);\n        const comments = `//${this.name}`;\n        state._emitUniformFromString(\"biasAndScaleSM\", \"vec3\");\n        state._emitUniformFromString(\"lightDataSM\", \"vec3\");\n        state._emitUniformFromString(\"depthValuesSM\", \"vec2\");\n        state._emitFunctionFromInclude(\"packingFunctions\", comments);\n        state.compilationString += `vec4 worldPos = ${this.worldPosition.associatedVariableName};\\r\\n`;\n        state.compilationString += `vec3 vPositionWSM;\\r\\n`;\n        state.compilationString += `float vDepthMetricSM = 0.0;\\r\\n`;\n        state.compilationString += `float zSM;\\r\\n`;\n        if (this.worldNormal.isConnected) {\n            state.compilationString += `vec3 vNormalW = ${this.worldNormal.associatedVariableName}.xyz;\\r\\n`;\n            state.compilationString += state._emitCodeFromInclude(\"shadowMapVertexNormalBias\", comments);\n        }\n        state.compilationString += `vec4 clipPos = ${this.viewProjection.associatedVariableName} * worldPos;\\r\\n`;\n        state.compilationString += state._emitCodeFromInclude(\"shadowMapVertexMetric\", comments, {\n            replaceStrings: [\n                {\n                    search: /gl_Position/g,\n                    replace: \"clipPos\",\n                },\n            ],\n        });\n        state.compilationString += state._emitCodeFromInclude(\"shadowMapFragment\", comments, {\n            replaceStrings: [\n                {\n                    search: /return;/g,\n                    replace: \"\",\n                },\n            ],\n        });\n        state.compilationString += `\r\n            #if SM_DEPTHTEXTURE == 1\r\n                #ifdef IS_NDC_HALF_ZRANGE\r\n                    gl_FragDepth = (clipPos.z / clipPos.w);\r\n                #else\r\n                    gl_FragDepth = (clipPos.z / clipPos.w) * 0.5 + 0.5;\r\n                #endif\r\n            #endif\r\n        `;\n        state.compilationString += `${this._declareOutput(this.depth, state)} = vec3(depthSM, 1., 1.);\\r\\n`;\n        return this;\n    }\n}\nRegisterClass(\"BABYLON.ShadowMapBlock\", ShadowMapBlock);\n//# sourceMappingURL=shadowMapBlock.js.map","/**\n * Enum defining the type of animations supported by InputBlock\n */\nexport var AnimatedInputBlockTypes;\n(function (AnimatedInputBlockTypes) {\n    /** No animation */\n    AnimatedInputBlockTypes[AnimatedInputBlockTypes[\"None\"] = 0] = \"None\";\n    /** Time based animation (is incremented by 0.6 each second). Will only work for floats */\n    AnimatedInputBlockTypes[AnimatedInputBlockTypes[\"Time\"] = 1] = \"Time\";\n    /** Time elapsed (in seconds) since the engine was initialized. Will only work for floats */\n    AnimatedInputBlockTypes[AnimatedInputBlockTypes[\"RealTime\"] = 2] = \"RealTime\";\n})(AnimatedInputBlockTypes || (AnimatedInputBlockTypes = {}));\n//# sourceMappingURL=animatedInputBlockTypes.js.map","/* eslint-disable @typescript-eslint/naming-convention */\nimport { NodeMaterialBlock } from \"../../nodeMaterialBlock.js\";\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes.js\";\nimport { NodeMaterialBlockConnectionPointMode } from \"../../Enums/nodeMaterialBlockConnectionPointMode.js\";\nimport { NodeMaterialSystemValues } from \"../../Enums/nodeMaterialSystemValues.js\";\nimport { Matrix, Vector2, Vector3, Vector4 } from \"../../../../Maths/math.vector.js\";\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets.js\";\nimport { GetClass, RegisterClass } from \"../../../../Misc/typeStore.js\";\nimport { Color3, Color4, TmpColors } from \"../../../../Maths/math.js\";\nimport { AnimatedInputBlockTypes } from \"./animatedInputBlockTypes.js\";\nimport { Observable } from \"../../../../Misc/observable.js\";\nimport { PrecisionDate } from \"../../../../Misc/precisionDate.js\";\nconst remapAttributeName = {\n    position2d: \"position\",\n    particle_uv: \"vUV\",\n    particle_color: \"vColor\",\n    particle_texturemask: \"textureMask\",\n    particle_positionw: \"vPositionW\",\n};\nconst attributeInFragmentOnly = {\n    particle_uv: true,\n    particle_color: true,\n    particle_texturemask: true,\n    particle_positionw: true,\n};\nconst attributeAsUniform = {\n    particle_texturemask: true,\n};\n/**\n * Block used to expose an input value\n */\nexport class InputBlock extends NodeMaterialBlock {\n    /**\n     * Gets or sets the connection point type (default is float)\n     */\n    get type() {\n        if (this._type === NodeMaterialBlockConnectionPointTypes.AutoDetect) {\n            if (this.isUniform && this.value != null) {\n                if (!isNaN(this.value)) {\n                    this._type = NodeMaterialBlockConnectionPointTypes.Float;\n                    return this._type;\n                }\n                switch (this.value.getClassName()) {\n                    case \"Vector2\":\n                        this._type = NodeMaterialBlockConnectionPointTypes.Vector2;\n                        return this._type;\n                    case \"Vector3\":\n                        this._type = NodeMaterialBlockConnectionPointTypes.Vector3;\n                        return this._type;\n                    case \"Vector4\":\n                        this._type = NodeMaterialBlockConnectionPointTypes.Vector4;\n                        return this._type;\n                    case \"Color3\":\n                        this._type = NodeMaterialBlockConnectionPointTypes.Color3;\n                        return this._type;\n                    case \"Color4\":\n                        this._type = NodeMaterialBlockConnectionPointTypes.Color4;\n                        return this._type;\n                    case \"Matrix\":\n                        this._type = NodeMaterialBlockConnectionPointTypes.Matrix;\n                        return this._type;\n                }\n            }\n            if (this.isAttribute) {\n                switch (this.name) {\n                    case \"position\":\n                    case \"normal\":\n                    case \"particle_positionw\":\n                        this._type = NodeMaterialBlockConnectionPointTypes.Vector3;\n                        return this._type;\n                    case \"uv\":\n                    case \"uv2\":\n                    case \"uv3\":\n                    case \"uv4\":\n                    case \"uv5\":\n                    case \"uv6\":\n                    case \"position2d\":\n                    case \"particle_uv\":\n                        this._type = NodeMaterialBlockConnectionPointTypes.Vector2;\n                        return this._type;\n                    case \"matricesIndices\":\n                    case \"matricesWeights\":\n                    case \"world0\":\n                    case \"world1\":\n                    case \"world2\":\n                    case \"world3\":\n                    case \"tangent\":\n                        this._type = NodeMaterialBlockConnectionPointTypes.Vector4;\n                        return this._type;\n                    case \"color\":\n                    case \"instanceColor\":\n                    case \"particle_color\":\n                    case \"particle_texturemask\":\n                        this._type = NodeMaterialBlockConnectionPointTypes.Color4;\n                        return this._type;\n                }\n            }\n            if (this.isSystemValue) {\n                switch (this._systemValue) {\n                    case NodeMaterialSystemValues.World:\n                    case NodeMaterialSystemValues.WorldView:\n                    case NodeMaterialSystemValues.WorldViewProjection:\n                    case NodeMaterialSystemValues.View:\n                    case NodeMaterialSystemValues.ViewProjection:\n                    case NodeMaterialSystemValues.Projection:\n                        this._type = NodeMaterialBlockConnectionPointTypes.Matrix;\n                        return this._type;\n                    case NodeMaterialSystemValues.CameraPosition:\n                        this._type = NodeMaterialBlockConnectionPointTypes.Vector3;\n                        return this._type;\n                    case NodeMaterialSystemValues.FogColor:\n                        this._type = NodeMaterialBlockConnectionPointTypes.Color3;\n                        return this._type;\n                    case NodeMaterialSystemValues.DeltaTime:\n                    case NodeMaterialSystemValues.MaterialAlpha:\n                        this._type = NodeMaterialBlockConnectionPointTypes.Float;\n                        return this._type;\n                    case NodeMaterialSystemValues.CameraParameters:\n                        this._type = NodeMaterialBlockConnectionPointTypes.Vector4;\n                        return this._type;\n                }\n            }\n        }\n        return this._type;\n    }\n    /**\n     * Creates a new InputBlock\n     * @param name defines the block name\n     * @param target defines the target of that block (Vertex by default)\n     * @param type defines the type of the input (can be set to NodeMaterialBlockConnectionPointTypes.AutoDetect)\n     */\n    constructor(name, target = NodeMaterialBlockTargets.Vertex, type = NodeMaterialBlockConnectionPointTypes.AutoDetect) {\n        super(name, target, false, true);\n        this._mode = NodeMaterialBlockConnectionPointMode.Undefined;\n        this._animationType = AnimatedInputBlockTypes.None;\n        /** Gets or set a value used to limit the range of float values */\n        this.min = 0;\n        /** Gets or set a value used to limit the range of float values */\n        this.max = 0;\n        /** Gets or set a value indicating that this input can only get 0 and 1 values */\n        this.isBoolean = false;\n        /** Gets or sets a value used by the Node Material editor to determine how to configure the current value if it is a matrix */\n        this.matrixMode = 0;\n        /** @internal */\n        this._systemValue = null;\n        /** Gets or sets a boolean indicating that the value of this input will not change after a build */\n        this.isConstant = false;\n        /** Gets or sets the group to use to display this block in the Inspector */\n        this.groupInInspector = \"\";\n        /** Gets an observable raised when the value is changed */\n        this.onValueChangedObservable = new Observable();\n        /** Gets or sets a boolean indicating if content needs to be converted to gamma space (for color3/4 only) */\n        this.convertToGammaSpace = false;\n        /** Gets or sets a boolean indicating if content needs to be converted to linear space (for color3/4 only) */\n        this.convertToLinearSpace = false;\n        this._type = type;\n        this.setDefaultValue();\n        this.registerOutput(\"output\", type);\n    }\n    /**\n     * Validates if a name is a reserve word.\n     * @param newName the new name to be given to the node.\n     * @returns false if the name is a reserve word, else true.\n     */\n    validateBlockName(newName) {\n        if (!this.isAttribute) {\n            return super.validateBlockName(newName);\n        }\n        return true;\n    }\n    /**\n     * Gets the output component\n     */\n    get output() {\n        return this._outputs[0];\n    }\n    /**\n     * Set the source of this connection point to a vertex attribute\n     * @param attributeName defines the attribute name (position, uv, normal, etc...). If not specified it will take the connection point name\n     * @returns the current connection point\n     */\n    setAsAttribute(attributeName) {\n        this._mode = NodeMaterialBlockConnectionPointMode.Attribute;\n        if (attributeName) {\n            this.name = attributeName;\n        }\n        return this;\n    }\n    /**\n     * Set the source of this connection point to a system value\n     * @param value define the system value to use (world, view, etc...) or null to switch to manual value\n     * @returns the current connection point\n     */\n    setAsSystemValue(value) {\n        this.systemValue = value;\n        return this;\n    }\n    /**\n     * Gets or sets the value of that point.\n     * Please note that this value will be ignored if valueCallback is defined\n     */\n    get value() {\n        return this._storedValue;\n    }\n    set value(value) {\n        if (this.type === NodeMaterialBlockConnectionPointTypes.Float) {\n            if (this.isBoolean) {\n                value = value ? 1 : 0;\n            }\n            else if (this.min !== this.max) {\n                value = Math.max(this.min, value);\n                value = Math.min(this.max, value);\n            }\n        }\n        this._storedValue = value;\n        this._mode = NodeMaterialBlockConnectionPointMode.Uniform;\n        this.onValueChangedObservable.notifyObservers(this);\n    }\n    /**\n     * Gets or sets a callback used to get the value of that point.\n     * Please note that setting this value will force the connection point to ignore the value property\n     */\n    get valueCallback() {\n        return this._valueCallback;\n    }\n    set valueCallback(value) {\n        this._valueCallback = value;\n        this._mode = NodeMaterialBlockConnectionPointMode.Uniform;\n    }\n    /**\n     * Gets or sets the associated variable name in the shader\n     */\n    get associatedVariableName() {\n        return this._associatedVariableName;\n    }\n    set associatedVariableName(value) {\n        this._associatedVariableName = value;\n    }\n    /** Gets or sets the type of animation applied to the input */\n    get animationType() {\n        return this._animationType;\n    }\n    set animationType(value) {\n        this._animationType = value;\n    }\n    /**\n     * Gets a boolean indicating that this connection point not defined yet\n     */\n    get isUndefined() {\n        return this._mode === NodeMaterialBlockConnectionPointMode.Undefined;\n    }\n    /**\n     * Gets or sets a boolean indicating that this connection point is coming from an uniform.\n     * In this case the connection point name must be the name of the uniform to use.\n     * Can only be set on inputs\n     */\n    get isUniform() {\n        return this._mode === NodeMaterialBlockConnectionPointMode.Uniform;\n    }\n    set isUniform(value) {\n        this._mode = value ? NodeMaterialBlockConnectionPointMode.Uniform : NodeMaterialBlockConnectionPointMode.Undefined;\n        this.associatedVariableName = \"\";\n    }\n    /**\n     * Gets or sets a boolean indicating that this connection point is coming from an attribute.\n     * In this case the connection point name must be the name of the attribute to use\n     * Can only be set on inputs\n     */\n    get isAttribute() {\n        return this._mode === NodeMaterialBlockConnectionPointMode.Attribute;\n    }\n    set isAttribute(value) {\n        this._mode = value ? NodeMaterialBlockConnectionPointMode.Attribute : NodeMaterialBlockConnectionPointMode.Undefined;\n        this.associatedVariableName = \"\";\n    }\n    /**\n     * Gets or sets a boolean indicating that this connection point is generating a varying variable.\n     * Can only be set on exit points\n     */\n    get isVarying() {\n        return this._mode === NodeMaterialBlockConnectionPointMode.Varying;\n    }\n    set isVarying(value) {\n        this._mode = value ? NodeMaterialBlockConnectionPointMode.Varying : NodeMaterialBlockConnectionPointMode.Undefined;\n        this.associatedVariableName = \"\";\n    }\n    /**\n     * Gets a boolean indicating that the current connection point is a system value\n     */\n    get isSystemValue() {\n        return this._systemValue != null;\n    }\n    /**\n     * Gets or sets the current well known value or null if not defined as a system value\n     */\n    get systemValue() {\n        return this._systemValue;\n    }\n    set systemValue(value) {\n        this._mode = NodeMaterialBlockConnectionPointMode.Uniform;\n        this.associatedVariableName = \"\";\n        this._systemValue = value;\n    }\n    /**\n     * Gets the current class name\n     * @returns the class name\n     */\n    getClassName() {\n        return \"InputBlock\";\n    }\n    /**\n     * Animate the input if animationType !== None\n     * @param scene defines the rendering scene\n     */\n    animate(scene) {\n        switch (this._animationType) {\n            case AnimatedInputBlockTypes.Time: {\n                if (this.type === NodeMaterialBlockConnectionPointTypes.Float) {\n                    this.value += scene.getAnimationRatio() * 0.01;\n                }\n                break;\n            }\n            case AnimatedInputBlockTypes.RealTime: {\n                if (this.type === NodeMaterialBlockConnectionPointTypes.Float) {\n                    this.value = (PrecisionDate.Now - scene.getEngine().startTime) / 1000;\n                }\n                break;\n            }\n        }\n    }\n    _emitDefine(define) {\n        if (define[0] === \"!\") {\n            return `#ifndef ${define.substring(1)}\\r\\n`;\n        }\n        return `#ifdef ${define}\\r\\n`;\n    }\n    initialize() {\n        this.associatedVariableName = \"\";\n    }\n    /**\n     * Set the input block to its default value (based on its type)\n     */\n    setDefaultValue() {\n        switch (this.type) {\n            case NodeMaterialBlockConnectionPointTypes.Float:\n                this.value = 0;\n                break;\n            case NodeMaterialBlockConnectionPointTypes.Vector2:\n                this.value = Vector2.Zero();\n                break;\n            case NodeMaterialBlockConnectionPointTypes.Vector3:\n                this.value = Vector3.Zero();\n                break;\n            case NodeMaterialBlockConnectionPointTypes.Vector4:\n                this.value = Vector4.Zero();\n                break;\n            case NodeMaterialBlockConnectionPointTypes.Color3:\n                this.value = Color3.White();\n                break;\n            case NodeMaterialBlockConnectionPointTypes.Color4:\n                this.value = new Color4(1, 1, 1, 1);\n                break;\n            case NodeMaterialBlockConnectionPointTypes.Matrix:\n                this.value = Matrix.Identity();\n                break;\n        }\n    }\n    _emitConstant(state) {\n        switch (this.type) {\n            case NodeMaterialBlockConnectionPointTypes.Float:\n                return `${state._emitFloat(this.value)}`;\n            case NodeMaterialBlockConnectionPointTypes.Vector2:\n                return `vec2(${this.value.x}, ${this.value.y})`;\n            case NodeMaterialBlockConnectionPointTypes.Vector3:\n                return `vec3(${this.value.x}, ${this.value.y}, ${this.value.z})`;\n            case NodeMaterialBlockConnectionPointTypes.Vector4:\n                return `vec4(${this.value.x}, ${this.value.y}, ${this.value.z}, ${this.value.w})`;\n            case NodeMaterialBlockConnectionPointTypes.Color3:\n                TmpColors.Color3[0].set(this.value.r, this.value.g, this.value.b);\n                if (this.convertToGammaSpace) {\n                    TmpColors.Color3[0].toGammaSpaceToRef(TmpColors.Color3[0]);\n                }\n                if (this.convertToLinearSpace) {\n                    TmpColors.Color3[0].toLinearSpaceToRef(TmpColors.Color3[0]);\n                }\n                return `vec3(${TmpColors.Color3[0].r}, ${TmpColors.Color3[0].g}, ${TmpColors.Color3[0].b})`;\n            case NodeMaterialBlockConnectionPointTypes.Color4:\n                TmpColors.Color4[0].set(this.value.r, this.value.g, this.value.b, this.value.a);\n                if (this.convertToGammaSpace) {\n                    TmpColors.Color4[0].toGammaSpaceToRef(TmpColors.Color4[0]);\n                }\n                if (this.convertToLinearSpace) {\n                    TmpColors.Color4[0].toLinearSpaceToRef(TmpColors.Color4[0]);\n                }\n                return `vec4(${TmpColors.Color4[0].r}, ${TmpColors.Color4[0].g}, ${TmpColors.Color4[0].b}, ${TmpColors.Color4[0].a})`;\n        }\n        return \"\";\n    }\n    /** @internal */\n    get _noContextSwitch() {\n        return attributeInFragmentOnly[this.name];\n    }\n    _emit(state, define) {\n        var _a;\n        // Uniforms\n        if (this.isUniform) {\n            if (!this.associatedVariableName) {\n                this.associatedVariableName = state._getFreeVariableName(\"u_\" + this.name);\n            }\n            if (this.isConstant) {\n                if (state.constants.indexOf(this.associatedVariableName) !== -1) {\n                    return;\n                }\n                state.constants.push(this.associatedVariableName);\n                state._constantDeclaration += this._declareOutput(this.output, state) + ` = ${this._emitConstant(state)};\\r\\n`;\n                return;\n            }\n            if (state.uniforms.indexOf(this.associatedVariableName) !== -1) {\n                return;\n            }\n            state.uniforms.push(this.associatedVariableName);\n            if (define) {\n                state._uniformDeclaration += this._emitDefine(define);\n            }\n            state._uniformDeclaration += `uniform ${state._getGLType(this.type)} ${this.associatedVariableName};\\r\\n`;\n            if (define) {\n                state._uniformDeclaration += `#endif\\r\\n`;\n            }\n            // well known\n            const hints = state.sharedData.hints;\n            if (this._systemValue !== null && this._systemValue !== undefined) {\n                switch (this._systemValue) {\n                    case NodeMaterialSystemValues.WorldView:\n                        hints.needWorldViewMatrix = true;\n                        break;\n                    case NodeMaterialSystemValues.WorldViewProjection:\n                        hints.needWorldViewProjectionMatrix = true;\n                        break;\n                }\n            }\n            else {\n                if (this._animationType !== AnimatedInputBlockTypes.None) {\n                    state.sharedData.animatedInputs.push(this);\n                }\n            }\n            return;\n        }\n        // Attribute\n        if (this.isAttribute) {\n            this.associatedVariableName = (_a = remapAttributeName[this.name]) !== null && _a !== void 0 ? _a : this.name;\n            if (this.target === NodeMaterialBlockTargets.Vertex && state._vertexState) {\n                // Attribute for fragment need to be carried over by varyings\n                if (attributeInFragmentOnly[this.name]) {\n                    if (attributeAsUniform[this.name]) {\n                        state._emitUniformFromString(this.associatedVariableName, state._getGLType(this.type), define);\n                    }\n                    else {\n                        state._emitVaryingFromString(this.associatedVariableName, state._getGLType(this.type), define);\n                    }\n                }\n                else {\n                    this._emit(state._vertexState, define);\n                }\n                return;\n            }\n            if (state.attributes.indexOf(this.associatedVariableName) !== -1) {\n                return;\n            }\n            state.attributes.push(this.associatedVariableName);\n            if (attributeInFragmentOnly[this.name]) {\n                if (attributeAsUniform[this.name]) {\n                    state._emitUniformFromString(this.associatedVariableName, state._getGLType(this.type), define);\n                }\n                else {\n                    state._emitVaryingFromString(this.associatedVariableName, state._getGLType(this.type), define);\n                }\n            }\n            else {\n                if (define) {\n                    state._attributeDeclaration += this._emitDefine(define);\n                }\n                state._attributeDeclaration += `attribute ${state._getGLType(this.type)} ${this.associatedVariableName};\\r\\n`;\n                if (define) {\n                    state._attributeDeclaration += `#endif\\r\\n`;\n                }\n            }\n        }\n    }\n    /**\n     * @internal\n     */\n    _transmitWorld(effect, world, worldView, worldViewProjection) {\n        if (!this._systemValue) {\n            return;\n        }\n        const variableName = this.associatedVariableName;\n        switch (this._systemValue) {\n            case NodeMaterialSystemValues.World:\n                effect.setMatrix(variableName, world);\n                break;\n            case NodeMaterialSystemValues.WorldView:\n                effect.setMatrix(variableName, worldView);\n                break;\n            case NodeMaterialSystemValues.WorldViewProjection:\n                effect.setMatrix(variableName, worldViewProjection);\n                break;\n        }\n    }\n    /**\n     * @internal\n     */\n    _transmit(effect, scene, material) {\n        if (this.isAttribute) {\n            return;\n        }\n        const variableName = this.associatedVariableName;\n        if (this._systemValue) {\n            switch (this._systemValue) {\n                case NodeMaterialSystemValues.World:\n                case NodeMaterialSystemValues.WorldView:\n                case NodeMaterialSystemValues.WorldViewProjection:\n                    return;\n                case NodeMaterialSystemValues.View:\n                    effect.setMatrix(variableName, scene.getViewMatrix());\n                    break;\n                case NodeMaterialSystemValues.Projection:\n                    effect.setMatrix(variableName, scene.getProjectionMatrix());\n                    break;\n                case NodeMaterialSystemValues.ViewProjection:\n                    effect.setMatrix(variableName, scene.getTransformMatrix());\n                    break;\n                case NodeMaterialSystemValues.CameraPosition:\n                    scene.bindEyePosition(effect, variableName, true);\n                    break;\n                case NodeMaterialSystemValues.FogColor:\n                    effect.setColor3(variableName, scene.fogColor);\n                    break;\n                case NodeMaterialSystemValues.DeltaTime:\n                    effect.setFloat(variableName, scene.deltaTime / 1000.0);\n                    break;\n                case NodeMaterialSystemValues.CameraParameters:\n                    if (scene.activeCamera) {\n                        effect.setFloat4(variableName, scene.getEngine().hasOriginBottomLeft ? -1 : 1, scene.activeCamera.minZ, scene.activeCamera.maxZ, 1 / scene.activeCamera.maxZ);\n                    }\n                    break;\n                case NodeMaterialSystemValues.MaterialAlpha:\n                    effect.setFloat(variableName, material.alpha);\n                    break;\n            }\n            return;\n        }\n        const value = this._valueCallback ? this._valueCallback() : this._storedValue;\n        if (value === null) {\n            return;\n        }\n        switch (this.type) {\n            case NodeMaterialBlockConnectionPointTypes.Float:\n                effect.setFloat(variableName, value);\n                break;\n            case NodeMaterialBlockConnectionPointTypes.Int:\n                effect.setInt(variableName, value);\n                break;\n            case NodeMaterialBlockConnectionPointTypes.Color3:\n                TmpColors.Color3[0].set(this.value.r, this.value.g, this.value.b);\n                if (this.convertToGammaSpace) {\n                    TmpColors.Color3[0].toGammaSpaceToRef(TmpColors.Color3[0]);\n                }\n                if (this.convertToLinearSpace) {\n                    TmpColors.Color3[0].toLinearSpaceToRef(TmpColors.Color3[0]);\n                }\n                effect.setColor3(variableName, TmpColors.Color3[0]);\n                break;\n            case NodeMaterialBlockConnectionPointTypes.Color4:\n                TmpColors.Color4[0].set(this.value.r, this.value.g, this.value.b, this.value.a);\n                if (this.convertToGammaSpace) {\n                    TmpColors.Color4[0].toGammaSpaceToRef(TmpColors.Color4[0]);\n                }\n                if (this.convertToLinearSpace) {\n                    TmpColors.Color4[0].toLinearSpaceToRef(TmpColors.Color4[0]);\n                }\n                effect.setDirectColor4(variableName, TmpColors.Color4[0]);\n                break;\n            case NodeMaterialBlockConnectionPointTypes.Vector2:\n                effect.setVector2(variableName, value);\n                break;\n            case NodeMaterialBlockConnectionPointTypes.Vector3:\n                effect.setVector3(variableName, value);\n                break;\n            case NodeMaterialBlockConnectionPointTypes.Vector4:\n                effect.setVector4(variableName, value);\n                break;\n            case NodeMaterialBlockConnectionPointTypes.Matrix:\n                effect.setMatrix(variableName, value);\n                break;\n        }\n    }\n    _buildBlock(state) {\n        super._buildBlock(state);\n        if (this.isUniform || this.isSystemValue) {\n            state.sharedData.inputBlocks.push(this);\n        }\n        this._emit(state);\n    }\n    _dumpPropertiesCode() {\n        const variableName = this._codeVariableName;\n        if (this.isAttribute) {\n            return super._dumpPropertiesCode() + `${variableName}.setAsAttribute(\"${this.name}\");\\r\\n`;\n        }\n        if (this.isSystemValue) {\n            return super._dumpPropertiesCode() + `${variableName}.setAsSystemValue(BABYLON.NodeMaterialSystemValues.${NodeMaterialSystemValues[this._systemValue]});\\r\\n`;\n        }\n        if (this.isUniform) {\n            const codes = [];\n            let valueString = \"\";\n            switch (this.type) {\n                case NodeMaterialBlockConnectionPointTypes.Float:\n                    valueString = `${this.value}`;\n                    break;\n                case NodeMaterialBlockConnectionPointTypes.Vector2:\n                    valueString = `new BABYLON.Vector2(${this.value.x}, ${this.value.y})`;\n                    break;\n                case NodeMaterialBlockConnectionPointTypes.Vector3:\n                    valueString = `new BABYLON.Vector3(${this.value.x}, ${this.value.y}, ${this.value.z})`;\n                    break;\n                case NodeMaterialBlockConnectionPointTypes.Vector4:\n                    valueString = `new BABYLON.Vector4(${this.value.x}, ${this.value.y}, ${this.value.z}, ${this.value.w})`;\n                    break;\n                case NodeMaterialBlockConnectionPointTypes.Color3:\n                    valueString = `new BABYLON.Color3(${this.value.r}, ${this.value.g}, ${this.value.b})`;\n                    if (this.convertToGammaSpace) {\n                        valueString += \".toGammaSpace()\";\n                    }\n                    if (this.convertToLinearSpace) {\n                        valueString += \".toLinearSpace()\";\n                    }\n                    break;\n                case NodeMaterialBlockConnectionPointTypes.Color4:\n                    valueString = `new BABYLON.Color4(${this.value.r}, ${this.value.g}, ${this.value.b}, ${this.value.a})`;\n                    if (this.convertToGammaSpace) {\n                        valueString += \".toGammaSpace()\";\n                    }\n                    if (this.convertToLinearSpace) {\n                        valueString += \".toLinearSpace()\";\n                    }\n                    break;\n                case NodeMaterialBlockConnectionPointTypes.Matrix:\n                    valueString = `BABYLON.Matrix.FromArray([${this.value.m}])`;\n                    break;\n            }\n            // Common Property \"Value\"\n            codes.push(`${variableName}.value = ${valueString}`);\n            // Float-Value-Specific Properties\n            if (this.type === NodeMaterialBlockConnectionPointTypes.Float) {\n                codes.push(`${variableName}.min = ${this.min}`, `${variableName}.max = ${this.max}`, `${variableName}.isBoolean = ${this.isBoolean}`, `${variableName}.matrixMode = ${this.matrixMode}`, `${variableName}.animationType = BABYLON.AnimatedInputBlockTypes.${AnimatedInputBlockTypes[this.animationType]}`);\n            }\n            // Common Property \"Type\"\n            codes.push(`${variableName}.isConstant = ${this.isConstant}`);\n            codes.push(\"\");\n            return super._dumpPropertiesCode() + codes.join(\";\\r\\n\");\n        }\n        return super._dumpPropertiesCode();\n    }\n    dispose() {\n        this.onValueChangedObservable.clear();\n        super.dispose();\n    }\n    serialize() {\n        const serializationObject = super.serialize();\n        serializationObject.type = this.type;\n        serializationObject.mode = this._mode;\n        serializationObject.systemValue = this._systemValue;\n        serializationObject.animationType = this._animationType;\n        serializationObject.min = this.min;\n        serializationObject.max = this.max;\n        serializationObject.isBoolean = this.isBoolean;\n        serializationObject.matrixMode = this.matrixMode;\n        serializationObject.isConstant = this.isConstant;\n        serializationObject.groupInInspector = this.groupInInspector;\n        serializationObject.convertToGammaSpace = this.convertToGammaSpace;\n        serializationObject.convertToLinearSpace = this.convertToLinearSpace;\n        if (this._storedValue != null && this._mode === NodeMaterialBlockConnectionPointMode.Uniform) {\n            if (this._storedValue.asArray) {\n                serializationObject.valueType = \"BABYLON.\" + this._storedValue.getClassName();\n                serializationObject.value = this._storedValue.asArray();\n            }\n            else {\n                serializationObject.valueType = \"number\";\n                serializationObject.value = this._storedValue;\n            }\n        }\n        return serializationObject;\n    }\n    _deserialize(serializationObject, scene, rootUrl) {\n        this._mode = serializationObject.mode;\n        super._deserialize(serializationObject, scene, rootUrl);\n        this._type = serializationObject.type;\n        this._systemValue = serializationObject.systemValue || serializationObject.wellKnownValue;\n        this._animationType = serializationObject.animationType;\n        this.min = serializationObject.min || 0;\n        this.max = serializationObject.max || 0;\n        this.isBoolean = !!serializationObject.isBoolean;\n        this.matrixMode = serializationObject.matrixMode || 0;\n        this.isConstant = !!serializationObject.isConstant;\n        this.groupInInspector = serializationObject.groupInInspector || \"\";\n        this.convertToGammaSpace = !!serializationObject.convertToGammaSpace;\n        this.convertToLinearSpace = !!serializationObject.convertToLinearSpace;\n        // Tangents back compat\n        if (serializationObject.name === \"tangent\" &&\n            serializationObject.mode === NodeMaterialBlockConnectionPointMode.Attribute &&\n            serializationObject.type === NodeMaterialBlockConnectionPointTypes.Vector3) {\n            this._type = NodeMaterialBlockConnectionPointTypes.Vector4;\n        }\n        if (!serializationObject.valueType) {\n            return;\n        }\n        if (serializationObject.valueType === \"number\") {\n            this._storedValue = serializationObject.value;\n        }\n        else {\n            const valueType = GetClass(serializationObject.valueType);\n            if (valueType) {\n                this._storedValue = valueType.FromArray(serializationObject.value);\n            }\n        }\n    }\n}\nRegisterClass(\"BABYLON.InputBlock\", InputBlock);\n//# sourceMappingURL=inputBlock.js.map","import { NodeMaterialBlock } from \"../../nodeMaterialBlock.js\";\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes.js\";\nimport { NodeMaterialConnectionPointDirection } from \"../../nodeMaterialBlockConnectionPoint.js\";\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets.js\";\nimport { RegisterClass } from \"../../../../Misc/typeStore.js\";\nimport { NodeMaterialConnectionPointCustomObject } from \"../../nodeMaterialConnectionPointCustomObject.js\";\nimport { TBNBlock } from \"../Fragment/TBNBlock.js\";\n/**\n * Block used to implement the anisotropy module of the PBR material\n */\nexport class AnisotropyBlock extends NodeMaterialBlock {\n    /**\n     * Create a new AnisotropyBlock\n     * @param name defines the block name\n     */\n    constructor(name) {\n        super(name, NodeMaterialBlockTargets.Fragment);\n        this._tangentCorrectionFactorName = \"\";\n        this._isUnique = true;\n        this.registerInput(\"intensity\", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);\n        this.registerInput(\"direction\", NodeMaterialBlockConnectionPointTypes.Vector2, true, NodeMaterialBlockTargets.Fragment);\n        this.registerInput(\"uv\", NodeMaterialBlockConnectionPointTypes.Vector2, true); // need this property and the next one in case there's no PerturbNormal block connected to the main PBR block\n        this.registerInput(\"worldTangent\", NodeMaterialBlockConnectionPointTypes.Vector4, true);\n        this.registerInput(\"TBN\", NodeMaterialBlockConnectionPointTypes.Object, true, NodeMaterialBlockTargets.VertexAndFragment, new NodeMaterialConnectionPointCustomObject(\"TBN\", this, NodeMaterialConnectionPointDirection.Input, TBNBlock, \"TBNBlock\"));\n        this.registerOutput(\"anisotropy\", NodeMaterialBlockConnectionPointTypes.Object, NodeMaterialBlockTargets.Fragment, new NodeMaterialConnectionPointCustomObject(\"anisotropy\", this, NodeMaterialConnectionPointDirection.Output, AnisotropyBlock, \"AnisotropyBlock\"));\n    }\n    /**\n     * Initialize the block and prepare the context for build\n     * @param state defines the state that will be used for the build\n     */\n    initialize(state) {\n        state._excludeVariableName(\"anisotropicOut\");\n        state._excludeVariableName(\"TBN\");\n    }\n    /**\n     * Gets the current class name\n     * @returns the class name\n     */\n    getClassName() {\n        return \"AnisotropyBlock\";\n    }\n    /**\n     * Gets the intensity input component\n     */\n    get intensity() {\n        return this._inputs[0];\n    }\n    /**\n     * Gets the direction input component\n     */\n    get direction() {\n        return this._inputs[1];\n    }\n    /**\n     * Gets the uv input component\n     */\n    get uv() {\n        return this._inputs[2];\n    }\n    /**\n     * Gets the worldTangent input component\n     */\n    get worldTangent() {\n        return this._inputs[3];\n    }\n    /**\n     * Gets the TBN input component\n     */\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    get TBN() {\n        return this._inputs[4];\n    }\n    /**\n     * Gets the anisotropy object output component\n     */\n    get anisotropy() {\n        return this._outputs[0];\n    }\n    _generateTBNSpace(state) {\n        let code = \"\";\n        const comments = `//${this.name}`;\n        const uv = this.uv;\n        const worldPosition = this.worldPositionConnectionPoint;\n        const worldNormal = this.worldNormalConnectionPoint;\n        const worldTangent = this.worldTangent;\n        if (!uv.isConnected) {\n            // we must set the uv input as optional because we may not end up in this method (in case a PerturbNormal block is linked to the PBR material)\n            // in which case uv is not required. But if we do come here, we do need the uv, so we have to raise an error but not with throw, else\n            // it will stop the building of the node material and will lead to errors in the editor!\n            console.error(\"You must connect the 'uv' input of the Anisotropy block!\");\n        }\n        state._emitExtension(\"derivatives\", \"#extension GL_OES_standard_derivatives : enable\");\n        const tangentReplaceString = { search: /defined\\(TANGENT\\)/g, replace: worldTangent.isConnected ? \"defined(TANGENT)\" : \"defined(IGNORE)\" };\n        const TBN = this.TBN;\n        if (TBN.isConnected) {\n            state.compilationString += `\r\n            #ifdef TBNBLOCK\r\n            mat3 vTBN = ${TBN.associatedVariableName};\r\n            #endif\r\n            `;\n        }\n        else if (worldTangent.isConnected) {\n            code += `vec3 tbnNormal = normalize(${worldNormal.associatedVariableName}.xyz);\\r\\n`;\n            code += `vec3 tbnTangent = normalize(${worldTangent.associatedVariableName}.xyz);\\r\\n`;\n            code += `vec3 tbnBitangent = cross(tbnNormal, tbnTangent) * ${this._tangentCorrectionFactorName};\\r\\n`;\n            code += `mat3 vTBN = mat3(tbnTangent, tbnBitangent, tbnNormal);\\r\\n`;\n        }\n        code += `\r\n            #if defined(${worldTangent.isConnected ? \"TANGENT\" : \"IGNORE\"}) && defined(NORMAL)\r\n                mat3 TBN = vTBN;\r\n            #else\r\n                mat3 TBN = cotangent_frame(${worldNormal.associatedVariableName + \".xyz\"}, ${\"v_\" + worldPosition.associatedVariableName + \".xyz\"}, ${uv.isConnected ? uv.associatedVariableName : \"vec2(0.)\"}, vec2(1., 1.));\r\n            #endif\\r\\n`;\n        state._emitFunctionFromInclude(\"bumpFragmentMainFunctions\", comments, {\n            replaceStrings: [tangentReplaceString],\n        });\n        return code;\n    }\n    /**\n     * Gets the main code of the block (fragment side)\n     * @param state current state of the node material building\n     * @param generateTBNSpace if true, the code needed to create the TBN coordinate space is generated\n     * @returns the shader code\n     */\n    getCode(state, generateTBNSpace = false) {\n        let code = \"\";\n        if (generateTBNSpace) {\n            code += this._generateTBNSpace(state);\n        }\n        const intensity = this.intensity.isConnected ? this.intensity.associatedVariableName : \"1.0\";\n        const direction = this.direction.isConnected ? this.direction.associatedVariableName : \"vec2(1., 0.)\";\n        code += `anisotropicOutParams anisotropicOut;\r\n            anisotropicBlock(\r\n                vec3(${direction}, ${intensity}),\r\n            #ifdef ANISOTROPIC_TEXTURE\r\n                vec3(0.),\r\n            #endif\r\n                TBN,\r\n                normalW,\r\n                viewDirectionW,\r\n                anisotropicOut\r\n            );\\r\\n`;\n        return code;\n    }\n    prepareDefines(mesh, nodeMaterial, defines) {\n        super.prepareDefines(mesh, nodeMaterial, defines);\n        defines.setValue(\"ANISOTROPIC\", true);\n        defines.setValue(\"ANISOTROPIC_TEXTURE\", false, true);\n    }\n    bind(effect, nodeMaterial, mesh) {\n        super.bind(effect, nodeMaterial, mesh);\n        if (mesh) {\n            effect.setFloat(this._tangentCorrectionFactorName, mesh.getWorldMatrix().determinant() < 0 ? -1 : 1);\n        }\n    }\n    _buildBlock(state) {\n        if (state.target === NodeMaterialBlockTargets.Fragment) {\n            state.sharedData.blocksWithDefines.push(this);\n            state.sharedData.bindableBlocks.push(this);\n            this._tangentCorrectionFactorName = state._getFreeDefineName(\"tangentCorrectionFactor\");\n            state._emitUniformFromString(this._tangentCorrectionFactorName, \"float\");\n        }\n        return this;\n    }\n}\nRegisterClass(\"BABYLON.AnisotropyBlock\", AnisotropyBlock);\n//# sourceMappingURL=anisotropyBlock.js.map","import { __decorate } from \"../../../../tslib.es6.js\";\nimport { NodeMaterialBlock } from \"../../nodeMaterialBlock.js\";\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes.js\";\nimport { NodeMaterialConnectionPointDirection } from \"../../nodeMaterialBlockConnectionPoint.js\";\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets.js\";\nimport { RegisterClass } from \"../../../../Misc/typeStore.js\";\nimport { InputBlock } from \"../Input/inputBlock.js\";\nimport { NodeMaterialConnectionPointCustomObject } from \"../../nodeMaterialConnectionPointCustomObject.js\";\nimport { PBRClearCoatConfiguration } from \"../../../PBR/pbrClearCoatConfiguration.js\";\nimport { editableInPropertyPage, PropertyTypeForEdition } from \"../../nodeMaterialDecorator.js\";\nimport { TBNBlock } from \"../Fragment/TBNBlock.js\";\n/**\n * Block used to implement the clear coat module of the PBR material\n */\nexport class ClearCoatBlock extends NodeMaterialBlock {\n    /**\n     * Create a new ClearCoatBlock\n     * @param name defines the block name\n     */\n    constructor(name) {\n        super(name, NodeMaterialBlockTargets.Fragment);\n        this._tangentCorrectionFactorName = \"\";\n        /**\n         * Defines if the F0 value should be remapped to account for the interface change in the material.\n         */\n        this.remapF0OnInterfaceChange = true;\n        this._isUnique = true;\n        this.registerInput(\"intensity\", NodeMaterialBlockConnectionPointTypes.Float, false, NodeMaterialBlockTargets.Fragment);\n        this.registerInput(\"roughness\", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);\n        this.registerInput(\"indexOfRefraction\", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);\n        this.registerInput(\"normalMapColor\", NodeMaterialBlockConnectionPointTypes.Color3, true, NodeMaterialBlockTargets.Fragment);\n        this.registerInput(\"uv\", NodeMaterialBlockConnectionPointTypes.Vector2, true, NodeMaterialBlockTargets.Fragment);\n        this.registerInput(\"tintColor\", NodeMaterialBlockConnectionPointTypes.Color3, true, NodeMaterialBlockTargets.Fragment);\n        this.registerInput(\"tintAtDistance\", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);\n        this.registerInput(\"tintThickness\", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);\n        this.registerInput(\"worldTangent\", NodeMaterialBlockConnectionPointTypes.Vector4, true);\n        this.registerInput(\"worldNormal\", NodeMaterialBlockConnectionPointTypes.AutoDetect, true);\n        this.worldNormal.addExcludedConnectionPointFromAllowedTypes(NodeMaterialBlockConnectionPointTypes.Color4 | NodeMaterialBlockConnectionPointTypes.Vector4 | NodeMaterialBlockConnectionPointTypes.Vector3);\n        this.registerInput(\"TBN\", NodeMaterialBlockConnectionPointTypes.Object, true, NodeMaterialBlockTargets.VertexAndFragment, new NodeMaterialConnectionPointCustomObject(\"TBN\", this, NodeMaterialConnectionPointDirection.Input, TBNBlock, \"TBNBlock\"));\n        this.registerOutput(\"clearcoat\", NodeMaterialBlockConnectionPointTypes.Object, NodeMaterialBlockTargets.Fragment, new NodeMaterialConnectionPointCustomObject(\"clearcoat\", this, NodeMaterialConnectionPointDirection.Output, ClearCoatBlock, \"ClearCoatBlock\"));\n    }\n    /**\n     * Initialize the block and prepare the context for build\n     * @param state defines the state that will be used for the build\n     */\n    initialize(state) {\n        state._excludeVariableName(\"clearcoatOut\");\n        state._excludeVariableName(\"vClearCoatParams\");\n        state._excludeVariableName(\"vClearCoatTintParams\");\n        state._excludeVariableName(\"vClearCoatRefractionParams\");\n        state._excludeVariableName(\"vClearCoatTangentSpaceParams\");\n        state._excludeVariableName(\"vGeometricNormaClearCoatW\");\n    }\n    /**\n     * Gets the current class name\n     * @returns the class name\n     */\n    getClassName() {\n        return \"ClearCoatBlock\";\n    }\n    /**\n     * Gets the intensity input component\n     */\n    get intensity() {\n        return this._inputs[0];\n    }\n    /**\n     * Gets the roughness input component\n     */\n    get roughness() {\n        return this._inputs[1];\n    }\n    /**\n     * Gets the ior input component\n     */\n    get indexOfRefraction() {\n        return this._inputs[2];\n    }\n    /**\n     * Gets the bump texture input component\n     */\n    get normalMapColor() {\n        return this._inputs[3];\n    }\n    /**\n     * Gets the uv input component\n     */\n    get uv() {\n        return this._inputs[4];\n    }\n    /**\n     * Gets the tint color input component\n     */\n    get tintColor() {\n        return this._inputs[5];\n    }\n    /**\n     * Gets the tint \"at distance\" input component\n     */\n    get tintAtDistance() {\n        return this._inputs[6];\n    }\n    /**\n     * Gets the tint thickness input component\n     */\n    get tintThickness() {\n        return this._inputs[7];\n    }\n    /**\n     * Gets the world tangent input component\n     */\n    get worldTangent() {\n        return this._inputs[8];\n    }\n    /**\n     * Gets the world normal input component\n     */\n    get worldNormal() {\n        return this._inputs[9];\n    }\n    /**\n     * Gets the TBN input component\n     */\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    get TBN() {\n        return this._inputs[10];\n    }\n    /**\n     * Gets the clear coat object output component\n     */\n    get clearcoat() {\n        return this._outputs[0];\n    }\n    autoConfigure() {\n        if (!this.intensity.isConnected) {\n            const intensityInput = new InputBlock(\"ClearCoat intensity\", NodeMaterialBlockTargets.Fragment, NodeMaterialBlockConnectionPointTypes.Float);\n            intensityInput.value = 1;\n            intensityInput.output.connectTo(this.intensity);\n        }\n    }\n    prepareDefines(mesh, nodeMaterial, defines) {\n        super.prepareDefines(mesh, nodeMaterial, defines);\n        defines.setValue(\"CLEARCOAT\", true);\n        defines.setValue(\"CLEARCOAT_TEXTURE\", false, true);\n        defines.setValue(\"CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE\", true, true);\n        defines.setValue(\"CLEARCOAT_TINT\", this.tintColor.isConnected || this.tintThickness.isConnected || this.tintAtDistance.isConnected, true);\n        defines.setValue(\"CLEARCOAT_BUMP\", this.normalMapColor.isConnected, true);\n        defines.setValue(\"CLEARCOAT_DEFAULTIOR\", this.indexOfRefraction.isConnected ? this.indexOfRefraction.connectInputBlock.value === PBRClearCoatConfiguration._DefaultIndexOfRefraction : true, true);\n        defines.setValue(\"CLEARCOAT_REMAP_F0\", this.remapF0OnInterfaceChange, true);\n    }\n    bind(effect, nodeMaterial, mesh) {\n        var _a, _b;\n        super.bind(effect, nodeMaterial, mesh);\n        // Clear Coat Refraction params\n        const indexOfRefraction = (_b = (_a = this.indexOfRefraction.connectInputBlock) === null || _a === void 0 ? void 0 : _a.value) !== null && _b !== void 0 ? _b : PBRClearCoatConfiguration._DefaultIndexOfRefraction;\n        const a = 1 - indexOfRefraction;\n        const b = 1 + indexOfRefraction;\n        const f0 = Math.pow(-a / b, 2); // Schlicks approx: (ior1 - ior2) / (ior1 + ior2) where ior2 for air is close to vacuum = 1.\n        const eta = 1 / indexOfRefraction;\n        effect.setFloat4(\"vClearCoatRefractionParams\", f0, eta, a, b);\n        // Clear Coat tangent space params\n        const mainPBRBlock = this.clearcoat.hasEndpoints ? this.clearcoat.endpoints[0].ownerBlock : null;\n        const perturbedNormalBlock = (mainPBRBlock === null || mainPBRBlock === void 0 ? void 0 : mainPBRBlock.perturbedNormal.isConnected) ? mainPBRBlock.perturbedNormal.connectedPoint.ownerBlock : null;\n        if (this._scene._mirroredCameraPosition) {\n            effect.setFloat2(\"vClearCoatTangentSpaceParams\", (perturbedNormalBlock === null || perturbedNormalBlock === void 0 ? void 0 : perturbedNormalBlock.invertX) ? 1.0 : -1.0, (perturbedNormalBlock === null || perturbedNormalBlock === void 0 ? void 0 : perturbedNormalBlock.invertY) ? 1.0 : -1.0);\n        }\n        else {\n            effect.setFloat2(\"vClearCoatTangentSpaceParams\", (perturbedNormalBlock === null || perturbedNormalBlock === void 0 ? void 0 : perturbedNormalBlock.invertX) ? -1.0 : 1.0, (perturbedNormalBlock === null || perturbedNormalBlock === void 0 ? void 0 : perturbedNormalBlock.invertY) ? -1.0 : 1.0);\n        }\n        if (mesh) {\n            effect.setFloat(this._tangentCorrectionFactorName, mesh.getWorldMatrix().determinant() < 0 ? -1 : 1);\n        }\n    }\n    _generateTBNSpace(state, worldPositionVarName, worldNormalVarName) {\n        let code = \"\";\n        const comments = `//${this.name}`;\n        const worldTangent = this.worldTangent;\n        state._emitExtension(\"derivatives\", \"#extension GL_OES_standard_derivatives : enable\");\n        const tangentReplaceString = { search: /defined\\(TANGENT\\)/g, replace: worldTangent.isConnected ? \"defined(TANGENT)\" : \"defined(IGNORE)\" };\n        const TBN = this.TBN;\n        if (TBN.isConnected) {\n            state.compilationString += `\r\n            #ifdef TBNBLOCK\r\n            mat3 vTBN = ${TBN.associatedVariableName};\r\n            #endif\r\n            `;\n        }\n        else if (worldTangent.isConnected) {\n            code += `vec3 tbnNormal = normalize(${worldNormalVarName}.xyz);\\r\\n`;\n            code += `vec3 tbnTangent = normalize(${worldTangent.associatedVariableName}.xyz);\\r\\n`;\n            code += `vec3 tbnBitangent = cross(tbnNormal, tbnTangent) * ${this._tangentCorrectionFactorName};\\r\\n`;\n            code += `mat3 vTBN = mat3(tbnTangent, tbnBitangent, tbnNormal);\\r\\n`;\n        }\n        state._emitFunctionFromInclude(\"bumpFragmentMainFunctions\", comments, {\n            replaceStrings: [tangentReplaceString],\n        });\n        return code;\n    }\n    /**\n     * Gets the main code of the block (fragment side)\n     * @param state current state of the node material building\n     * @param ccBlock instance of a ClearCoatBlock or null if the code must be generated without an active clear coat module\n     * @param reflectionBlock instance of a ReflectionBlock null if the code must be generated without an active reflection module\n     * @param worldPosVarName name of the variable holding the world position\n     * @param generateTBNSpace if true, the code needed to create the TBN coordinate space is generated\n     * @param vTBNAvailable indicate that the vTBN variable is already existing because it has already been generated by another block (PerturbNormal or Anisotropy)\n     * @param worldNormalVarName name of the variable holding the world normal\n     * @returns the shader code\n     */\n    static GetCode(state, ccBlock, reflectionBlock, worldPosVarName, generateTBNSpace, vTBNAvailable, worldNormalVarName) {\n        let code = \"\";\n        const intensity = (ccBlock === null || ccBlock === void 0 ? void 0 : ccBlock.intensity.isConnected) ? ccBlock.intensity.associatedVariableName : \"1.\";\n        const roughness = (ccBlock === null || ccBlock === void 0 ? void 0 : ccBlock.roughness.isConnected) ? ccBlock.roughness.associatedVariableName : \"0.\";\n        const normalMapColor = (ccBlock === null || ccBlock === void 0 ? void 0 : ccBlock.normalMapColor.isConnected) ? ccBlock.normalMapColor.associatedVariableName : \"vec3(0.)\";\n        const uv = (ccBlock === null || ccBlock === void 0 ? void 0 : ccBlock.uv.isConnected) ? ccBlock.uv.associatedVariableName : \"vec2(0.)\";\n        const tintColor = (ccBlock === null || ccBlock === void 0 ? void 0 : ccBlock.tintColor.isConnected) ? ccBlock.tintColor.associatedVariableName : \"vec3(1.)\";\n        const tintThickness = (ccBlock === null || ccBlock === void 0 ? void 0 : ccBlock.tintThickness.isConnected) ? ccBlock.tintThickness.associatedVariableName : \"1.\";\n        const tintAtDistance = (ccBlock === null || ccBlock === void 0 ? void 0 : ccBlock.tintAtDistance.isConnected) ? ccBlock.tintAtDistance.associatedVariableName : \"1.\";\n        const tintTexture = \"vec4(0.)\";\n        if (ccBlock) {\n            state._emitUniformFromString(\"vClearCoatRefractionParams\", \"vec4\");\n            state._emitUniformFromString(\"vClearCoatTangentSpaceParams\", \"vec2\");\n            const normalShading = ccBlock.worldNormal;\n            code += `vec3 vGeometricNormaClearCoatW = ${normalShading.isConnected ? \"normalize(\" + normalShading.associatedVariableName + \".xyz)\" : \"geometricNormalW\"};\\r\\n`;\n        }\n        else {\n            code += `vec3 vGeometricNormaClearCoatW = geometricNormalW;\\r\\n`;\n        }\n        if (generateTBNSpace && ccBlock) {\n            code += ccBlock._generateTBNSpace(state, worldPosVarName, worldNormalVarName);\n            vTBNAvailable = ccBlock.worldTangent.isConnected;\n        }\n        code += `clearcoatOutParams clearcoatOut;\r\n\r\n        #ifdef CLEARCOAT\r\n            vec2 vClearCoatParams = vec2(${intensity}, ${roughness});\r\n            vec4 vClearCoatTintParams = vec4(${tintColor}, ${tintThickness});\r\n\r\n            clearcoatBlock(\r\n                ${worldPosVarName}.xyz,\r\n                vGeometricNormaClearCoatW,\r\n                viewDirectionW,\r\n                vClearCoatParams,\r\n                specularEnvironmentR0,\r\n            #ifdef CLEARCOAT_TEXTURE\r\n                vec2(0.),\r\n            #endif\r\n            #ifdef CLEARCOAT_TINT\r\n                vClearCoatTintParams,\r\n                ${tintAtDistance},\r\n                vClearCoatRefractionParams,\r\n                #ifdef CLEARCOAT_TINT_TEXTURE\r\n                    ${tintTexture},\r\n                #endif\r\n            #endif\r\n            #ifdef CLEARCOAT_BUMP\r\n                vec2(0., 1.),\r\n                vec4(${normalMapColor}, 0.),\r\n                ${uv},\r\n                #if defined(${vTBNAvailable ? \"TANGENT\" : \"IGNORE\"}) && defined(NORMAL)\r\n                    vTBN,\r\n                #else\r\n                    vClearCoatTangentSpaceParams,\r\n                #endif\r\n                #ifdef OBJECTSPACE_NORMALMAP\r\n                    normalMatrix,\r\n                #endif\r\n            #endif\r\n            #if defined(FORCENORMALFORWARD) && defined(NORMAL)\r\n                faceNormal,\r\n            #endif\r\n            #ifdef REFLECTION\r\n                ${reflectionBlock === null || reflectionBlock === void 0 ? void 0 : reflectionBlock._vReflectionMicrosurfaceInfosName},\r\n                ${reflectionBlock === null || reflectionBlock === void 0 ? void 0 : reflectionBlock._vReflectionInfosName},\r\n                ${reflectionBlock === null || reflectionBlock === void 0 ? void 0 : reflectionBlock.reflectionColor},\r\n                vLightingIntensity,\r\n                #ifdef ${reflectionBlock === null || reflectionBlock === void 0 ? void 0 : reflectionBlock._define3DName}\r\n                    ${reflectionBlock === null || reflectionBlock === void 0 ? void 0 : reflectionBlock._cubeSamplerName},\r\n                #else\r\n                    ${reflectionBlock === null || reflectionBlock === void 0 ? void 0 : reflectionBlock._2DSamplerName},\r\n                #endif\r\n                #ifndef LODBASEDMICROSFURACE\r\n                    #ifdef ${reflectionBlock === null || reflectionBlock === void 0 ? void 0 : reflectionBlock._define3DName}\r\n                        ${reflectionBlock === null || reflectionBlock === void 0 ? void 0 : reflectionBlock._cubeSamplerName},\r\n                        ${reflectionBlock === null || reflectionBlock === void 0 ? void 0 : reflectionBlock._cubeSamplerName},\r\n                    #else\r\n                        ${reflectionBlock === null || reflectionBlock === void 0 ? void 0 : reflectionBlock._2DSamplerName},\r\n                        ${reflectionBlock === null || reflectionBlock === void 0 ? void 0 : reflectionBlock._2DSamplerName},\r\n                    #endif\r\n                #endif\r\n            #endif\r\n            #if defined(ENVIRONMENTBRDF) && !defined(${reflectionBlock === null || reflectionBlock === void 0 ? void 0 : reflectionBlock._defineSkyboxName})\r\n                #ifdef RADIANCEOCCLUSION\r\n                    ambientMonochrome,\r\n                #endif\r\n            #endif\r\n            #if defined(CLEARCOAT_BUMP) || defined(TWOSIDEDLIGHTING)\r\n                (gl_FrontFacing ? 1. : -1.),\r\n            #endif\r\n                clearcoatOut\r\n            );\r\n        #else\r\n            clearcoatOut.specularEnvironmentR0 = specularEnvironmentR0;\r\n        #endif\\r\\n`;\n        return code;\n    }\n    _buildBlock(state) {\n        this._scene = state.sharedData.scene;\n        if (state.target === NodeMaterialBlockTargets.Fragment) {\n            state.sharedData.bindableBlocks.push(this);\n            state.sharedData.blocksWithDefines.push(this);\n            this._tangentCorrectionFactorName = state._getFreeDefineName(\"tangentCorrectionFactor\");\n            state._emitUniformFromString(this._tangentCorrectionFactorName, \"float\");\n        }\n        return this;\n    }\n    _dumpPropertiesCode() {\n        let codeString = super._dumpPropertiesCode();\n        codeString += `${this._codeVariableName}.remapF0OnInterfaceChange = ${this.remapF0OnInterfaceChange};\\r\\n`;\n        return codeString;\n    }\n    serialize() {\n        const serializationObject = super.serialize();\n        serializationObject.remapF0OnInterfaceChange = this.remapF0OnInterfaceChange;\n        return serializationObject;\n    }\n    _deserialize(serializationObject, scene, rootUrl) {\n        var _a;\n        super._deserialize(serializationObject, scene, rootUrl);\n        this.remapF0OnInterfaceChange = (_a = serializationObject.remapF0OnInterfaceChange) !== null && _a !== void 0 ? _a : true;\n    }\n}\n__decorate([\n    editableInPropertyPage(\"Remap F0 on interface change\", PropertyTypeForEdition.Boolean, \"ADVANCED\")\n], ClearCoatBlock.prototype, \"remapF0OnInterfaceChange\", void 0);\nRegisterClass(\"BABYLON.ClearCoatBlock\", ClearCoatBlock);\n//# sourceMappingURL=clearCoatBlock.js.map"],"names":["LensFlare","static","size","position","color","imgUrl","system","constructor","this","alphaMode","texture","getScene","_system","engine","scene","getEngine","_drawWrapper","effect","createEffect","lensFlares","push","dispose","index","indexOf","splice","LensFlareSystem","_scene","name","emitter","Array","borderLimit","viewportBorder","layerMask","_vertexBuffers","_isEnabled","_SceneComponentInitialization","_emitter","id","lensFlareSystems","meshesSelectionPredicate","m","activeCamera","material","isVisible","isEnabled","isBlocker","vertices","_createIndexBuffer","indices","_indexBuffer","createIndexBuffer","value","getEmitter","setEmitter","newEmitter","getEmitterPosition","getAbsolutePosition","computeEffectivePosition","globalViewport","getTransformMatrix","_positionX","x","_positionY","y","getViewMatrix","width","height","rhs","useRightHandedSystem","z","_isVisible","direction","subtract","globalPosition","distance","length","normalize","ray","pickInfo","pickWithRay","hit","render","viewport","toGlobal","getRenderWidth","getRenderHeight","awayX","awayY","away","intensity","centerX","centerY","distX","distY","setState","setDepthBuffer","flare","isReady","enableEffect","bindBuffers","setAlphaMode","cw","ch","getAspectRatio","cx","cy","viewportMatrix","setMatrix","setTexture","setFloat4","r","g","b","drawElementsType","rebuild","_a","key","_rebuild","vertexBuffer","_releaseBuffer","parsedLensFlareSystem","rootUrl","getLastEntryById","emitterId","lensFlareSystem","flares","parsedFlare","AddFlare","textureName","serialize","serializationObject","asArray","_","parsedData","container","undefined","cache","lf","Parse","getLensFlareSystemById","toRemove","newLensFlareSystem","LensFlareSystemSceneComponent","register","_afterCameraDrawStage","registerStep","_draw","addFromContainer","forEach","o","addLensFlareSystem","removeFromContainer","removeLensFlareSystem","camera","lensFlaresEnabled","component","_getComponent","_addComponent","UpDir","ZeroVec","tmpv1","tmpv2","tmpMatrix","CascadedShadowGenerator","_validateFilter","filter","console","error","numCascades","_numCascades","Math","min","max","MIN_CASCADES_COUNT","MAX_CASCADES_COUNT","recreateShadowMap","_recreateSceneUBOs","freezeShadowCastersBoundingInfo","_freezeShadowCastersBoundingInfo","freeze","_freezeShadowCastersBoundingInfoObservable","onBeforeRenderObservable","remove","add","_computeShadowCastersBoundingInfo","bind","_scbiMin","copyFromFloats","Number","MAX_VALUE","_scbiMax","MIN_VALUE","_shadowMap","renderList","meshIndex","mesh","boundingBox","getBoundingInfo","minimizeInPlace","minimumWorld","maximizeInPlace","maximumWorld","meshes","receiveShadows","_shadowCastersBoundingInfo","reConstruct","shadowCastersBoundingInfo","boundingInfo","setMinMaxDistance","_minDistance","_maxDistance","_breaksAreDirty","minDistance","maxDistance","getClassName","CLASSNAME","getCascadeMinExtents","cascadeIndex","_cascadeMinExtents","getCascadeMaxExtents","_cascadeMaxExtents","shadowMaxZ","_getCamera","_shadowMaxZ","minZ","maxZ","_light","_markMeshesAsLightDirty","debug","_debug","dbg","depthClamp","_depthClamp","cascadeBlendPercentage","_cascadeBlendPercentage","lambda","_lambda","getCascadeViewMatrix","cascadeNum","_viewMatrices","getCascadeProjectionMatrix","_projectionMatrices","getCascadeTransformMatrix","_transformMatrices","setDepthRenderer","depthRenderer","_depthRenderer","_depthReducer","autoCalcDepthBounds","_autoCalcDepthBounds","deactivate","onAfterReductionPerformed","minmax","activate","autoCalcDepthBoundsRefreshRate","_b","_c","getDepthMap","refreshRate","splitFrustum","_splitFrustum","near","far","cameraRange","range","ratio","_cascades","p","log","uniform","d","prevBreakDistance","breakDistance","_viewSpaceFrustumsZ","_frustumLengths","_computeMatrices","getShadowDirection","_lightDirection","abs","_cachedDirection","copyFrom","useReverseDepthBuffer","_computeFrustumInWorldSpace","_computeCascadeFrustum","subtractToRef","_frustumCenter","addToRef","scale","_shadowCameraPos","update","isNDCHalfZRange","multiplyToRef","scaleInPlace","_mapSize","round","subtractInPlace","copyToArray","_transformMatricesAsArray","prevSplitDist","splitDist","invViewProj","getTransformationMatrix","cornerIndexOffset","cornerIndex","_FrustumCornersNDCSpace","_frustumCornersWorldSpace","addInPlace","stabilizeCascades","sphereRadius","dist","ceil","lightCameraPos","_disposeSceneUBOs","_sceneUBOs","i","createSceneUniformBuffer","IsSupported","_features","supportCSM","mapSize","light","usefulFloatFirst","super","usePercentageCloserFiltering","_initializeGenerator","_d","_e","_f","_g","_h","_j","_k","_l","_m","_o","_p","_q","_r","_s","_t","_u","_v","penumbraDarkness","DEFAULT_CASCADES_COUNT","_currentLayer","_createTargetRenderTexture","layers","_textureType","createDepthStencilTexture","_initializeShadowMap","Float32Array","_lightSizeUVCorrection","_depthCorrection","onBeforeBindObservable","clear","layer","setSceneUniformBuffer","_filter","setColorWrite","setTransformMatrix","_useUBO","getSceneUniformBuffer","unbindEffect","finalizeSceneUbo","_currentSceneUBO","_debugPushGroup","call","currentRenderPassId","_bindCustomEffectForRenderSubMeshForShadowMap","subMesh","_isReadyCustomDefines","defines","prepareDefines","lightIndex","shadowsEnabled","shadowEnabled","bindShadowLight","shadowMap","getShadowMap","getSize","setMatrices","setArray","setFloat","setDepthStencilTexture","_uniformBuffer","updateFloat4","getDarkness","frustumEdgeFalloff","setArray2","_contactHardeningLightSizeUVRatio","updateFloat2","getLight","getDepthMinZ","getDepthMaxZ","parsedShadowGenerator","shadowGenerator","shadowGenerators","className","ShadowGeneratorSceneComponent","_gatherRenderTargetsStage","_gatherRenderTargets","lights","getShadowGenerators","iterator","values","next","done","renderTargets","textures","ShadowGenerator","bias","_bias","normalBias","_normalBias","blurBoxOffset","_blurBoxOffset","_disposeBlurPostProcesses","blurScale","_blurScale","blurKernel","_blurKernel","useKernelBlur","_useKernelBlur","depthScale","_depthScale","getDepthScale","needCube","FILTER_BLUREXPONENTIALSHADOWMAP","useExponentialShadowMap","FILTER_BLURCLOSEEXPONENTIALSHADOWMAP","useCloseExponentialShadowMap","FILTER_PCF","FILTER_PCSS","usePoissonSampling","supportShadowSamplers","_applyFilterValues","FILTER_POISSONSAMPLING","FILTER_NONE","FILTER_EXPONENTIALSHADOWMAP","useBlurExponentialShadowMap","FILTER_CLOSEEXPONENTIALSHADOWMAP","useBlurCloseExponentialShadowMap","filteringQuality","_filteringQuality","useContactHardeningShadow","contactHardeningLightSizeUVRatio","darkness","_darkness","setDarkness","transparencyShadow","_transparencyShadow","setTransparencyShadow","transparent","getShadowMapForRendering","_shadowMap2","addShadowCaster","includeDescendants","childMesh","getChildMeshes","removeShadowCaster","child","getChildren","_camera","usefullFloatFirst","onBeforeShadowMapRenderObservable","onAfterShadowMapRenderObservable","onBeforeShadowMapRenderMeshObservable","onAfterShadowMapRenderMeshObservable","QUALITY_HIGH","enableSoftTransparentShadow","useOpacityTextureForTransparentShadow","forceBackFacesOnly","_viewMatrix","_projectionMatrix","_transformMatrix","_cachedPosition","_currentFaceIndex","_currentFaceIndexCache","_defaultTextureMatrix","_shadowGenerators","Map","set","supportsUniformBuffers","caps","getCaps","textureFloatRender","textureFloatLinearFiltering","textureHalfFloatRender","textureHalfFloatLinearFiltering","supportDepthStencilTexture","wrapU","wrapV","anisotropicFilteringLevel","updateSamplingMode","renderParticles","ignoreCameraViewport","_storedUniqueId","uniqueId","customRenderFunction","_renderForShadowMap","customIsReadyFunction","faceIndex","onAfterUnbindObservable","updateTransformMatrix","_debugPopGroup","postProcessManager","directRender","_blurPostProcesses","renderTarget","unBindFramebuffer","clearZero","clearOne","onClearObservable","onResizeObservable","rtt","getRenderSize","setRenderingAutoClearDepthStencil","_initializeBlurRTTAndPostProcesses","targetSize","_kernelBlurXPostprocess","externalTextureSamplerBinding","onApplyObservable","_kernelBlurYPostprocess","autoClear","packedFloat","_boxBlurPostprocess","setFloat2","opaqueSubMeshes","alphaTestSubMeshes","transparentSubMeshes","depthOnlySubMeshes","_renderSubMeshForShadowMap","data","getEffectiveMesh","_internalAbstractMeshDataInfo","_isActiveIntermediate","isTransparent","renderingMesh","getRenderingMesh","effectiveMesh","getMaterial","verticesCount","_renderId","getRenderId","detNeg","_getWorldMatrixDeterminant","sideOrientation","overrideMaterialSideOrientation","reverseSideOrientation","backFaceCulling","cullBackFaces","batch","_getInstancesRenderList","_id","getReplacementMesh","mustReturn","hardwareInstancedRendering","instancedArrays","visibleInstances","hasThinInstances","customAllowRendering","shadowDepthWrapper","drawWrapper","getEffect","_getDrawWrapper","_bind","fillMode","setFloat3","getTypeID","setVector3","visibility","alpha","_setMainDrawWrapperOverride","standalone","baseMaterial","bindForSubMesh","getWorldMatrix","opacityTexture","getTextureMatrix","needAlphaTesting","needAlphaBlending","alphaTexture","getAlphaTestTexture","useBones","computeBonesUsingShaders","skeleton","isUsingTextureForMatrices","boneTexture","getTransformMatrixTexture","bones","getTransformMatrices","morphTargetManager","isUsingTextureForTargets","bindUniformBuffer","world","getMeshUniformBuffer","bindToEffect","transferToEffect","notifyObservers","_processRendering","isInstance","worldOverride","resetRefreshCounter","forceCompilation","onCompiled","options","localOptions","useInstances","subMeshes","currentIndex","checkReady","needAlphaBlendingForMesh","getMesh","setTimeout","forceCompilationAsync","Promise","resolve","_prepareShadowDefines","toUpperCase","isVerticesDataPresent","isReadyForSubMesh","subMeshEffect","cachedDefines","attribs","nonUniformScaling","alphaCutOff","DEFAULT_ALPHA_CUTOFF","coordinatesIndex","fallbacks","numBoneInfluencers","addCPUSkinningFallback","manager","morphInfluencers","numInfluencers","customShaderOptions","define","join","shaderName","uniforms","samplers","uniformBuffers","attributes","attrib","sampler","uniformsNames","uniformBuffersNames","onError","indexParameters","maxSimultaneousMorphTargets","setEffect","QUALITY_LOW","QUALITY_MEDIUM","_currentRenderId","lightPosition","computeTransformedInformation","transformedPosition","needProjectionMatrixCompute","equals","setShadowProjectionMatrix","_disposeRTTandPostProcesses","ubo","entries","entry","delete","lightId","cameraId","constr","getLightById","getCameraById","getMeshesById","useVarianceShadowMap","useBlurVarianceShadowMap","N","DirectionalLight","shadowFrustumSize","_shadowFrustumSize","forceProjectionMatrixCompute","shadowOrthoScale","_shadowOrthoScale","orthoLeft","_orthoLeft","left","orthoRight","_orthoRight","right","orthoTop","_orthoTop","top","orthoBottom","_orthoBottom","bottom","autoUpdateExtends","autoCalcShadowZBounds","_setDefaultShadowProjectionMatrix","matrix","viewMatrix","_setDefaultFixedFrustumShadowProjectionMatrix","_setDefaultAutoExtendShadowProjectionMatrix","shadowMinZ","tempVector3","vectorsWorld","_shadowMinZ","xOffset","yOffset","_buildUniformLayout","addUniform","create","transformedDirection","transferToNodeMaterialEffect","lightDataUniformName","prepareLightSpecificDefines","prototype","HemisphericLight","groundColor","setDirectionToTarget","target","getShadowGenerator","_effect","normalizeDirection","updateColor3","computeWorldMatrix","_worldMatrix","Light","_range","_inverseSquaredRange","intensityMode","_intensityMode","_computePhotometricScale","radius","_radius","_shadowEnabled","includedOnlyMeshes","_includedOnlyMeshes","_hookArrayForIncludedOnly","excludedMeshes","_excludedMeshes","_hookArrayForExcluded","excludeWithLayerMask","_excludeWithLayerMask","_resyncMeshes","includeOnlyWithLayerMask","_includeOnlyWithLayerMask","lightmapMode","_lightmapMode","diffuse","specular","falloffType","FALLOFF_DEFAULT","_photometricScale","INTENSITYMODE_AUTOMATIC","renderPriority","_excludedMeshesIds","_includedOnlyMeshesIds","_isLight","addLight","transferTexturesToEffect","_bindLight","useSpecular","iAsString","toString","needUpdate","_lastUseSpecular","useUbo","scaledIntensity","getScaledIntensity","scaleToRef","updateColor4","fullDetails","ret","animations","_syncParentEnabledState","isDisposed","setEnabled","get","canAffectMesh","doNotRecurse","disposeMaterialAndTextures","stopAnimation","_parentContainer","_removeLightSource","removeLight","clone","newParent","GetConstructorFromName","clonedLight","parent","onClonedObservable","type","_serializeAsParent","excludedMeshesIds","includedOnlyMeshesIds","ranges","serializeAnimationRanges","constructorFunc","parsedLight","parentId","_waitingParentId","parentInstanceIndex","_waitingParentInstanceIndex","animationIndex","parsedAnimation","internalClass","autoAnimate","beginAnimation","autoAnimateFrom","autoAnimateTo","autoAnimateLoop","autoAnimateSpeed","array","oldPush","items","result","apply","item","_resyncLightSource","oldSplice","deleteCount","deleted","lightSources","_markSubMeshesAsLightDirty","_getPhotometricScale","resetCachedMaterial","photometricScale","lightTypeID","photometricMode","LIGHTTYPEID_DIRECTIONALLIGHT","INTENSITYMODE_ILLUMINANCE","INTENSITYMODE_LUMINOUSINTENSITY","LIGHTTYPEID_POINTLIGHT","LIGHTTYPEID_SPOTLIGHT","INTENSITYMODE_LUMINOUSPOWER","PI","INTENSITYMODE_LUMINANCE","apexAngleRadians","cos","LIGHTTYPEID_HEMISPHERICLIGHT","_reorderLightsInScene","_renderPriority","requireLightSorting","sortLightsByPriority","FALLOFF_PHYSICAL","FALLOFF_GLTF","FALLOFF_STANDARD","LIGHTMAP_DEFAULT","LIGHTMAP_SPECULAR","LIGHTMAP_SHADOWSONLY","LightConstants","a","PointLight","shadowAngle","_shadowAngle","_direction","previousNeedCube","ShadowLight","arguments","_needProjectionMatrixCompute","_setPosition","_position","_setDirection","getRotation","xaxis","yaxis","_initCache","_cache","_isSynchronized","force","isSynchronized","_updateCache","_markSyncedWithParent","_worldMatrixDeterminantIsDirty","customProjectionMatrixBuilder","SpotLight","angle","_angle","_cosHalfAngle","_projectionTextureProjectionLightDirty","_computeAngleValues","innerAngle","_innerAngle","shadowAngleScale","_shadowAngleScale","projectionTextureMatrix","_projectionTextureMatrix","projectionTextureLightNear","_projectionTextureLightNear","projectionTextureLightFar","_projectionTextureLightFar","projectionTextureUpDirection","_projectionTextureUpDirection","projectionTexture","_projectionTexture","_projectionTextureDirty","_IsProceduralTexture","executeWhenCompiled","_IsTexture","onLoadObservable","addOnce","onGeneratedObservable","projectionTextureProjectionLightMatrix","_projectionTextureProjectionLightMatrix","projection","exponent","_projectionTextureViewLightDirty","_projectionTextureViewTargetVector","_projectionTextureViewLightMatrix","_projectionTextureScalingMatrix","_computeProjectionTextureViewLightMatrix","_computeProjectionTextureProjectionLightMatrix","lightFar","lightNear","P","Q","S","tan","_computeProjectionTextureMatrix","u","uScale","v","vScale","_lightAngleScale","_lightAngleOffset","DefaultLoadingScreen","_renderingCanvas","_loadingText","_loadingDivBackgroundColor","_resizeLoadingUI","canvasRect","getBoundingClientRect","canvasPositioning","window","getComputedStyle","_loadingDiv","style","displayLoadingUI","document","createElement","opacity","transition","pointerEvents","display","gridTemplateRows","gridTemplateColumns","justifyItems","alignItems","_loadingTextDiv","marginTop","fontFamily","fontSize","textAlign","zIndex","innerHTML","appendChild","_style","getElementsByTagName","svgSupport","SVGSVGElement","imgBack","Image","DefaultLogoUrl","src","gridColumn","gridRow","transform","imageSpinnerContainer","imgSpinner","DefaultSpinnerUrl","animation","webkitAnimation","transformOrigin","webkitTransformOrigin","logoSize","w","h","loadingSize","addEventListener","backgroundColor","body","hideLoadingUI","removeEventListener","loadingUIText","text","loadingUIBackgroundColor","canvas","BabylonFileLoaderConfiguration","LoaderInjectedPhysicsEngine","tempIndexContainer","tempMaterialIndexContainer","parseMaterialByPredicate","predicate","materials","parsedMaterial","isDescendantOf","names","hierarchyIds","logOperation","operation","producer","file","version","exporter_version","loadDetailLevels","mastermesh","_waitingData","lods","ids","lodmeshes","wasenabled","distances","culling","lodid","lodmesh","getMeshById","addLODLevel","findParent","parentEntry","instances","parseInt","findMaterial","materialId","getLastMaterialById","loadAssetContainer","addToScene","JSON","parse","environmentTexture","isPBR","environmentTextureType","hdrSize","environmentTextureSize","hdrTexture","match","environmentTexturePrefilterOnLoad","environmentTextureRotationY","rotationY","endsWith","compressedTexture","environmentTextureForcedExtension","cubeTexture","createDefaultSkybox","skyboxScale","skyboxBlurLevel","environmentIntensity","reflectionProbes","parsedReflectionProbe","reflectionProbe","mat","getActiveTextures","t","multiMaterials","parsedMultiMaterial","mmat","morphTargetManagers","managerData","skeletons","parsedSkeleton","geometries","addedGeometry","vertexData","parsedVertexData","transformNodes","parsedTransformNode","node","parsedMesh","hasInstances","instance","cameras","parsedCamera","postProcesses","parsedPostProcess","postProcess","animationGroups","parsedAnimationGroup","animationGroup","transformNode","multimat","_waitingSubMaterialsUniqueIds","subMaterial","subMaterials","_waitingMaterialId","_hasWaitingData","bone","_waitingTransformNodeId","linkTransformNode","currentMesh","freezeWorldMatrix","excludedIndex","excludedMesh","includedOnlyIndex","includedOnlyMesh","_loadedUniqueId","actions","err","msg","Log","removeAllFromScene","extensions","canDirectLoad","importMesh","meshesNames","particleSystems","isArray","parsedIdToNodeMap","loadedTransformNodes","parsedJSONTransformNode","_waitingParsedUniqueId","loadedSkeletonsIds","loadedMaterialsIds","loadedMaterialsUniqueIds","loadedMorphTargetsIds","geometryId","found","geometryType","parsedGeometryData","materialUniqueId","materialArray","materialFound","loadSubMaterial","subMatId","multimatIndex","multimatCache","materialsUniqueIds","skeletonId","skeletonIndex","skeletonCache","morphTargetManagerId","morphTargetIndex","morphTargetCache","parsedMorphTarget","morphTarget","parentNode","loadedTransformNodeIndex","parser","parsedParticleSystem","load","useDelayedTextureLoading","clearColor","ambientColor","gravity","fogMode","fogColor","fogStart","fogEnd","fogDensity","physicsEnabled","physicsPlugin","physicsEngine","physicsGravity","enablePhysics","metadata","collisionsEnabled","activeCameraID","setActiveCameraById","SceneLoaderAnimationGroupLoadingMode","SceneLoader","ForceFullSceneLoadingForIncremental","ShowLoadingScreen","loggingLevel","CleanBoneMatrixWeights","_RegisteredPlugins","extension","registeredPlugin","GetDefaultPlugin","plugin","sceneFilename","queryStringPosition","substring","dotPosition","lastIndexOf","toLowerCase","_GetPluginForExtension","substr","fileInfo","message","exception","errorMessage","url","onSuccess","onProgress","onDispose","pluginExtension","directLoad","_GetDirectLoad","_GetPluginForDirectLoad","_GetPluginForFilename","createPlugin","OnPluginActivatedObservable","then","catch","useArrayBuffer","isBinary","dataCallback","responseURL","request","pluginDisposed","onDisposeObservable","abort","manifestChecked","errorCallback","statusText","fileOrUrl","loadFile","_loadFile","canUseOfflineSupport","enableOfflineSupport","exceptionFound","regex","disableOfflineSupportExceptionRules","test","offlineProvider","disableManifestCheck","sceneFile","startsWith","filename","Object","keys","meshNames","_GetFileInfo","loadingToken","addPendingData","disposeHandler","removePendingData","errorHandler","_FormatErrorMessage","progressHandler","event","e","successHandler","importedMeshesFiles","_LoadData","rewriteRootURL","syncedPlugin","loadingPluginName","importMeshAsync","reject","ImportMesh","Error","Append","Load","_ShowingLoadingScreen","executeWhenReady","loadAsync","assets","assetContainer","loadAssetContainerAsync","LoadAssetContainer","overwriteAnimations","animationGroupLoadingMode","Clean","targetConverter","animatable","animatables","reset","stopAllAnimations","slice","getNodes","Stop","stop","Sync","restart","NoSync","startingIndexForNewAnimatables","mergeAnimationsTo","onAnimationFileImportedObservable","ImportAnimations","NO_LOGGING","MINIMAL_LOGGING","SUMMARY_LOGGING","DETAILED_LOGGING","SceneLoaderFlags","_ForceFullSceneLoadingForIncremental","_ShowLoadingScreen","_LoggingLevel","_CleanBoneMatrixWeights","BackgroundMaterialDefines","DIFFUSE","DIFFUSEDIRECTUV","GAMMADIFFUSE","DIFFUSEHASALPHA","OPACITYFRESNEL","REFLECTIONBLUR","REFLECTIONFRESNEL","REFLECTIONFALLOFF","TEXTURELODSUPPORT","PREMULTIPLYALPHA","USERGBCOLOR","USEHIGHLIGHTANDSHADOWCOLORS","BACKMAT_SHADOWONLY","NOISE","REFLECTIONBGR","IMAGEPROCESSING","VIGNETTE","VIGNETTEBLENDMODEMULTIPLY","VIGNETTEBLENDMODEOPAQUE","TONEMAPPING","TONEMAPPING_ACES","CONTRAST","COLORCURVES","COLORGRADING","COLORGRADING3D","SAMPLER3DGREENDEPTH","SAMPLER3DBGRMAP","DITHER","IMAGEPROCESSINGPOSTPROCESS","SKIPFINALCOLORCLAMP","EXPOSURE","MULTIVIEW","REFLECTION","REFLECTIONMAP_3D","REFLECTIONMAP_SPHERICAL","REFLECTIONMAP_PLANAR","REFLECTIONMAP_CUBIC","REFLECTIONMAP_PROJECTION","REFLECTIONMAP_SKYBOX","REFLECTIONMAP_EXPLICIT","REFLECTIONMAP_EQUIRECTANGULAR","REFLECTIONMAP_EQUIRECTANGULAR_FIXED","REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED","INVERTCUBICMAP","REFLECTIONMAP_OPPOSITEZ","LODINREFLECTIONALPHA","GAMMAREFLECTION","RGBDREFLECTION","EQUIRECTANGULAR_RELFECTION_FOV","MAINUV1","MAINUV2","UV1","UV2","CLIPPLANE","CLIPPLANE2","CLIPPLANE3","CLIPPLANE4","CLIPPLANE5","CLIPPLANE6","POINTSIZE","FOG","NORMAL","NUM_BONE_INFLUENCERS","BonesPerMesh","INSTANCES","SHADOWFLOAT","LOGARITHMICDEPTH","NONUNIFORMSCALING","ALPHATEST","BackgroundMaterial","_perceptualColor","__perceptualColor","_computePrimaryColorFromPerceptualColor","_markAllSubMeshesAsLightsDirty","primaryColorShadowLevel","_primaryColorShadowLevel","_computePrimaryColors","primaryColorHighlightLevel","_primaryColorHighlightLevel","reflectionStandardFresnelWeight","reflectionWeight","reflectionReflectance0","StandardReflectance0","reflectionReflectance90","StandardReflectance90","fovMultiplier","_fovMultiplier","isNaN","_attachImageProcessingConfiguration","configuration","_imageProcessingConfiguration","_imageProcessingObserver","onUpdateParameters","imageProcessingConfiguration","_markAllSubMeshesAsImageProcessingDirty","_markAllSubMeshesAsTexturesDirty","cameraColorCurvesEnabled","colorCurvesEnabled","cameraColorGradingEnabled","colorGradingEnabled","cameraToneMappingEnabled","toneMappingEnabled","cameraExposure","exposure","cameraContrast","contrast","cameraColorGradingTexture","colorGradingTexture","cameraColorCurves","colorCurves","primaryColor","reflectionTexture","reflectionBlur","diffuseTexture","_shadowLights","shadowLights","shadowLevel","sceneCenter","opacityFresnel","reflectionFresnel","reflectionFalloffDistance","reflectionAmount","useRGBColor","enableNoise","useEquirectangularFOV","_maxSimultaneousLights","maxSimultaneousLights","_shadowOnly","shadowOnly","switchToBGR","_renderTargets","_reflectionControls","_white","_primaryShadowColor","_primaryHighlightColor","getRenderTargetTextures","_diffuseTexture","isRenderTarget","_reflectionTexture","hasRenderTargetTextures","hasAlpha","isFrozen","_wasPreviouslyReady","_wasPreviouslyUsingInstances","materialDefines","_isReadyForSubMesh","_needNormals","_areTexturesDirty","_needUVs","texturesEnabled","textureLOD","isReadyOrNotBlocking","gammaSpace","_opacityFresnel","isRGBD","_reflectionBlur","lodLevelInAlpha","coordinatesMode","isCube","invertZ","_useRGBColor","_enableNoise","_areLightsDirty","_areImageProcessingDirty","pointsCloud","fogEnabled","_shouldTurnAlphaTestOn","standardDerivatives","createNormals","isDirty","markAsProcessed","addFallback","_materialContext","buildUniformLayout","performancePriority","checkReadyOnlyOnce","_primaryColor","toLinearSpaceToRef","unbind","bindOnlyWorldMatrix","_activeEffect","mustRebind","_mustRebind","bindViewProjection","isSync","level","updateMatrix","getReflectionTextureMatrix","updateFloat3","lodGenerationScale","lodGenerationOffset","updateFloat","pointSize","_lodTextureMid","_lodTextureLow","_lodTextureHigh","bindEyePosition","needToAlwaysBindUniformBuffers","_needToBindSceneUbo","lightsEnabled","bindView","_afterBind","hasTexture","forceDisposeEffect","forceDisposeTextures","customType","source","CurrentScreenBlock","_samplerName","convertToGammaSpace","convertToLinearSpace","_isUnique","registerInput","registerOutput","_inputs","addExcludedConnectionPointFromAllowedTypes","_prioritizeVertex","uv","rgba","_outputs","rgb","initialize","state","_excludeVariableName","isConnected","sourceBlock","isInput","nodeMaterial","setValue","_linearDefineName","_gammaDefineName","_injectVertexCode","uvInput","connectedPoint","ownerBlock","isAttribute","_emitUniformFromString","associatedVariableName","_mainUVName","_emitVaryingFromString","compilationString","some","isConnectedInVertexShader","_writeTextureRead","output","hasEndpoints","_writeOutput","vertexMode","_tempTextureRead","swizzle","_declareOutput","_buildBlock","_getFreeVariableName","sharedData","blockingBlocks","textureBlocks","blocksWithDefines","_emit2DSampler","isConnectedInFragmentShader","_getFreeDefineName","comments","_emitFunctionFromInclude","_deserialize","ImageSourceBlock","_texture","markAllMaterialsAsDirty","samplerName","bindableBlocks","_dumpPropertiesCode","codeString","_codeVariableName","noMipmap","invertY","samplingMode","uAng","vAng","wAng","uOffset","vOffset","FogBlock","input","worldPosition","view","autoConfigure","viewInput","getInputBlockByPredicate","systemValue","setAsSystemValue","connectTo","fogColorInput","_fogParameters","removeUniforms","removeVaryings","removeIfDef","replaceStrings","search","replace","tempFogVariablename","_fogDistanceName","worldPos","LightBlock","block","_propertyName","that","generateOnlyFragmentCode","_setTarget","_setInitialTarget","getInputByName","_lightId","worldNormal","cameraPosition","glossiness","glossPower","diffuseColor","specularColor","diffuseOutput","specularOutput","shadow","cameraPositionInput","needNormals","needRebuild","specularEnabled","updateUniformsAndSamples","onlyUpdateBuffersList","counters","supportUniformBuffers","repeatKey","dynamicUniformBlocks","worldPosVaryingName","_emitCodeFromInclude","forcedBindableBlocks","worldPosVariableName","_emitFunction","substitutionVars","_registerTempVariable","notifiers","onValidation","_OnGenerateOnlyFragmentCodeChanged","TextureBlock","_imageSource","hasImageSource","_convertToGammaSpace","_convertToLinearSpace","fragmentOnly","disableLevelMultiplication","_fragmentOnly","parentBlock","inputs","mode","getBlockByPredicate","attributeName","setAsAttribute","initializeDefines","_mainUVDefineName","_isMixed","_defineName","toGamma","toLinear","isIdentityAs3x2","_textureInfoName","_textureTransformName","_transformedUVName","_generateTextureLookup","_generateConversionCode","complement","ReflectionTextureBlock","_onGenerateOnlyFragmentCodeChanged","writeOutputs","handleVertexSide","handleFragmentSideInits","normalWUnit","handleFragmentSideCodeReflectionCoords","handleFragmentSideCodeReflectionColor","_reflectionColorName","SceneDepthBlock","useNonLinearDepth","force32itsFloat","depth","_getTexture","enableDepthRenderer","activatePreviewCommand","callback","disableDepthRenderer","ClipPlanesBlock","useClipPlane1","clipPlane","useClipPlane2","clipPlane2","useClipPlane3","clipPlane3","useClipPlane4","clipPlane4","useClipPlane5","clipPlane5","useClipPlane6","clipPlane6","ReflectionTextureBaseBlock","positionInput","worldInput","_define3DName","_defineLocalCubicName","boundingBoxSize","_defineExplicitName","_defineSkyboxName","_defineCubicName","_defineSphericalName","_definePlanarName","_defineProjectionName","_defineEquirectangularName","_defineEquirectangularFixedName","_defineMirroredEquirectangularFixedName","_reflectionMatrixName","_cubeSamplerName","_2DSamplerName","_reflectionPositionName","boundingBoxPosition","_reflectionSizeName","_defineOppositeZ","code","_worldPositionNameInFragmentOnlyMode","_positionUVWName","_directionWName","_samplerDeclaration","_reflectionVectorName","_reflectionCoordsName","worldNormalVarName","onlyReflectionVector","doNotEmitInvertZ","reflectionMatrix","positionUVW","vEyePosition","lodVarName","swizzleLookupTexture","varName","forcedExtension","_prefiltered","TBNBlock","normal","tangent","TBN","row0","row1","row2","isSystemValue","normalInput","tangentInput","normalAvailable","connectInputBlock","tangentAvailable","useTBNBlock","FragmentOutputBlock","useLogarithmicDepth","hints","aValue","checks","notConnectedNonOptionalInputs","ImageProcessingBlock","convertInputToLinearSpace","PerturbNormalBlock","_tangentSpaceParameterName","_tangentCorrectionFactorName","_worldMatrixName","invertX","useParallaxOcclusion","useObjectSpaceNormalMap","worldTangent","normalMapColor","strength","viewDirection","parallaxScale","parallaxHeight","uvOffset","normalSamplerName","_ownerBlock","useParallax","_mirroredCameraPosition","determinant","strengthInput","replaceForParallaxInfos","isConnectedToInputBlock","isConstant","_emitFloat","replaceForBumpInfos","_emitExtension","tangentReplaceString","uvForPerturbNormal","DiscardBlock","cutoff","FrontFacingBlock","DerivativeBlock","_typeConnectionSource","dx","dy","FragCoordBlock","xy","xyz","xyzw","ScreenSizeBlock","_varName","ScreenSpaceBlock","vector","worldViewProjection","worldViewProjectionInput","worldViewProjectionName","tempVariableName","TwirlBlock","center","offset","centerInput","offsetInput","tempDelta","tempAngle","tempX","tempY","tempResult","HeightToNormalBlock","generateInWorldSpace","automaticNormalizationNormal","automaticNormalizationTangent","startCode","endCode","heightToNormal","FragDepthBlock","viewProjection","warn","ShadowMapBlock","AnimatedInputBlockTypes","remapAttributeName","position2d","particle_uv","particle_color","particle_texturemask","particle_positionw","attributeInFragmentOnly","attributeAsUniform","InputBlock","_type","isUniform","_systemValue","_mode","_animationType","isBoolean","matrixMode","groupInInspector","onValueChangedObservable","setDefaultValue","validateBlockName","newName","_storedValue","valueCallback","_valueCallback","_associatedVariableName","animationType","isUndefined","isVarying","animate","getAnimationRatio","startTime","_emitDefine","_emitConstant","_noContextSwitch","_emit","constants","_constantDeclaration","_uniformDeclaration","_getGLType","needWorldViewMatrix","needWorldViewProjectionMatrix","animatedInputs","_vertexState","_attributeDeclaration","_transmitWorld","worldView","variableName","_transmit","getProjectionMatrix","setColor3","deltaTime","hasOriginBottomLeft","setInt","setDirectColor4","setVector2","setVector4","inputBlocks","codes","valueString","valueType","wellKnownValue","FromArray","AnisotropyBlock","anisotropy","_generateTBNSpace","worldPositionConnectionPoint","worldNormalConnectionPoint","getCode","generateTBNSpace","ClearCoatBlock","remapF0OnInterfaceChange","roughness","indexOfRefraction","tintColor","tintAtDistance","tintThickness","clearcoat","intensityInput","f0","pow","eta","mainPBRBlock","endpoints","perturbedNormalBlock","perturbedNormal","worldPositionVarName","ccBlock","reflectionBlock","worldPosVarName","vTBNAvailable","normalShading","_vReflectionMicrosurfaceInfosName","_vReflectionInfosName","reflectionColor"],"sourceRoot":""}