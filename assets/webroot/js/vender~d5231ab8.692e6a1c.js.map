{"version":3,"file":"js/vender~d5231ab8.692e6a1c.js","mappings":"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","sources":["webpack:///../../../node_modules/@babylonjs/core/Shaders/depth.fragment.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/depth.vertex.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/depthOfField.fragment.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/depthOfFieldMerge.fragment.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/displayPass.fragment.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/fluidRenderingParticleDiffuse.vertex.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/fluidRenderingRender.fragment.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/fluidRenderingStandardBlur.fragment.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/fxaa.fragment.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/geometry.fragment.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/geometry.vertex.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/glowMapGeneration.vertex.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/glowMapMerge.fragment.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/gpuUpdateParticles.vertex.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/imageProcessing.fragment.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/kernelBlur.fragment.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/lensHighlights.fragment.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/line.vertex.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/oitBackBlend.fragment.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/oitFinal.fragment.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/outline.vertex.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/particles.fragment.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/particles.vertex.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/pbr.fragment.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/pbr.vertex.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/procedural.vertex.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/refraction.fragment.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/rgbdDecode.fragment.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/screenSpaceCurvature.fragment.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/screenSpaceReflection.fragment.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/screenSpaceReflection2.fragment.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/shadowMap.vertex.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/sharpen.fragment.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ssaoCombine.fragment.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/stereoscopicInterlace.fragment.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/tonemap.fragment.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/volumetricLightScattering.fragment.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/volumetricLightScatteringPass.fragment.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/volumetricLightScatteringPass.vertex.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/vrDistortionCorrection.fragment.js","webpack:///../../../node_modules/@babylonjs/core/Sprites/thinSprite.js","webpack:///../../../node_modules/@babylonjs/core/Sprites/sprite.js","webpack:///../../../node_modules/@babylonjs/core/Sprites/spriteSceneComponent.js","webpack:///../../../node_modules/@babylonjs/core/Sprites/spriteManager.js","webpack:///../../../node_modules/@babylonjs/core/Sprites/spriteMap.js","webpack:///../../../node_modules/@babylonjs/core/Sprites/spritePackedManager.js","webpack:///../../../node_modules/@babylonjs/core/States/alphaCullingState.js","webpack:///../../../node_modules/@babylonjs/core/States/depthCullingState.js","webpack:///../../../node_modules/@babylonjs/core/States/stencilState.js","webpack:///../../../node_modules/@babylonjs/core/States/stencilStateComposer.js","webpack:///../../../node_modules/@babylonjs/core/XR/features/WebXRControllerPointerSelection.js","webpack:///../../../node_modules/@babylonjs/core/XR/features/WebXRControllerTeleportation.js","webpack:///../../../node_modules/@babylonjs/core/XR/features/WebXRHandTracking.js","webpack:///../../../node_modules/@babylonjs/core/XR/features/WebXRNearInteraction.js","webpack:///../../../node_modules/@babylonjs/core/XR/features/WebXRHitTestLegacy.js","webpack:///../../../node_modules/@babylonjs/core/XR/features/WebXRAnchorSystem.js","webpack:///../../../node_modules/@babylonjs/core/XR/features/WebXRPlaneDetector.js","webpack:///../../../node_modules/@babylonjs/core/XR/features/WebXRBackgroundRemover.js","webpack:///../../../node_modules/@babylonjs/core/XR/features/WebXRControllerPhysics.js","webpack:///../../../node_modules/@babylonjs/core/XR/features/WebXRHitTest.js","webpack:///../../../node_modules/@babylonjs/core/XR/features/WebXRFeaturePointSystem.js","webpack:///../../../node_modules/@babylonjs/core/XR/features/WebXRMeshDetector.js","webpack:///../../../node_modules/@babylonjs/core/XR/features/WebXRImageTracking.js","webpack:///../../../node_modules/@babylonjs/core/XR/features/WebXRDOMOverlay.js","webpack:///../../../node_modules/@babylonjs/core/XR/features/WebXRControllerMovement.js","webpack:///../../../node_modules/@babylonjs/core/XR/features/WebXRLightEstimation.js","webpack:///../../../node_modules/@babylonjs/core/XR/features/WebXREyeTracking.js","webpack:///../../../node_modules/@babylonjs/core/XR/features/WebXRWalkingLocomotion.js","webpack:///../../../node_modules/@babylonjs/core/XR/features/WebXRLayers.js","webpack:///../../../node_modules/@babylonjs/core/XR/features/index.js","webpack:///../../../node_modules/@babylonjs/core/XR/index.js"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nimport \"./ShadersInclude/clipPlaneFragmentDeclaration.js\";\nimport \"./ShadersInclude/packingFunctions.js\";\nimport \"./ShadersInclude/clipPlaneFragment.js\";\nconst name = \"depthPixelShader\";\nconst shader = `#ifdef ALPHATEST\nvarying vec2 vUV;\runiform sampler2D diffuseSampler;\r#endif\n#include<clipPlaneFragmentDeclaration>\nvarying float vDepthMetric;\r#ifdef PACKED\n#include<packingFunctions>\n#endif\n#ifdef STORE_CAMERASPACE_Z\nvarying vec4 vViewPos;\r#endif\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void)\r{\r#include<clipPlaneFragment>\n#ifdef ALPHATEST\nif (texture2D(diffuseSampler,vUV).a<0.4)\rdiscard;\r#endif\n#ifdef STORE_CAMERASPACE_Z\n#ifdef PACKED\ngl_FragColor=pack(vViewPos.z);\r#else\ngl_FragColor=vec4(vViewPos.z,0.0,0.0,1.0);\r#endif\n#else\n#ifdef NONLINEARDEPTH\n#ifdef PACKED\ngl_FragColor=pack(gl_FragCoord.z);\r#else\ngl_FragColor=vec4(gl_FragCoord.z,0.0,0.0,0.0);\r#endif\n#else\n#ifdef PACKED\ngl_FragColor=pack(vDepthMetric);\r#else\ngl_FragColor=vec4(vDepthMetric,0.0,0.0,1.0);\r#endif\n#endif\n#endif\n}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const depthPixelShader = { name, shader };\n//# sourceMappingURL=depth.fragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nimport \"./ShadersInclude/bonesDeclaration.js\";\nimport \"./ShadersInclude/bakedVertexAnimationDeclaration.js\";\nimport \"./ShadersInclude/morphTargetsVertexGlobalDeclaration.js\";\nimport \"./ShadersInclude/morphTargetsVertexDeclaration.js\";\nimport \"./ShadersInclude/clipPlaneVertexDeclaration.js\";\nimport \"./ShadersInclude/instancesDeclaration.js\";\nimport \"./ShadersInclude/morphTargetsVertexGlobal.js\";\nimport \"./ShadersInclude/morphTargetsVertex.js\";\nimport \"./ShadersInclude/instancesVertex.js\";\nimport \"./ShadersInclude/bonesVertex.js\";\nimport \"./ShadersInclude/bakedVertexAnimation.js\";\nimport \"./ShadersInclude/clipPlaneVertex.js\";\nconst name = \"depthVertexShader\";\nconst shader = `attribute vec3 position;\r#include<bonesDeclaration>\n#include<bakedVertexAnimationDeclaration>\n#include<morphTargetsVertexGlobalDeclaration>\n#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]\n#include<clipPlaneVertexDeclaration>\n#include<instancesDeclaration>\nuniform mat4 viewProjection;\runiform vec2 depthValues;\r#if defined(ALPHATEST) || defined(NEED_UV)\nvarying vec2 vUV;\runiform mat4 diffuseMatrix;\r#ifdef UV1\nattribute vec2 uv;\r#endif\n#ifdef UV2\nattribute vec2 uv2;\r#endif\n#endif\n#ifdef STORE_CAMERASPACE_Z\nuniform mat4 view;\rvarying vec4 vViewPos;\r#endif\nvarying float vDepthMetric;\r#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void)\r{\rvec3 positionUpdated=position;\r#ifdef UV1\nvec2 uvUpdated=uv;\r#endif\n#include<morphTargetsVertexGlobal>\n#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]\n#include<instancesVertex>\n#include<bonesVertex>\n#include<bakedVertexAnimation>\nvec4 worldPos=finalWorld*vec4(positionUpdated,1.0);\r#include<clipPlaneVertex>\ngl_Position=viewProjection*worldPos;\r#ifdef STORE_CAMERASPACE_Z\nvViewPos=view*worldPos;\r#else\n#ifdef USE_REVERSE_DEPTHBUFFER\nvDepthMetric=((-gl_Position.z+depthValues.x)/(depthValues.y));\r#else\nvDepthMetric=((gl_Position.z+depthValues.x)/(depthValues.y));\r#endif\n#endif\n#if defined(ALPHATEST) || defined(BASIC_RENDER)\n#ifdef UV1\nvUV=vec2(diffuseMatrix*vec4(uvUpdated,1.0,0.0));\r#endif\n#ifdef UV2\nvUV=vec2(diffuseMatrix*vec4(uv2,1.0,0.0));\r#endif\n#endif\n}\r`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const depthVertexShader = { name, shader };\n//# sourceMappingURL=depth.vertex.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nconst name = \"depthOfFieldPixelShader\";\nconst shader = `uniform sampler2D textureSampler;\runiform sampler2D highlightsSampler;\runiform sampler2D depthSampler;\runiform sampler2D grainSampler;\runiform float grain_amount;\runiform bool blur_noise;\runiform float screen_width;\runiform float screen_height;\runiform float distortion;\runiform bool dof_enabled;\runiform float screen_distance; \runiform float aperture;\runiform float darken;\runiform float edge_blur;\runiform bool highlights;\runiform float near;\runiform float far;\rvarying vec2 vUV;\r#define PI 3.14159265\n#define TWOPI 6.28318530\n#define inverse_focal_length 0.1 \nvec2 centered_screen_pos;\rvec2 distorted_coords;\rfloat radius2;\rfloat radius;\rvec2 rand(vec2 co)\r{\rfloat noise1=(fract(sin(dot(co,vec2(12.9898,78.233)))*43758.5453));\rfloat noise2=(fract(sin(dot(co,vec2(12.9898,78.233)*2.0))*43758.5453));\rreturn clamp(vec2(noise1,noise2),0.0,1.0);\r}\rvec2 getDistortedCoords(vec2 coords) {\rif (distortion==0.0) { return coords; }\rvec2 direction=1.0*normalize(centered_screen_pos);\rvec2 dist_coords=vec2(0.5,0.5);\rdist_coords.x=0.5+direction.x*radius2*1.0;\rdist_coords.y=0.5+direction.y*radius2*1.0;\rfloat dist_amount=clamp(distortion*0.23,0.0,1.0);\rdist_coords=mix(coords,dist_coords,dist_amount);\rreturn dist_coords;\r}\rfloat sampleScreen(inout vec4 color,in vec2 offset,in float weight) {\rvec2 coords=distorted_coords;\rfloat angle=rand(coords*100.0).x*TWOPI;\rcoords+=vec2(offset.x*cos(angle)-offset.y*sin(angle),offset.x*sin(angle)+offset.y*cos(angle));\rcolor+=texture2D(textureSampler,coords)*weight;\rreturn weight;\r}\rfloat getBlurLevel(float size) {\rreturn min(3.0,ceil(size/1.0));\r}\rvec4 getBlurColor(float size) {\rvec4 col=texture2D(textureSampler,distorted_coords);\rfloat blur_level=getBlurLevel(size);\rfloat w=(size/screen_width);\rfloat h=(size/screen_height);\rfloat total_weight=1.0;\rvec2 sample_coords;\rtotal_weight+=sampleScreen(col,vec2(-0.50*w,0.24*h),0.93);\rtotal_weight+=sampleScreen(col,vec2(0.30*w,-0.75*h),0.90);\rtotal_weight+=sampleScreen(col,vec2(0.36*w,0.96*h),0.87);\rtotal_weight+=sampleScreen(col,vec2(-1.08*w,-0.55*h),0.85);\rtotal_weight+=sampleScreen(col,vec2(1.33*w,-0.37*h),0.83);\rtotal_weight+=sampleScreen(col,vec2(-0.82*w,1.31*h),0.80);\rtotal_weight+=sampleScreen(col,vec2(-0.31*w,-1.67*h),0.78);\rtotal_weight+=sampleScreen(col,vec2(1.47*w,1.11*h),0.76);\rtotal_weight+=sampleScreen(col,vec2(-1.97*w,0.19*h),0.74);\rtotal_weight+=sampleScreen(col,vec2(1.42*w,-1.57*h),0.72);\rif (blur_level>1.0) {\rtotal_weight+=sampleScreen(col,vec2(0.01*w,2.25*h),0.70);\rtotal_weight+=sampleScreen(col,vec2(-1.62*w,-1.74*h),0.67);\rtotal_weight+=sampleScreen(col,vec2(2.49*w,0.20*h),0.65);\rtotal_weight+=sampleScreen(col,vec2(-2.07*w,1.61*h),0.63);\rtotal_weight+=sampleScreen(col,vec2(0.46*w,-2.70*h),0.61);\rtotal_weight+=sampleScreen(col,vec2(1.55*w,2.40*h),0.59);\rtotal_weight+=sampleScreen(col,vec2(-2.88*w,-0.75*h),0.56);\rtotal_weight+=sampleScreen(col,vec2(2.73*w,-1.44*h),0.54);\rtotal_weight+=sampleScreen(col,vec2(-1.08*w,3.02*h),0.52);\rtotal_weight+=sampleScreen(col,vec2(-1.28*w,-3.05*h),0.49);\r}\rif (blur_level>2.0) {\rtotal_weight+=sampleScreen(col,vec2(3.11*w,1.43*h),0.46);\rtotal_weight+=sampleScreen(col,vec2(-3.36*w,1.08*h),0.44);\rtotal_weight+=sampleScreen(col,vec2(1.80*w,-3.16*h),0.41);\rtotal_weight+=sampleScreen(col,vec2(0.83*w,3.65*h),0.38);\rtotal_weight+=sampleScreen(col,vec2(-3.16*w,-2.19*h),0.34);\rtotal_weight+=sampleScreen(col,vec2(3.92*w,-0.53*h),0.31);\rtotal_weight+=sampleScreen(col,vec2(-2.59*w,3.12*h),0.26);\rtotal_weight+=sampleScreen(col,vec2(-0.20*w,-4.15*h),0.22);\rtotal_weight+=sampleScreen(col,vec2(3.02*w,3.00*h),0.15);\r}\rcol/=total_weight; \rif (darken>0.0) {\rcol.rgb*=clamp(0.3,1.0,1.05-size*0.5*darken);\r}\rreturn col;\r}\r#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void)\r{\rcentered_screen_pos=vec2(vUV.x-0.5,vUV.y-0.5);\rradius2=centered_screen_pos.x*centered_screen_pos.x+centered_screen_pos.y*centered_screen_pos.y;\rradius=sqrt(radius2);\rdistorted_coords=getDistortedCoords(vUV); \rvec2 texels_coords=vec2(vUV.x*screen_width,vUV.y*screen_height); \rfloat depth=texture2D(depthSampler,distorted_coords).r; \rfloat distance=near+(far-near)*depth; \rvec4 color=texture2D(textureSampler,vUV); \rfloat coc=abs(aperture*(screen_distance*(inverse_focal_length-1.0/distance)-1.0));\rif (dof_enabled==false || coc<0.07) { coc=0.0; }\rfloat edge_blur_amount=0.0;\rif (edge_blur>0.0) {\redge_blur_amount=clamp((radius*2.0-1.0+0.15*edge_blur)*1.5,0.0,1.0)*1.3;\r}\rfloat blur_amount=max(edge_blur_amount,coc);\rif (blur_amount==0.0) {\rgl_FragColor=texture2D(textureSampler,distorted_coords);\r}\relse {\rgl_FragColor=getBlurColor(blur_amount*1.7);\rif (highlights) {\rgl_FragColor.rgb+=clamp(coc,0.0,1.0)*texture2D(highlightsSampler,distorted_coords).rgb;\r}\rif (blur_noise) {\rvec2 noise=rand(distorted_coords)*0.01*blur_amount;\rvec2 blurred_coord=vec2(distorted_coords.x+noise.x,distorted_coords.y+noise.y);\rgl_FragColor=0.04*texture2D(textureSampler,blurred_coord)+0.96*gl_FragColor;\r}\r}\rif (grain_amount>0.0) {\rvec4 grain_color=texture2D(grainSampler,texels_coords*0.003);\rgl_FragColor.rgb+=(-0.5+grain_color.rgb)*0.30*grain_amount;\r}\r}\r`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const depthOfFieldPixelShader = { name, shader };\n//# sourceMappingURL=depthOfField.fragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nconst name = \"depthOfFieldMergePixelShader\";\nconst shader = `uniform sampler2D textureSampler;\rvarying vec2 vUV;\runiform sampler2D circleOfConfusionSampler;\runiform sampler2D blurStep0;\r#if BLUR_LEVEL>0\nuniform sampler2D blurStep1;\r#endif\n#if BLUR_LEVEL>1\nuniform sampler2D blurStep2;\r#endif\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void)\r{\rfloat coc=texture2D(circleOfConfusionSampler,vUV).r;\r#if BLUR_LEVEL==0\nvec4 original=texture2D(textureSampler,vUV);\rvec4 blurred0=texture2D(blurStep0,vUV);\rgl_FragColor=mix(original,blurred0,coc);\r#endif\n#if BLUR_LEVEL==1\nif(coc<0.5){\rvec4 original=texture2D(textureSampler,vUV);\rvec4 blurred1=texture2D(blurStep1,vUV);\rgl_FragColor=mix(original,blurred1,coc/0.5);\r}else{\rvec4 blurred0=texture2D(blurStep0,vUV);\rvec4 blurred1=texture2D(blurStep1,vUV);\rgl_FragColor=mix(blurred1,blurred0,(coc-0.5)/0.5);\r}\r#endif\n#if BLUR_LEVEL==2\nif(coc<0.33){\rvec4 original=texture2D(textureSampler,vUV);\rvec4 blurred2=texture2D(blurStep2,vUV);\rgl_FragColor=mix(original,blurred2,coc/0.33);\r}else if(coc<0.66){\rvec4 blurred1=texture2D(blurStep1,vUV);\rvec4 blurred2=texture2D(blurStep2,vUV);\rgl_FragColor=mix(blurred2,blurred1,(coc-0.33)/0.33);\r}else{\rvec4 blurred0=texture2D(blurStep0,vUV);\rvec4 blurred1=texture2D(blurStep1,vUV);\rgl_FragColor=mix(blurred1,blurred0,(coc-0.66)/0.34);\r}\r#endif\n}\r`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const depthOfFieldMergePixelShader = { name, shader };\n//# sourceMappingURL=depthOfFieldMerge.fragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nconst name = \"displayPassPixelShader\";\nconst shader = `varying vec2 vUV;\runiform sampler2D textureSampler;\runiform sampler2D passSampler;\r#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void)\r{\rgl_FragColor=texture2D(passSampler,vUV);\r}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const displayPassPixelShader = { name, shader };\n//# sourceMappingURL=displayPass.fragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nconst name = \"fluidRenderingParticleDiffuseVertexShader\";\nconst shader = `attribute vec3 position;\rattribute vec2 offset;\rattribute vec4 color;\runiform mat4 view;\runiform mat4 projection;\runiform vec2 size;\rvarying vec2 uv;\rvarying vec3 diffuseColor;\rvoid main(void) {\rvec3 cornerPos;\rcornerPos.xy=vec2(offset.x-0.5,offset.y-0.5)*size;\rcornerPos.z=0.0;\rvec3 viewPos=(view*vec4(position,1.0)).xyz+cornerPos;\rgl_Position=projection*vec4(viewPos,1.0);\ruv=offset;\rdiffuseColor=color.rgb;\r}\r`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const fluidRenderingParticleDiffuseVertexShader = { name, shader };\n//# sourceMappingURL=fluidRenderingParticleDiffuse.vertex.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nconst name = \"fluidRenderingRenderPixelShader\";\nconst shader = `#define IOR 1.333\n#define ETA 1.0/IOR\n#define F0 0.02\nuniform sampler2D textureSampler;\runiform sampler2D depthSampler;\r#ifdef FLUIDRENDERING_DIFFUSETEXTURE\nuniform sampler2D diffuseSampler;\r#else\nuniform vec3 diffuseColor;\r#endif\n#ifdef FLUIDRENDERING_FIXED_THICKNESS\nuniform float thickness;\runiform sampler2D bgDepthSampler;\r#else\nuniform float minimumThickness;\runiform sampler2D thicknessSampler;\r#endif\n#ifdef FLUIDRENDERING_ENVIRONMENT\nuniform samplerCube reflectionSampler;\r#endif\n#if defined(FLUIDRENDERING_DEBUG) && defined(FLUIDRENDERING_DEBUG_TEXTURE)\nuniform sampler2D debugSampler;\r#endif\nuniform mat4 viewMatrix;\runiform mat4 projectionMatrix;\runiform mat4 invProjectionMatrix;\runiform vec2 texelSize;\runiform vec3 dirLight;\runiform float cameraFar;\runiform float density;\runiform float refractionStrength;\runiform float fresnelClamp;\runiform float specularPower;\rvarying vec2 vUV;\rvec3 computeViewPosFromUVDepth(vec2 texCoord,float depth) {\rvec4 ndc;\rndc.xy=texCoord*2.0-1.0;\r#ifdef FLUIDRENDERING_RHS\nndc.z=-projectionMatrix[2].z+projectionMatrix[3].z/depth;\r#else\nndc.z=projectionMatrix[2].z+projectionMatrix[3].z/depth;\r#endif\nndc.w=1.0;\rvec4 eyePos=invProjectionMatrix*ndc;\reyePos.xyz/=eyePos.w;\rreturn eyePos.xyz;\r}\rvec3 getViewPosFromTexCoord(vec2 texCoord) {\rfloat depth=textureLod(depthSampler,texCoord,0.).x;\rreturn computeViewPosFromUVDepth(texCoord,depth);\r}\rvoid main(void) {\rvec2 texCoord=vUV;\r#if defined(FLUIDRENDERING_DEBUG) && defined(FLUIDRENDERING_DEBUG_TEXTURE)\nvec4 color=texture2D(debugSampler,texCoord);\r#ifdef FLUIDRENDERING_DEBUG_DEPTH\nglFragColor=vec4(color.rgb/vec3(2.0),1.);\rif (color.r>0.999 && color.g>0.999) {\rglFragColor=texture2D(textureSampler,texCoord);\r}\r#else\nglFragColor=vec4(color.rgb,1.);\rif (color.r<0.001 && color.g<0.001 && color.b<0.001) {\rglFragColor=texture2D(textureSampler,texCoord);\r}\r#endif\nreturn;\r#endif\nvec2 depthVel=textureLod(depthSampler,texCoord,0.).rg;\rfloat depth=depthVel.r;\r#ifndef FLUIDRENDERING_FIXED_THICKNESS\nfloat thickness=texture2D(thicknessSampler,texCoord).x;\r#else\nfloat bgDepth=texture2D(bgDepthSampler,texCoord).x;\rfloat depthNonLinear=projectionMatrix[2].z+projectionMatrix[3].z/depth;\rdepthNonLinear=depthNonLinear*0.5+0.5;\r#endif\nvec3 backColor=texture2D(textureSampler,texCoord).rgb;\r#ifndef FLUIDRENDERING_FIXED_THICKNESS\nif (depth>=cameraFar || depth<=0. || thickness<=minimumThickness) {\r#else\nif (depth>=cameraFar || depth<=0. || bgDepth<=depthNonLinear) {\r#endif\nglFragColor=vec4(backColor,1.);\rreturn;\r}\rvec3 viewPos=computeViewPosFromUVDepth(texCoord,depth);\rvec3 ddx=getViewPosFromTexCoord(texCoord+vec2(texelSize.x,0.))-viewPos;\rvec3 ddy=getViewPosFromTexCoord(texCoord+vec2(0.,texelSize.y))-viewPos;\rvec3 ddx2=viewPos-getViewPosFromTexCoord(texCoord+vec2(-texelSize.x,0.));\rif (abs(ddx.z)>abs(ddx2.z)) {\rddx=ddx2;\r}\rvec3 ddy2=viewPos-getViewPosFromTexCoord(texCoord+vec2(0.,-texelSize.y));\rif (abs(ddy.z)>abs(ddy2.z)) {\rddy=ddy2;\r}\rvec3 normal=normalize(cross(ddy,ddx));\r#ifdef FLUIDRENDERING_RHS\nnormal=-normal;\r#endif\n#ifndef WEBGPU\nif(isnan(normal.x) || isnan(normal.y) || isnan(normal.z) || isinf(normal.x) || isinf(normal.y) || isinf(normal.z)) {\rnormal=vec3(0.,0.,-1.);\r}\r#endif\n#if defined(FLUIDRENDERING_DEBUG) && defined(FLUIDRENDERING_DEBUG_SHOWNORMAL)\nglFragColor=vec4(normal*0.5+0.5,1.0);\rreturn;\r#endif\nvec3 rayDir=normalize(viewPos); \r#ifdef FLUIDRENDERING_DIFFUSETEXTURE\nvec3 diffuseColor=texture2D(diffuseSampler,texCoord).rgb;\r#endif\nvec3 lightDir=normalize(vec3(viewMatrix*vec4(-dirLight,0.)));\rvec3 H =normalize(lightDir-rayDir);\rfloat specular=pow(max(0.0,dot(H,normal)),specularPower);\r#ifdef FLUIDRENDERING_DEBUG_DIFFUSERENDERING\nfloat diffuse =max(0.0,dot(lightDir,normal))*1.0;\rglFragColor=vec4(vec3(0.1) /*ambient*/+vec3(0.42,0.50,1.00)*diffuse+vec3(0,0,0.2)+specular,1.);\rreturn;\r#endif\nvec3 refractionDir=refract(rayDir,normal,ETA);\rvec3 transmitted=(texture2D(textureSampler,vec2(texCoord+refractionDir.xy*thickness*refractionStrength)).rgb);\rvec3 transmittance=exp(-density*thickness*(1.0-diffuseColor)); \rvec3 refractionColor=transmitted*transmittance;\r#ifdef FLUIDRENDERING_ENVIRONMENT\nvec3 reflectionDir=reflect(rayDir,normal);\rvec3 reflectionColor=(textureCube(reflectionSampler,reflectionDir).rgb);\rfloat fresnel=clamp(F0+(1.0-F0)*pow(1.0-dot(normal,-rayDir),5.0),0.,fresnelClamp);\rvec3 finalColor=mix(refractionColor,reflectionColor,fresnel)+specular;\r#else\nvec3 finalColor=refractionColor+specular;\r#endif\n#ifdef FLUIDRENDERING_VELOCITY\nfloat velocity=depthVel.g;\rfinalColor=mix(finalColor,vec3(1.0),smoothstep(0.3,1.0,velocity/6.0));\r#endif\nglFragColor=vec4(finalColor,1.);\r}\r`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const fluidRenderingRenderPixelShader = { name, shader };\n//# sourceMappingURL=fluidRenderingRender.fragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nconst name = \"fluidRenderingStandardBlurPixelShader\";\nconst shader = `uniform sampler2D textureSampler;\runiform int filterSize;\runiform vec2 blurDir;\rvarying vec2 vUV;\rvoid main(void) {\rvec4 s=textureLod(textureSampler,vUV,0.);\rif (s.r==0.) {\rglFragColor=vec4(0.,0.,0.,1.);\rreturn;\r}\rfloat sigma=float(filterSize)/3.0;\rfloat twoSigma2=2.0*sigma*sigma;\rvec4 sum=vec4(0.);\rfloat wsum=0.;\rfor (int x=-filterSize; x<=filterSize; ++x) {\rvec2 coords=vec2(x);\rvec4 sampl=textureLod(textureSampler,vUV+coords*blurDir,0.);\rfloat w=exp(-coords.x*coords.x/twoSigma2);\rsum+=sampl*w;\rwsum+=w;\r}\rsum/=wsum;\rglFragColor=vec4(sum.rgb,1.);\r}\r`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const fluidRenderingStandardBlurPixelShader = { name, shader };\n//# sourceMappingURL=fluidRenderingStandardBlur.fragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nconst name = \"fxaaPixelShader\";\nconst shader = `#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)\n#define TEXTUREFUNC(s,c,l) texture2DLodEXT(s,c,l)\n#else\n#define TEXTUREFUNC(s,c,b) texture2D(s,c,b)\n#endif\nuniform sampler2D textureSampler;\runiform vec2 texelSize;\rvarying vec2 vUV;\rvarying vec2 sampleCoordS;\rvarying vec2 sampleCoordE;\rvarying vec2 sampleCoordN;\rvarying vec2 sampleCoordW;\rvarying vec2 sampleCoordNW;\rvarying vec2 sampleCoordSE;\rvarying vec2 sampleCoordNE;\rvarying vec2 sampleCoordSW;\rconst float fxaaQualitySubpix=1.0;\rconst float fxaaQualityEdgeThreshold=0.166;\rconst float fxaaQualityEdgeThresholdMin=0.0833;\rconst vec3 kLumaCoefficients=vec3(0.2126,0.7152,0.0722);\r#define FxaaLuma(rgba) dot(rgba.rgb,kLumaCoefficients)\nvoid main(){\rvec2 posM;\rposM.x=vUV.x;\rposM.y=vUV.y;\rvec4 rgbyM=TEXTUREFUNC(textureSampler,vUV,0.0);\rfloat lumaM=FxaaLuma(rgbyM);\rfloat lumaS=FxaaLuma(TEXTUREFUNC(textureSampler,sampleCoordS,0.0));\rfloat lumaE=FxaaLuma(TEXTUREFUNC(textureSampler,sampleCoordE,0.0));\rfloat lumaN=FxaaLuma(TEXTUREFUNC(textureSampler,sampleCoordN,0.0));\rfloat lumaW=FxaaLuma(TEXTUREFUNC(textureSampler,sampleCoordW,0.0));\rfloat maxSM=max(lumaS,lumaM);\rfloat minSM=min(lumaS,lumaM);\rfloat maxESM=max(lumaE,maxSM);\rfloat minESM=min(lumaE,minSM);\rfloat maxWN=max(lumaN,lumaW);\rfloat minWN=min(lumaN,lumaW);\rfloat rangeMax=max(maxWN,maxESM);\rfloat rangeMin=min(minWN,minESM);\rfloat rangeMaxScaled=rangeMax*fxaaQualityEdgeThreshold;\rfloat range=rangeMax-rangeMin;\rfloat rangeMaxClamped=max(fxaaQualityEdgeThresholdMin,rangeMaxScaled);\r#ifndef MALI\nif(range<rangeMaxClamped) \r{\rgl_FragColor=rgbyM;\rreturn;\r}\r#endif\nfloat lumaNW=FxaaLuma(TEXTUREFUNC(textureSampler,sampleCoordNW,0.0));\rfloat lumaSE=FxaaLuma(TEXTUREFUNC(textureSampler,sampleCoordSE,0.0));\rfloat lumaNE=FxaaLuma(TEXTUREFUNC(textureSampler,sampleCoordNE,0.0));\rfloat lumaSW=FxaaLuma(TEXTUREFUNC(textureSampler,sampleCoordSW,0.0));\rfloat lumaNS=lumaN+lumaS;\rfloat lumaWE=lumaW+lumaE;\rfloat subpixRcpRange=1.0/range;\rfloat subpixNSWE=lumaNS+lumaWE;\rfloat edgeHorz1=(-2.0*lumaM)+lumaNS;\rfloat edgeVert1=(-2.0*lumaM)+lumaWE;\rfloat lumaNESE=lumaNE+lumaSE;\rfloat lumaNWNE=lumaNW+lumaNE;\rfloat edgeHorz2=(-2.0*lumaE)+lumaNESE;\rfloat edgeVert2=(-2.0*lumaN)+lumaNWNE;\rfloat lumaNWSW=lumaNW+lumaSW;\rfloat lumaSWSE=lumaSW+lumaSE;\rfloat edgeHorz4=(abs(edgeHorz1)*2.0)+abs(edgeHorz2);\rfloat edgeVert4=(abs(edgeVert1)*2.0)+abs(edgeVert2);\rfloat edgeHorz3=(-2.0*lumaW)+lumaNWSW;\rfloat edgeVert3=(-2.0*lumaS)+lumaSWSE;\rfloat edgeHorz=abs(edgeHorz3)+edgeHorz4;\rfloat edgeVert=abs(edgeVert3)+edgeVert4;\rfloat subpixNWSWNESE=lumaNWSW+lumaNESE;\rfloat lengthSign=texelSize.x;\rbool horzSpan=edgeHorz>=edgeVert;\rfloat subpixA=subpixNSWE*2.0+subpixNWSWNESE;\rif (!horzSpan)\r{\rlumaN=lumaW;\r}\rif (!horzSpan) \r{\rlumaS=lumaE;\r}\rif (horzSpan) \r{\rlengthSign=texelSize.y;\r}\rfloat subpixB=(subpixA*(1.0/12.0))-lumaM;\rfloat gradientN=lumaN-lumaM;\rfloat gradientS=lumaS-lumaM;\rfloat lumaNN=lumaN+lumaM;\rfloat lumaSS=lumaS+lumaM;\rbool pairN=abs(gradientN)>=abs(gradientS);\rfloat gradient=max(abs(gradientN),abs(gradientS));\rif (pairN)\r{\rlengthSign=-lengthSign;\r}\rfloat subpixC=clamp(abs(subpixB)*subpixRcpRange,0.0,1.0);\rvec2 posB;\rposB.x=posM.x;\rposB.y=posM.y;\rvec2 offNP;\roffNP.x=(!horzSpan) ? 0.0 : texelSize.x;\roffNP.y=(horzSpan) ? 0.0 : texelSize.y;\rif (!horzSpan) \r{\rposB.x+=lengthSign*0.5;\r}\rif (horzSpan)\r{\rposB.y+=lengthSign*0.5;\r}\rvec2 posN;\rposN.x=posB.x-offNP.x*1.5;\rposN.y=posB.y-offNP.y*1.5;\rvec2 posP;\rposP.x=posB.x+offNP.x*1.5;\rposP.y=posB.y+offNP.y*1.5;\rfloat subpixD=((-2.0)*subpixC)+3.0;\rfloat lumaEndN=FxaaLuma(TEXTUREFUNC(textureSampler,posN,0.0));\rfloat subpixE=subpixC*subpixC;\rfloat lumaEndP=FxaaLuma(TEXTUREFUNC(textureSampler,posP,0.0));\rif (!pairN) \r{\rlumaNN=lumaSS;\r}\rfloat gradientScaled=gradient*1.0/4.0;\rfloat lumaMM=lumaM-lumaNN*0.5;\rfloat subpixF=subpixD*subpixE;\rbool lumaMLTZero=lumaMM<0.0;\rlumaEndN-=lumaNN*0.5;\rlumaEndP-=lumaNN*0.5;\rbool doneN=abs(lumaEndN)>=gradientScaled;\rbool doneP=abs(lumaEndP)>=gradientScaled;\rif (!doneN) \r{\rposN.x-=offNP.x*3.0;\r}\rif (!doneN) \r{\rposN.y-=offNP.y*3.0;\r}\rbool doneNP=(!doneN) || (!doneP);\rif (!doneP) \r{\rposP.x+=offNP.x*3.0;\r}\rif (!doneP)\r{\rposP.y+=offNP.y*3.0;\r}\rif (doneNP)\r{\rif (!doneN) lumaEndN=FxaaLuma(TEXTUREFUNC(textureSampler,posN.xy,0.0));\rif (!doneP) lumaEndP=FxaaLuma(TEXTUREFUNC(textureSampler,posP.xy,0.0));\rif (!doneN) lumaEndN=lumaEndN-lumaNN*0.5;\rif (!doneP) lumaEndP=lumaEndP-lumaNN*0.5;\rdoneN=abs(lumaEndN)>=gradientScaled;\rdoneP=abs(lumaEndP)>=gradientScaled;\rif (!doneN) posN.x-=offNP.x*12.0;\rif (!doneN) posN.y-=offNP.y*12.0;\rdoneNP=(!doneN) || (!doneP);\rif (!doneP) posP.x+=offNP.x*12.0;\rif (!doneP) posP.y+=offNP.y*12.0;\r}\rfloat dstN=posM.x-posN.x;\rfloat dstP=posP.x-posM.x;\rif (!horzSpan)\r{\rdstN=posM.y-posN.y;\r}\rif (!horzSpan) \r{\rdstP=posP.y-posM.y;\r}\rbool goodSpanN=(lumaEndN<0.0) != lumaMLTZero;\rfloat spanLength=(dstP+dstN);\rbool goodSpanP=(lumaEndP<0.0) != lumaMLTZero;\rfloat spanLengthRcp=1.0/spanLength;\rbool directionN=dstN<dstP;\rfloat dst=min(dstN,dstP);\rbool goodSpan=directionN ? goodSpanN : goodSpanP;\rfloat subpixG=subpixF*subpixF;\rfloat pixelOffset=(dst*(-spanLengthRcp))+0.5;\rfloat subpixH=subpixG*fxaaQualitySubpix;\rfloat pixelOffsetGood=goodSpan ? pixelOffset : 0.0;\rfloat pixelOffsetSubpix=max(pixelOffsetGood,subpixH);\rif (!horzSpan)\r{\rposM.x+=pixelOffsetSubpix*lengthSign;\r}\rif (horzSpan)\r{\rposM.y+=pixelOffsetSubpix*lengthSign;\r}\r#ifdef MALI\nif(range<rangeMaxClamped) \r{\rgl_FragColor=rgbyM;\r}\relse\r{\rgl_FragColor=TEXTUREFUNC(textureSampler,posM,0.0);\r}\r#else\ngl_FragColor=TEXTUREFUNC(textureSampler,posM,0.0);\r#endif\n}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const fxaaPixelShader = { name, shader };\n//# sourceMappingURL=fxaa.fragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nimport \"./ShadersInclude/clipPlaneFragmentDeclaration.js\";\nimport \"./ShadersInclude/mrtFragmentDeclaration.js\";\nimport \"./ShadersInclude/bumpFragmentMainFunctions.js\";\nimport \"./ShadersInclude/bumpFragmentFunctions.js\";\nimport \"./ShadersInclude/helperFunctions.js\";\nimport \"./ShadersInclude/clipPlaneFragment.js\";\nimport \"./ShadersInclude/bumpFragment.js\";\nconst name = \"geometryPixelShader\";\nconst shader = `#extension GL_EXT_draw_buffers : require\n#if defined(BUMP) || !defined(NORMAL)\n#extension GL_OES_standard_derivatives : enable\n#endif\nprecision highp float;\r#ifdef BUMP\nvarying mat4 vWorldView;\rvarying vec3 vNormalW;\r#else\nvarying vec3 vNormalV;\r#endif\nvarying vec4 vViewPos;\r#if defined(POSITION) || defined(BUMP)\nvarying vec3 vPositionW;\r#endif\n#ifdef VELOCITY\nvarying vec4 vCurrentPosition;\rvarying vec4 vPreviousPosition;\r#endif\n#ifdef NEED_UV\nvarying vec2 vUV;\r#endif\n#ifdef BUMP\nuniform vec3 vBumpInfos;\runiform vec2 vTangentSpaceParams;\r#endif\n#if defined(REFLECTIVITY)\n#if defined(ORMTEXTURE) || defined(SPECULARGLOSSINESSTEXTURE) || defined(REFLECTIVITYTEXTURE)\nuniform sampler2D reflectivitySampler;\rvarying vec2 vReflectivityUV;\r#endif\n#ifdef ALBEDOTEXTURE\nvarying vec2 vAlbedoUV;\runiform sampler2D albedoSampler;\r#endif\n#ifdef REFLECTIVITYCOLOR\nuniform vec3 reflectivityColor;\r#endif\n#ifdef ALBEDOCOLOR\nuniform vec3 albedoColor;\r#endif\n#ifdef METALLIC\nuniform float metallic;\r#endif\n#ifdef ROUGHNESS\nuniform float glossiness;\r#endif\n#endif\n#if defined(ALPHATEST) && defined(NEED_UV)\nuniform sampler2D diffuseSampler;\r#endif\n#include<clipPlaneFragmentDeclaration>\n#include<mrtFragmentDeclaration>[RENDER_TARGET_COUNT]\n#include<bumpFragmentMainFunctions>\n#include<bumpFragmentFunctions>\n#include<helperFunctions>\nvoid main() {\r#include<clipPlaneFragment>\n#ifdef ALPHATEST\nif (texture2D(diffuseSampler,vUV).a<0.4)\rdiscard;\r#endif\nvec3 normalOutput;\r#ifdef BUMP\nvec3 normalW=normalize(vNormalW);\r#include<bumpFragment>\nnormalOutput=normalize(vec3(vWorldView*vec4(normalW,0.0)));\r#else\nnormalOutput=normalize(vNormalV);\r#endif\n#ifdef PREPASS\n#ifdef PREPASS_DEPTH\ngl_FragData[DEPTH_INDEX]=vec4(vViewPos.z/vViewPos.w,0.0,0.0,1.0);\r#endif\n#ifdef PREPASS_NORMAL\ngl_FragData[NORMAL_INDEX]=vec4(normalOutput,1.0);\r#endif\n#else\ngl_FragData[0]=vec4(vViewPos.z/vViewPos.w,0.0,0.0,1.0);\rgl_FragData[1]=vec4(normalOutput,1.0);\r#endif\n#ifdef POSITION\ngl_FragData[POSITION_INDEX]=vec4(vPositionW,1.0);\r#endif\n#ifdef VELOCITY\nvec2 a=(vCurrentPosition.xy/vCurrentPosition.w)*0.5+0.5;\rvec2 b=(vPreviousPosition.xy/vPreviousPosition.w)*0.5+0.5;\rvec2 velocity=abs(a-b);\rvelocity=vec2(pow(velocity.x,1.0/3.0),pow(velocity.y,1.0/3.0))*sign(a-b)*0.5+0.5;\rgl_FragData[VELOCITY_INDEX]=vec4(velocity,0.0,1.0);\r#endif\n#ifdef REFLECTIVITY\nvec4 reflectivity=vec4(1.0,1.0,1.0,1.0);\r#ifdef METALLICWORKFLOW\nfloat metal=1.0;\rfloat roughness=1.0;\r#ifdef ORMTEXTURE\nmetal*=texture2D(reflectivitySampler,vReflectivityUV).b;\rroughness*=texture2D(reflectivitySampler,vReflectivityUV).g;\r#endif\n#ifdef METALLIC\nmetal*=metallic;\r#endif\n#ifdef ROUGHNESS\nroughness*=(1.0-glossiness); \r#endif\nreflectivity.a-=roughness;\rvec3 color=vec3(1.0);\r#ifdef ALBEDOTEXTURE\ncolor=texture2D(albedoSampler,vAlbedoUV).rgb;\r#ifdef GAMMAALBEDO\ncolor=toLinearSpace(color);\r#endif\n#endif\n#ifdef ALBEDOCOLOR\ncolor*=albedoColor.xyz;\r#endif\nreflectivity.rgb=mix(vec3(0.04),color,metal);\r#else\n#if defined(SPECULARGLOSSINESSTEXTURE) || defined(REFLECTIVITYTEXTURE)\nreflectivity=texture2D(reflectivitySampler,vReflectivityUV);\r#ifdef GAMMAREFLECTIVITYTEXTURE\nreflectivity.rgb=toLinearSpace(reflectivity.rgb);\r#endif\n#else \n#ifdef REFLECTIVITYCOLOR\nreflectivity.rgb=reflectivityColor.xyz;\rreflectivity.a=1.0;\r#endif\n#endif\n#ifdef GLOSSINESSS\nreflectivity.a*=glossiness; \r#endif\n#endif\ngl_FragData[REFLECTIVITY_INDEX]=reflectivity;\r#endif\n}\r`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const geometryPixelShader = { name, shader };\n//# sourceMappingURL=geometry.fragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nimport \"./ShadersInclude/bonesDeclaration.js\";\nimport \"./ShadersInclude/bakedVertexAnimationDeclaration.js\";\nimport \"./ShadersInclude/morphTargetsVertexGlobalDeclaration.js\";\nimport \"./ShadersInclude/morphTargetsVertexDeclaration.js\";\nimport \"./ShadersInclude/instancesDeclaration.js\";\nimport \"./ShadersInclude/geometryVertexDeclaration.js\";\nimport \"./ShadersInclude/geometryUboDeclaration.js\";\nimport \"./ShadersInclude/clipPlaneVertexDeclaration.js\";\nimport \"./ShadersInclude/morphTargetsVertexGlobal.js\";\nimport \"./ShadersInclude/morphTargetsVertex.js\";\nimport \"./ShadersInclude/instancesVertex.js\";\nimport \"./ShadersInclude/bonesVertex.js\";\nimport \"./ShadersInclude/bakedVertexAnimation.js\";\nimport \"./ShadersInclude/clipPlaneVertex.js\";\nimport \"./ShadersInclude/bumpVertex.js\";\nconst name = \"geometryVertexShader\";\nconst shader = `precision highp float;\r#include<bonesDeclaration>\n#include<bakedVertexAnimationDeclaration>\n#include<morphTargetsVertexGlobalDeclaration>\n#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]\n#include<instancesDeclaration>\n#include<__decl__geometryVertex>\n#include<clipPlaneVertexDeclaration>\nattribute vec3 position;\rattribute vec3 normal;\r#ifdef NEED_UV\nvarying vec2 vUV;\r#ifdef ALPHATEST\nuniform mat4 diffuseMatrix;\r#endif\n#ifdef BUMP\nuniform mat4 bumpMatrix;\rvarying vec2 vBumpUV;\r#endif\n#ifdef REFLECTIVITY\nuniform mat4 reflectivityMatrix;\runiform mat4 albedoMatrix;\rvarying vec2 vReflectivityUV;\rvarying vec2 vAlbedoUV;\r#endif\n#ifdef UV1\nattribute vec2 uv;\r#endif\n#ifdef UV2\nattribute vec2 uv2;\r#endif\n#endif\n#ifdef BUMP\nvarying mat4 vWorldView;\r#endif\n#ifdef BUMP\nvarying vec3 vNormalW;\r#else\nvarying vec3 vNormalV;\r#endif\nvarying vec4 vViewPos;\r#if defined(POSITION) || defined(BUMP)\nvarying vec3 vPositionW;\r#endif\n#ifdef VELOCITY\nuniform mat4 previousViewProjection;\rvarying vec4 vCurrentPosition;\rvarying vec4 vPreviousPosition;\r#endif\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void)\r{\rvec3 positionUpdated=position;\rvec3 normalUpdated=normal;\r#ifdef UV1\nvec2 uvUpdated=uv;\r#endif\n#include<morphTargetsVertexGlobal>\n#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]\n#include<instancesVertex>\n#if defined(VELOCITY) && !defined(BONES_VELOCITY_ENABLED)\nvCurrentPosition=viewProjection*finalWorld*vec4(positionUpdated,1.0);\rvPreviousPosition=previousViewProjection*finalPreviousWorld*vec4(positionUpdated,1.0);\r#endif\n#include<bonesVertex>\n#include<bakedVertexAnimation>\nvec4 worldPos=vec4(finalWorld*vec4(positionUpdated,1.0));\r#ifdef BUMP\nvWorldView=view*finalWorld;\rvNormalW=normalUpdated;\r#else\nvNormalV=normalize(vec3((view*finalWorld)*vec4(normalUpdated,0.0)));\r#endif\nvViewPos=view*worldPos;\r#if defined(VELOCITY) && defined(BONES_VELOCITY_ENABLED)\nvCurrentPosition=viewProjection*finalWorld*vec4(positionUpdated,1.0);\r#if NUM_BONE_INFLUENCERS>0\nmat4 previousInfluence;\rpreviousInfluence=mPreviousBones[int(matricesIndices[0])]*matricesWeights[0];\r#if NUM_BONE_INFLUENCERS>1\npreviousInfluence+=mPreviousBones[int(matricesIndices[1])]*matricesWeights[1];\r#endif\n#if NUM_BONE_INFLUENCERS>2\npreviousInfluence+=mPreviousBones[int(matricesIndices[2])]*matricesWeights[2];\r#endif\n#if NUM_BONE_INFLUENCERS>3\npreviousInfluence+=mPreviousBones[int(matricesIndices[3])]*matricesWeights[3];\r#endif\n#if NUM_BONE_INFLUENCERS>4\npreviousInfluence+=mPreviousBones[int(matricesIndicesExtra[0])]*matricesWeightsExtra[0];\r#endif\n#if NUM_BONE_INFLUENCERS>5\npreviousInfluence+=mPreviousBones[int(matricesIndicesExtra[1])]*matricesWeightsExtra[1];\r#endif\n#if NUM_BONE_INFLUENCERS>6\npreviousInfluence+=mPreviousBones[int(matricesIndicesExtra[2])]*matricesWeightsExtra[2];\r#endif\n#if NUM_BONE_INFLUENCERS>7\npreviousInfluence+=mPreviousBones[int(matricesIndicesExtra[3])]*matricesWeightsExtra[3];\r#endif\nvPreviousPosition=previousViewProjection*finalPreviousWorld*previousInfluence*vec4(positionUpdated,1.0);\r#else\nvPreviousPosition=previousViewProjection*finalPreviousWorld*vec4(positionUpdated,1.0);\r#endif\n#endif\n#if defined(POSITION) || defined(BUMP)\nvPositionW=worldPos.xyz/worldPos.w;\r#endif\ngl_Position=viewProjection*finalWorld*vec4(positionUpdated,1.0);\r#include<clipPlaneVertex>\n#ifdef NEED_UV\n#ifdef UV1\n#if defined(ALPHATEST) && defined(ALPHATEST_UV1)\nvUV=vec2(diffuseMatrix*vec4(uvUpdated,1.0,0.0));\r#else\nvUV=uv;\r#endif\n#ifdef BUMP_UV1\nvBumpUV=vec2(bumpMatrix*vec4(uvUpdated,1.0,0.0));\r#endif\n#ifdef REFLECTIVITY_UV1\nvReflectivityUV=vec2(reflectivityMatrix*vec4(uvUpdated,1.0,0.0));\r#endif\n#ifdef ALBEDO_UV1\nvAlbedoUV=vec2(albedoMatrix*vec4(uvUpdated,1.0,0.0));\r#endif\n#endif\n#ifdef UV2\n#if defined(ALPHATEST) && defined(ALPHATEST_UV2)\nvUV=vec2(diffuseMatrix*vec4(uv2,1.0,0.0));\r#else\nvUV=uv2;\r#endif\n#ifdef BUMP_UV2\nvBumpUV=vec2(bumpMatrix*vec4(uv2,1.0,0.0));\r#endif\n#ifdef REFLECTIVITY_UV2\nvReflectivityUV=vec2(reflectivityMatrix*vec4(uv2,1.0,0.0));\r#endif\n#ifdef ALBEDO_UV2\nvAlbedoUV=vec2(albedoMatrix*vec4(uv2,1.0,0.0));\r#endif\n#endif\n#endif\n#include<bumpVertex>\n}\r`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const geometryVertexShader = { name, shader };\n//# sourceMappingURL=geometry.vertex.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nimport \"./ShadersInclude/bonesDeclaration.js\";\nimport \"./ShadersInclude/bakedVertexAnimationDeclaration.js\";\nimport \"./ShadersInclude/morphTargetsVertexGlobalDeclaration.js\";\nimport \"./ShadersInclude/morphTargetsVertexDeclaration.js\";\nimport \"./ShadersInclude/clipPlaneVertexDeclaration.js\";\nimport \"./ShadersInclude/instancesDeclaration.js\";\nimport \"./ShadersInclude/morphTargetsVertexGlobal.js\";\nimport \"./ShadersInclude/morphTargetsVertex.js\";\nimport \"./ShadersInclude/instancesVertex.js\";\nimport \"./ShadersInclude/bonesVertex.js\";\nimport \"./ShadersInclude/bakedVertexAnimation.js\";\nimport \"./ShadersInclude/clipPlaneVertex.js\";\nconst name = \"glowMapGenerationVertexShader\";\nconst shader = `attribute vec3 position;\r#include<bonesDeclaration>\n#include<bakedVertexAnimationDeclaration>\n#include<morphTargetsVertexGlobalDeclaration>\n#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]\n#include<clipPlaneVertexDeclaration>\n#include<instancesDeclaration>\nuniform mat4 viewProjection;\rvarying vec4 vPosition;\r#ifdef UV1\nattribute vec2 uv;\r#endif\n#ifdef UV2\nattribute vec2 uv2;\r#endif\n#ifdef DIFFUSE\nvarying vec2 vUVDiffuse;\runiform mat4 diffuseMatrix;\r#endif\n#ifdef OPACITY\nvarying vec2 vUVOpacity;\runiform mat4 opacityMatrix;\r#endif\n#ifdef EMISSIVE\nvarying vec2 vUVEmissive;\runiform mat4 emissiveMatrix;\r#endif\n#ifdef VERTEXALPHA\nattribute vec4 color;\rvarying vec4 vColor;\r#endif\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void)\r{\rvec3 positionUpdated=position;\r#ifdef UV1\nvec2 uvUpdated=uv;\r#endif\n#include<morphTargetsVertexGlobal>\n#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]\n#include<instancesVertex>\n#include<bonesVertex>\n#include<bakedVertexAnimation>\nvec4 worldPos=finalWorld*vec4(positionUpdated,1.0);\r#ifdef CUBEMAP\nvPosition=worldPos;\rgl_Position=viewProjection*finalWorld*vec4(position,1.0);\r#else\nvPosition=viewProjection*worldPos;\rgl_Position=vPosition;\r#endif\n#ifdef DIFFUSE\n#ifdef DIFFUSEUV1\nvUVDiffuse=vec2(diffuseMatrix*vec4(uvUpdated,1.0,0.0));\r#endif\n#ifdef DIFFUSEUV2\nvUVDiffuse=vec2(diffuseMatrix*vec4(uv2,1.0,0.0));\r#endif\n#endif\n#ifdef OPACITY\n#ifdef OPACITYUV1\nvUVOpacity=vec2(opacityMatrix*vec4(uvUpdated,1.0,0.0));\r#endif\n#ifdef OPACITYUV2\nvUVOpacity=vec2(opacityMatrix*vec4(uv2,1.0,0.0));\r#endif\n#endif\n#ifdef EMISSIVE\n#ifdef EMISSIVEUV1\nvUVEmissive=vec2(emissiveMatrix*vec4(uvUpdated,1.0,0.0));\r#endif\n#ifdef EMISSIVEUV2\nvUVEmissive=vec2(emissiveMatrix*vec4(uv2,1.0,0.0));\r#endif\n#endif\n#ifdef VERTEXALPHA\nvColor=color;\r#endif\n#include<clipPlaneVertex>\n}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const glowMapGenerationVertexShader = { name, shader };\n//# sourceMappingURL=glowMapGeneration.vertex.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nconst name = \"glowMapMergePixelShader\";\nconst shader = `varying vec2 vUV;\runiform sampler2D textureSampler;\r#ifdef EMISSIVE\nuniform sampler2D textureSampler2;\r#endif\nuniform float offset;\r#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) {\r#define CUSTOM_FRAGMENT_MAIN_BEGIN\nvec4 baseColor=texture2D(textureSampler,vUV);\r#ifdef EMISSIVE\nbaseColor+=texture2D(textureSampler2,vUV);\rbaseColor*=offset;\r#else\nbaseColor.a=abs(offset-baseColor.a);\r#ifdef STROKE\nfloat alpha=smoothstep(.0,.1,baseColor.a);\rbaseColor.a=alpha;\rbaseColor.rgb=baseColor.rgb*alpha;\r#endif\n#endif\n#if LDR\nbaseColor=clamp(baseColor,0.,1.0);\r#endif\ngl_FragColor=baseColor;\r#define CUSTOM_FRAGMENT_MAIN_END\n}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const glowMapMergePixelShader = { name, shader };\n//# sourceMappingURL=glowMapMerge.fragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nconst name = \"gpuUpdateParticlesVertexShader\";\nconst shader = `#version 300 es\n#define PI 3.14159\nuniform float currentCount;\runiform float timeDelta;\runiform float stopFactor;\r#ifndef LOCAL\nuniform mat4 emitterWM;\r#endif\nuniform vec2 lifeTime;\runiform vec2 emitPower;\runiform vec2 sizeRange;\runiform vec4 scaleRange;\r#ifndef COLORGRADIENTS\nuniform vec4 color1;\runiform vec4 color2;\r#endif\nuniform vec3 gravity;\runiform sampler2D randomSampler;\runiform sampler2D randomSampler2;\runiform vec4 angleRange;\r#ifdef BOXEMITTER\nuniform vec3 direction1;\runiform vec3 direction2;\runiform vec3 minEmitBox;\runiform vec3 maxEmitBox;\r#endif\n#ifdef POINTEMITTER\nuniform vec3 direction1;\runiform vec3 direction2;\r#endif\n#ifdef HEMISPHERICEMITTER\nuniform float radius;\runiform float radiusRange;\runiform float directionRandomizer;\r#endif\n#ifdef SPHEREEMITTER\nuniform float radius;\runiform float radiusRange;\r#ifdef DIRECTEDSPHEREEMITTER\nuniform vec3 direction1;\runiform vec3 direction2;\r#else\nuniform float directionRandomizer;\r#endif\n#endif\n#ifdef CYLINDEREMITTER\nuniform float radius;\runiform float height;\runiform float radiusRange;\r#ifdef DIRECTEDCYLINDEREMITTER\nuniform vec3 direction1;\runiform vec3 direction2;\r#else\nuniform float directionRandomizer;\r#endif\n#endif\n#ifdef CONEEMITTER\nuniform vec2 radius;\runiform float coneAngle;\runiform vec2 height;\runiform float directionRandomizer;\r#endif\nin vec3 position;\r#ifdef CUSTOMEMITTER\nin vec3 initialPosition;\r#endif\nin float age;\rin float life;\rin vec4 seed;\rin vec3 size;\r#ifndef COLORGRADIENTS\nin vec4 color;\r#endif\nin vec3 direction;\r#ifndef BILLBOARD\nin vec3 initialDirection;\r#endif\n#ifdef ANGULARSPEEDGRADIENTS\nin float angle;\r#else\nin vec2 angle;\r#endif\n#ifdef ANIMATESHEET\nin float cellIndex;\r#ifdef ANIMATESHEETRANDOMSTART\nin float cellStartOffset;\r#endif\n#endif\n#ifdef NOISE\nin vec3 noiseCoordinates1;\rin vec3 noiseCoordinates2;\r#endif\nout vec3 outPosition;\r#ifdef CUSTOMEMITTER\nout vec3 outInitialPosition;\r#endif\nout float outAge;\rout float outLife;\rout vec4 outSeed;\rout vec3 outSize;\r#ifndef COLORGRADIENTS\nout vec4 outColor;\r#endif\nout vec3 outDirection;\r#ifndef BILLBOARD\nout vec3 outInitialDirection;\r#endif\n#ifdef ANGULARSPEEDGRADIENTS\nout float outAngle;\r#else\nout vec2 outAngle;\r#endif\n#ifdef ANIMATESHEET\nout float outCellIndex;\r#ifdef ANIMATESHEETRANDOMSTART\nout float outCellStartOffset;\r#endif\n#endif\n#ifdef NOISE\nout vec3 outNoiseCoordinates1;\rout vec3 outNoiseCoordinates2;\r#endif\n#ifdef SIZEGRADIENTS\nuniform sampler2D sizeGradientSampler;\r#endif \n#ifdef ANGULARSPEEDGRADIENTS\nuniform sampler2D angularSpeedGradientSampler;\r#endif \n#ifdef VELOCITYGRADIENTS\nuniform sampler2D velocityGradientSampler;\r#endif\n#ifdef LIMITVELOCITYGRADIENTS\nuniform sampler2D limitVelocityGradientSampler;\runiform float limitVelocityDamping;\r#endif\n#ifdef DRAGGRADIENTS\nuniform sampler2D dragGradientSampler;\r#endif\n#ifdef NOISE\nuniform vec3 noiseStrength;\runiform sampler2D noiseSampler;\r#endif\n#ifdef ANIMATESHEET\nuniform vec4 cellInfos;\r#endif\nvec3 getRandomVec3(float offset) {\rreturn texture(randomSampler2,vec2(float(gl_VertexID)*offset/currentCount,0)).rgb;\r}\rvec4 getRandomVec4(float offset) {\rreturn texture(randomSampler,vec2(float(gl_VertexID)*offset/currentCount,0));\r}\rvoid main() {\rfloat newAge=age+timeDelta; \rif (newAge>=life && stopFactor != 0.) {\rvec3 newPosition;\rvec3 newDirection;\rvec4 randoms=getRandomVec4(seed.x);\routLife=lifeTime.x+(lifeTime.y-lifeTime.x)*randoms.r;\routAge=newAge-life;\routSeed=seed;\r#ifdef SIZEGRADIENTS \noutSize.x=texture(sizeGradientSampler,vec2(0,0)).r;\r#else\noutSize.x=sizeRange.x+(sizeRange.y-sizeRange.x)*randoms.g;\r#endif\noutSize.y=scaleRange.x+(scaleRange.y-scaleRange.x)*randoms.b;\routSize.z=scaleRange.z+(scaleRange.w-scaleRange.z)*randoms.a; \r#ifndef COLORGRADIENTS\noutColor=color1+(color2-color1)*randoms.b;\r#endif\n#ifndef ANGULARSPEEDGRADIENTS \noutAngle.y=angleRange.x+(angleRange.y-angleRange.x)*randoms.a;\routAngle.x=angleRange.z+(angleRange.w-angleRange.z)*randoms.r;\r#else\noutAngle=angleRange.z+(angleRange.w-angleRange.z)*randoms.r;\r#endif \n#ifdef POINTEMITTER\nvec3 randoms2=getRandomVec3(seed.y);\rvec3 randoms3=getRandomVec3(seed.z);\rnewPosition=vec3(0,0,0);\rnewDirection=direction1+(direction2-direction1)*randoms3;\r#elif defined(BOXEMITTER)\nvec3 randoms2=getRandomVec3(seed.y);\rvec3 randoms3=getRandomVec3(seed.z);\rnewPosition=minEmitBox+(maxEmitBox-minEmitBox)*randoms2;\rnewDirection=direction1+(direction2-direction1)*randoms3; \r#elif defined(HEMISPHERICEMITTER)\nvec3 randoms2=getRandomVec3(seed.y);\rvec3 randoms3=getRandomVec3(seed.z);\rfloat phi=2.0*PI*randoms2.x;\rfloat theta=acos(2.0*randoms2.y-1.0);\rfloat randX=cos(phi)*sin(theta);\rfloat randY=cos(theta);\rfloat randZ=sin(phi)*sin(theta);\rnewPosition=(radius-(radius*radiusRange*randoms2.z))*vec3(randX,abs(randY),randZ);\rnewDirection=newPosition+directionRandomizer*randoms3; \r#elif defined(SPHEREEMITTER)\nvec3 randoms2=getRandomVec3(seed.y);\rvec3 randoms3=getRandomVec3(seed.z);\rfloat phi=2.0*PI*randoms2.x;\rfloat theta=acos(2.0*randoms2.y-1.0);\rfloat randX=cos(phi)*sin(theta);\rfloat randY=cos(theta);\rfloat randZ=sin(phi)*sin(theta);\rnewPosition=(radius-(radius*radiusRange*randoms2.z))*vec3(randX,randY,randZ);\r#ifdef DIRECTEDSPHEREEMITTER\nnewDirection=normalize(direction1+(direction2-direction1)*randoms3);\r#else\nnewDirection=normalize(newPosition+directionRandomizer*randoms3);\r#endif\n#elif defined(CYLINDEREMITTER)\nvec3 randoms2=getRandomVec3(seed.y);\rvec3 randoms3=getRandomVec3(seed.z);\rfloat yPos=(randoms2.x-0.5)*height;\rfloat angle=randoms2.y*PI*2.;\rfloat inverseRadiusRangeSquared=((1.-radiusRange)*(1.-radiusRange));\rfloat positionRadius=radius*sqrt(inverseRadiusRangeSquared+(randoms2.z*(1.-inverseRadiusRangeSquared)));\rfloat xPos=positionRadius*cos(angle);\rfloat zPos=positionRadius*sin(angle);\rnewPosition=vec3(xPos,yPos,zPos);\r#ifdef DIRECTEDCYLINDEREMITTER\nnewDirection=direction1+(direction2-direction1)*randoms3;\r#else\nangle=angle+((randoms3.x-0.5)*PI)*directionRandomizer;\rnewDirection=vec3(cos(angle),(randoms3.y-0.5)*directionRandomizer,sin(angle));\rnewDirection=normalize(newDirection);\r#endif\n#elif defined(CONEEMITTER)\nvec3 randoms2=getRandomVec3(seed.y);\rfloat s=2.0*PI*randoms2.x;\r#ifdef CONEEMITTERSPAWNPOINT\nfloat h=0.0001;\r#else\nfloat h=randoms2.y*height.y;\rh=1.-h*h; \r#endif\nfloat lRadius=radius.x-radius.x*randoms2.z*radius.y;\rlRadius=lRadius*h;\rfloat randX=lRadius*sin(s);\rfloat randZ=lRadius*cos(s);\rfloat randY=h *height.x;\rnewPosition=vec3(randX,randY,randZ); \rif (abs(cos(coneAngle))==1.0) {\rnewDirection=vec3(0.,1.0,0.);\r} else {\rvec3 randoms3=getRandomVec3(seed.z);\rnewDirection=normalize(newPosition+directionRandomizer*randoms3); \r}\r#elif defined(CUSTOMEMITTER)\nnewPosition=initialPosition;\routInitialPosition=initialPosition;\r#else \nnewPosition=vec3(0.,0.,0.);\rnewDirection=2.0*(getRandomVec3(seed.w)-vec3(0.5,0.5,0.5));\r#endif\nfloat power=emitPower.x+(emitPower.y-emitPower.x)*randoms.a;\r#ifdef LOCAL\noutPosition=newPosition;\r#else\noutPosition=(emitterWM*vec4(newPosition,1.)).xyz;\r#endif\n#ifdef CUSTOMEMITTER\noutDirection=direction;\r#ifndef BILLBOARD \noutInitialDirection=direction;\r#endif\n#else\n#ifdef LOCAL\nvec3 initial=newDirection;\r#else \nvec3 initial=(emitterWM*vec4(newDirection,0.)).xyz;\r#endif\noutDirection=initial*power;\r#ifndef BILLBOARD \noutInitialDirection=initial;\r#endif\n#endif\n#ifdef ANIMATESHEET \noutCellIndex=cellInfos.x;\r#ifdef ANIMATESHEETRANDOMSTART\noutCellStartOffset=randoms.a*outLife;\r#endif \n#endif\n#ifdef NOISE\noutNoiseCoordinates1=noiseCoordinates1;\routNoiseCoordinates2=noiseCoordinates2;\r#endif\n} else {\rfloat directionScale=timeDelta;\routAge=newAge;\rfloat ageGradient=newAge/life;\r#ifdef VELOCITYGRADIENTS\ndirectionScale*=texture(velocityGradientSampler,vec2(ageGradient,0)).r;\r#endif\n#ifdef DRAGGRADIENTS\ndirectionScale*=1.0-texture(dragGradientSampler,vec2(ageGradient,0)).r;\r#endif\n#if defined(CUSTOMEMITTER)\noutPosition=position+(direction-position)*ageGradient; \routInitialPosition=initialPosition;\r#else\noutPosition=position+direction*directionScale;\r#endif\noutLife=life;\routSeed=seed;\r#ifndef COLORGRADIENTS \noutColor=color;\r#endif\n#ifdef SIZEGRADIENTS\noutSize.x=texture(sizeGradientSampler,vec2(ageGradient,0)).r;\routSize.yz=size.yz;\r#else\noutSize=size;\r#endif \n#ifndef BILLBOARD \noutInitialDirection=initialDirection;\r#endif\n#ifdef CUSTOMEMITTER\noutDirection=direction;\r#else\nvec3 updatedDirection=direction+gravity*timeDelta;\r#ifdef LIMITVELOCITYGRADIENTS\nfloat limitVelocity=texture(limitVelocityGradientSampler,vec2(ageGradient,0)).r;\rfloat currentVelocity=length(updatedDirection);\rif (currentVelocity>limitVelocity) {\rupdatedDirection=updatedDirection*limitVelocityDamping;\r}\r#endif\noutDirection=updatedDirection;\r#ifdef NOISE\nfloat fetchedR=texture(noiseSampler,vec2(noiseCoordinates1.x,noiseCoordinates1.y)*vec2(0.5)+vec2(0.5)).r;\rfloat fetchedG=texture(noiseSampler,vec2(noiseCoordinates1.z,noiseCoordinates2.x)*vec2(0.5)+vec2(0.5)).r;\rfloat fetchedB=texture(noiseSampler,vec2(noiseCoordinates2.y,noiseCoordinates2.z)*vec2(0.5)+vec2(0.5)).r;\rvec3 force=vec3(2.*fetchedR-1.,2.*fetchedG-1.,2.*fetchedB-1.)*noiseStrength;\routDirection=outDirection+force*timeDelta;\routNoiseCoordinates1=noiseCoordinates1;\routNoiseCoordinates2=noiseCoordinates2;\r#endif \n#endif \n#ifdef ANGULARSPEEDGRADIENTS\nfloat angularSpeed=texture(angularSpeedGradientSampler,vec2(ageGradient,0)).r;\routAngle=angle+angularSpeed*timeDelta;\r#else\noutAngle=vec2(angle.x+angle.y*timeDelta,angle.y);\r#endif\n#ifdef ANIMATESHEET \nfloat offsetAge=outAge;\rfloat dist=cellInfos.y-cellInfos.x;\r#ifdef ANIMATESHEETRANDOMSTART\noutCellStartOffset=cellStartOffset;\roffsetAge+=cellStartOffset;\r#else\nfloat cellStartOffset=0.;\r#endif \nfloat ratio=0.;\rif (cellInfos.w==1.0) {\rratio=clamp(mod(cellStartOffset+cellInfos.z*offsetAge,life)/life,0.,1.0);\r}\relse {\rratio=clamp(cellStartOffset+cellInfos.z*offsetAge/life,0.,1.0);\r}\routCellIndex=float(int(cellInfos.x+ratio*dist));\r#endif\n}\r}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const gpuUpdateParticlesVertexShader = { name, shader };\n//# sourceMappingURL=gpuUpdateParticles.vertex.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nimport \"./ShadersInclude/imageProcessingDeclaration.js\";\nimport \"./ShadersInclude/helperFunctions.js\";\nimport \"./ShadersInclude/imageProcessingFunctions.js\";\nconst name = \"imageProcessingPixelShader\";\nconst shader = `varying vec2 vUV;\runiform sampler2D textureSampler;\r#include<imageProcessingDeclaration>\n#include<helperFunctions>\n#include<imageProcessingFunctions>\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void)\r{\rvec4 result=texture2D(textureSampler,vUV);\r#ifdef IMAGEPROCESSING\n#ifndef FROMLINEARSPACE\nresult.rgb=toLinearSpace(result.rgb);\r#endif\nresult=applyImageProcessing(result);\r#else\n#ifdef FROMLINEARSPACE\nresult=applyImageProcessing(result);\r#endif\n#endif\ngl_FragColor=result;\r}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const imageProcessingPixelShader = { name, shader };\n//# sourceMappingURL=imageProcessing.fragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nimport \"./ShadersInclude/kernelBlurVaryingDeclaration.js\";\nimport \"./ShadersInclude/packingFunctions.js\";\nimport \"./ShadersInclude/kernelBlurFragment.js\";\nimport \"./ShadersInclude/kernelBlurFragment2.js\";\nconst name = \"kernelBlurPixelShader\";\nconst shader = `uniform sampler2D textureSampler;\runiform vec2 delta;\rvarying vec2 sampleCenter;\r#ifdef DOF\nuniform sampler2D circleOfConfusionSampler;\rfloat sampleCoC(in vec2 offset) {\rfloat coc=texture2D(circleOfConfusionSampler,offset).r;\rreturn coc; \r}\r#endif\n#include<kernelBlurVaryingDeclaration>[0..varyingCount]\n#ifdef PACKEDFLOAT\n#include<packingFunctions>\n#endif\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void)\r{\rfloat computedWeight=0.0;\r#ifdef PACKEDFLOAT\nfloat blend=0.;\r#else\nvec4 blend=vec4(0.);\r#endif\n#ifdef DOF\nfloat sumOfWeights=CENTER_WEIGHT; \rfloat factor=0.0;\r#ifdef PACKEDFLOAT\nblend+=unpack(texture2D(textureSampler,sampleCenter))*CENTER_WEIGHT;\r#else\nblend+=texture2D(textureSampler,sampleCenter)*CENTER_WEIGHT;\r#endif\n#endif\n#include<kernelBlurFragment>[0..varyingCount]\n#include<kernelBlurFragment2>[0..depCount]\n#ifdef PACKEDFLOAT\ngl_FragColor=pack(blend);\r#else\ngl_FragColor=blend;\r#endif\n#ifdef DOF\ngl_FragColor/=sumOfWeights;\r#endif\n}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const kernelBlurPixelShader = { name, shader };\n//# sourceMappingURL=kernelBlur.fragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nconst name = \"lensHighlightsPixelShader\";\nconst shader = `uniform sampler2D textureSampler; \runiform float gain;\runiform float threshold;\runiform float screen_width;\runiform float screen_height;\rvarying vec2 vUV;\rvec4 highlightColor(vec4 color) {\rvec4 highlight=color;\rfloat luminance=dot(highlight.rgb,vec3(0.2125,0.7154,0.0721));\rfloat lum_threshold;\rif (threshold>1.0) { lum_threshold=0.94+0.01*threshold; }\relse { lum_threshold=0.5+0.44*threshold; }\rluminance=clamp((luminance-lum_threshold)*(1.0/(1.0-lum_threshold)),0.0,1.0);\rhighlight*=luminance*gain;\rhighlight.a=1.0;\rreturn highlight;\r}\r#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void)\r{\rvec4 original=texture2D(textureSampler,vUV);\rif (gain==-1.0) {\rgl_FragColor=vec4(0.0,0.0,0.0,1.0);\rreturn;\r}\rfloat w=2.0/screen_width;\rfloat h=2.0/screen_height;\rfloat weight=1.0;\rvec4 blurred=vec4(0.0,0.0,0.0,0.0);\r#ifdef PENTAGON\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-0.84*w,0.43*h)));\rblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(0.48*w,-1.29*h)));\rblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(0.61*w,1.51*h)));\rblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-1.55*w,-0.74*h)));\rblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.71*w,-0.52*h)));\rblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-0.94*w,1.59*h)));\rblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-0.40*w,-1.87*h)));\rblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.62*w,1.16*h)));\rblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.09*w,0.25*h)));\rblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.46*w,-1.71*h)));\rblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(0.08*w,2.42*h)));\rblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-1.85*w,-1.89*h)));\rblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(2.89*w,0.16*h)));\rblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.29*w,1.88*h)));\rblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(0.40*w,-2.81*h)));\rblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.54*w,2.26*h)));\rblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.60*w,-0.61*h)));\rblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(2.31*w,-1.30*h)));\rblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-0.83*w,2.53*h)));\rblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-1.12*w,-2.48*h)));\rblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(2.60*w,1.11*h)));\rblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.82*w,0.99*h)));\rblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.50*w,-2.81*h)));\rblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(0.85*w,3.33*h)));\rblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.94*w,-1.92*h)));\rblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(3.27*w,-0.53*h)));\rblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-1.95*w,2.48*h)));\rblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-0.23*w,-3.04*h)));\rblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(2.17*w,2.05*h)));\rblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.97*w,-0.04*h)));\rblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(2.25*w,-2.00*h)));\rblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-0.31*w,3.08*h)));\rblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-1.94*w,-2.59*h)));\rblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(3.37*w,0.64*h)));\rblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-3.13*w,1.93*h)));\rblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.03*w,-3.65*h)));\rblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.60*w,3.17*h)));\rblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-3.14*w,-1.19*h)));\rblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(3.00*w,-1.19*h)));\r#else\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-0.85*w,0.36*h)));\rblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(0.52*w,-1.14*h)));\rblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(0.46*w,1.42*h)));\rblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-1.46*w,-0.83*h)));\rblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.79*w,-0.42*h)));\rblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-1.11*w,1.62*h)));\rblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-0.29*w,-2.07*h)));\rblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.69*w,1.39*h)));\rblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.28*w,0.12*h)));\rblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.65*w,-1.69*h)));\rblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-0.08*w,2.44*h)));\rblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-1.63*w,-1.90*h)));\rblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(2.55*w,0.31*h)));\rblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.13*w,1.52*h)));\rblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(0.56*w,-2.61*h)));\rblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.38*w,2.34*h)));\rblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.64*w,-0.81*h)));\rblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(2.53*w,-1.21*h)));\rblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-1.06*w,2.63*h)));\rblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-1.00*w,-2.69*h)));\rblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(2.59*w,1.32*h)));\rblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.82*w,0.78*h)));\rblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.57*w,-2.50*h)));\rblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(0.54*w,2.93*h)));\rblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.39*w,-1.81*h)));\rblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(3.01*w,-0.28*h)));\rblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.04*w,2.25*h)));\rblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-0.02*w,-3.05*h)));\rblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(2.09*w,2.25*h)));\rblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-3.07*w,-0.25*h)));\rblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(2.44*w,-1.90*h)));\rblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-0.52*w,3.05*h)));\rblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-1.68*w,-2.61*h)));\rblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(3.01*w,0.79*h)));\rblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.76*w,1.46*h)));\rblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.05*w,-2.94*h)));\rblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.21*w,2.88*h)));\rblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.84*w,-1.30*h)));\rblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(2.98*w,-0.96*h)));\r#endif\nblurred/=39.0;\rgl_FragColor=blurred;\r}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const lensHighlightsPixelShader = { name, shader };\n//# sourceMappingURL=lensHighlights.fragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nimport \"./ShadersInclude/instancesDeclaration.js\";\nimport \"./ShadersInclude/clipPlaneVertexDeclaration.js\";\nimport \"./ShadersInclude/instancesVertex.js\";\nimport \"./ShadersInclude/clipPlaneVertex.js\";\nconst name = \"lineVertexShader\";\nconst shader = `#include<instancesDeclaration>\n#include<clipPlaneVertexDeclaration>\nattribute vec3 position;\rattribute vec4 normal;\runiform mat4 viewProjection;\runiform float width;\runiform float aspectRatio;\r#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void) {\r#define CUSTOM_VERTEX_MAIN_BEGIN\n#include<instancesVertex>\nmat4 worldViewProjection=viewProjection*finalWorld;\rvec4 viewPosition=worldViewProjection*vec4(position,1.0);\rvec4 viewPositionNext=worldViewProjection*vec4(normal.xyz,1.0);\rvec2 currentScreen=viewPosition.xy/viewPosition.w;\rvec2 nextScreen=viewPositionNext.xy/viewPositionNext.w;\rcurrentScreen.x*=aspectRatio;\rnextScreen.x*=aspectRatio;\rvec2 dir=normalize(nextScreen-currentScreen);\rvec2 normalDir=vec2(-dir.y,dir.x);\rnormalDir*=width/2.0;\rnormalDir.x/=aspectRatio;\rvec4 offset=vec4(normalDir*normal.w,0.0,0.0);\rgl_Position=viewPosition+offset;\r#if defined(CLIPPLANE) || defined(CLIPPLANE2) || defined(CLIPPLANE3) || defined(CLIPPLANE4) || defined(CLIPPLANE5) || defined(CLIPPLANE6)\nvec4 worldPos=finalWorld*vec4(position,1.0);\r#include<clipPlaneVertex>\n#endif\n#define CUSTOM_VERTEX_MAIN_END\n}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const lineVertexShader = { name, shader };\n//# sourceMappingURL=line.vertex.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nconst name = \"oitBackBlendPixelShader\";\nconst shader = `precision highp float;\runiform sampler2D uBackColor;\rvoid main() {\rglFragColor=texelFetch(uBackColor,ivec2(gl_FragCoord.xy),0);\rif (glFragColor.a==0.0) { \rdiscard;\r}\r}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const oitBackBlendPixelShader = { name, shader };\n//# sourceMappingURL=oitBackBlend.fragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nconst name = \"oitFinalPixelShader\";\nconst shader = `precision highp float;\runiform sampler2D uFrontColor;\runiform sampler2D uBackColor;\rvoid main() {\rivec2 fragCoord=ivec2(gl_FragCoord.xy);\rvec4 frontColor=texelFetch(uFrontColor,fragCoord,0);\rvec4 backColor=texelFetch(uBackColor,fragCoord,0);\rfloat alphaMultiplier=1.0-frontColor.a;\rglFragColor=vec4(\rfrontColor.rgb+alphaMultiplier*backColor.rgb,\rfrontColor.a+backColor.a\r);\r}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const oitFinalPixelShader = { name, shader };\n//# sourceMappingURL=oitFinal.fragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nimport \"./ShadersInclude/bonesDeclaration.js\";\nimport \"./ShadersInclude/bakedVertexAnimationDeclaration.js\";\nimport \"./ShadersInclude/morphTargetsVertexGlobalDeclaration.js\";\nimport \"./ShadersInclude/morphTargetsVertexDeclaration.js\";\nimport \"./ShadersInclude/clipPlaneVertexDeclaration.js\";\nimport \"./ShadersInclude/instancesDeclaration.js\";\nimport \"./ShadersInclude/logDepthDeclaration.js\";\nimport \"./ShadersInclude/morphTargetsVertexGlobal.js\";\nimport \"./ShadersInclude/morphTargetsVertex.js\";\nimport \"./ShadersInclude/instancesVertex.js\";\nimport \"./ShadersInclude/bonesVertex.js\";\nimport \"./ShadersInclude/bakedVertexAnimation.js\";\nimport \"./ShadersInclude/clipPlaneVertex.js\";\nimport \"./ShadersInclude/logDepthVertex.js\";\nconst name = \"outlineVertexShader\";\nconst shader = `attribute vec3 position;\rattribute vec3 normal;\r#include<bonesDeclaration>\n#include<bakedVertexAnimationDeclaration>\n#include<morphTargetsVertexGlobalDeclaration>\n#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]\n#include<clipPlaneVertexDeclaration>\nuniform float offset;\r#include<instancesDeclaration>\nuniform mat4 viewProjection;\r#ifdef ALPHATEST\nvarying vec2 vUV;\runiform mat4 diffuseMatrix;\r#ifdef UV1\nattribute vec2 uv;\r#endif\n#ifdef UV2\nattribute vec2 uv2;\r#endif\n#endif\n#include<logDepthDeclaration>\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void)\r{\rvec3 positionUpdated=position;\rvec3 normalUpdated=normal;\r#ifdef UV1\nvec2 uvUpdated=uv;\r#endif\n#include<morphTargetsVertexGlobal>\n#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]\nvec3 offsetPosition=positionUpdated+(normalUpdated*offset);\r#include<instancesVertex>\n#include<bonesVertex>\n#include<bakedVertexAnimation>\nvec4 worldPos=finalWorld*vec4(offsetPosition,1.0);\rgl_Position=viewProjection*worldPos;\r#ifdef ALPHATEST\n#ifdef UV1\nvUV=vec2(diffuseMatrix*vec4(uvUpdated,1.0,0.0));\r#endif\n#ifdef UV2\nvUV=vec2(diffuseMatrix*vec4(uv2,1.0,0.0));\r#endif\n#endif\n#include<clipPlaneVertex>\n#include<logDepthVertex>\n}\r`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const outlineVertexShader = { name, shader };\n//# sourceMappingURL=outline.vertex.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nimport \"./ShadersInclude/clipPlaneFragmentDeclaration.js\";\nimport \"./ShadersInclude/imageProcessingDeclaration.js\";\nimport \"./ShadersInclude/logDepthDeclaration.js\";\nimport \"./ShadersInclude/helperFunctions.js\";\nimport \"./ShadersInclude/imageProcessingFunctions.js\";\nimport \"./ShadersInclude/clipPlaneFragment.js\";\nimport \"./ShadersInclude/logDepthFragment.js\";\nconst name = \"particlesPixelShader\";\nconst shader = `#ifdef LOGARITHMICDEPTH\n#extension GL_EXT_frag_depth : enable\n#endif\nvarying vec2 vUV;\rvarying vec4 vColor;\runiform vec4 textureMask;\runiform sampler2D diffuseSampler;\r#include<clipPlaneFragmentDeclaration>\n#include<imageProcessingDeclaration>\n#include<logDepthDeclaration>\n#include<helperFunctions>\n#include<imageProcessingFunctions>\n#ifdef RAMPGRADIENT\nvarying vec4 remapRanges;\runiform sampler2D rampSampler;\r#endif\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) {\r#define CUSTOM_FRAGMENT_MAIN_BEGIN\n#include<clipPlaneFragment>\nvec4 textureColor=texture2D(diffuseSampler,vUV);\rvec4 baseColor=(textureColor*textureMask+(vec4(1.,1.,1.,1.)-textureMask))*vColor;\r#ifdef RAMPGRADIENT\nfloat alpha=baseColor.a;\rfloat remappedColorIndex=clamp((alpha-remapRanges.x)/remapRanges.y,0.0,1.0);\rvec4 rampColor=texture2D(rampSampler,vec2(1.0-remappedColorIndex,0.));\rbaseColor.rgb*=rampColor.rgb;\rfloat finalAlpha=baseColor.a;\rbaseColor.a=clamp((alpha*rampColor.a-remapRanges.z)/remapRanges.w,0.0,1.0);\r#endif\n#ifdef BLENDMULTIPLYMODE\nfloat sourceAlpha=vColor.a*textureColor.a;\rbaseColor.rgb=baseColor.rgb*sourceAlpha+vec3(1.0)*(1.0-sourceAlpha);\r#endif\n#include<logDepthFragment>\n#ifdef IMAGEPROCESSINGPOSTPROCESS\nbaseColor.rgb=toLinearSpace(baseColor.rgb);\r#else\n#ifdef IMAGEPROCESSING\nbaseColor.rgb=toLinearSpace(baseColor.rgb);\rbaseColor=applyImageProcessing(baseColor);\r#endif\n#endif\ngl_FragColor=baseColor;\r#define CUSTOM_FRAGMENT_MAIN_END\n}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const particlesPixelShader = { name, shader };\n//# sourceMappingURL=particles.fragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nimport \"./ShadersInclude/clipPlaneVertexDeclaration.js\";\nimport \"./ShadersInclude/logDepthDeclaration.js\";\nimport \"./ShadersInclude/clipPlaneVertex.js\";\nimport \"./ShadersInclude/logDepthVertex.js\";\nconst name = \"particlesVertexShader\";\nconst shader = `attribute vec3 position;\rattribute vec4 color;\rattribute float angle;\rattribute vec2 size;\r#ifdef ANIMATESHEET\nattribute float cellIndex;\r#endif\n#ifndef BILLBOARD\nattribute vec3 direction;\r#endif\n#ifdef BILLBOARDSTRETCHED\nattribute vec3 direction;\r#endif\n#ifdef RAMPGRADIENT\nattribute vec4 remapData;\r#endif\nattribute vec2 offset;\runiform mat4 view;\runiform mat4 projection;\runiform vec2 translationPivot;\r#ifdef ANIMATESHEET\nuniform vec3 particlesInfos; \r#endif\nvarying vec2 vUV;\rvarying vec4 vColor;\rvarying vec3 vPositionW;\r#ifdef RAMPGRADIENT\nvarying vec4 remapRanges;\r#endif\n#if defined(BILLBOARD) && !defined(BILLBOARDY) && !defined(BILLBOARDSTRETCHED)\nuniform mat4 invView;\r#endif\n#include<clipPlaneVertexDeclaration>\n#include<logDepthDeclaration>\n#ifdef BILLBOARD\nuniform vec3 eyePosition;\r#endif\nvec3 rotate(vec3 yaxis,vec3 rotatedCorner) {\rvec3 xaxis=normalize(cross(vec3(0.,1.0,0.),yaxis));\rvec3 zaxis=normalize(cross(yaxis,xaxis));\rvec3 row0=vec3(xaxis.x,xaxis.y,xaxis.z);\rvec3 row1=vec3(yaxis.x,yaxis.y,yaxis.z);\rvec3 row2=vec3(zaxis.x,zaxis.y,zaxis.z);\rmat3 rotMatrix= mat3(row0,row1,row2);\rvec3 alignedCorner=rotMatrix*rotatedCorner;\rreturn position+alignedCorner;\r}\r#ifdef BILLBOARDSTRETCHED\nvec3 rotateAlign(vec3 toCamera,vec3 rotatedCorner) {\rvec3 normalizedToCamera=normalize(toCamera);\rvec3 normalizedCrossDirToCamera=normalize(cross(normalize(direction),normalizedToCamera));\rvec3 row0=vec3(normalizedCrossDirToCamera.x,normalizedCrossDirToCamera.y,normalizedCrossDirToCamera.z);\rvec3 row2=vec3(normalizedToCamera.x,normalizedToCamera.y,normalizedToCamera.z);\r#ifdef BILLBOARDSTRETCHED_LOCAL\nvec3 row1=direction;\r#else\nvec3 crossProduct=normalize(cross(normalizedToCamera,normalizedCrossDirToCamera));\rvec3 row1=vec3(crossProduct.x,crossProduct.y,crossProduct.z);\r#endif\nmat3 rotMatrix= mat3(row0,row1,row2);\rvec3 alignedCorner=rotMatrix*rotatedCorner;\rreturn position+alignedCorner;\r}\r#endif\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void) {\r#define CUSTOM_VERTEX_MAIN_BEGIN\nvec2 cornerPos;\rcornerPos=(vec2(offset.x-0.5,offset.y -0.5)-translationPivot)*size+translationPivot;\r#ifdef BILLBOARD\nvec3 rotatedCorner;\r#ifdef BILLBOARDY\nrotatedCorner.x=cornerPos.x*cos(angle)-cornerPos.y*sin(angle);\rrotatedCorner.z=cornerPos.x*sin(angle)+cornerPos.y*cos(angle);\rrotatedCorner.y=0.;\rvec3 yaxis=position-eyePosition;\ryaxis.y=0.;\rvPositionW=rotate(normalize(yaxis),rotatedCorner);\rvec3 viewPos=(view*vec4(vPositionW,1.0)).xyz;\r#elif defined(BILLBOARDSTRETCHED)\nrotatedCorner.x=cornerPos.x*cos(angle)-cornerPos.y*sin(angle);\rrotatedCorner.y=cornerPos.x*sin(angle)+cornerPos.y*cos(angle);\rrotatedCorner.z=0.;\rvec3 toCamera=position-eyePosition;\rvPositionW=rotateAlign(toCamera,rotatedCorner);\rvec3 viewPos=(view*vec4(vPositionW,1.0)).xyz;\r#else\nrotatedCorner.x=cornerPos.x*cos(angle)-cornerPos.y*sin(angle);\rrotatedCorner.y=cornerPos.x*sin(angle)+cornerPos.y*cos(angle);\rrotatedCorner.z=0.;\rvec3 viewPos=(view*vec4(position,1.0)).xyz+rotatedCorner;\rvPositionW=(invView*vec4(viewPos,1)).xyz;\r#endif\n#ifdef RAMPGRADIENT\nremapRanges=remapData;\r#endif\ngl_Position=projection*vec4(viewPos,1.0);\r#else\nvec3 rotatedCorner;\rrotatedCorner.x=cornerPos.x*cos(angle)-cornerPos.y*sin(angle);\rrotatedCorner.z=cornerPos.x*sin(angle)+cornerPos.y*cos(angle);\rrotatedCorner.y=0.;\rvec3 yaxis=normalize(direction);\rvPositionW=rotate(yaxis,rotatedCorner);\rgl_Position=projection*view*vec4(vPositionW,1.0);\r#endif\nvColor=color;\r#ifdef ANIMATESHEET\nfloat rowOffset=floor(cellIndex*particlesInfos.z);\rfloat columnOffset=cellIndex-rowOffset/particlesInfos.z;\rvec2 uvScale=particlesInfos.xy;\rvec2 uvOffset=vec2(offset.x ,1.0-offset.y);\rvUV=(uvOffset+vec2(columnOffset,rowOffset))*uvScale;\r#else\nvUV=offset;\r#endif\n#if defined(CLIPPLANE) || defined(CLIPPLANE2) || defined(CLIPPLANE3) || defined(CLIPPLANE4) || defined(CLIPPLANE5) || defined(CLIPPLANE6)\nvec4 worldPos=vec4(vPositionW,1.0);\r#endif\n#include<clipPlaneVertex>\n#include<logDepthVertex>\n#define CUSTOM_VERTEX_MAIN_END\n}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const particlesVertexShader = { name, shader };\n//# sourceMappingURL=particles.vertex.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nimport \"./ShadersInclude/prePassDeclaration.js\";\nimport \"./ShadersInclude/oitDeclaration.js\";\nimport \"./ShadersInclude/pbrFragmentDeclaration.js\";\nimport \"./ShadersInclude/pbrUboDeclaration.js\";\nimport \"./ShadersInclude/pbrFragmentExtraDeclaration.js\";\nimport \"./ShadersInclude/lightFragmentDeclaration.js\";\nimport \"./ShadersInclude/lightUboDeclaration.js\";\nimport \"./ShadersInclude/pbrFragmentSamplersDeclaration.js\";\nimport \"./ShadersInclude/imageProcessingDeclaration.js\";\nimport \"./ShadersInclude/clipPlaneFragmentDeclaration.js\";\nimport \"./ShadersInclude/logDepthDeclaration.js\";\nimport \"./ShadersInclude/fogFragmentDeclaration.js\";\nimport \"./ShadersInclude/helperFunctions.js\";\nimport \"./ShadersInclude/subSurfaceScatteringFunctions.js\";\nimport \"./ShadersInclude/importanceSampling.js\";\nimport \"./ShadersInclude/pbrHelperFunctions.js\";\nimport \"./ShadersInclude/imageProcessingFunctions.js\";\nimport \"./ShadersInclude/shadowsFragmentFunctions.js\";\nimport \"./ShadersInclude/harmonicsFunctions.js\";\nimport \"./ShadersInclude/pbrDirectLightingSetupFunctions.js\";\nimport \"./ShadersInclude/pbrDirectLightingFalloffFunctions.js\";\nimport \"./ShadersInclude/pbrBRDFFunctions.js\";\nimport \"./ShadersInclude/hdrFilteringFunctions.js\";\nimport \"./ShadersInclude/pbrDirectLightingFunctions.js\";\nimport \"./ShadersInclude/pbrIBLFunctions.js\";\nimport \"./ShadersInclude/bumpFragmentMainFunctions.js\";\nimport \"./ShadersInclude/bumpFragmentFunctions.js\";\nimport \"./ShadersInclude/reflectionFunction.js\";\nimport \"./ShadersInclude/pbrBlockAlbedoOpacity.js\";\nimport \"./ShadersInclude/pbrBlockReflectivity.js\";\nimport \"./ShadersInclude/pbrBlockAmbientOcclusion.js\";\nimport \"./ShadersInclude/pbrBlockAlphaFresnel.js\";\nimport \"./ShadersInclude/pbrBlockAnisotropic.js\";\nimport \"./ShadersInclude/pbrBlockReflection.js\";\nimport \"./ShadersInclude/pbrBlockSheen.js\";\nimport \"./ShadersInclude/pbrBlockClearcoat.js\";\nimport \"./ShadersInclude/pbrBlockIridescence.js\";\nimport \"./ShadersInclude/pbrBlockSubSurface.js\";\nimport \"./ShadersInclude/clipPlaneFragment.js\";\nimport \"./ShadersInclude/pbrBlockNormalGeometric.js\";\nimport \"./ShadersInclude/bumpFragment.js\";\nimport \"./ShadersInclude/pbrBlockNormalFinal.js\";\nimport \"./ShadersInclude/depthPrePass.js\";\nimport \"./ShadersInclude/pbrBlockLightmapInit.js\";\nimport \"./ShadersInclude/pbrBlockGeometryInfo.js\";\nimport \"./ShadersInclude/pbrBlockReflectance0.js\";\nimport \"./ShadersInclude/pbrBlockReflectance.js\";\nimport \"./ShadersInclude/pbrBlockDirectLighting.js\";\nimport \"./ShadersInclude/lightFragment.js\";\nimport \"./ShadersInclude/pbrBlockFinalLitComponents.js\";\nimport \"./ShadersInclude/pbrBlockFinalUnlitComponents.js\";\nimport \"./ShadersInclude/pbrBlockFinalColorComposition.js\";\nimport \"./ShadersInclude/logDepthFragment.js\";\nimport \"./ShadersInclude/fogFragment.js\";\nimport \"./ShadersInclude/pbrBlockImageProcessing.js\";\nimport \"./ShadersInclude/oitFragment.js\";\nimport \"./ShadersInclude/pbrDebug.js\";\nconst name = \"pbrPixelShader\";\nconst shader = `#if defined(BUMP) || !defined(NORMAL) || defined(FORCENORMALFORWARD) || defined(SPECULARAA) || defined(CLEARCOAT_BUMP) || defined(ANISOTROPIC)\n#extension GL_OES_standard_derivatives : enable\n#endif\n#ifdef LODBASEDMICROSFURACE\n#extension GL_EXT_shader_texture_lod : enable\n#endif\n#define CUSTOM_FRAGMENT_BEGIN\n#ifdef LOGARITHMICDEPTH\n#extension GL_EXT_frag_depth : enable\n#endif\n#include<prePassDeclaration>[SCENE_MRT_COUNT]\nprecision highp float;\r#include<oitDeclaration>\n#ifndef FROMLINEARSPACE\n#define FROMLINEARSPACE\n#endif\n#include<__decl__pbrFragment>\n#include<pbrFragmentExtraDeclaration>\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\n#include<pbrFragmentSamplersDeclaration>\n#include<imageProcessingDeclaration>\n#include<clipPlaneFragmentDeclaration>\n#include<logDepthDeclaration>\n#include<fogFragmentDeclaration>\n#include<helperFunctions>\n#include<subSurfaceScatteringFunctions>\n#include<importanceSampling>\n#include<pbrHelperFunctions>\n#include<imageProcessingFunctions>\n#include<shadowsFragmentFunctions>\n#include<harmonicsFunctions>\n#include<pbrDirectLightingSetupFunctions>\n#include<pbrDirectLightingFalloffFunctions>\n#include<pbrBRDFFunctions>\n#include<hdrFilteringFunctions>\n#include<pbrDirectLightingFunctions>\n#include<pbrIBLFunctions>\n#include<bumpFragmentMainFunctions>\n#include<bumpFragmentFunctions>\n#ifdef REFLECTION\n#include<reflectionFunction>\n#endif\n#define CUSTOM_FRAGMENT_DEFINITIONS\n#include<pbrBlockAlbedoOpacity>\n#include<pbrBlockReflectivity>\n#include<pbrBlockAmbientOcclusion>\n#include<pbrBlockAlphaFresnel>\n#include<pbrBlockAnisotropic>\n#include<pbrBlockReflection>\n#include<pbrBlockSheen>\n#include<pbrBlockClearcoat>\n#include<pbrBlockIridescence>\n#include<pbrBlockSubSurface>\nvoid main(void) {\r#define CUSTOM_FRAGMENT_MAIN_BEGIN\n#include<clipPlaneFragment>\n#include<pbrBlockNormalGeometric>\n#include<bumpFragment>\n#include<pbrBlockNormalFinal>\nalbedoOpacityOutParams albedoOpacityOut;\r#ifdef ALBEDO\nvec4 albedoTexture=texture2D(albedoSampler,vAlbedoUV+uvOffset);\r#endif\n#ifdef OPACITY\nvec4 opacityMap=texture2D(opacitySampler,vOpacityUV+uvOffset);\r#endif\nalbedoOpacityBlock(\rvAlbedoColor,\r#ifdef ALBEDO\nalbedoTexture,\rvAlbedoInfos,\r#endif\n#ifdef OPACITY\nopacityMap,\rvOpacityInfos,\r#endif\n#ifdef DETAIL\ndetailColor,\rvDetailInfos,\r#endif\nalbedoOpacityOut\r);\rvec3 surfaceAlbedo=albedoOpacityOut.surfaceAlbedo;\rfloat alpha=albedoOpacityOut.alpha;\r#define CUSTOM_FRAGMENT_UPDATE_ALPHA\n#include<depthPrePass>\n#define CUSTOM_FRAGMENT_BEFORE_LIGHTS\nambientOcclusionOutParams aoOut;\r#ifdef AMBIENT\nvec3 ambientOcclusionColorMap=texture2D(ambientSampler,vAmbientUV+uvOffset).rgb;\r#endif\nambientOcclusionBlock(\r#ifdef AMBIENT\nambientOcclusionColorMap,\rvAmbientInfos,\r#endif\naoOut\r);\r#include<pbrBlockLightmapInit>\n#ifdef UNLIT\nvec3 diffuseBase=vec3(1.,1.,1.);\r#else\nvec3 baseColor=surfaceAlbedo;\rreflectivityOutParams reflectivityOut;\r#if defined(REFLECTIVITY)\nvec4 surfaceMetallicOrReflectivityColorMap=texture2D(reflectivitySampler,vReflectivityUV+uvOffset);\rvec4 baseReflectivity=surfaceMetallicOrReflectivityColorMap;\r#ifndef METALLICWORKFLOW\n#ifdef REFLECTIVITY_GAMMA\nsurfaceMetallicOrReflectivityColorMap=toLinearSpace(surfaceMetallicOrReflectivityColorMap);\r#endif\nsurfaceMetallicOrReflectivityColorMap.rgb*=vReflectivityInfos.y;\r#endif\n#endif\n#if defined(MICROSURFACEMAP)\nvec4 microSurfaceTexel=texture2D(microSurfaceSampler,vMicroSurfaceSamplerUV+uvOffset)*vMicroSurfaceSamplerInfos.y;\r#endif\n#ifdef METALLICWORKFLOW\nvec4 metallicReflectanceFactors=vMetallicReflectanceFactors;\r#ifdef REFLECTANCE\nvec4 reflectanceFactorsMap=texture2D(reflectanceSampler,vReflectanceUV+uvOffset);\r#ifdef REFLECTANCE_GAMMA\nreflectanceFactorsMap=toLinearSpace(reflectanceFactorsMap);\r#endif\nmetallicReflectanceFactors.rgb*=reflectanceFactorsMap.rgb;\r#endif\n#ifdef METALLIC_REFLECTANCE\nvec4 metallicReflectanceFactorsMap=texture2D(metallicReflectanceSampler,vMetallicReflectanceUV+uvOffset);\r#ifdef METALLIC_REFLECTANCE_GAMMA\nmetallicReflectanceFactorsMap=toLinearSpace(metallicReflectanceFactorsMap);\r#endif\n#ifndef METALLIC_REFLECTANCE_USE_ALPHA_ONLY\nmetallicReflectanceFactors.rgb*=metallicReflectanceFactorsMap.rgb;\r#endif\nmetallicReflectanceFactors*=metallicReflectanceFactorsMap.a;\r#endif\n#endif\nreflectivityBlock(\rvReflectivityColor,\r#ifdef METALLICWORKFLOW\nsurfaceAlbedo,\rmetallicReflectanceFactors,\r#endif\n#ifdef REFLECTIVITY\nvReflectivityInfos,\rsurfaceMetallicOrReflectivityColorMap,\r#endif\n#if defined(METALLICWORKFLOW) && defined(REFLECTIVITY) && defined(AOSTOREINMETALMAPRED)\naoOut.ambientOcclusionColor,\r#endif\n#ifdef MICROSURFACEMAP\nmicroSurfaceTexel,\r#endif\n#ifdef DETAIL\ndetailColor,\rvDetailInfos,\r#endif\nreflectivityOut\r);\rfloat microSurface=reflectivityOut.microSurface;\rfloat roughness=reflectivityOut.roughness;\r#ifdef METALLICWORKFLOW\nsurfaceAlbedo=reflectivityOut.surfaceAlbedo;\r#endif\n#if defined(METALLICWORKFLOW) && defined(REFLECTIVITY) && defined(AOSTOREINMETALMAPRED)\naoOut.ambientOcclusionColor=reflectivityOut.ambientOcclusionColor;\r#endif\n#ifdef ALPHAFRESNEL\n#if defined(ALPHATEST) || defined(ALPHABLEND)\nalphaFresnelOutParams alphaFresnelOut;\ralphaFresnelBlock(\rnormalW,\rviewDirectionW,\ralpha,\rmicroSurface,\ralphaFresnelOut\r);\ralpha=alphaFresnelOut.alpha;\r#endif\n#endif\n#include<pbrBlockGeometryInfo>\n#ifdef ANISOTROPIC\nanisotropicOutParams anisotropicOut;\r#ifdef ANISOTROPIC_TEXTURE\nvec3 anisotropyMapData=texture2D(anisotropySampler,vAnisotropyUV+uvOffset).rgb*vAnisotropyInfos.y;\r#endif\nanisotropicBlock(\rvAnisotropy,\r#ifdef ANISOTROPIC_TEXTURE\nanisotropyMapData,\r#endif\nTBN,\rnormalW,\rviewDirectionW,\ranisotropicOut\r);\r#endif\n#ifdef REFLECTION\nreflectionOutParams reflectionOut;\r#ifndef USE_CUSTOM_REFLECTION\nreflectionBlock(\rvPositionW,\rnormalW,\ralphaG,\rvReflectionMicrosurfaceInfos,\rvReflectionInfos,\rvReflectionColor,\r#ifdef ANISOTROPIC\nanisotropicOut,\r#endif\n#if defined(LODINREFLECTIONALPHA) && !defined(REFLECTIONMAP_SKYBOX)\nNdotVUnclamped,\r#endif\n#ifdef LINEARSPECULARREFLECTION\nroughness,\r#endif\nreflectionSampler,\r#if defined(NORMAL) && defined(USESPHERICALINVERTEX)\nvEnvironmentIrradiance,\r#endif\n#ifdef USESPHERICALFROMREFLECTIONMAP\n#if !defined(NORMAL) || !defined(USESPHERICALINVERTEX)\nreflectionMatrix,\r#endif\n#endif\n#ifdef USEIRRADIANCEMAP\nirradianceSampler,\r#endif\n#ifndef LODBASEDMICROSFURACE\nreflectionSamplerLow,\rreflectionSamplerHigh,\r#endif\n#ifdef REALTIME_FILTERING\nvReflectionFilteringInfo,\r#endif\nreflectionOut\r);\r#else\n#define CUSTOM_REFLECTION\n#endif\n#endif\n#include<pbrBlockReflectance0>\n#ifdef SHEEN\nsheenOutParams sheenOut;\r#ifdef SHEEN_TEXTURE\nvec4 sheenMapData=texture2D(sheenSampler,vSheenUV+uvOffset);\r#endif\n#if defined(SHEEN_ROUGHNESS) && defined(SHEEN_TEXTURE_ROUGHNESS) && !defined(SHEEN_TEXTURE_ROUGHNESS_IDENTICAL) && !defined(SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE)\nvec4 sheenMapRoughnessData=texture2D(sheenRoughnessSampler,vSheenRoughnessUV+uvOffset)*vSheenInfos.w;\r#endif\nsheenBlock(\rvSheenColor,\r#ifdef SHEEN_ROUGHNESS\nvSheenRoughness,\r#if defined(SHEEN_TEXTURE_ROUGHNESS) && !defined(SHEEN_TEXTURE_ROUGHNESS_IDENTICAL) && !defined(SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE)\nsheenMapRoughnessData,\r#endif\n#endif\nroughness,\r#ifdef SHEEN_TEXTURE\nsheenMapData,\rvSheenInfos.y,\r#endif\nreflectance,\r#ifdef SHEEN_LINKWITHALBEDO\nbaseColor,\rsurfaceAlbedo,\r#endif\n#ifdef ENVIRONMENTBRDF\nNdotV,\renvironmentBrdf,\r#endif\n#if defined(REFLECTION) && defined(ENVIRONMENTBRDF)\nAARoughnessFactors,\rvReflectionMicrosurfaceInfos,\rvReflectionInfos,\rvReflectionColor,\rvLightingIntensity,\rreflectionSampler,\rreflectionOut.reflectionCoords,\rNdotVUnclamped,\r#ifndef LODBASEDMICROSFURACE\nreflectionSamplerLow,\rreflectionSamplerHigh,\r#endif\n#ifdef REALTIME_FILTERING\nvReflectionFilteringInfo,\r#endif\n#if !defined(REFLECTIONMAP_SKYBOX) && defined(RADIANCEOCCLUSION)\nseo,\r#endif\n#if !defined(REFLECTIONMAP_SKYBOX) && defined(HORIZONOCCLUSION) && defined(BUMP) && defined(REFLECTIONMAP_3D)\neho,\r#endif\n#endif\nsheenOut\r);\r#ifdef SHEEN_LINKWITHALBEDO\nsurfaceAlbedo=sheenOut.surfaceAlbedo;\r#endif\n#endif\n#ifdef CLEARCOAT\n#ifdef CLEARCOAT_TEXTURE\nvec2 clearCoatMapData=texture2D(clearCoatSampler,vClearCoatUV+uvOffset).rg*vClearCoatInfos.y;\r#endif\n#endif\n#ifdef IRIDESCENCE\niridescenceOutParams iridescenceOut;\r#ifdef IRIDESCENCE_TEXTURE\nvec2 iridescenceMapData=texture2D(iridescenceSampler,vIridescenceUV+uvOffset).rg*vIridescenceInfos.y;\r#endif\n#ifdef IRIDESCENCE_THICKNESS_TEXTURE\nvec2 iridescenceThicknessMapData=texture2D(iridescenceThicknessSampler,vIridescenceThicknessUV+uvOffset).rg*vIridescenceInfos.w;\r#endif\niridescenceBlock(\rvIridescenceParams,\rNdotV,\rspecularEnvironmentR0,\r#ifdef IRIDESCENCE_TEXTURE\niridescenceMapData,\r#endif\n#ifdef IRIDESCENCE_THICKNESS_TEXTURE\niridescenceThicknessMapData,\r#endif\n#ifdef CLEARCOAT\nNdotVUnclamped,\r#ifdef CLEARCOAT_TEXTURE\nclearCoatMapData,\r#endif\n#endif\niridescenceOut\r);\rfloat iridescenceIntensity=iridescenceOut.iridescenceIntensity;\rspecularEnvironmentR0=iridescenceOut.specularEnvironmentR0;\r#endif\nclearcoatOutParams clearcoatOut;\r#ifdef CLEARCOAT\n#if defined(CLEARCOAT_TEXTURE_ROUGHNESS) && !defined(CLEARCOAT_TEXTURE_ROUGHNESS_IDENTICAL) && !defined(CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE)\nvec4 clearCoatMapRoughnessData=texture2D(clearCoatRoughnessSampler,vClearCoatRoughnessUV+uvOffset)*vClearCoatInfos.w;\r#endif\n#if defined(CLEARCOAT_TINT) && defined(CLEARCOAT_TINT_TEXTURE)\nvec4 clearCoatTintMapData=texture2D(clearCoatTintSampler,vClearCoatTintUV+uvOffset);\r#endif\n#ifdef CLEARCOAT_BUMP\nvec4 clearCoatBumpMapData=texture2D(clearCoatBumpSampler,vClearCoatBumpUV+uvOffset);\r#endif\nclearcoatBlock(\rvPositionW,\rgeometricNormalW,\rviewDirectionW,\rvClearCoatParams,\r#if defined(CLEARCOAT_TEXTURE_ROUGHNESS) && !defined(CLEARCOAT_TEXTURE_ROUGHNESS_IDENTICAL) && !defined(CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE)\nclearCoatMapRoughnessData,\r#endif\nspecularEnvironmentR0,\r#ifdef CLEARCOAT_TEXTURE\nclearCoatMapData,\r#endif\n#ifdef CLEARCOAT_TINT\nvClearCoatTintParams,\rclearCoatColorAtDistance,\rvClearCoatRefractionParams,\r#ifdef CLEARCOAT_TINT_TEXTURE\nclearCoatTintMapData,\r#endif\n#endif\n#ifdef CLEARCOAT_BUMP\nvClearCoatBumpInfos,\rclearCoatBumpMapData,\rvClearCoatBumpUV,\r#if defined(TANGENT) && defined(NORMAL)\nvTBN,\r#else\nvClearCoatTangentSpaceParams,\r#endif\n#ifdef OBJECTSPACE_NORMALMAP\nnormalMatrix,\r#endif\n#endif\n#if defined(FORCENORMALFORWARD) && defined(NORMAL)\nfaceNormal,\r#endif\n#ifdef REFLECTION\nvReflectionMicrosurfaceInfos,\rvReflectionInfos,\rvReflectionColor,\rvLightingIntensity,\rreflectionSampler,\r#ifndef LODBASEDMICROSFURACE\nreflectionSamplerLow,\rreflectionSamplerHigh,\r#endif\n#ifdef REALTIME_FILTERING\nvReflectionFilteringInfo,\r#endif\n#endif\n#if defined(ENVIRONMENTBRDF) && !defined(REFLECTIONMAP_SKYBOX)\n#ifdef RADIANCEOCCLUSION\nambientMonochrome,\r#endif\n#endif\n#if defined(CLEARCOAT_BUMP) || defined(TWOSIDEDLIGHTING)\n(gl_FrontFacing ? 1. : -1.),\r#endif\nclearcoatOut\r);\r#else\nclearcoatOut.specularEnvironmentR0=specularEnvironmentR0;\r#endif\n#include<pbrBlockReflectance>\nsubSurfaceOutParams subSurfaceOut;\r#ifdef SUBSURFACE\n#ifdef SS_THICKNESSANDMASK_TEXTURE\nvec4 thicknessMap=texture2D(thicknessSampler,vThicknessUV+uvOffset);\r#endif\n#ifdef SS_REFRACTIONINTENSITY_TEXTURE\nvec4 refractionIntensityMap=texture2D(refractionIntensitySampler,vRefractionIntensityUV+uvOffset);\r#endif\n#ifdef SS_TRANSLUCENCYINTENSITY_TEXTURE\nvec4 translucencyIntensityMap=texture2D(translucencyIntensitySampler,vTranslucencyIntensityUV+uvOffset);\r#endif\nsubSurfaceBlock(\rvSubSurfaceIntensity,\rvThicknessParam,\rvTintColor,\rnormalW,\rspecularEnvironmentReflectance,\r#ifdef SS_THICKNESSANDMASK_TEXTURE\nthicknessMap,\r#endif\n#ifdef SS_REFRACTIONINTENSITY_TEXTURE\nrefractionIntensityMap,\r#endif\n#ifdef SS_TRANSLUCENCYINTENSITY_TEXTURE\ntranslucencyIntensityMap,\r#endif\n#ifdef REFLECTION\n#ifdef SS_TRANSLUCENCY\nreflectionMatrix,\r#ifdef USESPHERICALFROMREFLECTIONMAP\n#if !defined(NORMAL) || !defined(USESPHERICALINVERTEX)\nreflectionOut.irradianceVector,\r#endif\n#if defined(REALTIME_FILTERING)\nreflectionSampler,\rvReflectionFilteringInfo,\r#endif\n#endif\n#ifdef USEIRRADIANCEMAP\nirradianceSampler,\r#endif\n#endif\n#endif\n#if defined(SS_REFRACTION) || defined(SS_TRANSLUCENCY)\nsurfaceAlbedo,\r#endif\n#ifdef SS_REFRACTION\nvPositionW,\rviewDirectionW,\rview,\rvRefractionInfos,\rrefractionMatrix,\rvRefractionMicrosurfaceInfos,\rvLightingIntensity,\r#ifdef SS_LINKREFRACTIONTOTRANSPARENCY\nalpha,\r#endif\n#ifdef SS_LODINREFRACTIONALPHA\nNdotVUnclamped,\r#endif\n#ifdef SS_LINEARSPECULARREFRACTION\nroughness,\r#endif\nalphaG,\rrefractionSampler,\r#ifndef LODBASEDMICROSFURACE\nrefractionSamplerLow,\rrefractionSamplerHigh,\r#endif\n#ifdef ANISOTROPIC\nanisotropicOut,\r#endif\n#ifdef REALTIME_FILTERING\nvRefractionFilteringInfo,\r#endif\n#ifdef SS_USE_LOCAL_REFRACTIONMAP_CUBIC\nvRefractionPosition,\rvRefractionSize,\r#endif\n#endif\n#ifdef SS_TRANSLUCENCY\nvDiffusionDistance,\r#endif\nsubSurfaceOut\r);\r#ifdef SS_REFRACTION\nsurfaceAlbedo=subSurfaceOut.surfaceAlbedo;\r#ifdef SS_LINKREFRACTIONTOTRANSPARENCY\nalpha=subSurfaceOut.alpha;\r#endif\n#endif\n#else\nsubSurfaceOut.specularEnvironmentReflectance=specularEnvironmentReflectance;\r#endif\n#include<pbrBlockDirectLighting>\n#include<lightFragment>[0..maxSimultaneousLights]\n#include<pbrBlockFinalLitComponents>\n#endif \n#include<pbrBlockFinalUnlitComponents>\n#define CUSTOM_FRAGMENT_BEFORE_FINALCOLORCOMPOSITION\n#include<pbrBlockFinalColorComposition>\n#include<logDepthFragment>\n#include<fogFragment>(color,finalColor)\n#include<pbrBlockImageProcessing>\n#define CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR\n#ifdef PREPASS\nfloat writeGeometryInfo=finalColor.a>0.4 ? 1.0 : 0.0;\r#ifdef PREPASS_POSITION\ngl_FragData[PREPASS_POSITION_INDEX]=vec4(vPositionW,writeGeometryInfo);\r#endif\n#ifdef PREPASS_VELOCITY\nvec2 a=(vCurrentPosition.xy/vCurrentPosition.w)*0.5+0.5;\rvec2 b=(vPreviousPosition.xy/vPreviousPosition.w)*0.5+0.5;\rvec2 velocity=abs(a-b);\rvelocity=vec2(pow(velocity.x,1.0/3.0),pow(velocity.y,1.0/3.0))*sign(a-b)*0.5+0.5;\rgl_FragData[PREPASS_VELOCITY_INDEX]=vec4(velocity,0.0,writeGeometryInfo);\r#endif\n#ifdef PREPASS_ALBEDO_SQRT\nvec3 sqAlbedo=sqrt(surfaceAlbedo); \r#endif\n#ifdef PREPASS_IRRADIANCE\nvec3 irradiance=finalDiffuse;\r#ifndef UNLIT\n#ifdef REFLECTION\nirradiance+=finalIrradiance;\r#endif\n#endif\n#ifdef SS_SCATTERING\ngl_FragData[0]=vec4(finalColor.rgb-irradiance,finalColor.a); \rirradiance/=sqAlbedo;\r#else\ngl_FragData[0]=finalColor; \rfloat scatteringDiffusionProfile=255.;\r#endif\ngl_FragData[PREPASS_IRRADIANCE_INDEX]=vec4(clamp(irradiance,vec3(0.),vec3(1.)),writeGeometryInfo*scatteringDiffusionProfile/255.); \r#else\ngl_FragData[0]=vec4(finalColor.rgb,finalColor.a);\r#endif\n#ifdef PREPASS_DEPTH\ngl_FragData[PREPASS_DEPTH_INDEX]=vec4(vViewPos.z,0.0,0.0,writeGeometryInfo); \r#endif\n#ifdef PREPASS_NORMAL\ngl_FragData[PREPASS_NORMAL_INDEX]=vec4(normalize((view*vec4(normalW,0.0)).rgb),writeGeometryInfo); \r#endif\n#ifdef PREPASS_ALBEDO_SQRT\ngl_FragData[PREPASS_ALBEDO_SQRT_INDEX]=vec4(sqAlbedo,writeGeometryInfo); \r#endif\n#ifdef PREPASS_REFLECTIVITY\n#ifndef UNLIT\ngl_FragData[PREPASS_REFLECTIVITY_INDEX]=vec4(specularEnvironmentR0,microSurface)*writeGeometryInfo;\r#else\ngl_FragData[PREPASS_REFLECTIVITY_INDEX]=vec4( 0.0,0.0,0.0,1.0 )*writeGeometryInfo;\r#endif\n#endif\n#endif\n#if !defined(PREPASS) || defined(WEBGL2)\ngl_FragColor=finalColor;\r#endif\n#include<oitFragment>\n#if ORDER_INDEPENDENT_TRANSPARENCY\nif (fragDepth==nearestDepth) {\rfrontColor.rgb+=finalColor.rgb*finalColor.a*alphaMultiplier;\rfrontColor.a=1.0-alphaMultiplier*(1.0-finalColor.a);\r} else {\rbackColor+=finalColor;\r}\r#endif\n#include<pbrDebug>\n#define CUSTOM_FRAGMENT_MAIN_END\n}\r`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const pbrPixelShader = { name, shader };\n//# sourceMappingURL=pbr.fragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nimport \"./ShadersInclude/pbrVertexDeclaration.js\";\nimport \"./ShadersInclude/pbrUboDeclaration.js\";\nimport \"./ShadersInclude/uvAttributeDeclaration.js\";\nimport \"./ShadersInclude/mainUVVaryingDeclaration.js\";\nimport \"./ShadersInclude/helperFunctions.js\";\nimport \"./ShadersInclude/bonesDeclaration.js\";\nimport \"./ShadersInclude/bakedVertexAnimationDeclaration.js\";\nimport \"./ShadersInclude/instancesDeclaration.js\";\nimport \"./ShadersInclude/prePassVertexDeclaration.js\";\nimport \"./ShadersInclude/samplerVertexDeclaration.js\";\nimport \"./ShadersInclude/harmonicsFunctions.js\";\nimport \"./ShadersInclude/bumpVertexDeclaration.js\";\nimport \"./ShadersInclude/clipPlaneVertexDeclaration.js\";\nimport \"./ShadersInclude/fogVertexDeclaration.js\";\nimport \"./ShadersInclude/lightVxFragmentDeclaration.js\";\nimport \"./ShadersInclude/lightVxUboDeclaration.js\";\nimport \"./ShadersInclude/morphTargetsVertexGlobalDeclaration.js\";\nimport \"./ShadersInclude/morphTargetsVertexDeclaration.js\";\nimport \"./ShadersInclude/logDepthDeclaration.js\";\nimport \"./ShadersInclude/morphTargetsVertexGlobal.js\";\nimport \"./ShadersInclude/morphTargetsVertex.js\";\nimport \"./ShadersInclude/instancesVertex.js\";\nimport \"./ShadersInclude/bonesVertex.js\";\nimport \"./ShadersInclude/bakedVertexAnimation.js\";\nimport \"./ShadersInclude/prePassVertex.js\";\nimport \"./ShadersInclude/uvVariableDeclaration.js\";\nimport \"./ShadersInclude/samplerVertexImplementation.js\";\nimport \"./ShadersInclude/bumpVertex.js\";\nimport \"./ShadersInclude/clipPlaneVertex.js\";\nimport \"./ShadersInclude/fogVertex.js\";\nimport \"./ShadersInclude/shadowsVertex.js\";\nimport \"./ShadersInclude/vertexColorMixing.js\";\nimport \"./ShadersInclude/logDepthVertex.js\";\nconst name = \"pbrVertexShader\";\nconst shader = `precision highp float;\r#include<__decl__pbrVertex>\n#define CUSTOM_VERTEX_BEGIN\nattribute vec3 position;\r#ifdef NORMAL\nattribute vec3 normal;\r#endif\n#ifdef TANGENT\nattribute vec4 tangent;\r#endif\n#ifdef UV1\nattribute vec2 uv;\r#endif\n#include<uvAttributeDeclaration>[2..7]\n#include<mainUVVaryingDeclaration>[1..7]\n#ifdef VERTEXCOLOR\nattribute vec4 color;\r#endif\n#include<helperFunctions>\n#include<bonesDeclaration>\n#include<bakedVertexAnimationDeclaration>\n#include<instancesDeclaration>\n#include<prePassVertexDeclaration>\n#include<samplerVertexDeclaration>(_DEFINENAME_,ALBEDO,_VARYINGNAME_,Albedo)\n#include<samplerVertexDeclaration>(_DEFINENAME_,DETAIL,_VARYINGNAME_,Detail)\n#include<samplerVertexDeclaration>(_DEFINENAME_,AMBIENT,_VARYINGNAME_,Ambient)\n#include<samplerVertexDeclaration>(_DEFINENAME_,OPACITY,_VARYINGNAME_,Opacity)\n#include<samplerVertexDeclaration>(_DEFINENAME_,EMISSIVE,_VARYINGNAME_,Emissive)\n#include<samplerVertexDeclaration>(_DEFINENAME_,LIGHTMAP,_VARYINGNAME_,Lightmap)\n#include<samplerVertexDeclaration>(_DEFINENAME_,REFLECTIVITY,_VARYINGNAME_,Reflectivity)\n#include<samplerVertexDeclaration>(_DEFINENAME_,MICROSURFACEMAP,_VARYINGNAME_,MicroSurfaceSampler)\n#include<samplerVertexDeclaration>(_DEFINENAME_,METALLIC_REFLECTANCE,_VARYINGNAME_,MetallicReflectance)\n#include<samplerVertexDeclaration>(_DEFINENAME_,REFLECTANCE,_VARYINGNAME_,Reflectance)\n#include<samplerVertexDeclaration>(_DEFINENAME_,BUMP,_VARYINGNAME_,Bump)\n#ifdef CLEARCOAT\n#include<samplerVertexDeclaration>(_DEFINENAME_,CLEARCOAT_TEXTURE,_VARYINGNAME_,ClearCoat)\n#include<samplerVertexDeclaration>(_DEFINENAME_,CLEARCOAT_TEXTURE_ROUGHNESS,_VARYINGNAME_,ClearCoatRoughness)\n#include<samplerVertexDeclaration>(_DEFINENAME_,CLEARCOAT_BUMP,_VARYINGNAME_,ClearCoatBump)\n#include<samplerVertexDeclaration>(_DEFINENAME_,CLEARCOAT_TINT_TEXTURE,_VARYINGNAME_,ClearCoatTint)\n#endif\n#ifdef IRIDESCENCE\n#include<samplerVertexDeclaration>(_DEFINENAME_,IRIDESCENCE_TEXTURE,_VARYINGNAME_,Iridescence)\n#include<samplerVertexDeclaration>(_DEFINENAME_,IRIDESCENCE_THICKNESS_TEXTURE,_VARYINGNAME_,IridescenceThickness)\n#endif\n#ifdef SHEEN\n#include<samplerVertexDeclaration>(_DEFINENAME_,SHEEN_TEXTURE,_VARYINGNAME_,Sheen)\n#include<samplerVertexDeclaration>(_DEFINENAME_,SHEEN_TEXTURE_ROUGHNESS,_VARYINGNAME_,SheenRoughness)\n#endif\n#ifdef ANISOTROPIC\n#include<samplerVertexDeclaration>(_DEFINENAME_,ANISOTROPIC_TEXTURE,_VARYINGNAME_,Anisotropy)\n#endif\n#ifdef SUBSURFACE\n#include<samplerVertexDeclaration>(_DEFINENAME_,SS_THICKNESSANDMASK_TEXTURE,_VARYINGNAME_,Thickness)\n#include<samplerVertexDeclaration>(_DEFINENAME_,SS_REFRACTIONINTENSITY_TEXTURE,_VARYINGNAME_,RefractionIntensity)\n#include<samplerVertexDeclaration>(_DEFINENAME_,SS_TRANSLUCENCYINTENSITY_TEXTURE,_VARYINGNAME_,TranslucencyIntensity)\n#endif\nvarying vec3 vPositionW;\r#if DEBUGMODE>0\nvarying vec4 vClipSpacePosition;\r#endif\n#ifdef NORMAL\nvarying vec3 vNormalW;\r#if defined(USESPHERICALFROMREFLECTIONMAP) && defined(USESPHERICALINVERTEX)\nvarying vec3 vEnvironmentIrradiance;\r#include<harmonicsFunctions>\n#endif\n#endif\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nvarying vec4 vColor;\r#endif\n#include<bumpVertexDeclaration>\n#include<clipPlaneVertexDeclaration>\n#include<fogVertexDeclaration>\n#include<__decl__lightVxFragment>[0..maxSimultaneousLights]\n#include<morphTargetsVertexGlobalDeclaration>\n#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]\n#ifdef REFLECTIONMAP_SKYBOX\nvarying vec3 vPositionUVW;\r#endif\n#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\nvarying vec3 vDirectionW;\r#endif\n#include<logDepthDeclaration>\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void) {\r#define CUSTOM_VERTEX_MAIN_BEGIN\nvec3 positionUpdated=position;\r#ifdef NORMAL\nvec3 normalUpdated=normal;\r#endif\n#ifdef TANGENT\nvec4 tangentUpdated=tangent;\r#endif\n#ifdef UV1\nvec2 uvUpdated=uv;\r#endif\n#include<morphTargetsVertexGlobal>\n#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]\n#ifdef REFLECTIONMAP_SKYBOX\nvPositionUVW=positionUpdated;\r#endif\n#define CUSTOM_VERTEX_UPDATE_POSITION\n#define CUSTOM_VERTEX_UPDATE_NORMAL\n#include<instancesVertex>\n#if defined(PREPASS) && defined(PREPASS_VELOCITY) && !defined(BONES_VELOCITY_ENABLED)\nvCurrentPosition=viewProjection*finalWorld*vec4(positionUpdated,1.0);\rvPreviousPosition=previousViewProjection*finalPreviousWorld*vec4(positionUpdated,1.0);\r#endif\n#include<bonesVertex>\n#include<bakedVertexAnimation>\nvec4 worldPos=finalWorld*vec4(positionUpdated,1.0);\rvPositionW=vec3(worldPos);\r#include<prePassVertex>\n#ifdef NORMAL\nmat3 normalWorld=mat3(finalWorld);\r#if defined(INSTANCES) && defined(THIN_INSTANCES)\nvNormalW=normalUpdated/vec3(dot(normalWorld[0],normalWorld[0]),dot(normalWorld[1],normalWorld[1]),dot(normalWorld[2],normalWorld[2]));\rvNormalW=normalize(normalWorld*vNormalW);\r#else\n#ifdef NONUNIFORMSCALING\nnormalWorld=transposeMat3(inverseMat3(normalWorld));\r#endif\nvNormalW=normalize(normalWorld*normalUpdated);\r#endif\n#if defined(USESPHERICALFROMREFLECTIONMAP) && defined(USESPHERICALINVERTEX)\nvec3 reflectionVector=vec3(reflectionMatrix*vec4(vNormalW,0)).xyz;\r#ifdef REFLECTIONMAP_OPPOSITEZ\nreflectionVector.z*=-1.0;\r#endif\nvEnvironmentIrradiance=computeEnvironmentIrradiance(reflectionVector);\r#endif\n#endif\n#define CUSTOM_VERTEX_UPDATE_WORLDPOS\n#ifdef MULTIVIEW\nif (gl_ViewID_OVR==0u) {\rgl_Position=viewProjection*worldPos;\r} else {\rgl_Position=viewProjectionR*worldPos;\r}\r#else\ngl_Position=viewProjection*worldPos;\r#endif\n#if DEBUGMODE>0\nvClipSpacePosition=gl_Position;\r#endif\n#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\nvDirectionW=normalize(vec3(finalWorld*vec4(positionUpdated,0.0)));\r#endif\n#ifndef UV1\nvec2 uvUpdated=vec2(0.,0.);\r#endif\n#ifdef MAINUV1\nvMainUV1=uvUpdated;\r#endif\n#include<uvVariableDeclaration>[2..7]\n#include<samplerVertexImplementation>(_DEFINENAME_,ALBEDO,_VARYINGNAME_,Albedo,_MATRIXNAME_,albedo,_INFONAME_,AlbedoInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,DETAIL,_VARYINGNAME_,Detail,_MATRIXNAME_,detail,_INFONAME_,DetailInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,AMBIENT,_VARYINGNAME_,Ambient,_MATRIXNAME_,ambient,_INFONAME_,AmbientInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,OPACITY,_VARYINGNAME_,Opacity,_MATRIXNAME_,opacity,_INFONAME_,OpacityInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,EMISSIVE,_VARYINGNAME_,Emissive,_MATRIXNAME_,emissive,_INFONAME_,EmissiveInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,LIGHTMAP,_VARYINGNAME_,Lightmap,_MATRIXNAME_,lightmap,_INFONAME_,LightmapInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,REFLECTIVITY,_VARYINGNAME_,Reflectivity,_MATRIXNAME_,reflectivity,_INFONAME_,ReflectivityInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,MICROSURFACEMAP,_VARYINGNAME_,MicroSurfaceSampler,_MATRIXNAME_,microSurfaceSampler,_INFONAME_,MicroSurfaceSamplerInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,METALLIC_REFLECTANCE,_VARYINGNAME_,MetallicReflectance,_MATRIXNAME_,metallicReflectance,_INFONAME_,MetallicReflectanceInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,REFLECTANCE,_VARYINGNAME_,Reflectance,_MATRIXNAME_,reflectance,_INFONAME_,ReflectanceInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,BUMP,_VARYINGNAME_,Bump,_MATRIXNAME_,bump,_INFONAME_,BumpInfos.x)\n#ifdef CLEARCOAT\n#include<samplerVertexImplementation>(_DEFINENAME_,CLEARCOAT_TEXTURE,_VARYINGNAME_,ClearCoat,_MATRIXNAME_,clearCoat,_INFONAME_,ClearCoatInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,CLEARCOAT_TEXTURE_ROUGHNESS,_VARYINGNAME_,ClearCoatRoughness,_MATRIXNAME_,clearCoatRoughness,_INFONAME_,ClearCoatInfos.z)\n#include<samplerVertexImplementation>(_DEFINENAME_,CLEARCOAT_BUMP,_VARYINGNAME_,ClearCoatBump,_MATRIXNAME_,clearCoatBump,_INFONAME_,ClearCoatBumpInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,CLEARCOAT_TINT_TEXTURE,_VARYINGNAME_,ClearCoatTint,_MATRIXNAME_,clearCoatTint,_INFONAME_,ClearCoatTintInfos.x)\n#endif\n#ifdef IRIDESCENCE\n#include<samplerVertexImplementation>(_DEFINENAME_,IRIDESCENCE_TEXTURE,_VARYINGNAME_,Iridescence,_MATRIXNAME_,iridescence,_INFONAME_,IridescenceInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,IRIDESCENCE_THICKNESS_TEXTURE,_VARYINGNAME_,IridescenceThickness,_MATRIXNAME_,iridescenceThickness,_INFONAME_,IridescenceInfos.z)\n#endif\n#ifdef SHEEN\n#include<samplerVertexImplementation>(_DEFINENAME_,SHEEN_TEXTURE,_VARYINGNAME_,Sheen,_MATRIXNAME_,sheen,_INFONAME_,SheenInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,SHEEN_TEXTURE_ROUGHNESS,_VARYINGNAME_,SheenRoughness,_MATRIXNAME_,sheen,_INFONAME_,SheenInfos.z)\n#endif\n#ifdef ANISOTROPIC\n#include<samplerVertexImplementation>(_DEFINENAME_,ANISOTROPIC_TEXTURE,_VARYINGNAME_,Anisotropy,_MATRIXNAME_,anisotropy,_INFONAME_,AnisotropyInfos.x)\n#endif\n#ifdef SUBSURFACE\n#include<samplerVertexImplementation>(_DEFINENAME_,SS_THICKNESSANDMASK_TEXTURE,_VARYINGNAME_,Thickness,_MATRIXNAME_,thickness,_INFONAME_,ThicknessInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,SS_REFRACTIONINTENSITY_TEXTURE,_VARYINGNAME_,RefractionIntensity,_MATRIXNAME_,refractionIntensity,_INFONAME_,RefractionIntensityInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,SS_TRANSLUCENCYINTENSITY_TEXTURE,_VARYINGNAME_,TranslucencyIntensity,_MATRIXNAME_,translucencyIntensity,_INFONAME_,TranslucencyIntensityInfos.x)\n#endif\n#include<bumpVertex>\n#include<clipPlaneVertex>\n#include<fogVertex>\n#include<shadowsVertex>[0..maxSimultaneousLights]\n#include<vertexColorMixing>\n#if defined(POINTSIZE) && !defined(WEBGPU)\ngl_PointSize=pointSize;\r#endif\n#include<logDepthVertex>\n#define CUSTOM_VERTEX_MAIN_END\n}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const pbrVertexShader = { name, shader };\n//# sourceMappingURL=pbr.vertex.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nconst name = \"proceduralVertexShader\";\nconst shader = `attribute vec2 position;\rvarying vec2 vPosition;\rvarying vec2 vUV;\rconst vec2 madd=vec2(0.5,0.5);\r#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void) {\r#define CUSTOM_VERTEX_MAIN_BEGIN\nvPosition=position;\rvUV=position*madd+madd;\rgl_Position=vec4(position,0.0,1.0);\r#define CUSTOM_VERTEX_MAIN_END\n}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const proceduralVertexShader = { name, shader };\n//# sourceMappingURL=procedural.vertex.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nconst name = \"refractionPixelShader\";\nconst shader = `varying vec2 vUV;\runiform sampler2D textureSampler;\runiform sampler2D refractionSampler;\runiform vec3 baseColor;\runiform float depth;\runiform float colorLevel;\rvoid main() {\rfloat ref=1.0-texture2D(refractionSampler,vUV).r;\rvec2 uv=vUV-vec2(0.5);\rvec2 offset=uv*depth*ref;\rvec3 sourceColor=texture2D(textureSampler,vUV-offset).rgb;\rgl_FragColor=vec4(sourceColor+sourceColor*ref*colorLevel,1.0);\r}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const refractionPixelShader = { name, shader };\n//# sourceMappingURL=refraction.fragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nimport \"./ShadersInclude/helperFunctions.js\";\nconst name = \"rgbdDecodePixelShader\";\nconst shader = `varying vec2 vUV;\runiform sampler2D textureSampler;\r#include<helperFunctions>\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) \r{\rgl_FragColor=vec4(fromRGBD(texture2D(textureSampler,vUV)),1.0);\r}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const rgbdDecodePixelShader = { name, shader };\n//# sourceMappingURL=rgbdDecode.fragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nconst name = \"screenSpaceCurvaturePixelShader\";\nconst shader = `precision highp float;\rvarying vec2 vUV;\runiform sampler2D textureSampler;\runiform sampler2D normalSampler;\runiform float curvature_ridge;\runiform float curvature_valley;\r#ifndef CURVATURE_OFFSET\n#define CURVATURE_OFFSET 1\n#endif\nfloat curvature_soft_clamp(float curvature,float control)\r{\rif (curvature<0.5/control)\rreturn curvature*(1.0-curvature*control);\rreturn 0.25/control;\r}\rfloat calculate_curvature(ivec2 texel,float ridge,float valley)\r{\rvec2 normal_up =texelFetch(normalSampler,texel+ivec2(0, CURVATURE_OFFSET),0).rb;\rvec2 normal_down =texelFetch(normalSampler,texel+ivec2(0,-CURVATURE_OFFSET),0).rb;\rvec2 normal_left =texelFetch(normalSampler,texel+ivec2(-CURVATURE_OFFSET,0),0).rb;\rvec2 normal_right=texelFetch(normalSampler,texel+ivec2( CURVATURE_OFFSET,0),0).rb;\rfloat normal_diff=((normal_up.g-normal_down.g)+(normal_right.r-normal_left.r));\rif (normal_diff<0.0)\rreturn -2.0*curvature_soft_clamp(-normal_diff,valley);\rreturn 2.0*curvature_soft_clamp(normal_diff,ridge);\r}\r#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) \r{\rivec2 texel=ivec2(gl_FragCoord.xy);\rvec4 baseColor=texture2D(textureSampler,vUV);\rfloat curvature=calculate_curvature(texel,curvature_ridge,curvature_valley);\rbaseColor.rgb*=curvature+1.0;\rgl_FragColor=baseColor;\r}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const screenSpaceCurvaturePixelShader = { name, shader };\n//# sourceMappingURL=screenSpaceCurvature.fragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nconst name = \"screenSpaceReflectionPixelShader\";\nconst shader = `uniform sampler2D textureSampler;\r#ifdef SSR_SUPPORTED\nuniform sampler2D reflectivitySampler;\runiform sampler2D normalSampler;\runiform sampler2D positionSampler;\r#endif\nuniform mat4 view;\runiform mat4 projection;\runiform float stepSize;\runiform float strength;\runiform float threshold;\runiform float roughnessFactor;\runiform float reflectionSpecularFalloffExponent;\rvarying vec2 vUV;\r#ifdef SSR_SUPPORTED\nstruct ReflectionInfo {\rvec3 color;\rvec4 coords;\r};\r/**\r* According to specular,see https:\r*/\rvec3 fresnelSchlick(float cosTheta,vec3 F0)\r{\rreturn F0+(1.0-F0)*pow(1.0-cosTheta,5.0);\r}\r/**\r* Once the pixel's coordinates has been found,let's adjust (smooth) a little bit\r* by sampling multiple reflection pixels.\r*/\rReflectionInfo smoothReflectionInfo(vec3 dir,vec3 hitCoord)\r{\rReflectionInfo info;\rinfo.color=vec3(0.0);\rvec4 projectedCoord;\rfloat sampledDepth;\rfor(int i=0; i<SMOOTH_STEPS; i++)\r{\rprojectedCoord=projection*vec4(hitCoord,1.0);\rprojectedCoord.xy/=projectedCoord.w;\rprojectedCoord.xy=0.5*projectedCoord.xy+vec2(0.5);\rsampledDepth=(view*texture2D(positionSampler,projectedCoord.xy)).z;\rfloat depth=sampledDepth-hitCoord.z;\rdir*=0.5;\rif(depth>0.0)\rhitCoord-=dir;\relse\rhitCoord+=dir;\rinfo.color+=texture2D(textureSampler,projectedCoord.xy).rgb;\r}\rprojectedCoord=projection*vec4(hitCoord,1.0);\rprojectedCoord.xy/=projectedCoord.w;\rprojectedCoord.xy=0.5*projectedCoord.xy+vec2(0.5);\rinfo.coords=vec4(projectedCoord.xy,sampledDepth,1.0);\rinfo.color+=texture2D(textureSampler,projectedCoord.xy).rgb;\rinfo.color/=float(SMOOTH_STEPS+1);\rreturn info;\r}\r/**\r* Tests the given world position (hitCoord) according to the given reflection vector (dir)\r* until it finds a collision (means that depth is enough close to say \"it's the pixel to sample!\").\r*/\rReflectionInfo getReflectionInfo(vec3 dir,vec3 hitCoord)\r{\rReflectionInfo info;\rvec4 projectedCoord;\rfloat sampledDepth;\rdir*=stepSize;\rfor(int i=0; i<REFLECTION_SAMPLES; i++)\r{\rhitCoord+=dir;\rprojectedCoord=projection*vec4(hitCoord,1.0);\rprojectedCoord.xy/=projectedCoord.w;\rprojectedCoord.xy=0.5*projectedCoord.xy+vec2(0.5);\rsampledDepth=(view*texture2D(positionSampler,projectedCoord.xy)).z;\rfloat depth=sampledDepth-hitCoord.z;\r#ifdef RIGHT_HANDED_SCENE\ndepth*=-1.0;\r#endif\nif(((depth-dir.z)<threshold) && depth<=0.0)\r{\r#ifdef ENABLE_SMOOTH_REFLECTIONS\nreturn smoothReflectionInfo(dir,hitCoord);\r#else\ninfo.color=texture2D(textureSampler,projectedCoord.xy).rgb;\rinfo.coords=vec4(projectedCoord.xy,sampledDepth,0.0);\rreturn info;\r#endif\n}\r}\rinfo.color=texture2D(textureSampler,projectedCoord.xy).rgb;\rinfo.coords=vec4(projectedCoord.xy,sampledDepth,0.0);\rreturn info;\r}\rvec3 hash(vec3 a)\r{\ra=fract(a*0.8);\ra+=dot(a,a.yxz+19.19);\rreturn fract((a.xxy+a.yxx)*a.zyx);\r}\r#endif\nvoid main()\r{\r#ifdef SSR_SUPPORTED\nvec4 albedoFull=texture2D(textureSampler,vUV);\rvec3 albedo=albedoFull.rgb;\rfloat spec=texture2D(reflectivitySampler,vUV).r;\rif (spec==0.0) {\rgl_FragColor=albedoFull;\rreturn;\r}\rvec3 normal=(texture2D(normalSampler,vUV)).xyz;\rvec3 position=(view*texture2D(positionSampler,vUV)).xyz;\rvec3 reflected=normalize(reflect(normalize(position),normalize(normal)));\rfloat roughness=1.0-texture2D(reflectivitySampler,vUV).a;\rvec3 jitt=mix(vec3(0.0),hash(position),roughness)*roughnessFactor;\rReflectionInfo info=getReflectionInfo(jitt+reflected,position);\rvec2 dCoords=smoothstep(0.2,0.6,abs(vec2(0.5,0.5)-info.coords.xy));\rfloat screenEdgefactor=clamp(1.0-(dCoords.x+dCoords.y),0.0,1.0);\rvec3 F0=vec3(0.04);\rF0 =mix(F0,albedo,spec);\rvec3 fresnel=fresnelSchlick(max(dot(normalize(normal),normalize(position)),0.0),F0);\r#ifdef RIGHT_HANDED_SCENE\nreflected.z*=-1.0;\r#endif\nfloat reflectionMultiplier=clamp(pow(spec*strength,reflectionSpecularFalloffExponent)*screenEdgefactor*reflected.z,0.0,0.9);\rfloat albedoMultiplier=1.0-reflectionMultiplier;\rvec3 SSR=info.color*fresnel;\rgl_FragColor=vec4((albedo*albedoMultiplier)+(SSR*reflectionMultiplier),albedoFull.a);\r#else\ngl_FragColor=texture2D(textureSampler,vUV);\r#endif\n}\r`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const screenSpaceReflectionPixelShader = { name, shader };\n//# sourceMappingURL=screenSpaceReflection.fragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nimport \"./ShadersInclude/helperFunctions.js\";\nimport \"./ShadersInclude/screenSpaceRayTrace.js\";\nconst name = \"screenSpaceReflection2PixelShader\";\nconst shader = `uniform sampler2D textureSampler;\rvarying vec2 vUV;\r#ifdef SSR_SUPPORTED\nuniform sampler2D reflectivitySampler;\runiform sampler2D normalSampler;\runiform sampler2D depthSampler;\r#ifdef SSRAYTRACE_USE_BACK_DEPTHBUFFER\nuniform sampler2D backDepthSampler;\runiform float backSizeFactor;\r#endif\n#ifdef SSR_USE_ENVIRONMENT_CUBE\nuniform samplerCube envCubeSampler;\r#ifdef USE_LOCAL_REFLECTIONMAP_CUBIC\nuniform vec3 vReflectionPosition;\runiform vec3 vReflectionSize;\r#endif\n#endif\nuniform mat4 view;\runiform mat4 invView;\runiform mat4 projection;\runiform mat4 invProjectionMatrix;\runiform mat4 projectionPixel;\runiform float nearPlaneZ;\runiform float stepSize;\runiform float maxSteps;\runiform float strength;\runiform float thickness;\runiform float roughnessFactor;\runiform float reflectionSpecularFalloffExponent;\runiform float maxDistance;\runiform float selfCollisionNumSkip;\r#include<helperFunctions>\n#include<screenSpaceRayTrace>\nvec3 fresnelSchlick(float cosTheta,vec3 F0)\r{\rreturn F0+(1.0-F0)*pow(1.0-cosTheta,5.0);\r}\rvec3 hash(vec3 a)\r{\ra=fract(a*0.8);\ra+=dot(a,a.yxz+19.19);\rreturn fract((a.xxy+a.yxx)*a.zyx);\r}\rvec3 computeViewPosFromUVDepth(vec2 texCoord,float depth) {\rvec4 ndc;\rndc.xy=texCoord*2.0-1.0;\r#ifdef SSRAYTRACE_RIGHT_HANDED_SCENE\nndc.z=-projection[2].z-projection[3].z/depth;\r#else\nndc.z=projection[2].z+projection[3].z/depth;\r#endif\nndc.w=1.0;\rvec4 eyePos=invProjectionMatrix*ndc;\reyePos.xyz/=eyePos.w;\rreturn eyePos.xyz;\r}\rfloat computeAttenuationForIntersection(ivec2 hitPixel,vec2 hitUV,vec3 vsRayOrigin,vec3 vsHitPoint,vec3 reflectionVector,float maxRayDistance) {\rfloat attenuation=1.0;\r#ifdef SSR_ATTENUATE_SCREEN_BORDERS\nvec2 dCoords=smoothstep(0.2,0.6,abs(vec2(0.5,0.5)-hitUV.xy));\rattenuation*=clamp(1.0-(dCoords.x+dCoords.y),0.0,1.0);\r#endif\n#ifdef SSR_ATTENUATE_INTERSECTION_DISTANCE\nattenuation*=1.0-clamp(distance(vsRayOrigin,vsHitPoint)/maxRayDistance,0.0,1.0);\r#endif\n#ifdef SSR_ATTENUATE_BACKFACE_REFLECTION\nvec3 reflectionNormal=texelFetch(normalSampler,hitPixel,0).xyz;\rfloat directionBasedAttenuation=smoothstep(-0.17,0.0,dot(reflectionNormal,-reflectionVector));\rattenuation*=directionBasedAttenuation;\r#endif\nreturn attenuation;\r}\r#endif\nvoid main()\r{\r#ifdef SSR_SUPPORTED\nvec4 colorFull=texture2D(textureSampler,vUV);\rvec3 color=toLinearSpace(colorFull.rgb);\rvec4 reflectivity=texture2D(reflectivitySampler,vUV);\rif (dot(reflectivity.rgb,vec3(1.))<=0.0) {\r#ifdef USE_BLUR\ngl_FragColor=vec4(0.);\r#else\ngl_FragColor=vec4(colorFull.rgb,1.0);\r#endif\nreturn;\r}\rvec2 texSize=vec2(textureSize(depthSampler,0));\rvec3 csNormal=texelFetch(normalSampler,ivec2(vUV*texSize),0).xyz; \rfloat depth=texelFetch(depthSampler,ivec2(vUV*texSize),0).r;\rvec3 csPosition=computeViewPosFromUVDepth(vUV,depth);\rvec3 csViewDirection=normalize(csPosition);\rvec3 csReflectedVector=reflect(csViewDirection,csNormal);\r#ifdef SSR_USE_ENVIRONMENT_CUBE\nvec3 wReflectedVector=vec3(invView*vec4(csReflectedVector,0.0));\r#ifdef SSR_USE_LOCAL_REFLECTIONMAP_CUBIC\nvec4 worldPos=invView*vec4(csPosition,1.0);\rwReflectedVector=parallaxCorrectNormal(worldPos.xyz,normalize(wReflectedVector),vReflectionSize,vReflectionPosition);\r#endif\n#ifdef SSR_INVERTCUBICMAP\nwReflectedVector.y*=-1.0;\r#endif\n#ifdef SSRAYTRACE_RIGHT_HANDED_SCENE\nwReflectedVector.z*=-1.0;\r#endif\nvec3 envColor=toLinearSpace(textureCube(envCubeSampler,wReflectedVector).xyz);\r#else\nvec3 envColor=color;\r#endif\nfloat reflectionAttenuation=1.0;\rbool rayHasHit=false;\rvec2 startPixel;\rvec2 hitPixel;\rvec3 hitPoint;\r#ifdef SSRAYTRACE_DEBUG\nvec3 debugColor;\r#endif\n#ifdef SSR_ATTENUATE_FACING_CAMERA\nreflectionAttenuation*=1.0-smoothstep(0.25,0.5,dot(-csViewDirection,csReflectedVector));\r#endif\nif (reflectionAttenuation>0.0) {\r#ifdef SSR_USE_BLUR\nvec3 jitt=vec3(0.);\r#else\nfloat roughness=1.0-reflectivity.a;\rvec3 jitt=mix(vec3(0.0),hash(csPosition),roughness)*roughnessFactor; \r#endif\nvec2 uv2=vUV*texSize;\rfloat c=(uv2.x+uv2.y)*0.25;\rfloat jitter=mod(c,1.0); \rrayHasHit=traceScreenSpaceRay1(\rcsPosition,\rnormalize(csReflectedVector+jitt),\rprojectionPixel,\rdepthSampler,\rtexSize,\r#ifdef SSRAYTRACE_USE_BACK_DEPTHBUFFER\nbackDepthSampler,\rbackSizeFactor,\r#endif\nthickness,\rnearPlaneZ,\rstepSize,\rjitter,\rmaxSteps,\rmaxDistance,\rselfCollisionNumSkip,\rstartPixel,\rhitPixel,\rhitPoint\r#ifdef SSRAYTRACE_DEBUG\n,debugColor\r#endif\n);\r}\r#ifdef SSRAYTRACE_DEBUG\ngl_FragColor=vec4(debugColor,1.);\rreturn;\r#endif\nvec3 F0=reflectivity.rgb;\rvec3 fresnel=fresnelSchlick(max(dot(csNormal,-csViewDirection),0.0),F0);\rvec3 SSR=envColor;\rif (rayHasHit) {\rvec3 color=toLinearSpace(texelFetch(textureSampler,ivec2(hitPixel),0).rgb);\rreflectionAttenuation*=computeAttenuationForIntersection(ivec2(hitPixel),hitPixel/texSize,csPosition,hitPoint,csReflectedVector,maxDistance);\rSSR=color*reflectionAttenuation+(1.0-reflectionAttenuation)*envColor;\r}\rSSR*=fresnel;\r#ifdef SSR_USE_BLUR\nfloat blur_radius=0.0;\rfloat roughness=1.0-reflectivity.a*(1.0-roughnessFactor);\rif (roughness>0.001) {\rfloat cone_angle=min(roughness,0.999)*3.14159265*0.5;\rfloat cone_len=distance(startPixel,hitPixel);\rfloat op_len=2.0*tan(cone_angle)*cone_len; \rfloat a=op_len;\rfloat h=cone_len;\rfloat a2=a*a;\rfloat fh2=4.0f*h*h;\rblur_radius=(a*(sqrt(a2+fh2)-a))/(4.0f*h);\r}\rgl_FragColor=vec4(SSR,blur_radius/255.0); \r#else\nvec3 reflectionMultiplier=clamp(pow(reflectivity.rgb*strength,vec3(reflectionSpecularFalloffExponent)),0.0,1.0);\rvec3 colorMultiplier=1.0-reflectionMultiplier;\rgl_FragColor=vec4(toGammaSpace((color*colorMultiplier)+(SSR*reflectionMultiplier)),colorFull.a);\r#endif\n#else\ngl_FragColor=texture2D(textureSampler,vUV);\r#endif\n}\r`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const screenSpaceReflection2PixelShader = { name, shader };\n//# sourceMappingURL=screenSpaceReflection2.fragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nimport \"./ShadersInclude/bonesDeclaration.js\";\nimport \"./ShadersInclude/bakedVertexAnimationDeclaration.js\";\nimport \"./ShadersInclude/morphTargetsVertexGlobalDeclaration.js\";\nimport \"./ShadersInclude/morphTargetsVertexDeclaration.js\";\nimport \"./ShadersInclude/helperFunctions.js\";\nimport \"./ShadersInclude/shadowMapVertexDeclaration.js\";\nimport \"./ShadersInclude/shadowMapUboDeclaration.js\";\nimport \"./ShadersInclude/shadowMapVertexExtraDeclaration.js\";\nimport \"./ShadersInclude/clipPlaneVertexDeclaration.js\";\nimport \"./ShadersInclude/morphTargetsVertexGlobal.js\";\nimport \"./ShadersInclude/morphTargetsVertex.js\";\nimport \"./ShadersInclude/instancesVertex.js\";\nimport \"./ShadersInclude/bonesVertex.js\";\nimport \"./ShadersInclude/bakedVertexAnimation.js\";\nimport \"./ShadersInclude/shadowMapVertexNormalBias.js\";\nimport \"./ShadersInclude/shadowMapVertexMetric.js\";\nimport \"./ShadersInclude/clipPlaneVertex.js\";\nconst name = \"shadowMapVertexShader\";\nconst shader = `attribute vec3 position;\r#ifdef NORMAL\nattribute vec3 normal;\r#endif\n#include<bonesDeclaration>\n#include<bakedVertexAnimationDeclaration>\n#include<morphTargetsVertexGlobalDeclaration>\n#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]\n#ifdef INSTANCES\nattribute vec4 world0;\rattribute vec4 world1;\rattribute vec4 world2;\rattribute vec4 world3;\r#endif\n#include<helperFunctions>\n#include<__decl__shadowMapVertex>\n#ifdef ALPHATEXTURE\nvarying vec2 vUV;\runiform mat4 diffuseMatrix;\r#ifdef UV1\nattribute vec2 uv;\r#endif\n#ifdef UV2\nattribute vec2 uv2;\r#endif\n#endif\n#include<shadowMapVertexExtraDeclaration>\n#include<clipPlaneVertexDeclaration>\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void)\r{\rvec3 positionUpdated=position;\r#ifdef UV1\nvec2 uvUpdated=uv;\r#endif\n#ifdef NORMAL\nvec3 normalUpdated=normal;\r#endif\n#include<morphTargetsVertexGlobal>\n#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]\n#include<instancesVertex>\n#include<bonesVertex>\n#include<bakedVertexAnimation>\nvec4 worldPos=finalWorld*vec4(positionUpdated,1.0);\r#ifdef NORMAL\nmat3 normWorldSM=mat3(finalWorld);\r#if defined(INSTANCES) && defined(THIN_INSTANCES)\nvec3 vNormalW=normalUpdated/vec3(dot(normWorldSM[0],normWorldSM[0]),dot(normWorldSM[1],normWorldSM[1]),dot(normWorldSM[2],normWorldSM[2]));\rvNormalW=normalize(normWorldSM*vNormalW);\r#else\n#ifdef NONUNIFORMSCALING\nnormWorldSM=transposeMat3(inverseMat3(normWorldSM));\r#endif\nvec3 vNormalW=normalize(normWorldSM*normalUpdated);\r#endif\n#endif\n#include<shadowMapVertexNormalBias>\ngl_Position=viewProjection*worldPos;\r#include<shadowMapVertexMetric>\n#ifdef ALPHATEXTURE\n#ifdef UV1\nvUV=vec2(diffuseMatrix*vec4(uvUpdated,1.0,0.0));\r#endif\n#ifdef UV2\nvUV=vec2(diffuseMatrix*vec4(uv2,1.0,0.0));\r#endif\n#endif\n#include<clipPlaneVertex>\n}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const shadowMapVertexShader = { name, shader };\n//# sourceMappingURL=shadowMap.vertex.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nconst name = \"sharpenPixelShader\";\nconst shader = `varying vec2 vUV;\runiform sampler2D textureSampler;\runiform vec2 screenSize;\runiform vec2 sharpnessAmounts;\r#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void)\r{\rvec2 onePixel=vec2(1.0,1.0)/screenSize;\rvec4 color=texture2D(textureSampler,vUV);\rvec4 edgeDetection=texture2D(textureSampler,vUV+onePixel*vec2(0,-1)) +\rtexture2D(textureSampler,vUV+onePixel*vec2(-1,0)) +\rtexture2D(textureSampler,vUV+onePixel*vec2(1,0)) +\rtexture2D(textureSampler,vUV+onePixel*vec2(0,1)) -\rcolor*4.0;\rgl_FragColor=max(vec4(color.rgb*sharpnessAmounts.y,color.a)-(sharpnessAmounts.x*vec4(edgeDetection.rgb,0)),0.);\r}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const sharpenPixelShader = { name, shader };\n//# sourceMappingURL=sharpen.fragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nconst name = \"ssaoCombinePixelShader\";\nconst shader = `uniform sampler2D textureSampler;\runiform sampler2D originalColor;\runiform vec4 viewport;\rvarying vec2 vUV;\r#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) {\r#define CUSTOM_FRAGMENT_MAIN_BEGIN\nvec4 ssaoColor=texture2D(textureSampler,viewport.xy+vUV*viewport.zw);\rvec4 sceneColor=texture2D(originalColor,vUV);\rgl_FragColor=sceneColor*ssaoColor;\r#define CUSTOM_FRAGMENT_MAIN_END\n}\r`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const ssaoCombinePixelShader = { name, shader };\n//# sourceMappingURL=ssaoCombine.fragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nconst name = \"stereoscopicInterlacePixelShader\";\nconst shader = `const vec3 TWO=vec3(2.0,2.0,2.0);\rvarying vec2 vUV;\runiform sampler2D camASampler;\runiform sampler2D textureSampler;\runiform vec2 stepSize;\r#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void)\r{\rbool useCamA;\rbool useCamB;\rvec2 texCoord1;\rvec2 texCoord2;\rvec3 frag1;\rvec3 frag2;\r#ifdef IS_STEREOSCOPIC_HORIZ\nuseCamB=vUV.x>0.5;\ruseCamA=!useCamB;\rtexCoord1=vec2(useCamB ? (vUV.x-0.5)*2.0 : vUV.x*2.0,vUV.y);\rtexCoord2=vec2(texCoord1.x+stepSize.x,vUV.y);\r#else\n#ifdef IS_STEREOSCOPIC_INTERLACED\nfloat rowNum=floor(vUV.y/stepSize.y);\ruseCamA=mod(rowNum,2.0)==1.0;\ruseCamB=mod(rowNum,2.0)==0.0;\rtexCoord1=vec2(vUV.x,vUV.y);\rtexCoord2=vec2(vUV.x,vUV.y);\r#else\nuseCamB=vUV.y>0.5;\ruseCamA=!useCamB;\rtexCoord1=vec2(vUV.x,useCamB ? (vUV.y-0.5)*2.0 : vUV.y*2.0);\rtexCoord2=vec2(vUV.x,texCoord1.y+stepSize.y);\r#endif\n#endif\nif (useCamB){\rfrag1=texture2D(textureSampler,texCoord1).rgb;\rfrag2=texture2D(textureSampler,texCoord2).rgb;\r}else if (useCamA){\rfrag1=texture2D(camASampler ,texCoord1).rgb;\rfrag2=texture2D(camASampler ,texCoord2).rgb;\r}else {\rdiscard;\r}\rgl_FragColor=vec4((frag1+frag2)/TWO,1.0);\r}\r`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const stereoscopicInterlacePixelShader = { name, shader };\n//# sourceMappingURL=stereoscopicInterlace.fragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nconst name = \"tonemapPixelShader\";\nconst shader = `varying vec2 vUV;\runiform sampler2D textureSampler;\runiform float _ExposureAdjustment;\r#if defined(HABLE_TONEMAPPING)\nconst float A=0.15;\rconst float B=0.50;\rconst float C=0.10;\rconst float D=0.20;\rconst float E=0.02;\rconst float F=0.30;\rconst float W=11.2;\r#endif\nfloat Luminance(vec3 c)\r{\rreturn dot(c,vec3(0.22,0.707,0.071));\r}\r#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) \r{\rvec3 colour=texture2D(textureSampler,vUV).rgb;\r#if defined(REINHARD_TONEMAPPING)\nfloat lum=Luminance(colour.rgb); \rfloat lumTm=lum*_ExposureAdjustment;\rfloat scale=lumTm/(1.0+lumTm); \rcolour*=scale/lum;\r#elif defined(HABLE_TONEMAPPING)\ncolour*=_ExposureAdjustment;\rconst float ExposureBias=2.0;\rvec3 x=ExposureBias*colour;\rvec3 curr=((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;\rx=vec3(W,W,W);\rvec3 whiteScale=1.0/(((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F);\rcolour=curr*whiteScale;\r#elif defined(OPTIMIZED_HEJIDAWSON_TONEMAPPING)\ncolour*=_ExposureAdjustment;\rvec3 X=max(vec3(0.0,0.0,0.0),colour-0.004);\rvec3 retColor=(X*(6.2*X+0.5))/(X*(6.2*X+1.7)+0.06);\rcolour=retColor*retColor;\r#elif defined(PHOTOGRAPHIC_TONEMAPPING)\ncolour= vec3(1.0,1.0,1.0)-exp2(-_ExposureAdjustment*colour);\r#endif\ngl_FragColor=vec4(colour.rgb,1.0);\r}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const tonemapPixelShader = { name, shader };\n//# sourceMappingURL=tonemap.fragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nconst name = \"volumetricLightScatteringPixelShader\";\nconst shader = `uniform sampler2D textureSampler;\runiform sampler2D lightScatteringSampler;\runiform float decay;\runiform float exposure;\runiform float weight;\runiform float density;\runiform vec2 meshPositionOnScreen;\rvarying vec2 vUV;\r#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) {\r#define CUSTOM_FRAGMENT_MAIN_BEGIN\nvec2 tc=vUV;\rvec2 deltaTexCoord=(tc-meshPositionOnScreen.xy);\rdeltaTexCoord*=1.0/float(NUM_SAMPLES)*density;\rfloat illuminationDecay=1.0;\rvec4 color=texture2D(lightScatteringSampler,tc)*0.4;\rfor(int i=0; i<NUM_SAMPLES; i++) {\rtc-=deltaTexCoord;\rvec4 dataSample=texture2D(lightScatteringSampler,tc)*0.4;\rdataSample*=illuminationDecay*weight;\rcolor+=dataSample;\rilluminationDecay*=decay;\r}\rvec4 realColor=texture2D(textureSampler,vUV);\rgl_FragColor=((vec4((vec3(color.r,color.g,color.b)*exposure),1))+(realColor*(1.5-0.4)));\r#define CUSTOM_FRAGMENT_MAIN_END\n}\r`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const volumetricLightScatteringPixelShader = { name, shader };\n//# sourceMappingURL=volumetricLightScattering.fragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nconst name = \"volumetricLightScatteringPassPixelShader\";\nconst shader = `#if defined(ALPHATEST) || defined(NEED_UV)\nvarying vec2 vUV;\r#endif\n#if defined(ALPHATEST)\nuniform sampler2D diffuseSampler;\r#endif\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void)\r{\r#if defined(ALPHATEST)\nvec4 diffuseColor=texture2D(diffuseSampler,vUV);\rif (diffuseColor.a<0.4)\rdiscard;\r#endif\ngl_FragColor=vec4(0.0,0.0,0.0,1.0);\r}\r`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const volumetricLightScatteringPassPixelShader = { name, shader };\n//# sourceMappingURL=volumetricLightScatteringPass.fragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nimport \"./ShadersInclude/bonesDeclaration.js\";\nimport \"./ShadersInclude/bakedVertexAnimationDeclaration.js\";\nimport \"./ShadersInclude/morphTargetsVertexGlobalDeclaration.js\";\nimport \"./ShadersInclude/morphTargetsVertexDeclaration.js\";\nimport \"./ShadersInclude/instancesDeclaration.js\";\nimport \"./ShadersInclude/morphTargetsVertexGlobal.js\";\nimport \"./ShadersInclude/morphTargetsVertex.js\";\nimport \"./ShadersInclude/instancesVertex.js\";\nimport \"./ShadersInclude/bonesVertex.js\";\nimport \"./ShadersInclude/bakedVertexAnimation.js\";\nconst name = \"volumetricLightScatteringPassVertexShader\";\nconst shader = `attribute vec3 position;\r#include<bonesDeclaration>\n#include<bakedVertexAnimationDeclaration>\n#include<morphTargetsVertexGlobalDeclaration>\n#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]\n#include<instancesDeclaration>\nuniform mat4 viewProjection;\runiform vec2 depthValues;\r#if defined(ALPHATEST) || defined(NEED_UV)\nvarying vec2 vUV;\runiform mat4 diffuseMatrix;\r#ifdef UV1\nattribute vec2 uv;\r#endif\n#ifdef UV2\nattribute vec2 uv2;\r#endif\n#endif\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void)\r{\rvec3 positionUpdated=position;\r#if (defined(ALPHATEST) || defined(NEED_UV)) && defined(UV1)\nvec2 uvUpdated=uv;\r#endif\n#include<morphTargetsVertexGlobal>\n#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]\n#include<instancesVertex>\n#include<bonesVertex>\n#include<bakedVertexAnimation>\ngl_Position=viewProjection*finalWorld*vec4(positionUpdated,1.0);\r#if defined(ALPHATEST) || defined(BASIC_RENDER)\n#ifdef UV1\nvUV=vec2(diffuseMatrix*vec4(uvUpdated,1.0,0.0));\r#endif\n#ifdef UV2\nvUV=vec2(diffuseMatrix*vec4(uv2,1.0,0.0));\r#endif\n#endif\n}\r`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const volumetricLightScatteringPassVertexShader = { name, shader };\n//# sourceMappingURL=volumetricLightScatteringPass.vertex.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nconst name = \"vrDistortionCorrectionPixelShader\";\nconst shader = `varying vec2 vUV;\runiform sampler2D textureSampler;\runiform vec2 LensCenter;\runiform vec2 Scale;\runiform vec2 ScaleIn;\runiform vec4 HmdWarpParam;\rvec2 HmdWarp(vec2 in01) {\rvec2 theta=(in01-LensCenter)*ScaleIn; \rfloat rSq=theta.x*theta.x+theta.y*theta.y;\rvec2 rvector=theta*(HmdWarpParam.x+HmdWarpParam.y*rSq+HmdWarpParam.z*rSq*rSq+HmdWarpParam.w*rSq*rSq*rSq);\rreturn LensCenter+Scale*rvector;\r}\r#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void)\r{\rvec2 tc=HmdWarp(vUV);\rif (tc.x <0.0 || tc.x>1.0 || tc.y<0.0 || tc.y>1.0)\rgl_FragColor=vec4(0.0,0.0,0.0,0.0);\relse{\rgl_FragColor=texture2D(textureSampler,tc);\r}\r}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const vrDistortionCorrectionPixelShader = { name, shader };\n//# sourceMappingURL=vrDistortionCorrection.fragment.js.map","/**\n * ThinSprite Class used to represent a thin sprite\n * This is the base class for sprites but can also directly be used with ThinEngine\n * @see https://doc.babylonjs.com/features/featuresDeepDive/sprites\n */\nexport class ThinSprite {\n    /**\n     * Returns a boolean indicating if the animation is started\n     */\n    get animationStarted() {\n        return this._animationStarted;\n    }\n    /** Gets the initial key for the animation (setting it will restart the animation)  */\n    get fromIndex() {\n        return this._fromIndex;\n    }\n    /** Gets or sets the end key for the animation (setting it will restart the animation)  */\n    get toIndex() {\n        return this._toIndex;\n    }\n    /** Gets or sets a boolean indicating if the animation is looping (setting it will restart the animation)  */\n    get loopAnimation() {\n        return this._loopAnimation;\n    }\n    /** Gets or sets the delay between cell changes (setting it will restart the animation)  */\n    get delay() {\n        return Math.max(this._delay, 1);\n    }\n    /**\n     * Creates a new Thin Sprite\n     */\n    constructor() {\n        /** Gets or sets the width */\n        this.width = 1.0;\n        /** Gets or sets the height */\n        this.height = 1.0;\n        /** Gets or sets rotation angle */\n        this.angle = 0;\n        /** Gets or sets a boolean indicating if UV coordinates should be inverted in U axis */\n        this.invertU = false;\n        /** Gets or sets a boolean indicating if UV coordinates should be inverted in B axis */\n        this.invertV = false;\n        /** Gets or sets a boolean indicating if the sprite is visible (renderable). Default is true */\n        this.isVisible = true;\n        this._animationStarted = false;\n        this._loopAnimation = false;\n        this._fromIndex = 0;\n        this._toIndex = 0;\n        this._delay = 0;\n        this._direction = 1;\n        this._time = 0;\n        this._onBaseAnimationEnd = null;\n        this.position = { x: 1.0, y: 1.0, z: 1.0 };\n        this.color = { r: 1.0, g: 1.0, b: 1.0, a: 1.0 };\n    }\n    /**\n     * Starts an animation\n     * @param from defines the initial key\n     * @param to defines the end key\n     * @param loop defines if the animation must loop\n     * @param delay defines the start delay (in ms)\n     * @param onAnimationEnd defines a callback for when the animation ends\n     */\n    playAnimation(from, to, loop, delay, onAnimationEnd) {\n        this._fromIndex = from;\n        this._toIndex = to;\n        this._loopAnimation = loop;\n        this._delay = delay || 1;\n        this._animationStarted = true;\n        this._onBaseAnimationEnd = onAnimationEnd;\n        if (from < to) {\n            this._direction = 1;\n        }\n        else {\n            this._direction = -1;\n            this._toIndex = from;\n            this._fromIndex = to;\n        }\n        this.cellIndex = from;\n        this._time = 0;\n    }\n    /** Stops current animation (if any) */\n    stopAnimation() {\n        this._animationStarted = false;\n    }\n    /**\n     * @internal\n     */\n    _animate(deltaTime) {\n        if (!this._animationStarted) {\n            return;\n        }\n        this._time += deltaTime;\n        if (this._time > this._delay) {\n            this._time = this._time % this._delay;\n            this.cellIndex += this._direction;\n            if ((this._direction > 0 && this.cellIndex > this._toIndex) || (this._direction < 0 && this.cellIndex < this._fromIndex)) {\n                if (this._loopAnimation) {\n                    this.cellIndex = this._direction > 0 ? this._fromIndex : this._toIndex;\n                }\n                else {\n                    this.cellIndex = this._toIndex;\n                    this._animationStarted = false;\n                    if (this._onBaseAnimationEnd) {\n                        this._onBaseAnimationEnd();\n                    }\n                }\n            }\n        }\n    }\n}\n//# sourceMappingURL=thinSprite.js.map","import { Vector3 } from \"../Maths/math.vector.js\";\nimport { Color4 } from \"../Maths/math.color.js\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { ThinSprite } from \"./thinSprite.js\";\n/**\n * Class used to represent a sprite\n * @see https://doc.babylonjs.com/features/featuresDeepDive/sprites\n */\nexport class Sprite extends ThinSprite {\n    /**\n     * Gets or sets the sprite size\n     */\n    get size() {\n        return this.width;\n    }\n    set size(value) {\n        this.width = value;\n        this.height = value;\n    }\n    /**\n     * Gets the manager of this sprite\n     */\n    get manager() {\n        return this._manager;\n    }\n    /**\n     * Creates a new Sprite\n     * @param name defines the name\n     * @param manager defines the manager\n     */\n    constructor(\n    /** defines the name */\n    name, manager) {\n        super();\n        this.name = name;\n        /** Gets the list of attached animations */\n        this.animations = new Array();\n        /** Gets or sets a boolean indicating if the sprite can be picked */\n        this.isPickable = false;\n        /** Gets or sets a boolean indicating that sprite texture alpha will be used for precise picking (false by default) */\n        this.useAlphaForPicking = false;\n        /**\n         * An event triggered when the control has been disposed\n         */\n        this.onDisposeObservable = new Observable();\n        this._onAnimationEnd = null;\n        this._endAnimation = () => {\n            if (this._onAnimationEnd) {\n                this._onAnimationEnd();\n            }\n            if (this.disposeWhenFinishedAnimating) {\n                this.dispose();\n            }\n        };\n        this.color = new Color4(1.0, 1.0, 1.0, 1.0);\n        this.position = Vector3.Zero();\n        this._manager = manager;\n        this._manager.sprites.push(this);\n        this.uniqueId = this._manager.scene.getUniqueId();\n    }\n    /**\n     * Returns the string \"Sprite\"\n     * @returns \"Sprite\"\n     */\n    getClassName() {\n        return \"Sprite\";\n    }\n    /** Gets or sets the initial key for the animation (setting it will restart the animation)  */\n    get fromIndex() {\n        return this._fromIndex;\n    }\n    set fromIndex(value) {\n        this.playAnimation(value, this._toIndex, this._loopAnimation, this._delay, this._onAnimationEnd);\n    }\n    /** Gets or sets the end key for the animation (setting it will restart the animation)  */\n    get toIndex() {\n        return this._toIndex;\n    }\n    set toIndex(value) {\n        this.playAnimation(this._fromIndex, value, this._loopAnimation, this._delay, this._onAnimationEnd);\n    }\n    /** Gets or sets a boolean indicating if the animation is looping (setting it will restart the animation)  */\n    get loopAnimation() {\n        return this._loopAnimation;\n    }\n    set loopAnimation(value) {\n        this.playAnimation(this._fromIndex, this._toIndex, value, this._delay, this._onAnimationEnd);\n    }\n    /** Gets or sets the delay between cell changes (setting it will restart the animation)  */\n    get delay() {\n        return Math.max(this._delay, 1);\n    }\n    set delay(value) {\n        this.playAnimation(this._fromIndex, this._toIndex, this._loopAnimation, value, this._onAnimationEnd);\n    }\n    /**\n     * Starts an animation\n     * @param from defines the initial key\n     * @param to defines the end key\n     * @param loop defines if the animation must loop\n     * @param delay defines the start delay (in ms)\n     * @param onAnimationEnd defines a callback to call when animation ends\n     */\n    playAnimation(from, to, loop, delay, onAnimationEnd = null) {\n        this._onAnimationEnd = onAnimationEnd;\n        super.playAnimation(from, to, loop, delay, this._endAnimation);\n    }\n    /** Release associated resources */\n    dispose() {\n        for (let i = 0; i < this._manager.sprites.length; i++) {\n            if (this._manager.sprites[i] == this) {\n                this._manager.sprites.splice(i, 1);\n            }\n        }\n        // Callback\n        this.onDisposeObservable.notifyObservers(this);\n        this.onDisposeObservable.clear();\n    }\n    /**\n     * Serializes the sprite to a JSON object\n     * @returns the JSON object\n     */\n    serialize() {\n        const serializationObject = {};\n        serializationObject.name = this.name;\n        serializationObject.position = this.position.asArray();\n        serializationObject.color = this.color.asArray();\n        serializationObject.width = this.width;\n        serializationObject.height = this.height;\n        serializationObject.angle = this.angle;\n        serializationObject.cellIndex = this.cellIndex;\n        serializationObject.cellRef = this.cellRef;\n        serializationObject.invertU = this.invertU;\n        serializationObject.invertV = this.invertV;\n        serializationObject.disposeWhenFinishedAnimating = this.disposeWhenFinishedAnimating;\n        serializationObject.isPickable = this.isPickable;\n        serializationObject.isVisible = this.isVisible;\n        serializationObject.useAlphaForPicking = this.useAlphaForPicking;\n        serializationObject.animationStarted = this.animationStarted;\n        serializationObject.fromIndex = this.fromIndex;\n        serializationObject.toIndex = this.toIndex;\n        serializationObject.loopAnimation = this.loopAnimation;\n        serializationObject.delay = this.delay;\n        return serializationObject;\n    }\n    /**\n     * Parses a JSON object to create a new sprite\n     * @param parsedSprite The JSON object to parse\n     * @param manager defines the hosting manager\n     * @returns the new sprite\n     */\n    static Parse(parsedSprite, manager) {\n        const sprite = new Sprite(parsedSprite.name, manager);\n        sprite.position = Vector3.FromArray(parsedSprite.position);\n        sprite.color = Color4.FromArray(parsedSprite.color);\n        sprite.width = parsedSprite.width;\n        sprite.height = parsedSprite.height;\n        sprite.angle = parsedSprite.angle;\n        sprite.cellIndex = parsedSprite.cellIndex;\n        sprite.cellRef = parsedSprite.cellRef;\n        sprite.invertU = parsedSprite.invertU;\n        sprite.invertV = parsedSprite.invertV;\n        sprite.disposeWhenFinishedAnimating = parsedSprite.disposeWhenFinishedAnimating;\n        sprite.isPickable = parsedSprite.isPickable;\n        sprite.isVisible = parsedSprite.isVisible;\n        sprite.useAlphaForPicking = parsedSprite.useAlphaForPicking;\n        sprite.fromIndex = parsedSprite.fromIndex;\n        sprite.toIndex = parsedSprite.toIndex;\n        sprite.loopAnimation = parsedSprite.loopAnimation;\n        sprite.delay = parsedSprite.delay;\n        if (parsedSprite.animationStarted) {\n            sprite.playAnimation(sprite.fromIndex, sprite.toIndex, sprite.loopAnimation, sprite.delay);\n        }\n        return sprite;\n    }\n}\n//# sourceMappingURL=sprite.js.map","import { Observable } from \"../Misc/observable.js\";\nimport { Scene } from \"../scene.js\";\nimport { Ray } from \"../Culling/ray.js\";\nimport { PickingInfo } from \"../Collisions/pickingInfo.js\";\nimport { SceneComponentConstants } from \"../sceneComponent.js\";\nimport { ActionEvent } from \"../Actions/actionEvent.js\";\n\nScene.prototype._internalPickSprites = function (ray, predicate, fastCheck, camera) {\n    if (!PickingInfo) {\n        return null;\n    }\n    let pickingInfo = null;\n    if (!camera) {\n        if (!this.activeCamera) {\n            return null;\n        }\n        camera = this.activeCamera;\n    }\n    if (this.spriteManagers.length > 0) {\n        for (let spriteIndex = 0; spriteIndex < this.spriteManagers.length; spriteIndex++) {\n            const spriteManager = this.spriteManagers[spriteIndex];\n            if (!spriteManager.isPickable) {\n                continue;\n            }\n            const result = spriteManager.intersects(ray, camera, predicate, fastCheck);\n            if (!result || !result.hit) {\n                continue;\n            }\n            if (!fastCheck && pickingInfo != null && result.distance >= pickingInfo.distance) {\n                continue;\n            }\n            pickingInfo = result;\n            if (fastCheck) {\n                break;\n            }\n        }\n    }\n    return pickingInfo || new PickingInfo();\n};\nScene.prototype._internalMultiPickSprites = function (ray, predicate, camera) {\n    if (!PickingInfo) {\n        return null;\n    }\n    let pickingInfos = new Array();\n    if (!camera) {\n        if (!this.activeCamera) {\n            return null;\n        }\n        camera = this.activeCamera;\n    }\n    if (this.spriteManagers.length > 0) {\n        for (let spriteIndex = 0; spriteIndex < this.spriteManagers.length; spriteIndex++) {\n            const spriteManager = this.spriteManagers[spriteIndex];\n            if (!spriteManager.isPickable) {\n                continue;\n            }\n            const results = spriteManager.multiIntersects(ray, camera, predicate);\n            if (results !== null) {\n                pickingInfos = pickingInfos.concat(results);\n            }\n        }\n    }\n    return pickingInfos;\n};\nScene.prototype.pickSprite = function (x, y, predicate, fastCheck, camera) {\n    if (!this._tempSpritePickingRay) {\n        return null;\n    }\n    this.createPickingRayInCameraSpaceToRef(x, y, this._tempSpritePickingRay, camera);\n    const result = this._internalPickSprites(this._tempSpritePickingRay, predicate, fastCheck, camera);\n    if (result) {\n        result.ray = this.createPickingRayInCameraSpace(x, y, camera);\n    }\n    return result;\n};\nScene.prototype.pickSpriteWithRay = function (ray, predicate, fastCheck, camera) {\n    if (!this._tempSpritePickingRay) {\n        return null;\n    }\n    if (!camera) {\n        if (!this.activeCamera) {\n            return null;\n        }\n        camera = this.activeCamera;\n    }\n    Ray.TransformToRef(ray, camera.getViewMatrix(), this._tempSpritePickingRay);\n    const result = this._internalPickSprites(this._tempSpritePickingRay, predicate, fastCheck, camera);\n    if (result) {\n        result.ray = ray;\n    }\n    return result;\n};\nScene.prototype.multiPickSprite = function (x, y, predicate, camera) {\n    this.createPickingRayInCameraSpaceToRef(x, y, this._tempSpritePickingRay, camera);\n    return this._internalMultiPickSprites(this._tempSpritePickingRay, predicate, camera);\n};\nScene.prototype.multiPickSpriteWithRay = function (ray, predicate, camera) {\n    if (!this._tempSpritePickingRay) {\n        return null;\n    }\n    if (!camera) {\n        if (!this.activeCamera) {\n            return null;\n        }\n        camera = this.activeCamera;\n    }\n    Ray.TransformToRef(ray, camera.getViewMatrix(), this._tempSpritePickingRay);\n    return this._internalMultiPickSprites(this._tempSpritePickingRay, predicate, camera);\n};\nScene.prototype.setPointerOverSprite = function (sprite) {\n    if (this._pointerOverSprite === sprite) {\n        return;\n    }\n    if (this._pointerOverSprite && this._pointerOverSprite.actionManager) {\n        this._pointerOverSprite.actionManager.processTrigger(10, ActionEvent.CreateNewFromSprite(this._pointerOverSprite, this));\n    }\n    this._pointerOverSprite = sprite;\n    if (this._pointerOverSprite && this._pointerOverSprite.actionManager) {\n        this._pointerOverSprite.actionManager.processTrigger(9, ActionEvent.CreateNewFromSprite(this._pointerOverSprite, this));\n    }\n};\nScene.prototype.getPointerOverSprite = function () {\n    return this._pointerOverSprite;\n};\n/**\n * Defines the sprite scene component responsible to manage sprites\n * in a given scene.\n */\nexport class SpriteSceneComponent {\n    /**\n     * Creates a new instance of the component for the given scene\n     * @param scene Defines the scene to register the component in\n     */\n    constructor(scene) {\n        /**\n         * The component name helpfull to identify the component in the list of scene components.\n         */\n        this.name = SceneComponentConstants.NAME_SPRITE;\n        this.scene = scene;\n        this.scene.spriteManagers = new Array();\n        this.scene._tempSpritePickingRay = Ray ? Ray.Zero() : null;\n        this.scene.onBeforeSpritesRenderingObservable = new Observable();\n        this.scene.onAfterSpritesRenderingObservable = new Observable();\n        this._spritePredicate = (sprite) => {\n            if (!sprite.actionManager) {\n                return false;\n            }\n            return sprite.isPickable && sprite.actionManager.hasPointerTriggers;\n        };\n    }\n    /**\n     * Registers the component in a given scene\n     */\n    register() {\n        this.scene._pointerMoveStage.registerStep(SceneComponentConstants.STEP_POINTERMOVE_SPRITE, this, this._pointerMove);\n        this.scene._pointerDownStage.registerStep(SceneComponentConstants.STEP_POINTERDOWN_SPRITE, this, this._pointerDown);\n        this.scene._pointerUpStage.registerStep(SceneComponentConstants.STEP_POINTERUP_SPRITE, this, this._pointerUp);\n    }\n    /**\n     * Rebuilds the elements related to this component in case of\n     * context lost for instance.\n     */\n    rebuild() {\n        /** Nothing to do for sprites */\n    }\n    /**\n     * Disposes the component and the associated resources.\n     */\n    dispose() {\n        this.scene.onBeforeSpritesRenderingObservable.clear();\n        this.scene.onAfterSpritesRenderingObservable.clear();\n        const spriteManagers = this.scene.spriteManagers;\n        while (spriteManagers.length) {\n            spriteManagers[0].dispose();\n        }\n    }\n    _pickSpriteButKeepRay(originalPointerInfo, x, y, fastCheck, camera) {\n        const result = this.scene.pickSprite(x, y, this._spritePredicate, fastCheck, camera);\n        if (result) {\n            result.ray = originalPointerInfo ? originalPointerInfo.ray : null;\n        }\n        return result;\n    }\n    _pointerMove(unTranslatedPointerX, unTranslatedPointerY, pickResult, isMeshPicked, element) {\n        const scene = this.scene;\n        if (isMeshPicked) {\n            scene.setPointerOverSprite(null);\n        }\n        else {\n            pickResult = this._pickSpriteButKeepRay(pickResult, unTranslatedPointerX, unTranslatedPointerY, false, scene.cameraToUseForPointers || undefined);\n            if (pickResult && pickResult.hit && pickResult.pickedSprite) {\n                scene.setPointerOverSprite(pickResult.pickedSprite);\n                if (!scene.doNotHandleCursors && element) {\n                    if (scene._pointerOverSprite && scene._pointerOverSprite.actionManager && scene._pointerOverSprite.actionManager.hoverCursor) {\n                        element.style.cursor = scene._pointerOverSprite.actionManager.hoverCursor;\n                    }\n                    else {\n                        element.style.cursor = scene.hoverCursor;\n                    }\n                }\n            }\n            else {\n                scene.setPointerOverSprite(null);\n            }\n        }\n        return pickResult;\n    }\n    _pointerDown(unTranslatedPointerX, unTranslatedPointerY, pickResult, evt) {\n        const scene = this.scene;\n        scene._pickedDownSprite = null;\n        if (scene.spriteManagers.length > 0) {\n            pickResult = scene.pickSprite(unTranslatedPointerX, unTranslatedPointerY, this._spritePredicate, false, scene.cameraToUseForPointers || undefined);\n            if (pickResult && pickResult.hit && pickResult.pickedSprite) {\n                if (pickResult.pickedSprite.actionManager) {\n                    scene._pickedDownSprite = pickResult.pickedSprite;\n                    switch (evt.button) {\n                        case 0:\n                            pickResult.pickedSprite.actionManager.processTrigger(2, ActionEvent.CreateNewFromSprite(pickResult.pickedSprite, scene, evt));\n                            break;\n                        case 1:\n                            pickResult.pickedSprite.actionManager.processTrigger(4, ActionEvent.CreateNewFromSprite(pickResult.pickedSprite, scene, evt));\n                            break;\n                        case 2:\n                            pickResult.pickedSprite.actionManager.processTrigger(3, ActionEvent.CreateNewFromSprite(pickResult.pickedSprite, scene, evt));\n                            break;\n                    }\n                    if (pickResult.pickedSprite.actionManager) {\n                        pickResult.pickedSprite.actionManager.processTrigger(5, ActionEvent.CreateNewFromSprite(pickResult.pickedSprite, scene, evt));\n                    }\n                }\n            }\n        }\n        return pickResult;\n    }\n    _pointerUp(unTranslatedPointerX, unTranslatedPointerY, pickResult, evt, doubleClick) {\n        const scene = this.scene;\n        if (scene.spriteManagers.length > 0) {\n            const spritePickResult = scene.pickSprite(unTranslatedPointerX, unTranslatedPointerY, this._spritePredicate, false, scene.cameraToUseForPointers || undefined);\n            if (spritePickResult) {\n                if (spritePickResult.hit && spritePickResult.pickedSprite) {\n                    if (spritePickResult.pickedSprite.actionManager) {\n                        spritePickResult.pickedSprite.actionManager.processTrigger(7, ActionEvent.CreateNewFromSprite(spritePickResult.pickedSprite, scene, evt));\n                        if (spritePickResult.pickedSprite.actionManager) {\n                            if (!this.scene._inputManager._isPointerSwiping()) {\n                                spritePickResult.pickedSprite.actionManager.processTrigger(1, ActionEvent.CreateNewFromSprite(spritePickResult.pickedSprite, scene, evt));\n                            }\n                            if (doubleClick) {\n                                spritePickResult.pickedSprite.actionManager.processTrigger(6, ActionEvent.CreateNewFromSprite(spritePickResult.pickedSprite, scene, evt));\n                            }\n                        }\n                    }\n                }\n                if (scene._pickedDownSprite && scene._pickedDownSprite.actionManager && scene._pickedDownSprite !== spritePickResult.pickedSprite) {\n                    scene._pickedDownSprite.actionManager.processTrigger(16, ActionEvent.CreateNewFromSprite(scene._pickedDownSprite, scene, evt));\n                }\n            }\n        }\n        return pickResult;\n    }\n}\n//# sourceMappingURL=spriteSceneComponent.js.map","import { Observable } from \"../Misc/observable.js\";\nimport { Vector3, TmpVectors, Matrix } from \"../Maths/math.vector.js\";\nimport { Sprite } from \"./sprite.js\";\nimport { SpriteSceneComponent } from \"./spriteSceneComponent.js\";\nimport { PickingInfo } from \"../Collisions/pickingInfo.js\";\nimport { Texture } from \"../Materials/Textures/texture.js\";\nimport { SceneComponentConstants } from \"../sceneComponent.js\";\nimport { Logger } from \"../Misc/logger.js\";\nimport { Tools } from \"../Misc/tools.js\";\nimport { WebRequest } from \"../Misc/webRequest.js\";\nimport { SpriteRenderer } from \"./spriteRenderer.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\n\n/**\n * Class used to manage multiple sprites on the same spritesheet\n * @see https://doc.babylonjs.com/features/featuresDeepDive/sprites\n */\nexport class SpriteManager {\n    /**\n     * Callback called when the manager is disposed\n     */\n    set onDispose(callback) {\n        if (this._onDisposeObserver) {\n            this.onDisposeObservable.remove(this._onDisposeObserver);\n        }\n        this._onDisposeObserver = this.onDisposeObservable.add(callback);\n    }\n    /**\n     * Gets the array of sprites\n     */\n    get children() {\n        return this.sprites;\n    }\n    /**\n     * Gets the hosting scene\n     */\n    get scene() {\n        return this._scene;\n    }\n    /**\n     * Gets the capacity of the manager\n     */\n    get capacity() {\n        return this._spriteRenderer.capacity;\n    }\n    /**\n     * Gets or sets the spritesheet texture\n     */\n    get texture() {\n        return this._spriteRenderer.texture;\n    }\n    set texture(value) {\n        value.wrapU = Texture.CLAMP_ADDRESSMODE;\n        value.wrapV = Texture.CLAMP_ADDRESSMODE;\n        this._spriteRenderer.texture = value;\n        this._textureContent = null;\n    }\n    /** Defines the default width of a cell in the spritesheet */\n    get cellWidth() {\n        return this._spriteRenderer.cellWidth;\n    }\n    set cellWidth(value) {\n        this._spriteRenderer.cellWidth = value;\n    }\n    /** Defines the default height of a cell in the spritesheet */\n    get cellHeight() {\n        return this._spriteRenderer.cellHeight;\n    }\n    set cellHeight(value) {\n        this._spriteRenderer.cellHeight = value;\n    }\n    /** Gets or sets a boolean indicating if the manager must consider scene fog when rendering */\n    get fogEnabled() {\n        return this._spriteRenderer.fogEnabled;\n    }\n    set fogEnabled(value) {\n        this._spriteRenderer.fogEnabled = value;\n    }\n    /**\n     * Blend mode use to render the particle, it can be any of\n     * the static undefined properties provided in this class.\n     * Default value is 2\n     */\n    get blendMode() {\n        return this._spriteRenderer.blendMode;\n    }\n    set blendMode(blendMode) {\n        this._spriteRenderer.blendMode = blendMode;\n    }\n    /** Disables writing to the depth buffer when rendering the sprites.\n     *  It can be handy to disable depth writing when using textures without alpha channel\n     *  and setting some specific blend modes.\n     */\n    get disableDepthWrite() {\n        return this._disableDepthWrite;\n    }\n    set disableDepthWrite(value) {\n        this._disableDepthWrite = value;\n        this._spriteRenderer.disableDepthWrite = value;\n    }\n    /**\n     * Creates a new sprite manager\n     * @param name defines the manager's name\n     * @param imgUrl defines the sprite sheet url\n     * @param capacity defines the maximum allowed number of sprites\n     * @param cellSize defines the size of a sprite cell\n     * @param scene defines the hosting scene\n     * @param epsilon defines the epsilon value to align texture (0.01 by default)\n     * @param samplingMode defines the sampling mode to use with spritesheet\n     * @param fromPacked set to false; do not alter\n     * @param spriteJSON null otherwise a JSON object defining sprite sheet data; do not alter\n     */\n    constructor(\n    /** defines the manager's name */\n    name, imgUrl, capacity, cellSize, scene, epsilon = 0.01, samplingMode = Texture.TRILINEAR_SAMPLINGMODE, fromPacked = false, spriteJSON = null) {\n        this.name = name;\n        /** Gets the list of sprites */\n        this.sprites = new Array();\n        /** Gets or sets the rendering group id (0 by default) */\n        this.renderingGroupId = 0;\n        /** Gets or sets camera layer mask */\n        this.layerMask = 0x0fffffff;\n        /** Gets or sets a boolean indicating if the sprites are pickable */\n        this.isPickable = false;\n        /**\n         * Gets or sets an object used to store user defined information for the sprite manager\n         */\n        this.metadata = null;\n        /** @internal */\n        this._wasDispatched = false;\n        /**\n         * An event triggered when the manager is disposed.\n         */\n        this.onDisposeObservable = new Observable();\n        this._disableDepthWrite = false;\n        /** True when packed cell data from JSON file is ready*/\n        this._packedAndReady = false;\n        this._customUpdate = (sprite, baseSize) => {\n            if (!sprite.cellRef) {\n                sprite.cellIndex = 0;\n            }\n            const num = sprite.cellIndex;\n            if (typeof num === \"number\" && isFinite(num) && Math.floor(num) === num) {\n                sprite.cellRef = this._spriteMap[sprite.cellIndex];\n            }\n            sprite._xOffset = this._cellData[sprite.cellRef].frame.x / baseSize.width;\n            sprite._yOffset = this._cellData[sprite.cellRef].frame.y / baseSize.height;\n            sprite._xSize = this._cellData[sprite.cellRef].frame.w;\n            sprite._ySize = this._cellData[sprite.cellRef].frame.h;\n        };\n        if (!scene) {\n            scene = EngineStore.LastCreatedScene;\n        }\n        if (!scene._getComponent(SceneComponentConstants.NAME_SPRITE)) {\n            scene._addComponent(new SpriteSceneComponent(scene));\n        }\n        this._fromPacked = fromPacked;\n        this._scene = scene;\n        const engine = this._scene.getEngine();\n        this._spriteRenderer = new SpriteRenderer(engine, capacity, epsilon, scene);\n        if (cellSize.width && cellSize.height) {\n            this.cellWidth = cellSize.width;\n            this.cellHeight = cellSize.height;\n        }\n        else if (cellSize !== undefined) {\n            this.cellWidth = cellSize;\n            this.cellHeight = cellSize;\n        }\n        else {\n            this._spriteRenderer = null;\n            return;\n        }\n        this._scene.spriteManagers.push(this);\n        this.uniqueId = this.scene.getUniqueId();\n        if (imgUrl) {\n            this.texture = new Texture(imgUrl, scene, true, false, samplingMode);\n        }\n        if (this._fromPacked) {\n            this._makePacked(imgUrl, spriteJSON);\n        }\n    }\n    /**\n     * Returns the string \"SpriteManager\"\n     * @returns \"SpriteManager\"\n     */\n    getClassName() {\n        return \"SpriteManager\";\n    }\n    _makePacked(imgUrl, spriteJSON) {\n        if (spriteJSON !== null) {\n            try {\n                //Get the JSON and Check its structure.  If its an array parse it if its a JSON string etc...\n                let celldata;\n                if (typeof spriteJSON === \"string\") {\n                    celldata = JSON.parse(spriteJSON);\n                }\n                else {\n                    celldata = spriteJSON;\n                }\n                if (celldata.frames.length) {\n                    const frametemp = {};\n                    for (let i = 0; i < celldata.frames.length; i++) {\n                        const _f = celldata.frames[i];\n                        if (typeof Object.keys(_f)[0] !== \"string\") {\n                            throw new Error(\"Invalid JSON Format.  Check the frame values and make sure the name is the first parameter.\");\n                        }\n                        const name = _f[Object.keys(_f)[0]];\n                        frametemp[name] = _f;\n                    }\n                    celldata.frames = frametemp;\n                }\n                const spritemap = Reflect.ownKeys(celldata.frames);\n                this._spriteMap = spritemap;\n                this._packedAndReady = true;\n                this._cellData = celldata.frames;\n            }\n            catch (e) {\n                this._fromPacked = false;\n                this._packedAndReady = false;\n                throw new Error(\"Invalid JSON from string. Spritesheet managed with constant cell size.\");\n            }\n        }\n        else {\n            const re = /\\./g;\n            let li;\n            do {\n                li = re.lastIndex;\n                re.test(imgUrl);\n            } while (re.lastIndex > 0);\n            const jsonUrl = imgUrl.substring(0, li - 1) + \".json\";\n            const onerror = () => {\n                Logger.Error(\"JSON ERROR: Unable to load JSON file.\");\n                this._fromPacked = false;\n                this._packedAndReady = false;\n            };\n            const onload = (data) => {\n                try {\n                    const celldata = JSON.parse(data);\n                    const spritemap = Reflect.ownKeys(celldata.frames);\n                    this._spriteMap = spritemap;\n                    this._packedAndReady = true;\n                    this._cellData = celldata.frames;\n                }\n                catch (e) {\n                    this._fromPacked = false;\n                    this._packedAndReady = false;\n                    throw new Error(\"Invalid JSON format. Please check documentation for format specifications.\");\n                }\n            };\n            Tools.LoadFile(jsonUrl, onload, undefined, undefined, false, onerror);\n        }\n    }\n    _checkTextureAlpha(sprite, ray, distance, min, max) {\n        if (!sprite.useAlphaForPicking || !this.texture) {\n            return true;\n        }\n        const textureSize = this.texture.getSize();\n        if (!this._textureContent) {\n            this._textureContent = new Uint8Array(textureSize.width * textureSize.height * 4);\n            this.texture.readPixels(0, 0, this._textureContent);\n        }\n        const contactPoint = TmpVectors.Vector3[0];\n        contactPoint.copyFrom(ray.direction);\n        contactPoint.normalize();\n        contactPoint.scaleInPlace(distance);\n        contactPoint.addInPlace(ray.origin);\n        const contactPointU = (contactPoint.x - min.x) / (max.x - min.x) - 0.5;\n        const contactPointV = 1.0 - (contactPoint.y - min.y) / (max.y - min.y) - 0.5;\n        // Rotate\n        const angle = sprite.angle;\n        const rotatedU = 0.5 + (contactPointU * Math.cos(angle) - contactPointV * Math.sin(angle));\n        const rotatedV = 0.5 + (contactPointU * Math.sin(angle) + contactPointV * Math.cos(angle));\n        const u = (sprite._xOffset * textureSize.width + rotatedU * sprite._xSize) | 0;\n        const v = (sprite._yOffset * textureSize.height + rotatedV * sprite._ySize) | 0;\n        const alpha = this._textureContent[(u + v * textureSize.width) * 4 + 3];\n        return alpha > 0.5;\n    }\n    /**\n     * Intersects the sprites with a ray\n     * @param ray defines the ray to intersect with\n     * @param camera defines the current active camera\n     * @param predicate defines a predicate used to select candidate sprites\n     * @param fastCheck defines if a fast check only must be done (the first potential sprite is will be used and not the closer)\n     * @returns null if no hit or a PickingInfo\n     */\n    intersects(ray, camera, predicate, fastCheck) {\n        const count = Math.min(this.capacity, this.sprites.length);\n        const min = Vector3.Zero();\n        const max = Vector3.Zero();\n        let distance = Number.MAX_VALUE;\n        let currentSprite = null;\n        const pickedPoint = TmpVectors.Vector3[0];\n        const cameraSpacePosition = TmpVectors.Vector3[1];\n        const cameraView = camera.getViewMatrix();\n        let activeRay = ray;\n        let pickedRay = ray;\n        for (let index = 0; index < count; index++) {\n            const sprite = this.sprites[index];\n            if (!sprite) {\n                continue;\n            }\n            if (predicate) {\n                if (!predicate(sprite)) {\n                    continue;\n                }\n            }\n            else if (!sprite.isPickable) {\n                continue;\n            }\n            Vector3.TransformCoordinatesToRef(sprite.position, cameraView, cameraSpacePosition);\n            if (sprite.angle) {\n                // Create a rotation matrix to rotate the ray to the sprite's rotation\n                Matrix.TranslationToRef(-cameraSpacePosition.x, -cameraSpacePosition.y, 0, TmpVectors.Matrix[1]);\n                Matrix.TranslationToRef(cameraSpacePosition.x, cameraSpacePosition.y, 0, TmpVectors.Matrix[2]);\n                Matrix.RotationZToRef(sprite.angle, TmpVectors.Matrix[3]);\n                // inv translation x rotation x translation\n                TmpVectors.Matrix[1].multiplyToRef(TmpVectors.Matrix[3], TmpVectors.Matrix[4]);\n                TmpVectors.Matrix[4].multiplyToRef(TmpVectors.Matrix[2], TmpVectors.Matrix[0]);\n                activeRay = ray.clone();\n                Vector3.TransformCoordinatesToRef(ray.origin, TmpVectors.Matrix[0], activeRay.origin);\n                Vector3.TransformNormalToRef(ray.direction, TmpVectors.Matrix[0], activeRay.direction);\n            }\n            else {\n                activeRay = ray;\n            }\n            min.copyFromFloats(cameraSpacePosition.x - sprite.width / 2, cameraSpacePosition.y - sprite.height / 2, cameraSpacePosition.z);\n            max.copyFromFloats(cameraSpacePosition.x + sprite.width / 2, cameraSpacePosition.y + sprite.height / 2, cameraSpacePosition.z);\n            if (activeRay.intersectsBoxMinMax(min, max)) {\n                const currentDistance = Vector3.Distance(cameraSpacePosition, activeRay.origin);\n                if (distance > currentDistance) {\n                    if (!this._checkTextureAlpha(sprite, activeRay, currentDistance, min, max)) {\n                        continue;\n                    }\n                    pickedRay = activeRay;\n                    distance = currentDistance;\n                    currentSprite = sprite;\n                    if (fastCheck) {\n                        break;\n                    }\n                }\n            }\n        }\n        if (currentSprite) {\n            const result = new PickingInfo();\n            cameraView.invertToRef(TmpVectors.Matrix[0]);\n            result.hit = true;\n            result.pickedSprite = currentSprite;\n            result.distance = distance;\n            // Get picked point\n            const direction = TmpVectors.Vector3[2];\n            direction.copyFrom(pickedRay.direction);\n            direction.normalize();\n            direction.scaleInPlace(distance);\n            pickedRay.origin.addToRef(direction, pickedPoint);\n            result.pickedPoint = Vector3.TransformCoordinates(pickedPoint, TmpVectors.Matrix[0]);\n            return result;\n        }\n        return null;\n    }\n    /**\n     * Intersects the sprites with a ray\n     * @param ray defines the ray to intersect with\n     * @param camera defines the current active camera\n     * @param predicate defines a predicate used to select candidate sprites\n     * @returns null if no hit or a PickingInfo array\n     */\n    multiIntersects(ray, camera, predicate) {\n        const count = Math.min(this.capacity, this.sprites.length);\n        const min = Vector3.Zero();\n        const max = Vector3.Zero();\n        let distance;\n        const results = [];\n        const pickedPoint = TmpVectors.Vector3[0].copyFromFloats(0, 0, 0);\n        const cameraSpacePosition = TmpVectors.Vector3[1].copyFromFloats(0, 0, 0);\n        const cameraView = camera.getViewMatrix();\n        for (let index = 0; index < count; index++) {\n            const sprite = this.sprites[index];\n            if (!sprite) {\n                continue;\n            }\n            if (predicate) {\n                if (!predicate(sprite)) {\n                    continue;\n                }\n            }\n            else if (!sprite.isPickable) {\n                continue;\n            }\n            Vector3.TransformCoordinatesToRef(sprite.position, cameraView, cameraSpacePosition);\n            min.copyFromFloats(cameraSpacePosition.x - sprite.width / 2, cameraSpacePosition.y - sprite.height / 2, cameraSpacePosition.z);\n            max.copyFromFloats(cameraSpacePosition.x + sprite.width / 2, cameraSpacePosition.y + sprite.height / 2, cameraSpacePosition.z);\n            if (ray.intersectsBoxMinMax(min, max)) {\n                distance = Vector3.Distance(cameraSpacePosition, ray.origin);\n                if (!this._checkTextureAlpha(sprite, ray, distance, min, max)) {\n                    continue;\n                }\n                const result = new PickingInfo();\n                results.push(result);\n                cameraView.invertToRef(TmpVectors.Matrix[0]);\n                result.hit = true;\n                result.pickedSprite = sprite;\n                result.distance = distance;\n                // Get picked point\n                const direction = TmpVectors.Vector3[2];\n                direction.copyFrom(ray.direction);\n                direction.normalize();\n                direction.scaleInPlace(distance);\n                ray.origin.addToRef(direction, pickedPoint);\n                result.pickedPoint = Vector3.TransformCoordinates(pickedPoint, TmpVectors.Matrix[0]);\n            }\n        }\n        return results;\n    }\n    /**\n     * Render all child sprites\n     */\n    render() {\n        // Check\n        if (this._fromPacked && (!this._packedAndReady || !this._spriteMap || !this._cellData)) {\n            return;\n        }\n        const engine = this._scene.getEngine();\n        const deltaTime = engine.getDeltaTime();\n        if (this._packedAndReady) {\n            this._spriteRenderer.render(this.sprites, deltaTime, this._scene.getViewMatrix(), this._scene.getProjectionMatrix(), this._customUpdate);\n        }\n        else {\n            this._spriteRenderer.render(this.sprites, deltaTime, this._scene.getViewMatrix(), this._scene.getProjectionMatrix());\n        }\n    }\n    /**\n     * Rebuilds the manager (after a context lost, for eg)\n     */\n    rebuild() {\n        var _a;\n        (_a = this._spriteRenderer) === null || _a === void 0 ? void 0 : _a.rebuild();\n    }\n    /**\n     * Release associated resources\n     */\n    dispose() {\n        if (this._spriteRenderer) {\n            this._spriteRenderer.dispose();\n            this._spriteRenderer = null;\n        }\n        this._textureContent = null;\n        // Remove from scene\n        const index = this._scene.spriteManagers.indexOf(this);\n        this._scene.spriteManagers.splice(index, 1);\n        // Callback\n        this.onDisposeObservable.notifyObservers(this);\n        this.onDisposeObservable.clear();\n        this.metadata = null;\n    }\n    /**\n     * Serializes the sprite manager to a JSON object\n     * @param serializeTexture defines if the texture must be serialized as well\n     * @returns the JSON object\n     */\n    serialize(serializeTexture = false) {\n        const serializationObject = {};\n        serializationObject.name = this.name;\n        serializationObject.capacity = this.capacity;\n        serializationObject.cellWidth = this.cellWidth;\n        serializationObject.cellHeight = this.cellHeight;\n        if (this.texture) {\n            if (serializeTexture) {\n                serializationObject.texture = this.texture.serialize();\n            }\n            else {\n                serializationObject.textureUrl = this.texture.name;\n                serializationObject.invertY = this.texture._invertY;\n            }\n        }\n        serializationObject.sprites = [];\n        for (const sprite of this.sprites) {\n            serializationObject.sprites.push(sprite.serialize());\n        }\n        serializationObject.metadata = this.metadata;\n        return serializationObject;\n    }\n    /**\n     * Parses a JSON object to create a new sprite manager.\n     * @param parsedManager The JSON object to parse\n     * @param scene The scene to create the sprite manager\n     * @param rootUrl The root url to use to load external dependencies like texture\n     * @returns the new sprite manager\n     */\n    static Parse(parsedManager, scene, rootUrl) {\n        const manager = new SpriteManager(parsedManager.name, \"\", parsedManager.capacity, {\n            width: parsedManager.cellWidth,\n            height: parsedManager.cellHeight,\n        }, scene);\n        if (parsedManager.metadata !== undefined) {\n            manager.metadata = parsedManager.metadata;\n        }\n        if (parsedManager.texture) {\n            manager.texture = Texture.Parse(parsedManager.texture, scene, rootUrl);\n        }\n        else if (parsedManager.textureName) {\n            manager.texture = new Texture(rootUrl + parsedManager.textureUrl, scene, false, parsedManager.invertY !== undefined ? parsedManager.invertY : true);\n        }\n        for (const parsedSprite of parsedManager.sprites) {\n            Sprite.Parse(parsedSprite, manager);\n        }\n        return manager;\n    }\n    /**\n     * Creates a sprite manager from a snippet saved in a remote file\n     * @param name defines the name of the sprite manager to create (can be null or empty to use the one from the json data)\n     * @param url defines the url to load from\n     * @param scene defines the hosting scene\n     * @param rootUrl defines the root URL to use to load textures and relative dependencies\n     * @returns a promise that will resolve to the new sprite manager\n     */\n    static ParseFromFileAsync(name, url, scene, rootUrl = \"\") {\n        return new Promise((resolve, reject) => {\n            const request = new WebRequest();\n            request.addEventListener(\"readystatechange\", () => {\n                if (request.readyState == 4) {\n                    if (request.status == 200) {\n                        const serializationObject = JSON.parse(request.responseText);\n                        const output = SpriteManager.Parse(serializationObject, scene || EngineStore.LastCreatedScene, rootUrl);\n                        if (name) {\n                            output.name = name;\n                        }\n                        resolve(output);\n                    }\n                    else {\n                        reject(\"Unable to load the sprite manager\");\n                    }\n                }\n            });\n            request.open(\"GET\", url);\n            request.send();\n        });\n    }\n    /**\n     * Creates a sprite manager from a snippet saved by the sprite editor\n     * @param snippetId defines the snippet to load (can be set to _BLANK to create a default one)\n     * @param scene defines the hosting scene\n     * @param rootUrl defines the root URL to use to load textures and relative dependencies\n     * @returns a promise that will resolve to the new sprite manager\n     */\n    static ParseFromSnippetAsync(snippetId, scene, rootUrl = \"\") {\n        if (snippetId === \"_BLANK\") {\n            return Promise.resolve(new SpriteManager(\"Default sprite manager\", \"//playground.babylonjs.com/textures/player.png\", 500, 64, scene));\n        }\n        return new Promise((resolve, reject) => {\n            const request = new WebRequest();\n            request.addEventListener(\"readystatechange\", () => {\n                if (request.readyState == 4) {\n                    if (request.status == 200) {\n                        const snippet = JSON.parse(JSON.parse(request.responseText).jsonPayload);\n                        const serializationObject = JSON.parse(snippet.spriteManager);\n                        const output = SpriteManager.Parse(serializationObject, scene || EngineStore.LastCreatedScene, rootUrl);\n                        output.snippetId = snippetId;\n                        resolve(output);\n                    }\n                    else {\n                        reject(\"Unable to load the snippet \" + snippetId);\n                    }\n                }\n            });\n            request.open(\"GET\", this.SnippetUrl + \"/\" + snippetId.replace(/#/g, \"/\"));\n            request.send();\n        });\n    }\n}\n/** Define the Url to load snippets */\nSpriteManager.SnippetUrl = `https://snippet.babylonjs.com`;\n/**\n * Creates a sprite manager from a snippet saved by the sprite editor\n * @deprecated Please use ParseFromSnippetAsync instead\n * @param snippetId defines the snippet to load (can be set to _BLANK to create a default one)\n * @param scene defines the hosting scene\n * @param rootUrl defines the root URL to use to load textures and relative dependencies\n * @returns a promise that will resolve to the new sprite manager\n */\nSpriteManager.CreateFromSnippetAsync = SpriteManager.ParseFromSnippetAsync;\n//# sourceMappingURL=spriteManager.js.map","import { Engine } from \"../Engines/engine.js\";\nimport { Vector2, Vector3 } from \"../Maths/math.vector.js\";\nimport { Texture } from \"../Materials/Textures/texture.js\";\nimport { RawTexture } from \"../Materials/Textures/rawTexture.js\";\nimport { ShaderMaterial } from \"../Materials/shaderMaterial.js\";\nimport { Effect } from \"../Materials/effect.js\";\nimport { CreatePlane } from \"../Meshes/Builders/planeBuilder.js\";\nimport \"../Shaders/spriteMap.fragment.js\";\nimport \"../Shaders/spriteMap.vertex.js\";\n/**\n * Class used to manage a grid restricted sprite deployment on an Output plane.\n */\nexport class SpriteMap {\n    /** Returns the Number of Sprites in the System */\n    get spriteCount() {\n        return this.sprites.length;\n    }\n    /** Returns the Position of Output Plane*/\n    get position() {\n        return this._output.position;\n    }\n    /** Returns the Position of Output Plane*/\n    set position(v) {\n        this._output.position = v;\n    }\n    /** Returns the Rotation of Output Plane*/\n    get rotation() {\n        return this._output.rotation;\n    }\n    /** Returns the Rotation of Output Plane*/\n    set rotation(v) {\n        this._output.rotation = v;\n    }\n    /** Sets the AnimationMap*/\n    get animationMap() {\n        return this._animationMap;\n    }\n    /** Sets the AnimationMap*/\n    set animationMap(v) {\n        const buffer = v._texture._bufferView;\n        const am = this._createTileAnimationBuffer(buffer);\n        this._animationMap.dispose();\n        this._animationMap = am;\n        this._material.setTexture(\"animationMap\", this._animationMap);\n    }\n    /**\n     * Creates a new SpriteMap\n     * @param name defines the SpriteMaps Name\n     * @param atlasJSON is the JSON file that controls the Sprites Frames and Meta\n     * @param spriteSheet is the Texture that the Sprites are on.\n     * @param options a basic deployment configuration\n     * @param scene The Scene that the map is deployed on\n     */\n    constructor(name, atlasJSON, spriteSheet, options, scene) {\n        this.name = name;\n        this.sprites = [];\n        this.atlasJSON = atlasJSON;\n        this.sprites = this.atlasJSON[\"frames\"];\n        this.spriteSheet = spriteSheet;\n        /**\n         * Run through the options and set what ever defaults are needed that where not declared.\n         */\n        this.options = options;\n        options.stageSize = options.stageSize || new Vector2(1, 1);\n        options.outputSize = options.outputSize || options.stageSize;\n        options.outputPosition = options.outputPosition || Vector3.Zero();\n        options.outputRotation = options.outputRotation || Vector3.Zero();\n        options.layerCount = options.layerCount || 1;\n        options.maxAnimationFrames = options.maxAnimationFrames || 0;\n        options.baseTile = options.baseTile || 0;\n        options.flipU = options.flipU || false;\n        options.colorMultiply = options.colorMultiply || new Vector3(1, 1, 1);\n        this._scene = scene;\n        this._frameMap = this._createFrameBuffer();\n        this._tileMaps = new Array();\n        for (let i = 0; i < options.layerCount; i++) {\n            this._tileMaps.push(this._createTileBuffer(null, i));\n        }\n        this._animationMap = this._createTileAnimationBuffer(null);\n        const defines = [];\n        defines.push(\"#define LAYERS \" + options.layerCount);\n        if (options.flipU) {\n            defines.push(\"#define FLIPU\");\n        }\n        defines.push(`#define MAX_ANIMATION_FRAMES ${options.maxAnimationFrames}.0`);\n        const shaderString = Effect.ShadersStore[\"spriteMapPixelShader\"];\n        let layerSampleString;\n        if (!scene.getEngine()._features.supportSwitchCaseInShader) {\n            layerSampleString = \"\";\n            for (let i = 0; i < options.layerCount; i++) {\n                layerSampleString += `if (${i} == i) { frameID = texture2D(tileMaps[${i}], (tileID + 0.5) / stageSize, 0.).x; }`;\n            }\n        }\n        else {\n            layerSampleString = \"switch(i) {\";\n            for (let i = 0; i < options.layerCount; i++) {\n                layerSampleString += \"case \" + i + \" : frameID = texture(tileMaps[\" + i + \"], (tileID + 0.5) / stageSize, 0.).x;\";\n                layerSampleString += \"break;\";\n            }\n            layerSampleString += \"}\";\n        }\n        Effect.ShadersStore[\"spriteMap\" + this.name + \"PixelShader\"] = shaderString.replace(\"#define LAYER_ID_SWITCH\", layerSampleString);\n        this._material = new ShaderMaterial(\"spriteMap:\" + this.name, this._scene, {\n            vertex: \"spriteMap\",\n            fragment: \"spriteMap\" + this.name,\n        }, {\n            defines,\n            attributes: [\"position\", \"normal\", \"uv\"],\n            uniforms: [\"worldViewProjection\", \"time\", \"stageSize\", \"outputSize\", \"spriteMapSize\", \"spriteCount\", \"time\", \"colorMul\", \"mousePosition\", \"curTile\", \"flipU\"],\n            samplers: [\"spriteSheet\", \"frameMap\", \"tileMaps\", \"animationMap\"],\n            needAlphaBlending: true,\n        });\n        this._time = 0;\n        this._material.setFloat(\"spriteCount\", this.spriteCount);\n        this._material.setVector2(\"stageSize\", options.stageSize);\n        this._material.setVector2(\"outputSize\", options.outputSize);\n        this._material.setTexture(\"spriteSheet\", this.spriteSheet);\n        this._material.setVector2(\"spriteMapSize\", new Vector2(1, 1));\n        this._material.setVector3(\"colorMul\", options.colorMultiply);\n        let tickSave = 0;\n        const bindSpriteTexture = () => {\n            if (this.spriteSheet && this.spriteSheet.isReady()) {\n                if (this.spriteSheet._texture) {\n                    this._material.setVector2(\"spriteMapSize\", new Vector2(this.spriteSheet._texture.baseWidth || 1, this.spriteSheet._texture.baseHeight || 1));\n                    return;\n                }\n            }\n            if (tickSave < 100) {\n                setTimeout(() => {\n                    tickSave++;\n                    bindSpriteTexture();\n                }, 100);\n            }\n        };\n        bindSpriteTexture();\n        this._material.setVector3(\"colorMul\", options.colorMultiply);\n        this._material.setTexture(\"frameMap\", this._frameMap);\n        this._material.setTextureArray(\"tileMaps\", this._tileMaps);\n        this._material.setTexture(\"animationMap\", this._animationMap);\n        this._material.setFloat(\"time\", this._time);\n        this._output = CreatePlane(name + \":output\", { size: 1, updatable: true }, scene);\n        this._output.scaling.x = options.outputSize.x;\n        this._output.scaling.y = options.outputSize.y;\n        this.position = options.outputPosition;\n        this.rotation = options.outputRotation;\n        const obfunction = () => {\n            this._time += this._scene.getEngine().getDeltaTime();\n            this._material.setFloat(\"time\", this._time);\n        };\n        this._scene.onBeforeRenderObservable.add(obfunction);\n        this._output.material = this._material;\n    }\n    /**\n     * Returns tileID location\n     * @returns Vector2 the cell position ID\n     */\n    getTileID() {\n        const p = this.getMousePosition();\n        p.multiplyInPlace(this.options.stageSize || Vector2.Zero());\n        p.x = Math.floor(p.x);\n        p.y = Math.floor(p.y);\n        return p;\n    }\n    /**\n     * Gets the UV location of the mouse over the SpriteMap.\n     * @returns Vector2 the UV position of the mouse interaction\n     */\n    getMousePosition() {\n        const out = this._output;\n        const pickinfo = this._scene.pick(this._scene.pointerX, this._scene.pointerY, (mesh) => {\n            if (mesh !== out) {\n                return false;\n            }\n            return true;\n        });\n        if (!pickinfo || !pickinfo.hit || !pickinfo.getTextureCoordinates) {\n            return new Vector2(-1, -1);\n        }\n        const coords = pickinfo.getTextureCoordinates();\n        if (coords) {\n            return coords;\n        }\n        return new Vector2(-1, -1);\n    }\n    /**\n     * Creates the \"frame\" texture Buffer\n     * -------------------------------------\n     * Structure of frames\n     *  \"filename\": \"Falling-Water-2.png\",\n     * \"frame\": {\"x\":69,\"y\":103,\"w\":24,\"h\":32},\n     * \"rotated\": true,\n     * \"trimmed\": true,\n     * \"spriteSourceSize\": {\"x\":4,\"y\":0,\"w\":24,\"h\":32},\n     * \"sourceSize\": {\"w\":32,\"h\":32}\n     * @returns RawTexture of the frameMap\n     */\n    _createFrameBuffer() {\n        const data = new Array();\n        //Do two Passes\n        for (let i = 0; i < this.spriteCount; i++) {\n            data.push(0, 0, 0, 0); //frame\n            data.push(0, 0, 0, 0); //spriteSourceSize\n            data.push(0, 0, 0, 0); //sourceSize, rotated, trimmed\n            data.push(0, 0, 0, 0); //Keep it pow2 cause I\"m cool like that... it helps with sampling accuracy as well. Plus then we have 4 other parameters for future stuff.\n        }\n        //Second Pass\n        for (let i = 0; i < this.spriteCount; i++) {\n            const f = this.sprites[i][\"frame\"];\n            const sss = this.sprites[i][\"spriteSourceSize\"];\n            const ss = this.sprites[i][\"sourceSize\"];\n            const r = this.sprites[i][\"rotated\"] ? 1 : 0;\n            const t = this.sprites[i][\"trimmed\"] ? 1 : 0;\n            //frame\n            data[i * 4] = f.x;\n            data[i * 4 + 1] = f.y;\n            data[i * 4 + 2] = f.w;\n            data[i * 4 + 3] = f.h;\n            //spriteSourceSize\n            data[i * 4 + this.spriteCount * 4] = sss.x;\n            data[i * 4 + 1 + this.spriteCount * 4] = sss.y;\n            data[i * 4 + 3 + this.spriteCount * 4] = sss.h;\n            //sourceSize, rotated, trimmed\n            data[i * 4 + this.spriteCount * 8] = ss.w;\n            data[i * 4 + 1 + this.spriteCount * 8] = ss.h;\n            data[i * 4 + 2 + this.spriteCount * 8] = r;\n            data[i * 4 + 3 + this.spriteCount * 8] = t;\n        }\n        const floatArray = new Float32Array(data);\n        const t = RawTexture.CreateRGBATexture(floatArray, this.spriteCount, 4, this._scene, false, false, Texture.NEAREST_NEAREST, Engine.TEXTURETYPE_FLOAT);\n        return t;\n    }\n    /**\n     * Creates the tileMap texture Buffer\n     * @param buffer normally and array of numbers, or a false to generate from scratch\n     * @param _layer indicates what layer for a logic trigger dealing with the baseTile.  The system uses this\n     * @returns RawTexture of the tileMap\n     */\n    _createTileBuffer(buffer, _layer = 0) {\n        let data = new Array();\n        const _ty = this.options.stageSize.y || 0;\n        const _tx = this.options.stageSize.x || 0;\n        if (!buffer) {\n            let bt = this.options.baseTile;\n            if (_layer != 0) {\n                bt = 0;\n            }\n            for (let y = 0; y < _ty; y++) {\n                for (let x = 0; x < _tx * 4; x += 4) {\n                    data.push(bt, 0, 0, 0);\n                }\n            }\n        }\n        else {\n            data = buffer;\n        }\n        const floatArray = new Float32Array(data);\n        const t = RawTexture.CreateRGBATexture(floatArray, _tx, _ty, this._scene, false, false, Texture.NEAREST_NEAREST, Engine.TEXTURETYPE_FLOAT);\n        return t;\n    }\n    /**\n     * Modifies the data of the tileMaps\n     * @param _layer is the ID of the layer you want to edit on the SpriteMap\n     * @param pos is the iVector2 Coordinates of the Tile\n     * @param tile The SpriteIndex of the new Tile\n     */\n    changeTiles(_layer = 0, pos, tile = 0) {\n        const buffer = this._tileMaps[_layer]._texture._bufferView;\n        if (buffer === null) {\n            return;\n        }\n        let p = new Array();\n        if (pos instanceof Vector2) {\n            p.push(pos);\n        }\n        else {\n            p = pos;\n        }\n        const _tx = this.options.stageSize.x || 0;\n        for (let i = 0; i < p.length; i++) {\n            const _p = p[i];\n            _p.x = Math.floor(_p.x);\n            _p.y = Math.floor(_p.y);\n            const id = _p.x * 4 + _p.y * (_tx * 4);\n            buffer[id] = tile;\n        }\n        const t = this._createTileBuffer(buffer);\n        this._tileMaps[_layer].dispose();\n        this._tileMaps[_layer] = t;\n        this._material.setTextureArray(\"tileMap\", this._tileMaps);\n    }\n    /**\n     * Creates the animationMap texture Buffer\n     * @param buffer normally and array of numbers, or a false to generate from scratch\n     * @returns RawTexture of the animationMap\n     */\n    _createTileAnimationBuffer(buffer) {\n        const data = new Array();\n        let floatArray;\n        if (!buffer) {\n            for (let i = 0; i < this.spriteCount; i++) {\n                data.push(0, 0, 0, 0);\n                let count = 1;\n                while (count < (this.options.maxAnimationFrames || 4)) {\n                    data.push(0, 0, 0, 0);\n                    count++;\n                }\n            }\n            floatArray = new Float32Array(data);\n        }\n        else {\n            floatArray = buffer;\n        }\n        const t = RawTexture.CreateRGBATexture(floatArray, this.spriteCount, this.options.maxAnimationFrames || 4, this._scene, false, false, Texture.NEAREST_NEAREST, Engine.TEXTURETYPE_FLOAT);\n        return t;\n    }\n    /**\n     * Modifies the data of the animationMap\n     * @param cellID is the Index of the Sprite\n     * @param _frame is the target Animation frame\n     * @param toCell is the Target Index of the next frame of the animation\n     * @param time is a value between 0-1 that is the trigger for when the frame should change tiles\n     * @param speed is a global scalar of the time variable on the map.\n     */\n    addAnimationToTile(cellID = 0, _frame = 0, toCell = 0, time = 0, speed = 1) {\n        const buffer = this._animationMap._texture._bufferView;\n        const id = cellID * 4 + this.spriteCount * 4 * _frame;\n        if (!buffer) {\n            return;\n        }\n        buffer[id] = toCell;\n        buffer[id + 1] = time;\n        buffer[id + 2] = speed;\n        const t = this._createTileAnimationBuffer(buffer);\n        this._animationMap.dispose();\n        this._animationMap = t;\n        this._material.setTexture(\"animationMap\", this._animationMap);\n    }\n    /**\n     * Exports the .tilemaps file\n     */\n    saveTileMaps() {\n        let maps = \"\";\n        for (let i = 0; i < this._tileMaps.length; i++) {\n            if (i > 0) {\n                maps += \"\\n\\r\";\n            }\n            maps += this._tileMaps[i]._texture._bufferView.toString();\n        }\n        const hiddenElement = document.createElement(\"a\");\n        hiddenElement.href = \"data:octet/stream;charset=utf-8,\" + encodeURI(maps);\n        hiddenElement.target = \"_blank\";\n        hiddenElement.download = this.name + \".tilemaps\";\n        hiddenElement.click();\n        hiddenElement.remove();\n    }\n    /**\n     * Imports the .tilemaps file\n     * @param url of the .tilemaps file\n     */\n    loadTileMaps(url) {\n        const xhr = new XMLHttpRequest();\n        xhr.open(\"GET\", url);\n        const _lc = this.options.layerCount || 0;\n        xhr.onload = () => {\n            const data = xhr.response.split(\"\\n\\r\");\n            for (let i = 0; i < _lc; i++) {\n                const d = data[i].split(\",\").map(Number);\n                const t = this._createTileBuffer(d);\n                this._tileMaps[i].dispose();\n                this._tileMaps[i] = t;\n            }\n            this._material.setTextureArray(\"tileMap\", this._tileMaps);\n        };\n        xhr.send();\n    }\n    /**\n     * Release associated resources\n     */\n    dispose() {\n        this._output.dispose();\n        this._material.dispose();\n        this._animationMap.dispose();\n        this._tileMaps.forEach((tm) => {\n            tm.dispose();\n        });\n        this._frameMap.dispose();\n    }\n}\n//# sourceMappingURL=spriteMap.js.map","import { SpriteManager } from \"./spriteManager.js\";\nimport { Texture } from \"../Materials/Textures/texture.js\";\n/**\n * Class used to manage multiple sprites of different sizes on the same spritesheet\n * @see https://doc.babylonjs.com/features/featuresDeepDive/sprites\n */\nexport class SpritePackedManager extends SpriteManager {\n    /**\n     * Creates a new sprite manager from a packed sprite sheet\n     * @param name defines the manager's name\n     * @param imgUrl defines the sprite sheet url\n     * @param capacity defines the maximum allowed number of sprites\n     * @param scene defines the hosting scene\n     * @param spriteJSON null otherwise a JSON object defining sprite sheet data\n     * @param epsilon defines the epsilon value to align texture (0.01 by default)\n     * @param samplingMode defines the sampling mode to use with spritesheet\n     * @param fromPacked set to true; do not alter\n     */\n    constructor(\n    /** defines the packed manager's name */\n    name, imgUrl, capacity, scene, spriteJSON = null, epsilon = 0.01, samplingMode = Texture.TRILINEAR_SAMPLINGMODE) {\n        //the cellSize parameter is not used when built from JSON which provides individual cell data, defaults to 64 if JSON load fails\n        super(name, imgUrl, capacity, 64, scene, epsilon, samplingMode, true, spriteJSON);\n        this.name = name;\n    }\n}\n//# sourceMappingURL=spritePackedManager.js.map","/**\n * @internal\n **/\nexport class AlphaState {\n    /**\n     * Initializes the state.\n     */\n    constructor() {\n        this._blendFunctionParameters = new Array(4);\n        this._blendEquationParameters = new Array(2);\n        this._blendConstants = new Array(4);\n        this._isBlendConstantsDirty = false;\n        this._alphaBlend = false;\n        this._isAlphaBlendDirty = false;\n        this._isBlendFunctionParametersDirty = false;\n        this._isBlendEquationParametersDirty = false;\n        this.reset();\n    }\n    get isDirty() {\n        return this._isAlphaBlendDirty || this._isBlendFunctionParametersDirty || this._isBlendEquationParametersDirty;\n    }\n    get alphaBlend() {\n        return this._alphaBlend;\n    }\n    set alphaBlend(value) {\n        if (this._alphaBlend === value) {\n            return;\n        }\n        this._alphaBlend = value;\n        this._isAlphaBlendDirty = true;\n    }\n    setAlphaBlendConstants(r, g, b, a) {\n        if (this._blendConstants[0] === r && this._blendConstants[1] === g && this._blendConstants[2] === b && this._blendConstants[3] === a) {\n            return;\n        }\n        this._blendConstants[0] = r;\n        this._blendConstants[1] = g;\n        this._blendConstants[2] = b;\n        this._blendConstants[3] = a;\n        this._isBlendConstantsDirty = true;\n    }\n    setAlphaBlendFunctionParameters(value0, value1, value2, value3) {\n        if (this._blendFunctionParameters[0] === value0 &&\n            this._blendFunctionParameters[1] === value1 &&\n            this._blendFunctionParameters[2] === value2 &&\n            this._blendFunctionParameters[3] === value3) {\n            return;\n        }\n        this._blendFunctionParameters[0] = value0;\n        this._blendFunctionParameters[1] = value1;\n        this._blendFunctionParameters[2] = value2;\n        this._blendFunctionParameters[3] = value3;\n        this._isBlendFunctionParametersDirty = true;\n    }\n    setAlphaEquationParameters(rgb, alpha) {\n        if (this._blendEquationParameters[0] === rgb && this._blendEquationParameters[1] === alpha) {\n            return;\n        }\n        this._blendEquationParameters[0] = rgb;\n        this._blendEquationParameters[1] = alpha;\n        this._isBlendEquationParametersDirty = true;\n    }\n    reset() {\n        this._alphaBlend = false;\n        this._blendFunctionParameters[0] = null;\n        this._blendFunctionParameters[1] = null;\n        this._blendFunctionParameters[2] = null;\n        this._blendFunctionParameters[3] = null;\n        this._blendEquationParameters[0] = null;\n        this._blendEquationParameters[1] = null;\n        this._blendConstants[0] = null;\n        this._blendConstants[1] = null;\n        this._blendConstants[2] = null;\n        this._blendConstants[3] = null;\n        this._isAlphaBlendDirty = true;\n        this._isBlendFunctionParametersDirty = false;\n        this._isBlendEquationParametersDirty = false;\n        this._isBlendConstantsDirty = false;\n    }\n    apply(gl) {\n        if (!this.isDirty) {\n            return;\n        }\n        // Alpha blend\n        if (this._isAlphaBlendDirty) {\n            if (this._alphaBlend) {\n                gl.enable(gl.BLEND);\n            }\n            else {\n                gl.disable(gl.BLEND);\n            }\n            this._isAlphaBlendDirty = false;\n        }\n        // Alpha function\n        if (this._isBlendFunctionParametersDirty) {\n            gl.blendFuncSeparate(this._blendFunctionParameters[0], this._blendFunctionParameters[1], this._blendFunctionParameters[2], this._blendFunctionParameters[3]);\n            this._isBlendFunctionParametersDirty = false;\n        }\n        // Alpha equation\n        if (this._isBlendEquationParametersDirty) {\n            gl.blendEquationSeparate(this._blendEquationParameters[0], this._blendEquationParameters[1]);\n            this._isBlendEquationParametersDirty = false;\n        }\n        // Constants\n        if (this._isBlendConstantsDirty) {\n            gl.blendColor(this._blendConstants[0], this._blendConstants[1], this._blendConstants[2], this._blendConstants[3]);\n            this._isBlendConstantsDirty = false;\n        }\n    }\n}\n//# sourceMappingURL=alphaCullingState.js.map","/**\n * @internal\n **/\nexport class DepthCullingState {\n    /**\n     * Initializes the state.\n     * @param reset\n     */\n    constructor(reset = true) {\n        this._isDepthTestDirty = false;\n        this._isDepthMaskDirty = false;\n        this._isDepthFuncDirty = false;\n        this._isCullFaceDirty = false;\n        this._isCullDirty = false;\n        this._isZOffsetDirty = false;\n        this._isFrontFaceDirty = false;\n        if (reset) {\n            this.reset();\n        }\n    }\n    get isDirty() {\n        return (this._isDepthFuncDirty ||\n            this._isDepthTestDirty ||\n            this._isDepthMaskDirty ||\n            this._isCullFaceDirty ||\n            this._isCullDirty ||\n            this._isZOffsetDirty ||\n            this._isFrontFaceDirty);\n    }\n    get zOffset() {\n        return this._zOffset;\n    }\n    set zOffset(value) {\n        if (this._zOffset === value) {\n            return;\n        }\n        this._zOffset = value;\n        this._isZOffsetDirty = true;\n    }\n    get zOffsetUnits() {\n        return this._zOffsetUnits;\n    }\n    set zOffsetUnits(value) {\n        if (this._zOffsetUnits === value) {\n            return;\n        }\n        this._zOffsetUnits = value;\n        this._isZOffsetDirty = true;\n    }\n    get cullFace() {\n        return this._cullFace;\n    }\n    set cullFace(value) {\n        if (this._cullFace === value) {\n            return;\n        }\n        this._cullFace = value;\n        this._isCullFaceDirty = true;\n    }\n    get cull() {\n        return this._cull;\n    }\n    set cull(value) {\n        if (this._cull === value) {\n            return;\n        }\n        this._cull = value;\n        this._isCullDirty = true;\n    }\n    get depthFunc() {\n        return this._depthFunc;\n    }\n    set depthFunc(value) {\n        if (this._depthFunc === value) {\n            return;\n        }\n        this._depthFunc = value;\n        this._isDepthFuncDirty = true;\n    }\n    get depthMask() {\n        return this._depthMask;\n    }\n    set depthMask(value) {\n        if (this._depthMask === value) {\n            return;\n        }\n        this._depthMask = value;\n        this._isDepthMaskDirty = true;\n    }\n    get depthTest() {\n        return this._depthTest;\n    }\n    set depthTest(value) {\n        if (this._depthTest === value) {\n            return;\n        }\n        this._depthTest = value;\n        this._isDepthTestDirty = true;\n    }\n    get frontFace() {\n        return this._frontFace;\n    }\n    set frontFace(value) {\n        if (this._frontFace === value) {\n            return;\n        }\n        this._frontFace = value;\n        this._isFrontFaceDirty = true;\n    }\n    reset() {\n        this._depthMask = true;\n        this._depthTest = true;\n        this._depthFunc = null;\n        this._cullFace = null;\n        this._cull = null;\n        this._zOffset = 0;\n        this._zOffsetUnits = 0;\n        this._frontFace = null;\n        this._isDepthTestDirty = true;\n        this._isDepthMaskDirty = true;\n        this._isDepthFuncDirty = false;\n        this._isCullFaceDirty = false;\n        this._isCullDirty = false;\n        this._isZOffsetDirty = true;\n        this._isFrontFaceDirty = false;\n    }\n    apply(gl) {\n        if (!this.isDirty) {\n            return;\n        }\n        // Cull\n        if (this._isCullDirty) {\n            if (this.cull) {\n                gl.enable(gl.CULL_FACE);\n            }\n            else {\n                gl.disable(gl.CULL_FACE);\n            }\n            this._isCullDirty = false;\n        }\n        // Cull face\n        if (this._isCullFaceDirty) {\n            gl.cullFace(this.cullFace);\n            this._isCullFaceDirty = false;\n        }\n        // Depth mask\n        if (this._isDepthMaskDirty) {\n            gl.depthMask(this.depthMask);\n            this._isDepthMaskDirty = false;\n        }\n        // Depth test\n        if (this._isDepthTestDirty) {\n            if (this.depthTest) {\n                gl.enable(gl.DEPTH_TEST);\n            }\n            else {\n                gl.disable(gl.DEPTH_TEST);\n            }\n            this._isDepthTestDirty = false;\n        }\n        // Depth func\n        if (this._isDepthFuncDirty) {\n            gl.depthFunc(this.depthFunc);\n            this._isDepthFuncDirty = false;\n        }\n        // zOffset\n        if (this._isZOffsetDirty) {\n            if (this.zOffset || this.zOffsetUnits) {\n                gl.enable(gl.POLYGON_OFFSET_FILL);\n                gl.polygonOffset(this.zOffset, this.zOffsetUnits);\n            }\n            else {\n                gl.disable(gl.POLYGON_OFFSET_FILL);\n            }\n            this._isZOffsetDirty = false;\n        }\n        // Front face\n        if (this._isFrontFaceDirty) {\n            gl.frontFace(this.frontFace);\n            this._isFrontFaceDirty = false;\n        }\n    }\n}\n//# sourceMappingURL=depthCullingState.js.map","\n/**\n * @internal\n **/\nexport class StencilState {\n    constructor() {\n        this.reset();\n    }\n    reset() {\n        this.enabled = false;\n        this.mask = 0xff;\n        this.func = StencilState.ALWAYS;\n        this.funcRef = 1;\n        this.funcMask = 0xff;\n        this.opStencilFail = StencilState.KEEP;\n        this.opDepthFail = StencilState.KEEP;\n        this.opStencilDepthPass = StencilState.REPLACE;\n    }\n    get stencilFunc() {\n        return this.func;\n    }\n    set stencilFunc(value) {\n        this.func = value;\n    }\n    get stencilFuncRef() {\n        return this.funcRef;\n    }\n    set stencilFuncRef(value) {\n        this.funcRef = value;\n    }\n    get stencilFuncMask() {\n        return this.funcMask;\n    }\n    set stencilFuncMask(value) {\n        this.funcMask = value;\n    }\n    get stencilOpStencilFail() {\n        return this.opStencilFail;\n    }\n    set stencilOpStencilFail(value) {\n        this.opStencilFail = value;\n    }\n    get stencilOpDepthFail() {\n        return this.opDepthFail;\n    }\n    set stencilOpDepthFail(value) {\n        this.opDepthFail = value;\n    }\n    get stencilOpStencilDepthPass() {\n        return this.opStencilDepthPass;\n    }\n    set stencilOpStencilDepthPass(value) {\n        this.opStencilDepthPass = value;\n    }\n    get stencilMask() {\n        return this.mask;\n    }\n    set stencilMask(value) {\n        this.mask = value;\n    }\n    get stencilTest() {\n        return this.enabled;\n    }\n    set stencilTest(value) {\n        this.enabled = value;\n    }\n}\n/** Passed to depthFunction or stencilFunction to specify depth or stencil tests will always pass. i.e. Pixels will be drawn in the order they are drawn */\nStencilState.ALWAYS = 519;\n/** Passed to stencilOperation to specify that stencil value must be kept */\nStencilState.KEEP = 7680;\n/** Passed to stencilOperation to specify that stencil value must be replaced */\nStencilState.REPLACE = 7681;\n//# sourceMappingURL=stencilState.js.map","/**\n * @internal\n **/\nexport class StencilStateComposer {\n    get isDirty() {\n        return this._isStencilTestDirty || this._isStencilMaskDirty || this._isStencilFuncDirty || this._isStencilOpDirty;\n    }\n    get func() {\n        return this._func;\n    }\n    set func(value) {\n        if (this._func === value) {\n            return;\n        }\n        this._func = value;\n        this._isStencilFuncDirty = true;\n    }\n    get funcRef() {\n        return this._funcRef;\n    }\n    set funcRef(value) {\n        if (this._funcRef === value) {\n            return;\n        }\n        this._funcRef = value;\n        this._isStencilFuncDirty = true;\n    }\n    get funcMask() {\n        return this._funcMask;\n    }\n    set funcMask(value) {\n        if (this._funcMask === value) {\n            return;\n        }\n        this._funcMask = value;\n        this._isStencilFuncDirty = true;\n    }\n    get opStencilFail() {\n        return this._opStencilFail;\n    }\n    set opStencilFail(value) {\n        if (this._opStencilFail === value) {\n            return;\n        }\n        this._opStencilFail = value;\n        this._isStencilOpDirty = true;\n    }\n    get opDepthFail() {\n        return this._opDepthFail;\n    }\n    set opDepthFail(value) {\n        if (this._opDepthFail === value) {\n            return;\n        }\n        this._opDepthFail = value;\n        this._isStencilOpDirty = true;\n    }\n    get opStencilDepthPass() {\n        return this._opStencilDepthPass;\n    }\n    set opStencilDepthPass(value) {\n        if (this._opStencilDepthPass === value) {\n            return;\n        }\n        this._opStencilDepthPass = value;\n        this._isStencilOpDirty = true;\n    }\n    get mask() {\n        return this._mask;\n    }\n    set mask(value) {\n        if (this._mask === value) {\n            return;\n        }\n        this._mask = value;\n        this._isStencilMaskDirty = true;\n    }\n    get enabled() {\n        return this._enabled;\n    }\n    set enabled(value) {\n        if (this._enabled === value) {\n            return;\n        }\n        this._enabled = value;\n        this._isStencilTestDirty = true;\n    }\n    constructor(reset = true) {\n        this._isStencilTestDirty = false;\n        this._isStencilMaskDirty = false;\n        this._isStencilFuncDirty = false;\n        this._isStencilOpDirty = false;\n        this.useStencilGlobalOnly = false;\n        if (reset) {\n            this.reset();\n        }\n    }\n    reset() {\n        var _a;\n        this.stencilMaterial = undefined;\n        (_a = this.stencilGlobal) === null || _a === void 0 ? void 0 : _a.reset();\n        this._isStencilTestDirty = true;\n        this._isStencilMaskDirty = true;\n        this._isStencilFuncDirty = true;\n        this._isStencilOpDirty = true;\n    }\n    apply(gl) {\n        var _a;\n        if (!gl) {\n            return;\n        }\n        const stencilMaterialEnabled = !this.useStencilGlobalOnly && !!((_a = this.stencilMaterial) === null || _a === void 0 ? void 0 : _a.enabled);\n        this.enabled = stencilMaterialEnabled ? this.stencilMaterial.enabled : this.stencilGlobal.enabled;\n        this.func = stencilMaterialEnabled ? this.stencilMaterial.func : this.stencilGlobal.func;\n        this.funcRef = stencilMaterialEnabled ? this.stencilMaterial.funcRef : this.stencilGlobal.funcRef;\n        this.funcMask = stencilMaterialEnabled ? this.stencilMaterial.funcMask : this.stencilGlobal.funcMask;\n        this.opStencilFail = stencilMaterialEnabled ? this.stencilMaterial.opStencilFail : this.stencilGlobal.opStencilFail;\n        this.opDepthFail = stencilMaterialEnabled ? this.stencilMaterial.opDepthFail : this.stencilGlobal.opDepthFail;\n        this.opStencilDepthPass = stencilMaterialEnabled ? this.stencilMaterial.opStencilDepthPass : this.stencilGlobal.opStencilDepthPass;\n        this.mask = stencilMaterialEnabled ? this.stencilMaterial.mask : this.stencilGlobal.mask;\n        if (!this.isDirty) {\n            return;\n        }\n        // Stencil test\n        if (this._isStencilTestDirty) {\n            if (this.enabled) {\n                gl.enable(gl.STENCIL_TEST);\n            }\n            else {\n                gl.disable(gl.STENCIL_TEST);\n            }\n            this._isStencilTestDirty = false;\n        }\n        // Stencil mask\n        if (this._isStencilMaskDirty) {\n            gl.stencilMask(this.mask);\n            this._isStencilMaskDirty = false;\n        }\n        // Stencil func\n        if (this._isStencilFuncDirty) {\n            gl.stencilFunc(this.func, this.funcRef, this.funcMask);\n            this._isStencilFuncDirty = false;\n        }\n        // Stencil op\n        if (this._isStencilOpDirty) {\n            gl.stencilOp(this.opStencilFail, this.opDepthFail, this.opStencilDepthPass);\n            this._isStencilOpDirty = false;\n        }\n    }\n}\n//# sourceMappingURL=stencilStateComposer.js.map","import { WebXRFeaturesManager, WebXRFeatureName } from \"../webXRFeaturesManager.js\";\nimport { Matrix, Vector3 } from \"../../Maths/math.vector.js\";\nimport { Color3 } from \"../../Maths/math.color.js\";\nimport { Axis } from \"../../Maths/math.axis.js\";\nimport { StandardMaterial } from \"../../Materials/standardMaterial.js\";\nimport { CreateCylinder } from \"../../Meshes/Builders/cylinderBuilder.js\";\nimport { CreateTorus } from \"../../Meshes/Builders/torusBuilder.js\";\nimport { Ray } from \"../../Culling/ray.js\";\nimport { PickingInfo } from \"../../Collisions/pickingInfo.js\";\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature.js\";\nimport { UtilityLayerRenderer } from \"../../Rendering/utilityLayerRenderer.js\";\nimport { Viewport } from \"../../Maths/math.viewport.js\";\nimport { Tools } from \"../../Misc/tools.js\";\n/**\n * A module that will enable pointer selection for motion controllers of XR Input Sources\n */\nexport class WebXRControllerPointerSelection extends WebXRAbstractFeature {\n    /**\n     * constructs a new background remover module\n     * @param _xrSessionManager the session manager for this module\n     * @param _options read-only options to be used in this module\n     */\n    constructor(_xrSessionManager, _options) {\n        super(_xrSessionManager);\n        this._options = _options;\n        this._attachController = (xrController) => {\n            if (this._controllers[xrController.uniqueId]) {\n                // already attached\n                return;\n            }\n            const { laserPointer, selectionMesh } = this._generateNewMeshPair(xrController.pointer);\n            // get two new meshes\n            this._controllers[xrController.uniqueId] = {\n                xrController,\n                laserPointer,\n                selectionMesh,\n                meshUnderPointer: null,\n                pick: null,\n                tmpRay: new Ray(new Vector3(), new Vector3()),\n                disabledByNearInteraction: false,\n                id: WebXRControllerPointerSelection._IdCounter++,\n            };\n            if (this._attachedController) {\n                if (!this._options.enablePointerSelectionOnAllControllers &&\n                    this._options.preferredHandedness &&\n                    xrController.inputSource.handedness === this._options.preferredHandedness) {\n                    this._attachedController = xrController.uniqueId;\n                }\n            }\n            else {\n                if (!this._options.enablePointerSelectionOnAllControllers) {\n                    this._attachedController = xrController.uniqueId;\n                }\n            }\n            switch (xrController.inputSource.targetRayMode) {\n                case \"tracked-pointer\":\n                    return this._attachTrackedPointerRayMode(xrController);\n                case \"gaze\":\n                    return this._attachGazeMode(xrController);\n                case \"screen\":\n                    return this._attachScreenRayMode(xrController);\n            }\n        };\n        this._controllers = {};\n        this._tmpVectorForPickCompare = new Vector3();\n        /**\n         * Disable lighting on the laser pointer (so it will always be visible)\n         */\n        this.disablePointerLighting = true;\n        /**\n         * Disable lighting on the selection mesh (so it will always be visible)\n         */\n        this.disableSelectionMeshLighting = true;\n        /**\n         * Should the laser pointer be displayed\n         */\n        this.displayLaserPointer = true;\n        /**\n         * Should the selection mesh be displayed (The ring at the end of the laser pointer)\n         */\n        this.displaySelectionMesh = true;\n        /**\n         * This color will be set to the laser pointer when selection is triggered\n         */\n        this.laserPointerPickedColor = new Color3(0.9, 0.9, 0.9);\n        /**\n         * Default color of the laser pointer\n         */\n        this.laserPointerDefaultColor = new Color3(0.7, 0.7, 0.7);\n        /**\n         * default color of the selection ring\n         */\n        this.selectionMeshDefaultColor = new Color3(0.8, 0.8, 0.8);\n        /**\n         * This color will be applied to the selection ring when selection is triggered\n         */\n        this.selectionMeshPickedColor = new Color3(0.3, 0.3, 1.0);\n        this._identityMatrix = Matrix.Identity();\n        this._screenCoordinatesRef = Vector3.Zero();\n        this._viewportRef = new Viewport(0, 0, 0, 0);\n        this._scene = this._xrSessionManager.scene;\n    }\n    /**\n     * attach this feature\n     * Will usually be called by the features manager\n     *\n     * @returns true if successful.\n     */\n    attach() {\n        if (!super.attach()) {\n            return false;\n        }\n        this._options.xrInput.controllers.forEach(this._attachController);\n        this._addNewAttachObserver(this._options.xrInput.onControllerAddedObservable, this._attachController);\n        this._addNewAttachObserver(this._options.xrInput.onControllerRemovedObservable, (controller) => {\n            // REMOVE the controller\n            this._detachController(controller.uniqueId);\n        });\n        this._scene.constantlyUpdateMeshUnderPointer = true;\n        if (this._options.gazeCamera) {\n            const webXRCamera = this._options.gazeCamera;\n            const { laserPointer, selectionMesh } = this._generateNewMeshPair(webXRCamera);\n            this._controllers[\"camera\"] = {\n                webXRCamera,\n                laserPointer,\n                selectionMesh,\n                meshUnderPointer: null,\n                pick: null,\n                tmpRay: new Ray(new Vector3(), new Vector3()),\n                disabledByNearInteraction: false,\n                id: WebXRControllerPointerSelection._IdCounter++,\n            };\n            this._attachGazeMode();\n        }\n        return true;\n    }\n    /**\n     * detach this feature.\n     * Will usually be called by the features manager\n     *\n     * @returns true if successful.\n     */\n    detach() {\n        if (!super.detach()) {\n            return false;\n        }\n        Object.keys(this._controllers).forEach((controllerId) => {\n            this._detachController(controllerId);\n        });\n        return true;\n    }\n    /**\n     * Will get the mesh under a specific pointer.\n     * `scene.meshUnderPointer` will only return one mesh - either left or right.\n     * @param controllerId the controllerId to check\n     * @returns The mesh under pointer or null if no mesh is under the pointer\n     */\n    getMeshUnderPointer(controllerId) {\n        if (this._controllers[controllerId]) {\n            return this._controllers[controllerId].meshUnderPointer;\n        }\n        else {\n            return null;\n        }\n    }\n    /**\n     * Get the xr controller that correlates to the pointer id in the pointer event\n     *\n     * @param id the pointer id to search for\n     * @returns the controller that correlates to this id or null if not found\n     */\n    getXRControllerByPointerId(id) {\n        const keys = Object.keys(this._controllers);\n        for (let i = 0; i < keys.length; ++i) {\n            if (this._controllers[keys[i]].id === id) {\n                return this._controllers[keys[i]].xrController || null;\n            }\n        }\n        return null;\n    }\n    /**\n     * @internal\n     */\n    _getPointerSelectionDisabledByPointerId(id) {\n        const keys = Object.keys(this._controllers);\n        for (let i = 0; i < keys.length; ++i) {\n            if (this._controllers[keys[i]].id === id) {\n                return this._controllers[keys[i]].disabledByNearInteraction;\n            }\n        }\n        return true;\n    }\n    /**\n     * @internal\n     */\n    _setPointerSelectionDisabledByPointerId(id, state) {\n        const keys = Object.keys(this._controllers);\n        for (let i = 0; i < keys.length; ++i) {\n            if (this._controllers[keys[i]].id === id) {\n                this._controllers[keys[i]].disabledByNearInteraction = state;\n                return;\n            }\n        }\n    }\n    _onXRFrame(_xrFrame) {\n        Object.keys(this._controllers).forEach((id) => {\n            // only do this for the selected pointer\n            const controllerData = this._controllers[id];\n            if ((!this._options.enablePointerSelectionOnAllControllers && id !== this._attachedController) || controllerData.disabledByNearInteraction) {\n                controllerData.selectionMesh.isVisible = false;\n                controllerData.laserPointer.isVisible = false;\n                controllerData.pick = null;\n                return;\n            }\n            controllerData.laserPointer.isVisible = this.displayLaserPointer;\n            let controllerGlobalPosition;\n            // Every frame check collisions/input\n            if (controllerData.xrController) {\n                controllerGlobalPosition = controllerData.xrController.pointer.position;\n                controllerData.xrController.getWorldPointerRayToRef(controllerData.tmpRay);\n            }\n            else if (controllerData.webXRCamera) {\n                controllerGlobalPosition = controllerData.webXRCamera.position;\n                controllerData.webXRCamera.getForwardRayToRef(controllerData.tmpRay);\n            }\n            else {\n                return;\n            }\n            if (this._options.maxPointerDistance) {\n                controllerData.tmpRay.length = this._options.maxPointerDistance;\n            }\n            // update pointerX and pointerY of the scene. Only if the flag is set to true!\n            if (!this._options.disableScenePointerVectorUpdate && controllerGlobalPosition) {\n                const scene = this._xrSessionManager.scene;\n                const camera = this._options.xrInput.xrCamera;\n                if (camera) {\n                    camera.viewport.toGlobalToRef(scene.getEngine().getRenderWidth(), scene.getEngine().getRenderHeight(), this._viewportRef);\n                    Vector3.ProjectToRef(controllerGlobalPosition, this._identityMatrix, scene.getTransformMatrix(), this._viewportRef, this._screenCoordinatesRef);\n                    // stay safe\n                    if (typeof this._screenCoordinatesRef.x === \"number\" &&\n                        typeof this._screenCoordinatesRef.y === \"number\" &&\n                        !isNaN(this._screenCoordinatesRef.x) &&\n                        !isNaN(this._screenCoordinatesRef.y)) {\n                        scene.pointerX = this._screenCoordinatesRef.x;\n                        scene.pointerY = this._screenCoordinatesRef.y;\n                        controllerData.screenCoordinates = {\n                            x: this._screenCoordinatesRef.x,\n                            y: this._screenCoordinatesRef.y,\n                        };\n                    }\n                }\n            }\n            let utilityScenePick = null;\n            if (this._utilityLayerScene) {\n                utilityScenePick = this._utilityLayerScene.pickWithRay(controllerData.tmpRay, this._utilityLayerScene.pointerMovePredicate || this.raySelectionPredicate);\n            }\n            const originalScenePick = this._scene.pickWithRay(controllerData.tmpRay, this._scene.pointerMovePredicate || this.raySelectionPredicate);\n            if (!utilityScenePick || !utilityScenePick.hit) {\n                // No hit in utility scene\n                controllerData.pick = originalScenePick;\n            }\n            else if (!originalScenePick || !originalScenePick.hit) {\n                // No hit in original scene\n                controllerData.pick = utilityScenePick;\n            }\n            else if (utilityScenePick.distance < originalScenePick.distance) {\n                // Hit is closer in utility scene\n                controllerData.pick = utilityScenePick;\n            }\n            else {\n                // Hit is closer in original scene\n                controllerData.pick = originalScenePick;\n            }\n            if (controllerData.pick && controllerData.xrController) {\n                controllerData.pick.aimTransform = controllerData.xrController.pointer;\n                controllerData.pick.gripTransform = controllerData.xrController.grip || null;\n            }\n            const pick = controllerData.pick;\n            if (pick && pick.pickedPoint && pick.hit) {\n                // Update laser state\n                this._updatePointerDistance(controllerData.laserPointer, pick.distance);\n                // Update cursor state\n                controllerData.selectionMesh.position.copyFrom(pick.pickedPoint);\n                controllerData.selectionMesh.scaling.x = Math.sqrt(pick.distance);\n                controllerData.selectionMesh.scaling.y = Math.sqrt(pick.distance);\n                controllerData.selectionMesh.scaling.z = Math.sqrt(pick.distance);\n                // To avoid z-fighting\n                const pickNormal = this._convertNormalToDirectionOfRay(pick.getNormal(true), controllerData.tmpRay);\n                const deltaFighting = 0.001;\n                controllerData.selectionMesh.position.copyFrom(pick.pickedPoint);\n                if (pickNormal) {\n                    const axis1 = Vector3.Cross(Axis.Y, pickNormal);\n                    const axis2 = Vector3.Cross(pickNormal, axis1);\n                    Vector3.RotationFromAxisToRef(axis2, pickNormal, axis1, controllerData.selectionMesh.rotation);\n                    controllerData.selectionMesh.position.addInPlace(pickNormal.scale(deltaFighting));\n                }\n                controllerData.selectionMesh.isVisible = true && this.displaySelectionMesh;\n                controllerData.meshUnderPointer = pick.pickedMesh;\n            }\n            else {\n                controllerData.selectionMesh.isVisible = false;\n                this._updatePointerDistance(controllerData.laserPointer, 1);\n                controllerData.meshUnderPointer = null;\n            }\n        });\n    }\n    get _utilityLayerScene() {\n        return this._options.customUtilityLayerScene || UtilityLayerRenderer.DefaultUtilityLayer.utilityLayerScene;\n    }\n    _attachGazeMode(xrController) {\n        const controllerData = this._controllers[(xrController && xrController.uniqueId) || \"camera\"];\n        // attached when touched, detaches when raised\n        const timeToSelect = this._options.timeToSelect || 3000;\n        const sceneToRenderTo = this._options.useUtilityLayer ? this._utilityLayerScene : this._scene;\n        let oldPick = new PickingInfo();\n        const discMesh = CreateTorus(\"selection\", {\n            diameter: 0.0035 * 15,\n            thickness: 0.0025 * 6,\n            tessellation: 20,\n        }, sceneToRenderTo);\n        discMesh.isVisible = false;\n        discMesh.isPickable = false;\n        discMesh.parent = controllerData.selectionMesh;\n        let timer = 0;\n        let downTriggered = false;\n        const pointerEventInit = {\n            pointerId: controllerData.id,\n            pointerType: \"xr\",\n        };\n        controllerData.onFrameObserver = this._xrSessionManager.onXRFrameObservable.add(() => {\n            if (!controllerData.pick) {\n                return;\n            }\n            this._augmentPointerInit(pointerEventInit, controllerData.id, controllerData.screenCoordinates);\n            controllerData.laserPointer.material.alpha = 0;\n            discMesh.isVisible = false;\n            if (controllerData.pick.hit) {\n                if (!this._pickingMoved(oldPick, controllerData.pick)) {\n                    if (timer > timeToSelect / 10) {\n                        discMesh.isVisible = true;\n                    }\n                    timer += this._scene.getEngine().getDeltaTime();\n                    if (timer >= timeToSelect) {\n                        this._scene.simulatePointerDown(controllerData.pick, pointerEventInit);\n                        // this pointerdown event is not setting the controllerData.pointerDownTriggered to avoid a pointerUp event when this feature is detached\n                        downTriggered = true;\n                        // pointer up right after down, if disable on touch out\n                        if (this._options.disablePointerUpOnTouchOut) {\n                            this._scene.simulatePointerUp(controllerData.pick, pointerEventInit);\n                        }\n                        discMesh.isVisible = false;\n                    }\n                    else {\n                        const scaleFactor = 1 - timer / timeToSelect;\n                        discMesh.scaling.set(scaleFactor, scaleFactor, scaleFactor);\n                    }\n                }\n                else {\n                    if (downTriggered) {\n                        if (!this._options.disablePointerUpOnTouchOut) {\n                            this._scene.simulatePointerUp(controllerData.pick, pointerEventInit);\n                        }\n                    }\n                    downTriggered = false;\n                    timer = 0;\n                }\n            }\n            else {\n                downTriggered = false;\n                timer = 0;\n            }\n            this._scene.simulatePointerMove(controllerData.pick, pointerEventInit);\n            oldPick = controllerData.pick;\n        });\n        if (this._options.renderingGroupId !== undefined) {\n            discMesh.renderingGroupId = this._options.renderingGroupId;\n        }\n        if (xrController) {\n            xrController.onDisposeObservable.addOnce(() => {\n                if (controllerData.pick && !this._options.disablePointerUpOnTouchOut && downTriggered) {\n                    this._scene.simulatePointerUp(controllerData.pick, pointerEventInit);\n                    controllerData.finalPointerUpTriggered = true;\n                }\n                discMesh.dispose();\n            });\n        }\n    }\n    _attachScreenRayMode(xrController) {\n        const controllerData = this._controllers[xrController.uniqueId];\n        let downTriggered = false;\n        const pointerEventInit = {\n            pointerId: controllerData.id,\n            pointerType: \"xr\",\n        };\n        controllerData.onFrameObserver = this._xrSessionManager.onXRFrameObservable.add(() => {\n            this._augmentPointerInit(pointerEventInit, controllerData.id, controllerData.screenCoordinates);\n            if (!controllerData.pick || (this._options.disablePointerUpOnTouchOut && downTriggered)) {\n                return;\n            }\n            if (!downTriggered) {\n                this._scene.simulatePointerDown(controllerData.pick, pointerEventInit);\n                controllerData.pointerDownTriggered = true;\n                downTriggered = true;\n                if (this._options.disablePointerUpOnTouchOut) {\n                    this._scene.simulatePointerUp(controllerData.pick, pointerEventInit);\n                }\n            }\n            else {\n                this._scene.simulatePointerMove(controllerData.pick, pointerEventInit);\n            }\n        });\n        xrController.onDisposeObservable.addOnce(() => {\n            this._augmentPointerInit(pointerEventInit, controllerData.id, controllerData.screenCoordinates);\n            this._xrSessionManager.runInXRFrame(() => {\n                if (controllerData.pick && !controllerData.finalPointerUpTriggered && downTriggered && !this._options.disablePointerUpOnTouchOut) {\n                    this._scene.simulatePointerUp(controllerData.pick, pointerEventInit);\n                    controllerData.finalPointerUpTriggered = true;\n                }\n            });\n        });\n    }\n    _attachTrackedPointerRayMode(xrController) {\n        const controllerData = this._controllers[xrController.uniqueId];\n        if (this._options.forceGazeMode) {\n            return this._attachGazeMode(xrController);\n        }\n        const pointerEventInit = {\n            pointerId: controllerData.id,\n            pointerType: \"xr\",\n        };\n        controllerData.onFrameObserver = this._xrSessionManager.onXRFrameObservable.add(() => {\n            controllerData.laserPointer.material.disableLighting = this.disablePointerLighting;\n            controllerData.selectionMesh.material.disableLighting = this.disableSelectionMeshLighting;\n            if (controllerData.pick) {\n                this._augmentPointerInit(pointerEventInit, controllerData.id, controllerData.screenCoordinates);\n                this._scene.simulatePointerMove(controllerData.pick, pointerEventInit);\n            }\n        });\n        if (xrController.inputSource.gamepad) {\n            const init = (motionController) => {\n                if (this._options.overrideButtonId) {\n                    controllerData.selectionComponent = motionController.getComponent(this._options.overrideButtonId);\n                }\n                if (!controllerData.selectionComponent) {\n                    controllerData.selectionComponent = motionController.getMainComponent();\n                }\n                controllerData.onButtonChangedObserver = controllerData.selectionComponent.onButtonStateChangedObservable.add((component) => {\n                    if (component.changes.pressed) {\n                        const pressed = component.changes.pressed.current;\n                        if (controllerData.pick) {\n                            if (this._options.enablePointerSelectionOnAllControllers || xrController.uniqueId === this._attachedController) {\n                                this._augmentPointerInit(pointerEventInit, controllerData.id, controllerData.screenCoordinates);\n                                if (pressed) {\n                                    this._scene.simulatePointerDown(controllerData.pick, pointerEventInit);\n                                    controllerData.pointerDownTriggered = true;\n                                    controllerData.selectionMesh.material.emissiveColor = this.selectionMeshPickedColor;\n                                    controllerData.laserPointer.material.emissiveColor = this.laserPointerPickedColor;\n                                }\n                                else {\n                                    this._scene.simulatePointerUp(controllerData.pick, pointerEventInit);\n                                    controllerData.selectionMesh.material.emissiveColor = this.selectionMeshDefaultColor;\n                                    controllerData.laserPointer.material.emissiveColor = this.laserPointerDefaultColor;\n                                }\n                            }\n                        }\n                        else {\n                            if (pressed && !this._options.enablePointerSelectionOnAllControllers && !this._options.disableSwitchOnClick) {\n                                this._attachedController = xrController.uniqueId;\n                            }\n                        }\n                    }\n                });\n            };\n            if (xrController.motionController) {\n                init(xrController.motionController);\n            }\n            else {\n                xrController.onMotionControllerInitObservable.add(init);\n            }\n        }\n        else {\n            // use the select and squeeze events\n            const selectStartListener = (event) => {\n                this._augmentPointerInit(pointerEventInit, controllerData.id, controllerData.screenCoordinates);\n                if (controllerData.xrController && event.inputSource === controllerData.xrController.inputSource && controllerData.pick) {\n                    this._scene.simulatePointerDown(controllerData.pick, pointerEventInit);\n                    controllerData.pointerDownTriggered = true;\n                    controllerData.selectionMesh.material.emissiveColor = this.selectionMeshPickedColor;\n                    controllerData.laserPointer.material.emissiveColor = this.laserPointerPickedColor;\n                }\n            };\n            const selectEndListener = (event) => {\n                this._augmentPointerInit(pointerEventInit, controllerData.id, controllerData.screenCoordinates);\n                if (controllerData.xrController && event.inputSource === controllerData.xrController.inputSource && controllerData.pick) {\n                    this._scene.simulatePointerUp(controllerData.pick, pointerEventInit);\n                    controllerData.selectionMesh.material.emissiveColor = this.selectionMeshDefaultColor;\n                    controllerData.laserPointer.material.emissiveColor = this.laserPointerDefaultColor;\n                }\n            };\n            controllerData.eventListeners = {\n                selectend: selectEndListener,\n                selectstart: selectStartListener,\n            };\n            this._xrSessionManager.session.addEventListener(\"selectstart\", selectStartListener);\n            this._xrSessionManager.session.addEventListener(\"selectend\", selectEndListener);\n        }\n    }\n    _convertNormalToDirectionOfRay(normal, ray) {\n        if (normal) {\n            const angle = Math.acos(Vector3.Dot(normal, ray.direction));\n            if (angle < Math.PI / 2) {\n                normal.scaleInPlace(-1);\n            }\n        }\n        return normal;\n    }\n    _detachController(xrControllerUniqueId) {\n        const controllerData = this._controllers[xrControllerUniqueId];\n        if (!controllerData) {\n            return;\n        }\n        if (controllerData.selectionComponent) {\n            if (controllerData.onButtonChangedObserver) {\n                controllerData.selectionComponent.onButtonStateChangedObservable.remove(controllerData.onButtonChangedObserver);\n            }\n        }\n        if (controllerData.onFrameObserver) {\n            this._xrSessionManager.onXRFrameObservable.remove(controllerData.onFrameObserver);\n        }\n        if (controllerData.eventListeners) {\n            Object.keys(controllerData.eventListeners).forEach((eventName) => {\n                const func = controllerData.eventListeners && controllerData.eventListeners[eventName];\n                if (func) {\n                    // For future reference - this is an issue in the WebXR typings.\n                    this._xrSessionManager.session.removeEventListener(eventName, func);\n                }\n            });\n        }\n        if (!controllerData.finalPointerUpTriggered && controllerData.pointerDownTriggered) {\n            // Stay safe and fire a pointerup, in case it wasn't already triggered\n            const pointerEventInit = {\n                pointerId: controllerData.id,\n                pointerType: \"xr\",\n            };\n            this._xrSessionManager.runInXRFrame(() => {\n                this._augmentPointerInit(pointerEventInit, controllerData.id, controllerData.screenCoordinates);\n                this._scene.simulatePointerUp(controllerData.pick || new PickingInfo(), pointerEventInit);\n                controllerData.finalPointerUpTriggered = true;\n            });\n        }\n        this._xrSessionManager.scene.onBeforeRenderObservable.addOnce(() => {\n            try {\n                controllerData.selectionMesh.dispose();\n                controllerData.laserPointer.dispose();\n                // remove from the map\n                delete this._controllers[xrControllerUniqueId];\n                if (this._attachedController === xrControllerUniqueId) {\n                    // check for other controllers\n                    const keys = Object.keys(this._controllers);\n                    if (keys.length) {\n                        this._attachedController = keys[0];\n                    }\n                    else {\n                        this._attachedController = \"\";\n                    }\n                }\n            }\n            catch (e) {\n                Tools.Warn(\"controller already detached.\");\n            }\n        });\n    }\n    _generateNewMeshPair(meshParent) {\n        const sceneToRenderTo = this._options.useUtilityLayer ? this._options.customUtilityLayerScene || UtilityLayerRenderer.DefaultUtilityLayer.utilityLayerScene : this._scene;\n        const laserPointer = this._options.customLasterPointerMeshGenerator\n            ? this._options.customLasterPointerMeshGenerator()\n            : CreateCylinder(\"laserPointer\", {\n                height: 1,\n                diameterTop: 0.0002,\n                diameterBottom: 0.004,\n                tessellation: 20,\n                subdivisions: 1,\n            }, sceneToRenderTo);\n        laserPointer.parent = meshParent;\n        const laserPointerMaterial = new StandardMaterial(\"laserPointerMat\", sceneToRenderTo);\n        laserPointerMaterial.emissiveColor = this.laserPointerDefaultColor;\n        laserPointerMaterial.alpha = 0.7;\n        laserPointer.material = laserPointerMaterial;\n        laserPointer.rotation.x = Math.PI / 2;\n        this._updatePointerDistance(laserPointer, 1);\n        laserPointer.isPickable = false;\n        laserPointer.isVisible = false;\n        // Create a gaze tracker for the  XR controller\n        const selectionMesh = this._options.customSelectionMeshGenerator\n            ? this._options.customSelectionMeshGenerator()\n            : CreateTorus(\"gazeTracker\", {\n                diameter: 0.0035 * 3,\n                thickness: 0.0025 * 3,\n                tessellation: 20,\n            }, sceneToRenderTo);\n        selectionMesh.bakeCurrentTransformIntoVertices();\n        selectionMesh.isPickable = false;\n        selectionMesh.isVisible = false;\n        const targetMat = new StandardMaterial(\"targetMat\", sceneToRenderTo);\n        targetMat.specularColor = Color3.Black();\n        targetMat.emissiveColor = this.selectionMeshDefaultColor;\n        targetMat.backFaceCulling = false;\n        selectionMesh.material = targetMat;\n        if (this._options.renderingGroupId !== undefined) {\n            laserPointer.renderingGroupId = this._options.renderingGroupId;\n            selectionMesh.renderingGroupId = this._options.renderingGroupId;\n        }\n        return {\n            laserPointer,\n            selectionMesh,\n        };\n    }\n    _pickingMoved(oldPick, newPick) {\n        var _a;\n        if (!oldPick.hit || !newPick.hit) {\n            return true;\n        }\n        if (!oldPick.pickedMesh || !oldPick.pickedPoint || !newPick.pickedMesh || !newPick.pickedPoint) {\n            return true;\n        }\n        if (oldPick.pickedMesh !== newPick.pickedMesh) {\n            return true;\n        }\n        (_a = oldPick.pickedPoint) === null || _a === void 0 ? void 0 : _a.subtractToRef(newPick.pickedPoint, this._tmpVectorForPickCompare);\n        this._tmpVectorForPickCompare.set(Math.abs(this._tmpVectorForPickCompare.x), Math.abs(this._tmpVectorForPickCompare.y), Math.abs(this._tmpVectorForPickCompare.z));\n        const delta = (this._options.gazeModePointerMovedFactor || 1) * 0.01 * newPick.distance;\n        const length = this._tmpVectorForPickCompare.length();\n        if (length > delta) {\n            return true;\n        }\n        return false;\n    }\n    _updatePointerDistance(_laserPointer, distance = 100) {\n        _laserPointer.scaling.y = distance;\n        // a bit of distance from the controller\n        if (this._scene.useRightHandedSystem) {\n            distance *= -1;\n        }\n        _laserPointer.position.z = distance / 2 + 0.05;\n    }\n    _augmentPointerInit(pointerEventInit, id, screenCoordinates) {\n        pointerEventInit.pointerId = id;\n        pointerEventInit.pointerType = \"xr\";\n        if (screenCoordinates) {\n            pointerEventInit.screenX = screenCoordinates.x;\n            pointerEventInit.screenY = screenCoordinates.y;\n        }\n    }\n    /** @internal */\n    get lasterPointerDefaultColor() {\n        // here due to a typo\n        return this.laserPointerDefaultColor;\n    }\n}\nWebXRControllerPointerSelection._IdCounter = 200;\n/**\n * The module's name\n */\nWebXRControllerPointerSelection.Name = WebXRFeatureName.POINTER_SELECTION;\n/**\n * The (Babylon) version of this module.\n * This is an integer representing the implementation version.\n * This number does not correspond to the WebXR specs version\n */\nWebXRControllerPointerSelection.Version = 1;\n//register the plugin\nWebXRFeaturesManager.AddWebXRFeature(WebXRControllerPointerSelection.Name, (xrSessionManager, options) => {\n    return () => new WebXRControllerPointerSelection(xrSessionManager, options);\n}, WebXRControllerPointerSelection.Version, true);\n//# sourceMappingURL=WebXRControllerPointerSelection.js.map","import { WebXRFeaturesManager, WebXRFeatureName } from \"../webXRFeaturesManager.js\";\nimport { Observable } from \"../../Misc/observable.js\";\nimport { WebXRControllerComponent } from \"../motionController/webXRControllerComponent.js\";\nimport { Vector3, Quaternion } from \"../../Maths/math.vector.js\";\nimport { Ray } from \"../../Culling/ray.js\";\nimport { DynamicTexture } from \"../../Materials/Textures/dynamicTexture.js\";\nimport { CreateCylinder } from \"../../Meshes/Builders/cylinderBuilder.js\";\nimport { SineEase, EasingFunction } from \"../../Animations/easing.js\";\nimport { Animation } from \"../../Animations/animation.js\";\nimport { Axis } from \"../../Maths/math.axis.js\";\nimport { StandardMaterial } from \"../../Materials/standardMaterial.js\";\nimport { CreateGround } from \"../../Meshes/Builders/groundBuilder.js\";\nimport { CreateTorus } from \"../../Meshes/Builders/torusBuilder.js\";\nimport { Curve3 } from \"../../Maths/math.path.js\";\nimport { CreateLines } from \"../../Meshes/Builders/linesBuilder.js\";\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature.js\";\nimport { Color3 } from \"../../Maths/math.color.js\";\nimport { UtilityLayerRenderer } from \"../../Rendering/utilityLayerRenderer.js\";\nimport { PointerEventTypes } from \"../../Events/pointerEvents.js\";\nimport { setAndStartTimer } from \"../../Misc/timer.js\";\n/**\n * This is a teleportation feature to be used with WebXR-enabled motion controllers.\n * When enabled and attached, the feature will allow a user to move around and rotate in the scene using\n * the input of the attached controllers.\n */\nexport class WebXRMotionControllerTeleportation extends WebXRAbstractFeature {\n    /**\n     * Is rotation enabled when moving forward?\n     * Disabling this feature will prevent the user from deciding the direction when teleporting\n     */\n    get rotationEnabled() {\n        return this._rotationEnabled;\n    }\n    /**\n     * Sets whether rotation is enabled or not\n     * @param enabled is rotation enabled when teleportation is shown\n     */\n    set rotationEnabled(enabled) {\n        this._rotationEnabled = enabled;\n        if (this._options.teleportationTargetMesh) {\n            const children = this._options.teleportationTargetMesh.getChildMeshes(false, (node) => node.name === \"rotationCone\");\n            if (children[0]) {\n                children[0].setEnabled(enabled);\n            }\n        }\n    }\n    /**\n     * Exposes the currently set teleportation target mesh.\n     */\n    get teleportationTargetMesh() {\n        return this._options.teleportationTargetMesh || null;\n    }\n    /**\n     * constructs a new teleportation system\n     * @param _xrSessionManager an instance of WebXRSessionManager\n     * @param _options configuration object for this feature\n     */\n    constructor(_xrSessionManager, _options) {\n        super(_xrSessionManager);\n        this._options = _options;\n        this._controllers = {};\n        this._snappedToPoint = false;\n        this._tmpRay = new Ray(new Vector3(), new Vector3());\n        this._tmpVector = new Vector3();\n        this._tmpQuaternion = new Quaternion();\n        /**\n         * Skip the next teleportation. This can be controlled by the user to prevent the user from teleportation\n         * to sections that are not yet \"unlocked\", but should still show the teleportation mesh.\n         */\n        this.skipNextTeleportation = false;\n        /**\n         * Is movement backwards enabled\n         */\n        this.backwardsMovementEnabled = true;\n        /**\n         * Distance to travel when moving backwards\n         */\n        this.backwardsTeleportationDistance = 0.7;\n        /**\n         * The distance from the user to the inspection point in the direction of the controller\n         * A higher number will allow the user to move further\n         * defaults to 5 (meters, in xr units)\n         */\n        this.parabolicCheckRadius = 5;\n        /**\n         * Should the module support parabolic ray on top of direct ray\n         * If enabled, the user will be able to point \"at the sky\" and move according to predefined radius distance\n         * Very helpful when moving between floors / different heights\n         */\n        this.parabolicRayEnabled = true;\n        /**\n         * The second type of ray - straight line.\n         * Should it be enabled or should the parabolic line be the only one.\n         */\n        this.straightRayEnabled = true;\n        /**\n         * How much rotation should be applied when rotating right and left\n         */\n        this.rotationAngle = Math.PI / 8;\n        /**\n         * This observable will notify when the target mesh position was updated.\n         * The picking info it provides contains the point to which the target mesh will move ()\n         */\n        this.onTargetMeshPositionUpdatedObservable = new Observable();\n        /**\n         * Is teleportation enabled. Can be used to allow rotation only.\n         */\n        this.teleportationEnabled = true;\n        this._rotationEnabled = true;\n        this._attachController = (xrController) => {\n            if (this._controllers[xrController.uniqueId] || (this._options.forceHandedness && xrController.inputSource.handedness !== this._options.forceHandedness)) {\n                // already attached\n                return;\n            }\n            this._controllers[xrController.uniqueId] = {\n                xrController,\n                teleportationState: {\n                    forward: false,\n                    backwards: false,\n                    rotating: false,\n                    currentRotation: 0,\n                    baseRotation: 0,\n                },\n            };\n            const controllerData = this._controllers[xrController.uniqueId];\n            // motion controller only available to gamepad-enabled input sources.\n            if (controllerData.xrController.inputSource.targetRayMode === \"tracked-pointer\" && controllerData.xrController.inputSource.gamepad) {\n                // motion controller support\n                const initMotionController = () => {\n                    if (xrController.motionController) {\n                        const movementController = xrController.motionController.getComponentOfType(WebXRControllerComponent.THUMBSTICK_TYPE) ||\n                            xrController.motionController.getComponentOfType(WebXRControllerComponent.TOUCHPAD_TYPE);\n                        if (!movementController || this._options.useMainComponentOnly) {\n                            // use trigger to move on long press\n                            const mainComponent = xrController.motionController.getMainComponent();\n                            if (!mainComponent) {\n                                return;\n                            }\n                            controllerData.teleportationComponent = mainComponent;\n                            controllerData.onButtonChangedObserver = mainComponent.onButtonStateChangedObservable.add(() => {\n                                if (!this.teleportationEnabled) {\n                                    return;\n                                }\n                                // did \"pressed\" changed?\n                                if (mainComponent.changes.pressed) {\n                                    if (mainComponent.changes.pressed.current) {\n                                        // simulate \"forward\" thumbstick push\n                                        controllerData.teleportationState.forward = true;\n                                        this._currentTeleportationControllerId = controllerData.xrController.uniqueId;\n                                        controllerData.teleportationState.baseRotation = this._options.xrInput.xrCamera.rotationQuaternion.toEulerAngles().y;\n                                        controllerData.teleportationState.currentRotation = 0;\n                                        const timeToSelect = this._options.timeToTeleport || 3000;\n                                        setAndStartTimer({\n                                            timeout: timeToSelect,\n                                            contextObservable: this._xrSessionManager.onXRFrameObservable,\n                                            breakCondition: () => !mainComponent.pressed,\n                                            onEnded: () => {\n                                                if (this._currentTeleportationControllerId === controllerData.xrController.uniqueId && controllerData.teleportationState.forward) {\n                                                    this._teleportForward(xrController.uniqueId);\n                                                }\n                                            },\n                                        });\n                                    }\n                                    else {\n                                        controllerData.teleportationState.forward = false;\n                                        this._currentTeleportationControllerId = \"\";\n                                    }\n                                }\n                            });\n                        }\n                        else {\n                            controllerData.teleportationComponent = movementController;\n                            // use thumbstick (or touchpad if thumbstick not available)\n                            controllerData.onAxisChangedObserver = movementController.onAxisValueChangedObservable.add((axesData) => {\n                                if (axesData.y <= 0.7 && controllerData.teleportationState.backwards) {\n                                    controllerData.teleportationState.backwards = false;\n                                }\n                                if (axesData.y > 0.7 && !controllerData.teleportationState.forward && this.backwardsMovementEnabled && !this.snapPointsOnly) {\n                                    // teleport backwards\n                                    // General gist: Go Back N units, cast a ray towards the floor. If collided, move.\n                                    if (!controllerData.teleportationState.backwards) {\n                                        controllerData.teleportationState.backwards = true;\n                                        // teleport backwards ONCE\n                                        this._tmpQuaternion.copyFrom(this._options.xrInput.xrCamera.rotationQuaternion);\n                                        this._tmpQuaternion.toEulerAnglesToRef(this._tmpVector);\n                                        // get only the y rotation\n                                        this._tmpVector.x = 0;\n                                        this._tmpVector.z = 0;\n                                        // get the quaternion\n                                        Quaternion.FromEulerVectorToRef(this._tmpVector, this._tmpQuaternion);\n                                        this._tmpVector.set(0, 0, this.backwardsTeleportationDistance * (this._xrSessionManager.scene.useRightHandedSystem ? 1.0 : -1.0));\n                                        this._tmpVector.rotateByQuaternionToRef(this._tmpQuaternion, this._tmpVector);\n                                        this._tmpVector.addInPlace(this._options.xrInput.xrCamera.position);\n                                        this._tmpRay.origin.copyFrom(this._tmpVector);\n                                        // This will prevent the user from \"falling\" to a lower platform!\n                                        // TODO - should this be a flag? 'allow falling to lower platforms'?\n                                        this._tmpRay.length = this._options.xrInput.xrCamera.realWorldHeight + 0.1;\n                                        // Right handed system had here \"1\" instead of -1. This is unneeded.\n                                        this._tmpRay.direction.set(0, -1, 0);\n                                        const pick = this._xrSessionManager.scene.pickWithRay(this._tmpRay, (o) => {\n                                            return this._floorMeshes.indexOf(o) !== -1;\n                                        });\n                                        // pick must exist, but stay safe\n                                        if (pick && pick.pickedPoint) {\n                                            // Teleport the users feet to where they targeted. Ignore the Y axis.\n                                            // If the \"falling to lower platforms\" feature is implemented the Y axis should be set here as well\n                                            this._options.xrInput.xrCamera.position.x = pick.pickedPoint.x;\n                                            this._options.xrInput.xrCamera.position.z = pick.pickedPoint.z;\n                                        }\n                                    }\n                                }\n                                if (axesData.y < -0.7 && !this._currentTeleportationControllerId && !controllerData.teleportationState.rotating && this.teleportationEnabled) {\n                                    controllerData.teleportationState.forward = true;\n                                    this._currentTeleportationControllerId = controllerData.xrController.uniqueId;\n                                    controllerData.teleportationState.baseRotation = this._options.xrInput.xrCamera.rotationQuaternion.toEulerAngles().y;\n                                }\n                                if (axesData.x) {\n                                    if (!controllerData.teleportationState.forward) {\n                                        if (!controllerData.teleportationState.rotating && Math.abs(axesData.x) > 0.7) {\n                                            // rotate in the right direction positive is right\n                                            controllerData.teleportationState.rotating = true;\n                                            const rotation = this.rotationAngle * (axesData.x > 0 ? 1 : -1) * (this._xrSessionManager.scene.useRightHandedSystem ? -1 : 1);\n                                            Quaternion.FromEulerAngles(0, rotation, 0).multiplyToRef(this._options.xrInput.xrCamera.rotationQuaternion, this._options.xrInput.xrCamera.rotationQuaternion);\n                                        }\n                                    }\n                                    else {\n                                        if (this._currentTeleportationControllerId === controllerData.xrController.uniqueId) {\n                                            // set the rotation of the forward movement\n                                            if (this.rotationEnabled) {\n                                                setTimeout(() => {\n                                                    controllerData.teleportationState.currentRotation = Math.atan2(axesData.x, axesData.y * (this._xrSessionManager.scene.useRightHandedSystem ? 1 : -1));\n                                                });\n                                            }\n                                            else {\n                                                controllerData.teleportationState.currentRotation = 0;\n                                            }\n                                        }\n                                    }\n                                }\n                                else {\n                                    controllerData.teleportationState.rotating = false;\n                                }\n                                if (axesData.x === 0 && axesData.y === 0) {\n                                    if (controllerData.teleportationState.forward) {\n                                        this._teleportForward(xrController.uniqueId);\n                                    }\n                                }\n                            });\n                        }\n                    }\n                };\n                if (xrController.motionController) {\n                    initMotionController();\n                }\n                else {\n                    xrController.onMotionControllerInitObservable.addOnce(() => {\n                        initMotionController();\n                    });\n                }\n            }\n            else {\n                this._xrSessionManager.scene.onPointerObservable.add((pointerInfo) => {\n                    if (pointerInfo.type === PointerEventTypes.POINTERDOWN) {\n                        controllerData.teleportationState.forward = true;\n                        this._currentTeleportationControllerId = controllerData.xrController.uniqueId;\n                        controllerData.teleportationState.baseRotation = this._options.xrInput.xrCamera.rotationQuaternion.toEulerAngles().y;\n                        controllerData.teleportationState.currentRotation = 0;\n                        const timeToSelect = this._options.timeToTeleport || 3000;\n                        setAndStartTimer({\n                            timeout: timeToSelect,\n                            contextObservable: this._xrSessionManager.onXRFrameObservable,\n                            onEnded: () => {\n                                if (this._currentTeleportationControllerId === controllerData.xrController.uniqueId && controllerData.teleportationState.forward) {\n                                    this._teleportForward(xrController.uniqueId);\n                                }\n                            },\n                        });\n                    }\n                    else if (pointerInfo.type === PointerEventTypes.POINTERUP) {\n                        controllerData.teleportationState.forward = false;\n                        this._currentTeleportationControllerId = \"\";\n                    }\n                });\n            }\n        };\n        // create default mesh if not provided\n        if (!this._options.teleportationTargetMesh) {\n            this._createDefaultTargetMesh();\n        }\n        this._floorMeshes = this._options.floorMeshes || [];\n        this._snapToPositions = this._options.snapPositions || [];\n        this._setTargetMeshVisibility(false);\n    }\n    /**\n     * Get the snapPointsOnly flag\n     */\n    get snapPointsOnly() {\n        return !!this._options.snapPointsOnly;\n    }\n    /**\n     * Sets the snapPointsOnly flag\n     * @param snapToPoints should teleportation be exclusively to snap points\n     */\n    set snapPointsOnly(snapToPoints) {\n        this._options.snapPointsOnly = snapToPoints;\n    }\n    /**\n     * Add a new mesh to the floor meshes array\n     * @param mesh the mesh to use as floor mesh\n     */\n    addFloorMesh(mesh) {\n        this._floorMeshes.push(mesh);\n    }\n    /**\n     * Add a mesh to the list of meshes blocking the teleportation ray\n     * @param mesh The mesh to add to the teleportation-blocking meshes\n     */\n    addBlockerMesh(mesh) {\n        this._options.pickBlockerMeshes = this._options.pickBlockerMeshes || [];\n        this._options.pickBlockerMeshes.push(mesh);\n    }\n    /**\n     * Add a new snap-to point to fix teleportation to this position\n     * @param newSnapPoint The new Snap-To point\n     */\n    addSnapPoint(newSnapPoint) {\n        this._snapToPositions.push(newSnapPoint);\n    }\n    attach() {\n        if (!super.attach()) {\n            return false;\n        }\n        // Safety reset\n        this._currentTeleportationControllerId = \"\";\n        this._options.xrInput.controllers.forEach(this._attachController);\n        this._addNewAttachObserver(this._options.xrInput.onControllerAddedObservable, this._attachController);\n        this._addNewAttachObserver(this._options.xrInput.onControllerRemovedObservable, (controller) => {\n            // REMOVE the controller\n            this._detachController(controller.uniqueId);\n        });\n        return true;\n    }\n    detach() {\n        if (!super.detach()) {\n            return false;\n        }\n        Object.keys(this._controllers).forEach((controllerId) => {\n            this._detachController(controllerId);\n        });\n        this._setTargetMeshVisibility(false);\n        this._currentTeleportationControllerId = \"\";\n        this._controllers = {};\n        return true;\n    }\n    dispose() {\n        super.dispose();\n        this._options.teleportationTargetMesh && this._options.teleportationTargetMesh.dispose(false, true);\n    }\n    /**\n     * Remove a mesh from the floor meshes array\n     * @param mesh the mesh to remove\n     */\n    removeFloorMesh(mesh) {\n        const index = this._floorMeshes.indexOf(mesh);\n        if (index !== -1) {\n            this._floorMeshes.splice(index, 1);\n        }\n    }\n    /**\n     * Remove a mesh from the blocker meshes array\n     * @param mesh the mesh to remove\n     */\n    removeBlockerMesh(mesh) {\n        this._options.pickBlockerMeshes = this._options.pickBlockerMeshes || [];\n        const index = this._options.pickBlockerMeshes.indexOf(mesh);\n        if (index !== -1) {\n            this._options.pickBlockerMeshes.splice(index, 1);\n        }\n    }\n    /**\n     * Remove a mesh from the floor meshes array using its name\n     * @param name the mesh name to remove\n     */\n    removeFloorMeshByName(name) {\n        const mesh = this._xrSessionManager.scene.getMeshByName(name);\n        if (mesh) {\n            this.removeFloorMesh(mesh);\n        }\n    }\n    /**\n     * This function will iterate through the array, searching for this point or equal to it. It will then remove it from the snap-to array\n     * @param snapPointToRemove the point (or a clone of it) to be removed from the array\n     * @returns was the point found and removed or not\n     */\n    removeSnapPoint(snapPointToRemove) {\n        // check if the object is in the array\n        let index = this._snapToPositions.indexOf(snapPointToRemove);\n        // if not found as an object, compare to the points\n        if (index === -1) {\n            for (let i = 0; i < this._snapToPositions.length; ++i) {\n                // equals? index is i, break the loop\n                if (this._snapToPositions[i].equals(snapPointToRemove)) {\n                    index = i;\n                    break;\n                }\n            }\n        }\n        // index is not -1? remove the object\n        if (index !== -1) {\n            this._snapToPositions.splice(index, 1);\n            return true;\n        }\n        return false;\n    }\n    /**\n     * This function sets a selection feature that will be disabled when\n     * the forward ray is shown and will be reattached when hidden.\n     * This is used to remove the selection rays when moving.\n     * @param selectionFeature the feature to disable when forward movement is enabled\n     */\n    setSelectionFeature(selectionFeature) {\n        this._selectionFeature = selectionFeature;\n    }\n    _onXRFrame(_xrFrame) {\n        const frame = this._xrSessionManager.currentFrame;\n        const scene = this._xrSessionManager.scene;\n        if (!this.attach || !frame) {\n            return;\n        }\n        // render target if needed\n        const targetMesh = this._options.teleportationTargetMesh;\n        if (this._currentTeleportationControllerId) {\n            if (!targetMesh) {\n                return;\n            }\n            targetMesh.rotationQuaternion = targetMesh.rotationQuaternion || new Quaternion();\n            const controllerData = this._controllers[this._currentTeleportationControllerId];\n            if (controllerData && controllerData.teleportationState.forward) {\n                // set the rotation\n                Quaternion.RotationYawPitchRollToRef(controllerData.teleportationState.currentRotation + controllerData.teleportationState.baseRotation, 0, 0, targetMesh.rotationQuaternion);\n                // set the ray and position\n                let hitPossible = false;\n                controllerData.xrController.getWorldPointerRayToRef(this._tmpRay);\n                if (this.straightRayEnabled) {\n                    // first check if direct ray possible\n                    // pick grounds that are LOWER only. upper will use parabolic path\n                    const pick = scene.pickWithRay(this._tmpRay, (o) => {\n                        // check for mesh-blockers\n                        if (this._options.pickBlockerMeshes && this._options.pickBlockerMeshes.indexOf(o) !== -1) {\n                            return true;\n                        }\n                        const index = this._floorMeshes.indexOf(o);\n                        if (index === -1) {\n                            return false;\n                        }\n                        return this._floorMeshes[index].absolutePosition.y < this._options.xrInput.xrCamera.globalPosition.y;\n                    });\n                    if (pick && pick.pickedMesh && this._options.pickBlockerMeshes && this._options.pickBlockerMeshes.indexOf(pick.pickedMesh) !== -1) {\n                        return;\n                    }\n                    else if (pick && pick.pickedPoint) {\n                        hitPossible = true;\n                        this._setTargetMeshPosition(pick);\n                        this._setTargetMeshVisibility(true);\n                        this._showParabolicPath(pick);\n                    }\n                }\n                // straight ray is still the main ray, but disabling the straight line will force parabolic line.\n                if (this.parabolicRayEnabled && !hitPossible) {\n                    // radius compensation according to pointer rotation around X\n                    const xRotation = controllerData.xrController.pointer.rotationQuaternion.toEulerAngles().x;\n                    const compensation = 1 + (Math.PI / 2 - Math.abs(xRotation));\n                    // check parabolic ray\n                    const radius = this.parabolicCheckRadius * compensation;\n                    this._tmpRay.origin.addToRef(this._tmpRay.direction.scale(radius * 2), this._tmpVector);\n                    this._tmpVector.y = this._tmpRay.origin.y;\n                    this._tmpRay.origin.addInPlace(this._tmpRay.direction.scale(radius));\n                    this._tmpVector.subtractToRef(this._tmpRay.origin, this._tmpRay.direction);\n                    this._tmpRay.direction.normalize();\n                    const pick = scene.pickWithRay(this._tmpRay, (o) => {\n                        // check for mesh-blockers\n                        if (this._options.pickBlockerMeshes && this._options.pickBlockerMeshes.indexOf(o) !== -1) {\n                            return true;\n                        }\n                        return this._floorMeshes.indexOf(o) !== -1;\n                    });\n                    if (pick && pick.pickedMesh && this._options.pickBlockerMeshes && this._options.pickBlockerMeshes.indexOf(pick.pickedMesh) !== -1) {\n                        return;\n                    }\n                    else if (pick && pick.pickedPoint) {\n                        hitPossible = true;\n                        this._setTargetMeshPosition(pick);\n                        this._setTargetMeshVisibility(true);\n                        this._showParabolicPath(pick);\n                    }\n                }\n                // if needed, set visible:\n                this._setTargetMeshVisibility(hitPossible);\n            }\n            else {\n                this._setTargetMeshVisibility(false);\n            }\n        }\n        else {\n            this._setTargetMeshVisibility(false);\n        }\n    }\n    _createDefaultTargetMesh() {\n        // set defaults\n        this._options.defaultTargetMeshOptions = this._options.defaultTargetMeshOptions || {};\n        const sceneToRenderTo = this._options.useUtilityLayer\n            ? this._options.customUtilityLayerScene || UtilityLayerRenderer.DefaultUtilityLayer.utilityLayerScene\n            : this._xrSessionManager.scene;\n        const teleportationTarget = CreateGround(\"teleportationTarget\", { width: 2, height: 2, subdivisions: 2 }, sceneToRenderTo);\n        teleportationTarget.isPickable = false;\n        if (this._options.defaultTargetMeshOptions.teleportationCircleMaterial) {\n            teleportationTarget.material = this._options.defaultTargetMeshOptions.teleportationCircleMaterial;\n        }\n        else {\n            const length = 512;\n            const dynamicTexture = new DynamicTexture(\"teleportationPlaneDynamicTexture\", length, sceneToRenderTo, true);\n            dynamicTexture.hasAlpha = true;\n            const context = dynamicTexture.getContext();\n            const centerX = length / 2;\n            const centerY = length / 2;\n            const radius = 200;\n            context.beginPath();\n            context.arc(centerX, centerY, radius, 0, 2 * Math.PI, false);\n            context.fillStyle = this._options.defaultTargetMeshOptions.teleportationFillColor || \"#444444\";\n            context.fill();\n            context.lineWidth = 10;\n            context.strokeStyle = this._options.defaultTargetMeshOptions.teleportationBorderColor || \"#FFFFFF\";\n            context.stroke();\n            context.closePath();\n            dynamicTexture.update();\n            const teleportationCircleMaterial = new StandardMaterial(\"teleportationPlaneMaterial\", sceneToRenderTo);\n            teleportationCircleMaterial.diffuseTexture = dynamicTexture;\n            teleportationTarget.material = teleportationCircleMaterial;\n        }\n        const torus = CreateTorus(\"torusTeleportation\", {\n            diameter: 0.75,\n            thickness: 0.1,\n            tessellation: 20,\n        }, sceneToRenderTo);\n        torus.isPickable = false;\n        torus.parent = teleportationTarget;\n        if (!this._options.defaultTargetMeshOptions.disableAnimation) {\n            const animationInnerCircle = new Animation(\"animationInnerCircle\", \"position.y\", 30, Animation.ANIMATIONTYPE_FLOAT, Animation.ANIMATIONLOOPMODE_CYCLE);\n            const keys = [];\n            keys.push({\n                frame: 0,\n                value: 0,\n            });\n            keys.push({\n                frame: 30,\n                value: 0.4,\n            });\n            keys.push({\n                frame: 60,\n                value: 0,\n            });\n            animationInnerCircle.setKeys(keys);\n            const easingFunction = new SineEase();\n            easingFunction.setEasingMode(EasingFunction.EASINGMODE_EASEINOUT);\n            animationInnerCircle.setEasingFunction(easingFunction);\n            torus.animations = [];\n            torus.animations.push(animationInnerCircle);\n            sceneToRenderTo.beginAnimation(torus, 0, 60, true);\n        }\n        const cone = CreateCylinder(\"rotationCone\", { diameterTop: 0, tessellation: 4 }, sceneToRenderTo);\n        cone.isPickable = false;\n        cone.scaling.set(0.5, 0.12, 0.2);\n        cone.rotate(Axis.X, Math.PI / 2);\n        cone.position.z = 0.6;\n        cone.parent = torus;\n        if (this._options.defaultTargetMeshOptions.torusArrowMaterial) {\n            torus.material = this._options.defaultTargetMeshOptions.torusArrowMaterial;\n            cone.material = this._options.defaultTargetMeshOptions.torusArrowMaterial;\n        }\n        else {\n            const torusConeMaterial = new StandardMaterial(\"torusConsMat\", sceneToRenderTo);\n            torusConeMaterial.disableLighting = !!this._options.defaultTargetMeshOptions.disableLighting;\n            if (torusConeMaterial.disableLighting) {\n                torusConeMaterial.emissiveColor = new Color3(0.3, 0.3, 1.0);\n            }\n            else {\n                torusConeMaterial.diffuseColor = new Color3(0.3, 0.3, 1.0);\n            }\n            torusConeMaterial.alpha = 0.9;\n            torus.material = torusConeMaterial;\n            cone.material = torusConeMaterial;\n            this._teleportationRingMaterial = torusConeMaterial;\n        }\n        if (this._options.renderingGroupId !== undefined) {\n            teleportationTarget.renderingGroupId = this._options.renderingGroupId;\n            torus.renderingGroupId = this._options.renderingGroupId;\n            cone.renderingGroupId = this._options.renderingGroupId;\n        }\n        this._options.teleportationTargetMesh = teleportationTarget;\n        // hide the teleportation target mesh right after creating it.\n        this._setTargetMeshVisibility(false);\n    }\n    _detachController(xrControllerUniqueId) {\n        const controllerData = this._controllers[xrControllerUniqueId];\n        if (!controllerData) {\n            return;\n        }\n        if (controllerData.teleportationComponent) {\n            if (controllerData.onAxisChangedObserver) {\n                controllerData.teleportationComponent.onAxisValueChangedObservable.remove(controllerData.onAxisChangedObserver);\n            }\n            if (controllerData.onButtonChangedObserver) {\n                controllerData.teleportationComponent.onButtonStateChangedObservable.remove(controllerData.onButtonChangedObserver);\n            }\n        }\n        // remove from the map\n        delete this._controllers[xrControllerUniqueId];\n    }\n    _findClosestSnapPointWithRadius(realPosition, radius = this._options.snapToPositionRadius || 0.8) {\n        let closestPoint = null;\n        let closestDistance = Number.MAX_VALUE;\n        if (this._snapToPositions.length) {\n            const radiusSquared = radius * radius;\n            this._snapToPositions.forEach((position) => {\n                const dist = Vector3.DistanceSquared(position, realPosition);\n                if (dist <= radiusSquared && dist < closestDistance) {\n                    closestDistance = dist;\n                    closestPoint = position;\n                }\n            });\n        }\n        return closestPoint;\n    }\n    _setTargetMeshPosition(pickInfo) {\n        const newPosition = pickInfo.pickedPoint;\n        if (!this._options.teleportationTargetMesh || !newPosition) {\n            return;\n        }\n        const snapPosition = this._findClosestSnapPointWithRadius(newPosition);\n        this._snappedToPoint = !!snapPosition;\n        if (this.snapPointsOnly && !this._snappedToPoint && this._teleportationRingMaterial) {\n            this._teleportationRingMaterial.diffuseColor.set(1.0, 0.3, 0.3);\n        }\n        else if (this.snapPointsOnly && this._snappedToPoint && this._teleportationRingMaterial) {\n            this._teleportationRingMaterial.diffuseColor.set(0.3, 0.3, 1.0);\n        }\n        this._options.teleportationTargetMesh.position.copyFrom(snapPosition || newPosition);\n        this._options.teleportationTargetMesh.position.y += 0.01;\n        this.onTargetMeshPositionUpdatedObservable.notifyObservers(pickInfo);\n    }\n    _setTargetMeshVisibility(visible) {\n        if (!this._options.teleportationTargetMesh) {\n            return;\n        }\n        if (this._options.teleportationTargetMesh.isVisible === visible) {\n            return;\n        }\n        this._options.teleportationTargetMesh.isVisible = visible;\n        this._options.teleportationTargetMesh.getChildren(undefined, false).forEach((m) => {\n            m.isVisible = visible;\n        });\n        if (!visible) {\n            if (this._quadraticBezierCurve) {\n                this._quadraticBezierCurve.dispose();\n                this._quadraticBezierCurve = null;\n            }\n            if (this._selectionFeature) {\n                this._selectionFeature.attach();\n            }\n        }\n        else {\n            if (this._selectionFeature) {\n                this._selectionFeature.detach();\n            }\n        }\n    }\n    _showParabolicPath(pickInfo) {\n        if (!pickInfo.pickedPoint || !this._currentTeleportationControllerId) {\n            return;\n        }\n        const sceneToRenderTo = this._options.useUtilityLayer\n            ? this._options.customUtilityLayerScene || UtilityLayerRenderer.DefaultUtilityLayer.utilityLayerScene\n            : this._xrSessionManager.scene;\n        const controllerData = this._controllers[this._currentTeleportationControllerId];\n        const quadraticBezierVectors = Curve3.CreateQuadraticBezier(controllerData.xrController.pointer.absolutePosition, pickInfo.ray.origin, pickInfo.pickedPoint, 25);\n        if (!this._options.generateRayPathMesh) {\n            this._quadraticBezierCurve = CreateLines(\"teleportation path line\", { points: quadraticBezierVectors.getPoints(), instance: this._quadraticBezierCurve, updatable: true }, sceneToRenderTo);\n        }\n        else {\n            this._quadraticBezierCurve = this._options.generateRayPathMesh(quadraticBezierVectors.getPoints(), pickInfo);\n        }\n        this._quadraticBezierCurve.isPickable = false;\n        if (this._options.renderingGroupId !== undefined) {\n            this._quadraticBezierCurve.renderingGroupId = this._options.renderingGroupId;\n        }\n    }\n    _teleportForward(controllerId) {\n        const controllerData = this._controllers[controllerId];\n        if (!controllerData || !controllerData.teleportationState.forward || !this.teleportationEnabled) {\n            return;\n        }\n        controllerData.teleportationState.forward = false;\n        this._currentTeleportationControllerId = \"\";\n        if (this.snapPointsOnly && !this._snappedToPoint) {\n            return;\n        }\n        if (this.skipNextTeleportation) {\n            this.skipNextTeleportation = false;\n            return;\n        }\n        // do the movement forward here\n        if (this._options.teleportationTargetMesh && this._options.teleportationTargetMesh.isVisible) {\n            const height = this._options.xrInput.xrCamera.realWorldHeight;\n            this._options.xrInput.xrCamera.onBeforeCameraTeleport.notifyObservers(this._options.xrInput.xrCamera.position);\n            this._options.xrInput.xrCamera.position.copyFrom(this._options.teleportationTargetMesh.position);\n            this._options.xrInput.xrCamera.position.y += height;\n            Quaternion.FromEulerAngles(0, controllerData.teleportationState.currentRotation - (this._xrSessionManager.scene.useRightHandedSystem ? Math.PI : 0), 0).multiplyToRef(this._options.xrInput.xrCamera.rotationQuaternion, this._options.xrInput.xrCamera.rotationQuaternion);\n            this._options.xrInput.xrCamera.onAfterCameraTeleport.notifyObservers(this._options.xrInput.xrCamera.position);\n        }\n    }\n}\n/**\n * The module's name\n */\nWebXRMotionControllerTeleportation.Name = WebXRFeatureName.TELEPORTATION;\n/**\n * The (Babylon) version of this module.\n * This is an integer representing the implementation version.\n * This number does not correspond to the webxr specs version\n */\nWebXRMotionControllerTeleportation.Version = 1;\nWebXRFeaturesManager.AddWebXRFeature(WebXRMotionControllerTeleportation.Name, (xrSessionManager, options) => {\n    return () => new WebXRMotionControllerTeleportation(xrSessionManager, options);\n}, WebXRMotionControllerTeleportation.Version, true);\n//# sourceMappingURL=WebXRControllerTeleportation.js.map","import { WebXRAbstractFeature } from \"./WebXRAbstractFeature.js\";\nimport { WebXRFeatureName, WebXRFeaturesManager } from \"../webXRFeaturesManager.js\";\nimport { Matrix, Quaternion } from \"../../Maths/math.vector.js\";\nimport { PhysicsImpostor } from \"../../Physics/v1/physicsImpostor.js\";\nimport { Observable } from \"../../Misc/observable.js\";\nimport { SceneLoader } from \"../../Loading/sceneLoader.js\";\nimport { Color3 } from \"../../Maths/math.color.js\";\nimport { NodeMaterial } from \"../../Materials/Node/nodeMaterial.js\";\nimport { Material } from \"../../Materials/material.js\";\nimport { CreateIcoSphere } from \"../../Meshes/Builders/icoSphereBuilder.js\";\nimport { TransformNode } from \"../../Meshes/transformNode.js\";\nimport { Axis } from \"../../Maths/math.axis.js\";\nimport { EngineStore } from \"../../Engines/engineStore.js\";\n\n/**\n * Parts of the hands divided to writs and finger names\n */\nexport var HandPart;\n(function (HandPart) {\n    /**\n     * HandPart - Wrist\n     */\n    HandPart[\"WRIST\"] = \"wrist\";\n    /**\n     * HandPart - The thumb\n     */\n    HandPart[\"THUMB\"] = \"thumb\";\n    /**\n     * HandPart - Index finger\n     */\n    HandPart[\"INDEX\"] = \"index\";\n    /**\n     * HandPart - Middle finger\n     */\n    HandPart[\"MIDDLE\"] = \"middle\";\n    /**\n     * HandPart - Ring finger\n     */\n    HandPart[\"RING\"] = \"ring\";\n    /**\n     * HandPart - Little finger\n     */\n    HandPart[\"LITTLE\"] = \"little\";\n})(HandPart || (HandPart = {}));\n/**\n * Joints of the hand as defined by the WebXR specification.\n * https://immersive-web.github.io/webxr-hand-input/#skeleton-joints-section\n */\nexport var WebXRHandJoint;\n(function (WebXRHandJoint) {\n    /** Wrist */\n    WebXRHandJoint[\"WRIST\"] = \"wrist\";\n    /** Thumb near wrist */\n    WebXRHandJoint[\"THUMB_METACARPAL\"] = \"thumb-metacarpal\";\n    /** Thumb first knuckle */\n    WebXRHandJoint[\"THUMB_PHALANX_PROXIMAL\"] = \"thumb-phalanx-proximal\";\n    /** Thumb second knuckle */\n    WebXRHandJoint[\"THUMB_PHALANX_DISTAL\"] = \"thumb-phalanx-distal\";\n    /** Thumb tip */\n    WebXRHandJoint[\"THUMB_TIP\"] = \"thumb-tip\";\n    /** Index finger near wrist */\n    WebXRHandJoint[\"INDEX_FINGER_METACARPAL\"] = \"index-finger-metacarpal\";\n    /** Index finger first knuckle */\n    WebXRHandJoint[\"INDEX_FINGER_PHALANX_PROXIMAL\"] = \"index-finger-phalanx-proximal\";\n    /** Index finger second knuckle */\n    WebXRHandJoint[\"INDEX_FINGER_PHALANX_INTERMEDIATE\"] = \"index-finger-phalanx-intermediate\";\n    /** Index finger third knuckle */\n    WebXRHandJoint[\"INDEX_FINGER_PHALANX_DISTAL\"] = \"index-finger-phalanx-distal\";\n    /** Index finger tip */\n    WebXRHandJoint[\"INDEX_FINGER_TIP\"] = \"index-finger-tip\";\n    /** Middle finger near wrist */\n    WebXRHandJoint[\"MIDDLE_FINGER_METACARPAL\"] = \"middle-finger-metacarpal\";\n    /** Middle finger first knuckle */\n    WebXRHandJoint[\"MIDDLE_FINGER_PHALANX_PROXIMAL\"] = \"middle-finger-phalanx-proximal\";\n    /** Middle finger second knuckle */\n    WebXRHandJoint[\"MIDDLE_FINGER_PHALANX_INTERMEDIATE\"] = \"middle-finger-phalanx-intermediate\";\n    /** Middle finger third knuckle */\n    WebXRHandJoint[\"MIDDLE_FINGER_PHALANX_DISTAL\"] = \"middle-finger-phalanx-distal\";\n    /** Middle finger tip */\n    WebXRHandJoint[\"MIDDLE_FINGER_TIP\"] = \"middle-finger-tip\";\n    /** Ring finger near wrist */\n    WebXRHandJoint[\"RING_FINGER_METACARPAL\"] = \"ring-finger-metacarpal\";\n    /** Ring finger first knuckle */\n    WebXRHandJoint[\"RING_FINGER_PHALANX_PROXIMAL\"] = \"ring-finger-phalanx-proximal\";\n    /** Ring finger second knuckle */\n    WebXRHandJoint[\"RING_FINGER_PHALANX_INTERMEDIATE\"] = \"ring-finger-phalanx-intermediate\";\n    /** Ring finger third knuckle */\n    WebXRHandJoint[\"RING_FINGER_PHALANX_DISTAL\"] = \"ring-finger-phalanx-distal\";\n    /** Ring finger tip */\n    WebXRHandJoint[\"RING_FINGER_TIP\"] = \"ring-finger-tip\";\n    /** Pinky finger near wrist */\n    WebXRHandJoint[\"PINKY_FINGER_METACARPAL\"] = \"pinky-finger-metacarpal\";\n    /** Pinky finger first knuckle */\n    WebXRHandJoint[\"PINKY_FINGER_PHALANX_PROXIMAL\"] = \"pinky-finger-phalanx-proximal\";\n    /** Pinky finger second knuckle */\n    WebXRHandJoint[\"PINKY_FINGER_PHALANX_INTERMEDIATE\"] = \"pinky-finger-phalanx-intermediate\";\n    /** Pinky finger third knuckle */\n    WebXRHandJoint[\"PINKY_FINGER_PHALANX_DISTAL\"] = \"pinky-finger-phalanx-distal\";\n    /** Pinky finger tip */\n    WebXRHandJoint[\"PINKY_FINGER_TIP\"] = \"pinky-finger-tip\";\n})(WebXRHandJoint || (WebXRHandJoint = {}));\nconst handJointReferenceArray = [\n    WebXRHandJoint.WRIST,\n    WebXRHandJoint.THUMB_METACARPAL,\n    WebXRHandJoint.THUMB_PHALANX_PROXIMAL,\n    WebXRHandJoint.THUMB_PHALANX_DISTAL,\n    WebXRHandJoint.THUMB_TIP,\n    WebXRHandJoint.INDEX_FINGER_METACARPAL,\n    WebXRHandJoint.INDEX_FINGER_PHALANX_PROXIMAL,\n    WebXRHandJoint.INDEX_FINGER_PHALANX_INTERMEDIATE,\n    WebXRHandJoint.INDEX_FINGER_PHALANX_DISTAL,\n    WebXRHandJoint.INDEX_FINGER_TIP,\n    WebXRHandJoint.MIDDLE_FINGER_METACARPAL,\n    WebXRHandJoint.MIDDLE_FINGER_PHALANX_PROXIMAL,\n    WebXRHandJoint.MIDDLE_FINGER_PHALANX_INTERMEDIATE,\n    WebXRHandJoint.MIDDLE_FINGER_PHALANX_DISTAL,\n    WebXRHandJoint.MIDDLE_FINGER_TIP,\n    WebXRHandJoint.RING_FINGER_METACARPAL,\n    WebXRHandJoint.RING_FINGER_PHALANX_PROXIMAL,\n    WebXRHandJoint.RING_FINGER_PHALANX_INTERMEDIATE,\n    WebXRHandJoint.RING_FINGER_PHALANX_DISTAL,\n    WebXRHandJoint.RING_FINGER_TIP,\n    WebXRHandJoint.PINKY_FINGER_METACARPAL,\n    WebXRHandJoint.PINKY_FINGER_PHALANX_PROXIMAL,\n    WebXRHandJoint.PINKY_FINGER_PHALANX_INTERMEDIATE,\n    WebXRHandJoint.PINKY_FINGER_PHALANX_DISTAL,\n    WebXRHandJoint.PINKY_FINGER_TIP,\n];\nconst handPartsDefinition = {\n    [HandPart.WRIST]: [WebXRHandJoint.WRIST],\n    [HandPart.THUMB]: [WebXRHandJoint.THUMB_METACARPAL, WebXRHandJoint.THUMB_PHALANX_PROXIMAL, WebXRHandJoint.THUMB_PHALANX_DISTAL, WebXRHandJoint.THUMB_TIP],\n    [HandPart.INDEX]: [\n        WebXRHandJoint.INDEX_FINGER_METACARPAL,\n        WebXRHandJoint.INDEX_FINGER_PHALANX_PROXIMAL,\n        WebXRHandJoint.INDEX_FINGER_PHALANX_INTERMEDIATE,\n        WebXRHandJoint.INDEX_FINGER_PHALANX_DISTAL,\n        WebXRHandJoint.INDEX_FINGER_TIP,\n    ],\n    [HandPart.MIDDLE]: [\n        WebXRHandJoint.MIDDLE_FINGER_METACARPAL,\n        WebXRHandJoint.MIDDLE_FINGER_PHALANX_PROXIMAL,\n        WebXRHandJoint.MIDDLE_FINGER_PHALANX_INTERMEDIATE,\n        WebXRHandJoint.MIDDLE_FINGER_PHALANX_DISTAL,\n        WebXRHandJoint.MIDDLE_FINGER_TIP,\n    ],\n    [HandPart.RING]: [\n        WebXRHandJoint.RING_FINGER_METACARPAL,\n        WebXRHandJoint.RING_FINGER_PHALANX_PROXIMAL,\n        WebXRHandJoint.RING_FINGER_PHALANX_INTERMEDIATE,\n        WebXRHandJoint.RING_FINGER_PHALANX_DISTAL,\n        WebXRHandJoint.RING_FINGER_TIP,\n    ],\n    [HandPart.LITTLE]: [\n        WebXRHandJoint.PINKY_FINGER_METACARPAL,\n        WebXRHandJoint.PINKY_FINGER_PHALANX_PROXIMAL,\n        WebXRHandJoint.PINKY_FINGER_PHALANX_INTERMEDIATE,\n        WebXRHandJoint.PINKY_FINGER_PHALANX_DISTAL,\n        WebXRHandJoint.PINKY_FINGER_TIP,\n    ],\n};\n/**\n * Representing a single hand (with its corresponding native XRHand object)\n */\nexport class WebXRHand {\n    /**\n     * Get the hand mesh.\n     */\n    get handMesh() {\n        return this._handMesh;\n    }\n    /**\n     * Get meshes of part of the hand.\n     * @param part The part of hand to get.\n     * @returns An array of meshes that correlate to the hand part requested.\n     */\n    getHandPartMeshes(part) {\n        return handPartsDefinition[part].map((name) => this._jointMeshes[handJointReferenceArray.indexOf(name)]);\n    }\n    /**\n     * Retrieves a mesh linked to a named joint in the hand.\n     * @param jointName The name of the joint.\n     * @returns An AbstractMesh whose position corresponds with the joint position.\n     */\n    getJointMesh(jointName) {\n        return this._jointMeshes[handJointReferenceArray.indexOf(jointName)];\n    }\n    /**\n     * Construct a new hand object\n     * @param xrController The controller to which the hand correlates.\n     * @param _jointMeshes The meshes to be used to track the hand joints.\n     * @param _handMesh An optional hand mesh.\n     * @param rigMapping An optional rig mapping for the hand mesh.\n     *                   If not provided (but a hand mesh is provided),\n     *                   it will be assumed that the hand mesh's bones are named\n     *                   directly after the WebXR bone names.\n     * @param _leftHandedMeshes Are the hand meshes left-handed-system meshes\n     * @param _jointsInvisible Are the tracked joint meshes visible\n     * @param _jointScaleFactor Scale factor for all joint meshes\n     */\n    constructor(\n    /** The controller to which the hand correlates. */\n    xrController, _jointMeshes, _handMesh, \n    /** An optional rig mapping for the hand mesh. If not provided (but a hand mesh is provided),\n     * it will be assumed that the hand mesh's bones are named directly after the WebXR bone names. */\n    rigMapping, _leftHandedMeshes = false, _jointsInvisible = false, _jointScaleFactor = 1) {\n        this.xrController = xrController;\n        this._jointMeshes = _jointMeshes;\n        this._handMesh = _handMesh;\n        this.rigMapping = rigMapping;\n        this._leftHandedMeshes = _leftHandedMeshes;\n        this._jointsInvisible = _jointsInvisible;\n        this._jointScaleFactor = _jointScaleFactor;\n        /**\n         * Transform nodes that will directly receive the transforms from the WebXR matrix data.\n         */\n        this._jointTransforms = new Array(handJointReferenceArray.length);\n        /**\n         * The float array that will directly receive the transform matrix data from WebXR.\n         */\n        this._jointTransformMatrices = new Float32Array(handJointReferenceArray.length * 16);\n        this._tempJointMatrix = new Matrix();\n        /**\n         * The float array that will directly receive the joint radii from WebXR.\n         */\n        this._jointRadii = new Float32Array(handJointReferenceArray.length);\n        this._scene = _jointMeshes[0].getScene();\n        // Initialize the joint transform quaternions and link the transforms to the bones.\n        for (let jointIdx = 0; jointIdx < this._jointTransforms.length; jointIdx++) {\n            const jointTransform = (this._jointTransforms[jointIdx] = new TransformNode(handJointReferenceArray[jointIdx], this._scene));\n            jointTransform.rotationQuaternion = new Quaternion();\n            // Set the rotation quaternion so we can use it later for tracking.\n            _jointMeshes[jointIdx].rotationQuaternion = new Quaternion();\n        }\n        if (_handMesh) {\n            // Note that this logic needs to happen after we initialize the joint tracking transform nodes.\n            this.setHandMesh(_handMesh, rigMapping);\n        }\n        // hide the motion controller, if available/loaded\n        if (this.xrController.motionController) {\n            if (this.xrController.motionController.rootMesh) {\n                this.xrController.motionController.rootMesh.setEnabled(false);\n            }\n            else {\n                this.xrController.motionController.onModelLoadedObservable.add((controller) => {\n                    if (controller.rootMesh) {\n                        controller.rootMesh.setEnabled(false);\n                    }\n                });\n            }\n        }\n        this.xrController.onMotionControllerInitObservable.add((motionController) => {\n            motionController.onModelLoadedObservable.add((controller) => {\n                if (controller.rootMesh) {\n                    controller.rootMesh.setEnabled(false);\n                }\n            });\n            if (motionController.rootMesh) {\n                motionController.rootMesh.setEnabled(false);\n            }\n        });\n    }\n    /**\n     * Sets the current hand mesh to render for the WebXRHand.\n     * @param handMesh The rigged hand mesh that will be tracked to the user's hand.\n     * @param rigMapping The mapping from XRHandJoint to bone names to use with the mesh.\n     */\n    setHandMesh(handMesh, rigMapping) {\n        this._handMesh = handMesh;\n        // Avoid any strange frustum culling. We will manually control visibility via attach and detach.\n        handMesh.alwaysSelectAsActiveMesh = true;\n        handMesh.getChildMeshes().forEach((mesh) => (mesh.alwaysSelectAsActiveMesh = true));\n        // Link the bones in the hand mesh to the transform nodes that will be bound to the WebXR tracked joints.\n        if (this._handMesh.skeleton) {\n            const handMeshSkeleton = this._handMesh.skeleton;\n            handJointReferenceArray.forEach((jointName, jointIdx) => {\n                const jointBoneIdx = handMeshSkeleton.getBoneIndexByName(rigMapping ? rigMapping[jointName] : jointName);\n                if (jointBoneIdx !== -1) {\n                    handMeshSkeleton.bones[jointBoneIdx].linkTransformNode(this._jointTransforms[jointIdx]);\n                }\n            });\n        }\n    }\n    /**\n     * Update this hand from the latest xr frame.\n     * @param xrFrame The latest frame received from WebXR.\n     * @param referenceSpace The current viewer reference space.\n     */\n    updateFromXRFrame(xrFrame, referenceSpace) {\n        const hand = this.xrController.inputSource.hand;\n        if (!hand) {\n            return;\n        }\n        // TODO: Modify webxr.d.ts to better match WebXR IDL so we don't need this any cast.\n        const anyHand = hand;\n        const jointSpaces = handJointReferenceArray.map((jointName) => anyHand[jointName] || hand.get(jointName));\n        let trackingSuccessful = false;\n        if (xrFrame.fillPoses && xrFrame.fillJointRadii) {\n            trackingSuccessful = xrFrame.fillPoses(jointSpaces, referenceSpace, this._jointTransformMatrices) && xrFrame.fillJointRadii(jointSpaces, this._jointRadii);\n        }\n        else if (xrFrame.getJointPose) {\n            trackingSuccessful = true;\n            // Warning: This codepath is slow by comparison, only here for compat.\n            for (let jointIdx = 0; jointIdx < jointSpaces.length; jointIdx++) {\n                const jointPose = xrFrame.getJointPose(jointSpaces[jointIdx], referenceSpace);\n                if (jointPose) {\n                    this._jointTransformMatrices.set(jointPose.transform.matrix, jointIdx * 16);\n                    this._jointRadii[jointIdx] = jointPose.radius || 0.008;\n                }\n                else {\n                    trackingSuccessful = false;\n                    break;\n                }\n            }\n        }\n        if (!trackingSuccessful) {\n            return;\n        }\n        handJointReferenceArray.forEach((_jointName, jointIdx) => {\n            const jointTransform = this._jointTransforms[jointIdx];\n            Matrix.FromArrayToRef(this._jointTransformMatrices, jointIdx * 16, this._tempJointMatrix);\n            this._tempJointMatrix.decompose(undefined, jointTransform.rotationQuaternion, jointTransform.position);\n            // The radius we need to make the joint in order for it to roughly cover the joints of the user's real hand.\n            const scaledJointRadius = this._jointRadii[jointIdx] * this._jointScaleFactor;\n            const jointMesh = this._jointMeshes[jointIdx];\n            jointMesh.isVisible = !this._handMesh && !this._jointsInvisible;\n            jointMesh.position.copyFrom(jointTransform.position);\n            jointMesh.rotationQuaternion.copyFrom(jointTransform.rotationQuaternion);\n            jointMesh.scaling.setAll(scaledJointRadius);\n            // The WebXR data comes as right-handed, so we might need to do some conversions.\n            if (!this._scene.useRightHandedSystem) {\n                jointMesh.position.z *= -1;\n                jointMesh.rotationQuaternion.z *= -1;\n                jointMesh.rotationQuaternion.w *= -1;\n                if (this._leftHandedMeshes && this._handMesh) {\n                    jointTransform.position.z *= -1;\n                    jointTransform.rotationQuaternion.z *= -1;\n                    jointTransform.rotationQuaternion.w *= -1;\n                }\n            }\n        });\n        if (this._handMesh) {\n            this._handMesh.isVisible = true;\n        }\n    }\n    /**\n     * Dispose this Hand object\n     */\n    dispose() {\n        if (this._handMesh) {\n            this._handMesh.isVisible = false;\n        }\n    }\n}\n/**\n * WebXR Hand Joint tracking feature, available for selected browsers and devices\n */\nexport class WebXRHandTracking extends WebXRAbstractFeature {\n    static _GenerateTrackedJointMeshes(featureOptions) {\n        const meshes = {};\n        [\"left\", \"right\"].map((handedness) => {\n            var _a, _b, _c, _d, _e;\n            const trackedMeshes = [];\n            const originalMesh = ((_a = featureOptions.jointMeshes) === null || _a === void 0 ? void 0 : _a.sourceMesh) || CreateIcoSphere(\"jointParent\", WebXRHandTracking._ICOSPHERE_PARAMS);\n            originalMesh.isVisible = !!((_b = featureOptions.jointMeshes) === null || _b === void 0 ? void 0 : _b.keepOriginalVisible);\n            for (let i = 0; i < handJointReferenceArray.length; ++i) {\n                let newInstance = originalMesh.createInstance(`${handedness}-handJoint-${i}`);\n                if ((_c = featureOptions.jointMeshes) === null || _c === void 0 ? void 0 : _c.onHandJointMeshGenerated) {\n                    const returnedMesh = featureOptions.jointMeshes.onHandJointMeshGenerated(newInstance, i, handedness);\n                    if (returnedMesh) {\n                        if (returnedMesh !== newInstance) {\n                            newInstance.dispose();\n                            newInstance = returnedMesh;\n                        }\n                    }\n                }\n                newInstance.isPickable = false;\n                if ((_d = featureOptions.jointMeshes) === null || _d === void 0 ? void 0 : _d.enablePhysics) {\n                    const props = ((_e = featureOptions.jointMeshes) === null || _e === void 0 ? void 0 : _e.physicsProps) || {};\n                    // downscale the instances so that physics will be initialized correctly\n                    newInstance.scaling.setAll(0.02);\n                    const type = props.impostorType !== undefined ? props.impostorType : PhysicsImpostor.SphereImpostor;\n                    newInstance.physicsImpostor = new PhysicsImpostor(newInstance, type, { mass: 0, ...props });\n                }\n                newInstance.rotationQuaternion = new Quaternion();\n                newInstance.isVisible = false;\n                trackedMeshes.push(newInstance);\n            }\n            meshes[handedness] = trackedMeshes;\n        });\n        return { left: meshes.left, right: meshes.right };\n    }\n    static _GenerateDefaultHandMeshesAsync(scene, options) {\n        // eslint-disable-next-line no-async-promise-executor\n        return new Promise(async (resolve) => {\n            var _a, _b, _c, _d, _e;\n            const riggedMeshes = {};\n            // check the cache, defensive\n            if ((_b = (_a = WebXRHandTracking._RightHandGLB) === null || _a === void 0 ? void 0 : _a.meshes[1]) === null || _b === void 0 ? void 0 : _b.isDisposed()) {\n                WebXRHandTracking._RightHandGLB = null;\n            }\n            if ((_d = (_c = WebXRHandTracking._LeftHandGLB) === null || _c === void 0 ? void 0 : _c.meshes[1]) === null || _d === void 0 ? void 0 : _d.isDisposed()) {\n                WebXRHandTracking._LeftHandGLB = null;\n            }\n            const handsDefined = !!(WebXRHandTracking._RightHandGLB && WebXRHandTracking._LeftHandGLB);\n            // load them in parallel\n            const handGLBs = await Promise.all([\n                WebXRHandTracking._RightHandGLB ||\n                    SceneLoader.ImportMeshAsync(\"\", WebXRHandTracking.DEFAULT_HAND_MODEL_BASE_URL, WebXRHandTracking.DEFAULT_HAND_MODEL_RIGHT_FILENAME, scene),\n                WebXRHandTracking._LeftHandGLB ||\n                    SceneLoader.ImportMeshAsync(\"\", WebXRHandTracking.DEFAULT_HAND_MODEL_BASE_URL, WebXRHandTracking.DEFAULT_HAND_MODEL_LEFT_FILENAME, scene),\n            ]);\n            WebXRHandTracking._RightHandGLB = handGLBs[0];\n            WebXRHandTracking._LeftHandGLB = handGLBs[1];\n            const handShader = new NodeMaterial(\"handShader\", scene, { emitComments: false });\n            await handShader.loadAsync(WebXRHandTracking.DEFAULT_HAND_MODEL_SHADER_URL);\n            // depth prepass and alpha mode\n            handShader.needDepthPrePass = true;\n            handShader.transparencyMode = Material.MATERIAL_ALPHABLEND;\n            handShader.alphaMode = 2;\n            // build node materials\n            handShader.build(false);\n            // shader\n            const handColors = {\n                base: Color3.FromInts(116, 63, 203),\n                fresnel: Color3.FromInts(149, 102, 229),\n                fingerColor: Color3.FromInts(177, 130, 255),\n                tipFresnel: Color3.FromInts(220, 200, 255),\n                ...(_e = options === null || options === void 0 ? void 0 : options.handMeshes) === null || _e === void 0 ? void 0 : _e.customColors,\n            };\n            const handNodes = {\n                base: handShader.getBlockByName(\"baseColor\"),\n                fresnel: handShader.getBlockByName(\"fresnelColor\"),\n                fingerColor: handShader.getBlockByName(\"fingerColor\"),\n                tipFresnel: handShader.getBlockByName(\"tipFresnelColor\"),\n            };\n            handNodes.base.value = handColors.base;\n            handNodes.fresnel.value = handColors.fresnel;\n            handNodes.fingerColor.value = handColors.fingerColor;\n            handNodes.tipFresnel.value = handColors.tipFresnel;\n            [\"left\", \"right\"].forEach((handedness) => {\n                const handGLB = handedness == \"left\" ? WebXRHandTracking._LeftHandGLB : WebXRHandTracking._RightHandGLB;\n                if (!handGLB) {\n                    // this should never happen!\n                    throw new Error(\"Could not load hand model\");\n                }\n                const handMesh = handGLB.meshes[1];\n                handMesh._internalAbstractMeshDataInfo._computeBonesUsingShaders = true;\n                handMesh.material = handShader.clone(`${handedness}HandShaderClone`, true);\n                handMesh.isVisible = false;\n                riggedMeshes[handedness] = handMesh;\n                // single change for left handed systems\n                if (!handsDefined && !scene.useRightHandedSystem) {\n                    handGLB.meshes[1].rotate(Axis.Y, Math.PI);\n                }\n            });\n            handShader.dispose();\n            resolve({ left: riggedMeshes.left, right: riggedMeshes.right });\n        });\n    }\n    /**\n     * Generates a mapping from XRHandJoint to bone name for the default hand mesh.\n     * @param handedness The handedness being mapped for.\n     */\n    static _GenerateDefaultHandMeshRigMapping(handedness) {\n        const H = handedness == \"right\" ? \"R\" : \"L\";\n        return {\n            [WebXRHandJoint.WRIST]: `wrist_${H}`,\n            [WebXRHandJoint.THUMB_METACARPAL]: `thumb_metacarpal_${H}`,\n            [WebXRHandJoint.THUMB_PHALANX_PROXIMAL]: `thumb_proxPhalanx_${H}`,\n            [WebXRHandJoint.THUMB_PHALANX_DISTAL]: `thumb_distPhalanx_${H}`,\n            [WebXRHandJoint.THUMB_TIP]: `thumb_tip_${H}`,\n            [WebXRHandJoint.INDEX_FINGER_METACARPAL]: `index_metacarpal_${H}`,\n            [WebXRHandJoint.INDEX_FINGER_PHALANX_PROXIMAL]: `index_proxPhalanx_${H}`,\n            [WebXRHandJoint.INDEX_FINGER_PHALANX_INTERMEDIATE]: `index_intPhalanx_${H}`,\n            [WebXRHandJoint.INDEX_FINGER_PHALANX_DISTAL]: `index_distPhalanx_${H}`,\n            [WebXRHandJoint.INDEX_FINGER_TIP]: `index_tip_${H}`,\n            [WebXRHandJoint.MIDDLE_FINGER_METACARPAL]: `middle_metacarpal_${H}`,\n            [WebXRHandJoint.MIDDLE_FINGER_PHALANX_PROXIMAL]: `middle_proxPhalanx_${H}`,\n            [WebXRHandJoint.MIDDLE_FINGER_PHALANX_INTERMEDIATE]: `middle_intPhalanx_${H}`,\n            [WebXRHandJoint.MIDDLE_FINGER_PHALANX_DISTAL]: `middle_distPhalanx_${H}`,\n            [WebXRHandJoint.MIDDLE_FINGER_TIP]: `middle_tip_${H}`,\n            [WebXRHandJoint.RING_FINGER_METACARPAL]: `ring_metacarpal_${H}`,\n            [WebXRHandJoint.RING_FINGER_PHALANX_PROXIMAL]: `ring_proxPhalanx_${H}`,\n            [WebXRHandJoint.RING_FINGER_PHALANX_INTERMEDIATE]: `ring_intPhalanx_${H}`,\n            [WebXRHandJoint.RING_FINGER_PHALANX_DISTAL]: `ring_distPhalanx_${H}`,\n            [WebXRHandJoint.RING_FINGER_TIP]: `ring_tip_${H}`,\n            [WebXRHandJoint.PINKY_FINGER_METACARPAL]: `little_metacarpal_${H}`,\n            [WebXRHandJoint.PINKY_FINGER_PHALANX_PROXIMAL]: `little_proxPhalanx_${H}`,\n            [WebXRHandJoint.PINKY_FINGER_PHALANX_INTERMEDIATE]: `little_intPhalanx_${H}`,\n            [WebXRHandJoint.PINKY_FINGER_PHALANX_DISTAL]: `little_distPhalanx_${H}`,\n            [WebXRHandJoint.PINKY_FINGER_TIP]: `little_tip_${H}`,\n        };\n    }\n    /**\n     * Check if the needed objects are defined.\n     * This does not mean that the feature is enabled, but that the objects needed are well defined.\n     */\n    isCompatible() {\n        return typeof XRHand !== \"undefined\";\n    }\n    /**\n     * Get the hand object according to the controller id\n     * @param controllerId the controller id to which we want to get the hand\n     * @returns null if not found or the WebXRHand object if found\n     */\n    getHandByControllerId(controllerId) {\n        return this._attachedHands[controllerId];\n    }\n    /**\n     * Get a hand object according to the requested handedness\n     * @param handedness the handedness to request\n     * @returns null if not found or the WebXRHand object if found\n     */\n    getHandByHandedness(handedness) {\n        if (handedness == \"none\") {\n            return null;\n        }\n        return this._trackingHands[handedness];\n    }\n    /**\n     * Creates a new instance of the XR hand tracking feature.\n     * @param _xrSessionManager An instance of WebXRSessionManager.\n     * @param options Options to use when constructing this feature.\n     */\n    constructor(_xrSessionManager, \n    /** Options to use when constructing this feature. */\n    options) {\n        super(_xrSessionManager);\n        this.options = options;\n        this._attachedHands = {};\n        this._trackingHands = { left: null, right: null };\n        this._handResources = { jointMeshes: null, handMeshes: null, rigMappings: null };\n        /**\n         * This observable will notify registered observers when a new hand object was added and initialized\n         */\n        this.onHandAddedObservable = new Observable();\n        /**\n         * This observable will notify its observers right before the hand object is disposed\n         */\n        this.onHandRemovedObservable = new Observable();\n        this._attachHand = (xrController) => {\n            var _a, _b, _c;\n            if (!xrController.inputSource.hand || xrController.inputSource.handedness == \"none\" || !this._handResources.jointMeshes) {\n                return;\n            }\n            const handedness = xrController.inputSource.handedness;\n            const webxrHand = new WebXRHand(xrController, this._handResources.jointMeshes[handedness], this._handResources.handMeshes && this._handResources.handMeshes[handedness], this._handResources.rigMappings && this._handResources.rigMappings[handedness], (_a = this.options.handMeshes) === null || _a === void 0 ? void 0 : _a.meshesUseLeftHandedCoordinates, (_b = this.options.jointMeshes) === null || _b === void 0 ? void 0 : _b.invisible, (_c = this.options.jointMeshes) === null || _c === void 0 ? void 0 : _c.scaleFactor);\n            this._attachedHands[xrController.uniqueId] = webxrHand;\n            this._trackingHands[handedness] = webxrHand;\n            this.onHandAddedObservable.notifyObservers(webxrHand);\n        };\n        this._detachHand = (xrController) => {\n            this._detachHandById(xrController.uniqueId);\n        };\n        this.xrNativeFeatureName = \"hand-tracking\";\n        // Support legacy versions of the options object by copying over joint mesh properties\n        const anyOptions = options;\n        const anyJointMeshOptions = anyOptions.jointMeshes;\n        if (anyJointMeshOptions) {\n            if (typeof anyJointMeshOptions.disableDefaultHandMesh !== \"undefined\") {\n                options.handMeshes = options.handMeshes || {};\n                options.handMeshes.disableDefaultMeshes = anyJointMeshOptions.disableDefaultHandMesh;\n            }\n            if (typeof anyJointMeshOptions.handMeshes !== \"undefined\") {\n                options.handMeshes = options.handMeshes || {};\n                options.handMeshes.customMeshes = anyJointMeshOptions.handMeshes;\n            }\n            if (typeof anyJointMeshOptions.leftHandedSystemMeshes !== \"undefined\") {\n                options.handMeshes = options.handMeshes || {};\n                options.handMeshes.meshesUseLeftHandedCoordinates = anyJointMeshOptions.leftHandedSystemMeshes;\n            }\n            if (typeof anyJointMeshOptions.rigMapping !== \"undefined\") {\n                options.handMeshes = options.handMeshes || {};\n                const leftRigMapping = {};\n                const rightRigMapping = {};\n                [\n                    [anyJointMeshOptions.rigMapping.left, leftRigMapping],\n                    [anyJointMeshOptions.rigMapping.right, rightRigMapping],\n                ].forEach((rigMappingTuple) => {\n                    const legacyRigMapping = rigMappingTuple[0];\n                    const rigMapping = rigMappingTuple[1];\n                    legacyRigMapping.forEach((modelJointName, index) => {\n                        rigMapping[handJointReferenceArray[index]] = modelJointName;\n                    });\n                });\n                options.handMeshes.customRigMappings = {\n                    left: leftRigMapping,\n                    right: rightRigMapping,\n                };\n            }\n        }\n    }\n    /**\n     * Attach this feature.\n     * Will usually be called by the features manager.\n     *\n     * @returns true if successful.\n     */\n    attach() {\n        var _a, _b, _c, _d;\n        if (!super.attach()) {\n            return false;\n        }\n        this._handResources = {\n            jointMeshes: WebXRHandTracking._GenerateTrackedJointMeshes(this.options),\n            handMeshes: ((_a = this.options.handMeshes) === null || _a === void 0 ? void 0 : _a.customMeshes) || null,\n            rigMappings: ((_b = this.options.handMeshes) === null || _b === void 0 ? void 0 : _b.customRigMappings) || null,\n        };\n        // If they didn't supply custom meshes and are not disabling the default meshes...\n        if (!((_c = this.options.handMeshes) === null || _c === void 0 ? void 0 : _c.customMeshes) && !((_d = this.options.handMeshes) === null || _d === void 0 ? void 0 : _d.disableDefaultMeshes)) {\n            WebXRHandTracking._GenerateDefaultHandMeshesAsync(EngineStore.LastCreatedScene, this.options).then((defaultHandMeshes) => {\n                var _a, _b;\n                this._handResources.handMeshes = defaultHandMeshes;\n                this._handResources.rigMappings = {\n                    left: WebXRHandTracking._GenerateDefaultHandMeshRigMapping(\"left\"),\n                    right: WebXRHandTracking._GenerateDefaultHandMeshRigMapping(\"right\"),\n                };\n                // Apply meshes to existing hands if already tracking.\n                (_a = this._trackingHands.left) === null || _a === void 0 ? void 0 : _a.setHandMesh(this._handResources.handMeshes.left, this._handResources.rigMappings.left);\n                (_b = this._trackingHands.right) === null || _b === void 0 ? void 0 : _b.setHandMesh(this._handResources.handMeshes.right, this._handResources.rigMappings.right);\n            });\n        }\n        this.options.xrInput.controllers.forEach(this._attachHand);\n        this._addNewAttachObserver(this.options.xrInput.onControllerAddedObservable, this._attachHand);\n        this._addNewAttachObserver(this.options.xrInput.onControllerRemovedObservable, this._detachHand);\n        return true;\n    }\n    _onXRFrame(_xrFrame) {\n        var _a, _b;\n        (_a = this._trackingHands.left) === null || _a === void 0 ? void 0 : _a.updateFromXRFrame(_xrFrame, this._xrSessionManager.referenceSpace);\n        (_b = this._trackingHands.right) === null || _b === void 0 ? void 0 : _b.updateFromXRFrame(_xrFrame, this._xrSessionManager.referenceSpace);\n    }\n    _detachHandById(controllerId) {\n        var _a;\n        const hand = this.getHandByControllerId(controllerId);\n        if (hand) {\n            const handedness = hand.xrController.inputSource.handedness == \"left\" ? \"left\" : \"right\";\n            if (((_a = this._trackingHands[handedness]) === null || _a === void 0 ? void 0 : _a.xrController.uniqueId) === controllerId) {\n                this._trackingHands[handedness] = null;\n            }\n            this.onHandRemovedObservable.notifyObservers(hand);\n            hand.dispose();\n            delete this._attachedHands[controllerId];\n        }\n    }\n    /**\n     * Detach this feature.\n     * Will usually be called by the features manager.\n     *\n     * @returns true if successful.\n     */\n    detach() {\n        if (!super.detach()) {\n            return false;\n        }\n        Object.keys(this._attachedHands).forEach((uniqueId) => this._detachHandById(uniqueId));\n        return true;\n    }\n    /**\n     * Dispose this feature and all of the resources attached.\n     */\n    dispose() {\n        var _a;\n        super.dispose();\n        this.onHandAddedObservable.clear();\n        this.onHandRemovedObservable.clear();\n        if (this._handResources.handMeshes && !((_a = this.options.handMeshes) === null || _a === void 0 ? void 0 : _a.customMeshes)) {\n            // this will dispose the cached meshes\n            this._handResources.handMeshes.left.dispose();\n            this._handResources.handMeshes.right.dispose();\n            // remove the cached meshes\n            WebXRHandTracking._RightHandGLB = null;\n            WebXRHandTracking._LeftHandGLB = null;\n        }\n        if (this._handResources.jointMeshes) {\n            this._handResources.jointMeshes.left.forEach((trackedMesh) => trackedMesh.dispose());\n            this._handResources.jointMeshes.right.forEach((trackedMesh) => trackedMesh.dispose());\n        }\n    }\n}\n/**\n * The module's name\n */\nWebXRHandTracking.Name = WebXRFeatureName.HAND_TRACKING;\n/**\n * The (Babylon) version of this module.\n * This is an integer representing the implementation version.\n * This number does not correspond to the WebXR specs version\n */\nWebXRHandTracking.Version = 1;\n/** The base URL for the default hand model. */\nWebXRHandTracking.DEFAULT_HAND_MODEL_BASE_URL = \"https://assets.babylonjs.com/meshes/HandMeshes/\";\n/** The filename to use for the default right hand model. */\nWebXRHandTracking.DEFAULT_HAND_MODEL_RIGHT_FILENAME = \"r_hand_rhs.glb\";\n/** The filename to use for the default left hand model. */\nWebXRHandTracking.DEFAULT_HAND_MODEL_LEFT_FILENAME = \"l_hand_rhs.glb\";\n/** The URL pointing to the default hand model NodeMaterial shader. */\nWebXRHandTracking.DEFAULT_HAND_MODEL_SHADER_URL = \"https://assets.babylonjs.com/meshes/HandMeshes/handsShader.json\";\n// We want to use lightweight models, diameter will initially be 1 but scaled to the values returned from WebXR.\nWebXRHandTracking._ICOSPHERE_PARAMS = { radius: 0.5, flat: false, subdivisions: 2 };\nWebXRHandTracking._RightHandGLB = null;\nWebXRHandTracking._LeftHandGLB = null;\n//register the plugin\nWebXRFeaturesManager.AddWebXRFeature(WebXRHandTracking.Name, (xrSessionManager, options) => {\n    return () => new WebXRHandTracking(xrSessionManager, options);\n}, WebXRHandTracking.Version, false);\n//# sourceMappingURL=WebXRHandTracking.js.map","import { WebXRFeaturesManager, WebXRFeatureName } from \"../webXRFeaturesManager.js\";\nimport { CreateSphere } from \"../../Meshes/Builders/sphereBuilder.js\";\nimport { Vector3, Quaternion, TmpVectors } from \"../../Maths/math.vector.js\";\nimport { Ray } from \"../../Culling/ray.js\";\nimport { PickingInfo } from \"../../Collisions/pickingInfo.js\";\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature.js\";\nimport { UtilityLayerRenderer } from \"../../Rendering/utilityLayerRenderer.js\";\nimport { BoundingSphere } from \"../../Culling/boundingSphere.js\";\nimport { StandardMaterial } from \"../../Materials/standardMaterial.js\";\nimport { Color3 } from \"../../Maths/math.color.js\";\nimport { NodeMaterial } from \"../../Materials/Node/nodeMaterial.js\";\nimport { Animation } from \"../../Animations/animation.js\";\nimport { QuadraticEase, EasingFunction } from \"../../Animations/easing.js\";\n// side effects\nimport \"../../Meshes/subMesh.project.js\";\n// Tracks the interaction animation state when using a motion controller with a near interaction orb\nvar ControllerOrbAnimationState;\n(function (ControllerOrbAnimationState) {\n    /**\n     * Orb is invisible\n     */\n    ControllerOrbAnimationState[ControllerOrbAnimationState[\"DEHYDRATED\"] = 0] = \"DEHYDRATED\";\n    /**\n     * Orb is visible and inside the hover range\n     */\n    ControllerOrbAnimationState[ControllerOrbAnimationState[\"HOVER\"] = 1] = \"HOVER\";\n    /**\n     * Orb is visible and touching a near interaction target\n     */\n    ControllerOrbAnimationState[ControllerOrbAnimationState[\"TOUCH\"] = 2] = \"TOUCH\";\n})(ControllerOrbAnimationState || (ControllerOrbAnimationState = {}));\n/**\n * Where should the near interaction mesh be attached to when using a motion controller for near interaction\n */\nexport var WebXRNearControllerMode;\n(function (WebXRNearControllerMode) {\n    /**\n     * Motion controllers will not support near interaction\n     */\n    WebXRNearControllerMode[WebXRNearControllerMode[\"DISABLED\"] = 0] = \"DISABLED\";\n    /**\n     * The interaction point for motion controllers will be inside of them\n     */\n    WebXRNearControllerMode[WebXRNearControllerMode[\"CENTERED_ON_CONTROLLER\"] = 1] = \"CENTERED_ON_CONTROLLER\";\n    /**\n     * The interaction point for motion controllers will be in front of the controller\n     */\n    WebXRNearControllerMode[WebXRNearControllerMode[\"CENTERED_IN_FRONT\"] = 2] = \"CENTERED_IN_FRONT\";\n})(WebXRNearControllerMode || (WebXRNearControllerMode = {}));\n/**\n * A module that will enable near interaction near interaction for hands and motion controllers of XR Input Sources\n */\nexport class WebXRNearInteraction extends WebXRAbstractFeature {\n    /**\n     * constructs a new background remover module\n     * @param _xrSessionManager the session manager for this module\n     * @param _options read-only options to be used in this module\n     */\n    constructor(_xrSessionManager, _options) {\n        super(_xrSessionManager);\n        this._options = _options;\n        this._tmpRay = new Ray(new Vector3(), new Vector3());\n        this._attachController = (xrController) => {\n            if (this._controllers[xrController.uniqueId]) {\n                // already attached\n                return;\n            }\n            // get two new meshes\n            const { touchCollisionMesh, touchCollisionMeshFunction, hydrateCollisionMeshFunction } = this._generateNewTouchPointMesh();\n            const selectionMesh = this._generateVisualCue();\n            this._controllers[xrController.uniqueId] = {\n                xrController,\n                meshUnderPointer: null,\n                nearInteractionTargetMesh: null,\n                pick: null,\n                stalePick: null,\n                touchCollisionMesh,\n                touchCollisionMeshFunction: touchCollisionMeshFunction,\n                hydrateCollisionMeshFunction: hydrateCollisionMeshFunction,\n                currentAnimationState: ControllerOrbAnimationState.DEHYDRATED,\n                grabRay: new Ray(new Vector3(), new Vector3()),\n                hoverInteraction: false,\n                nearInteraction: false,\n                grabInteraction: false,\n                id: WebXRNearInteraction._IdCounter++,\n                pickedPointVisualCue: selectionMesh,\n            };\n            if (this._attachedController) {\n                if (!this._options.enableNearInteractionOnAllControllers &&\n                    this._options.preferredHandedness &&\n                    xrController.inputSource.handedness === this._options.preferredHandedness) {\n                    this._attachedController = xrController.uniqueId;\n                }\n            }\n            else {\n                if (!this._options.enableNearInteractionOnAllControllers) {\n                    this._attachedController = xrController.uniqueId;\n                }\n            }\n            switch (xrController.inputSource.targetRayMode) {\n                case \"tracked-pointer\":\n                    return this._attachNearInteractionMode(xrController);\n                case \"gaze\":\n                    return null;\n                case \"screen\":\n                    return null;\n            }\n        };\n        this._controllers = {};\n        this._farInteractionFeature = null;\n        /**\n         * default color of the selection ring\n         */\n        this.selectionMeshDefaultColor = new Color3(0.8, 0.8, 0.8);\n        /**\n         * This color will be applied to the selection ring when selection is triggered\n         */\n        this.selectionMeshPickedColor = new Color3(0.3, 0.3, 1.0);\n        this._hoverRadius = 0.1;\n        this._pickRadius = 0.02;\n        this._controllerPickRadius = 0.03; // The radius is slightly larger here to make it easier to manipulate since it's not tied to the hand position\n        this._nearGrabLengthScale = 5;\n        this._scene = this._xrSessionManager.scene;\n        if (this._options.nearInteractionControllerMode === undefined) {\n            this._options.nearInteractionControllerMode = WebXRNearControllerMode.CENTERED_IN_FRONT;\n        }\n        if (this._options.farInteractionFeature) {\n            this._farInteractionFeature = this._options.farInteractionFeature;\n        }\n    }\n    /**\n     * Attach this feature\n     * Will usually be called by the features manager\n     *\n     * @returns true if successful.\n     */\n    attach() {\n        if (!super.attach()) {\n            return false;\n        }\n        this._options.xrInput.controllers.forEach(this._attachController);\n        this._addNewAttachObserver(this._options.xrInput.onControllerAddedObservable, this._attachController);\n        this._addNewAttachObserver(this._options.xrInput.onControllerRemovedObservable, (controller) => {\n            // REMOVE the controller\n            this._detachController(controller.uniqueId);\n        });\n        this._scene.constantlyUpdateMeshUnderPointer = true;\n        return true;\n    }\n    /**\n     * Detach this feature.\n     * Will usually be called by the features manager\n     *\n     * @returns true if successful.\n     */\n    detach() {\n        if (!super.detach()) {\n            return false;\n        }\n        Object.keys(this._controllers).forEach((controllerId) => {\n            this._detachController(controllerId);\n        });\n        return true;\n    }\n    /**\n     * Will get the mesh under a specific pointer.\n     * `scene.meshUnderPointer` will only return one mesh - either left or right.\n     * @param controllerId the controllerId to check\n     * @returns The mesh under pointer or null if no mesh is under the pointer\n     */\n    getMeshUnderPointer(controllerId) {\n        if (this._controllers[controllerId]) {\n            return this._controllers[controllerId].meshUnderPointer;\n        }\n        else {\n            return null;\n        }\n    }\n    /**\n     * Get the xr controller that correlates to the pointer id in the pointer event\n     *\n     * @param id the pointer id to search for\n     * @returns the controller that correlates to this id or null if not found\n     */\n    getXRControllerByPointerId(id) {\n        const keys = Object.keys(this._controllers);\n        for (let i = 0; i < keys.length; ++i) {\n            if (this._controllers[keys[i]].id === id) {\n                return this._controllers[keys[i]].xrController || null;\n            }\n        }\n        return null;\n    }\n    /**\n     * This function sets webXRControllerPointerSelection feature that will be disabled when\n     * the hover range is reached for a mesh and will be reattached when not in hover range.\n     * This is used to remove the selection rays when moving.\n     * @param farInteractionFeature the feature to disable when finger is in hover range for a mesh\n     */\n    setFarInteractionFeature(farInteractionFeature) {\n        this._farInteractionFeature = farInteractionFeature;\n    }\n    /**\n     * Filter used for near interaction pick and hover\n     * @param mesh\n     */\n    _nearPickPredicate(mesh) {\n        return mesh.isEnabled() && mesh.isVisible && mesh.isPickable && mesh.isNearPickable;\n    }\n    /**\n     * Filter used for near interaction grab\n     * @param mesh\n     */\n    _nearGrabPredicate(mesh) {\n        return mesh.isEnabled() && mesh.isVisible && mesh.isPickable && mesh.isNearGrabbable;\n    }\n    /**\n     * Filter used for any near interaction\n     * @param mesh\n     */\n    _nearInteractionPredicate(mesh) {\n        return mesh.isEnabled() && mesh.isVisible && mesh.isPickable && (mesh.isNearPickable || mesh.isNearGrabbable);\n    }\n    _controllerAvailablePredicate(mesh, controllerId) {\n        let parent = mesh;\n        while (parent) {\n            if (parent.reservedDataStore && parent.reservedDataStore.nearInteraction && parent.reservedDataStore.nearInteraction.excludedControllerId === controllerId) {\n                return false;\n            }\n            parent = parent.parent;\n        }\n        return true;\n    }\n    _handleTransitionAnimation(controllerData, newState) {\n        var _a;\n        if (controllerData.currentAnimationState === newState ||\n            this._options.nearInteractionControllerMode !== WebXRNearControllerMode.CENTERED_IN_FRONT ||\n            !!((_a = controllerData.xrController) === null || _a === void 0 ? void 0 : _a.inputSource.hand)) {\n            return;\n        }\n        // Don't always break to allow for animation fallthrough on rare cases of multi-transitions\n        if (newState > controllerData.currentAnimationState) {\n            switch (controllerData.currentAnimationState) {\n                case ControllerOrbAnimationState.DEHYDRATED: {\n                    controllerData.hydrateCollisionMeshFunction(true);\n                    if (newState === ControllerOrbAnimationState.HOVER) {\n                        break;\n                    }\n                }\n                // eslint-disable-next-line no-fallthrough\n                case ControllerOrbAnimationState.HOVER: {\n                    controllerData.touchCollisionMeshFunction(true);\n                    if (newState === ControllerOrbAnimationState.TOUCH) {\n                        break;\n                    }\n                }\n            }\n        }\n        else {\n            switch (controllerData.currentAnimationState) {\n                case ControllerOrbAnimationState.TOUCH: {\n                    controllerData.touchCollisionMeshFunction(false);\n                    if (newState === ControllerOrbAnimationState.HOVER) {\n                        break;\n                    }\n                }\n                // eslint-disable-next-line no-fallthrough\n                case ControllerOrbAnimationState.HOVER: {\n                    controllerData.hydrateCollisionMeshFunction(false);\n                    if (newState === ControllerOrbAnimationState.DEHYDRATED) {\n                        break;\n                    }\n                }\n            }\n        }\n        controllerData.currentAnimationState = newState;\n    }\n    _processTouchPoint(id, position, orientation) {\n        var _a;\n        const controllerData = this._controllers[id];\n        // Position and orientation could be temporary values, se we take care of them before calling any functions that use temporary vectors/quaternions\n        controllerData.grabRay.origin.copyFrom(position);\n        orientation.toEulerAnglesToRef(TmpVectors.Vector3[0]);\n        controllerData.grabRay.direction.copyFrom(TmpVectors.Vector3[0]);\n        if (this._options.nearInteractionControllerMode === WebXRNearControllerMode.CENTERED_IN_FRONT && !((_a = controllerData.xrController) === null || _a === void 0 ? void 0 : _a.inputSource.hand)) {\n            // offset the touch point in the direction the transform is facing\n            controllerData.xrController.getWorldPointerRayToRef(this._tmpRay);\n            controllerData.grabRay.origin.addInPlace(this._tmpRay.direction.scale(0.05));\n        }\n        controllerData.grabRay.length = this._nearGrabLengthScale * this._hoverRadius;\n        controllerData.touchCollisionMesh.position.copyFrom(controllerData.grabRay.origin);\n    }\n    _onXRFrame(_xrFrame) {\n        Object.keys(this._controllers).forEach((id) => {\n            var _a;\n            // only do this for the selected pointer\n            const controllerData = this._controllers[id];\n            const handData = (_a = controllerData.xrController) === null || _a === void 0 ? void 0 : _a.inputSource.hand;\n            // If near interaction is not enabled/available for this controller, return early\n            if ((!this._options.enableNearInteractionOnAllControllers && id !== this._attachedController) ||\n                !controllerData.xrController ||\n                (!handData && (!this._options.nearInteractionControllerMode || !controllerData.xrController.inputSource.gamepad))) {\n                controllerData.pick = null;\n                return;\n            }\n            controllerData.hoverInteraction = false;\n            controllerData.nearInteraction = false;\n            // Every frame check collisions/input\n            if (controllerData.xrController) {\n                if (handData) {\n                    const xrIndexTip = handData.get(\"index-finger-tip\");\n                    if (xrIndexTip) {\n                        const indexTipPose = _xrFrame.getJointPose(xrIndexTip, this._xrSessionManager.referenceSpace);\n                        if (indexTipPose && indexTipPose.transform) {\n                            const axisRHSMultiplier = this._scene.useRightHandedSystem ? 1 : -1;\n                            TmpVectors.Vector3[0].set(indexTipPose.transform.position.x, indexTipPose.transform.position.y, indexTipPose.transform.position.z * axisRHSMultiplier);\n                            TmpVectors.Quaternion[0].set(indexTipPose.transform.orientation.x, indexTipPose.transform.orientation.y, indexTipPose.transform.orientation.z * axisRHSMultiplier, indexTipPose.transform.orientation.w * axisRHSMultiplier);\n                            this._processTouchPoint(id, TmpVectors.Vector3[0], TmpVectors.Quaternion[0]);\n                        }\n                    }\n                }\n                else if (controllerData.xrController.inputSource.gamepad && this._options.nearInteractionControllerMode !== WebXRNearControllerMode.DISABLED) {\n                    let controllerPose = controllerData.xrController.pointer;\n                    if (controllerData.xrController.grip && this._options.nearInteractionControllerMode === WebXRNearControllerMode.CENTERED_ON_CONTROLLER) {\n                        controllerPose = controllerData.xrController.grip;\n                    }\n                    this._processTouchPoint(id, controllerPose.position, controllerPose.rotationQuaternion);\n                }\n            }\n            else {\n                return;\n            }\n            const accuratePickInfo = (originalScenePick, utilityScenePick) => {\n                let pick = null;\n                if (!utilityScenePick || !utilityScenePick.hit) {\n                    // No hit in utility scene\n                    pick = originalScenePick;\n                }\n                else if (!originalScenePick || !originalScenePick.hit) {\n                    // No hit in original scene\n                    pick = utilityScenePick;\n                }\n                else if (utilityScenePick.distance < originalScenePick.distance) {\n                    // Hit is closer in utility scene\n                    pick = utilityScenePick;\n                }\n                else {\n                    // Hit is closer in original scene\n                    pick = originalScenePick;\n                }\n                return pick;\n            };\n            const populateNearInteractionInfo = (nearInteractionInfo) => {\n                let result = new PickingInfo();\n                let nearInteractionAtOrigin = false;\n                const nearInteraction = nearInteractionInfo && nearInteractionInfo.pickedPoint && nearInteractionInfo.hit;\n                if (nearInteractionInfo === null || nearInteractionInfo === void 0 ? void 0 : nearInteractionInfo.pickedPoint) {\n                    nearInteractionAtOrigin = nearInteractionInfo.pickedPoint.x === 0 && nearInteractionInfo.pickedPoint.y === 0 && nearInteractionInfo.pickedPoint.z === 0;\n                }\n                if (nearInteraction && !nearInteractionAtOrigin) {\n                    result = nearInteractionInfo;\n                }\n                return result;\n            };\n            // Don't perform touch logic while grabbing, to prevent triggering touch interactions while in the middle of a grab interaction\n            // Dont update cursor logic either - the cursor should already be visible for the grab to be in range,\n            // and in order to maintain its position on the target mesh it is parented for the duration of the grab.\n            if (!controllerData.grabInteraction) {\n                let pick = null;\n                // near interaction hover\n                let utilitySceneHoverPick = null;\n                if (this._options.useUtilityLayer && this._utilityLayerScene) {\n                    utilitySceneHoverPick = this._pickWithSphere(controllerData, this._hoverRadius, this._utilityLayerScene, (mesh) => this._nearInteractionPredicate(mesh));\n                }\n                const originalSceneHoverPick = this._pickWithSphere(controllerData, this._hoverRadius, this._scene, (mesh) => this._nearInteractionPredicate(mesh));\n                const hoverPickInfo = accuratePickInfo(originalSceneHoverPick, utilitySceneHoverPick);\n                if (hoverPickInfo && hoverPickInfo.hit) {\n                    pick = populateNearInteractionInfo(hoverPickInfo);\n                    if (pick.hit) {\n                        controllerData.hoverInteraction = true;\n                    }\n                }\n                // near interaction pick\n                if (controllerData.hoverInteraction) {\n                    let utilitySceneNearPick = null;\n                    const radius = handData ? this._pickRadius : this._controllerPickRadius;\n                    if (this._options.useUtilityLayer && this._utilityLayerScene) {\n                        utilitySceneNearPick = this._pickWithSphere(controllerData, radius, this._utilityLayerScene, (mesh) => this._nearPickPredicate(mesh));\n                    }\n                    const originalSceneNearPick = this._pickWithSphere(controllerData, radius, this._scene, (mesh) => this._nearPickPredicate(mesh));\n                    const pickInfo = accuratePickInfo(originalSceneNearPick, utilitySceneNearPick);\n                    const nearPick = populateNearInteractionInfo(pickInfo);\n                    if (nearPick.hit) {\n                        // Near pick takes precedence over hover interaction\n                        pick = nearPick;\n                        controllerData.nearInteraction = true;\n                    }\n                }\n                controllerData.stalePick = controllerData.pick;\n                controllerData.pick = pick;\n                // Update mesh under pointer\n                if (controllerData.pick && controllerData.pick.pickedPoint && controllerData.pick.hit) {\n                    controllerData.meshUnderPointer = controllerData.pick.pickedMesh;\n                    controllerData.pickedPointVisualCue.position.copyFrom(controllerData.pick.pickedPoint);\n                    controllerData.pickedPointVisualCue.isVisible = true;\n                    if (this._farInteractionFeature && this._farInteractionFeature.attached) {\n                        this._farInteractionFeature._setPointerSelectionDisabledByPointerId(controllerData.id, true);\n                    }\n                }\n                else {\n                    controllerData.meshUnderPointer = null;\n                    controllerData.pickedPointVisualCue.isVisible = false;\n                    if (this._farInteractionFeature && this._farInteractionFeature.attached) {\n                        this._farInteractionFeature._setPointerSelectionDisabledByPointerId(controllerData.id, false);\n                    }\n                }\n            }\n            // Update the interaction animation. Only updates if the visible touch mesh is active\n            let state = ControllerOrbAnimationState.DEHYDRATED;\n            if (controllerData.grabInteraction || controllerData.nearInteraction) {\n                state = ControllerOrbAnimationState.TOUCH;\n            }\n            else if (controllerData.hoverInteraction) {\n                state = ControllerOrbAnimationState.HOVER;\n            }\n            this._handleTransitionAnimation(controllerData, state);\n        });\n    }\n    get _utilityLayerScene() {\n        return this._options.customUtilityLayerScene || UtilityLayerRenderer.DefaultUtilityLayer.utilityLayerScene;\n    }\n    _generateVisualCue() {\n        const sceneToRenderTo = this._options.useUtilityLayer ? this._options.customUtilityLayerScene || UtilityLayerRenderer.DefaultUtilityLayer.utilityLayerScene : this._scene;\n        const selectionMesh = CreateSphere(\"nearInteraction\", {\n            diameter: 0.0035 * 3,\n        }, sceneToRenderTo);\n        selectionMesh.bakeCurrentTransformIntoVertices();\n        selectionMesh.isPickable = false;\n        selectionMesh.isVisible = false;\n        selectionMesh.rotationQuaternion = Quaternion.Identity();\n        const targetMat = new StandardMaterial(\"targetMat\", sceneToRenderTo);\n        targetMat.specularColor = Color3.Black();\n        targetMat.emissiveColor = this.selectionMeshDefaultColor;\n        targetMat.backFaceCulling = false;\n        selectionMesh.material = targetMat;\n        return selectionMesh;\n    }\n    _isControllerReadyForNearInteraction(id) {\n        if (this._farInteractionFeature) {\n            return this._farInteractionFeature._getPointerSelectionDisabledByPointerId(id);\n        }\n        return true;\n    }\n    _attachNearInteractionMode(xrController) {\n        const controllerData = this._controllers[xrController.uniqueId];\n        const pointerEventInit = {\n            pointerId: controllerData.id,\n            pointerType: \"xr-near\",\n        };\n        controllerData.onFrameObserver = this._xrSessionManager.onXRFrameObservable.add(() => {\n            if ((!this._options.enableNearInteractionOnAllControllers && xrController.uniqueId !== this._attachedController) ||\n                !controllerData.xrController ||\n                (!controllerData.xrController.inputSource.hand && (!this._options.nearInteractionControllerMode || !controllerData.xrController.inputSource.gamepad))) {\n                return;\n            }\n            if (controllerData.pick) {\n                controllerData.pick.ray = controllerData.grabRay;\n            }\n            if (controllerData.pick && this._isControllerReadyForNearInteraction(controllerData.id)) {\n                this._scene.simulatePointerMove(controllerData.pick, pointerEventInit);\n            }\n            // Near pick pointer event\n            if (controllerData.nearInteraction && controllerData.pick && controllerData.pick.hit) {\n                if (!controllerData.nearInteractionTargetMesh) {\n                    this._scene.simulatePointerDown(controllerData.pick, pointerEventInit);\n                    controllerData.nearInteractionTargetMesh = controllerData.meshUnderPointer;\n                }\n            }\n            else if (controllerData.nearInteractionTargetMesh && controllerData.stalePick) {\n                this._scene.simulatePointerUp(controllerData.stalePick, pointerEventInit);\n                controllerData.nearInteractionTargetMesh = null;\n            }\n        });\n        const grabCheck = (pressed) => {\n            if (this._options.enableNearInteractionOnAllControllers ||\n                (xrController.uniqueId === this._attachedController && this._isControllerReadyForNearInteraction(controllerData.id))) {\n                if (controllerData.pick) {\n                    controllerData.pick.ray = controllerData.grabRay;\n                }\n                if (pressed && controllerData.pick && controllerData.meshUnderPointer && this._nearGrabPredicate(controllerData.meshUnderPointer)) {\n                    controllerData.grabInteraction = true;\n                    controllerData.pickedPointVisualCue.isVisible = false;\n                    this._scene.simulatePointerDown(controllerData.pick, pointerEventInit);\n                }\n                else if (!pressed && controllerData.pick && controllerData.grabInteraction) {\n                    this._scene.simulatePointerUp(controllerData.pick, pointerEventInit);\n                    controllerData.grabInteraction = false;\n                    controllerData.pickedPointVisualCue.isVisible = true;\n                }\n            }\n            else {\n                if (pressed && !this._options.enableNearInteractionOnAllControllers && !this._options.disableSwitchOnClick) {\n                    this._attachedController = xrController.uniqueId;\n                }\n            }\n        };\n        if (xrController.inputSource.gamepad) {\n            const init = (motionController) => {\n                controllerData.squeezeComponent = motionController.getComponent(\"grasp\");\n                if (controllerData.squeezeComponent) {\n                    controllerData.onSqueezeButtonChangedObserver = controllerData.squeezeComponent.onButtonStateChangedObservable.add((component) => {\n                        if (component.changes.pressed) {\n                            const pressed = component.changes.pressed.current;\n                            grabCheck(pressed);\n                        }\n                    });\n                }\n                else {\n                    controllerData.selectionComponent = motionController.getMainComponent();\n                    controllerData.onButtonChangedObserver = controllerData.selectionComponent.onButtonStateChangedObservable.add((component) => {\n                        if (component.changes.pressed) {\n                            const pressed = component.changes.pressed.current;\n                            grabCheck(pressed);\n                        }\n                    });\n                }\n            };\n            if (xrController.motionController) {\n                init(xrController.motionController);\n            }\n            else {\n                xrController.onMotionControllerInitObservable.add(init);\n            }\n        }\n        else {\n            // use the select and squeeze events\n            const selectStartListener = (event) => {\n                if (controllerData.xrController &&\n                    event.inputSource === controllerData.xrController.inputSource &&\n                    controllerData.pick &&\n                    this._isControllerReadyForNearInteraction(controllerData.id) &&\n                    controllerData.meshUnderPointer &&\n                    this._nearGrabPredicate(controllerData.meshUnderPointer)) {\n                    controllerData.grabInteraction = true;\n                    controllerData.pickedPointVisualCue.isVisible = false;\n                    this._scene.simulatePointerDown(controllerData.pick, pointerEventInit);\n                }\n            };\n            const selectEndListener = (event) => {\n                if (controllerData.xrController &&\n                    event.inputSource === controllerData.xrController.inputSource &&\n                    controllerData.pick &&\n                    this._isControllerReadyForNearInteraction(controllerData.id)) {\n                    this._scene.simulatePointerUp(controllerData.pick, pointerEventInit);\n                    controllerData.grabInteraction = false;\n                    controllerData.pickedPointVisualCue.isVisible = true;\n                }\n            };\n            controllerData.eventListeners = {\n                selectend: selectEndListener,\n                selectstart: selectStartListener,\n            };\n            this._xrSessionManager.session.addEventListener(\"selectstart\", selectStartListener);\n            this._xrSessionManager.session.addEventListener(\"selectend\", selectEndListener);\n        }\n    }\n    _detachController(xrControllerUniqueId) {\n        const controllerData = this._controllers[xrControllerUniqueId];\n        if (!controllerData) {\n            return;\n        }\n        if (controllerData.squeezeComponent) {\n            if (controllerData.onSqueezeButtonChangedObserver) {\n                controllerData.squeezeComponent.onButtonStateChangedObservable.remove(controllerData.onSqueezeButtonChangedObserver);\n            }\n        }\n        if (controllerData.selectionComponent) {\n            if (controllerData.onButtonChangedObserver) {\n                controllerData.selectionComponent.onButtonStateChangedObservable.remove(controllerData.onButtonChangedObserver);\n            }\n        }\n        if (controllerData.onFrameObserver) {\n            this._xrSessionManager.onXRFrameObservable.remove(controllerData.onFrameObserver);\n        }\n        if (controllerData.eventListeners) {\n            Object.keys(controllerData.eventListeners).forEach((eventName) => {\n                const func = controllerData.eventListeners && controllerData.eventListeners[eventName];\n                if (func) {\n                    this._xrSessionManager.session.removeEventListener(eventName, func);\n                }\n            });\n        }\n        controllerData.touchCollisionMesh.dispose();\n        controllerData.pickedPointVisualCue.dispose();\n        this._xrSessionManager.runInXRFrame(() => {\n            // Fire a pointerup\n            const pointerEventInit = {\n                pointerId: controllerData.id,\n                pointerType: \"xr-near\",\n            };\n            this._scene.simulatePointerUp(new PickingInfo(), pointerEventInit);\n        });\n        // remove from the map\n        delete this._controllers[xrControllerUniqueId];\n        if (this._attachedController === xrControllerUniqueId) {\n            // check for other controllers\n            const keys = Object.keys(this._controllers);\n            if (keys.length) {\n                this._attachedController = keys[0];\n            }\n            else {\n                this._attachedController = \"\";\n            }\n        }\n    }\n    _generateNewTouchPointMesh() {\n        // populate information for near hover, pick and pinch\n        const meshCreationScene = this._options.useUtilityLayer ? this._options.customUtilityLayerScene || UtilityLayerRenderer.DefaultUtilityLayer.utilityLayerScene : this._scene;\n        const touchCollisionMesh = CreateSphere(\"PickSphere\", { diameter: 1 }, meshCreationScene);\n        touchCollisionMesh.isVisible = false;\n        // Generate the material for the touch mesh visuals\n        if (this._options.motionControllerOrbMaterial) {\n            touchCollisionMesh.material = this._options.motionControllerOrbMaterial;\n        }\n        else {\n            NodeMaterial.ParseFromSnippetAsync(\"8RUNKL#3\", meshCreationScene).then((nodeMaterial) => {\n                touchCollisionMesh.material = nodeMaterial;\n            });\n        }\n        const easingFunction = new QuadraticEase();\n        easingFunction.setEasingMode(EasingFunction.EASINGMODE_EASEINOUT);\n        // Adjust the visual size based off of the size of the touch collision orb.\n        // Having the size perfectly match for hover gives a more accurate tell for when the user will start interacting with the target\n        // Sizes for other states are somewhat arbitrary, as they are based on what feels nice during an interaction\n        const hoverSizeVec = new Vector3(this._controllerPickRadius, this._controllerPickRadius, this._controllerPickRadius);\n        const touchSize = this._controllerPickRadius * (4 / 3);\n        const touchSizeVec = new Vector3(touchSize, touchSize, touchSize);\n        const hydrateTransitionSize = this._controllerPickRadius * (7 / 6);\n        const hydrateTransitionSizeVec = new Vector3(hydrateTransitionSize, hydrateTransitionSize, hydrateTransitionSize);\n        const touchHoverTransitionSize = this._controllerPickRadius * (4 / 5);\n        const touchHoverTransitionSizeVec = new Vector3(touchHoverTransitionSize, touchHoverTransitionSize, touchHoverTransitionSize);\n        const hoverTouchTransitionSize = this._controllerPickRadius * (3 / 2);\n        const hoverTouchTransitionSizeVec = new Vector3(hoverTouchTransitionSize, hoverTouchTransitionSize, hoverTouchTransitionSize);\n        const touchKeys = [\n            { frame: 0, value: hoverSizeVec },\n            { frame: 10, value: hoverTouchTransitionSizeVec },\n            { frame: 18, value: touchSizeVec },\n        ];\n        const releaseKeys = [\n            { frame: 0, value: touchSizeVec },\n            { frame: 10, value: touchHoverTransitionSizeVec },\n            { frame: 18, value: hoverSizeVec },\n        ];\n        const hydrateKeys = [\n            { frame: 0, value: Vector3.ZeroReadOnly },\n            { frame: 12, value: hydrateTransitionSizeVec },\n            { frame: 15, value: hoverSizeVec },\n        ];\n        const dehydrateKeys = [\n            { frame: 0, value: hoverSizeVec },\n            { frame: 10, value: Vector3.ZeroReadOnly },\n            { frame: 15, value: Vector3.ZeroReadOnly },\n        ];\n        const touchAction = new Animation(\"touch\", \"scaling\", 60, Animation.ANIMATIONTYPE_VECTOR3, Animation.ANIMATIONLOOPMODE_CONSTANT);\n        const releaseAction = new Animation(\"release\", \"scaling\", 60, Animation.ANIMATIONTYPE_VECTOR3, Animation.ANIMATIONLOOPMODE_CONSTANT);\n        const hydrateAction = new Animation(\"hydrate\", \"scaling\", 60, Animation.ANIMATIONTYPE_VECTOR3, Animation.ANIMATIONLOOPMODE_CONSTANT);\n        const dehydrateAction = new Animation(\"dehydrate\", \"scaling\", 60, Animation.ANIMATIONTYPE_VECTOR3, Animation.ANIMATIONLOOPMODE_CONSTANT);\n        touchAction.setEasingFunction(easingFunction);\n        releaseAction.setEasingFunction(easingFunction);\n        hydrateAction.setEasingFunction(easingFunction);\n        dehydrateAction.setEasingFunction(easingFunction);\n        touchAction.setKeys(touchKeys);\n        releaseAction.setKeys(releaseKeys);\n        hydrateAction.setKeys(hydrateKeys);\n        dehydrateAction.setKeys(dehydrateKeys);\n        const touchCollisionMeshFunction = (isTouch) => {\n            const action = isTouch ? touchAction : releaseAction;\n            meshCreationScene.beginDirectAnimation(touchCollisionMesh, [action], 0, 18, false, 1);\n        };\n        const hydrateCollisionMeshFunction = (isHydration) => {\n            const action = isHydration ? hydrateAction : dehydrateAction;\n            if (isHydration) {\n                touchCollisionMesh.isVisible = true;\n            }\n            meshCreationScene.beginDirectAnimation(touchCollisionMesh, [action], 0, 15, false, 1, () => {\n                if (!isHydration) {\n                    touchCollisionMesh.isVisible = false;\n                }\n            });\n        };\n        return { touchCollisionMesh, touchCollisionMeshFunction, hydrateCollisionMeshFunction };\n    }\n    _pickWithSphere(controllerData, radius, sceneToUse, predicate) {\n        const pickingInfo = new PickingInfo();\n        pickingInfo.distance = +Infinity;\n        if (controllerData.touchCollisionMesh && controllerData.xrController) {\n            const position = controllerData.touchCollisionMesh.position;\n            const sphere = BoundingSphere.CreateFromCenterAndRadius(position, radius);\n            for (let meshIndex = 0; meshIndex < sceneToUse.meshes.length; meshIndex++) {\n                const mesh = sceneToUse.meshes[meshIndex];\n                if (!predicate(mesh) || !this._controllerAvailablePredicate(mesh, controllerData.xrController.uniqueId)) {\n                    continue;\n                }\n                const result = WebXRNearInteraction.PickMeshWithSphere(mesh, sphere);\n                if (result && result.hit && result.distance < pickingInfo.distance) {\n                    pickingInfo.hit = result.hit;\n                    pickingInfo.pickedMesh = mesh;\n                    pickingInfo.pickedPoint = result.pickedPoint;\n                    pickingInfo.aimTransform = controllerData.xrController.pointer;\n                    pickingInfo.gripTransform = controllerData.xrController.grip || null;\n                    pickingInfo.originMesh = controllerData.touchCollisionMesh;\n                    pickingInfo.distance = result.distance;\n                }\n            }\n        }\n        return pickingInfo;\n    }\n    /**\n     * Picks a mesh with a sphere\n     * @param mesh the mesh to pick\n     * @param sphere picking sphere in world coordinates\n     * @param skipBoundingInfo a boolean indicating if we should skip the bounding info check\n     * @returns the picking info\n     */\n    static PickMeshWithSphere(mesh, sphere, skipBoundingInfo = false) {\n        const subMeshes = mesh.subMeshes;\n        const pi = new PickingInfo();\n        const boundingInfo = mesh.getBoundingInfo();\n        if (!mesh._generatePointsArray()) {\n            return pi;\n        }\n        if (!mesh.subMeshes || !boundingInfo) {\n            return pi;\n        }\n        if (!skipBoundingInfo && !BoundingSphere.Intersects(boundingInfo.boundingSphere, sphere)) {\n            return pi;\n        }\n        const result = TmpVectors.Vector3[0];\n        const tmpVec = TmpVectors.Vector3[1];\n        let distance = +Infinity;\n        let tmp, tmpDistanceSphereToCenter, tmpDistanceSurfaceToCenter;\n        const center = TmpVectors.Vector3[2];\n        const worldToMesh = TmpVectors.Matrix[0];\n        worldToMesh.copyFrom(mesh.getWorldMatrix());\n        worldToMesh.invert();\n        Vector3.TransformCoordinatesToRef(sphere.center, worldToMesh, center);\n        for (let index = 0; index < subMeshes.length; index++) {\n            const subMesh = subMeshes[index];\n            subMesh.projectToRef(center, mesh._positions, mesh.getIndices(), tmpVec);\n            Vector3.TransformCoordinatesToRef(tmpVec, mesh.getWorldMatrix(), tmpVec);\n            tmp = Vector3.Distance(tmpVec, sphere.center);\n            // Check for finger inside of mesh\n            tmpDistanceSurfaceToCenter = Vector3.Distance(tmpVec, mesh.getAbsolutePosition());\n            tmpDistanceSphereToCenter = Vector3.Distance(sphere.center, mesh.getAbsolutePosition());\n            if (tmpDistanceSphereToCenter !== -1 && tmpDistanceSurfaceToCenter !== -1 && tmpDistanceSurfaceToCenter > tmpDistanceSphereToCenter) {\n                tmp = 0;\n                tmpVec.copyFrom(sphere.center);\n            }\n            if (tmp !== -1 && tmp < distance) {\n                distance = tmp;\n                result.copyFrom(tmpVec);\n            }\n        }\n        if (distance < sphere.radius) {\n            pi.hit = true;\n            pi.distance = distance;\n            pi.pickedMesh = mesh;\n            pi.pickedPoint = result.clone();\n        }\n        return pi;\n    }\n}\nWebXRNearInteraction._IdCounter = 200;\n/**\n * The module's name\n */\nWebXRNearInteraction.Name = WebXRFeatureName.NEAR_INTERACTION;\n/**\n * The (Babylon) version of this module.\n * This is an integer representing the implementation version.\n * This number does not correspond to the WebXR specs version\n */\nWebXRNearInteraction.Version = 1;\n//Register the plugin\nWebXRFeaturesManager.AddWebXRFeature(WebXRNearInteraction.Name, (xrSessionManager, options) => {\n    return () => new WebXRNearInteraction(xrSessionManager, options);\n}, WebXRNearInteraction.Version, true);\n//# sourceMappingURL=WebXRNearInteraction.js.map","import { WebXRFeaturesManager, WebXRFeatureName } from \"../webXRFeaturesManager.js\";\nimport { Observable } from \"../../Misc/observable.js\";\nimport { Vector3, Matrix } from \"../../Maths/math.vector.js\";\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature.js\";\nimport { Tools } from \"../../Misc/tools.js\";\n/**\n * The currently-working hit-test module.\n * Hit test (or Ray-casting) is used to interact with the real world.\n * For further information read here - https://github.com/immersive-web/hit-test\n */\nexport class WebXRHitTestLegacy extends WebXRAbstractFeature {\n    /**\n     * Creates a new instance of the (legacy version) hit test feature\n     * @param _xrSessionManager an instance of WebXRSessionManager\n     * @param options options to use when constructing this feature\n     */\n    constructor(_xrSessionManager, \n    /**\n     * options to use when constructing this feature\n     */\n    options = {}) {\n        super(_xrSessionManager);\n        this.options = options;\n        // in XR space z-forward is negative\n        this._direction = new Vector3(0, 0, -1);\n        this._mat = new Matrix();\n        this._onSelectEnabled = false;\n        this._origin = new Vector3(0, 0, 0);\n        /**\n         * Populated with the last native XR Hit Results\n         */\n        this.lastNativeXRHitResults = [];\n        /**\n         * Triggered when new babylon (transformed) hit test results are available\n         */\n        this.onHitTestResultObservable = new Observable();\n        this._onHitTestResults = (xrResults) => {\n            const mats = xrResults.map((result) => {\n                const mat = Matrix.FromArray(result.hitMatrix);\n                if (!this._xrSessionManager.scene.useRightHandedSystem) {\n                    mat.toggleModelMatrixHandInPlace();\n                }\n                // if (this.options.coordinatesSpace === Space.WORLD) {\n                if (this.options.worldParentNode) {\n                    mat.multiplyToRef(this.options.worldParentNode.getWorldMatrix(), mat);\n                }\n                return {\n                    xrHitResult: result,\n                    transformationMatrix: mat,\n                };\n            });\n            this.lastNativeXRHitResults = xrResults;\n            this.onHitTestResultObservable.notifyObservers(mats);\n        };\n        // can be done using pointerdown event, and xrSessionManager.currentFrame\n        this._onSelect = (event) => {\n            if (!this._onSelectEnabled) {\n                return;\n            }\n            WebXRHitTestLegacy.XRHitTestWithSelectEvent(event, this._xrSessionManager.referenceSpace);\n        };\n        this.xrNativeFeatureName = \"hit-test\";\n        Tools.Warn(\"A newer version of this plugin is available\");\n    }\n    /**\n     * execute a hit test with an XR Ray\n     *\n     * @param xrSession a native xrSession that will execute this hit test\n     * @param xrRay the ray (position and direction) to use for ray-casting\n     * @param referenceSpace native XR reference space to use for the hit-test\n     * @param filter filter function that will filter the results\n     * @returns a promise that resolves with an array of native XR hit result in xr coordinates system\n     */\n    static XRHitTestWithRay(xrSession, xrRay, referenceSpace, filter) {\n        return xrSession.requestHitTest(xrRay, referenceSpace).then((results) => {\n            const filterFunction = filter || ((result) => !!result.hitMatrix);\n            return results.filter(filterFunction);\n        });\n    }\n    /**\n     * Execute a hit test on the current running session using a select event returned from a transient input (such as touch)\n     * @param event the (select) event to use to select with\n     * @param referenceSpace the reference space to use for this hit test\n     * @returns a promise that resolves with an array of native XR hit result in xr coordinates system\n     */\n    static XRHitTestWithSelectEvent(event, referenceSpace) {\n        const targetRayPose = event.frame.getPose(event.inputSource.targetRaySpace, referenceSpace);\n        if (!targetRayPose) {\n            return Promise.resolve([]);\n        }\n        const targetRay = new XRRay(targetRayPose.transform);\n        return this.XRHitTestWithRay(event.frame.session, targetRay, referenceSpace);\n    }\n    /**\n     * attach this feature\n     * Will usually be called by the features manager\n     *\n     * @returns true if successful.\n     */\n    attach() {\n        if (!super.attach()) {\n            return false;\n        }\n        if (this.options.testOnPointerDownOnly) {\n            this._xrSessionManager.session.addEventListener(\"select\", this._onSelect, false);\n        }\n        return true;\n    }\n    /**\n     * detach this feature.\n     * Will usually be called by the features manager\n     *\n     * @returns true if successful.\n     */\n    detach() {\n        if (!super.detach()) {\n            return false;\n        }\n        // disable select\n        this._onSelectEnabled = false;\n        this._xrSessionManager.session.removeEventListener(\"select\", this._onSelect);\n        return true;\n    }\n    /**\n     * Dispose this feature and all of the resources attached\n     */\n    dispose() {\n        super.dispose();\n        this.onHitTestResultObservable.clear();\n    }\n    _onXRFrame(frame) {\n        // make sure we do nothing if (async) not attached\n        if (!this.attached || this.options.testOnPointerDownOnly) {\n            return;\n        }\n        const pose = frame.getViewerPose(this._xrSessionManager.referenceSpace);\n        if (!pose) {\n            return;\n        }\n        Matrix.FromArrayToRef(pose.transform.matrix, 0, this._mat);\n        Vector3.TransformCoordinatesFromFloatsToRef(0, 0, 0, this._mat, this._origin);\n        Vector3.TransformCoordinatesFromFloatsToRef(0, 0, -1, this._mat, this._direction);\n        this._direction.subtractInPlace(this._origin);\n        this._direction.normalize();\n        const ray = new XRRay({ x: this._origin.x, y: this._origin.y, z: this._origin.z, w: 0 }, { x: this._direction.x, y: this._direction.y, z: this._direction.z, w: 0 });\n        WebXRHitTestLegacy.XRHitTestWithRay(this._xrSessionManager.session, ray, this._xrSessionManager.referenceSpace).then(this._onHitTestResults);\n    }\n}\n/**\n * The module's name\n */\nWebXRHitTestLegacy.Name = WebXRFeatureName.HIT_TEST;\n/**\n * The (Babylon) version of this module.\n * This is an integer representing the implementation version.\n * This number does not correspond to the WebXR specs version\n */\nWebXRHitTestLegacy.Version = 1;\n//register the plugin versions\nWebXRFeaturesManager.AddWebXRFeature(WebXRHitTestLegacy.Name, (xrSessionManager, options) => {\n    return () => new WebXRHitTestLegacy(xrSessionManager, options);\n}, WebXRHitTestLegacy.Version, false);\n//# sourceMappingURL=WebXRHitTestLegacy.js.map","import { WebXRFeatureName, WebXRFeaturesManager } from \"../webXRFeaturesManager.js\";\nimport { Observable } from \"../../Misc/observable.js\";\nimport { Matrix, Vector3, Quaternion } from \"../../Maths/math.vector.js\";\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature.js\";\nimport { Tools } from \"../../Misc/tools.js\";\nlet anchorIdProvider = 0;\n/**\n * An implementation of the anchor system for WebXR.\n * For further information see https://github.com/immersive-web/anchors/\n */\nexport class WebXRAnchorSystem extends WebXRAbstractFeature {\n    /**\n     * Set the reference space to use for anchor creation, when not using a hit test.\n     * Will default to the session's reference space if not defined\n     */\n    set referenceSpaceForFrameAnchors(referenceSpace) {\n        this._referenceSpaceForFrameAnchors = referenceSpace;\n    }\n    /**\n     * constructs a new anchor system\n     * @param _xrSessionManager an instance of WebXRSessionManager\n     * @param _options configuration object for this feature\n     */\n    constructor(_xrSessionManager, _options = {}) {\n        super(_xrSessionManager);\n        this._options = _options;\n        this._lastFrameDetected = new Set();\n        this._trackedAnchors = [];\n        this._futureAnchors = [];\n        /**\n         * Observers registered here will be executed when a new anchor was added to the session\n         */\n        this.onAnchorAddedObservable = new Observable();\n        /**\n         * Observers registered here will be executed when an anchor was removed from the session\n         */\n        this.onAnchorRemovedObservable = new Observable();\n        /**\n         * Observers registered here will be executed when an existing anchor updates\n         * This can execute N times every frame\n         */\n        this.onAnchorUpdatedObservable = new Observable();\n        this._tmpVector = new Vector3();\n        this._tmpQuaternion = new Quaternion();\n        this.xrNativeFeatureName = \"anchors\";\n    }\n    _populateTmpTransformation(position, rotationQuaternion) {\n        this._tmpVector.copyFrom(position);\n        this._tmpQuaternion.copyFrom(rotationQuaternion);\n        if (!this._xrSessionManager.scene.useRightHandedSystem) {\n            this._tmpVector.z *= -1;\n            this._tmpQuaternion.z *= -1;\n            this._tmpQuaternion.w *= -1;\n        }\n        return {\n            position: this._tmpVector,\n            rotationQuaternion: this._tmpQuaternion,\n        };\n    }\n    /**\n     * Create a new anchor point using a hit test result at a specific point in the scene\n     * An anchor is tracked only after it is added to the trackerAnchors in xrFrame. The promise returned here does not yet guaranty that.\n     * Use onAnchorAddedObservable to get newly added anchors if you require tracking guaranty.\n     *\n     * @param hitTestResult The hit test result to use for this anchor creation\n     * @param position an optional position offset for this anchor\n     * @param rotationQuaternion an optional rotation offset for this anchor\n     * @returns A promise that fulfills when babylon has created the corresponding WebXRAnchor object and tracking has begun\n     */\n    async addAnchorPointUsingHitTestResultAsync(hitTestResult, position = new Vector3(), rotationQuaternion = new Quaternion()) {\n        // convert to XR space (right handed) if needed\n        this._populateTmpTransformation(position, rotationQuaternion);\n        // the matrix that we'll use\n        const m = new XRRigidTransform({ x: this._tmpVector.x, y: this._tmpVector.y, z: this._tmpVector.z }, { x: this._tmpQuaternion.x, y: this._tmpQuaternion.y, z: this._tmpQuaternion.z, w: this._tmpQuaternion.w });\n        if (!hitTestResult.xrHitResult.createAnchor) {\n            this.detach();\n            throw new Error(\"Anchors not enabled in this environment/browser\");\n        }\n        else {\n            try {\n                const nativeAnchor = await hitTestResult.xrHitResult.createAnchor(m);\n                return new Promise((resolve, reject) => {\n                    this._futureAnchors.push({\n                        nativeAnchor,\n                        resolved: false,\n                        submitted: true,\n                        xrTransformation: m,\n                        resolve,\n                        reject,\n                    });\n                });\n            }\n            catch (error) {\n                throw new Error(error);\n            }\n        }\n    }\n    /**\n     * Add a new anchor at a specific position and rotation\n     * This function will add a new anchor per default in the next available frame. Unless forced, the createAnchor function\n     * will be called in the next xrFrame loop to make sure that the anchor can be created correctly.\n     * An anchor is tracked only after it is added to the trackerAnchors in xrFrame. The promise returned here does not yet guaranty that.\n     * Use onAnchorAddedObservable to get newly added anchors if you require tracking guaranty.\n     *\n     * @param position the position in which to add an anchor\n     * @param rotationQuaternion an optional rotation for the anchor transformation\n     * @param forceCreateInCurrentFrame force the creation of this anchor in the current frame. Must be called inside xrFrame loop!\n     * @returns A promise that fulfills when babylon has created the corresponding WebXRAnchor object and tracking has begun\n     */\n    async addAnchorAtPositionAndRotationAsync(position, rotationQuaternion = new Quaternion(), forceCreateInCurrentFrame = false) {\n        // convert to XR space (right handed) if needed\n        this._populateTmpTransformation(position, rotationQuaternion);\n        // the matrix that we'll use\n        const xrTransformation = new XRRigidTransform({ x: this._tmpVector.x, y: this._tmpVector.y, z: this._tmpVector.z }, { x: this._tmpQuaternion.x, y: this._tmpQuaternion.y, z: this._tmpQuaternion.z, w: this._tmpQuaternion.w });\n        const xrAnchor = forceCreateInCurrentFrame && this.attached && this._xrSessionManager.currentFrame\n            ? await this._createAnchorAtTransformation(xrTransformation, this._xrSessionManager.currentFrame)\n            : undefined;\n        // add the transformation to the future anchors list\n        return new Promise((resolve, reject) => {\n            this._futureAnchors.push({\n                nativeAnchor: xrAnchor,\n                resolved: false,\n                submitted: false,\n                xrTransformation,\n                resolve,\n                reject,\n            });\n        });\n    }\n    /**\n     * Get the list of anchors currently being tracked by the system\n     */\n    get anchors() {\n        return this._trackedAnchors;\n    }\n    /**\n     * detach this feature.\n     * Will usually be called by the features manager\n     *\n     * @returns true if successful.\n     */\n    detach() {\n        if (!super.detach()) {\n            return false;\n        }\n        if (!this._options.doNotRemoveAnchorsOnSessionEnded) {\n            while (this._trackedAnchors.length) {\n                const toRemove = this._trackedAnchors.pop();\n                if (toRemove) {\n                    try {\n                        // try to natively remove it as well\n                        toRemove.remove();\n                    }\n                    catch (e) {\n                        // no-op\n                    }\n                    // as the xr frame loop is removed, we need to notify manually\n                    this.onAnchorRemovedObservable.notifyObservers(toRemove);\n                }\n            }\n        }\n        return true;\n    }\n    /**\n     * Dispose this feature and all of the resources attached\n     */\n    dispose() {\n        this._futureAnchors.length = 0;\n        super.dispose();\n        this.onAnchorAddedObservable.clear();\n        this.onAnchorRemovedObservable.clear();\n        this.onAnchorUpdatedObservable.clear();\n    }\n    _onXRFrame(frame) {\n        if (!this.attached || !frame) {\n            return;\n        }\n        const trackedAnchors = frame.trackedAnchors;\n        if (trackedAnchors) {\n            const toRemove = this._trackedAnchors\n                .filter((anchor) => !trackedAnchors.has(anchor.xrAnchor))\n                .map((anchor) => {\n                const index = this._trackedAnchors.indexOf(anchor);\n                return index;\n            });\n            let idxTracker = 0;\n            toRemove.forEach((index) => {\n                const anchor = this._trackedAnchors.splice(index - idxTracker, 1)[0];\n                this.onAnchorRemovedObservable.notifyObservers(anchor);\n                idxTracker++;\n            });\n            // now check for new ones\n            trackedAnchors.forEach((xrAnchor) => {\n                if (!this._lastFrameDetected.has(xrAnchor)) {\n                    const newAnchor = {\n                        id: anchorIdProvider++,\n                        xrAnchor: xrAnchor,\n                        remove: () => xrAnchor.delete(),\n                    };\n                    const anchor = this._updateAnchorWithXRFrame(xrAnchor, newAnchor, frame);\n                    this._trackedAnchors.push(anchor);\n                    this.onAnchorAddedObservable.notifyObservers(anchor);\n                    // search for the future anchor promise that matches this\n                    const results = this._futureAnchors.filter((futureAnchor) => futureAnchor.nativeAnchor === xrAnchor);\n                    const result = results[0];\n                    if (result) {\n                        result.resolve(anchor);\n                        result.resolved = true;\n                    }\n                }\n                else {\n                    const index = this._findIndexInAnchorArray(xrAnchor);\n                    const anchor = this._trackedAnchors[index];\n                    try {\n                        // anchors update every frame\n                        this._updateAnchorWithXRFrame(xrAnchor, anchor, frame);\n                        if (anchor.attachedNode) {\n                            anchor.attachedNode.rotationQuaternion = anchor.attachedNode.rotationQuaternion || new Quaternion();\n                            anchor.transformationMatrix.decompose(anchor.attachedNode.scaling, anchor.attachedNode.rotationQuaternion, anchor.attachedNode.position);\n                        }\n                        this.onAnchorUpdatedObservable.notifyObservers(anchor);\n                    }\n                    catch (e) {\n                        Tools.Warn(`Anchor could not be updated`);\n                    }\n                }\n            });\n            this._lastFrameDetected = trackedAnchors;\n        }\n        // process future anchors\n        this._futureAnchors.forEach((futureAnchor) => {\n            if (!futureAnchor.resolved && !futureAnchor.submitted) {\n                this._createAnchorAtTransformation(futureAnchor.xrTransformation, frame).then((nativeAnchor) => {\n                    futureAnchor.nativeAnchor = nativeAnchor;\n                }, (error) => {\n                    futureAnchor.resolved = true;\n                    futureAnchor.reject(error);\n                });\n                futureAnchor.submitted = true;\n            }\n        });\n    }\n    /**\n     * avoiding using Array.find for global support.\n     * @param xrAnchor the plane to find in the array\n     */\n    _findIndexInAnchorArray(xrAnchor) {\n        for (let i = 0; i < this._trackedAnchors.length; ++i) {\n            if (this._trackedAnchors[i].xrAnchor === xrAnchor) {\n                return i;\n            }\n        }\n        return -1;\n    }\n    _updateAnchorWithXRFrame(xrAnchor, anchor, xrFrame) {\n        // matrix\n        const pose = xrFrame.getPose(xrAnchor.anchorSpace, this._xrSessionManager.referenceSpace);\n        if (pose) {\n            const mat = anchor.transformationMatrix || new Matrix();\n            Matrix.FromArrayToRef(pose.transform.matrix, 0, mat);\n            if (!this._xrSessionManager.scene.useRightHandedSystem) {\n                mat.toggleModelMatrixHandInPlace();\n            }\n            anchor.transformationMatrix = mat;\n            if (!this._options.worldParentNode) {\n                // Logger.Warn(\"Please provide a world parent node to apply world transformation\");\n            }\n            else {\n                mat.multiplyToRef(this._options.worldParentNode.getWorldMatrix(), mat);\n            }\n        }\n        return anchor;\n    }\n    async _createAnchorAtTransformation(xrTransformation, xrFrame) {\n        var _a;\n        if (xrFrame.createAnchor) {\n            try {\n                return xrFrame.createAnchor(xrTransformation, (_a = this._referenceSpaceForFrameAnchors) !== null && _a !== void 0 ? _a : this._xrSessionManager.referenceSpace);\n            }\n            catch (error) {\n                throw new Error(error);\n            }\n        }\n        else {\n            this.detach();\n            throw new Error(\"Anchors are not enabled in your browser\");\n        }\n    }\n}\n/**\n * The module's name\n */\nWebXRAnchorSystem.Name = WebXRFeatureName.ANCHOR_SYSTEM;\n/**\n * The (Babylon) version of this module.\n * This is an integer representing the implementation version.\n * This number does not correspond to the WebXR specs version\n */\nWebXRAnchorSystem.Version = 1;\n// register the plugin\nWebXRFeaturesManager.AddWebXRFeature(WebXRAnchorSystem.Name, (xrSessionManager, options) => {\n    return () => new WebXRAnchorSystem(xrSessionManager, options);\n}, WebXRAnchorSystem.Version);\n//# sourceMappingURL=WebXRAnchorSystem.js.map","import { WebXRFeaturesManager, WebXRFeatureName } from \"../webXRFeaturesManager.js\";\nimport { Observable } from \"../../Misc/observable.js\";\nimport { Vector3, Matrix } from \"../../Maths/math.vector.js\";\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature.js\";\nlet planeIdProvider = 0;\n/**\n * The plane detector is used to detect planes in the real world when in AR\n * For more information see https://github.com/immersive-web/real-world-geometry/\n */\nexport class WebXRPlaneDetector extends WebXRAbstractFeature {\n    /**\n     * construct a new Plane Detector\n     * @param _xrSessionManager an instance of xr Session manager\n     * @param _options configuration to use when constructing this feature\n     */\n    constructor(_xrSessionManager, _options = {}) {\n        super(_xrSessionManager);\n        this._options = _options;\n        this._detectedPlanes = [];\n        this._enabled = false;\n        this._lastFrameDetected = new Set();\n        /**\n         * Observers registered here will be executed when a new plane was added to the session\n         */\n        this.onPlaneAddedObservable = new Observable();\n        /**\n         * Observers registered here will be executed when a plane is no longer detected in the session\n         */\n        this.onPlaneRemovedObservable = new Observable();\n        /**\n         * Observers registered here will be executed when an existing plane updates (for example - expanded)\n         * This can execute N times every frame\n         */\n        this.onPlaneUpdatedObservable = new Observable();\n        this.xrNativeFeatureName = \"plane-detection\";\n        if (this._xrSessionManager.session) {\n            this._init();\n        }\n        else {\n            this._xrSessionManager.onXRSessionInit.addOnce(() => {\n                this._init();\n            });\n        }\n    }\n    /**\n     * detach this feature.\n     * Will usually be called by the features manager\n     *\n     * @returns true if successful.\n     */\n    detach() {\n        if (!super.detach()) {\n            return false;\n        }\n        if (!this._options.doNotRemovePlanesOnSessionEnded) {\n            while (this._detectedPlanes.length) {\n                const toRemove = this._detectedPlanes.pop();\n                if (toRemove) {\n                    this.onPlaneRemovedObservable.notifyObservers(toRemove);\n                }\n            }\n        }\n        return true;\n    }\n    /**\n     * Dispose this feature and all of the resources attached\n     */\n    dispose() {\n        super.dispose();\n        this.onPlaneAddedObservable.clear();\n        this.onPlaneRemovedObservable.clear();\n        this.onPlaneUpdatedObservable.clear();\n    }\n    /**\n     * Check if the needed objects are defined.\n     * This does not mean that the feature is enabled, but that the objects needed are well defined.\n     */\n    isCompatible() {\n        return typeof XRPlane !== \"undefined\";\n    }\n    _onXRFrame(frame) {\n        var _a;\n        if (!this.attached || !this._enabled || !frame) {\n            return;\n        }\n        const detectedPlanes = frame.detectedPlanes || ((_a = frame.worldInformation) === null || _a === void 0 ? void 0 : _a.detectedPlanes);\n        if (detectedPlanes) {\n            // remove all planes that are not currently detected in the frame\n            for (let planeIdx = 0; planeIdx < this._detectedPlanes.length; planeIdx++) {\n                const plane = this._detectedPlanes[planeIdx];\n                if (!detectedPlanes.has(plane.xrPlane)) {\n                    this._detectedPlanes.splice(planeIdx--, 1);\n                    this.onPlaneRemovedObservable.notifyObservers(plane);\n                }\n            }\n            // now check for new ones\n            detectedPlanes.forEach((xrPlane) => {\n                if (!this._lastFrameDetected.has(xrPlane)) {\n                    const newPlane = {\n                        id: planeIdProvider++,\n                        xrPlane: xrPlane,\n                        polygonDefinition: [],\n                    };\n                    const plane = this._updatePlaneWithXRPlane(xrPlane, newPlane, frame);\n                    this._detectedPlanes.push(plane);\n                    this.onPlaneAddedObservable.notifyObservers(plane);\n                }\n                else {\n                    // updated?\n                    if (xrPlane.lastChangedTime === this._xrSessionManager.currentTimestamp) {\n                        const index = this._findIndexInPlaneArray(xrPlane);\n                        const plane = this._detectedPlanes[index];\n                        this._updatePlaneWithXRPlane(xrPlane, plane, frame);\n                        this.onPlaneUpdatedObservable.notifyObservers(plane);\n                    }\n                }\n            });\n            this._lastFrameDetected = detectedPlanes;\n        }\n    }\n    _init() {\n        const internalInit = () => {\n            this._enabled = true;\n            if (this._detectedPlanes.length) {\n                this._detectedPlanes.length = 0;\n            }\n        };\n        // Only supported by BabylonNative\n        if (!!this._xrSessionManager.isNative && !!this._options.preferredDetectorOptions && !!this._xrSessionManager.session.trySetPreferredPlaneDetectorOptions) {\n            this._xrSessionManager.session.trySetPreferredPlaneDetectorOptions(this._options.preferredDetectorOptions);\n        }\n        if (!this._xrSessionManager.session.updateWorldTrackingState) {\n            internalInit();\n            return;\n        }\n        this._xrSessionManager.session.updateWorldTrackingState({ planeDetectionState: { enabled: true } });\n        internalInit();\n    }\n    _updatePlaneWithXRPlane(xrPlane, plane, xrFrame) {\n        plane.polygonDefinition = xrPlane.polygon.map((xrPoint) => {\n            const rightHandedSystem = this._xrSessionManager.scene.useRightHandedSystem ? 1 : -1;\n            return new Vector3(xrPoint.x, xrPoint.y, xrPoint.z * rightHandedSystem);\n        });\n        // matrix\n        const pose = xrFrame.getPose(xrPlane.planeSpace, this._xrSessionManager.referenceSpace);\n        if (pose) {\n            const mat = plane.transformationMatrix || new Matrix();\n            Matrix.FromArrayToRef(pose.transform.matrix, 0, mat);\n            if (!this._xrSessionManager.scene.useRightHandedSystem) {\n                mat.toggleModelMatrixHandInPlace();\n            }\n            plane.transformationMatrix = mat;\n            if (this._options.worldParentNode) {\n                mat.multiplyToRef(this._options.worldParentNode.getWorldMatrix(), mat);\n            }\n        }\n        return plane;\n    }\n    /**\n     * avoiding using Array.find for global support.\n     * @param xrPlane the plane to find in the array\n     */\n    _findIndexInPlaneArray(xrPlane) {\n        for (let i = 0; i < this._detectedPlanes.length; ++i) {\n            if (this._detectedPlanes[i].xrPlane === xrPlane) {\n                return i;\n            }\n        }\n        return -1;\n    }\n}\n/**\n * The module's name\n */\nWebXRPlaneDetector.Name = WebXRFeatureName.PLANE_DETECTION;\n/**\n * The (Babylon) version of this module.\n * This is an integer representing the implementation version.\n * This number does not correspond to the WebXR specs version\n */\nWebXRPlaneDetector.Version = 1;\n//register the plugin\nWebXRFeaturesManager.AddWebXRFeature(WebXRPlaneDetector.Name, (xrSessionManager, options) => {\n    return () => new WebXRPlaneDetector(xrSessionManager, options);\n}, WebXRPlaneDetector.Version);\n//# sourceMappingURL=WebXRPlaneDetector.js.map","import { WebXRFeaturesManager, WebXRFeatureName } from \"../webXRFeaturesManager.js\";\nimport { Observable } from \"../../Misc/observable.js\";\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature.js\";\n/**\n * A module that will automatically disable background meshes when entering AR and will enable them when leaving AR.\n */\nexport class WebXRBackgroundRemover extends WebXRAbstractFeature {\n    /**\n     * constructs a new background remover module\n     * @param _xrSessionManager the session manager for this module\n     * @param options read-only options to be used in this module\n     */\n    constructor(_xrSessionManager, \n    /**\n     * read-only options to be used in this module\n     */\n    options = {}) {\n        super(_xrSessionManager);\n        this.options = options;\n        /**\n         * registered observers will be triggered when the background state changes\n         */\n        this.onBackgroundStateChangedObservable = new Observable();\n    }\n    /**\n     * attach this feature\n     * Will usually be called by the features manager\n     *\n     * @returns true if successful.\n     */\n    attach() {\n        this._setBackgroundState(false);\n        return super.attach();\n    }\n    /**\n     * detach this feature.\n     * Will usually be called by the features manager\n     *\n     * @returns true if successful.\n     */\n    detach() {\n        this._setBackgroundState(true);\n        return super.detach();\n    }\n    /**\n     * Dispose this feature and all of the resources attached\n     */\n    dispose() {\n        super.dispose();\n        this.onBackgroundStateChangedObservable.clear();\n    }\n    _onXRFrame(_xrFrame) {\n        // no-op\n    }\n    _setBackgroundState(newState) {\n        const scene = this._xrSessionManager.scene;\n        if (!this.options.ignoreEnvironmentHelper) {\n            if (this.options.environmentHelperRemovalFlags) {\n                if (this.options.environmentHelperRemovalFlags.skyBox) {\n                    const backgroundSkybox = scene.getMeshByName(\"BackgroundSkybox\");\n                    if (backgroundSkybox) {\n                        backgroundSkybox.setEnabled(newState);\n                    }\n                }\n                if (this.options.environmentHelperRemovalFlags.ground) {\n                    const backgroundPlane = scene.getMeshByName(\"BackgroundPlane\");\n                    if (backgroundPlane) {\n                        backgroundPlane.setEnabled(newState);\n                    }\n                }\n            }\n            else {\n                const backgroundHelper = scene.getMeshByName(\"BackgroundHelper\");\n                if (backgroundHelper) {\n                    backgroundHelper.setEnabled(newState);\n                }\n            }\n        }\n        if (this.options.backgroundMeshes) {\n            this.options.backgroundMeshes.forEach((mesh) => mesh.setEnabled(newState));\n        }\n        this.onBackgroundStateChangedObservable.notifyObservers(newState);\n    }\n}\n/**\n * The module's name\n */\nWebXRBackgroundRemover.Name = WebXRFeatureName.BACKGROUND_REMOVER;\n/**\n * The (Babylon) version of this module.\n * This is an integer representing the implementation version.\n * This number does not correspond to the WebXR specs version\n */\nWebXRBackgroundRemover.Version = 1;\n//register the plugin\nWebXRFeaturesManager.AddWebXRFeature(WebXRBackgroundRemover.Name, (xrSessionManager, options) => {\n    return () => new WebXRBackgroundRemover(xrSessionManager, options);\n}, WebXRBackgroundRemover.Version, true);\n//# sourceMappingURL=WebXRBackgroundRemover.js.map","import { WebXRAbstractFeature } from \"./WebXRAbstractFeature.js\";\nimport { Vector3, Quaternion } from \"../../Maths/math.vector.js\";\nimport { PhysicsImpostor } from \"../../Physics/v1/physicsImpostor.js\";\nimport { CreateSphere } from \"../../Meshes/Builders/sphereBuilder.js\";\nimport { WebXRFeatureName, WebXRFeaturesManager } from \"../webXRFeaturesManager.js\";\nimport { Logger } from \"../../Misc/logger.js\";\n/**\n * Options for the controller physics feature\n */\nexport class IWebXRControllerPhysicsOptions {\n}\n/**\n * Add physics impostor to your webxr controllers,\n * including naive calculation of their linear and angular velocity\n */\nexport class WebXRControllerPhysics extends WebXRAbstractFeature {\n    _createPhysicsImpostor(xrController) {\n        const impostorType = this._options.physicsProperties.impostorType || PhysicsImpostor.SphereImpostor;\n        const impostorSize = this._options.physicsProperties.impostorSize || 0.1;\n        const impostorMesh = CreateSphere(\"impostor-mesh-\" + xrController.uniqueId, {\n            diameterX: typeof impostorSize === \"number\" ? impostorSize : impostorSize.width,\n            diameterY: typeof impostorSize === \"number\" ? impostorSize : impostorSize.height,\n            diameterZ: typeof impostorSize === \"number\" ? impostorSize : impostorSize.depth,\n        });\n        impostorMesh.isVisible = this._debugMode;\n        impostorMesh.isPickable = false;\n        impostorMesh.rotationQuaternion = new Quaternion();\n        const controllerMesh = xrController.grip || xrController.pointer;\n        impostorMesh.position.copyFrom(controllerMesh.position);\n        impostorMesh.rotationQuaternion.copyFrom(controllerMesh.rotationQuaternion);\n        const impostor = new PhysicsImpostor(impostorMesh, impostorType, {\n            mass: 0,\n            ...this._options.physicsProperties,\n        });\n        this._controllers[xrController.uniqueId] = {\n            xrController,\n            impostor,\n            impostorMesh,\n        };\n    }\n    /**\n     * Construct a new Controller Physics Feature\n     * @param _xrSessionManager the corresponding xr session manager\n     * @param _options options to create this feature with\n     */\n    constructor(_xrSessionManager, _options) {\n        super(_xrSessionManager);\n        this._options = _options;\n        this._attachController = (xrController) => {\n            if (this._controllers[xrController.uniqueId]) {\n                // already attached\n                return;\n            }\n            if (!this._xrSessionManager.scene.isPhysicsEnabled()) {\n                Logger.Warn(\"physics engine not enabled, skipped. Please add this controller manually.\");\n            }\n            // if no motion controller available, create impostors!\n            if (this._options.physicsProperties.useControllerMesh && xrController.inputSource.gamepad) {\n                xrController.onMotionControllerInitObservable.addOnce((motionController) => {\n                    if (!motionController._doNotLoadControllerMesh) {\n                        motionController.onModelLoadedObservable.addOnce(() => {\n                            const impostor = new PhysicsImpostor(motionController.rootMesh, PhysicsImpostor.MeshImpostor, {\n                                mass: 0,\n                                ...this._options.physicsProperties,\n                            });\n                            const controllerMesh = xrController.grip || xrController.pointer;\n                            this._controllers[xrController.uniqueId] = {\n                                xrController,\n                                impostor,\n                                oldPos: controllerMesh.position.clone(),\n                                oldRotation: controllerMesh.rotationQuaternion.clone(),\n                            };\n                        });\n                    }\n                    else {\n                        // This controller isn't using a model, create impostors instead\n                        this._createPhysicsImpostor(xrController);\n                    }\n                });\n            }\n            else {\n                this._createPhysicsImpostor(xrController);\n            }\n        };\n        this._controllers = {};\n        this._debugMode = false;\n        this._delta = 0;\n        this._lastTimestamp = 0;\n        this._tmpQuaternion = new Quaternion();\n        this._tmpVector = new Vector3();\n        if (!this._options.physicsProperties) {\n            this._options.physicsProperties = {};\n        }\n    }\n    /**\n     * @internal\n     * enable debugging - will show console outputs and the impostor mesh\n     */\n    _enablePhysicsDebug() {\n        this._debugMode = true;\n        Object.keys(this._controllers).forEach((controllerId) => {\n            const controllerData = this._controllers[controllerId];\n            if (controllerData.impostorMesh) {\n                controllerData.impostorMesh.isVisible = true;\n            }\n        });\n    }\n    /**\n     * Manually add a controller (if no xrInput was provided or physics engine was not enabled)\n     * @param xrController the controller to add\n     */\n    addController(xrController) {\n        this._attachController(xrController);\n    }\n    /**\n     * attach this feature\n     * Will usually be called by the features manager\n     *\n     * @returns true if successful.\n     */\n    attach() {\n        if (!super.attach()) {\n            return false;\n        }\n        if (!this._options.xrInput) {\n            return true;\n        }\n        this._options.xrInput.controllers.forEach(this._attachController);\n        this._addNewAttachObserver(this._options.xrInput.onControllerAddedObservable, this._attachController);\n        this._addNewAttachObserver(this._options.xrInput.onControllerRemovedObservable, (controller) => {\n            // REMOVE the controller\n            this._detachController(controller.uniqueId);\n        });\n        if (this._options.enableHeadsetImpostor) {\n            const params = this._options.headsetImpostorParams || {\n                impostorType: PhysicsImpostor.SphereImpostor,\n                restitution: 0.8,\n                impostorSize: 0.3,\n            };\n            const impostorSize = params.impostorSize || 0.3;\n            this._headsetMesh = CreateSphere(\"headset-mesh\", {\n                diameterX: typeof impostorSize === \"number\" ? impostorSize : impostorSize.width,\n                diameterY: typeof impostorSize === \"number\" ? impostorSize : impostorSize.height,\n                diameterZ: typeof impostorSize === \"number\" ? impostorSize : impostorSize.depth,\n            });\n            this._headsetMesh.rotationQuaternion = new Quaternion();\n            this._headsetMesh.isVisible = false;\n            this._headsetImpostor = new PhysicsImpostor(this._headsetMesh, params.impostorType, { mass: 0, ...params });\n        }\n        return true;\n    }\n    /**\n     * detach this feature.\n     * Will usually be called by the features manager\n     *\n     * @returns true if successful.\n     */\n    detach() {\n        if (!super.detach()) {\n            return false;\n        }\n        Object.keys(this._controllers).forEach((controllerId) => {\n            this._detachController(controllerId);\n        });\n        if (this._headsetMesh) {\n            this._headsetMesh.dispose();\n        }\n        return true;\n    }\n    /**\n     * Get the headset impostor, if enabled\n     * @returns the impostor\n     */\n    getHeadsetImpostor() {\n        return this._headsetImpostor;\n    }\n    /**\n     * Get the physics impostor of a specific controller.\n     * The impostor is not attached to a mesh because a mesh for each controller is not obligatory\n     * @param controller the controller or the controller id of which to get the impostor\n     * @returns the impostor or null\n     */\n    getImpostorForController(controller) {\n        const id = typeof controller === \"string\" ? controller : controller.uniqueId;\n        if (this._controllers[id]) {\n            return this._controllers[id].impostor;\n        }\n        else {\n            return null;\n        }\n    }\n    /**\n     * Update the physics properties provided in the constructor\n     * @param newProperties the new properties object\n     * @param newProperties.impostorType\n     * @param newProperties.impostorSize\n     * @param newProperties.friction\n     * @param newProperties.restitution\n     */\n    setPhysicsProperties(newProperties) {\n        this._options.physicsProperties = {\n            ...this._options.physicsProperties,\n            ...newProperties,\n        };\n    }\n    _onXRFrame(_xrFrame) {\n        var _a, _b;\n        this._delta = this._xrSessionManager.currentTimestamp - this._lastTimestamp;\n        this._lastTimestamp = this._xrSessionManager.currentTimestamp;\n        if (this._headsetMesh && this._headsetImpostor) {\n            this._headsetMesh.position.copyFrom(this._options.xrInput.xrCamera.globalPosition);\n            this._headsetMesh.rotationQuaternion.copyFrom(this._options.xrInput.xrCamera.absoluteRotation);\n            if ((_a = this._options.xrInput.xrCamera._lastXRViewerPose) === null || _a === void 0 ? void 0 : _a.linearVelocity) {\n                const lv = this._options.xrInput.xrCamera._lastXRViewerPose.linearVelocity;\n                this._tmpVector.set(lv.x, lv.y, lv.z);\n                this._headsetImpostor.setLinearVelocity(this._tmpVector);\n            }\n            if ((_b = this._options.xrInput.xrCamera._lastXRViewerPose) === null || _b === void 0 ? void 0 : _b.angularVelocity) {\n                const av = this._options.xrInput.xrCamera._lastXRViewerPose.angularVelocity;\n                this._tmpVector.set(av.x, av.y, av.z);\n                this._headsetImpostor.setAngularVelocity(this._tmpVector);\n            }\n        }\n        Object.keys(this._controllers).forEach((controllerId) => {\n            var _a, _b;\n            const controllerData = this._controllers[controllerId];\n            const controllerMesh = controllerData.xrController.grip || controllerData.xrController.pointer;\n            const comparedPosition = controllerData.oldPos || controllerData.impostorMesh.position;\n            if ((_a = controllerData.xrController._lastXRPose) === null || _a === void 0 ? void 0 : _a.linearVelocity) {\n                const lv = controllerData.xrController._lastXRPose.linearVelocity;\n                this._tmpVector.set(lv.x, lv.y, lv.z);\n                controllerData.impostor.setLinearVelocity(this._tmpVector);\n            }\n            else {\n                controllerMesh.position.subtractToRef(comparedPosition, this._tmpVector);\n                this._tmpVector.scaleInPlace(1000 / this._delta);\n                controllerData.impostor.setLinearVelocity(this._tmpVector);\n            }\n            comparedPosition.copyFrom(controllerMesh.position);\n            if (this._debugMode) {\n                console.log(this._tmpVector, \"linear\");\n            }\n            const comparedQuaternion = controllerData.oldRotation || controllerData.impostorMesh.rotationQuaternion;\n            if ((_b = controllerData.xrController._lastXRPose) === null || _b === void 0 ? void 0 : _b.angularVelocity) {\n                const av = controllerData.xrController._lastXRPose.angularVelocity;\n                this._tmpVector.set(av.x, av.y, av.z);\n                controllerData.impostor.setAngularVelocity(this._tmpVector);\n            }\n            else {\n                if (!comparedQuaternion.equalsWithEpsilon(controllerMesh.rotationQuaternion)) {\n                    // roughly based on this - https://www.gamedev.net/forums/topic/347752-quaternion-and-angular-velocity/\n                    comparedQuaternion.conjugateInPlace().multiplyToRef(controllerMesh.rotationQuaternion, this._tmpQuaternion);\n                    const len = Math.sqrt(this._tmpQuaternion.x * this._tmpQuaternion.x + this._tmpQuaternion.y * this._tmpQuaternion.y + this._tmpQuaternion.z * this._tmpQuaternion.z);\n                    this._tmpVector.set(this._tmpQuaternion.x, this._tmpQuaternion.y, this._tmpQuaternion.z);\n                    // define a better epsilon\n                    if (len < 0.001) {\n                        this._tmpVector.scaleInPlace(2);\n                    }\n                    else {\n                        const angle = 2 * Math.atan2(len, this._tmpQuaternion.w);\n                        this._tmpVector.scaleInPlace(angle / (len * (this._delta / 1000)));\n                    }\n                    controllerData.impostor.setAngularVelocity(this._tmpVector);\n                }\n            }\n            comparedQuaternion.copyFrom(controllerMesh.rotationQuaternion);\n            if (this._debugMode) {\n                console.log(this._tmpVector, this._tmpQuaternion, \"angular\");\n            }\n        });\n    }\n    _detachController(xrControllerUniqueId) {\n        const controllerData = this._controllers[xrControllerUniqueId];\n        if (!controllerData) {\n            return;\n        }\n        if (controllerData.impostorMesh) {\n            controllerData.impostorMesh.dispose();\n        }\n        // remove from the map\n        delete this._controllers[xrControllerUniqueId];\n    }\n}\n/**\n * The module's name\n */\nWebXRControllerPhysics.Name = WebXRFeatureName.PHYSICS_CONTROLLERS;\n/**\n * The (Babylon) version of this module.\n * This is an integer representing the implementation version.\n * This number does not correspond to the webxr specs version\n */\nWebXRControllerPhysics.Version = 1;\n//register the plugin\nWebXRFeaturesManager.AddWebXRFeature(WebXRControllerPhysics.Name, (xrSessionManager, options) => {\n    return () => new WebXRControllerPhysics(xrSessionManager, options);\n}, WebXRControllerPhysics.Version, true);\n//# sourceMappingURL=WebXRControllerPhysics.js.map","import { WebXRFeaturesManager, WebXRFeatureName } from \"../webXRFeaturesManager.js\";\nimport { Observable } from \"../../Misc/observable.js\";\nimport { Vector3, Matrix, Quaternion } from \"../../Maths/math.vector.js\";\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature.js\";\nimport { Tools } from \"../../Misc/tools.js\";\n/**\n * The currently-working hit-test module.\n * Hit test (or Ray-casting) is used to interact with the real world.\n * For further information read here - https://github.com/immersive-web/hit-test\n *\n * Tested on chrome (mobile) 80.\n */\nexport class WebXRHitTest extends WebXRAbstractFeature {\n    /**\n     * Creates a new instance of the hit test feature\n     * @param _xrSessionManager an instance of WebXRSessionManager\n     * @param options options to use when constructing this feature\n     */\n    constructor(_xrSessionManager, \n    /**\n     * options to use when constructing this feature\n     */\n    options = {}) {\n        super(_xrSessionManager);\n        this.options = options;\n        this._tmpMat = new Matrix();\n        this._tmpPos = new Vector3();\n        this._tmpQuat = new Quaternion();\n        this._initHitTestSource = (referenceSpace) => {\n            if (!referenceSpace) {\n                return;\n            }\n            const offsetRay = new XRRay(this.options.offsetRay || {});\n            const hitTestOptions = {\n                space: this.options.useReferenceSpace ? referenceSpace : this._xrSessionManager.viewerReferenceSpace,\n                offsetRay: offsetRay,\n            };\n            if (this.options.entityTypes) {\n                hitTestOptions.entityTypes = this.options.entityTypes;\n            }\n            if (!hitTestOptions.space) {\n                Tools.Warn(\"waiting for viewer reference space to initialize\");\n                return;\n            }\n            this._xrSessionManager.session.requestHitTestSource(hitTestOptions).then((hitTestSource) => {\n                if (this._xrHitTestSource) {\n                    this._xrHitTestSource.cancel();\n                }\n                this._xrHitTestSource = hitTestSource;\n            });\n        };\n        /**\n         * When set to true, each hit test will have its own position/rotation objects\n         * When set to false, position and rotation objects will be reused for each hit test. It is expected that\n         * the developers will clone them or copy them as they see fit.\n         */\n        this.autoCloneTransformation = false;\n        /**\n         * Triggered when new babylon (transformed) hit test results are available\n         * Note - this will be called when results come back from the device. It can be an empty array!!\n         */\n        this.onHitTestResultObservable = new Observable();\n        /**\n         * Use this to temporarily pause hit test checks.\n         */\n        this.paused = false;\n        this.xrNativeFeatureName = \"hit-test\";\n        Tools.Warn(\"Hit test is an experimental and unstable feature.\");\n    }\n    /**\n     * attach this feature\n     * Will usually be called by the features manager\n     *\n     * @returns true if successful.\n     */\n    attach() {\n        if (!super.attach()) {\n            return false;\n        }\n        // Feature enabled, but not available\n        if (!this._xrSessionManager.session.requestHitTestSource) {\n            return false;\n        }\n        if (!this.options.disablePermanentHitTest) {\n            if (this._xrSessionManager.referenceSpace) {\n                this._initHitTestSource(this._xrSessionManager.referenceSpace);\n            }\n            this._xrSessionManager.onXRReferenceSpaceChanged.add(this._initHitTestSource);\n        }\n        if (this.options.enableTransientHitTest) {\n            const offsetRay = new XRRay(this.options.transientOffsetRay || {});\n            this._xrSessionManager.session.requestHitTestSourceForTransientInput({\n                profile: this.options.transientHitTestProfile || \"generic-touchscreen\",\n                offsetRay,\n                entityTypes: this.options.entityTypes,\n            }).then((hitSource) => {\n                this._transientXrHitTestSource = hitSource;\n            });\n        }\n        return true;\n    }\n    /**\n     * detach this feature.\n     * Will usually be called by the features manager\n     *\n     * @returns true if successful.\n     */\n    detach() {\n        if (!super.detach()) {\n            return false;\n        }\n        if (this._xrHitTestSource) {\n            this._xrHitTestSource.cancel();\n            this._xrHitTestSource = null;\n        }\n        this._xrSessionManager.onXRReferenceSpaceChanged.removeCallback(this._initHitTestSource);\n        if (this._transientXrHitTestSource) {\n            this._transientXrHitTestSource.cancel();\n            this._transientXrHitTestSource = null;\n        }\n        return true;\n    }\n    /**\n     * Dispose this feature and all of the resources attached\n     */\n    dispose() {\n        super.dispose();\n        this.onHitTestResultObservable.clear();\n    }\n    _onXRFrame(frame) {\n        // make sure we do nothing if (async) not attached\n        if (!this.attached || this.paused) {\n            return;\n        }\n        if (this._xrHitTestSource) {\n            const results = frame.getHitTestResults(this._xrHitTestSource);\n            this._processWebXRHitTestResult(results);\n        }\n        if (this._transientXrHitTestSource) {\n            const hitTestResultsPerInputSource = frame.getHitTestResultsForTransientInput(this._transientXrHitTestSource);\n            hitTestResultsPerInputSource.forEach((resultsPerInputSource) => {\n                this._processWebXRHitTestResult(resultsPerInputSource.results, resultsPerInputSource.inputSource);\n            });\n        }\n    }\n    _processWebXRHitTestResult(hitTestResults, inputSource) {\n        const results = [];\n        hitTestResults.forEach((hitTestResult) => {\n            const pose = hitTestResult.getPose(this._xrSessionManager.referenceSpace);\n            if (!pose) {\n                return;\n            }\n            const pos = pose.transform.position;\n            const quat = pose.transform.orientation;\n            this._tmpPos.set(pos.x, pos.y, pos.z);\n            this._tmpQuat.set(quat.x, quat.y, quat.z, quat.w);\n            Matrix.FromFloat32ArrayToRefScaled(pose.transform.matrix, 0, 1, this._tmpMat);\n            if (!this._xrSessionManager.scene.useRightHandedSystem) {\n                this._tmpPos.z *= -1;\n                this._tmpQuat.z *= -1;\n                this._tmpQuat.w *= -1;\n                this._tmpMat.toggleModelMatrixHandInPlace();\n            }\n            const result = {\n                position: this.autoCloneTransformation ? this._tmpPos.clone() : this._tmpPos,\n                rotationQuaternion: this.autoCloneTransformation ? this._tmpQuat.clone() : this._tmpQuat,\n                transformationMatrix: this.autoCloneTransformation ? this._tmpMat.clone() : this._tmpMat,\n                inputSource: inputSource,\n                isTransient: !!inputSource,\n                xrHitResult: hitTestResult,\n            };\n            results.push(result);\n        });\n        this.onHitTestResultObservable.notifyObservers(results);\n    }\n}\n/**\n * The module's name\n */\nWebXRHitTest.Name = WebXRFeatureName.HIT_TEST;\n/**\n * The (Babylon) version of this module.\n * This is an integer representing the implementation version.\n * This number does not correspond to the WebXR specs version\n */\nWebXRHitTest.Version = 2;\n//register the plugin versions\nWebXRFeaturesManager.AddWebXRFeature(WebXRHitTest.Name, (xrSessionManager, options) => {\n    return () => new WebXRHitTest(xrSessionManager, options);\n}, WebXRHitTest.Version, false);\n//# sourceMappingURL=WebXRHitTest.js.map","import { WebXRFeaturesManager, WebXRFeatureName } from \"../webXRFeaturesManager.js\";\nimport { Observable } from \"../../Misc/observable.js\";\nimport { Vector3 } from \"../../Maths/math.vector.js\";\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature.js\";\n/**\n * The feature point system is used to detect feature points from real world geometry.\n * This feature is currently experimental and only supported on BabylonNative, and should not be used in the browser.\n * The newly introduced API can be seen in webxr.nativeextensions.d.ts and described in FeaturePoints.md.\n */\nexport class WebXRFeaturePointSystem extends WebXRAbstractFeature {\n    /**\n     * The current feature point cloud maintained across frames.\n     */\n    get featurePointCloud() {\n        return this._featurePointCloud;\n    }\n    /**\n     * construct the feature point system\n     * @param _xrSessionManager an instance of xr Session manager\n     */\n    constructor(_xrSessionManager) {\n        super(_xrSessionManager);\n        this._enabled = false;\n        this._featurePointCloud = [];\n        /**\n         * Observers registered here will be executed whenever new feature points are added (on XRFrame while the session is tracking).\n         * Will notify the observers about which feature points have been added.\n         */\n        this.onFeaturePointsAddedObservable = new Observable();\n        /**\n         * Observers registered here will be executed whenever a feature point has been updated (on XRFrame while the session is tracking).\n         * Will notify the observers about which feature points have been updated.\n         */\n        this.onFeaturePointsUpdatedObservable = new Observable();\n        this.xrNativeFeatureName = \"bjsfeature-points\";\n        if (this._xrSessionManager.session) {\n            this._init();\n        }\n        else {\n            this._xrSessionManager.onXRSessionInit.addOnce(() => {\n                this._init();\n            });\n        }\n    }\n    /**\n     * Detach this feature.\n     * Will usually be called by the features manager\n     *\n     * @returns true if successful.\n     */\n    detach() {\n        if (!super.detach()) {\n            return false;\n        }\n        this.featurePointCloud.length = 0;\n        return true;\n    }\n    /**\n     * Dispose this feature and all of the resources attached\n     */\n    dispose() {\n        super.dispose();\n        this._featurePointCloud.length = 0;\n        this.onFeaturePointsUpdatedObservable.clear();\n        this.onFeaturePointsAddedObservable.clear();\n    }\n    /**\n     * On receiving a new XR frame if this feature is attached notify observers new feature point data is available.\n     * @param frame\n     */\n    _onXRFrame(frame) {\n        if (!this.attached || !this._enabled || !frame) {\n            return;\n        }\n        const featurePointRawData = frame.featurePointCloud;\n        if (!featurePointRawData || featurePointRawData.length === 0) {\n            return;\n        }\n        else {\n            if (featurePointRawData.length % 5 !== 0) {\n                throw new Error(\"Received malformed feature point cloud of length: \" + featurePointRawData.length);\n            }\n            const numberOfFeaturePoints = featurePointRawData.length / 5;\n            const updatedFeaturePoints = new Array();\n            const addedFeaturePoints = new Array();\n            for (let i = 0; i < numberOfFeaturePoints; i++) {\n                const rawIndex = i * 5;\n                const id = featurePointRawData[rawIndex + 4];\n                // IDs should be durable across frames and strictly increasing from 0 up, so use them as indexing into the feature point array.\n                if (!this._featurePointCloud[id]) {\n                    this._featurePointCloud[id] = { position: new Vector3(), confidenceValue: 0 };\n                    addedFeaturePoints.push(id);\n                }\n                else {\n                    updatedFeaturePoints.push(id);\n                }\n                // Set the feature point values.\n                this._featurePointCloud[id].position.x = featurePointRawData[rawIndex];\n                this._featurePointCloud[id].position.y = featurePointRawData[rawIndex + 1];\n                this._featurePointCloud[id].position.z = featurePointRawData[rawIndex + 2];\n                this._featurePointCloud[id].confidenceValue = featurePointRawData[rawIndex + 3];\n            }\n            // Signal observers that feature points have been added if necessary.\n            if (addedFeaturePoints.length > 0) {\n                this.onFeaturePointsAddedObservable.notifyObservers(addedFeaturePoints);\n            }\n            // Signal observers that feature points have been updated if necessary.\n            if (updatedFeaturePoints.length > 0) {\n                this.onFeaturePointsUpdatedObservable.notifyObservers(updatedFeaturePoints);\n            }\n        }\n    }\n    /**\n     * Initializes the feature. If the feature point feature is not available for this environment do not mark the feature as enabled.\n     */\n    _init() {\n        if (!this._xrSessionManager.session.trySetFeaturePointCloudEnabled || !this._xrSessionManager.session.trySetFeaturePointCloudEnabled(true)) {\n            // fail silently\n            return;\n        }\n        this._enabled = true;\n    }\n}\n/**\n * The module's name\n */\nWebXRFeaturePointSystem.Name = WebXRFeatureName.FEATURE_POINTS;\n/**\n * The (Babylon) version of this module.\n * This is an integer representing the implementation version.\n * This number does not correspond to the WebXR specs version\n */\nWebXRFeaturePointSystem.Version = 1;\n// register the plugin\nWebXRFeaturesManager.AddWebXRFeature(WebXRFeaturePointSystem.Name, (xrSessionManager) => {\n    return () => new WebXRFeaturePointSystem(xrSessionManager);\n}, WebXRFeaturePointSystem.Version);\n//# sourceMappingURL=WebXRFeaturePointSystem.js.map","import { WebXRFeaturesManager, WebXRFeatureName } from \"../webXRFeaturesManager.js\";\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature.js\";\nimport { Matrix } from \"../../Maths/math.js\";\nimport { Observable } from \"../../Misc/observable.js\";\nlet meshIdProvider = 0;\n/**\n * The mesh detector is used to detect meshes in the real world when in AR\n */\nexport class WebXRMeshDetector extends WebXRAbstractFeature {\n    constructor(_xrSessionManager, _options = {}) {\n        super(_xrSessionManager);\n        this._options = _options;\n        this._detectedMeshes = new Map();\n        /**\n         * Observers registered here will be executed when a new mesh was added to the session\n         */\n        this.onMeshAddedObservable = new Observable();\n        /**\n         * Observers registered here will be executed when a mesh is no longer detected in the session\n         */\n        this.onMeshRemovedObservable = new Observable();\n        /**\n         * Observers registered here will be executed when an existing mesh updates\n         */\n        this.onMeshUpdatedObservable = new Observable();\n        this.xrNativeFeatureName = \"mesh-detection\";\n        if (this._xrSessionManager.session) {\n            this._init();\n        }\n        else {\n            this._xrSessionManager.onXRSessionInit.addOnce(() => {\n                this._init();\n            });\n        }\n    }\n    detach() {\n        if (!super.detach()) {\n            return false;\n        }\n        // Only supported by BabylonNative\n        if (!!this._xrSessionManager.isNative && !!this._xrSessionManager.session.trySetMeshDetectorEnabled) {\n            this._xrSessionManager.session.trySetMeshDetectorEnabled(false);\n        }\n        if (!this._options.doNotRemoveMeshesOnSessionEnded) {\n            this._detectedMeshes.forEach((mesh) => {\n                this.onMeshRemovedObservable.notifyObservers(mesh);\n            });\n            this._detectedMeshes.clear();\n        }\n        return true;\n    }\n    dispose() {\n        super.dispose();\n        this.onMeshAddedObservable.clear();\n        this.onMeshRemovedObservable.clear();\n        this.onMeshUpdatedObservable.clear();\n    }\n    _onXRFrame(frame) {\n        var _a;\n        // TODO remove try catch\n        try {\n            if (!this.attached || !frame) {\n                return;\n            }\n            const detectedMeshes = (_a = frame.worldInformation) === null || _a === void 0 ? void 0 : _a.detectedMeshes;\n            if (detectedMeshes) {\n                const toRemove = new Set();\n                this._detectedMeshes.forEach((vertexData, xrMesh) => {\n                    if (!detectedMeshes.has(xrMesh)) {\n                        toRemove.add(xrMesh);\n                    }\n                });\n                toRemove.forEach((xrMesh) => {\n                    const vertexData = this._detectedMeshes.get(xrMesh);\n                    if (vertexData) {\n                        this.onMeshRemovedObservable.notifyObservers(vertexData);\n                        this._detectedMeshes.delete(xrMesh);\n                    }\n                });\n                // now check for new ones\n                detectedMeshes.forEach((xrMesh) => {\n                    if (!this._detectedMeshes.has(xrMesh)) {\n                        const partialVertexData = {\n                            id: meshIdProvider++,\n                            xrMesh: xrMesh,\n                        };\n                        const vertexData = this._updateVertexDataWithXRMesh(xrMesh, partialVertexData, frame);\n                        this._detectedMeshes.set(xrMesh, vertexData);\n                        this.onMeshAddedObservable.notifyObservers(vertexData);\n                    }\n                    else {\n                        // updated?\n                        if (xrMesh.lastChangedTime === this._xrSessionManager.currentTimestamp) {\n                            const vertexData = this._detectedMeshes.get(xrMesh);\n                            if (vertexData) {\n                                this._updateVertexDataWithXRMesh(xrMesh, vertexData, frame);\n                                this.onMeshUpdatedObservable.notifyObservers(vertexData);\n                            }\n                        }\n                    }\n                });\n            }\n        }\n        catch (error) {\n            console.log(error.stack);\n        }\n    }\n    _init() {\n        // Only supported by BabylonNative\n        if (this._xrSessionManager.isNative) {\n            if (this._xrSessionManager.session.trySetMeshDetectorEnabled) {\n                this._xrSessionManager.session.trySetMeshDetectorEnabled(true);\n            }\n            if (!!this._options.preferredDetectorOptions && !!this._xrSessionManager.session.trySetPreferredMeshDetectorOptions) {\n                this._xrSessionManager.session.trySetPreferredMeshDetectorOptions(this._options.preferredDetectorOptions);\n            }\n        }\n    }\n    _updateVertexDataWithXRMesh(xrMesh, mesh, xrFrame) {\n        mesh.xrMesh = xrMesh;\n        mesh.worldParentNode = this._options.worldParentNode;\n        if (this._options.convertCoordinateSystems) {\n            if (!this._xrSessionManager.scene.useRightHandedSystem) {\n                mesh.positions = new Float32Array(xrMesh.positions.length);\n                for (let i = 0; i < xrMesh.positions.length; i += 3) {\n                    mesh.positions[i] = xrMesh.positions[i];\n                    mesh.positions[i + 1] = xrMesh.positions[i + 1];\n                    mesh.positions[i + 2] = -1 * xrMesh.positions[i + 2];\n                }\n                if (xrMesh.normals) {\n                    mesh.normals = new Float32Array(xrMesh.normals.length);\n                    for (let i = 0; i < xrMesh.normals.length; i += 3) {\n                        mesh.normals[i] = xrMesh.normals[i];\n                        mesh.normals[i + 1] = xrMesh.normals[i + 1];\n                        mesh.normals[i + 2] = -1 * xrMesh.normals[i + 2];\n                    }\n                }\n            }\n            else {\n                mesh.positions = xrMesh.positions;\n                mesh.normals = xrMesh.normals;\n            }\n            // WebXR should provide indices in a counterclockwise winding order regardless of coordinate system handedness\n            mesh.indices = xrMesh.indices;\n            // matrix\n            const pose = xrFrame.getPose(xrMesh.meshSpace, this._xrSessionManager.referenceSpace);\n            if (pose) {\n                const mat = mesh.transformationMatrix || new Matrix();\n                Matrix.FromArrayToRef(pose.transform.matrix, 0, mat);\n                if (!this._xrSessionManager.scene.useRightHandedSystem) {\n                    mat.toggleModelMatrixHandInPlace();\n                }\n                mesh.transformationMatrix = mat;\n                if (this._options.worldParentNode) {\n                    mat.multiplyToRef(this._options.worldParentNode.getWorldMatrix(), mat);\n                }\n            }\n        }\n        return mesh;\n    }\n}\n/**\n * The module's name\n */\nWebXRMeshDetector.Name = WebXRFeatureName.MESH_DETECTION;\n/**\n * The (Babylon) version of this module.\n * This is an integer representing the implementation version.\n * This number does not correspond to the WebXR specs version\n */\nWebXRMeshDetector.Version = 1;\nWebXRFeaturesManager.AddWebXRFeature(WebXRMeshDetector.Name, (xrSessionManager, options) => {\n    return () => new WebXRMeshDetector(xrSessionManager, options);\n}, WebXRMeshDetector.Version, false);\n//# sourceMappingURL=WebXRMeshDetector.js.map","import { WebXRFeaturesManager, WebXRFeatureName } from \"../webXRFeaturesManager.js\";\nimport { Observable } from \"../../Misc/observable.js\";\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature.js\";\nimport { Matrix } from \"../../Maths/math.vector.js\";\nimport { Tools } from \"../../Misc/tools.js\";\n/**\n * Enum that describes the state of the image trackability score status for this session.\n */\nvar ImageTrackingScoreStatus;\n(function (ImageTrackingScoreStatus) {\n    // AR Session has not yet assessed image trackability scores.\n    ImageTrackingScoreStatus[ImageTrackingScoreStatus[\"NotReceived\"] = 0] = \"NotReceived\";\n    // A request to retrieve trackability scores has been sent, but no response has been received.\n    ImageTrackingScoreStatus[ImageTrackingScoreStatus[\"Waiting\"] = 1] = \"Waiting\";\n    // Image trackability scores have been received for this session\n    ImageTrackingScoreStatus[ImageTrackingScoreStatus[\"Received\"] = 2] = \"Received\";\n})(ImageTrackingScoreStatus || (ImageTrackingScoreStatus = {}));\n/**\n * Image tracking for immersive AR sessions.\n * Providing a list of images and their estimated widths will enable tracking those images in the real world.\n */\nexport class WebXRImageTracking extends WebXRAbstractFeature {\n    /**\n     * constructs the image tracking feature\n     * @param _xrSessionManager the session manager for this module\n     * @param options read-only options to be used in this module\n     */\n    constructor(_xrSessionManager, \n    /**\n     * read-only options to be used in this module\n     */\n    options) {\n        super(_xrSessionManager);\n        this.options = options;\n        /**\n         * This will be triggered if the underlying system deems an image untrackable.\n         * The index is the index of the image from the array used to initialize the feature.\n         */\n        this.onUntrackableImageFoundObservable = new Observable();\n        /**\n         * An image was deemed trackable, and the system will start tracking it.\n         */\n        this.onTrackableImageFoundObservable = new Observable();\n        /**\n         * The image was found and its state was updated.\n         */\n        this.onTrackedImageUpdatedObservable = new Observable();\n        this._trackableScoreStatus = ImageTrackingScoreStatus.NotReceived;\n        this._trackedImages = [];\n        this.xrNativeFeatureName = \"image-tracking\";\n    }\n    /**\n     * attach this feature\n     * Will usually be called by the features manager\n     *\n     * @returns true if successful.\n     */\n    attach() {\n        return super.attach();\n    }\n    /**\n     * detach this feature.\n     * Will usually be called by the features manager\n     *\n     * @returns true if successful.\n     */\n    detach() {\n        return super.detach();\n    }\n    /**\n     * Get a tracked image by its ID.\n     *\n     * @param id the id of the image to load (position in the init array)\n     * @returns a trackable image, if exists in this location\n     */\n    getTrackedImageById(id) {\n        return this._trackedImages[id] || null;\n    }\n    /**\n     * Dispose this feature and all of the resources attached\n     */\n    dispose() {\n        super.dispose();\n        this._trackedImages.forEach((trackedImage) => {\n            trackedImage.originalBitmap.close();\n        });\n        this._trackedImages.length = 0;\n        this.onTrackableImageFoundObservable.clear();\n        this.onUntrackableImageFoundObservable.clear();\n        this.onTrackedImageUpdatedObservable.clear();\n    }\n    /**\n     * Extends the session init object if needed\n     * @returns augmentation object fo the xr session init object.\n     */\n    async getXRSessionInitExtension() {\n        if (!this.options.images || !this.options.images.length) {\n            return {};\n        }\n        const promises = this.options.images.map((image) => {\n            if (typeof image.src === \"string\") {\n                return this._xrSessionManager.scene.getEngine()._createImageBitmapFromSource(image.src);\n            }\n            else {\n                return Promise.resolve(image.src); // resolve is probably unneeded\n            }\n        });\n        try {\n            const images = await Promise.all(promises);\n            this._originalTrackingRequest = images.map((image, idx) => {\n                return {\n                    image,\n                    widthInMeters: this.options.images[idx].estimatedRealWorldWidth,\n                };\n            });\n            return {\n                trackedImages: this._originalTrackingRequest,\n            };\n        }\n        catch (ex) {\n            Tools.Error(\"Error loading images for tracking, WebXRImageTracking disabled for this session.\");\n            return {};\n        }\n    }\n    _onXRFrame(_xrFrame) {\n        if (!_xrFrame.getImageTrackingResults || this._trackableScoreStatus === ImageTrackingScoreStatus.Waiting) {\n            return;\n        }\n        // Image tracking scores may be generated a few frames after the XR Session initializes.\n        // If we haven't received scores yet, then kick off the task to check scores and return immediately.\n        if (this._trackableScoreStatus === ImageTrackingScoreStatus.NotReceived) {\n            this._checkScoresAsync();\n            return;\n        }\n        const imageTrackedResults = _xrFrame.getImageTrackingResults();\n        for (const result of imageTrackedResults) {\n            let changed = false;\n            const imageIndex = result.index;\n            const imageObject = this._trackedImages[imageIndex];\n            if (!imageObject) {\n                // something went wrong!\n                continue;\n            }\n            imageObject.xrTrackingResult = result;\n            if (imageObject.realWorldWidth !== result.measuredWidthInMeters) {\n                imageObject.realWorldWidth = result.measuredWidthInMeters;\n                changed = true;\n            }\n            // Get the pose of the image relative to a reference space.\n            const pose = _xrFrame.getPose(result.imageSpace, this._xrSessionManager.referenceSpace);\n            if (pose) {\n                const mat = imageObject.transformationMatrix;\n                Matrix.FromArrayToRef(pose.transform.matrix, 0, mat);\n                if (!this._xrSessionManager.scene.useRightHandedSystem) {\n                    mat.toggleModelMatrixHandInPlace();\n                }\n                changed = true;\n            }\n            const state = result.trackingState;\n            const emulated = state === \"emulated\";\n            if (imageObject.emulated !== emulated) {\n                imageObject.emulated = emulated;\n                changed = true;\n            }\n            if (changed) {\n                this.onTrackedImageUpdatedObservable.notifyObservers(imageObject);\n            }\n        }\n    }\n    async _checkScoresAsync() {\n        if (!this._xrSessionManager.session.getTrackedImageScores || this._trackableScoreStatus !== ImageTrackingScoreStatus.NotReceived) {\n            return;\n        }\n        this._trackableScoreStatus = ImageTrackingScoreStatus.Waiting;\n        const imageScores = await this._xrSessionManager.session.getTrackedImageScores();\n        if (!imageScores || imageScores.length === 0) {\n            this._trackableScoreStatus = ImageTrackingScoreStatus.NotReceived;\n            return;\n        }\n        // check the scores for all\n        for (let idx = 0; idx < imageScores.length; ++idx) {\n            if (imageScores[idx] == \"untrackable\") {\n                this.onUntrackableImageFoundObservable.notifyObservers(idx);\n            }\n            else {\n                const originalBitmap = this._originalTrackingRequest[idx].image;\n                const imageObject = {\n                    id: idx,\n                    originalBitmap,\n                    transformationMatrix: new Matrix(),\n                    ratio: originalBitmap.width / originalBitmap.height,\n                };\n                this._trackedImages[idx] = imageObject;\n                this.onTrackableImageFoundObservable.notifyObservers(imageObject);\n            }\n        }\n        this._trackableScoreStatus = imageScores.length > 0 ? ImageTrackingScoreStatus.Received : ImageTrackingScoreStatus.NotReceived;\n    }\n}\n/**\n * The module's name\n */\nWebXRImageTracking.Name = WebXRFeatureName.IMAGE_TRACKING;\n/**\n * The (Babylon) version of this module.\n * This is an integer representing the implementation version.\n * This number does not correspond to the WebXR specs version\n */\nWebXRImageTracking.Version = 1;\n//register the plugin\nWebXRFeaturesManager.AddWebXRFeature(WebXRImageTracking.Name, (xrSessionManager, options) => {\n    return () => new WebXRImageTracking(xrSessionManager, options);\n}, WebXRImageTracking.Version, false);\n//# sourceMappingURL=WebXRImageTracking.js.map","import { Tools } from \"../../Misc/tools.js\";\nimport { WebXRFeatureName, WebXRFeaturesManager } from \"../webXRFeaturesManager.js\";\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature.js\";\n/**\n * DOM Overlay Feature\n *\n * @since 5.0.0\n */\nexport class WebXRDomOverlay extends WebXRAbstractFeature {\n    /**\n     * Creates a new instance of the dom-overlay feature\n     * @param _xrSessionManager an instance of WebXRSessionManager\n     * @param options options to use when constructing this feature\n     */\n    constructor(_xrSessionManager, \n    /**\n     * options to use when constructing this feature\n     */\n    options) {\n        super(_xrSessionManager);\n        this.options = options;\n        /**\n         * Type of overlay - non-null when available\n         */\n        this._domOverlayType = null;\n        /**\n         * Event Listener to supress \"beforexrselect\" events.\n         */\n        this._beforeXRSelectListener = null;\n        /**\n         * Element used for overlay\n         */\n        this._element = null;\n        this.xrNativeFeatureName = \"dom-overlay\";\n        // https://immersive-web.github.io/dom-overlays/\n        Tools.Warn(\"dom-overlay is an experimental and unstable feature.\");\n    }\n    /**\n     * attach this feature\n     * Will usually be called by the features manager\n     *\n     * @returns true if successful.\n     */\n    attach() {\n        if (!super.attach()) {\n            return false;\n        }\n        // Feature not available\n        if (!this._xrSessionManager.session.domOverlayState || this._xrSessionManager.session.domOverlayState.type === null) {\n            return false;\n        }\n        this._domOverlayType = this._xrSessionManager.session.domOverlayState.type;\n        if (this._element !== null && this.options.supressXRSelectEvents === true) {\n            this._beforeXRSelectListener = (ev) => {\n                ev.preventDefault();\n            };\n            this._element.addEventListener(\"beforexrselect\", this._beforeXRSelectListener);\n        }\n        return true;\n    }\n    /**\n     * The type of DOM overlay (null when not supported).  Provided by UA and remains unchanged for duration of session.\n     */\n    get domOverlayType() {\n        return this._domOverlayType;\n    }\n    /**\n     * Dispose this feature and all of the resources attached\n     */\n    dispose() {\n        super.dispose();\n        if (this._element !== null && this._beforeXRSelectListener) {\n            this._element.removeEventListener(\"beforexrselect\", this._beforeXRSelectListener);\n        }\n    }\n    _onXRFrame(_xrFrame) {\n        /* empty */\n    }\n    /**\n     * Extends the session init object if needed\n     * @returns augmentation object for the xr session init object.\n     */\n    async getXRSessionInitExtension() {\n        if (this.options.element === undefined) {\n            Tools.Warn('\"element\" option must be provided to attach xr-dom-overlay feature.');\n            return {};\n        }\n        else if (typeof this.options.element === \"string\") {\n            const selectedElement = document.querySelector(this.options.element);\n            if (selectedElement === null) {\n                Tools.Warn(`element not found '${this.options.element}' (not requesting xr-dom-overlay)`);\n                return {};\n            }\n            this._element = selectedElement;\n        }\n        else {\n            this._element = this.options.element;\n        }\n        return {\n            domOverlay: {\n                root: this._element,\n            },\n        };\n    }\n}\n/**\n * The module's name\n */\nWebXRDomOverlay.Name = WebXRFeatureName.DOM_OVERLAY;\n/**\n * The (Babylon) version of this module.\n * This is an integer representing the implementation version.\n * This number does not correspond to the WebXR specs version\n */\nWebXRDomOverlay.Version = 1;\n//register the plugin\nWebXRFeaturesManager.AddWebXRFeature(WebXRDomOverlay.Name, (xrSessionManager, options) => {\n    return () => new WebXRDomOverlay(xrSessionManager, options);\n}, WebXRDomOverlay.Version, false);\n//# sourceMappingURL=WebXRDOMOverlay.js.map","import { WebXRFeaturesManager, WebXRFeatureName } from \"../webXRFeaturesManager.js\";\nimport { WebXRControllerComponent } from \"../motionController/webXRControllerComponent.js\";\nimport { Matrix, Quaternion, Vector3 } from \"../../Maths/math.vector.js\";\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature.js\";\nimport { Tools } from \"../../Misc/tools.js\";\n/**\n * This is a movement feature to be used with WebXR-enabled motion controllers.\n * When enabled and attached, the feature will allow a user to move around and rotate in the scene using\n * the input of the attached controllers.\n */\nexport class WebXRControllerMovement extends WebXRAbstractFeature {\n    /**\n     * Current movement direction.  Will be null before XR Frames have been processed.\n     */\n    get movementDirection() {\n        return this._movementDirection;\n    }\n    /**\n     * Is movement enabled\n     */\n    get movementEnabled() {\n        return this._featureContext.movementEnabled;\n    }\n    /**\n     * Sets whether movement is enabled or not\n     * @param enabled is movement enabled\n     */\n    set movementEnabled(enabled) {\n        this._featureContext.movementEnabled = enabled;\n    }\n    /**\n     * If movement follows viewer pose\n     */\n    get movementOrientationFollowsViewerPose() {\n        return this._featureContext.movementOrientationFollowsViewerPose;\n    }\n    /**\n     * Sets whether movement follows viewer pose\n     * @param followsPose is movement should follow viewer pose\n     */\n    set movementOrientationFollowsViewerPose(followsPose) {\n        this._featureContext.movementOrientationFollowsViewerPose = followsPose;\n    }\n    /**\n     * Gets movement speed\n     */\n    get movementSpeed() {\n        return this._featureContext.movementSpeed;\n    }\n    /**\n     * Sets movement speed\n     * @param movementSpeed movement speed\n     */\n    set movementSpeed(movementSpeed) {\n        this._featureContext.movementSpeed = movementSpeed;\n    }\n    /**\n     * Gets minimum threshold the controller's thumbstick/touchpad must pass before being recognized for movement (avoids jitter/unintentional movement)\n     */\n    get movementThreshold() {\n        return this._featureContext.movementThreshold;\n    }\n    /**\n     * Sets minimum threshold the controller's thumbstick/touchpad must pass before being recognized for movement (avoids jitter/unintentional movement)\n     * @param movementThreshold new threshold\n     */\n    set movementThreshold(movementThreshold) {\n        this._featureContext.movementThreshold = movementThreshold;\n    }\n    /**\n     * Is rotation enabled\n     */\n    get rotationEnabled() {\n        return this._featureContext.rotationEnabled;\n    }\n    /**\n     * Sets whether rotation is enabled or not\n     * @param enabled is rotation enabled\n     */\n    set rotationEnabled(enabled) {\n        this._featureContext.rotationEnabled = enabled;\n    }\n    /**\n     * Gets rotation speed factor\n     */\n    get rotationSpeed() {\n        return this._featureContext.rotationSpeed;\n    }\n    /**\n     * Sets rotation speed factor (1.0 is default)\n     * @param rotationSpeed new rotation speed factor\n     */\n    set rotationSpeed(rotationSpeed) {\n        this._featureContext.rotationSpeed = rotationSpeed;\n    }\n    /**\n     * Gets minimum threshold the controller's thumbstick/touchpad must pass before being recognized for rotation (avoids jitter/unintentional rotation)\n     */\n    get rotationThreshold() {\n        return this._featureContext.rotationThreshold;\n    }\n    /**\n     * Sets minimum threshold the controller's thumbstick/touchpad must pass before being recognized for rotation (avoids jitter/unintentional rotation)\n     * @param threshold new threshold\n     */\n    set rotationThreshold(threshold) {\n        this._featureContext.rotationThreshold = threshold;\n    }\n    /**\n     * constructs a new movement controller system\n     * @param _xrSessionManager an instance of WebXRSessionManager\n     * @param options configuration object for this feature\n     */\n    constructor(_xrSessionManager, options) {\n        var _a, _b, _c, _d, _e, _f;\n        super(_xrSessionManager);\n        this._controllers = {};\n        this._currentRegistrationConfigurations = [];\n        // forward direction for movement, which may differ from viewer pose.\n        this._movementDirection = null;\n        // unused\n        this._tmpRotationMatrix = Matrix.Identity();\n        this._tmpTranslationDirection = new Vector3();\n        this._tmpMovementTranslation = new Vector3();\n        this._attachController = (xrController) => {\n            if (this._controllers[xrController.uniqueId]) {\n                // already attached\n                return;\n            }\n            this._controllers[xrController.uniqueId] = {\n                xrController,\n                registeredComponents: [],\n            };\n            const controllerData = this._controllers[xrController.uniqueId];\n            // movement controller only available to gamepad-enabled input sources.\n            if (controllerData.xrController.inputSource.targetRayMode === \"tracked-pointer\" && controllerData.xrController.inputSource.gamepad) {\n                // motion controller support\n                const initController = () => {\n                    if (xrController.motionController) {\n                        for (const registration of this._currentRegistrationConfigurations) {\n                            let component = null;\n                            if (registration.allowedComponentTypes) {\n                                for (const componentType of registration.allowedComponentTypes) {\n                                    const componentOfType = xrController.motionController.getComponentOfType(componentType);\n                                    if (componentOfType !== null) {\n                                        component = componentOfType;\n                                        break;\n                                    }\n                                }\n                            }\n                            if (registration.mainComponentOnly) {\n                                const mainComponent = xrController.motionController.getMainComponent();\n                                if (mainComponent === null) {\n                                    continue;\n                                }\n                                component = mainComponent;\n                            }\n                            if (typeof registration.componentSelectionPredicate === \"function\") {\n                                // if does not match we do want to ignore a previously found component\n                                component = registration.componentSelectionPredicate(xrController);\n                            }\n                            if (component && registration.forceHandedness) {\n                                if (xrController.inputSource.handedness !== registration.forceHandedness) {\n                                    continue; // do not register\n                                }\n                            }\n                            if (component === null) {\n                                continue; // do not register\n                            }\n                            const registeredComponent = {\n                                registrationConfiguration: registration,\n                                component,\n                            };\n                            controllerData.registeredComponents.push(registeredComponent);\n                            if (\"axisChangedHandler\" in registration) {\n                                registeredComponent.onAxisChangedObserver = component.onAxisValueChangedObservable.add((axesData) => {\n                                    registration.axisChangedHandler(axesData, this._movementState, this._featureContext, this._xrInput);\n                                });\n                            }\n                            if (\"buttonChangedhandler\" in registration) {\n                                registeredComponent.onButtonChangedObserver = component.onButtonStateChangedObservable.add(() => {\n                                    if (component.changes.pressed) {\n                                        registration.buttonChangedhandler(component.changes.pressed, this._movementState, this._featureContext, this._xrInput);\n                                    }\n                                });\n                            }\n                        }\n                    }\n                };\n                if (xrController.motionController) {\n                    initController();\n                }\n                else {\n                    xrController.onMotionControllerInitObservable.addOnce(() => {\n                        initController();\n                    });\n                }\n            }\n        };\n        if (!options || options.xrInput === undefined) {\n            Tools.Error('WebXRControllerMovement feature requires \"xrInput\" option.');\n            return;\n        }\n        if (Array.isArray(options.customRegistrationConfigurations)) {\n            this._currentRegistrationConfigurations = options.customRegistrationConfigurations;\n        }\n        else {\n            this._currentRegistrationConfigurations = WebXRControllerMovement.REGISTRATIONS.default;\n        }\n        // synchronized from feature setter properties\n        this._featureContext = {\n            movementEnabled: options.movementEnabled || true,\n            movementOrientationFollowsViewerPose: (_a = options.movementOrientationFollowsViewerPose) !== null && _a !== void 0 ? _a : true,\n            movementSpeed: (_b = options.movementSpeed) !== null && _b !== void 0 ? _b : 1,\n            movementThreshold: (_c = options.movementThreshold) !== null && _c !== void 0 ? _c : 0.25,\n            rotationEnabled: (_d = options.rotationEnabled) !== null && _d !== void 0 ? _d : true,\n            rotationSpeed: (_e = options.rotationSpeed) !== null && _e !== void 0 ? _e : 1.0,\n            rotationThreshold: (_f = options.rotationThreshold) !== null && _f !== void 0 ? _f : 0.25,\n        };\n        this._movementState = {\n            moveX: 0,\n            moveY: 0,\n            rotateX: 0,\n            rotateY: 0,\n        };\n        this._xrInput = options.xrInput;\n    }\n    attach() {\n        if (!super.attach()) {\n            return false;\n        }\n        this._xrInput.controllers.forEach(this._attachController);\n        this._addNewAttachObserver(this._xrInput.onControllerAddedObservable, this._attachController);\n        this._addNewAttachObserver(this._xrInput.onControllerRemovedObservable, (controller) => {\n            // REMOVE the controller\n            this._detachController(controller.uniqueId);\n        });\n        return true;\n    }\n    detach() {\n        if (!super.detach()) {\n            return false;\n        }\n        Object.keys(this._controllers).forEach((controllerId) => {\n            this._detachController(controllerId);\n        });\n        this._controllers = {};\n        return true;\n    }\n    /**\n     * Occurs on every XR frame.\n     * @param _xrFrame\n     */\n    _onXRFrame(_xrFrame) {\n        if (!this.attach) {\n            return;\n        }\n        if (this._movementDirection === null) {\n            this._movementDirection = this._xrInput.xrCamera.rotationQuaternion.clone();\n        }\n        if (this._movementState.rotateX !== 0 && this._featureContext.rotationEnabled) {\n            // smooth rotation\n            const deltaMillis = this._xrSessionManager.scene.getEngine().getDeltaTime();\n            const rotationY = deltaMillis * 0.001 * this._featureContext.rotationSpeed * this._movementState.rotateX * (this._xrSessionManager.scene.useRightHandedSystem ? -1 : 1);\n            if (this._featureContext.movementOrientationFollowsViewerPose === true) {\n                this._xrInput.xrCamera.cameraRotation.y += rotationY;\n                this._movementDirection = this._xrInput.xrCamera.rotationQuaternion.multiply(Quaternion.RotationYawPitchRoll(rotationY, 0, 0));\n            }\n            else {\n                // movement orientation direction does not affect camera.  We use rotation speed multiplier\n                // otherwise need to implement inertia and constraints for same feel as TargetCamera.\n                this._movementDirection.multiplyInPlace(Quaternion.RotationYawPitchRoll(rotationY * 3.0, 0, 0));\n            }\n        }\n        else if (this._featureContext.movementOrientationFollowsViewerPose === true) {\n            this._movementDirection.copyFrom(this._xrInput.xrCamera.rotationQuaternion);\n        }\n        if ((this._movementState.moveX !== 0 || this._movementState.moveY !== 0) && this._featureContext.movementEnabled) {\n            Matrix.FromQuaternionToRef(this._movementDirection, this._tmpRotationMatrix);\n            this._tmpTranslationDirection.set(this._movementState.moveX, 0, this._movementState.moveY * (this._xrSessionManager.scene.useRightHandedSystem ? 1.0 : -1.0));\n            // move according to forward direction based on camera speed\n            Vector3.TransformCoordinatesToRef(this._tmpTranslationDirection, this._tmpRotationMatrix, this._tmpMovementTranslation);\n            this._tmpMovementTranslation.scaleInPlace(this._xrInput.xrCamera._computeLocalCameraSpeed() * this._featureContext.movementSpeed);\n            this._xrInput.xrCamera.cameraDirection.addInPlace(this._tmpMovementTranslation);\n        }\n    }\n    _detachController(xrControllerUniqueId) {\n        const controllerData = this._controllers[xrControllerUniqueId];\n        if (!controllerData) {\n            return;\n        }\n        for (const registeredComponent of controllerData.registeredComponents) {\n            if (registeredComponent.onAxisChangedObserver) {\n                registeredComponent.component.onAxisValueChangedObservable.remove(registeredComponent.onAxisChangedObserver);\n            }\n            if (registeredComponent.onButtonChangedObserver) {\n                registeredComponent.component.onButtonStateChangedObservable.remove(registeredComponent.onButtonChangedObserver);\n            }\n        }\n        // remove from the map\n        delete this._controllers[xrControllerUniqueId];\n    }\n}\n/**\n * The module's name\n */\nWebXRControllerMovement.Name = WebXRFeatureName.MOVEMENT;\n/**\n * Standard controller configurations.\n */\nWebXRControllerMovement.REGISTRATIONS = {\n    default: [\n        {\n            allowedComponentTypes: [WebXRControllerComponent.THUMBSTICK_TYPE, WebXRControllerComponent.TOUCHPAD_TYPE],\n            forceHandedness: \"left\",\n            axisChangedHandler: (axes, movementState, featureContext) => {\n                movementState.rotateX = Math.abs(axes.x) > featureContext.rotationThreshold ? axes.x : 0;\n                movementState.rotateY = Math.abs(axes.y) > featureContext.rotationThreshold ? axes.y : 0;\n            },\n        },\n        {\n            allowedComponentTypes: [WebXRControllerComponent.THUMBSTICK_TYPE, WebXRControllerComponent.TOUCHPAD_TYPE],\n            forceHandedness: \"right\",\n            axisChangedHandler: (axes, movementState, featureContext) => {\n                movementState.moveX = Math.abs(axes.x) > featureContext.movementThreshold ? axes.x : 0;\n                movementState.moveY = Math.abs(axes.y) > featureContext.movementThreshold ? axes.y : 0;\n            },\n        },\n    ],\n};\n/**\n * The (Babylon) version of this module.\n * This is an integer representing the implementation version.\n * This number does not correspond to the webxr specs version\n */\nWebXRControllerMovement.Version = 1;\nWebXRFeaturesManager.AddWebXRFeature(WebXRControllerMovement.Name, (xrSessionManager, options) => {\n    return () => new WebXRControllerMovement(xrSessionManager, options);\n}, WebXRControllerMovement.Version, true);\n//# sourceMappingURL=WebXRControllerMovement.js.map","import { WebGLHardwareTexture } from \"../../Engines/WebGL/webGLHardwareTexture.js\";\nimport { InternalTexture, InternalTextureSource } from \"../../Materials/Textures/internalTexture.js\";\nimport { Observable } from \"../../Misc/observable.js\";\nimport { Tools } from \"../../Misc/tools.js\";\nimport { WebXRFeatureName, WebXRFeaturesManager } from \"../webXRFeaturesManager.js\";\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature.js\";\n\nimport { Color3 } from \"../../Maths/math.color.js\";\nimport { Vector3 } from \"../../Maths/math.vector.js\";\nimport { DirectionalLight } from \"../../Lights/directionalLight.js\";\nimport { BaseTexture } from \"../../Materials/Textures/baseTexture.js\";\nimport { SphericalHarmonics, SphericalPolynomial } from \"../../Maths/sphericalPolynomial.js\";\nimport { LightConstants } from \"../../Lights/lightConstants.js\";\n/**\n * Light Estimation Feature\n *\n * @since 5.0.0\n */\nexport class WebXRLightEstimation extends WebXRAbstractFeature {\n    /**\n     * Creates a new instance of the light estimation feature\n     * @param _xrSessionManager an instance of WebXRSessionManager\n     * @param options options to use when constructing this feature\n     */\n    constructor(_xrSessionManager, \n    /**\n     * options to use when constructing this feature\n     */\n    options) {\n        super(_xrSessionManager);\n        this.options = options;\n        this._canvasContext = null;\n        this._reflectionCubeMap = null;\n        this._xrLightEstimate = null;\n        this._xrLightProbe = null;\n        this._xrWebGLBinding = null;\n        this._lightDirection = Vector3.Up().negateInPlace();\n        this._lightColor = Color3.White();\n        this._intensity = 1;\n        this._sphericalHarmonics = new SphericalHarmonics();\n        this._cubeMapPollTime = Date.now();\n        this._lightEstimationPollTime = Date.now();\n        /**\n         * ARCore's reflection cube map size is 16x16.\n         * Once other systems support this feature we will need to change this to be dynamic.\n         * see https://github.com/immersive-web/lighting-estimation/blob/main/lighting-estimation-explainer.md#cube-map-open-questions\n         */\n        this._reflectionCubeMapTextureSize = 16;\n        /**\n         * If createDirectionalLightSource is set to true this light source will be created automatically.\n         * Otherwise this can be set with an external directional light source.\n         * This light will be updated whenever the light estimation values change.\n         */\n        this.directionalLight = null;\n        /**\n         * This observable will notify when the reflection cube map is updated.\n         */\n        this.onReflectionCubeMapUpdatedObservable = new Observable();\n        /**\n         * Event Listener for \"reflectionchange\" events.\n         */\n        this._updateReflectionCubeMap = () => {\n            var _a;\n            if (!this._xrLightProbe) {\n                return;\n            }\n            // check poll time, do not update if it has not been long enough\n            if (this.options.cubeMapPollInterval) {\n                const now = Date.now();\n                if (now - this._cubeMapPollTime < this.options.cubeMapPollInterval) {\n                    return;\n                }\n                this._cubeMapPollTime = now;\n            }\n            const lp = this._getXRGLBinding().getReflectionCubeMap(this._xrLightProbe);\n            if (lp && this._reflectionCubeMap) {\n                if (!this._reflectionCubeMap._texture) {\n                    const internalTexture = new InternalTexture(this._xrSessionManager.scene.getEngine(), InternalTextureSource.Unknown);\n                    internalTexture.isCube = true;\n                    internalTexture.invertY = false;\n                    internalTexture._useSRGBBuffer = this.options.reflectionFormat === \"srgba8\";\n                    internalTexture.format = 5;\n                    internalTexture.generateMipMaps = true;\n                    internalTexture.type = this.options.reflectionFormat !== \"srgba8\" ? 2 : 0;\n                    internalTexture.samplingMode = 3;\n                    internalTexture.width = this._reflectionCubeMapTextureSize;\n                    internalTexture.height = this._reflectionCubeMapTextureSize;\n                    internalTexture._cachedWrapU = 1;\n                    internalTexture._cachedWrapV = 1;\n                    internalTexture._hardwareTexture = new WebGLHardwareTexture(lp, this._getCanvasContext());\n                    this._reflectionCubeMap._texture = internalTexture;\n                }\n                else {\n                    (_a = this._reflectionCubeMap._texture._hardwareTexture) === null || _a === void 0 ? void 0 : _a.set(lp);\n                    this._reflectionCubeMap._texture.getEngine().resetTextureCache();\n                }\n                this._reflectionCubeMap._texture.isReady = true;\n                this._xrSessionManager.scene.markAllMaterialsAsDirty(1);\n                this.onReflectionCubeMapUpdatedObservable.notifyObservers(this._reflectionCubeMap);\n            }\n        };\n        this.xrNativeFeatureName = \"light-estimation\";\n        if (this.options.createDirectionalLightSource) {\n            this.directionalLight = new DirectionalLight(\"light estimation directional\", this._lightDirection, this._xrSessionManager.scene);\n            this.directionalLight.position = new Vector3(0, 8, 0);\n            // intensity will be set later\n            this.directionalLight.intensity = 0;\n            this.directionalLight.falloffType = LightConstants.FALLOFF_GLTF;\n        }\n        // https://immersive-web.github.io/lighting-estimation/\n        Tools.Warn(\"light-estimation is an experimental and unstable feature.\");\n    }\n    /**\n     * While the estimated cube map is expected to update over time to better reflect the user's environment as they move around those changes are unlikely to happen with every XRFrame.\n     * Since creating and processing the cube map is potentially expensive, especially if mip maps are needed, you can listen to the onReflectionCubeMapUpdatedObservable to determine\n     * when it has been updated.\n     */\n    get reflectionCubeMapTexture() {\n        return this._reflectionCubeMap;\n    }\n    /**\n     * The most recent light estimate.  Available starting on the first frame where the device provides a light probe.\n     */\n    get xrLightingEstimate() {\n        if (this._xrLightEstimate) {\n            return {\n                lightColor: this._lightColor,\n                lightDirection: this._lightDirection,\n                lightIntensity: this._intensity,\n                sphericalHarmonics: this._sphericalHarmonics,\n            };\n        }\n        return this._xrLightEstimate;\n    }\n    _getCanvasContext() {\n        if (this._canvasContext === null) {\n            this._canvasContext = this._xrSessionManager.scene.getEngine()._gl;\n        }\n        return this._canvasContext;\n    }\n    _getXRGLBinding() {\n        if (this._xrWebGLBinding === null) {\n            const context = this._getCanvasContext();\n            this._xrWebGLBinding = new XRWebGLBinding(this._xrSessionManager.session, context);\n        }\n        return this._xrWebGLBinding;\n    }\n    /**\n     * attach this feature\n     * Will usually be called by the features manager\n     *\n     * @returns true if successful.\n     */\n    attach() {\n        var _a;\n        if (!super.attach()) {\n            return false;\n        }\n        const reflectionFormat = (_a = this.options.reflectionFormat) !== null && _a !== void 0 ? _a : (this._xrSessionManager.session.preferredReflectionFormat || \"srgba8\");\n        this.options.reflectionFormat = reflectionFormat;\n        this._xrSessionManager.session\n            .requestLightProbe({\n            reflectionFormat,\n        })\n            .then((xrLightProbe) => {\n            this._xrLightProbe = xrLightProbe;\n            if (!this.options.disableCubeMapReflection) {\n                if (!this._reflectionCubeMap) {\n                    this._reflectionCubeMap = new BaseTexture(this._xrSessionManager.scene);\n                    this._reflectionCubeMap._isCube = true;\n                    this._reflectionCubeMap.coordinatesMode = 3;\n                    if (this.options.setSceneEnvironmentTexture) {\n                        this._xrSessionManager.scene.environmentTexture = this._reflectionCubeMap;\n                    }\n                }\n                this._xrLightProbe.addEventListener(\"reflectionchange\", this._updateReflectionCubeMap);\n            }\n        });\n        return true;\n    }\n    /**\n     * detach this feature.\n     * Will usually be called by the features manager\n     *\n     * @returns true if successful.\n     */\n    detach() {\n        const detached = super.detach();\n        if (this._xrLightProbe !== null && !this.options.disableCubeMapReflection) {\n            this._xrLightProbe.removeEventListener(\"reflectionchange\", this._updateReflectionCubeMap);\n            this._xrLightProbe = null;\n        }\n        this._canvasContext = null;\n        this._xrLightEstimate = null;\n        // When the session ends (on detach) we must clear our XRWebGLBinging instance, which references the ended session.\n        this._xrWebGLBinding = null;\n        return detached;\n    }\n    /**\n     * Dispose this feature and all of the resources attached\n     */\n    dispose() {\n        super.dispose();\n        this.onReflectionCubeMapUpdatedObservable.clear();\n        if (this.directionalLight) {\n            this.directionalLight.dispose();\n            this.directionalLight = null;\n        }\n        if (this._reflectionCubeMap !== null) {\n            if (this._reflectionCubeMap._texture) {\n                this._reflectionCubeMap._texture.dispose();\n            }\n            this._reflectionCubeMap.dispose();\n            this._reflectionCubeMap = null;\n        }\n    }\n    _onXRFrame(_xrFrame) {\n        var _a;\n        if (this._xrLightProbe !== null) {\n            if (this.options.lightEstimationPollInterval) {\n                const now = Date.now();\n                if (now - this._lightEstimationPollTime < this.options.lightEstimationPollInterval) {\n                    return;\n                }\n                this._lightEstimationPollTime = now;\n            }\n            this._xrLightEstimate = _xrFrame.getLightEstimate(this._xrLightProbe);\n            if (this._xrLightEstimate) {\n                this._intensity = Math.max(1.0, this._xrLightEstimate.primaryLightIntensity.x, this._xrLightEstimate.primaryLightIntensity.y, this._xrLightEstimate.primaryLightIntensity.z);\n                const rhsFactor = this._xrSessionManager.scene.useRightHandedSystem ? 1.0 : -1.0;\n                // recreate the vector caches, so that the last one provided to the user will persist\n                if (this.options.disableVectorReuse) {\n                    this._lightDirection = new Vector3();\n                    this._lightColor = new Color3();\n                    if (this.directionalLight) {\n                        this.directionalLight.direction = this._lightDirection;\n                        this.directionalLight.diffuse = this._lightColor;\n                    }\n                }\n                this._lightDirection.copyFromFloats(this._xrLightEstimate.primaryLightDirection.x, this._xrLightEstimate.primaryLightDirection.y, this._xrLightEstimate.primaryLightDirection.z * rhsFactor);\n                this._lightColor.copyFromFloats(this._xrLightEstimate.primaryLightIntensity.x / this._intensity, this._xrLightEstimate.primaryLightIntensity.y / this._intensity, this._xrLightEstimate.primaryLightIntensity.z / this._intensity);\n                this._sphericalHarmonics.updateFromFloatsArray(this._xrLightEstimate.sphericalHarmonicsCoefficients);\n                if (this._reflectionCubeMap && !this.options.disableSphericalPolynomial) {\n                    this._reflectionCubeMap.sphericalPolynomial = this._reflectionCubeMap.sphericalPolynomial || new SphericalPolynomial();\n                    (_a = this._reflectionCubeMap.sphericalPolynomial) === null || _a === void 0 ? void 0 : _a.updateFromHarmonics(this._sphericalHarmonics);\n                }\n                // direction from instead of direction to\n                this._lightDirection.negateInPlace();\n                // set the values after calculating them\n                if (this.directionalLight) {\n                    this.directionalLight.direction.copyFrom(this._lightDirection);\n                    this.directionalLight.intensity = Math.min(this._intensity, 1.0);\n                    this.directionalLight.diffuse.copyFrom(this._lightColor);\n                }\n            }\n        }\n    }\n}\n/**\n * The module's name\n */\nWebXRLightEstimation.Name = WebXRFeatureName.LIGHT_ESTIMATION;\n/**\n * The (Babylon) version of this module.\n * This is an integer representing the implementation version.\n * This number does not correspond to the WebXR specs version\n */\nWebXRLightEstimation.Version = 1;\n// register the plugin\nWebXRFeaturesManager.AddWebXRFeature(WebXRLightEstimation.Name, (xrSessionManager, options) => {\n    return () => new WebXRLightEstimation(xrSessionManager, options);\n}, WebXRLightEstimation.Version, false);\n//# sourceMappingURL=WebXRLightEstimation.js.map","import { WebXRFeaturesManager, WebXRFeatureName } from \"../webXRFeaturesManager.js\";\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature.js\";\nimport { Observable } from \"../../Misc/observable.js\";\nimport { Vector3, TmpVectors } from \"../../Maths/math.vector.js\";\nimport { Ray } from \"../../Culling/ray.js\";\n/**\n * The WebXR Eye Tracking feature grabs eye data from the device and provides it in an easy-access format.\n * Currently only enabled for BabylonNative applications.\n */\nexport class WebXREyeTracking extends WebXRAbstractFeature {\n    /**\n     * Creates a new instance of the XR eye tracking feature.\n     * @param _xrSessionManager An instance of WebXRSessionManager.\n     */\n    constructor(_xrSessionManager) {\n        super(_xrSessionManager);\n        /**\n         * This observable will notify registered observers when eye tracking starts\n         */\n        this.onEyeTrackingStartedObservable = new Observable();\n        /**\n         * This observable will notify registered observers when eye tracking ends\n         */\n        this.onEyeTrackingEndedObservable = new Observable();\n        /**\n         * This observable will notify registered observers on each frame that has valid tracking\n         */\n        this.onEyeTrackingFrameUpdateObservable = new Observable();\n        this._eyeTrackingStartListener = (event) => {\n            this._latestEyeSpace = event.gazeSpace;\n            this._gazeRay = new Ray(Vector3.Zero(), Vector3.Forward());\n            this.onEyeTrackingStartedObservable.notifyObservers(this._gazeRay);\n        };\n        this._eyeTrackingEndListener = () => {\n            this._latestEyeSpace = null;\n            this._gazeRay = null;\n            this.onEyeTrackingEndedObservable.notifyObservers();\n        };\n        this.xrNativeFeatureName = \"eye-tracking\";\n        if (this._xrSessionManager.session) {\n            this._init();\n        }\n        else {\n            this._xrSessionManager.onXRSessionInit.addOnce(() => {\n                this._init();\n            });\n        }\n    }\n    /**\n     * Dispose this feature and all of the resources attached.\n     */\n    dispose() {\n        super.dispose();\n        this._xrSessionManager.session.removeEventListener(\"eyetrackingstart\", this._eyeTrackingStartListener);\n        this._xrSessionManager.session.removeEventListener(\"eyetrackingend\", this._eyeTrackingEndListener);\n        this.onEyeTrackingStartedObservable.clear();\n        this.onEyeTrackingEndedObservable.clear();\n        this.onEyeTrackingFrameUpdateObservable.clear();\n    }\n    /**\n     * Returns whether the gaze data is valid or not\n     * @returns true if the data is valid\n     */\n    get isEyeGazeValid() {\n        return !!this._gazeRay;\n    }\n    /**\n     * Get a reference to the gaze ray. This data is valid while eye tracking persists, and will be set to null when gaze data is no longer available\n     * @returns a reference to the gaze ray if it exists and is valid, returns null otherwise.\n     */\n    getEyeGaze() {\n        return this._gazeRay;\n    }\n    _onXRFrame(frame) {\n        if (!this.attached || !frame) {\n            return;\n        }\n        if (this._latestEyeSpace && this._gazeRay) {\n            const pose = frame.getPose(this._latestEyeSpace, this._xrSessionManager.referenceSpace);\n            if (pose) {\n                this._gazeRay.origin.set(pose.transform.position.x, pose.transform.position.y, pose.transform.position.z);\n                const quat = pose.transform.orientation;\n                TmpVectors.Quaternion[0].set(quat.x, quat.y, quat.z, quat.w);\n                if (!this._xrSessionManager.scene.useRightHandedSystem) {\n                    this._gazeRay.origin.z *= -1;\n                    TmpVectors.Quaternion[0].z *= -1;\n                    TmpVectors.Quaternion[0].w *= -1;\n                    Vector3.LeftHandedForwardReadOnly.rotateByQuaternionToRef(TmpVectors.Quaternion[0], this._gazeRay.direction);\n                }\n                else {\n                    Vector3.RightHandedForwardReadOnly.rotateByQuaternionToRef(TmpVectors.Quaternion[0], this._gazeRay.direction);\n                }\n                this.onEyeTrackingFrameUpdateObservable.notifyObservers(this._gazeRay);\n            }\n        }\n    }\n    _init() {\n        // Only supported by BabylonNative\n        if (this._xrSessionManager.isNative) {\n            this._xrSessionManager.session.addEventListener(\"eyetrackingstart\", this._eyeTrackingStartListener);\n            this._xrSessionManager.session.addEventListener(\"eyetrackingend\", this._eyeTrackingEndListener);\n        }\n    }\n}\n/**\n * The module's name\n */\nWebXREyeTracking.Name = WebXRFeatureName.EYE_TRACKING;\n/**\n * The (Babylon) version of this module.\n * This is an integer representing the implementation version.\n * This number does not correspond to the WebXR specs version\n */\nWebXREyeTracking.Version = 1;\nWebXRFeaturesManager.AddWebXRFeature(WebXREyeTracking.Name, (xrSessionManager) => {\n    return () => new WebXREyeTracking(xrSessionManager);\n}, WebXREyeTracking.Version, false);\n//# sourceMappingURL=WebXREyeTracking.js.map","import { TmpVectors, Vector2, Vector3 } from \"../../Maths/math.vector.js\";\nimport { Logger } from \"../../Misc/logger.js\";\nimport { Observable } from \"../../Misc/observable.js\";\nimport { WebXRFeatureName, WebXRFeaturesManager } from \"../webXRFeaturesManager.js\";\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature.js\";\nclass CircleBuffer {\n    constructor(numSamples, initializer) {\n        this._samples = [];\n        this._idx = 0;\n        for (let idx = 0; idx < numSamples; ++idx) {\n            this._samples.push(initializer ? initializer() : Vector2.Zero());\n        }\n    }\n    get length() {\n        return this._samples.length;\n    }\n    push(x, y) {\n        this._idx = (this._idx + this._samples.length - 1) % this._samples.length;\n        this.at(0).copyFromFloats(x, y);\n    }\n    at(idx) {\n        if (idx >= this._samples.length) {\n            throw new Error(\"Index out of bounds\");\n        }\n        return this._samples[(this._idx + idx) % this._samples.length];\n    }\n}\nclass FirstStepDetector {\n    constructor() {\n        this._samples = new CircleBuffer(20);\n        this._entropy = 0;\n        this.onFirstStepDetected = new Observable();\n    }\n    update(posX, posY, forwardX, forwardY) {\n        this._samples.push(posX, posY);\n        const origin = this._samples.at(0);\n        this._entropy *= this._entropyDecayFactor;\n        this._entropy += Vector2.Distance(origin, this._samples.at(1));\n        if (this._entropy > this._entropyThreshold) {\n            return;\n        }\n        let samePointIdx;\n        for (samePointIdx = this._samePointCheckStartIdx; samePointIdx < this._samples.length; ++samePointIdx) {\n            if (Vector2.DistanceSquared(origin, this._samples.at(samePointIdx)) < this._samePointSquaredDistanceThreshold) {\n                break;\n            }\n        }\n        if (samePointIdx === this._samples.length) {\n            return;\n        }\n        let apexDistSquared = -1;\n        let apexIdx = 0;\n        for (let distSquared, idx = 1; idx < samePointIdx; ++idx) {\n            distSquared = Vector2.DistanceSquared(origin, this._samples.at(idx));\n            if (distSquared > apexDistSquared) {\n                apexIdx = idx;\n                apexDistSquared = distSquared;\n            }\n        }\n        if (apexDistSquared < this._apexSquaredDistanceThreshold) {\n            return;\n        }\n        const apex = this._samples.at(apexIdx);\n        const axis = apex.subtract(origin);\n        axis.normalize();\n        const vec = TmpVectors.Vector2[0];\n        let dot;\n        let sample;\n        let sumSquaredProjectionDistances = 0;\n        for (let idx = 1; idx < samePointIdx; ++idx) {\n            sample = this._samples.at(idx);\n            sample.subtractToRef(origin, vec);\n            dot = Vector2.Dot(axis, vec);\n            sumSquaredProjectionDistances += vec.lengthSquared() - dot * dot;\n        }\n        if (sumSquaredProjectionDistances > samePointIdx * this._squaredProjectionDistanceThreshold) {\n            return;\n        }\n        const forwardVec = TmpVectors.Vector3[0];\n        forwardVec.set(forwardX, forwardY, 0);\n        const axisVec = TmpVectors.Vector3[1];\n        axisVec.set(axis.x, axis.y, 0);\n        const isApexLeft = Vector3.Cross(forwardVec, axisVec).z > 0;\n        const leftApex = origin.clone();\n        const rightApex = origin.clone();\n        apex.subtractToRef(origin, axis);\n        if (isApexLeft) {\n            axis.scaleAndAddToRef(this._axisToApexShrinkFactor, leftApex);\n            axis.scaleAndAddToRef(this._axisToApexExtendFactor, rightApex);\n        }\n        else {\n            axis.scaleAndAddToRef(this._axisToApexExtendFactor, leftApex);\n            axis.scaleAndAddToRef(this._axisToApexShrinkFactor, rightApex);\n        }\n        this.onFirstStepDetected.notifyObservers({\n            leftApex: leftApex,\n            rightApex: rightApex,\n            currentPosition: origin,\n            currentStepDirection: isApexLeft ? \"right\" : \"left\",\n        });\n    }\n    reset() {\n        for (let idx = 0; idx < this._samples.length; ++idx) {\n            this._samples.at(idx).copyFromFloats(0, 0);\n        }\n    }\n    get _samePointCheckStartIdx() {\n        return Math.floor(this._samples.length / 3);\n    }\n    get _samePointSquaredDistanceThreshold() {\n        return 0.03 * 0.03;\n    }\n    get _apexSquaredDistanceThreshold() {\n        return 0.09 * 0.09;\n    }\n    get _squaredProjectionDistanceThreshold() {\n        return 0.03 * 0.03;\n    }\n    get _axisToApexShrinkFactor() {\n        return 0.8;\n    }\n    get _axisToApexExtendFactor() {\n        return -1.6;\n    }\n    get _entropyDecayFactor() {\n        return 0.93;\n    }\n    get _entropyThreshold() {\n        return 0.4;\n    }\n}\nclass WalkingTracker {\n    constructor(leftApex, rightApex, currentPosition, currentStepDirection) {\n        this._leftApex = new Vector2();\n        this._rightApex = new Vector2();\n        this._currentPosition = new Vector2();\n        this._axis = new Vector2();\n        this._axisLength = -1;\n        this._forward = new Vector2();\n        this._steppingLeft = false;\n        this._t = -1;\n        this._maxT = -1;\n        this._maxTPosition = new Vector2();\n        this._vitality = 0;\n        this.onMovement = new Observable();\n        this.onFootfall = new Observable();\n        this._reset(leftApex, rightApex, currentPosition, currentStepDirection === \"left\");\n    }\n    _reset(leftApex, rightApex, currentPosition, steppingLeft) {\n        this._leftApex.copyFrom(leftApex);\n        this._rightApex.copyFrom(rightApex);\n        this._steppingLeft = steppingLeft;\n        if (this._steppingLeft) {\n            this._leftApex.subtractToRef(this._rightApex, this._axis);\n            this._forward.copyFromFloats(-this._axis.y, this._axis.x);\n        }\n        else {\n            this._rightApex.subtractToRef(this._leftApex, this._axis);\n            this._forward.copyFromFloats(this._axis.y, -this._axis.x);\n        }\n        this._axisLength = this._axis.length();\n        this._forward.scaleInPlace(1 / this._axisLength);\n        this._updateTAndVitality(currentPosition.x, currentPosition.y);\n        this._maxT = this._t;\n        this._maxTPosition.copyFrom(currentPosition);\n        this._vitality = 1;\n    }\n    _updateTAndVitality(x, y) {\n        this._currentPosition.copyFromFloats(x, y);\n        if (this._steppingLeft) {\n            this._currentPosition.subtractInPlace(this._rightApex);\n        }\n        else {\n            this._currentPosition.subtractInPlace(this._leftApex);\n        }\n        const priorT = this._t;\n        const dot = Vector2.Dot(this._currentPosition, this._axis);\n        this._t = dot / (this._axisLength * this._axisLength);\n        const projDistSquared = this._currentPosition.lengthSquared() - (dot / this._axisLength) * (dot / this._axisLength);\n        // TODO: Extricate the magic.\n        this._vitality *= 0.92 - 100 * Math.max(projDistSquared - 0.0016, 0) + Math.max(this._t - priorT, 0);\n    }\n    update(x, y) {\n        if (this._vitality < this._vitalityThreshold) {\n            return false;\n        }\n        const priorT = this._t;\n        this._updateTAndVitality(x, y);\n        if (this._t > this._maxT) {\n            this._maxT = this._t;\n            this._maxTPosition.copyFromFloats(x, y);\n        }\n        if (this._vitality < this._vitalityThreshold) {\n            return false;\n        }\n        if (this._t > priorT) {\n            this.onMovement.notifyObservers({ deltaT: this._t - priorT });\n            if (priorT < 0.5 && this._t >= 0.5) {\n                this.onFootfall.notifyObservers({ foot: this._steppingLeft ? \"left\" : \"right\" });\n            }\n        }\n        if (this._t < 0.95 * this._maxT) {\n            this._currentPosition.copyFromFloats(x, y);\n            if (this._steppingLeft) {\n                this._leftApex.copyFrom(this._maxTPosition);\n            }\n            else {\n                this._rightApex.copyFrom(this._maxTPosition);\n            }\n            this._reset(this._leftApex, this._rightApex, this._currentPosition, !this._steppingLeft);\n        }\n        if (this._axisLength < 0.03) {\n            return false;\n        }\n        return true;\n    }\n    get _vitalityThreshold() {\n        return 0.1;\n    }\n    get forward() {\n        return this._forward;\n    }\n}\nclass Walker {\n    static get _MillisecondsPerUpdate() {\n        // 15 FPS\n        return 1000 / 15;\n    }\n    constructor(engine) {\n        this._detector = new FirstStepDetector();\n        this._walker = null;\n        this._movement = new Vector2();\n        this._millisecondsSinceLastUpdate = Walker._MillisecondsPerUpdate;\n        this.movementThisFrame = Vector3.Zero();\n        this._engine = engine;\n        this._detector.onFirstStepDetected.add((event) => {\n            if (!this._walker) {\n                this._walker = new WalkingTracker(event.leftApex, event.rightApex, event.currentPosition, event.currentStepDirection);\n                this._walker.onFootfall.add(() => {\n                    console.log(\"Footfall!\");\n                });\n                this._walker.onMovement.add((event) => {\n                    this._walker.forward.scaleAndAddToRef(0.024 * event.deltaT, this._movement);\n                });\n            }\n        });\n    }\n    update(position, forward) {\n        forward.y = 0;\n        forward.normalize();\n        // Enforce reduced framerate\n        this._millisecondsSinceLastUpdate += this._engine.getDeltaTime();\n        if (this._millisecondsSinceLastUpdate >= Walker._MillisecondsPerUpdate) {\n            this._millisecondsSinceLastUpdate -= Walker._MillisecondsPerUpdate;\n            this._detector.update(position.x, position.z, forward.x, forward.z);\n            if (this._walker) {\n                const updated = this._walker.update(position.x, position.z);\n                if (!updated) {\n                    this._walker = null;\n                }\n            }\n            this._movement.scaleInPlace(0.85);\n        }\n        this.movementThisFrame.set(this._movement.x, 0, this._movement.y);\n    }\n}\n/**\n * A module that will enable VR locomotion by detecting when the user walks in place.\n */\nexport class WebXRWalkingLocomotion extends WebXRAbstractFeature {\n    /**\n     * The module's name.\n     */\n    static get Name() {\n        return WebXRFeatureName.WALKING_LOCOMOTION;\n    }\n    /**\n     * The (Babylon) version of this module.\n     * This is an integer representing the implementation version.\n     * This number has no external basis.\n     */\n    static get Version() {\n        return 1;\n    }\n    /**\n     * The target to be articulated by walking locomotion.\n     * When the walking locomotion feature detects walking in place, this element's\n     * X and Z coordinates will be modified to reflect locomotion. This target should\n     * be either the XR space's origin (i.e., the parent node of the WebXRCamera) or\n     * the WebXRCamera itself. Note that the WebXRCamera path will modify the position\n     * of the WebXRCamera directly and is thus discouraged.\n     */\n    get locomotionTarget() {\n        return this._locomotionTarget;\n    }\n    /**\n     * The target to be articulated by walking locomotion.\n     * When the walking locomotion feature detects walking in place, this element's\n     * X and Z coordinates will be modified to reflect locomotion. This target should\n     * be either the XR space's origin (i.e., the parent node of the WebXRCamera) or\n     * the WebXRCamera itself. Note that the WebXRCamera path will modify the position\n     * of the WebXRCamera directly and is thus discouraged.\n     */\n    set locomotionTarget(locomotionTarget) {\n        this._locomotionTarget = locomotionTarget;\n        this._isLocomotionTargetWebXRCamera = this._locomotionTarget.getClassName() === \"WebXRCamera\";\n    }\n    /**\n     * Construct a new Walking Locomotion feature.\n     * @param sessionManager manager for the current XR session\n     * @param options creation options, prominently including the vector target for locomotion\n     */\n    constructor(sessionManager, options) {\n        super(sessionManager);\n        this._up = new Vector3();\n        this._forward = new Vector3();\n        this._position = new Vector3();\n        this._movement = new Vector3();\n        this._sessionManager = sessionManager;\n        this.locomotionTarget = options.locomotionTarget;\n        if (this._isLocomotionTargetWebXRCamera) {\n            Logger.Warn(\"Using walking locomotion directly on a WebXRCamera may have unintended interactions with other XR techniques. Using an XR space parent is highly recommended\");\n        }\n    }\n    /**\n     * Checks whether this feature is compatible with the current WebXR session.\n     * Walking locomotion is only compatible with \"immersive-vr\" sessions.\n     * @returns true if compatible, false otherwise\n     */\n    isCompatible() {\n        return this._sessionManager.sessionMode === undefined || this._sessionManager.sessionMode === \"immersive-vr\";\n    }\n    /**\n     * Attaches the feature.\n     * Typically called automatically by the features manager.\n     * @returns true if attach succeeded, false otherwise\n     */\n    attach() {\n        if (!this.isCompatible || !super.attach()) {\n            return false;\n        }\n        this._walker = new Walker(this._sessionManager.scene.getEngine());\n        return true;\n    }\n    /**\n     * Detaches the feature.\n     * Typically called automatically by the features manager.\n     * @returns true if detach succeeded, false otherwise\n     */\n    detach() {\n        if (!super.detach()) {\n            return false;\n        }\n        this._walker = null;\n        return true;\n    }\n    _onXRFrame(frame) {\n        const pose = frame.getViewerPose(this._sessionManager.baseReferenceSpace);\n        if (!pose) {\n            return;\n        }\n        const handednessScalar = this.locomotionTarget.getScene().useRightHandedSystem ? 1 : -1;\n        const m = pose.transform.matrix;\n        this._up.copyFromFloats(m[4], m[5], handednessScalar * m[6]);\n        this._forward.copyFromFloats(m[8], m[9], handednessScalar * m[10]);\n        this._position.copyFromFloats(m[12], m[13], handednessScalar * m[14]);\n        // Compute the nape position\n        this._forward.scaleAndAddToRef(0.05, this._position);\n        this._up.scaleAndAddToRef(-0.05, this._position);\n        this._walker.update(this._position, this._forward);\n        this._movement.copyFrom(this._walker.movementThisFrame);\n        if (!this._isLocomotionTargetWebXRCamera) {\n            Vector3.TransformNormalToRef(this._movement, this.locomotionTarget.getWorldMatrix(), this._movement);\n        }\n        this.locomotionTarget.position.addInPlace(this._movement);\n    }\n}\n//register the plugin\nWebXRFeaturesManager.AddWebXRFeature(WebXRWalkingLocomotion.Name, (xrSessionManager, options) => {\n    return () => new WebXRWalkingLocomotion(xrSessionManager, options);\n}, WebXRWalkingLocomotion.Version, false);\n//# sourceMappingURL=WebXRWalkingLocomotion.js.map","import { WebXRFeatureName, WebXRFeaturesManager } from \"../webXRFeaturesManager.js\";\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature.js\";\nimport { WebXRLayerRenderTargetTextureProvider } from \"../webXRRenderTargetTextureProvider.js\";\nimport { WebXRLayerWrapper } from \"../webXRLayerWrapper.js\";\nimport { WebXRWebGLLayerWrapper } from \"../webXRWebGLLayer.js\";\n/**\n * Wraps xr composition layers.\n * @internal\n */\nexport class WebXRCompositionLayerWrapper extends WebXRLayerWrapper {\n    constructor(getWidth, getHeight, layer, layerType, isMultiview, createRTTProvider) {\n        super(getWidth, getHeight, layer, layerType, createRTTProvider);\n        this.getWidth = getWidth;\n        this.getHeight = getHeight;\n        this.layer = layer;\n        this.layerType = layerType;\n        this.isMultiview = isMultiview;\n        this.createRTTProvider = createRTTProvider;\n    }\n}\n/**\n * Provides render target textures and other important rendering information for a given XRCompositionLayer.\n * @internal\n */\nclass WebXRCompositionLayerRenderTargetTextureProvider extends WebXRLayerRenderTargetTextureProvider {\n    constructor(_xrSessionManager, _xrWebGLBinding, layerWrapper) {\n        super(_xrSessionManager.scene, layerWrapper);\n        this._xrSessionManager = _xrSessionManager;\n        this._xrWebGLBinding = _xrWebGLBinding;\n        this.layerWrapper = layerWrapper;\n        this._lastSubImages = new Map();\n        this._compositionLayer = layerWrapper.layer;\n    }\n    _getRenderTargetForSubImage(subImage, eye) {\n        const lastSubImage = this._lastSubImages.get(eye);\n        const eyeIndex = eye == \"left\" ? 0 : 1;\n        if (!this._renderTargetTextures[eyeIndex] || (lastSubImage === null || lastSubImage === void 0 ? void 0 : lastSubImage.textureWidth) !== subImage.textureWidth || (lastSubImage === null || lastSubImage === void 0 ? void 0 : lastSubImage.textureHeight) != subImage.textureHeight) {\n            this._renderTargetTextures[eyeIndex] = this._createRenderTargetTexture(subImage.textureWidth, subImage.textureHeight, null, subImage.colorTexture, subImage.depthStencilTexture, this.layerWrapper.isMultiview);\n            this._framebufferDimensions = {\n                framebufferWidth: subImage.textureWidth,\n                framebufferHeight: subImage.textureHeight,\n            };\n        }\n        this._lastSubImages.set(eye, subImage);\n        return this._renderTargetTextures[eyeIndex];\n    }\n    _getSubImageForEye(eye) {\n        const currentFrame = this._xrSessionManager.currentFrame;\n        if (currentFrame) {\n            return this._xrWebGLBinding.getSubImage(this._compositionLayer, currentFrame, eye);\n        }\n        return null;\n    }\n    getRenderTargetTextureForEye(eye) {\n        const subImage = this._getSubImageForEye(eye);\n        if (subImage) {\n            return this._getRenderTargetForSubImage(subImage, eye);\n        }\n        return null;\n    }\n    getRenderTargetTextureForView(view) {\n        return this.getRenderTargetTextureForEye(view.eye);\n    }\n    _setViewportForSubImage(viewport, subImage) {\n        const textureWidth = subImage.textureWidth;\n        const textureHeight = subImage.textureHeight;\n        const xrViewport = subImage.viewport;\n        viewport.x = xrViewport.x / textureWidth;\n        viewport.y = xrViewport.y / textureHeight;\n        viewport.width = xrViewport.width / textureWidth;\n        viewport.height = xrViewport.height / textureHeight;\n    }\n    trySetViewportForView(viewport, view) {\n        const subImage = this._lastSubImages.get(view.eye) || this._getSubImageForEye(view.eye);\n        if (subImage) {\n            this._setViewportForSubImage(viewport, subImage);\n            return true;\n        }\n        return false;\n    }\n}\n/**\n * Wraps xr projection layers.\n * @internal\n */\nexport class WebXRProjectionLayerWrapper extends WebXRCompositionLayerWrapper {\n    constructor(layer, isMultiview, xrGLBinding) {\n        super(() => layer.textureWidth, () => layer.textureHeight, layer, \"XRProjectionLayer\", isMultiview, (sessionManager) => new WebXRProjectionLayerRenderTargetTextureProvider(sessionManager, xrGLBinding, this));\n        this.layer = layer;\n    }\n}\n/**\n * Provides render target textures and other important rendering information for a given XRProjectionLayer.\n * @internal\n */\nclass WebXRProjectionLayerRenderTargetTextureProvider extends WebXRCompositionLayerRenderTargetTextureProvider {\n    constructor(_xrSessionManager, _xrWebGLBinding, layerWrapper) {\n        super(_xrSessionManager, _xrWebGLBinding, layerWrapper);\n        this.layerWrapper = layerWrapper;\n        this._projectionLayer = layerWrapper.layer;\n    }\n    _getSubImageForView(view) {\n        return this._xrWebGLBinding.getViewSubImage(this._projectionLayer, view);\n    }\n    getRenderTargetTextureForView(view) {\n        return this._getRenderTargetForSubImage(this._getSubImageForView(view), view.eye);\n    }\n    getRenderTargetTextureForEye(eye) {\n        const lastSubImage = this._lastSubImages.get(eye);\n        if (lastSubImage) {\n            return this._getRenderTargetForSubImage(lastSubImage, eye);\n        }\n        return null;\n    }\n    trySetViewportForView(viewport, view) {\n        const subImage = this._lastSubImages.get(view.eye) || this._getSubImageForView(view);\n        if (subImage) {\n            this._setViewportForSubImage(viewport, subImage);\n            return true;\n        }\n        return false;\n    }\n}\nconst defaultXRWebGLLayerInit = {};\nconst defaultXRProjectionLayerInit = {\n    textureType: \"texture\",\n    colorFormat: 0x1908 /* WebGLRenderingContext.RGBA */,\n    depthFormat: 0x88f0 /* WebGLRenderingContext.DEPTH24_STENCIL8 */,\n    scaleFactor: 1.0,\n};\n/**\n * Exposes the WebXR Layers API.\n */\nexport class WebXRLayers extends WebXRAbstractFeature {\n    constructor(_xrSessionManager, _options = {}) {\n        super(_xrSessionManager);\n        this._options = _options;\n        /**\n         * Already-created layers\n         */\n        this._existingLayers = [];\n        this.xrNativeFeatureName = \"layers\";\n    }\n    /**\n     * Attach this feature.\n     * Will usually be called by the features manager.\n     *\n     * @returns true if successful.\n     */\n    attach() {\n        if (!super.attach()) {\n            return false;\n        }\n        const engine = this._xrSessionManager.scene.getEngine();\n        this._glContext = engine._gl;\n        this._xrWebGLBinding = new XRWebGLBinding(this._xrSessionManager.session, this._glContext);\n        this._existingLayers.length = 0;\n        const projectionLayerInit = { ...defaultXRProjectionLayerInit };\n        const projectionLayerMultiview = this._options.preferMultiviewOnInit && engine.getCaps().multiview;\n        if (projectionLayerMultiview) {\n            projectionLayerInit.textureType = \"texture-array\";\n        }\n        this.addXRSessionLayer(this.createProjectionLayer(projectionLayerInit, projectionLayerMultiview));\n        return true;\n    }\n    detach() {\n        if (!super.detach()) {\n            return false;\n        }\n        this._existingLayers.length = 0;\n        return true;\n    }\n    /**\n     * Creates a new XRWebGLLayer.\n     * @param params an object providing configuration options for the new XRWebGLLayer\n     * @returns the XRWebGLLayer\n     */\n    createXRWebGLLayer(params = defaultXRWebGLLayerInit) {\n        const layer = new XRWebGLLayer(this._xrSessionManager.session, this._glContext, params);\n        return new WebXRWebGLLayerWrapper(layer);\n    }\n    /**\n     * Creates a new XRProjectionLayer.\n     * @param params an object providing configuration options for the new XRProjectionLayer.\n     * @param multiview whether the projection layer should render with multiview.\n     * @returns the projection layer\n     */\n    createProjectionLayer(params = defaultXRProjectionLayerInit, multiview = false) {\n        if (multiview && params.textureType !== \"texture-array\") {\n            throw new Error(\"Projection layers can only be made multiview if they use texture arrays. Set the textureType parameter to 'texture-array'.\");\n        }\n        // TODO (rgerd): Support RTT's that are bound to sub-images in the texture array.\n        if (!multiview && params.textureType === \"texture-array\") {\n            throw new Error(\"We currently only support multiview rendering when the textureType parameter is set to 'texture-array'.\");\n        }\n        const projLayer = this._xrWebGLBinding.createProjectionLayer(params);\n        return new WebXRProjectionLayerWrapper(projLayer, multiview, this._xrWebGLBinding);\n    }\n    /**\n     * Add a new layer to the already-existing list of layers\n     * @param wrappedLayer the new layer to add to the existing ones\n     */\n    addXRSessionLayer(wrappedLayer) {\n        this.setXRSessionLayers([...this._existingLayers, wrappedLayer]);\n    }\n    /**\n     * Sets the layers to be used by the XR session.\n     * Note that you must call this function with any layers you wish to render to\n     * since it adds them to the XR session's render state\n     * (replacing any layers that were added in a previous call to setXRSessionLayers or updateRenderState).\n     * This method also sets up the session manager's render target texture provider\n     * as the first layer in the array, which feeds the WebXR camera(s) attached to the session.\n     * @param wrappedLayers An array of WebXRLayerWrapper, usually returned from the WebXRLayers createLayer functions.\n     */\n    setXRSessionLayers(wrappedLayers) {\n        this._existingLayers = wrappedLayers;\n        const renderStateInit = { ...this._xrSessionManager.session.renderState };\n        // Clear out the layer-related fields.\n        renderStateInit.baseLayer = undefined;\n        renderStateInit.layers = wrappedLayers.map((wrappedLayer) => wrappedLayer.layer);\n        this._xrSessionManager.updateRenderState(renderStateInit);\n        this._xrSessionManager._setBaseLayerWrapper(wrappedLayers.length > 0 ? wrappedLayers[0] : null);\n    }\n    isCompatible() {\n        // TODO (rgerd): Add native support.\n        return !this._xrSessionManager.isNative && typeof XRWebGLBinding !== \"undefined\" && !!XRWebGLBinding.prototype.createProjectionLayer;\n    }\n    /**\n     * Dispose this feature and all of the resources attached.\n     */\n    dispose() {\n        super.dispose();\n    }\n    _onXRFrame(_xrFrame) {\n        /* empty */\n    }\n}\n/**\n * The module's name\n */\nWebXRLayers.Name = WebXRFeatureName.LAYERS;\n/**\n * The (Babylon) version of this module.\n * This is an integer representing the implementation version.\n * This number does not correspond to the WebXR specs version\n */\nWebXRLayers.Version = 1;\n//register the plugin\nWebXRFeaturesManager.AddWebXRFeature(WebXRLayers.Name, (xrSessionManager, options) => {\n    return () => new WebXRLayers(xrSessionManager, options);\n}, WebXRLayers.Version, false);\n//# sourceMappingURL=WebXRLayers.js.map","export * from \"./WebXRAbstractFeature.js\";\nexport * from \"./WebXRHitTestLegacy.js\";\nexport * from \"./WebXRAnchorSystem.js\";\nexport * from \"./WebXRPlaneDetector.js\";\nexport * from \"./WebXRBackgroundRemover.js\";\nexport * from \"./WebXRControllerTeleportation.js\";\nexport * from \"./WebXRControllerPointerSelection.js\";\nexport * from \"./WebXRControllerPhysics.js\";\nexport * from \"./WebXRHitTest.js\";\nexport * from \"./WebXRFeaturePointSystem.js\";\nexport * from \"./WebXRHandTracking.js\";\nexport * from \"./WebXRMeshDetector.js\";\nexport * from \"./WebXRImageTracking.js\";\nexport * from \"./WebXRNearInteraction.js\";\nexport * from \"./WebXRDOMOverlay.js\";\nexport * from \"./WebXRControllerMovement.js\";\nexport * from \"./WebXRLightEstimation.js\";\nexport * from \"./WebXREyeTracking.js\";\nexport * from \"./WebXRWalkingLocomotion.js\";\nexport * from \"./WebXRLayers.js\";\n//# sourceMappingURL=index.js.map","/* eslint-disable import/no-internal-modules */\nexport * from \"./webXRCamera.js\";\nexport * from \"./webXREnterExitUI.js\";\nexport * from \"./webXRExperienceHelper.js\";\nexport * from \"./webXRInput.js\";\nexport * from \"./webXRInputSource.js\";\nexport * from \"./webXRManagedOutputCanvas.js\";\nexport * from \"./webXRTypes.js\";\nexport * from \"./webXRSessionManager.js\";\nexport * from \"./webXRDefaultExperience.js\";\nexport * from \"./webXRFeaturesManager.js\";\nexport * from \"./features/index.js\";\nexport * from \"./motionController/index.js\";\nexport * from \"./native/index.js\";\n//# sourceMappingURL=index.js.map"],"names":["name","shader","this","r","i"],"sourceRoot":""}