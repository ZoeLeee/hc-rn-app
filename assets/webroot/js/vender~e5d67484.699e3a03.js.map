{"version":3,"file":"js/vender~e5d67484.699e3a03.js","mappings":"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","sources":["webpack:///../../../node_modules/@babylonjs/core/Misc/HighDynamicRange/cubemapToSphericalPolynomial.js","webpack:///../../../node_modules/@babylonjs/core/Misc/HighDynamicRange/hdr.js","webpack:///../../../node_modules/@babylonjs/core/Misc/HighDynamicRange/panoramaToCubemap.js","webpack:///../../../node_modules/@babylonjs/core/Misc/andOrNotEvaluator.js","webpack:///../../../node_modules/@babylonjs/core/Misc/arrayTools.js","webpack:///../../../node_modules/@babylonjs/core/Misc/assetsManager.js","webpack:///../../../node_modules/@babylonjs/core/Misc/basis.js","webpack:///../../../node_modules/@babylonjs/core/Misc/brdfTextureTools.js","webpack:///../../../node_modules/@babylonjs/core/Misc/codeStringParsingTools.js","webpack:///../../../node_modules/@babylonjs/core/Misc/copyTextureToTexture.js","webpack:///../../../node_modules/@babylonjs/core/Misc/copyTools.js","webpack:///../../../node_modules/@babylonjs/core/Misc/coroutine.js","webpack:///../../../node_modules/@babylonjs/core/Misc/dataReader.js","webpack:///../../../node_modules/@babylonjs/core/Misc/dds.js","webpack:///../../../node_modules/@babylonjs/core/Misc/decorators.js","webpack:///../../../node_modules/@babylonjs/core/Misc/deepCopier.js","webpack:///../../../node_modules/@babylonjs/core/Misc/deferred.js","webpack:///../../../node_modules/@babylonjs/core/Misc/depthReducer.js","webpack:///../../../node_modules/@babylonjs/core/Misc/devTools.js","webpack:///../../../node_modules/@babylonjs/core/Misc/domManagement.js","webpack:///../../../node_modules/@babylonjs/core/Misc/dumpTools.js","webpack:///../../../node_modules/@babylonjs/core/Misc/environmentTextureTools.js","webpack:///../../../node_modules/@babylonjs/core/Misc/error.js","webpack:///../../../node_modules/@babylonjs/core/Misc/fileTools.js","webpack:///../../../node_modules/@babylonjs/core/Misc/filesInput.js","webpack:///../../../node_modules/@babylonjs/core/Misc/filesInputStore.js","webpack:///../../../node_modules/@babylonjs/core/Misc/gradients.js","webpack:///../../../node_modules/@babylonjs/core/Misc/guid.js","webpack:///../../../node_modules/@babylonjs/core/Misc/observable.extensions.js","webpack:///../../../node_modules/@babylonjs/core/Misc/sceneOptimizer.js","webpack:///../../../node_modules/@babylonjs/core/Misc/sceneSerializer.js","webpack:///../../../node_modules/@babylonjs/core/Misc/videoRecorder.js","webpack:///../../../node_modules/@babylonjs/core/Misc/iInspectable.js","webpack:///../../../node_modules/@babylonjs/core/Misc/dataStorage.js","webpack:///../../../node_modules/@babylonjs/core/Misc/trajectoryClassifier.js","webpack:///../../../node_modules/@babylonjs/core/Misc/reflector.js","webpack:///../../../node_modules/@babylonjs/core/Misc/PerformanceViewer/dynamicFloat32Array.js","webpack:///../../../node_modules/@babylonjs/core/Misc/PerformanceViewer/performanceViewerCollector.js","webpack:///../../../node_modules/@babylonjs/core/Misc/PerformanceViewer/performanceViewerSceneExtension.js","webpack:///../../../node_modules/@babylonjs/core/Misc/observableCoroutine.js","webpack:///../../../node_modules/@babylonjs/core/Misc/instantiationTools.js","webpack:///../../../node_modules/@babylonjs/core/Misc/khronosTextureContainer.js","webpack:///../../../node_modules/@babylonjs/core/Misc/khronosTextureContainer2.js","webpack:///../../../node_modules/@babylonjs/core/Misc/logger.js","webpack:///../../../node_modules/@babylonjs/core/Misc/minMaxReducer.js","webpack:///../../../node_modules/@babylonjs/core/Misc/observable.js","webpack:///../../../node_modules/@babylonjs/core/Misc/perfCounter.js","webpack:///../../../node_modules/@babylonjs/core/Misc/performanceMonitor.js","webpack:///../../../node_modules/@babylonjs/core/Misc/pivotTools.js","webpack:///../../../node_modules/@babylonjs/core/Misc/precisionDate.js","webpack:///../../../node_modules/@babylonjs/core/Misc/retryStrategy.js","webpack:///../../../node_modules/@babylonjs/core/Misc/rgbdTextureTools.js","webpack:///../../../node_modules/@babylonjs/core/Misc/screenshotTools.js","webpack:///../../../node_modules/@babylonjs/core/Misc/smartArray.js","webpack:///../../../node_modules/@babylonjs/core/Misc/stringDictionary.js","webpack:///../../../node_modules/@babylonjs/core/Misc/stringTools.js","webpack:///../../../node_modules/@babylonjs/core/Misc/tags.js","webpack:///../../../node_modules/@babylonjs/core/Misc/textureTools.js","webpack:///../../../node_modules/@babylonjs/core/Misc/tga.js","webpack:///../../../node_modules/@babylonjs/core/Misc/timer.js","webpack:///../../../node_modules/@babylonjs/core/Misc/timingTools.js","webpack:///../../../node_modules/@babylonjs/core/Misc/tools.js","webpack:///../../../node_modules/@babylonjs/core/Misc/typeStore.js","webpack:///../../../node_modules/@babylonjs/core/Misc/uniqueIdGenerator.js","webpack:///../../../node_modules/@babylonjs/core/Misc/virtualJoystick.js","webpack:///../../../node_modules/@babylonjs/core/Misc/webRequest.js","webpack:///../../../node_modules/@babylonjs/core/Misc/workerPool.js","webpack:///../../../node_modules/@babylonjs/core/Morph/morphTarget.js","webpack:///../../../node_modules/@babylonjs/core/Morph/morphTargetManager.js","webpack:///../../../node_modules/@babylonjs/core/Offline/database.js"],"sourcesContent":["import { Vector3 } from \"../../Maths/math.vector.js\";\nimport { Scalar } from \"../../Maths/math.scalar.js\";\nimport { SphericalPolynomial, SphericalHarmonics } from \"../../Maths/sphericalPolynomial.js\";\n\nimport { ToLinearSpace } from \"../../Maths/math.constants.js\";\nimport { Color3 } from \"../../Maths/math.color.js\";\nclass FileFaceOrientation {\n    constructor(name, worldAxisForNormal, worldAxisForFileX, worldAxisForFileY) {\n        this.name = name;\n        this.worldAxisForNormal = worldAxisForNormal;\n        this.worldAxisForFileX = worldAxisForFileX;\n        this.worldAxisForFileY = worldAxisForFileY;\n    }\n}\n/**\n * Helper class dealing with the extraction of spherical polynomial dataArray\n * from a cube map.\n */\nexport class CubeMapToSphericalPolynomialTools {\n    /**\n     * Converts a texture to the according Spherical Polynomial data.\n     * This extracts the first 3 orders only as they are the only one used in the lighting.\n     *\n     * @param texture The texture to extract the information from.\n     * @returns The Spherical Polynomial data.\n     */\n    static ConvertCubeMapTextureToSphericalPolynomial(texture) {\n        var _a;\n        if (!texture.isCube) {\n            // Only supports cube Textures currently.\n            return null;\n        }\n        (_a = texture.getScene()) === null || _a === void 0 ? void 0 : _a.getEngine().flushFramebuffer();\n        const size = texture.getSize().width;\n        const rightPromise = texture.readPixels(0, undefined, undefined, false);\n        const leftPromise = texture.readPixels(1, undefined, undefined, false);\n        let upPromise;\n        let downPromise;\n        if (texture.isRenderTarget) {\n            upPromise = texture.readPixels(3, undefined, undefined, false);\n            downPromise = texture.readPixels(2, undefined, undefined, false);\n        }\n        else {\n            upPromise = texture.readPixels(2, undefined, undefined, false);\n            downPromise = texture.readPixels(3, undefined, undefined, false);\n        }\n        const frontPromise = texture.readPixels(4, undefined, undefined, false);\n        const backPromise = texture.readPixels(5, undefined, undefined, false);\n        const gammaSpace = texture.gammaSpace;\n        // Always read as RGBA.\n        const format = 5;\n        let type = 0;\n        if (texture.textureType == 1 || texture.textureType == 2) {\n            type = 1;\n        }\n        return new Promise((resolve) => {\n            Promise.all([leftPromise, rightPromise, upPromise, downPromise, frontPromise, backPromise]).then(([left, right, up, down, front, back]) => {\n                const cubeInfo = {\n                    size,\n                    right,\n                    left,\n                    up,\n                    down,\n                    front,\n                    back,\n                    format,\n                    type,\n                    gammaSpace,\n                };\n                resolve(this.ConvertCubeMapToSphericalPolynomial(cubeInfo));\n            });\n        });\n    }\n    /**\n     * Compute the area on the unit sphere of the rectangle defined by (x,y) and the origin\n     * See https://www.rorydriscoll.com/2012/01/15/cubemap-texel-solid-angle/\n     * @param x\n     * @param y\n     */\n    static _AreaElement(x, y) {\n        return Math.atan2(x * y, Math.sqrt(x * x + y * y + 1));\n    }\n    /**\n     * Converts a cubemap to the according Spherical Polynomial data.\n     * This extracts the first 3 orders only as they are the only one used in the lighting.\n     *\n     * @param cubeInfo The Cube map to extract the information from.\n     * @returns The Spherical Polynomial data.\n     */\n    static ConvertCubeMapToSphericalPolynomial(cubeInfo) {\n        const sphericalHarmonics = new SphericalHarmonics();\n        let totalSolidAngle = 0.0;\n        // The (u,v) range is [-1,+1], so the distance between each texel is 2/Size.\n        const du = 2.0 / cubeInfo.size;\n        const dv = du;\n        const halfTexel = 0.5 * du;\n        // The (u,v) of the first texel is half a texel from the corner (-1,-1).\n        const minUV = halfTexel - 1.0;\n        for (let faceIndex = 0; faceIndex < 6; faceIndex++) {\n            const fileFace = this._FileFaces[faceIndex];\n            const dataArray = cubeInfo[fileFace.name];\n            let v = minUV;\n            // TODO: we could perform the summation directly into a SphericalPolynomial (SP), which is more efficient than SphericalHarmonic (SH).\n            // This is possible because during the summation we do not need the SH-specific properties, e.g. orthogonality.\n            // Because SP is still linear, so summation is fine in that basis.\n            const stride = cubeInfo.format === 5 ? 4 : 3;\n            for (let y = 0; y < cubeInfo.size; y++) {\n                let u = minUV;\n                for (let x = 0; x < cubeInfo.size; x++) {\n                    // World direction (not normalised)\n                    const worldDirection = fileFace.worldAxisForFileX.scale(u).add(fileFace.worldAxisForFileY.scale(v)).add(fileFace.worldAxisForNormal);\n                    worldDirection.normalize();\n                    const deltaSolidAngle = this._AreaElement(u - halfTexel, v - halfTexel) -\n                        this._AreaElement(u - halfTexel, v + halfTexel) -\n                        this._AreaElement(u + halfTexel, v - halfTexel) +\n                        this._AreaElement(u + halfTexel, v + halfTexel);\n                    let r = dataArray[y * cubeInfo.size * stride + x * stride + 0];\n                    let g = dataArray[y * cubeInfo.size * stride + x * stride + 1];\n                    let b = dataArray[y * cubeInfo.size * stride + x * stride + 2];\n                    // Prevent NaN harmonics with extreme HDRI data.\n                    if (isNaN(r)) {\n                        r = 0;\n                    }\n                    if (isNaN(g)) {\n                        g = 0;\n                    }\n                    if (isNaN(b)) {\n                        b = 0;\n                    }\n                    // Handle Integer types.\n                    if (cubeInfo.type === 0) {\n                        r /= 255;\n                        g /= 255;\n                        b /= 255;\n                    }\n                    // Handle Gamma space textures.\n                    if (cubeInfo.gammaSpace) {\n                        r = Math.pow(Scalar.Clamp(r), ToLinearSpace);\n                        g = Math.pow(Scalar.Clamp(g), ToLinearSpace);\n                        b = Math.pow(Scalar.Clamp(b), ToLinearSpace);\n                    }\n                    // Prevent to explode in case of really high dynamic ranges.\n                    // sh 3 would not be enough to accurately represent it.\n                    const max = 4096;\n                    r = Scalar.Clamp(r, 0, max);\n                    g = Scalar.Clamp(g, 0, max);\n                    b = Scalar.Clamp(b, 0, max);\n                    const color = new Color3(r, g, b);\n                    sphericalHarmonics.addLight(worldDirection, color, deltaSolidAngle);\n                    totalSolidAngle += deltaSolidAngle;\n                    u += du;\n                }\n                v += dv;\n            }\n        }\n        // Solid angle for entire sphere is 4*pi\n        const sphereSolidAngle = 4.0 * Math.PI;\n        // Adjust the solid angle to allow for how many faces we processed.\n        const facesProcessed = 6.0;\n        const expectedSolidAngle = (sphereSolidAngle * facesProcessed) / 6.0;\n        // Adjust the harmonics so that the accumulated solid angle matches the expected solid angle.\n        // This is needed because the numerical integration over the cube uses a\n        // small angle approximation of solid angle for each texel (see deltaSolidAngle),\n        // and also to compensate for accumulative error due to float precision in the summation.\n        const correctionFactor = expectedSolidAngle / totalSolidAngle;\n        sphericalHarmonics.scaleInPlace(correctionFactor);\n        sphericalHarmonics.convertIncidentRadianceToIrradiance();\n        sphericalHarmonics.convertIrradianceToLambertianRadiance();\n        return SphericalPolynomial.FromHarmonics(sphericalHarmonics);\n    }\n}\nCubeMapToSphericalPolynomialTools._FileFaces = [\n    new FileFaceOrientation(\"right\", new Vector3(1, 0, 0), new Vector3(0, 0, -1), new Vector3(0, -1, 0)),\n    new FileFaceOrientation(\"left\", new Vector3(-1, 0, 0), new Vector3(0, 0, 1), new Vector3(0, -1, 0)),\n    new FileFaceOrientation(\"up\", new Vector3(0, 1, 0), new Vector3(1, 0, 0), new Vector3(0, 0, 1)),\n    new FileFaceOrientation(\"down\", new Vector3(0, -1, 0), new Vector3(1, 0, 0), new Vector3(0, 0, -1)),\n    new FileFaceOrientation(\"front\", new Vector3(0, 0, 1), new Vector3(1, 0, 0), new Vector3(0, -1, 0)),\n    new FileFaceOrientation(\"back\", new Vector3(0, 0, -1), new Vector3(-1, 0, 0), new Vector3(0, -1, 0)), // -Z bottom\n];\n//# sourceMappingURL=cubemapToSphericalPolynomial.js.map","import { PanoramaToCubeMapTools } from \"./panoramaToCubemap.js\";\n/**\n * This groups tools to convert HDR texture to native colors array.\n */\nexport class HDRTools {\n    static _Ldexp(mantissa, exponent) {\n        if (exponent > 1023) {\n            return mantissa * Math.pow(2, 1023) * Math.pow(2, exponent - 1023);\n        }\n        if (exponent < -1074) {\n            return mantissa * Math.pow(2, -1074) * Math.pow(2, exponent + 1074);\n        }\n        return mantissa * Math.pow(2, exponent);\n    }\n    static _Rgbe2float(float32array, red, green, blue, exponent, index) {\n        if (exponent > 0) {\n            /*nonzero pixel*/\n            exponent = this._Ldexp(1.0, exponent - (128 + 8));\n            float32array[index + 0] = red * exponent;\n            float32array[index + 1] = green * exponent;\n            float32array[index + 2] = blue * exponent;\n        }\n        else {\n            float32array[index + 0] = 0;\n            float32array[index + 1] = 0;\n            float32array[index + 2] = 0;\n        }\n    }\n    static _ReadStringLine(uint8array, startIndex) {\n        let line = \"\";\n        let character = \"\";\n        for (let i = startIndex; i < uint8array.length - startIndex; i++) {\n            character = String.fromCharCode(uint8array[i]);\n            if (character == \"\\n\") {\n                break;\n            }\n            line += character;\n        }\n        return line;\n    }\n    /**\n     * Reads header information from an RGBE texture stored in a native array.\n     * More information on this format are available here:\n     * https://en.wikipedia.org/wiki/RGBE_image_format\n     *\n     * @param uint8array The binary file stored in  native array.\n     * @returns The header information.\n     */\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    static RGBE_ReadHeader(uint8array) {\n        let height = 0;\n        let width = 0;\n        let line = this._ReadStringLine(uint8array, 0);\n        if (line[0] != \"#\" || line[1] != \"?\") {\n            throw \"Bad HDR Format.\";\n        }\n        let endOfHeader = false;\n        let findFormat = false;\n        let lineIndex = 0;\n        do {\n            lineIndex += line.length + 1;\n            line = this._ReadStringLine(uint8array, lineIndex);\n            if (line == \"FORMAT=32-bit_rle_rgbe\") {\n                findFormat = true;\n            }\n            else if (line.length == 0) {\n                endOfHeader = true;\n            }\n        } while (!endOfHeader);\n        if (!findFormat) {\n            throw \"HDR Bad header format, unsupported FORMAT\";\n        }\n        lineIndex += line.length + 1;\n        line = this._ReadStringLine(uint8array, lineIndex);\n        const sizeRegexp = /^-Y (.*) \\+X (.*)$/g;\n        const match = sizeRegexp.exec(line);\n        // TODO. Support +Y and -X if needed.\n        if (!match || match.length < 3) {\n            throw \"HDR Bad header format, no size\";\n        }\n        width = parseInt(match[2]);\n        height = parseInt(match[1]);\n        if (width < 8 || width > 0x7fff) {\n            throw \"HDR Bad header format, unsupported size\";\n        }\n        lineIndex += line.length + 1;\n        return {\n            height: height,\n            width: width,\n            dataPosition: lineIndex,\n        };\n    }\n    /**\n     * Returns the cubemap information (each faces texture data) extracted from an RGBE texture.\n     * This RGBE texture needs to store the information as a panorama.\n     *\n     * More information on this format are available here:\n     * https://en.wikipedia.org/wiki/RGBE_image_format\n     *\n     * @param buffer The binary file stored in an array buffer.\n     * @param size The expected size of the extracted cubemap.\n     * @returns The Cube Map information.\n     */\n    static GetCubeMapTextureData(buffer, size) {\n        const uint8array = new Uint8Array(buffer);\n        const hdrInfo = this.RGBE_ReadHeader(uint8array);\n        const data = this.RGBE_ReadPixels(uint8array, hdrInfo);\n        const cubeMapData = PanoramaToCubeMapTools.ConvertPanoramaToCubemap(data, hdrInfo.width, hdrInfo.height, size);\n        return cubeMapData;\n    }\n    /**\n     * Returns the pixels data extracted from an RGBE texture.\n     * This pixels will be stored left to right up to down in the R G B order in one array.\n     *\n     * More information on this format are available here:\n     * https://en.wikipedia.org/wiki/RGBE_image_format\n     *\n     * @param uint8array The binary file stored in an array buffer.\n     * @param hdrInfo The header information of the file.\n     * @returns The pixels data in RGB right to left up to down order.\n     */\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    static RGBE_ReadPixels(uint8array, hdrInfo) {\n        return this._RGBEReadPixelsRLE(uint8array, hdrInfo);\n    }\n    static _RGBEReadPixelsRLE(uint8array, hdrInfo) {\n        let num_scanlines = hdrInfo.height;\n        const scanline_width = hdrInfo.width;\n        let a, b, c, d, count;\n        let dataIndex = hdrInfo.dataPosition;\n        let index = 0, endIndex = 0, i = 0;\n        const scanLineArrayBuffer = new ArrayBuffer(scanline_width * 4); // four channel R G B E\n        const scanLineArray = new Uint8Array(scanLineArrayBuffer);\n        // 3 channels of 4 bytes per pixel in float.\n        const resultBuffer = new ArrayBuffer(hdrInfo.width * hdrInfo.height * 4 * 3);\n        const resultArray = new Float32Array(resultBuffer);\n        // read in each successive scanline\n        while (num_scanlines > 0) {\n            a = uint8array[dataIndex++];\n            b = uint8array[dataIndex++];\n            c = uint8array[dataIndex++];\n            d = uint8array[dataIndex++];\n            if (a != 2 || b != 2 || c & 0x80 || hdrInfo.width < 8 || hdrInfo.width > 32767) {\n                return this._RGBEReadPixelsNOTRLE(uint8array, hdrInfo);\n            }\n            if (((c << 8) | d) != scanline_width) {\n                throw \"HDR Bad header format, wrong scan line width\";\n            }\n            index = 0;\n            // read each of the four channels for the scanline into the buffer\n            for (i = 0; i < 4; i++) {\n                endIndex = (i + 1) * scanline_width;\n                while (index < endIndex) {\n                    a = uint8array[dataIndex++];\n                    b = uint8array[dataIndex++];\n                    if (a > 128) {\n                        // a run of the same value\n                        count = a - 128;\n                        if (count == 0 || count > endIndex - index) {\n                            throw \"HDR Bad Format, bad scanline data (run)\";\n                        }\n                        while (count-- > 0) {\n                            scanLineArray[index++] = b;\n                        }\n                    }\n                    else {\n                        // a non-run\n                        count = a;\n                        if (count == 0 || count > endIndex - index) {\n                            throw \"HDR Bad Format, bad scanline data (non-run)\";\n                        }\n                        scanLineArray[index++] = b;\n                        if (--count > 0) {\n                            for (let j = 0; j < count; j++) {\n                                scanLineArray[index++] = uint8array[dataIndex++];\n                            }\n                        }\n                    }\n                }\n            }\n            // now convert data from buffer into floats\n            for (i = 0; i < scanline_width; i++) {\n                a = scanLineArray[i];\n                b = scanLineArray[i + scanline_width];\n                c = scanLineArray[i + 2 * scanline_width];\n                d = scanLineArray[i + 3 * scanline_width];\n                this._Rgbe2float(resultArray, a, b, c, d, (hdrInfo.height - num_scanlines) * scanline_width * 3 + i * 3);\n            }\n            num_scanlines--;\n        }\n        return resultArray;\n    }\n    static _RGBEReadPixelsNOTRLE(uint8array, hdrInfo) {\n        // this file is not run length encoded\n        // read values sequentially\n        let num_scanlines = hdrInfo.height;\n        const scanline_width = hdrInfo.width;\n        let a, b, c, d, i;\n        let dataIndex = hdrInfo.dataPosition;\n        // 3 channels of 4 bytes per pixel in float.\n        const resultBuffer = new ArrayBuffer(hdrInfo.width * hdrInfo.height * 4 * 3);\n        const resultArray = new Float32Array(resultBuffer);\n        // read in each successive scanline\n        while (num_scanlines > 0) {\n            for (i = 0; i < hdrInfo.width; i++) {\n                a = uint8array[dataIndex++];\n                b = uint8array[dataIndex++];\n                c = uint8array[dataIndex++];\n                d = uint8array[dataIndex++];\n                this._Rgbe2float(resultArray, a, b, c, d, (hdrInfo.height - num_scanlines) * scanline_width * 3 + i * 3);\n            }\n            num_scanlines--;\n        }\n        return resultArray;\n    }\n}\n//# sourceMappingURL=hdr.js.map","import { Vector3 } from \"../../Maths/math.vector.js\";\n\n/**\n * Helper class useful to convert panorama picture to their cubemap representation in 6 faces.\n */\nexport class PanoramaToCubeMapTools {\n    /**\n     * Converts a panorama stored in RGB right to left up to down format into a cubemap (6 faces).\n     *\n     * @param float32Array The source data.\n     * @param inputWidth The width of the input panorama.\n     * @param inputHeight The height of the input panorama.\n     * @param size The willing size of the generated cubemap (each faces will be size * size pixels)\n     * @returns The cubemap data\n     */\n    static ConvertPanoramaToCubemap(float32Array, inputWidth, inputHeight, size) {\n        if (!float32Array) {\n            throw \"ConvertPanoramaToCubemap: input cannot be null\";\n        }\n        if (float32Array.length != inputWidth * inputHeight * 3) {\n            throw \"ConvertPanoramaToCubemap: input size is wrong\";\n        }\n        const textureFront = this.CreateCubemapTexture(size, this.FACE_FRONT, float32Array, inputWidth, inputHeight);\n        const textureBack = this.CreateCubemapTexture(size, this.FACE_BACK, float32Array, inputWidth, inputHeight);\n        const textureLeft = this.CreateCubemapTexture(size, this.FACE_LEFT, float32Array, inputWidth, inputHeight);\n        const textureRight = this.CreateCubemapTexture(size, this.FACE_RIGHT, float32Array, inputWidth, inputHeight);\n        const textureUp = this.CreateCubemapTexture(size, this.FACE_UP, float32Array, inputWidth, inputHeight);\n        const textureDown = this.CreateCubemapTexture(size, this.FACE_DOWN, float32Array, inputWidth, inputHeight);\n        return {\n            front: textureFront,\n            back: textureBack,\n            left: textureLeft,\n            right: textureRight,\n            up: textureUp,\n            down: textureDown,\n            size: size,\n            type: 1,\n            format: 4,\n            gammaSpace: false,\n        };\n    }\n    static CreateCubemapTexture(texSize, faceData, float32Array, inputWidth, inputHeight) {\n        const buffer = new ArrayBuffer(texSize * texSize * 4 * 3);\n        const textureArray = new Float32Array(buffer);\n        const rotDX1 = faceData[1].subtract(faceData[0]).scale(1 / texSize);\n        const rotDX2 = faceData[3].subtract(faceData[2]).scale(1 / texSize);\n        const dy = 1 / texSize;\n        let fy = 0;\n        for (let y = 0; y < texSize; y++) {\n            let xv1 = faceData[0];\n            let xv2 = faceData[2];\n            for (let x = 0; x < texSize; x++) {\n                const v = xv2.subtract(xv1).scale(fy).add(xv1);\n                v.normalize();\n                const color = this.CalcProjectionSpherical(v, float32Array, inputWidth, inputHeight);\n                // 3 channels per pixels\n                textureArray[y * texSize * 3 + x * 3 + 0] = color.r;\n                textureArray[y * texSize * 3 + x * 3 + 1] = color.g;\n                textureArray[y * texSize * 3 + x * 3 + 2] = color.b;\n                xv1 = xv1.add(rotDX1);\n                xv2 = xv2.add(rotDX2);\n            }\n            fy += dy;\n        }\n        return textureArray;\n    }\n    static CalcProjectionSpherical(vDir, float32Array, inputWidth, inputHeight) {\n        let theta = Math.atan2(vDir.z, vDir.x);\n        const phi = Math.acos(vDir.y);\n        while (theta < -Math.PI) {\n            theta += 2 * Math.PI;\n        }\n        while (theta > Math.PI) {\n            theta -= 2 * Math.PI;\n        }\n        let dx = theta / Math.PI;\n        const dy = phi / Math.PI;\n        // recenter.\n        dx = dx * 0.5 + 0.5;\n        let px = Math.round(dx * inputWidth);\n        if (px < 0) {\n            px = 0;\n        }\n        else if (px >= inputWidth) {\n            px = inputWidth - 1;\n        }\n        let py = Math.round(dy * inputHeight);\n        if (py < 0) {\n            py = 0;\n        }\n        else if (py >= inputHeight) {\n            py = inputHeight - 1;\n        }\n        const inputY = inputHeight - py - 1;\n        const r = float32Array[inputY * inputWidth * 3 + px * 3 + 0];\n        const g = float32Array[inputY * inputWidth * 3 + px * 3 + 1];\n        const b = float32Array[inputY * inputWidth * 3 + px * 3 + 2];\n        return {\n            r: r,\n            g: g,\n            b: b,\n        };\n    }\n}\nPanoramaToCubeMapTools.FACE_LEFT = [new Vector3(-1.0, -1.0, -1.0), new Vector3(1.0, -1.0, -1.0), new Vector3(-1.0, 1.0, -1.0), new Vector3(1.0, 1.0, -1.0)];\nPanoramaToCubeMapTools.FACE_RIGHT = [new Vector3(1.0, -1.0, 1.0), new Vector3(-1.0, -1.0, 1.0), new Vector3(1.0, 1.0, 1.0), new Vector3(-1.0, 1.0, 1.0)];\nPanoramaToCubeMapTools.FACE_FRONT = [new Vector3(1.0, -1.0, -1.0), new Vector3(1.0, -1.0, 1.0), new Vector3(1.0, 1.0, -1.0), new Vector3(1.0, 1.0, 1.0)];\nPanoramaToCubeMapTools.FACE_BACK = [new Vector3(-1.0, -1.0, 1.0), new Vector3(-1.0, -1.0, -1.0), new Vector3(-1.0, 1.0, 1.0), new Vector3(-1.0, 1.0, -1.0)];\nPanoramaToCubeMapTools.FACE_DOWN = [new Vector3(1.0, 1.0, -1.0), new Vector3(1.0, 1.0, 1.0), new Vector3(-1.0, 1.0, -1.0), new Vector3(-1.0, 1.0, 1.0)];\nPanoramaToCubeMapTools.FACE_UP = [new Vector3(-1.0, -1.0, -1.0), new Vector3(-1.0, -1.0, 1.0), new Vector3(1.0, -1.0, -1.0), new Vector3(1.0, -1.0, 1.0)];\n//# sourceMappingURL=panoramaToCubemap.js.map","/**\n * Class used to evaluate queries containing `and` and `or` operators\n */\nexport class AndOrNotEvaluator {\n    /**\n     * Evaluate a query\n     * @param query defines the query to evaluate\n     * @param evaluateCallback defines the callback used to filter result\n     * @returns true if the query matches\n     */\n    static Eval(query, evaluateCallback) {\n        if (!query.match(/\\([^()]*\\)/g)) {\n            query = AndOrNotEvaluator._HandleParenthesisContent(query, evaluateCallback);\n        }\n        else {\n            query = query.replace(/\\([^()]*\\)/g, (r) => {\n                // remove parenthesis\n                r = r.slice(1, r.length - 1);\n                return AndOrNotEvaluator._HandleParenthesisContent(r, evaluateCallback);\n            });\n        }\n        if (query === \"true\") {\n            return true;\n        }\n        if (query === \"false\") {\n            return false;\n        }\n        return AndOrNotEvaluator.Eval(query, evaluateCallback);\n    }\n    static _HandleParenthesisContent(parenthesisContent, evaluateCallback) {\n        evaluateCallback =\n            evaluateCallback ||\n                ((r) => {\n                    return r === \"true\" ? true : false;\n                });\n        let result;\n        const or = parenthesisContent.split(\"||\");\n        for (const i in or) {\n            if (Object.prototype.hasOwnProperty.call(or, i)) {\n                let ori = AndOrNotEvaluator._SimplifyNegation(or[i].trim());\n                const and = ori.split(\"&&\");\n                if (and.length > 1) {\n                    for (let j = 0; j < and.length; ++j) {\n                        const andj = AndOrNotEvaluator._SimplifyNegation(and[j].trim());\n                        if (andj !== \"true\" && andj !== \"false\") {\n                            if (andj[0] === \"!\") {\n                                result = !evaluateCallback(andj.substring(1));\n                            }\n                            else {\n                                result = evaluateCallback(andj);\n                            }\n                        }\n                        else {\n                            result = andj === \"true\" ? true : false;\n                        }\n                        if (!result) {\n                            // no need to continue since 'false && ... && ...' will always return false\n                            ori = \"false\";\n                            break;\n                        }\n                    }\n                }\n                if (result || ori === \"true\") {\n                    // no need to continue since 'true || ... || ...' will always return true\n                    result = true;\n                    break;\n                }\n                // result equals false (or undefined)\n                if (ori !== \"true\" && ori !== \"false\") {\n                    if (ori[0] === \"!\") {\n                        result = !evaluateCallback(ori.substring(1));\n                    }\n                    else {\n                        result = evaluateCallback(ori);\n                    }\n                }\n                else {\n                    result = ori === \"true\" ? true : false;\n                }\n            }\n        }\n        // the whole parenthesis scope is replaced by 'true' or 'false'\n        return result ? \"true\" : \"false\";\n    }\n    static _SimplifyNegation(booleanString) {\n        booleanString = booleanString.replace(/^[\\s!]+/, (r) => {\n            // remove whitespaces\n            r = r.replace(/[\\s]/g, () => \"\");\n            return r.length % 2 ? \"!\" : \"\";\n        });\n        booleanString = booleanString.trim();\n        if (booleanString === \"!true\") {\n            booleanString = \"false\";\n        }\n        else if (booleanString === \"!false\") {\n            booleanString = \"true\";\n        }\n        return booleanString;\n    }\n}\n//# sourceMappingURL=andOrNotEvaluator.js.map","/* eslint-disable @typescript-eslint/naming-convention */\n/**\n * Class containing a set of static utilities functions for arrays.\n */\nexport class ArrayTools {\n    /**\n     * Returns an array of the given size filled with elements built from the given constructor and the parameters.\n     * @param size the number of element to construct and put in the array.\n     * @param itemBuilder a callback responsible for creating new instance of item. Called once per array entry.\n     * @returns a new array filled with new objects.\n     */\n    static BuildArray(size, itemBuilder) {\n        const a = [];\n        for (let i = 0; i < size; ++i) {\n            a.push(itemBuilder());\n        }\n        return a;\n    }\n    /**\n     * Returns a tuple of the given size filled with elements built from the given constructor and the parameters.\n     * @param size he number of element to construct and put in the tuple.\n     * @param itemBuilder a callback responsible for creating new instance of item. Called once per tuple entry.\n     * @returns a new tuple filled with new objects.\n     */\n    static BuildTuple(size, itemBuilder) {\n        return ArrayTools.BuildArray(size, itemBuilder);\n    }\n}\n/**\n * Observes a function and calls the given callback when it is called.\n * @param object Defines the object the function to observe belongs to.\n * @param functionName Defines the name of the function to observe.\n * @param callback Defines the callback to call when the function is called.\n * @returns A function to call to stop observing\n */\nfunction _observeArrayfunction(object, functionName, callback) {\n    // Finds the function to observe\n    const oldFunction = object[functionName];\n    if (typeof oldFunction !== \"function\") {\n        return null;\n    }\n    // Creates a new function that calls the callback and the old function\n    const newFunction = function () {\n        const previousLength = object.length;\n        const returnValue = newFunction.previous.apply(object, arguments);\n        callback(functionName, previousLength);\n        return returnValue;\n    };\n    // Doublishly links the new function and the old function\n    oldFunction.next = newFunction;\n    newFunction.previous = oldFunction;\n    // Replaces the old function with the new function\n    object[functionName] = newFunction;\n    // Returns a function to disable the hook\n    return () => {\n        // Only unhook if the function is still hooked\n        const previous = newFunction.previous;\n        if (!previous) {\n            return;\n        }\n        // Finds the ref to the next function in the chain\n        const next = newFunction.next;\n        // If in the middle of the chain, link the previous and next functions\n        if (next) {\n            previous.next = next;\n            next.previous = previous;\n        }\n        // If at the end of the chain, remove the reference to the previous function\n        // and restore the previous function\n        else {\n            previous.next = undefined;\n            object[functionName] = previous;\n        }\n        // Lose reference to the previous and next functions\n        newFunction.next = undefined;\n        newFunction.previous = undefined;\n    };\n}\n/**\n * Defines the list of functions to proxy when observing an array.\n * The scope is currently reduced to the common functions used in the render target render list and the scene cameras.\n */\nconst observedArrayFunctions = [\"push\", \"splice\", \"pop\", \"shift\", \"unshift\"];\n/**\n * Observes an array and notifies the given observer when the array is modified.\n * @param array Defines the array to observe\n * @param callback Defines the function to call when the array is modified (in the limit of the observed array functions)\n * @returns A function to call to stop observing the array\n * @internal\n */\nexport function _ObserveArray(array, callback) {\n    // Observes all the required array functions and stores the unhook functions\n    const unObserveFunctions = observedArrayFunctions.map((name) => {\n        return _observeArrayfunction(array, name, callback);\n    });\n    // Returns a function that unhook all the observed functions\n    return () => {\n        unObserveFunctions.forEach((unObserveFunction) => {\n            unObserveFunction === null || unObserveFunction === void 0 ? void 0 : unObserveFunction();\n        });\n    };\n}\n//# sourceMappingURL=arrayTools.js.map","import { SceneLoader } from \"../Loading/sceneLoader.js\";\nimport { Tools } from \"./tools.js\";\nimport { Observable } from \"./observable.js\";\nimport { Texture } from \"../Materials/Textures/texture.js\";\nimport { CubeTexture } from \"../Materials/Textures/cubeTexture.js\";\nimport { HDRCubeTexture } from \"../Materials/Textures/hdrCubeTexture.js\";\nimport { EquiRectangularCubeTexture } from \"../Materials/Textures/equiRectangularCubeTexture.js\";\nimport { Logger } from \"../Misc/logger.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\n/**\n * Defines the list of states available for a task inside a AssetsManager\n */\nexport var AssetTaskState;\n(function (AssetTaskState) {\n    /**\n     * Initialization\n     */\n    AssetTaskState[AssetTaskState[\"INIT\"] = 0] = \"INIT\";\n    /**\n     * Running\n     */\n    AssetTaskState[AssetTaskState[\"RUNNING\"] = 1] = \"RUNNING\";\n    /**\n     * Done\n     */\n    AssetTaskState[AssetTaskState[\"DONE\"] = 2] = \"DONE\";\n    /**\n     * Error\n     */\n    AssetTaskState[AssetTaskState[\"ERROR\"] = 3] = \"ERROR\";\n})(AssetTaskState || (AssetTaskState = {}));\n/**\n * Define an abstract asset task used with a AssetsManager class to load assets into a scene\n */\nexport class AbstractAssetTask {\n    /**\n     * Creates a new AssetsManager\n     * @param name defines the name of the task\n     */\n    constructor(\n    /**\n     * Task name\n     */ name) {\n        this.name = name;\n        this._isCompleted = false;\n        this._taskState = AssetTaskState.INIT;\n    }\n    /**\n     * Get if the task is completed\n     */\n    get isCompleted() {\n        return this._isCompleted;\n    }\n    /**\n     * Gets the current state of the task\n     */\n    get taskState() {\n        return this._taskState;\n    }\n    /**\n     * Gets the current error object (if task is in error)\n     */\n    get errorObject() {\n        return this._errorObject;\n    }\n    /**\n     * Internal only\n     * @internal\n     */\n    _setErrorObject(message, exception) {\n        if (this._errorObject) {\n            return;\n        }\n        this._errorObject = {\n            message: message,\n            exception: exception,\n        };\n    }\n    /**\n     * Execute the current task\n     * @param scene defines the scene where you want your assets to be loaded\n     * @param onSuccess is a callback called when the task is successfully executed\n     * @param onError is a callback called if an error occurs\n     */\n    run(scene, onSuccess, onError) {\n        this._taskState = AssetTaskState.RUNNING;\n        this.runTask(scene, () => {\n            this._onDoneCallback(onSuccess, onError);\n        }, (msg, exception) => {\n            this._onErrorCallback(onError, msg, exception);\n        });\n    }\n    /**\n     * Execute the current task\n     * @param scene defines the scene where you want your assets to be loaded\n     * @param onSuccess is a callback called when the task is successfully executed\n     * @param onError is a callback called if an error occurs\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    runTask(scene, onSuccess, onError) {\n        throw new Error(\"runTask is not implemented\");\n    }\n    /**\n     * Reset will set the task state back to INIT, so the next load call of the assets manager will execute this task again.\n     * This can be used with failed tasks that have the reason for failure fixed.\n     */\n    reset() {\n        this._taskState = AssetTaskState.INIT;\n    }\n    _onErrorCallback(onError, message, exception) {\n        this._taskState = AssetTaskState.ERROR;\n        this._errorObject = {\n            message: message,\n            exception: exception,\n        };\n        if (this.onError) {\n            this.onError(this, message, exception);\n        }\n        onError();\n    }\n    _onDoneCallback(onSuccess, onError) {\n        try {\n            this._taskState = AssetTaskState.DONE;\n            this._isCompleted = true;\n            if (this.onSuccess) {\n                this.onSuccess(this);\n            }\n            onSuccess();\n        }\n        catch (e) {\n            this._onErrorCallback(onError, \"Task is done, error executing success callback(s)\", e);\n        }\n    }\n}\n/**\n * Class used to share progress information about assets loading\n */\nexport class AssetsProgressEvent {\n    /**\n     * Creates a AssetsProgressEvent\n     * @param remainingCount defines the number of remaining tasks to process\n     * @param totalCount defines the total number of tasks\n     * @param task defines the task that was just processed\n     */\n    constructor(remainingCount, totalCount, task) {\n        this.remainingCount = remainingCount;\n        this.totalCount = totalCount;\n        this.task = task;\n    }\n}\n/**\n * Define a task used by AssetsManager to load assets into a container\n */\nexport class ContainerAssetTask extends AbstractAssetTask {\n    /**\n     * Creates a new ContainerAssetTask\n     * @param name defines the name of the task\n     * @param meshesNames defines the list of mesh's names you want to load\n     * @param rootUrl defines the root url to use as a base to load your meshes and associated resources\n     * @param sceneFilename defines the filename or File of the scene to load from\n     */\n    constructor(\n    /**\n     * Defines the name of the task\n     */\n    name, \n    /**\n     * Defines the list of mesh's names you want to load\n     */\n    meshesNames, \n    /**\n     * Defines the root url to use as a base to load your meshes and associated resources\n     */\n    rootUrl, \n    /**\n     * Defines the filename or File of the scene to load from\n     */\n    sceneFilename, \n    /**\n     * Defines the extension to use to load the scene (if not defined, \".babylon\" will be used)\n     */\n    extension) {\n        super(name);\n        this.name = name;\n        this.meshesNames = meshesNames;\n        this.rootUrl = rootUrl;\n        this.sceneFilename = sceneFilename;\n        this.extension = extension;\n    }\n    /**\n     * Execute the current task\n     * @param scene defines the scene where you want your assets to be loaded\n     * @param onSuccess is a callback called when the task is successfully executed\n     * @param onError is a callback called if an error occurs\n     */\n    runTask(scene, onSuccess, onError) {\n        SceneLoader.LoadAssetContainer(this.rootUrl, this.sceneFilename, scene, (container) => {\n            this.loadedContainer = container;\n            this.loadedMeshes = container.meshes;\n            this.loadedTransformNodes = container.transformNodes;\n            this.loadedParticleSystems = container.particleSystems;\n            this.loadedSkeletons = container.skeletons;\n            this.loadedAnimationGroups = container.animationGroups;\n            onSuccess();\n        }, null, (scene, message, exception) => {\n            onError(message, exception);\n        }, this.extension);\n    }\n}\n/**\n * Define a task used by AssetsManager to load meshes\n */\nexport class MeshAssetTask extends AbstractAssetTask {\n    /**\n     * Creates a new MeshAssetTask\n     * @param name defines the name of the task\n     * @param meshesNames defines the list of mesh's names you want to load\n     * @param rootUrl defines the root url to use as a base to load your meshes and associated resources\n     * @param sceneFilename defines the filename or File of the scene to load from\n     */\n    constructor(\n    /**\n     * Defines the name of the task\n     */\n    name, \n    /**\n     * Defines the list of mesh's names you want to load\n     */\n    meshesNames, \n    /**\n     * Defines the root url to use as a base to load your meshes and associated resources\n     */\n    rootUrl, \n    /**\n     * Defines the filename or File of the scene to load from\n     */\n    sceneFilename, \n    /**\n     * Defines the extension to use to load the scene (if not defined, \".babylon\" will be used)\n     */\n    extension) {\n        super(name);\n        this.name = name;\n        this.meshesNames = meshesNames;\n        this.rootUrl = rootUrl;\n        this.sceneFilename = sceneFilename;\n        this.extension = extension;\n    }\n    /**\n     * Execute the current task\n     * @param scene defines the scene where you want your assets to be loaded\n     * @param onSuccess is a callback called when the task is successfully executed\n     * @param onError is a callback called if an error occurs\n     */\n    runTask(scene, onSuccess, onError) {\n        SceneLoader.ImportMesh(this.meshesNames, this.rootUrl, this.sceneFilename, scene, (meshes, particleSystems, skeletons, animationGroups, transformNodes) => {\n            this.loadedMeshes = meshes;\n            this.loadedTransformNodes = transformNodes;\n            this.loadedParticleSystems = particleSystems;\n            this.loadedSkeletons = skeletons;\n            this.loadedAnimationGroups = animationGroups;\n            onSuccess();\n        }, null, (scene, message, exception) => {\n            onError(message, exception);\n        }, this.extension);\n    }\n}\n/**\n * Define a task used by AssetsManager to load text content\n */\nexport class TextFileAssetTask extends AbstractAssetTask {\n    /**\n     * Creates a new TextFileAssetTask object\n     * @param name defines the name of the task\n     * @param url defines the location of the file to load\n     */\n    constructor(\n    /**\n     * Defines the name of the task\n     */\n    name, \n    /**\n     * Defines the location of the file to load\n     */\n    url) {\n        super(name);\n        this.name = name;\n        this.url = url;\n    }\n    /**\n     * Execute the current task\n     * @param scene defines the scene where you want your assets to be loaded\n     * @param onSuccess is a callback called when the task is successfully executed\n     * @param onError is a callback called if an error occurs\n     */\n    runTask(scene, onSuccess, onError) {\n        scene._loadFile(this.url, (data) => {\n            this.text = data;\n            onSuccess();\n        }, undefined, false, false, (request, exception) => {\n            if (request) {\n                onError(request.status + \" \" + request.statusText, exception);\n            }\n        });\n    }\n}\n/**\n * Define a task used by AssetsManager to load binary data\n */\nexport class BinaryFileAssetTask extends AbstractAssetTask {\n    /**\n     * Creates a new BinaryFileAssetTask object\n     * @param name defines the name of the new task\n     * @param url defines the location of the file to load\n     */\n    constructor(\n    /**\n     * Defines the name of the task\n     */\n    name, \n    /**\n     * Defines the location of the file to load\n     */\n    url) {\n        super(name);\n        this.name = name;\n        this.url = url;\n    }\n    /**\n     * Execute the current task\n     * @param scene defines the scene where you want your assets to be loaded\n     * @param onSuccess is a callback called when the task is successfully executed\n     * @param onError is a callback called if an error occurs\n     */\n    runTask(scene, onSuccess, onError) {\n        scene._loadFile(this.url, (data) => {\n            this.data = data;\n            onSuccess();\n        }, undefined, true, true, (request, exception) => {\n            if (request) {\n                onError(request.status + \" \" + request.statusText, exception);\n            }\n        });\n    }\n}\n/**\n * Define a task used by AssetsManager to load images\n */\nexport class ImageAssetTask extends AbstractAssetTask {\n    /**\n     * Creates a new ImageAssetTask\n     * @param name defines the name of the task\n     * @param url defines the location of the image to load\n     */\n    constructor(\n    /**\n     * Defines the name of the task\n     */\n    name, \n    /**\n     * Defines the location of the image to load\n     */\n    url) {\n        super(name);\n        this.name = name;\n        this.url = url;\n    }\n    /**\n     * Execute the current task\n     * @param scene defines the scene where you want your assets to be loaded\n     * @param onSuccess is a callback called when the task is successfully executed\n     * @param onError is a callback called if an error occurs\n     */\n    runTask(scene, onSuccess, onError) {\n        const img = new Image();\n        Tools.SetCorsBehavior(this.url, img);\n        img.onload = () => {\n            this.image = img;\n            onSuccess();\n        };\n        img.onerror = (err) => {\n            onError(\"Error loading image\", err);\n        };\n        img.src = this.url;\n    }\n}\n/**\n * Define a task used by AssetsManager to load 2D textures\n */\nexport class TextureAssetTask extends AbstractAssetTask {\n    /**\n     * Creates a new TextureAssetTask object\n     * @param name defines the name of the task\n     * @param url defines the location of the file to load\n     * @param noMipmap defines if mipmap should not be generated (default is false)\n     * @param invertY defines if texture must be inverted on Y axis (default is true)\n     * @param samplingMode defines the sampling mode to use (default is Texture.TRILINEAR_SAMPLINGMODE)\n     */\n    constructor(\n    /**\n     * Defines the name of the task\n     */\n    name, \n    /**\n     * Defines the location of the file to load\n     */\n    url, \n    /**\n     * Defines if mipmap should not be generated (default is false)\n     */\n    noMipmap, \n    /**\n     * Defines if texture must be inverted on Y axis (default is true)\n     */\n    invertY = true, \n    /**\n     * Defines the sampling mode to use (default is Texture.TRILINEAR_SAMPLINGMODE)\n     */\n    samplingMode = Texture.TRILINEAR_SAMPLINGMODE) {\n        super(name);\n        this.name = name;\n        this.url = url;\n        this.noMipmap = noMipmap;\n        this.invertY = invertY;\n        this.samplingMode = samplingMode;\n    }\n    /**\n     * Execute the current task\n     * @param scene defines the scene where you want your assets to be loaded\n     * @param onSuccess is a callback called when the task is successfully executed\n     * @param onError is a callback called if an error occurs\n     */\n    runTask(scene, onSuccess, onError) {\n        const onload = () => {\n            onSuccess();\n        };\n        const onerror = (message, exception) => {\n            onError(message, exception);\n        };\n        this.texture = new Texture(this.url, scene, this.noMipmap, this.invertY, this.samplingMode, onload, onerror);\n    }\n}\n/**\n * Define a task used by AssetsManager to load cube textures\n */\nexport class CubeTextureAssetTask extends AbstractAssetTask {\n    /**\n     * Creates a new CubeTextureAssetTask\n     * @param name defines the name of the task\n     * @param url defines the location of the files to load (You have to specify the folder where the files are + filename with no extension)\n     * @param extensions defines the extensions to use to load files ([\"_px\", \"_py\", \"_pz\", \"_nx\", \"_ny\", \"_nz\"] by default)\n     * @param noMipmap defines if mipmaps should not be generated (default is false)\n     * @param files defines the explicit list of files (undefined by default)\n     * @param prefiltered\n     */\n    constructor(\n    /**\n     * Defines the name of the task\n     */\n    name, \n    /**\n     * Defines the location of the files to load (You have to specify the folder where the files are + filename with no extension)\n     */\n    url, \n    /**\n     * Defines the extensions to use to load files ([\"_px\", \"_py\", \"_pz\", \"_nx\", \"_ny\", \"_nz\"] by default)\n     */\n    extensions, \n    /**\n     * Defines if mipmaps should not be generated (default is false)\n     */\n    noMipmap, \n    /**\n     * Defines the explicit list of files (undefined by default)\n     */\n    files, \n    /**\n     * Defines the prefiltered texture option (default is false)\n     */\n    prefiltered) {\n        super(name);\n        this.name = name;\n        this.url = url;\n        this.extensions = extensions;\n        this.noMipmap = noMipmap;\n        this.files = files;\n        this.prefiltered = prefiltered;\n    }\n    /**\n     * Execute the current task\n     * @param scene defines the scene where you want your assets to be loaded\n     * @param onSuccess is a callback called when the task is successfully executed\n     * @param onError is a callback called if an error occurs\n     */\n    runTask(scene, onSuccess, onError) {\n        const onload = () => {\n            onSuccess();\n        };\n        const onerror = (message, exception) => {\n            onError(message, exception);\n        };\n        this.texture = new CubeTexture(this.url, scene, this.extensions, this.noMipmap, this.files, onload, onerror, undefined, this.prefiltered);\n    }\n}\n/**\n * Define a task used by AssetsManager to load HDR cube textures\n */\nexport class HDRCubeTextureAssetTask extends AbstractAssetTask {\n    /**\n     * Creates a new HDRCubeTextureAssetTask object\n     * @param name defines the name of the task\n     * @param url defines the location of the file to load\n     * @param size defines the desired size (the more it increases the longer the generation will be) If the size is omitted this implies you are using a preprocessed cubemap.\n     * @param noMipmap defines if mipmaps should not be generated (default is false)\n     * @param generateHarmonics specifies whether you want to extract the polynomial harmonics during the generation process (default is true)\n     * @param gammaSpace specifies if the texture will be use in gamma or linear space (the PBR material requires those texture in linear space, but the standard material would require them in Gamma space) (default is false)\n     * @param reserved Internal use only\n     */\n    constructor(\n    /**\n     * Defines the name of the task\n     */\n    name, \n    /**\n     * Defines the location of the file to load\n     */\n    url, \n    /**\n     * Defines the desired size (the more it increases the longer the generation will be)\n     */\n    size, \n    /**\n     * Defines if mipmaps should not be generated (default is false)\n     */\n    noMipmap = false, \n    /**\n     * Specifies whether you want to extract the polynomial harmonics during the generation process (default is true)\n     */\n    generateHarmonics = true, \n    /**\n     * Specifies if the texture will be use in gamma or linear space (the PBR material requires those texture in linear space, but the standard material would require them in Gamma space) (default is false)\n     */\n    gammaSpace = false, \n    /**\n     * Internal Use Only\n     */\n    reserved = false) {\n        super(name);\n        this.name = name;\n        this.url = url;\n        this.size = size;\n        this.noMipmap = noMipmap;\n        this.generateHarmonics = generateHarmonics;\n        this.gammaSpace = gammaSpace;\n        this.reserved = reserved;\n    }\n    /**\n     * Execute the current task\n     * @param scene defines the scene where you want your assets to be loaded\n     * @param onSuccess is a callback called when the task is successfully executed\n     * @param onError is a callback called if an error occurs\n     */\n    runTask(scene, onSuccess, onError) {\n        const onload = () => {\n            onSuccess();\n        };\n        const onerror = (message, exception) => {\n            onError(message, exception);\n        };\n        this.texture = new HDRCubeTexture(this.url, scene, this.size, this.noMipmap, this.generateHarmonics, this.gammaSpace, this.reserved, onload, onerror);\n    }\n}\n/**\n * Define a task used by AssetsManager to load Equirectangular cube textures\n */\nexport class EquiRectangularCubeTextureAssetTask extends AbstractAssetTask {\n    /**\n     * Creates a new EquiRectangularCubeTextureAssetTask object\n     * @param name defines the name of the task\n     * @param url defines the location of the file to load\n     * @param size defines the desired size (the more it increases the longer the generation will be)\n     * If the size is omitted this implies you are using a preprocessed cubemap.\n     * @param noMipmap defines if mipmaps should not be generated (default is false)\n     * @param gammaSpace specifies if the texture will be used in gamma or linear space\n     * (the PBR material requires those texture in linear space, but the standard material would require them in Gamma space)\n     * (default is true)\n     */\n    constructor(\n    /**\n     * Defines the name of the task\n     */\n    name, \n    /**\n     * Defines the location of the file to load\n     */\n    url, \n    /**\n     * Defines the desired size (the more it increases the longer the generation will be)\n     */\n    size, \n    /**\n     * Defines if mipmaps should not be generated (default is false)\n     */\n    noMipmap = false, \n    /**\n     * Specifies if the texture will be use in gamma or linear space (the PBR material requires those texture in linear space,\n     * but the standard material would require them in Gamma space) (default is true)\n     */\n    gammaSpace = true) {\n        super(name);\n        this.name = name;\n        this.url = url;\n        this.size = size;\n        this.noMipmap = noMipmap;\n        this.gammaSpace = gammaSpace;\n    }\n    /**\n     * Execute the current task\n     * @param scene defines the scene where you want your assets to be loaded\n     * @param onSuccess is a callback called when the task is successfully executed\n     * @param onError is a callback called if an error occurs\n     */\n    runTask(scene, onSuccess, onError) {\n        const onload = () => {\n            onSuccess();\n        };\n        const onerror = (message, exception) => {\n            onError(message, exception);\n        };\n        this.texture = new EquiRectangularCubeTexture(this.url, scene, this.size, this.noMipmap, this.gammaSpace, onload, onerror);\n    }\n}\n/**\n * This class can be used to easily import assets into a scene\n * @see https://doc.babylonjs.com/features/featuresDeepDive/importers/assetManager\n */\nexport class AssetsManager {\n    /**\n     * Creates a new AssetsManager\n     * @param scene defines the scene to work on\n     */\n    constructor(scene) {\n        this._isLoading = false;\n        this._tasks = new Array();\n        this._waitingTasksCount = 0;\n        this._totalTasksCount = 0;\n        /**\n         * Observable called when all tasks are processed\n         */\n        this.onTaskSuccessObservable = new Observable();\n        /**\n         * Observable called when a task had an error\n         */\n        this.onTaskErrorObservable = new Observable();\n        /**\n         * Observable called when all tasks were executed\n         */\n        this.onTasksDoneObservable = new Observable();\n        /**\n         * Observable called when a task is done (whatever the result is)\n         */\n        this.onProgressObservable = new Observable();\n        /**\n         * Gets or sets a boolean defining if the AssetsManager should use the default loading screen\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/customLoadingScreen\n         */\n        this.useDefaultLoadingScreen = true;\n        /**\n         * Gets or sets a boolean defining if the AssetsManager should automatically hide the loading screen\n         * when all assets have been downloaded.\n         * If set to false, you need to manually call in hideLoadingUI() once your scene is ready.\n         */\n        this.autoHideLoadingUI = true;\n        this._scene = scene || EngineStore.LastCreatedScene;\n    }\n    /**\n     * Add a ContainerAssetTask to the list of active tasks\n     * @param taskName defines the name of the new task\n     * @param meshesNames defines the name of meshes to load\n     * @param rootUrl defines the root url to use to locate files\n     * @param sceneFilename defines the filename of the scene file or the File itself\n     * @param extension defines the extension to use to load the file\n     * @returns a new ContainerAssetTask object\n     */\n    addContainerTask(taskName, meshesNames, rootUrl, sceneFilename, extension) {\n        const task = new ContainerAssetTask(taskName, meshesNames, rootUrl, sceneFilename, extension);\n        this._tasks.push(task);\n        return task;\n    }\n    /**\n     * Add a MeshAssetTask to the list of active tasks\n     * @param taskName defines the name of the new task\n     * @param meshesNames defines the name of meshes to load\n     * @param rootUrl defines the root url to use to locate files\n     * @param sceneFilename defines the filename of the scene file or the File itself\n     * @param extension defines the extension to use to load the file\n     * @returns a new MeshAssetTask object\n     */\n    addMeshTask(taskName, meshesNames, rootUrl, sceneFilename, extension) {\n        const task = new MeshAssetTask(taskName, meshesNames, rootUrl, sceneFilename, extension);\n        this._tasks.push(task);\n        return task;\n    }\n    /**\n     * Add a TextFileAssetTask to the list of active tasks\n     * @param taskName defines the name of the new task\n     * @param url defines the url of the file to load\n     * @returns a new TextFileAssetTask object\n     */\n    addTextFileTask(taskName, url) {\n        const task = new TextFileAssetTask(taskName, url);\n        this._tasks.push(task);\n        return task;\n    }\n    /**\n     * Add a BinaryFileAssetTask to the list of active tasks\n     * @param taskName defines the name of the new task\n     * @param url defines the url of the file to load\n     * @returns a new BinaryFileAssetTask object\n     */\n    addBinaryFileTask(taskName, url) {\n        const task = new BinaryFileAssetTask(taskName, url);\n        this._tasks.push(task);\n        return task;\n    }\n    /**\n     * Add a ImageAssetTask to the list of active tasks\n     * @param taskName defines the name of the new task\n     * @param url defines the url of the file to load\n     * @returns a new ImageAssetTask object\n     */\n    addImageTask(taskName, url) {\n        const task = new ImageAssetTask(taskName, url);\n        this._tasks.push(task);\n        return task;\n    }\n    /**\n     * Add a TextureAssetTask to the list of active tasks\n     * @param taskName defines the name of the new task\n     * @param url defines the url of the file to load\n     * @param noMipmap defines if the texture must not receive mipmaps (false by default)\n     * @param invertY defines if you want to invert Y axis of the loaded texture (true by default)\n     * @param samplingMode defines the sampling mode to use (Texture.TRILINEAR_SAMPLINGMODE by default)\n     * @returns a new TextureAssetTask object\n     */\n    addTextureTask(taskName, url, noMipmap, invertY, samplingMode = Texture.TRILINEAR_SAMPLINGMODE) {\n        const task = new TextureAssetTask(taskName, url, noMipmap, invertY, samplingMode);\n        this._tasks.push(task);\n        return task;\n    }\n    /**\n     * Add a CubeTextureAssetTask to the list of active tasks\n     * @param taskName defines the name of the new task\n     * @param url defines the url of the file to load\n     * @param extensions defines the extension to use to load the cube map (can be null)\n     * @param noMipmap defines if the texture must not receive mipmaps (false by default)\n     * @param files defines the list of files to load (can be null)\n     * @param prefiltered defines the prefiltered texture option (default is false)\n     * @returns a new CubeTextureAssetTask object\n     */\n    addCubeTextureTask(taskName, url, extensions, noMipmap, files, prefiltered) {\n        const task = new CubeTextureAssetTask(taskName, url, extensions, noMipmap, files, prefiltered);\n        this._tasks.push(task);\n        return task;\n    }\n    /**\n     *\n     * Add a HDRCubeTextureAssetTask to the list of active tasks\n     * @param taskName defines the name of the new task\n     * @param url defines the url of the file to load\n     * @param size defines the size you want for the cubemap (can be null)\n     * @param noMipmap defines if the texture must not receive mipmaps (false by default)\n     * @param generateHarmonics defines if you want to automatically generate (true by default)\n     * @param gammaSpace specifies if the texture will be use in gamma or linear space (the PBR material requires those texture in linear space, but the standard material would require them in Gamma space) (default is false)\n     * @param reserved Internal use only\n     * @returns a new HDRCubeTextureAssetTask object\n     */\n    addHDRCubeTextureTask(taskName, url, size, noMipmap = false, generateHarmonics = true, gammaSpace = false, reserved = false) {\n        const task = new HDRCubeTextureAssetTask(taskName, url, size, noMipmap, generateHarmonics, gammaSpace, reserved);\n        this._tasks.push(task);\n        return task;\n    }\n    /**\n     *\n     * Add a EquiRectangularCubeTextureAssetTask to the list of active tasks\n     * @param taskName defines the name of the new task\n     * @param url defines the url of the file to load\n     * @param size defines the size you want for the cubemap (can be null)\n     * @param noMipmap defines if the texture must not receive mipmaps (false by default)\n     * @param gammaSpace Specifies if the texture will be used in gamma or linear space\n     * (the PBR material requires those textures in linear space, but the standard material would require them in Gamma space)\n     * @returns a new EquiRectangularCubeTextureAssetTask object\n     */\n    addEquiRectangularCubeTextureAssetTask(taskName, url, size, noMipmap = false, gammaSpace = true) {\n        const task = new EquiRectangularCubeTextureAssetTask(taskName, url, size, noMipmap, gammaSpace);\n        this._tasks.push(task);\n        return task;\n    }\n    /**\n     * Remove a task from the assets manager.\n     * @param task the task to remove\n     */\n    removeTask(task) {\n        const index = this._tasks.indexOf(task);\n        if (index > -1) {\n            this._tasks.splice(index, 1);\n        }\n    }\n    _decreaseWaitingTasksCount(task) {\n        this._waitingTasksCount--;\n        try {\n            if (this.onProgress) {\n                this.onProgress(this._waitingTasksCount, this._totalTasksCount, task);\n            }\n            this.onProgressObservable.notifyObservers(new AssetsProgressEvent(this._waitingTasksCount, this._totalTasksCount, task));\n        }\n        catch (e) {\n            Logger.Error(\"Error running progress callbacks.\");\n            console.log(e);\n        }\n        if (this._waitingTasksCount === 0) {\n            try {\n                const currentTasks = this._tasks.slice();\n                if (this.onFinish) {\n                    // Calling onFinish with immutable array of tasks\n                    this.onFinish(currentTasks);\n                }\n                // Let's remove successful tasks\n                for (const task of currentTasks) {\n                    if (task.taskState === AssetTaskState.DONE) {\n                        const index = this._tasks.indexOf(task);\n                        if (index > -1) {\n                            this._tasks.splice(index, 1);\n                        }\n                    }\n                }\n                this.onTasksDoneObservable.notifyObservers(this._tasks);\n            }\n            catch (e) {\n                Logger.Error(\"Error running tasks-done callbacks.\");\n                console.log(e);\n            }\n            this._isLoading = false;\n            if (this.autoHideLoadingUI) {\n                this._scene.getEngine().hideLoadingUI();\n            }\n        }\n    }\n    _runTask(task) {\n        const done = () => {\n            try {\n                if (this.onTaskSuccess) {\n                    this.onTaskSuccess(task);\n                }\n                this.onTaskSuccessObservable.notifyObservers(task);\n                this._decreaseWaitingTasksCount(task);\n            }\n            catch (e) {\n                error(\"Error executing task success callbacks\", e);\n            }\n        };\n        const error = (message, exception) => {\n            task._setErrorObject(message, exception);\n            if (this.onTaskError) {\n                this.onTaskError(task);\n            }\n            else if (!task.onError) {\n                Logger.Error(this._formatTaskErrorMessage(task));\n            }\n            this.onTaskErrorObservable.notifyObservers(task);\n            this._decreaseWaitingTasksCount(task);\n        };\n        task.run(this._scene, done, error);\n    }\n    _formatTaskErrorMessage(task) {\n        let errorMessage = \"Unable to complete task \" + task.name;\n        if (task.errorObject.message) {\n            errorMessage += `: ${task.errorObject.message}`;\n        }\n        if (task.errorObject.exception) {\n            errorMessage += `: ${task.errorObject.exception}`;\n        }\n        return errorMessage;\n    }\n    /**\n     * Reset the AssetsManager and remove all tasks\n     * @returns the current instance of the AssetsManager\n     */\n    reset() {\n        this._isLoading = false;\n        this._tasks = new Array();\n        return this;\n    }\n    /**\n     * Start the loading process\n     * @returns the current instance of the AssetsManager\n     */\n    load() {\n        if (this._isLoading) {\n            return this;\n        }\n        this._isLoading = true;\n        this._waitingTasksCount = this._tasks.length;\n        this._totalTasksCount = this._tasks.length;\n        if (this._waitingTasksCount === 0) {\n            this._isLoading = false;\n            if (this.onFinish) {\n                this.onFinish(this._tasks);\n            }\n            this.onTasksDoneObservable.notifyObservers(this._tasks);\n            return this;\n        }\n        if (this.useDefaultLoadingScreen) {\n            this._scene.getEngine().displayLoadingUI();\n        }\n        for (let index = 0; index < this._tasks.length; index++) {\n            const task = this._tasks[index];\n            if (task.taskState === AssetTaskState.INIT) {\n                this._runTask(task);\n            }\n        }\n        return this;\n    }\n    /**\n     * Start the loading process as an async operation\n     * @returns a promise returning the list of failed tasks\n     */\n    loadAsync() {\n        return new Promise((resolve, reject) => {\n            if (this._isLoading) {\n                resolve();\n                return;\n            }\n            this.onTasksDoneObservable.addOnce((remainingTasks) => {\n                if (remainingTasks && remainingTasks.length) {\n                    reject(remainingTasks);\n                }\n                else {\n                    resolve();\n                }\n            });\n            this.load();\n        });\n    }\n}\n//# sourceMappingURL=assetsManager.js.map","import { Tools } from \"./tools.js\";\nimport { Texture } from \"../Materials/Textures/texture.js\";\nimport { InternalTexture, InternalTextureSource } from \"../Materials/Textures/internalTexture.js\";\nimport { Scalar } from \"../Maths/math.scalar.js\";\n\n/**\n * Info about the .basis files\n */\nclass BasisFileInfo {\n}\n/**\n * Result of transcoding a basis file\n */\nclass TranscodeResult {\n}\n/**\n * Configuration options for the Basis transcoder\n */\nexport class BasisTranscodeConfiguration {\n}\n/**\n * @internal\n * Enum of basis transcoder formats\n */\nvar BASIS_FORMATS;\n(function (BASIS_FORMATS) {\n    BASIS_FORMATS[BASIS_FORMATS[\"cTFETC1\"] = 0] = \"cTFETC1\";\n    BASIS_FORMATS[BASIS_FORMATS[\"cTFETC2\"] = 1] = \"cTFETC2\";\n    BASIS_FORMATS[BASIS_FORMATS[\"cTFBC1\"] = 2] = \"cTFBC1\";\n    BASIS_FORMATS[BASIS_FORMATS[\"cTFBC3\"] = 3] = \"cTFBC3\";\n    BASIS_FORMATS[BASIS_FORMATS[\"cTFBC4\"] = 4] = \"cTFBC4\";\n    BASIS_FORMATS[BASIS_FORMATS[\"cTFBC5\"] = 5] = \"cTFBC5\";\n    BASIS_FORMATS[BASIS_FORMATS[\"cTFBC7\"] = 6] = \"cTFBC7\";\n    BASIS_FORMATS[BASIS_FORMATS[\"cTFPVRTC1_4_RGB\"] = 8] = \"cTFPVRTC1_4_RGB\";\n    BASIS_FORMATS[BASIS_FORMATS[\"cTFPVRTC1_4_RGBA\"] = 9] = \"cTFPVRTC1_4_RGBA\";\n    BASIS_FORMATS[BASIS_FORMATS[\"cTFASTC_4x4\"] = 10] = \"cTFASTC_4x4\";\n    BASIS_FORMATS[BASIS_FORMATS[\"cTFATC_RGB\"] = 11] = \"cTFATC_RGB\";\n    BASIS_FORMATS[BASIS_FORMATS[\"cTFATC_RGBA_INTERPOLATED_ALPHA\"] = 12] = \"cTFATC_RGBA_INTERPOLATED_ALPHA\";\n    BASIS_FORMATS[BASIS_FORMATS[\"cTFRGBA32\"] = 13] = \"cTFRGBA32\";\n    BASIS_FORMATS[BASIS_FORMATS[\"cTFRGB565\"] = 14] = \"cTFRGB565\";\n    BASIS_FORMATS[BASIS_FORMATS[\"cTFBGR565\"] = 15] = \"cTFBGR565\";\n    BASIS_FORMATS[BASIS_FORMATS[\"cTFRGBA4444\"] = 16] = \"cTFRGBA4444\";\n    BASIS_FORMATS[BASIS_FORMATS[\"cTFFXT1_RGB\"] = 17] = \"cTFFXT1_RGB\";\n    BASIS_FORMATS[BASIS_FORMATS[\"cTFPVRTC2_4_RGB\"] = 18] = \"cTFPVRTC2_4_RGB\";\n    BASIS_FORMATS[BASIS_FORMATS[\"cTFPVRTC2_4_RGBA\"] = 19] = \"cTFPVRTC2_4_RGBA\";\n    BASIS_FORMATS[BASIS_FORMATS[\"cTFETC2_EAC_R11\"] = 20] = \"cTFETC2_EAC_R11\";\n    BASIS_FORMATS[BASIS_FORMATS[\"cTFETC2_EAC_RG11\"] = 21] = \"cTFETC2_EAC_RG11\";\n})(BASIS_FORMATS || (BASIS_FORMATS = {}));\n/**\n * Used to load .Basis files\n * See https://github.com/BinomialLLC/basis_universal/tree/master/webgl\n */\nexport const BasisToolsOptions = {\n    /**\n     * URL to use when loading the basis transcoder\n     */\n    JSModuleURL: \"https://cdn.babylonjs.com/basisTranscoder/1/basis_transcoder.js\",\n    /**\n     * URL to use when loading the wasm module for the transcoder\n     */\n    WasmModuleURL: \"https://cdn.babylonjs.com/basisTranscoder/1/basis_transcoder.wasm\",\n};\n/**\n * Get the internal format to be passed to texImage2D corresponding to the .basis format value\n * @param basisFormat format chosen from GetSupportedTranscodeFormat\n * @param engine\n * @returns internal format corresponding to the Basis format\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport const GetInternalFormatFromBasisFormat = (basisFormat, engine) => {\n    let format;\n    switch (basisFormat) {\n        case BASIS_FORMATS.cTFETC1:\n            format = 36196;\n            break;\n        case BASIS_FORMATS.cTFBC1:\n            format = 33776;\n            break;\n        case BASIS_FORMATS.cTFBC4:\n            format = 33779;\n            break;\n        case BASIS_FORMATS.cTFASTC_4x4:\n            format = 37808;\n            break;\n        case BASIS_FORMATS.cTFETC2:\n            format = 37496;\n            break;\n        case BASIS_FORMATS.cTFBC7:\n            format = 36492;\n            break;\n    }\n    if (format === undefined) {\n        throw \"The chosen Basis transcoder format is not currently supported\";\n    }\n    return format;\n};\nlet _WorkerPromise = null;\nlet _Worker = null;\nlet _actionId = 0;\nconst _IgnoreSupportedFormats = false;\nconst _CreateWorkerAsync = () => {\n    if (!_WorkerPromise) {\n        _WorkerPromise = new Promise((res, reject) => {\n            if (_Worker) {\n                res(_Worker);\n            }\n            else {\n                Tools.LoadFileAsync(BasisToolsOptions.WasmModuleURL)\n                    .then((wasmBinary) => {\n                    if (typeof URL !== \"function\") {\n                        return reject(\"Basis transcoder requires an environment with a URL constructor\");\n                    }\n                    const workerBlobUrl = URL.createObjectURL(new Blob([`(${workerFunc})()`], { type: \"application/javascript\" }));\n                    _Worker = new Worker(workerBlobUrl);\n                    const initHandler = (msg) => {\n                        if (msg.data.action === \"init\") {\n                            _Worker.removeEventListener(\"message\", initHandler);\n                            res(_Worker);\n                        }\n                        else if (msg.data.action === \"error\") {\n                            reject(msg.data.error || \"error initializing worker\");\n                        }\n                    };\n                    _Worker.addEventListener(\"message\", initHandler);\n                    _Worker.postMessage({ action: \"init\", url: BasisToolsOptions.JSModuleURL, wasmBinary: wasmBinary });\n                })\n                    .catch(reject);\n            }\n        });\n    }\n    return _WorkerPromise;\n};\n/**\n * Transcodes a loaded image file to compressed pixel data\n * @param data image data to transcode\n * @param config configuration options for the transcoding\n * @returns a promise resulting in the transcoded image\n */\nexport const TranscodeAsync = (data, config) => {\n    const dataView = data instanceof ArrayBuffer ? new Uint8Array(data) : data;\n    return new Promise((res, rej) => {\n        _CreateWorkerAsync().then(() => {\n            const actionId = _actionId++;\n            const messageHandler = (msg) => {\n                if (msg.data.action === \"transcode\" && msg.data.id === actionId) {\n                    _Worker.removeEventListener(\"message\", messageHandler);\n                    if (!msg.data.success) {\n                        rej(\"Transcode is not supported on this device\");\n                    }\n                    else {\n                        res(msg.data);\n                    }\n                }\n            };\n            _Worker.addEventListener(\"message\", messageHandler);\n            const dataViewCopy = new Uint8Array(dataView.byteLength);\n            dataViewCopy.set(new Uint8Array(dataView.buffer, dataView.byteOffset, dataView.byteLength));\n            _Worker.postMessage({ action: \"transcode\", id: actionId, imageData: dataViewCopy, config: config, ignoreSupportedFormats: _IgnoreSupportedFormats }, [\n                dataViewCopy.buffer,\n            ]);\n        }, (error) => {\n            rej(error);\n        });\n    });\n};\n/**\n * Binds a texture according to its underlying target.\n * @param texture texture to bind\n * @param engine the engine to bind the texture in\n */\nconst BindTexture = (texture, engine) => {\n    var _a, _b;\n    let target = (_a = engine._gl) === null || _a === void 0 ? void 0 : _a.TEXTURE_2D;\n    if (texture.isCube) {\n        target = (_b = engine._gl) === null || _b === void 0 ? void 0 : _b.TEXTURE_CUBE_MAP;\n    }\n    engine._bindTextureDirectly(target, texture, true);\n};\n/**\n * Loads a texture from the transcode result\n * @param texture texture load to\n * @param transcodeResult the result of transcoding the basis file to load from\n */\nexport const LoadTextureFromTranscodeResult = (texture, transcodeResult) => {\n    const engine = texture.getEngine();\n    for (let i = 0; i < transcodeResult.fileInfo.images.length; i++) {\n        const rootImage = transcodeResult.fileInfo.images[i].levels[0];\n        texture._invertVScale = texture.invertY;\n        if (transcodeResult.format === -1 || transcodeResult.format === BASIS_FORMATS.cTFRGB565) {\n            // No compatable compressed format found, fallback to RGB\n            texture.type = 10;\n            texture.format = 4;\n            if (engine._features.basisNeedsPOT && (Scalar.Log2(rootImage.width) % 1 !== 0 || Scalar.Log2(rootImage.height) % 1 !== 0)) {\n                // Create non power of two texture\n                const source = new InternalTexture(engine, InternalTextureSource.Temp);\n                texture._invertVScale = texture.invertY;\n                source.type = 10;\n                source.format = 4;\n                // Fallback requires aligned width/height\n                source.width = (rootImage.width + 3) & ~3;\n                source.height = (rootImage.height + 3) & ~3;\n                BindTexture(source, engine);\n                engine._uploadDataToTextureDirectly(source, new Uint16Array(rootImage.transcodedPixels.buffer), i, 0, 4, true);\n                // Resize to power of two\n                engine._rescaleTexture(source, texture, engine.scenes[0], engine._getInternalFormat(4), () => {\n                    engine._releaseTexture(source);\n                    BindTexture(texture, engine);\n                });\n            }\n            else {\n                // Fallback is already inverted\n                texture._invertVScale = !texture.invertY;\n                // Upload directly\n                texture.width = (rootImage.width + 3) & ~3;\n                texture.height = (rootImage.height + 3) & ~3;\n                texture.samplingMode = 2;\n                BindTexture(texture, engine);\n                engine._uploadDataToTextureDirectly(texture, new Uint16Array(rootImage.transcodedPixels.buffer), i, 0, 4, true);\n            }\n        }\n        else {\n            texture.width = rootImage.width;\n            texture.height = rootImage.height;\n            texture.generateMipMaps = transcodeResult.fileInfo.images[i].levels.length > 1;\n            const format = BasisTools.GetInternalFormatFromBasisFormat(transcodeResult.format, engine);\n            texture.format = format;\n            BindTexture(texture, engine);\n            // Upload all mip levels in the file\n            transcodeResult.fileInfo.images[i].levels.forEach((level, index) => {\n                engine._uploadCompressedDataToTextureDirectly(texture, format, level.width, level.height, level.transcodedPixels, i, index);\n            });\n            if (engine._features.basisNeedsPOT && (Scalar.Log2(texture.width) % 1 !== 0 || Scalar.Log2(texture.height) % 1 !== 0)) {\n                Tools.Warn(\"Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1.\");\n                texture._cachedWrapU = Texture.CLAMP_ADDRESSMODE;\n                texture._cachedWrapV = Texture.CLAMP_ADDRESSMODE;\n            }\n        }\n    }\n};\n/**\n * Used to load .Basis files\n * See https://github.com/BinomialLLC/basis_universal/tree/master/webgl\n */\nexport const BasisTools = {\n    /**\n     * URL to use when loading the basis transcoder\n     */\n    JSModuleURL: BasisToolsOptions.JSModuleURL,\n    /**\n     * URL to use when loading the wasm module for the transcoder\n     */\n    WasmModuleURL: BasisToolsOptions.WasmModuleURL,\n    /**\n     * Get the internal format to be passed to texImage2D corresponding to the .basis format value\n     * @param basisFormat format chosen from GetSupportedTranscodeFormat\n     * @returns internal format corresponding to the Basis format\n     */\n    GetInternalFormatFromBasisFormat,\n    /**\n     * Transcodes a loaded image file to compressed pixel data\n     * @param data image data to transcode\n     * @param config configuration options for the transcoding\n     * @returns a promise resulting in the transcoded image\n     */\n    TranscodeAsync,\n    /**\n     * Loads a texture from the transcode result\n     * @param texture texture load to\n     * @param transcodeResult the result of transcoding the basis file to load from\n     */\n    LoadTextureFromTranscodeResult,\n};\nfunction workerFunc() {\n    const _BASIS_FORMAT = {\n        cTFETC1: 0,\n        cTFETC2: 1,\n        cTFBC1: 2,\n        cTFBC3: 3,\n        cTFBC4: 4,\n        cTFBC5: 5,\n        cTFBC7: 6,\n        cTFPVRTC1_4_RGB: 8,\n        cTFPVRTC1_4_RGBA: 9,\n        cTFASTC_4x4: 10,\n        cTFATC_RGB: 11,\n        cTFATC_RGBA_INTERPOLATED_ALPHA: 12,\n        cTFRGBA32: 13,\n        cTFRGB565: 14,\n        cTFBGR565: 15,\n        cTFRGBA4444: 16,\n        cTFFXT1_RGB: 17,\n        cTFPVRTC2_4_RGB: 18,\n        cTFPVRTC2_4_RGBA: 19,\n        cTFETC2_EAC_R11: 20,\n        cTFETC2_EAC_RG11: 21,\n    };\n    let transcoderModulePromise = null;\n    onmessage = (event) => {\n        if (event.data.action === \"init\") {\n            // Load the transcoder if it hasn't been yet\n            if (!transcoderModulePromise) {\n                // make sure we loaded the script correctly\n                try {\n                    importScripts(event.data.url);\n                }\n                catch (e) {\n                    postMessage({ action: \"error\", error: e });\n                }\n                transcoderModulePromise = BASIS({\n                    // Override wasm binary\n                    wasmBinary: event.data.wasmBinary,\n                });\n            }\n            if (transcoderModulePromise !== null) {\n                transcoderModulePromise.then((m) => {\n                    BASIS = m;\n                    m.initializeBasis();\n                    postMessage({ action: \"init\" });\n                });\n            }\n        }\n        else if (event.data.action === \"transcode\") {\n            // Transcode the basis image and return the resulting pixels\n            const config = event.data.config;\n            const imgData = event.data.imageData;\n            const loadedFile = new BASIS.BasisFile(imgData);\n            const fileInfo = GetFileInfo(loadedFile);\n            let format = event.data.ignoreSupportedFormats ? null : GetSupportedTranscodeFormat(event.data.config, fileInfo);\n            let needsConversion = false;\n            if (format === null) {\n                needsConversion = true;\n                format = fileInfo.hasAlpha ? _BASIS_FORMAT.cTFBC3 : _BASIS_FORMAT.cTFBC1;\n            }\n            // Begin transcode\n            let success = true;\n            if (!loadedFile.startTranscoding()) {\n                success = false;\n            }\n            const buffers = [];\n            for (let imageIndex = 0; imageIndex < fileInfo.images.length; imageIndex++) {\n                if (!success) {\n                    break;\n                }\n                const image = fileInfo.images[imageIndex];\n                if (config.loadSingleImage === undefined || config.loadSingleImage === imageIndex) {\n                    let mipCount = image.levels.length;\n                    if (config.loadMipmapLevels === false) {\n                        mipCount = 1;\n                    }\n                    for (let levelIndex = 0; levelIndex < mipCount; levelIndex++) {\n                        const levelInfo = image.levels[levelIndex];\n                        const pixels = TranscodeLevel(loadedFile, imageIndex, levelIndex, format, needsConversion);\n                        if (!pixels) {\n                            success = false;\n                            break;\n                        }\n                        levelInfo.transcodedPixels = pixels;\n                        buffers.push(levelInfo.transcodedPixels.buffer);\n                    }\n                }\n            }\n            // Close file\n            loadedFile.close();\n            loadedFile.delete();\n            if (needsConversion) {\n                format = -1;\n            }\n            if (!success) {\n                postMessage({ action: \"transcode\", success: success, id: event.data.id });\n            }\n            else {\n                postMessage({ action: \"transcode\", success: success, id: event.data.id, fileInfo: fileInfo, format: format }, buffers);\n            }\n        }\n    };\n    /**\n     * Detects the supported transcode format for the file\n     * @param config transcode config\n     * @param fileInfo info about the file\n     * @returns the chosed format or null if none are supported\n     */\n    function GetSupportedTranscodeFormat(config, fileInfo) {\n        let format = null;\n        if (config.supportedCompressionFormats) {\n            if (config.supportedCompressionFormats.astc) {\n                format = _BASIS_FORMAT.cTFASTC_4x4;\n            }\n            else if (config.supportedCompressionFormats.bc7) {\n                format = _BASIS_FORMAT.cTFBC7;\n            }\n            else if (config.supportedCompressionFormats.s3tc) {\n                format = fileInfo.hasAlpha ? _BASIS_FORMAT.cTFBC3 : _BASIS_FORMAT.cTFBC1;\n            }\n            else if (config.supportedCompressionFormats.pvrtc) {\n                format = fileInfo.hasAlpha ? _BASIS_FORMAT.cTFPVRTC1_4_RGBA : _BASIS_FORMAT.cTFPVRTC1_4_RGB;\n            }\n            else if (config.supportedCompressionFormats.etc2) {\n                format = _BASIS_FORMAT.cTFETC2;\n            }\n            else if (config.supportedCompressionFormats.etc1) {\n                format = _BASIS_FORMAT.cTFETC1;\n            }\n            else {\n                format = _BASIS_FORMAT.cTFRGB565;\n            }\n        }\n        return format;\n    }\n    /**\n     * Retrieves information about the basis file eg. dimensions\n     * @param basisFile the basis file to get the info from\n     * @returns information about the basis file\n     */\n    function GetFileInfo(basisFile) {\n        const hasAlpha = basisFile.getHasAlpha();\n        const imageCount = basisFile.getNumImages();\n        const images = [];\n        for (let i = 0; i < imageCount; i++) {\n            const imageInfo = {\n                levels: [],\n            };\n            const levelCount = basisFile.getNumLevels(i);\n            for (let level = 0; level < levelCount; level++) {\n                const levelInfo = {\n                    width: basisFile.getImageWidth(i, level),\n                    height: basisFile.getImageHeight(i, level),\n                };\n                imageInfo.levels.push(levelInfo);\n            }\n            images.push(imageInfo);\n        }\n        const info = { hasAlpha, images };\n        return info;\n    }\n    function TranscodeLevel(loadedFile, imageIndex, levelIndex, format, convertToRgb565) {\n        const dstSize = loadedFile.getImageTranscodedSizeInBytes(imageIndex, levelIndex, format);\n        let dst = new Uint8Array(dstSize);\n        if (!loadedFile.transcodeImage(dst, imageIndex, levelIndex, format, 1, 0)) {\n            return null;\n        }\n        // If no supported format is found, load as dxt and convert to rgb565\n        if (convertToRgb565) {\n            const alignedWidth = (loadedFile.getImageWidth(imageIndex, levelIndex) + 3) & ~3;\n            const alignedHeight = (loadedFile.getImageHeight(imageIndex, levelIndex) + 3) & ~3;\n            dst = ConvertDxtToRgb565(dst, 0, alignedWidth, alignedHeight);\n        }\n        return dst;\n    }\n    /**\n     * From https://github.com/BinomialLLC/basis_universal/blob/master/webgl/texture/dxt-to-rgb565.js\n     * An unoptimized version of dxtToRgb565.  Also, the floating\n     * point math used to compute the colors actually results in\n     * slightly different colors compared to hardware DXT decoders.\n     * @param src dxt src pixels\n     * @param srcByteOffset offset for the start of src\n     * @param  width aligned width of the image\n     * @param  height aligned height of the image\n     * @returns the converted pixels\n     */\n    function ConvertDxtToRgb565(src, srcByteOffset, width, height) {\n        const c = new Uint16Array(4);\n        const dst = new Uint16Array(width * height);\n        const blockWidth = width / 4;\n        const blockHeight = height / 4;\n        for (let blockY = 0; blockY < blockHeight; blockY++) {\n            for (let blockX = 0; blockX < blockWidth; blockX++) {\n                const i = srcByteOffset + 8 * (blockY * blockWidth + blockX);\n                c[0] = src[i] | (src[i + 1] << 8);\n                c[1] = src[i + 2] | (src[i + 3] << 8);\n                c[2] =\n                    ((2 * (c[0] & 0x1f) + 1 * (c[1] & 0x1f)) / 3) |\n                        (((2 * (c[0] & 0x7e0) + 1 * (c[1] & 0x7e0)) / 3) & 0x7e0) |\n                        (((2 * (c[0] & 0xf800) + 1 * (c[1] & 0xf800)) / 3) & 0xf800);\n                c[3] =\n                    ((2 * (c[1] & 0x1f) + 1 * (c[0] & 0x1f)) / 3) |\n                        (((2 * (c[1] & 0x7e0) + 1 * (c[0] & 0x7e0)) / 3) & 0x7e0) |\n                        (((2 * (c[1] & 0xf800) + 1 * (c[0] & 0xf800)) / 3) & 0xf800);\n                for (let row = 0; row < 4; row++) {\n                    const m = src[i + 4 + row];\n                    let dstI = (blockY * 4 + row) * width + blockX * 4;\n                    dst[dstI++] = c[m & 0x3];\n                    dst[dstI++] = c[(m >> 2) & 0x3];\n                    dst[dstI++] = c[(m >> 4) & 0x3];\n                    dst[dstI++] = c[(m >> 6) & 0x3];\n                }\n            }\n        }\n        return dst;\n    }\n}\nObject.defineProperty(BasisTools, \"JSModuleURL\", {\n    get: function () {\n        return BasisToolsOptions.JSModuleURL;\n    },\n    set: function (value) {\n        BasisToolsOptions.JSModuleURL = value;\n    },\n});\nObject.defineProperty(BasisTools, \"WasmModuleURL\", {\n    get: function () {\n        return BasisToolsOptions.WasmModuleURL;\n    },\n    set: function (value) {\n        BasisToolsOptions.WasmModuleURL = value;\n    },\n});\n//# sourceMappingURL=basis.js.map","import { Texture } from \"../Materials/Textures/texture.js\";\nimport { RGBDTextureTools } from \"./rgbdTextureTools.js\";\nimport { Tools } from \"./tools.js\";\n// eslint-disable-next-line @typescript-eslint/naming-convention\nconst _environmentBRDFBase64Texture = \"data:image/png;base64,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\";\nlet _instanceNumber = 0;\n/**\n * Gets a default environment BRDF for MS-BRDF Height Correlated BRDF\n * @param scene defines the hosting scene\n * @returns the environment BRDF texture\n */\nexport const GetEnvironmentBRDFTexture = (scene) => {\n    if (!scene.environmentBRDFTexture) {\n        // Forces Delayed Texture Loading to prevent undefined error whilst setting RGBD values.\n        const useDelayedTextureLoading = scene.useDelayedTextureLoading;\n        scene.useDelayedTextureLoading = false;\n        const previousState = scene._blockEntityCollection;\n        scene._blockEntityCollection = false;\n        const texture = Texture.CreateFromBase64String(_environmentBRDFBase64Texture, \"EnvironmentBRDFTexture\" + _instanceNumber++, scene, true, false, Texture.BILINEAR_SAMPLINGMODE);\n        scene._blockEntityCollection = previousState;\n        // BRDF Texture should not be cached here due to pre processing and redundant scene caches.\n        const texturesCache = scene.getEngine().getLoadedTexturesCache();\n        const index = texturesCache.indexOf(texture.getInternalTexture());\n        if (index !== -1) {\n            texturesCache.splice(index, 1);\n        }\n        texture.isRGBD = true;\n        texture.wrapU = Texture.CLAMP_ADDRESSMODE;\n        texture.wrapV = Texture.CLAMP_ADDRESSMODE;\n        scene.environmentBRDFTexture = texture;\n        scene.useDelayedTextureLoading = useDelayedTextureLoading;\n        RGBDTextureTools.ExpandRGBDTexture(texture);\n        const observer = scene.getEngine().onContextRestoredObservable.add(() => {\n            texture.isRGBD = true;\n            const checkReady = () => {\n                if (texture.isReady()) {\n                    RGBDTextureTools.ExpandRGBDTexture(texture);\n                }\n                else {\n                    Tools.SetImmediate(checkReady);\n                }\n            };\n            checkReady();\n        });\n        scene.onDisposeObservable.add(() => {\n            scene.getEngine().onContextRestoredObservable.remove(observer);\n        });\n    }\n    return scene.environmentBRDFTexture;\n};\n/**\n * Class used to host texture specific utilities\n */\nexport const BRDFTextureTools = {\n    /**\n     * Gets a default environment BRDF for MS-BRDF Height Correlated BRDF\n     * @param scene defines the hosting scene\n     * @returns the environment BRDF texture\n     */\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    GetEnvironmentBRDFTexture,\n};\n//# sourceMappingURL=brdfTextureTools.js.map","/**\n * Extracts the characters between two markers (for eg, between \"(\" and \")\"). The function handles nested markers as well as markers inside strings (delimited by \", ' or `) and comments\n * @param markerOpen opening marker\n * @param markerClose closing marker\n * @param block code block to parse\n * @param startIndex starting index in block where the extraction must start. The character at block[startIndex] should be the markerOpen character!\n * @returns index of the last character for the extraction (or -1 if the string is invalid - no matching closing marker found). The string to extract (without the markers) is the string between startIndex + 1 and the returned value (exclusive)\n */\nexport function ExtractBetweenMarkers(markerOpen, markerClose, block, startIndex) {\n    let currPos = startIndex, openMarkers = 0, waitForChar = \"\";\n    while (currPos < block.length) {\n        const currChar = block.charAt(currPos);\n        if (!waitForChar) {\n            switch (currChar) {\n                case markerOpen:\n                    openMarkers++;\n                    break;\n                case markerClose:\n                    openMarkers--;\n                    break;\n                case '\"':\n                case \"'\":\n                case \"`\":\n                    waitForChar = currChar;\n                    break;\n                case \"/\":\n                    if (currPos + 1 < block.length) {\n                        const nextChar = block.charAt(currPos + 1);\n                        if (nextChar === \"/\") {\n                            waitForChar = \"\\n\";\n                        }\n                        else if (nextChar === \"*\") {\n                            waitForChar = \"*/\";\n                        }\n                    }\n                    break;\n            }\n        }\n        else {\n            if (currChar === waitForChar) {\n                if (waitForChar === '\"' || waitForChar === \"'\") {\n                    block.charAt(currPos - 1) !== \"\\\\\" && (waitForChar = \"\");\n                }\n                else {\n                    waitForChar = \"\";\n                }\n            }\n            else if (waitForChar === \"*/\" && currChar === \"*\" && currPos + 1 < block.length) {\n                block.charAt(currPos + 1) === \"/\" && (waitForChar = \"\");\n                if (waitForChar === \"\") {\n                    currPos++;\n                }\n            }\n        }\n        currPos++;\n        if (openMarkers === 0) {\n            break;\n        }\n    }\n    return openMarkers === 0 ? currPos - 1 : -1;\n}\n/**\n * Parses a string and skip whitespaces\n * @param s string to parse\n * @param index index where to start parsing\n * @returns the index after all whitespaces have been skipped\n */\nexport function SkipWhitespaces(s, index) {\n    while (index < s.length) {\n        const c = s[index];\n        if (c !== \" \" && c !== \"\\n\" && c !== \"\\r\" && c !== \"\\t\" && c !== \"\\u000a\" && c !== \"\\u00a0\") {\n            break;\n        }\n        index++;\n    }\n    return index;\n}\n/**\n * Checks if a character is an identifier character (meaning, if it is 0-9, A-Z, a-z or _)\n * @param c character to check\n * @returns true if the character is an identifier character\n */\nexport function IsIdentifierChar(c) {\n    const v = c.charCodeAt(0);\n    return ((v >= 48 && v <= 57) || // 0-9\n        (v >= 65 && v <= 90) || // A-Z\n        (v >= 97 && v <= 122) || // a-z\n        v == 95); // _\n}\n/**\n * Removes the comments of a code block\n * @param block code block to parse\n * @returns block with the comments removed\n */\nexport function RemoveComments(block) {\n    let currPos = 0, waitForChar = \"\", inComments = false;\n    const s = [];\n    while (currPos < block.length) {\n        const currChar = block.charAt(currPos);\n        if (!waitForChar) {\n            switch (currChar) {\n                case '\"':\n                case \"'\":\n                case \"`\":\n                    waitForChar = currChar;\n                    break;\n                case \"/\":\n                    if (currPos + 1 < block.length) {\n                        const nextChar = block.charAt(currPos + 1);\n                        if (nextChar === \"/\") {\n                            waitForChar = \"\\n\";\n                            inComments = true;\n                        }\n                        else if (nextChar === \"*\") {\n                            waitForChar = \"*/\";\n                            inComments = true;\n                        }\n                    }\n                    break;\n            }\n            if (!inComments) {\n                s.push(currChar);\n            }\n        }\n        else {\n            if (currChar === waitForChar) {\n                if (waitForChar === '\"' || waitForChar === \"'\") {\n                    block.charAt(currPos - 1) !== \"\\\\\" && (waitForChar = \"\");\n                    s.push(currChar);\n                }\n                else {\n                    waitForChar = \"\";\n                    inComments = false;\n                }\n            }\n            else if (waitForChar === \"*/\" && currChar === \"*\" && currPos + 1 < block.length) {\n                block.charAt(currPos + 1) === \"/\" && (waitForChar = \"\");\n                if (waitForChar === \"\") {\n                    inComments = false;\n                    currPos++;\n                }\n            }\n            else {\n                if (!inComments) {\n                    s.push(currChar);\n                }\n            }\n        }\n        currPos++;\n    }\n    return s.join(\"\");\n}\n/**\n * Finds the first occurrence of a character in a string going backward\n * @param s the string to parse\n * @param index starting index in the string\n * @param c the character to find\n * @returns the index of the character if found, else -1\n */\nexport function FindBackward(s, index, c) {\n    while (index >= 0 && s.charAt(index) !== c) {\n        index--;\n    }\n    return index;\n}\n/**\n * Escapes a string so that it is usable as a regular expression\n * @param s string to escape\n * @returns escaped string\n */\nexport function EscapeRegExp(s) {\n    return s.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n}\n//# sourceMappingURL=codeStringParsingTools.js.map","import { EffectRenderer, EffectWrapper } from \"../Materials/effectRenderer.js\";\n\nimport \"../Shaders/copyTextureToTexture.fragment.js\";\n/**\n * Conversion modes available when copying a texture into another one\n */\nexport var ConversionMode;\n(function (ConversionMode) {\n    ConversionMode[ConversionMode[\"None\"] = 0] = \"None\";\n    ConversionMode[ConversionMode[\"ToLinearSpace\"] = 1] = \"ToLinearSpace\";\n    ConversionMode[ConversionMode[\"ToGammaSpace\"] = 2] = \"ToGammaSpace\";\n})(ConversionMode || (ConversionMode = {}));\n/**\n * Class used for fast copy from one texture to another\n */\nexport class CopyTextureToTexture {\n    _textureIsInternal(texture) {\n        return texture.getInternalTexture === undefined;\n    }\n    /**\n     * Constructs a new instance of the class\n     * @param engine The engine to use for the copy\n     * @param isDepthTexture True means that we should write (using gl_FragDepth) into the depth texture attached to the destination (default: false)\n     */\n    constructor(engine, isDepthTexture = false) {\n        this._engine = engine;\n        this._isDepthTexture = isDepthTexture;\n        this._renderer = new EffectRenderer(engine);\n        this._effectWrapper = new EffectWrapper({\n            engine: engine,\n            name: \"CopyTextureToTexture\",\n            fragmentShader: \"copyTextureToTexture\",\n            useShaderStore: true,\n            uniformNames: [\"conversion\"],\n            samplerNames: [\"textureSampler\"],\n            defines: isDepthTexture ? [\"#define DEPTH_TEXTURE\"] : [],\n        });\n        this._effectWrapper.onApplyObservable.add(() => {\n            if (isDepthTexture) {\n                engine.setState(false);\n                engine.setDepthBuffer(true);\n                engine.depthCullingState.depthMask = true;\n                engine.depthCullingState.depthFunc = 519;\n            }\n            if (this._textureIsInternal(this._source)) {\n                this._effectWrapper.effect._bindTexture(\"textureSampler\", this._source);\n            }\n            else {\n                this._effectWrapper.effect.setTexture(\"textureSampler\", this._source);\n            }\n            this._effectWrapper.effect.setFloat(\"conversion\", this._conversion);\n        });\n    }\n    /**\n     * Indicates if the effect is ready to be used for the copy\n     * @returns true if \"copy\" can be called without delay, else false\n     */\n    isReady() {\n        return this._effectWrapper.effect.isReady();\n    }\n    /**\n     * Copy one texture into another\n     * @param source The source texture\n     * @param destination The destination texture\n     * @param conversion The conversion mode that should be applied when copying\n     * @returns\n     */\n    copy(source, destination, conversion = ConversionMode.None) {\n        if (!this.isReady()) {\n            return false;\n        }\n        this._source = source;\n        this._conversion = conversion;\n        const engineDepthFunc = this._engine.depthCullingState.depthFunc;\n        this._renderer.render(this._effectWrapper, destination);\n        if (this._isDepthTexture && engineDepthFunc) {\n            this._engine.depthCullingState.depthFunc = engineDepthFunc;\n        }\n        return true;\n    }\n    /**\n     * Releases all the resources used by the class\n     */\n    dispose() {\n        this._effectWrapper.dispose();\n        this._renderer.dispose();\n    }\n}\n//# sourceMappingURL=copyTextureToTexture.js.map","/**\n * Transform some pixel data to a base64 string\n * @param pixels defines the pixel data to transform to base64\n * @param size defines the width and height of the (texture) data\n * @param invertY true if the data must be inverted for the Y coordinate during the conversion\n * @returns The base64 encoded string or null\n */\nexport function GenerateBase64StringFromPixelData(pixels, size, invertY = false) {\n    const width = size.width;\n    const height = size.height;\n    if (pixels instanceof Float32Array) {\n        let len = pixels.byteLength / pixels.BYTES_PER_ELEMENT;\n        const npixels = new Uint8Array(len);\n        while (--len >= 0) {\n            let val = pixels[len];\n            if (val < 0) {\n                val = 0;\n            }\n            else if (val > 1) {\n                val = 1;\n            }\n            npixels[len] = val * 255;\n        }\n        pixels = npixels;\n    }\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = width;\n    canvas.height = height;\n    const ctx = canvas.getContext(\"2d\");\n    if (!ctx) {\n        return null;\n    }\n    const imageData = ctx.createImageData(width, height);\n    const castData = imageData.data;\n    castData.set(pixels);\n    ctx.putImageData(imageData, 0, 0);\n    if (invertY) {\n        const canvas2 = document.createElement(\"canvas\");\n        canvas2.width = width;\n        canvas2.height = height;\n        const ctx2 = canvas2.getContext(\"2d\");\n        if (!ctx2) {\n            return null;\n        }\n        ctx2.translate(0, height);\n        ctx2.scale(1, -1);\n        ctx2.drawImage(canvas, 0, 0);\n        return canvas2.toDataURL(\"image/png\");\n    }\n    return canvas.toDataURL(\"image/png\");\n}\n/**\n * Reads the pixels stored in the webgl texture and returns them as a base64 string\n * @param texture defines the texture to read pixels from\n * @param faceIndex defines the face of the texture to read (in case of cube texture)\n * @param level defines the LOD level of the texture to read (in case of Mip Maps)\n * @returns The base64 encoded string or null\n */\nexport function GenerateBase64StringFromTexture(texture, faceIndex = 0, level = 0) {\n    const internalTexture = texture.getInternalTexture();\n    if (!internalTexture) {\n        return null;\n    }\n    const pixels = texture._readPixelsSync(faceIndex, level);\n    if (!pixels) {\n        return null;\n    }\n    return GenerateBase64StringFromPixelData(pixels, texture.getSize(), internalTexture.invertY);\n}\n/**\n * Reads the pixels stored in the webgl texture and returns them as a base64 string\n * @param texture defines the texture to read pixels from\n * @param faceIndex defines the face of the texture to read (in case of cube texture)\n * @param level defines the LOD level of the texture to read (in case of Mip Maps)\n * @returns The base64 encoded string or null wrapped in a promise\n */\nexport async function GenerateBase64StringFromTextureAsync(texture, faceIndex = 0, level = 0) {\n    const internalTexture = texture.getInternalTexture();\n    if (!internalTexture) {\n        return null;\n    }\n    const pixels = await texture.readPixels(faceIndex, level);\n    if (!pixels) {\n        return null;\n    }\n    return GenerateBase64StringFromPixelData(pixels, texture.getSize(), internalTexture.invertY);\n}\n/**\n * Class used to host copy specific utilities\n * (Back-compat)\n */\nexport const CopyTools = {\n    /**\n     * Transform some pixel data to a base64 string\n     * @param pixels defines the pixel data to transform to base64\n     * @param size defines the width and height of the (texture) data\n     * @param invertY true if the data must be inverted for the Y coordinate during the conversion\n     * @returns The base64 encoded string or null\n     */\n    GenerateBase64StringFromPixelData,\n    /**\n     * Reads the pixels stored in the webgl texture and returns them as a base64 string\n     * @param texture defines the texture to read pixels from\n     * @param faceIndex defines the face of the texture to read (in case of cube texture)\n     * @param level defines the LOD level of the texture to read (in case of Mip Maps)\n     * @returns The base64 encoded string or null\n     */\n    GenerateBase64StringFromTexture,\n    /**\n     * Reads the pixels stored in the webgl texture and returns them as a base64 string\n     * @param texture defines the texture to read pixels from\n     * @param faceIndex defines the face of the texture to read (in case of cube texture)\n     * @param level defines the LOD level of the texture to read (in case of Mip Maps)\n     * @returns The base64 encoded string or null wrapped in a promise\n     */\n    GenerateBase64StringFromTextureAsync,\n};\n//# sourceMappingURL=copyTools.js.map","/* eslint-disable @typescript-eslint/naming-convention */\n// \"Coroutines are computer program components that generalize subroutines for non-preemptive multitasking, by allowing execution to be suspended and resumed.\"\n// https://en.wikipedia.org/wiki/Coroutine\n// The inline scheduler simply steps the coroutine synchronously. This is useful for running a coroutine synchronously, and also as a helper function for other schedulers.\n/**\n * @internal\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport function inlineScheduler(coroutine, onStep, onError) {\n    try {\n        const step = coroutine.next();\n        if (step.done) {\n            onStep(step);\n        }\n        else if (!step.value) {\n            // NOTE: The properties of step have been narrowed, but the type of step itself is not narrowed, so the cast below is the most type safe way to deal with this without instantiating a new object to hold the values.\n            onStep(step);\n        }\n        else {\n            step.value.then(() => {\n                step.value = undefined;\n                onStep(step);\n            }, onError);\n        }\n    }\n    catch (error) {\n        onError(error);\n    }\n}\n// The yielding scheduler steps the coroutine synchronously until the specified time interval has elapsed, then yields control so other operations can be performed.\n// A single instance of a yielding scheduler could be shared across multiple coroutines to yield when their collective work exceeds the threshold.\n/**\n * @internal\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport function createYieldingScheduler(yieldAfterMS = 25) {\n    let startTime;\n    return (coroutine, onStep, onError) => {\n        const currentTime = performance.now();\n        if (startTime === undefined || currentTime - startTime > yieldAfterMS) {\n            // If this is the first coroutine step, or if the time interval has elapsed, record a new start time, and schedule the coroutine step to happen later, effectively yielding control of the execution context.\n            startTime = currentTime;\n            setTimeout(() => {\n                inlineScheduler(coroutine, onStep, onError);\n            }, 0);\n        }\n        else {\n            // Otherwise it is not time to yield yet, so step the coroutine synchronously.\n            inlineScheduler(coroutine, onStep, onError);\n        }\n    };\n}\n// Runs the specified coroutine with the specified scheduler. The success or error callback will be invoked when the coroutine finishes.\n/**\n * @internal\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport function runCoroutine(coroutine, scheduler, onSuccess, onError, abortSignal) {\n    const resume = () => {\n        let reschedule;\n        const onStep = (stepResult) => {\n            if (stepResult.done) {\n                // If the coroutine is done, report success.\n                onSuccess(stepResult.value);\n            }\n            else {\n                // If the coroutine is not done, resume the coroutine (via the scheduler).\n                if (reschedule === undefined) {\n                    // If reschedule is undefined at this point, then the coroutine must have stepped synchronously, so just flag another loop iteration.\n                    reschedule = true;\n                }\n                else {\n                    // If reschedule is defined at this point, then the coroutine must have stepped asynchronously, so call resume to restart the step loop.\n                    resume();\n                }\n            }\n        };\n        do {\n            reschedule = undefined;\n            if (!abortSignal || !abortSignal.aborted) {\n                scheduler(coroutine, onStep, onError);\n            }\n            else {\n                onError(new Error(\"Aborted\"));\n            }\n            if (reschedule === undefined) {\n                // If reschedule is undefined at this point, then the coroutine must have stepped asynchronously, so stop looping and let the coroutine be resumed later.\n                reschedule = false;\n            }\n        } while (reschedule);\n    };\n    resume();\n}\n// Runs the specified coroutine synchronously.\n/**\n * @internal\n */\nexport function runCoroutineSync(coroutine, abortSignal) {\n    // Run the coroutine with the inline scheduler, storing the returned value, or re-throwing the error (since the error callback will be called synchronously by the inline scheduler).\n    let result;\n    runCoroutine(coroutine, inlineScheduler, (r) => (result = r), (e) => {\n        throw e;\n    }, abortSignal);\n    // Synchronously return the result of the coroutine.\n    return result;\n}\n// Runs the specified coroutine asynchronously with the specified scheduler.\n/**\n * @internal\n */\nexport function runCoroutineAsync(coroutine, scheduler, abortSignal) {\n    // Run the coroutine with a yielding scheduler, resolving or rejecting the result promise when the coroutine finishes.\n    return new Promise((resolve, reject) => {\n        runCoroutine(coroutine, scheduler, resolve, reject, abortSignal);\n    });\n}\n/**\n * Given a function that returns a Coroutine<T>, produce a function with the same parameters that returns a T.\n * The returned function runs the coroutine synchronously.\n * @param coroutineFactory A function that returns a Coroutine<T>.\n * @param abortSignal\n * @returns A function that runs the coroutine synchronously.\n * @internal\n */\nexport function makeSyncFunction(coroutineFactory, abortSignal) {\n    return (...params) => {\n        // Run the coroutine synchronously.\n        return runCoroutineSync(coroutineFactory(...params), abortSignal);\n    };\n}\n/**\n * Given a function that returns a Coroutine<T>, product a function with the same parameters that returns a Promise<T>.\n * The returned function runs the coroutine asynchronously, yield control of the execution context occasionally to enable a more responsive experience.\n * @param coroutineFactory A function that returns a Coroutine<T>.\n * @param scheduler\n * @param abortSignal\n * @returns A function that runs the coroutine asynchronously.\n * @internal\n */\nexport function makeAsyncFunction(coroutineFactory, scheduler, abortSignal) {\n    return (...params) => {\n        // Run the coroutine asynchronously.\n        return runCoroutineAsync(coroutineFactory(...params), scheduler, abortSignal);\n    };\n}\n//# sourceMappingURL=coroutine.js.map","import { Decode } from \"./stringTools.js\";\n/**\n * Utility class for reading from a data buffer\n */\nexport class DataReader {\n    /**\n     * Constructor\n     * @param buffer The buffer to read\n     */\n    constructor(buffer) {\n        /**\n         * The current byte offset from the beginning of the data buffer.\n         */\n        this.byteOffset = 0;\n        this.buffer = buffer;\n    }\n    /**\n     * Loads the given byte length.\n     * @param byteLength The byte length to load\n     * @returns A promise that resolves when the load is complete\n     */\n    loadAsync(byteLength) {\n        return this.buffer.readAsync(this.byteOffset, byteLength).then((data) => {\n            this._dataView = new DataView(data.buffer, data.byteOffset, data.byteLength);\n            this._dataByteOffset = 0;\n        });\n    }\n    /**\n     * Read a unsigned 32-bit integer from the currently loaded data range.\n     * @returns The 32-bit integer read\n     */\n    readUint32() {\n        const value = this._dataView.getUint32(this._dataByteOffset, true);\n        this._dataByteOffset += 4;\n        this.byteOffset += 4;\n        return value;\n    }\n    /**\n     * Read a byte array from the currently loaded data range.\n     * @param byteLength The byte length to read\n     * @returns The byte array read\n     */\n    readUint8Array(byteLength) {\n        const value = new Uint8Array(this._dataView.buffer, this._dataView.byteOffset + this._dataByteOffset, byteLength);\n        this._dataByteOffset += byteLength;\n        this.byteOffset += byteLength;\n        return value;\n    }\n    /**\n     * Read a string from the currently loaded data range.\n     * @param byteLength The byte length to read\n     * @returns The string read\n     */\n    readString(byteLength) {\n        return Decode(this.readUint8Array(byteLength));\n    }\n    /**\n     * Skips the given byte length the currently loaded data range.\n     * @param byteLength The byte length to skip\n     */\n    skipBytes(byteLength) {\n        this._dataByteOffset += byteLength;\n        this.byteOffset += byteLength;\n    }\n}\n//# sourceMappingURL=dataReader.js.map","/* eslint-disable @typescript-eslint/naming-convention */\nimport { Scalar } from \"../Maths/math.scalar.js\";\nimport { SphericalPolynomial } from \"../Maths/sphericalPolynomial.js\";\n\nimport { InternalTexture, InternalTextureSource } from \"../Materials/Textures/internalTexture.js\";\nimport { Logger } from \"../Misc/logger.js\";\nimport { CubeMapToSphericalPolynomialTools } from \"../Misc/HighDynamicRange/cubemapToSphericalPolynomial.js\";\nimport { BaseTexture } from \"../Materials/Textures/baseTexture.js\";\nimport { ThinEngine } from \"../Engines/thinEngine.js\";\nimport { FromHalfFloat, ToHalfFloat } from \"./textureTools.js\";\nimport \"../Engines/Extensions/engine.cubeTexture.js\";\n// Based on demo done by Brandon Jones - http://media.tojicode.com/webgl-samples/dds.html\n// All values and structures referenced from:\n// http://msdn.microsoft.com/en-us/library/bb943991.aspx/\nconst DDS_MAGIC = 0x20534444;\nconst //DDSD_CAPS = 0x1,\n//DDSD_HEIGHT = 0x2,\n//DDSD_WIDTH = 0x4,\n//DDSD_PITCH = 0x8,\n//DDSD_PIXELFORMAT = 0x1000,\nDDSD_MIPMAPCOUNT = 0x20000;\n//DDSD_LINEARSIZE = 0x80000,\n//DDSD_DEPTH = 0x800000;\n// var DDSCAPS_COMPLEX = 0x8,\n//     DDSCAPS_MIPMAP = 0x400000,\n//     DDSCAPS_TEXTURE = 0x1000;\nconst DDSCAPS2_CUBEMAP = 0x200;\n// DDSCAPS2_CUBEMAP_POSITIVEX = 0x400,\n// DDSCAPS2_CUBEMAP_NEGATIVEX = 0x800,\n// DDSCAPS2_CUBEMAP_POSITIVEY = 0x1000,\n// DDSCAPS2_CUBEMAP_NEGATIVEY = 0x2000,\n// DDSCAPS2_CUBEMAP_POSITIVEZ = 0x4000,\n// DDSCAPS2_CUBEMAP_NEGATIVEZ = 0x8000,\n// DDSCAPS2_VOLUME = 0x200000;\nconst //DDPF_ALPHAPIXELS = 0x1,\n//DDPF_ALPHA = 0x2,\nDDPF_FOURCC = 0x4, DDPF_RGB = 0x40, \n//DDPF_YUV = 0x200,\nDDPF_LUMINANCE = 0x20000;\nfunction FourCCToInt32(value) {\n    return value.charCodeAt(0) + (value.charCodeAt(1) << 8) + (value.charCodeAt(2) << 16) + (value.charCodeAt(3) << 24);\n}\nfunction Int32ToFourCC(value) {\n    return String.fromCharCode(value & 0xff, (value >> 8) & 0xff, (value >> 16) & 0xff, (value >> 24) & 0xff);\n}\nconst FOURCC_DXT1 = FourCCToInt32(\"DXT1\");\nconst FOURCC_DXT3 = FourCCToInt32(\"DXT3\");\nconst FOURCC_DXT5 = FourCCToInt32(\"DXT5\");\nconst FOURCC_DX10 = FourCCToInt32(\"DX10\");\nconst FOURCC_D3DFMT_R16G16B16A16F = 113;\nconst FOURCC_D3DFMT_R32G32B32A32F = 116;\nconst DXGI_FORMAT_R32G32B32A32_FLOAT = 2;\nconst DXGI_FORMAT_R16G16B16A16_FLOAT = 10;\nconst DXGI_FORMAT_B8G8R8X8_UNORM = 88;\nconst headerLengthInt = 31; // The header length in 32 bit ints\n// Offsets into the header array\nconst off_magic = 0;\nconst off_size = 1;\nconst off_flags = 2;\nconst off_height = 3;\nconst off_width = 4;\nconst off_mipmapCount = 7;\nconst off_pfFlags = 20;\nconst off_pfFourCC = 21;\nconst off_RGBbpp = 22;\nconst off_RMask = 23;\nconst off_GMask = 24;\nconst off_BMask = 25;\nconst off_AMask = 26;\n// var off_caps1 = 27;\nconst off_caps2 = 28;\n// var off_caps3 = 29;\n// var off_caps4 = 30;\nconst off_dxgiFormat = 32;\n/**\n * Class used to provide DDS decompression tools\n */\nexport class DDSTools {\n    /**\n     * Gets DDS information from an array buffer\n     * @param data defines the array buffer view to read data from\n     * @returns the DDS information\n     */\n    static GetDDSInfo(data) {\n        const header = new Int32Array(data.buffer, data.byteOffset, headerLengthInt);\n        const extendedHeader = new Int32Array(data.buffer, data.byteOffset, headerLengthInt + 4);\n        let mipmapCount = 1;\n        if (header[off_flags] & DDSD_MIPMAPCOUNT) {\n            mipmapCount = Math.max(1, header[off_mipmapCount]);\n        }\n        const fourCC = header[off_pfFourCC];\n        const dxgiFormat = fourCC === FOURCC_DX10 ? extendedHeader[off_dxgiFormat] : 0;\n        let textureType = 0;\n        switch (fourCC) {\n            case FOURCC_D3DFMT_R16G16B16A16F:\n                textureType = 2;\n                break;\n            case FOURCC_D3DFMT_R32G32B32A32F:\n                textureType = 1;\n                break;\n            case FOURCC_DX10:\n                if (dxgiFormat === DXGI_FORMAT_R16G16B16A16_FLOAT) {\n                    textureType = 2;\n                    break;\n                }\n                if (dxgiFormat === DXGI_FORMAT_R32G32B32A32_FLOAT) {\n                    textureType = 1;\n                    break;\n                }\n        }\n        return {\n            width: header[off_width],\n            height: header[off_height],\n            mipmapCount: mipmapCount,\n            isFourCC: (header[off_pfFlags] & DDPF_FOURCC) === DDPF_FOURCC,\n            isRGB: (header[off_pfFlags] & DDPF_RGB) === DDPF_RGB,\n            isLuminance: (header[off_pfFlags] & DDPF_LUMINANCE) === DDPF_LUMINANCE,\n            isCube: (header[off_caps2] & DDSCAPS2_CUBEMAP) === DDSCAPS2_CUBEMAP,\n            isCompressed: fourCC === FOURCC_DXT1 || fourCC === FOURCC_DXT3 || fourCC === FOURCC_DXT5,\n            dxgiFormat: dxgiFormat,\n            textureType: textureType,\n        };\n    }\n    static _GetHalfFloatAsFloatRGBAArrayBuffer(width, height, dataOffset, dataLength, arrayBuffer, lod) {\n        const destArray = new Float32Array(dataLength);\n        const srcData = new Uint16Array(arrayBuffer, dataOffset);\n        let index = 0;\n        for (let y = 0; y < height; y++) {\n            for (let x = 0; x < width; x++) {\n                const srcPos = (x + y * width) * 4;\n                destArray[index] = FromHalfFloat(srcData[srcPos]);\n                destArray[index + 1] = FromHalfFloat(srcData[srcPos + 1]);\n                destArray[index + 2] = FromHalfFloat(srcData[srcPos + 2]);\n                if (DDSTools.StoreLODInAlphaChannel) {\n                    destArray[index + 3] = lod;\n                }\n                else {\n                    destArray[index + 3] = FromHalfFloat(srcData[srcPos + 3]);\n                }\n                index += 4;\n            }\n        }\n        return destArray;\n    }\n    static _GetHalfFloatRGBAArrayBuffer(width, height, dataOffset, dataLength, arrayBuffer, lod) {\n        if (DDSTools.StoreLODInAlphaChannel) {\n            const destArray = new Uint16Array(dataLength);\n            const srcData = new Uint16Array(arrayBuffer, dataOffset);\n            let index = 0;\n            for (let y = 0; y < height; y++) {\n                for (let x = 0; x < width; x++) {\n                    const srcPos = (x + y * width) * 4;\n                    destArray[index] = srcData[srcPos];\n                    destArray[index + 1] = srcData[srcPos + 1];\n                    destArray[index + 2] = srcData[srcPos + 2];\n                    destArray[index + 3] = ToHalfFloat(lod);\n                    index += 4;\n                }\n            }\n            return destArray;\n        }\n        return new Uint16Array(arrayBuffer, dataOffset, dataLength);\n    }\n    static _GetFloatRGBAArrayBuffer(width, height, dataOffset, dataLength, arrayBuffer, lod) {\n        if (DDSTools.StoreLODInAlphaChannel) {\n            const destArray = new Float32Array(dataLength);\n            const srcData = new Float32Array(arrayBuffer, dataOffset);\n            let index = 0;\n            for (let y = 0; y < height; y++) {\n                for (let x = 0; x < width; x++) {\n                    const srcPos = (x + y * width) * 4;\n                    destArray[index] = srcData[srcPos];\n                    destArray[index + 1] = srcData[srcPos + 1];\n                    destArray[index + 2] = srcData[srcPos + 2];\n                    destArray[index + 3] = lod;\n                    index += 4;\n                }\n            }\n            return destArray;\n        }\n        return new Float32Array(arrayBuffer, dataOffset, dataLength);\n    }\n    static _GetFloatAsHalfFloatRGBAArrayBuffer(width, height, dataOffset, dataLength, arrayBuffer, lod) {\n        const destArray = new Uint16Array(dataLength);\n        const srcData = new Float32Array(arrayBuffer, dataOffset);\n        let index = 0;\n        for (let y = 0; y < height; y++) {\n            for (let x = 0; x < width; x++) {\n                destArray[index] = ToHalfFloat(srcData[index]);\n                destArray[index + 1] = ToHalfFloat(srcData[index + 1]);\n                destArray[index + 2] = ToHalfFloat(srcData[index + 2]);\n                if (DDSTools.StoreLODInAlphaChannel) {\n                    destArray[index + 3] = ToHalfFloat(lod);\n                }\n                else {\n                    destArray[index + 3] = ToHalfFloat(srcData[index + 3]);\n                }\n                index += 4;\n            }\n        }\n        return destArray;\n    }\n    static _GetFloatAsUIntRGBAArrayBuffer(width, height, dataOffset, dataLength, arrayBuffer, lod) {\n        const destArray = new Uint8Array(dataLength);\n        const srcData = new Float32Array(arrayBuffer, dataOffset);\n        let index = 0;\n        for (let y = 0; y < height; y++) {\n            for (let x = 0; x < width; x++) {\n                const srcPos = (x + y * width) * 4;\n                destArray[index] = Scalar.Clamp(srcData[srcPos]) * 255;\n                destArray[index + 1] = Scalar.Clamp(srcData[srcPos + 1]) * 255;\n                destArray[index + 2] = Scalar.Clamp(srcData[srcPos + 2]) * 255;\n                if (DDSTools.StoreLODInAlphaChannel) {\n                    destArray[index + 3] = lod;\n                }\n                else {\n                    destArray[index + 3] = Scalar.Clamp(srcData[srcPos + 3]) * 255;\n                }\n                index += 4;\n            }\n        }\n        return destArray;\n    }\n    static _GetHalfFloatAsUIntRGBAArrayBuffer(width, height, dataOffset, dataLength, arrayBuffer, lod) {\n        const destArray = new Uint8Array(dataLength);\n        const srcData = new Uint16Array(arrayBuffer, dataOffset);\n        let index = 0;\n        for (let y = 0; y < height; y++) {\n            for (let x = 0; x < width; x++) {\n                const srcPos = (x + y * width) * 4;\n                destArray[index] = Scalar.Clamp(FromHalfFloat(srcData[srcPos])) * 255;\n                destArray[index + 1] = Scalar.Clamp(FromHalfFloat(srcData[srcPos + 1])) * 255;\n                destArray[index + 2] = Scalar.Clamp(FromHalfFloat(srcData[srcPos + 2])) * 255;\n                if (DDSTools.StoreLODInAlphaChannel) {\n                    destArray[index + 3] = lod;\n                }\n                else {\n                    destArray[index + 3] = Scalar.Clamp(FromHalfFloat(srcData[srcPos + 3])) * 255;\n                }\n                index += 4;\n            }\n        }\n        return destArray;\n    }\n    static _GetRGBAArrayBuffer(width, height, dataOffset, dataLength, arrayBuffer, rOffset, gOffset, bOffset, aOffset) {\n        const byteArray = new Uint8Array(dataLength);\n        const srcData = new Uint8Array(arrayBuffer, dataOffset);\n        let index = 0;\n        for (let y = 0; y < height; y++) {\n            for (let x = 0; x < width; x++) {\n                const srcPos = (x + y * width) * 4;\n                byteArray[index] = srcData[srcPos + rOffset];\n                byteArray[index + 1] = srcData[srcPos + gOffset];\n                byteArray[index + 2] = srcData[srcPos + bOffset];\n                byteArray[index + 3] = srcData[srcPos + aOffset];\n                index += 4;\n            }\n        }\n        return byteArray;\n    }\n    static _ExtractLongWordOrder(value) {\n        if (value === 0 || value === 255 || value === -16777216) {\n            return 0;\n        }\n        return 1 + DDSTools._ExtractLongWordOrder(value >> 8);\n    }\n    static _GetRGBArrayBuffer(width, height, dataOffset, dataLength, arrayBuffer, rOffset, gOffset, bOffset) {\n        const byteArray = new Uint8Array(dataLength);\n        const srcData = new Uint8Array(arrayBuffer, dataOffset);\n        let index = 0;\n        for (let y = 0; y < height; y++) {\n            for (let x = 0; x < width; x++) {\n                const srcPos = (x + y * width) * 3;\n                byteArray[index] = srcData[srcPos + rOffset];\n                byteArray[index + 1] = srcData[srcPos + gOffset];\n                byteArray[index + 2] = srcData[srcPos + bOffset];\n                index += 3;\n            }\n        }\n        return byteArray;\n    }\n    static _GetLuminanceArrayBuffer(width, height, dataOffset, dataLength, arrayBuffer) {\n        const byteArray = new Uint8Array(dataLength);\n        const srcData = new Uint8Array(arrayBuffer, dataOffset);\n        let index = 0;\n        for (let y = 0; y < height; y++) {\n            for (let x = 0; x < width; x++) {\n                const srcPos = x + y * width;\n                byteArray[index] = srcData[srcPos];\n                index++;\n            }\n        }\n        return byteArray;\n    }\n    /**\n     * Uploads DDS Levels to a Babylon Texture\n     * @internal\n     */\n    static UploadDDSLevels(engine, texture, data, info, loadMipmaps, faces, lodIndex = -1, currentFace, destTypeMustBeFilterable = true) {\n        let sphericalPolynomialFaces = null;\n        if (info.sphericalPolynomial) {\n            sphericalPolynomialFaces = new Array();\n        }\n        const ext = !!engine.getCaps().s3tc;\n        // TODO WEBGPU Once generateMipMaps is split into generateMipMaps + hasMipMaps in InternalTexture this line can be removed\n        texture.generateMipMaps = loadMipmaps;\n        const header = new Int32Array(data.buffer, data.byteOffset, headerLengthInt);\n        let fourCC, width, height, dataLength = 0, dataOffset;\n        let byteArray, mipmapCount, mip;\n        let internalCompressedFormat = 0;\n        let blockBytes = 1;\n        if (header[off_magic] !== DDS_MAGIC) {\n            Logger.Error(\"Invalid magic number in DDS header\");\n            return;\n        }\n        if (!info.isFourCC && !info.isRGB && !info.isLuminance) {\n            Logger.Error(\"Unsupported format, must contain a FourCC, RGB or LUMINANCE code\");\n            return;\n        }\n        if (info.isCompressed && !ext) {\n            Logger.Error(\"Compressed textures are not supported on this platform.\");\n            return;\n        }\n        let bpp = header[off_RGBbpp];\n        dataOffset = header[off_size] + 4;\n        let computeFormats = false;\n        if (info.isFourCC) {\n            fourCC = header[off_pfFourCC];\n            switch (fourCC) {\n                case FOURCC_DXT1:\n                    blockBytes = 8;\n                    internalCompressedFormat = 33777;\n                    break;\n                case FOURCC_DXT3:\n                    blockBytes = 16;\n                    internalCompressedFormat = 33778;\n                    break;\n                case FOURCC_DXT5:\n                    blockBytes = 16;\n                    internalCompressedFormat = 33779;\n                    break;\n                case FOURCC_D3DFMT_R16G16B16A16F:\n                    computeFormats = true;\n                    bpp = 64;\n                    break;\n                case FOURCC_D3DFMT_R32G32B32A32F:\n                    computeFormats = true;\n                    bpp = 128;\n                    break;\n                case FOURCC_DX10: {\n                    // There is an additionnal header so dataOffset need to be changed\n                    dataOffset += 5 * 4; // 5 uints\n                    let supported = false;\n                    switch (info.dxgiFormat) {\n                        case DXGI_FORMAT_R16G16B16A16_FLOAT:\n                            computeFormats = true;\n                            bpp = 64;\n                            supported = true;\n                            break;\n                        case DXGI_FORMAT_R32G32B32A32_FLOAT:\n                            computeFormats = true;\n                            bpp = 128;\n                            supported = true;\n                            break;\n                        case DXGI_FORMAT_B8G8R8X8_UNORM:\n                            info.isRGB = true;\n                            info.isFourCC = false;\n                            bpp = 32;\n                            supported = true;\n                            break;\n                    }\n                    if (supported) {\n                        break;\n                    }\n                }\n                // eslint-disable-next-line no-fallthrough\n                default:\n                    console.error(\"Unsupported FourCC code:\", Int32ToFourCC(fourCC));\n                    return;\n            }\n        }\n        const rOffset = DDSTools._ExtractLongWordOrder(header[off_RMask]);\n        const gOffset = DDSTools._ExtractLongWordOrder(header[off_GMask]);\n        const bOffset = DDSTools._ExtractLongWordOrder(header[off_BMask]);\n        const aOffset = DDSTools._ExtractLongWordOrder(header[off_AMask]);\n        if (computeFormats) {\n            internalCompressedFormat = engine._getRGBABufferInternalSizedFormat(info.textureType);\n        }\n        mipmapCount = 1;\n        if (header[off_flags] & DDSD_MIPMAPCOUNT && loadMipmaps !== false) {\n            mipmapCount = Math.max(1, header[off_mipmapCount]);\n        }\n        const startFace = currentFace || 0;\n        const caps = engine.getCaps();\n        for (let face = startFace; face < faces; face++) {\n            width = header[off_width];\n            height = header[off_height];\n            for (mip = 0; mip < mipmapCount; ++mip) {\n                if (lodIndex === -1 || lodIndex === mip) {\n                    // In case of fixed LOD, if the lod has just been uploaded, early exit.\n                    const i = lodIndex === -1 ? mip : 0;\n                    if (!info.isCompressed && info.isFourCC) {\n                        texture.format = 5;\n                        dataLength = width * height * 4;\n                        let floatArray = null;\n                        if (engine._badOS || engine._badDesktopOS || (!caps.textureHalfFloat && !caps.textureFloat)) {\n                            // Required because iOS has many issues with float and half float generation\n                            if (bpp === 128) {\n                                floatArray = DDSTools._GetFloatAsUIntRGBAArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, i);\n                                if (sphericalPolynomialFaces && i == 0) {\n                                    sphericalPolynomialFaces.push(DDSTools._GetFloatRGBAArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, i));\n                                }\n                            }\n                            else if (bpp === 64) {\n                                floatArray = DDSTools._GetHalfFloatAsUIntRGBAArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, i);\n                                if (sphericalPolynomialFaces && i == 0) {\n                                    sphericalPolynomialFaces.push(DDSTools._GetHalfFloatAsFloatRGBAArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, i));\n                                }\n                            }\n                            texture.type = 0;\n                        }\n                        else {\n                            const floatAvailable = caps.textureFloat && ((destTypeMustBeFilterable && caps.textureFloatLinearFiltering) || !destTypeMustBeFilterable);\n                            const halfFloatAvailable = caps.textureHalfFloat && ((destTypeMustBeFilterable && caps.textureHalfFloatLinearFiltering) || !destTypeMustBeFilterable);\n                            const destType = (bpp === 128 || (bpp === 64 && !halfFloatAvailable)) && floatAvailable\n                                ? 1\n                                : (bpp === 64 || (bpp === 128 && !floatAvailable)) && halfFloatAvailable\n                                    ? 2\n                                    : 0;\n                            let dataGetter;\n                            let dataGetterPolynomial = null;\n                            switch (bpp) {\n                                case 128: {\n                                    switch (destType) {\n                                        case 1:\n                                            dataGetter = DDSTools._GetFloatRGBAArrayBuffer;\n                                            dataGetterPolynomial = null;\n                                            break;\n                                        case 2:\n                                            dataGetter = DDSTools._GetFloatAsHalfFloatRGBAArrayBuffer;\n                                            dataGetterPolynomial = DDSTools._GetFloatRGBAArrayBuffer;\n                                            break;\n                                        case 0:\n                                            dataGetter = DDSTools._GetFloatAsUIntRGBAArrayBuffer;\n                                            dataGetterPolynomial = DDSTools._GetFloatRGBAArrayBuffer;\n                                            break;\n                                    }\n                                    break;\n                                }\n                                default: {\n                                    // 64 bpp\n                                    switch (destType) {\n                                        case 1:\n                                            dataGetter = DDSTools._GetHalfFloatAsFloatRGBAArrayBuffer;\n                                            dataGetterPolynomial = null;\n                                            break;\n                                        case 2:\n                                            dataGetter = DDSTools._GetHalfFloatRGBAArrayBuffer;\n                                            dataGetterPolynomial = DDSTools._GetHalfFloatAsFloatRGBAArrayBuffer;\n                                            break;\n                                        case 0:\n                                            dataGetter = DDSTools._GetHalfFloatAsUIntRGBAArrayBuffer;\n                                            dataGetterPolynomial = DDSTools._GetHalfFloatAsFloatRGBAArrayBuffer;\n                                            break;\n                                    }\n                                    break;\n                                }\n                            }\n                            texture.type = destType;\n                            floatArray = dataGetter(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, i);\n                            if (sphericalPolynomialFaces && i == 0) {\n                                sphericalPolynomialFaces.push(dataGetterPolynomial ? dataGetterPolynomial(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, i) : floatArray);\n                            }\n                        }\n                        if (floatArray) {\n                            engine._uploadDataToTextureDirectly(texture, floatArray, face, i);\n                        }\n                    }\n                    else if (info.isRGB) {\n                        texture.type = 0;\n                        if (bpp === 24) {\n                            texture.format = 4;\n                            dataLength = width * height * 3;\n                            byteArray = DDSTools._GetRGBArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, rOffset, gOffset, bOffset);\n                            engine._uploadDataToTextureDirectly(texture, byteArray, face, i);\n                        }\n                        else {\n                            // 32\n                            texture.format = 5;\n                            dataLength = width * height * 4;\n                            byteArray = DDSTools._GetRGBAArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, rOffset, gOffset, bOffset, aOffset);\n                            engine._uploadDataToTextureDirectly(texture, byteArray, face, i);\n                        }\n                    }\n                    else if (info.isLuminance) {\n                        const unpackAlignment = engine._getUnpackAlignement();\n                        const unpaddedRowSize = width;\n                        const paddedRowSize = Math.floor((width + unpackAlignment - 1) / unpackAlignment) * unpackAlignment;\n                        dataLength = paddedRowSize * (height - 1) + unpaddedRowSize;\n                        byteArray = DDSTools._GetLuminanceArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer);\n                        texture.format = 1;\n                        texture.type = 0;\n                        engine._uploadDataToTextureDirectly(texture, byteArray, face, i);\n                    }\n                    else {\n                        dataLength = (((Math.max(4, width) / 4) * Math.max(4, height)) / 4) * blockBytes;\n                        byteArray = new Uint8Array(data.buffer, data.byteOffset + dataOffset, dataLength);\n                        texture.type = 0;\n                        engine._uploadCompressedDataToTextureDirectly(texture, internalCompressedFormat, width, height, byteArray, face, i);\n                    }\n                }\n                dataOffset += bpp ? width * height * (bpp / 8) : dataLength;\n                width *= 0.5;\n                height *= 0.5;\n                width = Math.max(1.0, width);\n                height = Math.max(1.0, height);\n            }\n            if (currentFace !== undefined) {\n                // Loading a single face\n                break;\n            }\n        }\n        if (sphericalPolynomialFaces && sphericalPolynomialFaces.length > 0) {\n            info.sphericalPolynomial = CubeMapToSphericalPolynomialTools.ConvertCubeMapToSphericalPolynomial({\n                size: header[off_width],\n                right: sphericalPolynomialFaces[0],\n                left: sphericalPolynomialFaces[1],\n                up: sphericalPolynomialFaces[2],\n                down: sphericalPolynomialFaces[3],\n                front: sphericalPolynomialFaces[4],\n                back: sphericalPolynomialFaces[5],\n                format: 5,\n                type: 1,\n                gammaSpace: false,\n            });\n        }\n        else {\n            info.sphericalPolynomial = undefined;\n        }\n    }\n}\n/**\n * Gets or sets a boolean indicating that LOD info is stored in alpha channel (false by default)\n */\nDDSTools.StoreLODInAlphaChannel = false;\n/**\n * Create a cube texture from prefiltered data (ie. the mipmaps contain ready to use data for PBR reflection)\n * @param rootUrl defines the url where the file to load is located\n * @param scene defines the current scene\n * @param lodScale defines scale to apply to the mip map selection\n * @param lodOffset defines offset to apply to the mip map selection\n * @param onLoad defines an optional callback raised when the texture is loaded\n * @param onError defines an optional callback raised if there is an issue to load the texture\n * @param format defines the format of the data\n * @param forcedExtension defines the extension to use to pick the right loader\n * @param createPolynomials defines wheter or not to create polynomails harmonics for the texture\n * @returns the cube texture as an InternalTexture\n */\nThinEngine.prototype.createPrefilteredCubeTexture = function (rootUrl, scene, lodScale, lodOffset, onLoad = null, onError = null, format, forcedExtension = null, createPolynomials = true) {\n    const callback = (loadData) => {\n        if (!loadData) {\n            if (onLoad) {\n                onLoad(null);\n            }\n            return;\n        }\n        const texture = loadData.texture;\n        if (!createPolynomials) {\n            texture._sphericalPolynomial = new SphericalPolynomial();\n        }\n        else if (loadData.info.sphericalPolynomial) {\n            texture._sphericalPolynomial = loadData.info.sphericalPolynomial;\n        }\n        texture._source = InternalTextureSource.CubePrefiltered;\n        if (this.getCaps().textureLOD) {\n            // Do not add extra process if texture lod is supported.\n            if (onLoad) {\n                onLoad(texture);\n            }\n            return;\n        }\n        const mipSlices = 3;\n        const gl = this._gl;\n        const width = loadData.width;\n        if (!width) {\n            return;\n        }\n        const textures = [];\n        for (let i = 0; i < mipSlices; i++) {\n            //compute LOD from even spacing in smoothness (matching shader calculation)\n            const smoothness = i / (mipSlices - 1);\n            const roughness = 1 - smoothness;\n            const minLODIndex = lodOffset; // roughness = 0\n            const maxLODIndex = Scalar.Log2(width) * lodScale + lodOffset; // roughness = 1\n            const lodIndex = minLODIndex + (maxLODIndex - minLODIndex) * roughness;\n            const mipmapIndex = Math.round(Math.min(Math.max(lodIndex, 0), maxLODIndex));\n            const glTextureFromLod = new InternalTexture(this, InternalTextureSource.Temp);\n            glTextureFromLod.type = texture.type;\n            glTextureFromLod.format = texture.format;\n            glTextureFromLod.width = Math.pow(2, Math.max(Scalar.Log2(width) - mipmapIndex, 0));\n            glTextureFromLod.height = glTextureFromLod.width;\n            glTextureFromLod.isCube = true;\n            glTextureFromLod._cachedWrapU = 0;\n            glTextureFromLod._cachedWrapV = 0;\n            this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, glTextureFromLod, true);\n            glTextureFromLod.samplingMode = 2;\n            gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n            gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n            gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n            gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n            if (loadData.isDDS) {\n                const info = loadData.info;\n                const data = loadData.data;\n                this._unpackFlipY(info.isCompressed);\n                DDSTools.UploadDDSLevels(this, glTextureFromLod, data, info, true, 6, mipmapIndex);\n            }\n            else {\n                Logger.Warn(\"DDS is the only prefiltered cube map supported so far.\");\n            }\n            this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, null);\n            // Wrap in a base texture for easy binding.\n            const lodTexture = new BaseTexture(scene);\n            lodTexture._isCube = true;\n            lodTexture._texture = glTextureFromLod;\n            glTextureFromLod.isReady = true;\n            textures.push(lodTexture);\n        }\n        texture._lodTextureHigh = textures[2];\n        texture._lodTextureMid = textures[1];\n        texture._lodTextureLow = textures[0];\n        if (onLoad) {\n            onLoad(texture);\n        }\n    };\n    return this.createCubeTexture(rootUrl, scene, null, false, callback, onError, format, forcedExtension, createPolynomials, lodScale, lodOffset);\n};\n//# sourceMappingURL=dds.js.map","/* eslint-disable @typescript-eslint/no-unused-vars */\n/* eslint-disable @typescript-eslint/naming-convention */\nimport { Tags } from \"../Misc/tags.js\";\nimport { Quaternion, Vector2, Vector3, Matrix } from \"../Maths/math.vector.js\";\nimport { _WarnImport } from \"./devTools.js\";\nimport { Color4, Color3 } from \"../Maths/math.color.js\";\nconst __decoratorInitialStore = {};\nconst __mergedStore = {};\nconst _copySource = function (creationFunction, source, instanciate) {\n    const destination = creationFunction();\n    // Tags\n    if (Tags) {\n        Tags.AddTagsTo(destination, source.tags);\n    }\n    const classStore = getMergedStore(destination);\n    // Properties\n    for (const property in classStore) {\n        const propertyDescriptor = classStore[property];\n        const sourceProperty = source[property];\n        const propertyType = propertyDescriptor.type;\n        if (sourceProperty !== undefined && sourceProperty !== null && (property !== \"uniqueId\" || SerializationHelper.AllowLoadingUniqueId)) {\n            switch (propertyType) {\n                case 0: // Value\n                case 6: // Mesh reference\n                case 11: // Camera reference\n                    destination[property] = sourceProperty;\n                    break;\n                case 1: // Texture\n                    destination[property] = instanciate || sourceProperty.isRenderTarget ? sourceProperty : sourceProperty.clone();\n                    break;\n                case 2: // Color3\n                case 3: // FresnelParameters\n                case 4: // Vector2\n                case 5: // Vector3\n                case 7: // Color Curves\n                case 10: // Quaternion\n                case 12: // Matrix\n                    destination[property] = instanciate ? sourceProperty : sourceProperty.clone();\n                    break;\n            }\n        }\n    }\n    return destination;\n};\nfunction getDirectStore(target) {\n    const classKey = target.getClassName();\n    if (!__decoratorInitialStore[classKey]) {\n        __decoratorInitialStore[classKey] = {};\n    }\n    return __decoratorInitialStore[classKey];\n}\n/**\n * Return the list of properties flagged as serializable\n * @param target host object\n */\nfunction getMergedStore(target) {\n    const classKey = target.getClassName();\n    if (__mergedStore[classKey]) {\n        return __mergedStore[classKey];\n    }\n    __mergedStore[classKey] = {};\n    const store = __mergedStore[classKey];\n    let currentTarget = target;\n    let currentKey = classKey;\n    while (currentKey) {\n        const initialStore = __decoratorInitialStore[currentKey];\n        for (const property in initialStore) {\n            store[property] = initialStore[property];\n        }\n        let parent;\n        let done = false;\n        do {\n            parent = Object.getPrototypeOf(currentTarget);\n            if (!parent.getClassName) {\n                done = true;\n                break;\n            }\n            if (parent.getClassName() !== currentKey) {\n                break;\n            }\n            currentTarget = parent;\n        } while (parent);\n        if (done) {\n            break;\n        }\n        currentKey = parent.getClassName();\n        currentTarget = parent;\n    }\n    return store;\n}\nfunction generateSerializableMember(type, sourceName) {\n    return (target, propertyKey) => {\n        const classStore = getDirectStore(target);\n        if (!classStore[propertyKey]) {\n            classStore[propertyKey] = { type: type, sourceName: sourceName };\n        }\n    };\n}\nfunction generateExpandMember(setCallback, targetKey = null) {\n    return (target, propertyKey) => {\n        const key = targetKey || \"_\" + propertyKey;\n        Object.defineProperty(target, propertyKey, {\n            get: function () {\n                return this[key];\n            },\n            set: function (value) {\n                // does this object (i.e. vector3) has an equals function? use it!\n                // Note - not using \"with epsilon\" here, it is expected te behave like the internal cache does.\n                if (typeof this.equals === \"function\") {\n                    if (this.equals(value)) {\n                        return;\n                    }\n                }\n                if (this[key] === value) {\n                    return;\n                }\n                this[key] = value;\n                target[setCallback].apply(this);\n            },\n            enumerable: true,\n            configurable: true,\n        });\n    };\n}\nexport function expandToProperty(callback, targetKey = null) {\n    return generateExpandMember(callback, targetKey);\n}\nexport function serialize(sourceName) {\n    return generateSerializableMember(0, sourceName); // value member\n}\nexport function serializeAsTexture(sourceName) {\n    return generateSerializableMember(1, sourceName); // texture member\n}\nexport function serializeAsColor3(sourceName) {\n    return generateSerializableMember(2, sourceName); // color3 member\n}\nexport function serializeAsFresnelParameters(sourceName) {\n    return generateSerializableMember(3, sourceName); // fresnel parameters member\n}\nexport function serializeAsVector2(sourceName) {\n    return generateSerializableMember(4, sourceName); // vector2 member\n}\nexport function serializeAsVector3(sourceName) {\n    return generateSerializableMember(5, sourceName); // vector3 member\n}\nexport function serializeAsMeshReference(sourceName) {\n    return generateSerializableMember(6, sourceName); // mesh reference member\n}\nexport function serializeAsColorCurves(sourceName) {\n    return generateSerializableMember(7, sourceName); // color curves\n}\nexport function serializeAsColor4(sourceName) {\n    return generateSerializableMember(8, sourceName); // color 4\n}\nexport function serializeAsImageProcessingConfiguration(sourceName) {\n    return generateSerializableMember(9, sourceName); // image processing\n}\nexport function serializeAsQuaternion(sourceName) {\n    return generateSerializableMember(10, sourceName); // quaternion member\n}\nexport function serializeAsMatrix(sourceName) {\n    return generateSerializableMember(12, sourceName); // matrix member\n}\n/**\n * Decorator used to define property that can be serialized as reference to a camera\n * @param sourceName defines the name of the property to decorate\n */\nexport function serializeAsCameraReference(sourceName) {\n    return generateSerializableMember(11, sourceName); // camera reference member\n}\n/**\n * Class used to help serialization objects\n */\nexport class SerializationHelper {\n    /**\n     * Appends the serialized animations from the source animations\n     * @param source Source containing the animations\n     * @param destination Target to store the animations\n     */\n    static AppendSerializedAnimations(source, destination) {\n        if (source.animations) {\n            destination.animations = [];\n            for (let animationIndex = 0; animationIndex < source.animations.length; animationIndex++) {\n                const animation = source.animations[animationIndex];\n                destination.animations.push(animation.serialize());\n            }\n        }\n    }\n    /**\n     * Static function used to serialized a specific entity\n     * @param entity defines the entity to serialize\n     * @param serializationObject defines the optional target object where serialization data will be stored\n     * @returns a JSON compatible object representing the serialization of the entity\n     */\n    static Serialize(entity, serializationObject) {\n        if (!serializationObject) {\n            serializationObject = {};\n        }\n        // Tags\n        if (Tags) {\n            serializationObject.tags = Tags.GetTags(entity);\n        }\n        const serializedProperties = getMergedStore(entity);\n        // Properties\n        for (const property in serializedProperties) {\n            const propertyDescriptor = serializedProperties[property];\n            const targetPropertyName = propertyDescriptor.sourceName || property;\n            const propertyType = propertyDescriptor.type;\n            const sourceProperty = entity[property];\n            if (sourceProperty !== undefined && sourceProperty !== null && (property !== \"uniqueId\" || SerializationHelper.AllowLoadingUniqueId)) {\n                switch (propertyType) {\n                    case 0: // Value\n                        serializationObject[targetPropertyName] = sourceProperty;\n                        break;\n                    case 1: // Texture\n                        serializationObject[targetPropertyName] = sourceProperty.serialize();\n                        break;\n                    case 2: // Color3\n                        serializationObject[targetPropertyName] = sourceProperty.asArray();\n                        break;\n                    case 3: // FresnelParameters\n                        serializationObject[targetPropertyName] = sourceProperty.serialize();\n                        break;\n                    case 4: // Vector2\n                        serializationObject[targetPropertyName] = sourceProperty.asArray();\n                        break;\n                    case 5: // Vector3\n                        serializationObject[targetPropertyName] = sourceProperty.asArray();\n                        break;\n                    case 6: // Mesh reference\n                        serializationObject[targetPropertyName] = sourceProperty.id;\n                        break;\n                    case 7: // Color Curves\n                        serializationObject[targetPropertyName] = sourceProperty.serialize();\n                        break;\n                    case 8: // Color 4\n                        serializationObject[targetPropertyName] = sourceProperty.asArray();\n                        break;\n                    case 9: // Image Processing\n                        serializationObject[targetPropertyName] = sourceProperty.serialize();\n                        break;\n                    case 10: // Quaternion\n                        serializationObject[targetPropertyName] = sourceProperty.asArray();\n                        break;\n                    case 11: // Camera reference\n                        serializationObject[targetPropertyName] = sourceProperty.id;\n                        break;\n                    case 12: // Matrix\n                        serializationObject[targetPropertyName] = sourceProperty.asArray();\n                        break;\n                }\n            }\n        }\n        return serializationObject;\n    }\n    /**\n     * Creates a new entity from a serialization data object\n     * @param creationFunction defines a function used to instanciated the new entity\n     * @param source defines the source serialization data\n     * @param scene defines the hosting scene\n     * @param rootUrl defines the root url for resources\n     * @returns a new entity\n     */\n    static Parse(creationFunction, source, scene, rootUrl = null) {\n        const destination = creationFunction();\n        if (!rootUrl) {\n            rootUrl = \"\";\n        }\n        // Tags\n        if (Tags) {\n            Tags.AddTagsTo(destination, source.tags);\n        }\n        const classStore = getMergedStore(destination);\n        // Properties\n        for (const property in classStore) {\n            const propertyDescriptor = classStore[property];\n            const sourceProperty = source[propertyDescriptor.sourceName || property];\n            const propertyType = propertyDescriptor.type;\n            if (sourceProperty !== undefined && sourceProperty !== null && (property !== \"uniqueId\" || SerializationHelper.AllowLoadingUniqueId)) {\n                const dest = destination;\n                switch (propertyType) {\n                    case 0: // Value\n                        dest[property] = sourceProperty;\n                        break;\n                    case 1: // Texture\n                        if (scene) {\n                            dest[property] = SerializationHelper._TextureParser(sourceProperty, scene, rootUrl);\n                        }\n                        break;\n                    case 2: // Color3\n                        dest[property] = Color3.FromArray(sourceProperty);\n                        break;\n                    case 3: // FresnelParameters\n                        dest[property] = SerializationHelper._FresnelParametersParser(sourceProperty);\n                        break;\n                    case 4: // Vector2\n                        dest[property] = Vector2.FromArray(sourceProperty);\n                        break;\n                    case 5: // Vector3\n                        dest[property] = Vector3.FromArray(sourceProperty);\n                        break;\n                    case 6: // Mesh reference\n                        if (scene) {\n                            dest[property] = scene.getLastMeshById(sourceProperty);\n                        }\n                        break;\n                    case 7: // Color Curves\n                        dest[property] = SerializationHelper._ColorCurvesParser(sourceProperty);\n                        break;\n                    case 8: // Color 4\n                        dest[property] = Color4.FromArray(sourceProperty);\n                        break;\n                    case 9: // Image Processing\n                        dest[property] = SerializationHelper._ImageProcessingConfigurationParser(sourceProperty);\n                        break;\n                    case 10: // Quaternion\n                        dest[property] = Quaternion.FromArray(sourceProperty);\n                        break;\n                    case 11: // Camera reference\n                        if (scene) {\n                            dest[property] = scene.getCameraById(sourceProperty);\n                        }\n                        break;\n                    case 12: // Matrix\n                        dest[property] = Matrix.FromArray(sourceProperty);\n                        break;\n                }\n            }\n        }\n        return destination;\n    }\n    /**\n     * Clones an object\n     * @param creationFunction defines the function used to instanciate the new object\n     * @param source defines the source object\n     * @returns the cloned object\n     */\n    static Clone(creationFunction, source) {\n        return _copySource(creationFunction, source, false);\n    }\n    /**\n     * Instanciates a new object based on a source one (some data will be shared between both object)\n     * @param creationFunction defines the function used to instanciate the new object\n     * @param source defines the source object\n     * @returns the new object\n     */\n    static Instanciate(creationFunction, source) {\n        return _copySource(creationFunction, source, true);\n    }\n}\n/**\n * Gets or sets a boolean to indicate if the UniqueId property should be serialized\n */\nSerializationHelper.AllowLoadingUniqueId = false;\n/**\n * @internal\n */\nSerializationHelper._ImageProcessingConfigurationParser = (sourceProperty) => {\n    throw _WarnImport(\"ImageProcessingConfiguration\");\n};\n/**\n * @internal\n */\nSerializationHelper._FresnelParametersParser = (sourceProperty) => {\n    throw _WarnImport(\"FresnelParameters\");\n};\n/**\n * @internal\n */\nSerializationHelper._ColorCurvesParser = (sourceProperty) => {\n    throw _WarnImport(\"ColorCurves\");\n};\n/**\n * @internal\n */\nSerializationHelper._TextureParser = (sourceProperty, scene, rootUrl) => {\n    throw _WarnImport(\"Texture\");\n};\n/**\n * Decorator used to redirect a function to a native implementation if available.\n * @internal\n */\nexport function nativeOverride(target, propertyKey, descriptor, predicate) {\n    // Cache the original JS function for later.\n    const jsFunc = descriptor.value;\n    // Override the JS function to check for a native override on first invocation. Setting descriptor.value overrides the function at the early stage of code being loaded/imported.\n    descriptor.value = (...params) => {\n        // Assume the resolved function will be the original JS function, then we will check for the Babylon Native context.\n        let func = jsFunc;\n        // Check if we are executing in a Babylon Native context (e.g. check the presence of the _native global property) and if so also check if a function override is available.\n        if (typeof _native !== \"undefined\" && _native[propertyKey]) {\n            const nativeFunc = _native[propertyKey];\n            // If a predicate was provided, then we'll need to invoke the predicate on each invocation of the underlying function to determine whether to call the native function or the JS function.\n            if (predicate) {\n                // The resolved function will execute the predicate and then either execute the native function or the JS function.\n                func = (...params) => (predicate(...params) ? nativeFunc(...params) : jsFunc(...params));\n            }\n            else {\n                // The resolved function will directly execute the native function.\n                func = nativeFunc;\n            }\n        }\n        // Override the JS function again with the final resolved target function.\n        target[propertyKey] = func;\n        // The JS function has now been overridden based on whether we're executing in the context of Babylon Native, but we still need to invoke that function.\n        // Future invocations of the function will just directly invoke the final overridden function, not any of the decorator setup logic above.\n        return func(...params);\n    };\n}\n/**\n * Decorator factory that applies the nativeOverride decorator, but determines whether to redirect to the native implementation based on a filter function that evaluates the function arguments.\n * @param predicate\n * @example @nativeOverride.filter((...[arg1]: Parameters<typeof someClass.someMethod>) => arg1.length > 20)\n *          public someMethod(arg1: string, arg2: number): string {\n * @internal\n */\nnativeOverride.filter = function (predicate) {\n    return (target, propertyKey, descriptor) => nativeOverride(target, propertyKey, descriptor, predicate);\n};\n//# sourceMappingURL=decorators.js.map","import { Logger } from \"./logger.js\";\nconst CloneValue = (source, destinationObject) => {\n    if (!source) {\n        return null;\n    }\n    if (source.getClassName && source.getClassName() === \"Mesh\") {\n        return null;\n    }\n    if (source.getClassName && source.getClassName() === \"SubMesh\") {\n        return source.clone(destinationObject);\n    }\n    else if (source.clone) {\n        return source.clone();\n    }\n    return null;\n};\nfunction GetAllPropertyNames(obj) {\n    const props = [];\n    do {\n        Object.getOwnPropertyNames(obj).forEach(function (prop) {\n            if (props.indexOf(prop) === -1) {\n                props.push(prop);\n            }\n        });\n    } while ((obj = Object.getPrototypeOf(obj)));\n    return props;\n}\n/**\n * Class containing a set of static utilities functions for deep copy.\n */\nexport class DeepCopier {\n    /**\n     * Tries to copy an object by duplicating every property\n     * @param source defines the source object\n     * @param destination defines the target object\n     * @param doNotCopyList defines a list of properties to avoid\n     * @param mustCopyList defines a list of properties to copy (even if they start with _)\n     */\n    static DeepCopy(source, destination, doNotCopyList, mustCopyList) {\n        const properties = GetAllPropertyNames(source);\n        for (const prop of properties) {\n            if (prop[0] === \"_\" && (!mustCopyList || mustCopyList.indexOf(prop) === -1)) {\n                continue;\n            }\n            if (prop.endsWith(\"Observable\")) {\n                continue;\n            }\n            if (doNotCopyList && doNotCopyList.indexOf(prop) !== -1) {\n                continue;\n            }\n            const sourceValue = source[prop];\n            const typeOfSourceValue = typeof sourceValue;\n            if (typeOfSourceValue === \"function\") {\n                continue;\n            }\n            try {\n                if (typeOfSourceValue === \"object\") {\n                    if (sourceValue instanceof Array) {\n                        destination[prop] = [];\n                        if (sourceValue.length > 0) {\n                            if (typeof sourceValue[0] == \"object\") {\n                                for (let index = 0; index < sourceValue.length; index++) {\n                                    const clonedValue = CloneValue(sourceValue[index], destination);\n                                    if (destination[prop].indexOf(clonedValue) === -1) {\n                                        // Test if auto inject was not done\n                                        destination[prop].push(clonedValue);\n                                    }\n                                }\n                            }\n                            else {\n                                destination[prop] = sourceValue.slice(0);\n                            }\n                        }\n                    }\n                    else {\n                        destination[prop] = CloneValue(sourceValue, destination);\n                    }\n                }\n                else {\n                    destination[prop] = sourceValue;\n                }\n            }\n            catch (e) {\n                // Log a warning (it could be because of a read-only property)\n                Logger.Warn(e.message);\n            }\n        }\n    }\n}\n//# sourceMappingURL=deepCopier.js.map","/**\n * Wrapper class for promise with external resolve and reject.\n */\nexport class Deferred {\n    /**\n     * The resolve method of the promise associated with this deferred object.\n     */\n    get resolve() {\n        return this._resolve;\n    }\n    /**\n     * The reject method of the promise associated with this deferred object.\n     */\n    get reject() {\n        return this._reject;\n    }\n    /**\n     * Constructor for this deferred object.\n     */\n    constructor() {\n        this.promise = new Promise((resolve, reject) => {\n            this._resolve = resolve;\n            this._reject = reject;\n        });\n    }\n}\n//# sourceMappingURL=deferred.js.map","\nimport { DepthRenderer } from \"../Rendering/depthRenderer.js\";\nimport { MinMaxReducer } from \"./minMaxReducer.js\";\n/**\n * This class is a small wrapper around the MinMaxReducer class to compute the min/max values of a depth texture\n */\nexport class DepthReducer extends MinMaxReducer {\n    /**\n     * Gets the depth renderer used for the computation.\n     * Note that the result is null if you provide your own renderer when calling setDepthRenderer.\n     */\n    get depthRenderer() {\n        return this._depthRenderer;\n    }\n    /**\n     * Creates a depth reducer\n     * @param camera The camera used to render the depth texture\n     */\n    constructor(camera) {\n        super(camera);\n    }\n    /**\n     * Sets the depth renderer to use to generate the depth map\n     * @param depthRenderer The depth renderer to use. If not provided, a new one will be created automatically\n     * @param type The texture type of the depth map (default: TEXTURETYPE_HALF_FLOAT)\n     * @param forceFullscreenViewport Forces the post processes used for the reduction to be applied without taking into account viewport (defaults to true)\n     */\n    setDepthRenderer(depthRenderer = null, type = 2, forceFullscreenViewport = true) {\n        const scene = this._camera.getScene();\n        if (this._depthRenderer) {\n            delete scene._depthRenderer[this._depthRendererId];\n            this._depthRenderer.dispose();\n            this._depthRenderer = null;\n        }\n        if (depthRenderer === null) {\n            if (!scene._depthRenderer) {\n                scene._depthRenderer = {};\n            }\n            depthRenderer = this._depthRenderer = new DepthRenderer(scene, type, this._camera, false, 1);\n            depthRenderer.enabled = false;\n            this._depthRendererId = \"minmax\" + this._camera.id;\n            scene._depthRenderer[this._depthRendererId] = depthRenderer;\n        }\n        super.setSourceTexture(depthRenderer.getDepthMap(), true, type, forceFullscreenViewport);\n    }\n    /**\n     * @internal\n     */\n    setSourceTexture(sourceTexture, depthRedux, type = 2, forceFullscreenViewport = true) {\n        super.setSourceTexture(sourceTexture, depthRedux, type, forceFullscreenViewport);\n    }\n    /**\n     * Activates the reduction computation.\n     * When activated, the observers registered in onAfterReductionPerformed are\n     * called after the computation is performed\n     */\n    activate() {\n        if (this._depthRenderer) {\n            this._depthRenderer.enabled = true;\n        }\n        super.activate();\n    }\n    /**\n     * Deactivates the reduction computation.\n     */\n    deactivate() {\n        super.deactivate();\n        if (this._depthRenderer) {\n            this._depthRenderer.enabled = false;\n        }\n    }\n    /**\n     * Disposes the depth reducer\n     * @param disposeAll true to dispose all the resources. You should always call this function with true as the parameter (or without any parameter as it is the default one). This flag is meant to be used internally.\n     */\n    dispose(disposeAll = true) {\n        super.dispose(disposeAll);\n        if (this._depthRenderer && disposeAll) {\n            const scene = this._depthRenderer.getDepthMap().getScene();\n            if (scene) {\n                delete scene._depthRenderer[this._depthRendererId];\n            }\n            this._depthRenderer.dispose();\n            this._depthRenderer = null;\n        }\n    }\n}\n//# sourceMappingURL=depthReducer.js.map","/**\n * @internal\n */\nexport function _WarnImport(name) {\n    return `${name} needs to be imported before as it contains a side-effect required by your code.`;\n}\n//# sourceMappingURL=devTools.js.map","/* eslint-disable @typescript-eslint/naming-convention */\n/**\n * Checks if the window object exists\n * @returns true if the window object exists\n */\nexport function IsWindowObjectExist() {\n    return typeof window !== \"undefined\";\n}\n/**\n * Checks if the navigator object exists\n * @returns true if the navigator object exists\n */\nexport function IsNavigatorAvailable() {\n    return typeof navigator !== \"undefined\";\n}\n/**\n * Check if the document object exists\n * @returns true if the document object exists\n */\nexport function IsDocumentAvailable() {\n    return typeof document !== \"undefined\";\n}\n/**\n * Extracts text content from a DOM element hierarchy\n * @param element defines the root element\n * @returns a string\n */\nexport function GetDOMTextContent(element) {\n    let result = \"\";\n    let child = element.firstChild;\n    while (child) {\n        if (child.nodeType === 3) {\n            result += child.textContent;\n        }\n        child = child.nextSibling;\n    }\n    return result;\n}\n/**\n * Sets of helpers dealing with the DOM and some of the recurrent functions needed in\n * Babylon.js\n */\nexport const DomManagement = {\n    /**\n     * Checks if the window object exists\n     * @returns true if the window object exists\n     */\n    IsWindowObjectExist,\n    /**\n     * Checks if the navigator object exists\n     * @returns true if the navigator object exists\n     */\n    IsNavigatorAvailable,\n    /**\n     * Check if the document object exists\n     * @returns true if the document object exists\n     */\n    IsDocumentAvailable,\n    /**\n     * Extracts text content from a DOM element hierarchy\n     * @param element defines the root element\n     * @returns a string\n     */\n    GetDOMTextContent,\n};\n//# sourceMappingURL=domManagement.js.map","import { ThinEngine } from \"../Engines/thinEngine.js\";\n\nimport { EffectRenderer, EffectWrapper } from \"../Materials/effectRenderer.js\";\nimport { Tools } from \"./tools.js\";\nimport { passPixelShader } from \"../Shaders/pass.fragment.js\";\n/**\n * Class containing a set of static utilities functions to dump data from a canvas\n */\nexport class DumpTools {\n    static _CreateDumpRenderer() {\n        if (!DumpTools._DumpToolsEngine) {\n            const canvas = document.createElement(\"canvas\");\n            const engine = new ThinEngine(canvas, false, {\n                preserveDrawingBuffer: true,\n                depth: false,\n                stencil: false,\n                alpha: true,\n                premultipliedAlpha: false,\n                antialias: false,\n                failIfMajorPerformanceCaveat: false,\n            });\n            engine.getCaps().parallelShaderCompile = undefined;\n            const renderer = new EffectRenderer(engine);\n            const wrapper = new EffectWrapper({\n                engine,\n                name: passPixelShader.name,\n                fragmentShader: passPixelShader.shader,\n                samplerNames: [\"textureSampler\"],\n            });\n            DumpTools._DumpToolsEngine = {\n                canvas,\n                engine,\n                renderer,\n                wrapper,\n            };\n        }\n        return DumpTools._DumpToolsEngine;\n    }\n    /**\n     * Dumps the current bound framebuffer\n     * @param width defines the rendering width\n     * @param height defines the rendering height\n     * @param engine defines the hosting engine\n     * @param successCallback defines the callback triggered once the data are available\n     * @param mimeType defines the mime type of the result\n     * @param fileName defines the filename to download. If present, the result will automatically be downloaded\n     * @returns a void promise\n     */\n    static async DumpFramebuffer(width, height, engine, successCallback, mimeType = \"image/png\", fileName) {\n        // Read the contents of the framebuffer\n        const bufferView = await engine.readPixels(0, 0, width, height);\n        const data = new Uint8Array(bufferView.buffer);\n        DumpTools.DumpData(width, height, data, successCallback, mimeType, fileName, true);\n    }\n    /**\n     * Dumps an array buffer\n     * @param width defines the rendering width\n     * @param height defines the rendering height\n     * @param data the data array\n     * @param mimeType defines the mime type of the result\n     * @param fileName defines the filename to download. If present, the result will automatically be downloaded\n     * @param invertY true to invert the picture in the Y dimension\n     * @param toArrayBuffer true to convert the data to an ArrayBuffer (encoded as `mimeType`) instead of a base64 string\n     * @param quality defines the quality of the result\n     * @returns a promise that resolve to the final data\n     */\n    static DumpDataAsync(width, height, data, mimeType = \"image/png\", fileName, invertY = false, toArrayBuffer = false, quality) {\n        return new Promise((resolve) => {\n            DumpTools.DumpData(width, height, data, (result) => resolve(result), mimeType, fileName, invertY, toArrayBuffer, quality);\n        });\n    }\n    /**\n     * Dumps an array buffer\n     * @param width defines the rendering width\n     * @param height defines the rendering height\n     * @param data the data array\n     * @param successCallback defines the callback triggered once the data are available\n     * @param mimeType defines the mime type of the result\n     * @param fileName defines the filename to download. If present, the result will automatically be downloaded\n     * @param invertY true to invert the picture in the Y dimension\n     * @param toArrayBuffer true to convert the data to an ArrayBuffer (encoded as `mimeType`) instead of a base64 string\n     * @param quality defines the quality of the result\n     */\n    static DumpData(width, height, data, successCallback, mimeType = \"image/png\", fileName, invertY = false, toArrayBuffer = false, quality) {\n        const renderer = DumpTools._CreateDumpRenderer();\n        renderer.engine.setSize(width, height, true);\n        // Convert if data are float32\n        if (data instanceof Float32Array) {\n            const data2 = new Uint8Array(data.length);\n            let n = data.length;\n            while (n--) {\n                const v = data[n];\n                data2[n] = v < 0 ? 0 : v > 1 ? 1 : Math.round(v * 255);\n            }\n            data = data2;\n        }\n        // Create the image\n        const texture = renderer.engine.createRawTexture(data, width, height, 5, false, !invertY, 1);\n        renderer.renderer.setViewport();\n        renderer.renderer.applyEffectWrapper(renderer.wrapper);\n        renderer.wrapper.effect._bindTexture(\"textureSampler\", texture);\n        renderer.renderer.draw();\n        if (toArrayBuffer) {\n            Tools.ToBlob(renderer.canvas, (blob) => {\n                const fileReader = new FileReader();\n                fileReader.onload = (event) => {\n                    const arrayBuffer = event.target.result;\n                    if (successCallback) {\n                        successCallback(arrayBuffer);\n                    }\n                };\n                fileReader.readAsArrayBuffer(blob);\n            }, mimeType, quality);\n        }\n        else {\n            Tools.EncodeScreenshotCanvasData(renderer.canvas, successCallback, mimeType, fileName, quality);\n        }\n        texture.dispose();\n    }\n    /**\n     * Dispose the dump tools associated resources\n     */\n    static Dispose() {\n        if (DumpTools._DumpToolsEngine) {\n            DumpTools._DumpToolsEngine.wrapper.dispose();\n            DumpTools._DumpToolsEngine.renderer.dispose();\n            DumpTools._DumpToolsEngine.engine.dispose();\n        }\n        DumpTools._DumpToolsEngine = null;\n    }\n}\n/**\n * This will be executed automatically for UMD and es5.\n * If esm dev wants the side effects to execute they will have to run it manually\n * Once we build native modules those need to be exported.\n * @internal\n */\nconst initSideEffects = () => {\n    // References the dependencies.\n    Tools.DumpData = DumpTools.DumpData;\n    Tools.DumpDataAsync = DumpTools.DumpDataAsync;\n    Tools.DumpFramebuffer = DumpTools.DumpFramebuffer;\n};\ninitSideEffects();\n//# sourceMappingURL=dumpTools.js.map","import { Tools } from \"./tools.js\";\nimport { Vector3 } from \"../Maths/math.vector.js\";\nimport { Scalar } from \"../Maths/math.scalar.js\";\nimport { SphericalPolynomial } from \"../Maths/sphericalPolynomial.js\";\nimport { InternalTexture, InternalTextureSource } from \"../Materials/Textures/internalTexture.js\";\nimport { BaseTexture } from \"../Materials/Textures/baseTexture.js\";\n\nimport { Scene } from \"../scene.js\";\nimport { PostProcess } from \"../PostProcesses/postProcess.js\";\nimport { Logger } from \"../Misc/logger.js\";\nimport { RGBDTextureTools } from \"./rgbdTextureTools.js\";\nimport \"../Engines/Extensions/engine.renderTargetCube.js\";\nimport \"../Engines/Extensions/engine.readTexture.js\";\nimport \"../Materials/Textures/baseTexture.polynomial.js\";\nimport \"../Shaders/rgbdEncode.fragment.js\";\nimport \"../Shaders/rgbdDecode.fragment.js\";\nimport { DumpTools } from \"../Misc/dumpTools.js\";\nconst DefaultEnvironmentTextureImageType = \"image/png\";\nconst CurrentVersion = 2;\n/**\n * Magic number identifying the env file.\n */\nconst MagicBytes = [0x86, 0x16, 0x87, 0x96, 0xf6, 0xd6, 0x96, 0x36];\n/**\n * Gets the environment info from an env file.\n * @param data The array buffer containing the .env bytes.\n * @returns the environment file info (the json header) if successfully parsed, normalized to the latest supported version.\n */\nexport function GetEnvInfo(data) {\n    const dataView = new DataView(data.buffer, data.byteOffset, data.byteLength);\n    let pos = 0;\n    for (let i = 0; i < MagicBytes.length; i++) {\n        if (dataView.getUint8(pos++) !== MagicBytes[i]) {\n            Logger.Error(\"Not a babylon environment map\");\n            return null;\n        }\n    }\n    // Read json manifest - collect characters up to null terminator\n    let manifestString = \"\";\n    let charCode = 0x00;\n    while ((charCode = dataView.getUint8(pos++))) {\n        manifestString += String.fromCharCode(charCode);\n    }\n    let manifest = JSON.parse(manifestString);\n    manifest = normalizeEnvInfo(manifest);\n    if (manifest.specular) {\n        // Extend the header with the position of the payload.\n        manifest.specular.specularDataPosition = pos;\n        // Fallback to 0.8 exactly if lodGenerationScale is not defined for backward compatibility.\n        manifest.specular.lodGenerationScale = manifest.specular.lodGenerationScale || 0.8;\n    }\n    return manifest;\n}\n/**\n * Normalizes any supported version of the environment file info to the latest version\n * @param info environment file info on any supported version\n * @returns environment file info in the latest supported version\n * @private\n */\nexport function normalizeEnvInfo(info) {\n    if (info.version > CurrentVersion) {\n        throw new Error(`Unsupported babylon environment map version \"${info.version}\". Latest supported version is \"${CurrentVersion}\".`);\n    }\n    if (info.version === 2) {\n        return info;\n    }\n    // Migrate a v1 info to v2\n    info = { ...info, version: 2, imageType: DefaultEnvironmentTextureImageType };\n    return info;\n}\n/**\n * Creates an environment texture from a loaded cube texture.\n * @param texture defines the cube texture to convert in env file\n * @param options options for the conversion process\n * @param options.imageType the mime type for the encoded images, with support for \"image/png\" (default) and \"image/webp\"\n * @param options.imageQuality the image quality of encoded WebP images.\n * @returns a promise containing the environment data if successful.\n */\nexport async function CreateEnvTextureAsync(texture, options = {}) {\n    var _a;\n    const internalTexture = texture.getInternalTexture();\n    if (!internalTexture) {\n        return Promise.reject(\"The cube texture is invalid.\");\n    }\n    const imageType = (_a = options.imageType) !== null && _a !== void 0 ? _a : DefaultEnvironmentTextureImageType;\n    const engine = internalTexture.getEngine();\n    if (texture.textureType !== 2 &&\n        texture.textureType !== 1 &&\n        texture.textureType !== 0 &&\n        texture.textureType !== 0 &&\n        texture.textureType !== 7 &&\n        texture.textureType !== -1) {\n        return Promise.reject(\"The cube texture should allow HDR (Full Float or Half Float).\");\n    }\n    let textureType = 1;\n    if (!engine.getCaps().textureFloatRender) {\n        textureType = 2;\n        if (!engine.getCaps().textureHalfFloatRender) {\n            return Promise.reject(\"Env texture can only be created when the browser supports half float or full float rendering.\");\n        }\n    }\n    const cubeWidth = internalTexture.width;\n    const hostingScene = new Scene(engine);\n    const specularTextures = {};\n    // As we are going to readPixels the faces of the cube, make sure the drawing/update commands for the cube texture are fully sent to the GPU in case it is drawn for the first time in this very frame!\n    engine.flushFramebuffer();\n    // Read and collect all mipmaps data from the cube.\n    const mipmapsCount = Scalar.ILog2(internalTexture.width);\n    for (let i = 0; i <= mipmapsCount; i++) {\n        const faceWidth = Math.pow(2, mipmapsCount - i);\n        // All faces of the cube.\n        for (let face = 0; face < 6; face++) {\n            let faceData = await texture.readPixels(face, i, undefined, false);\n            if (faceData && faceData.byteLength === faceData.length) {\n                const faceDataFloat = new Float32Array(faceData.byteLength * 4);\n                for (let i = 0; i < faceData.byteLength; i++) {\n                    faceDataFloat[i] = faceData[i] / 255;\n                    // Gamma to linear\n                    faceDataFloat[i] = Math.pow(faceDataFloat[i], 2.2);\n                }\n                faceData = faceDataFloat;\n            }\n            const tempTexture = engine.createRawTexture(faceData, faceWidth, faceWidth, 5, false, true, 1, null, textureType);\n            await RGBDTextureTools.EncodeTextureToRGBD(tempTexture, hostingScene, textureType);\n            const rgbdEncodedData = await engine._readTexturePixels(tempTexture, faceWidth, faceWidth);\n            const imageEncodedData = await DumpTools.DumpDataAsync(faceWidth, faceWidth, rgbdEncodedData, imageType, undefined, false, true, options.imageQuality);\n            specularTextures[i * 6 + face] = imageEncodedData;\n            tempTexture.dispose();\n        }\n    }\n    // We can delete the hosting scene keeping track of all the creation objects\n    hostingScene.dispose();\n    // Creates the json header for the env texture\n    const info = {\n        version: CurrentVersion,\n        width: cubeWidth,\n        imageType,\n        irradiance: _CreateEnvTextureIrradiance(texture),\n        specular: {\n            mipmaps: [],\n            lodGenerationScale: texture.lodGenerationScale,\n        },\n    };\n    // Sets the specular image data information\n    let position = 0;\n    for (let i = 0; i <= mipmapsCount; i++) {\n        for (let face = 0; face < 6; face++) {\n            const byteLength = specularTextures[i * 6 + face].byteLength;\n            info.specular.mipmaps.push({\n                length: byteLength,\n                position: position,\n            });\n            position += byteLength;\n        }\n    }\n    // Encode the JSON as an array buffer\n    const infoString = JSON.stringify(info);\n    const infoBuffer = new ArrayBuffer(infoString.length + 1);\n    const infoView = new Uint8Array(infoBuffer); // Limited to ascii subset matching unicode.\n    for (let i = 0, strLen = infoString.length; i < strLen; i++) {\n        infoView[i] = infoString.charCodeAt(i);\n    }\n    // Ends up with a null terminator for easier parsing\n    infoView[infoString.length] = 0x00;\n    // Computes the final required size and creates the storage\n    const totalSize = MagicBytes.length + position + infoBuffer.byteLength;\n    const finalBuffer = new ArrayBuffer(totalSize);\n    const finalBufferView = new Uint8Array(finalBuffer);\n    const dataView = new DataView(finalBuffer);\n    // Copy the magic bytes identifying the file in\n    let pos = 0;\n    for (let i = 0; i < MagicBytes.length; i++) {\n        dataView.setUint8(pos++, MagicBytes[i]);\n    }\n    // Add the json info\n    finalBufferView.set(new Uint8Array(infoBuffer), pos);\n    pos += infoBuffer.byteLength;\n    // Finally inserts the texture data\n    for (let i = 0; i <= mipmapsCount; i++) {\n        for (let face = 0; face < 6; face++) {\n            const dataBuffer = specularTextures[i * 6 + face];\n            finalBufferView.set(new Uint8Array(dataBuffer), pos);\n            pos += dataBuffer.byteLength;\n        }\n    }\n    // Voila\n    return finalBuffer;\n}\n/**\n * Creates a JSON representation of the spherical data.\n * @param texture defines the texture containing the polynomials\n * @returns the JSON representation of the spherical info\n */\nfunction _CreateEnvTextureIrradiance(texture) {\n    const polynmials = texture.sphericalPolynomial;\n    if (polynmials == null) {\n        return null;\n    }\n    return {\n        x: [polynmials.x.x, polynmials.x.y, polynmials.x.z],\n        y: [polynmials.y.x, polynmials.y.y, polynmials.y.z],\n        z: [polynmials.z.x, polynmials.z.y, polynmials.z.z],\n        xx: [polynmials.xx.x, polynmials.xx.y, polynmials.xx.z],\n        yy: [polynmials.yy.x, polynmials.yy.y, polynmials.yy.z],\n        zz: [polynmials.zz.x, polynmials.zz.y, polynmials.zz.z],\n        yz: [polynmials.yz.x, polynmials.yz.y, polynmials.yz.z],\n        zx: [polynmials.zx.x, polynmials.zx.y, polynmials.zx.z],\n        xy: [polynmials.xy.x, polynmials.xy.y, polynmials.xy.z],\n    };\n}\n/**\n * Creates the ArrayBufferViews used for initializing environment texture image data.\n * @param data the image data\n * @param info parameters that determine what views will be created for accessing the underlying buffer\n * @returns the views described by info providing access to the underlying buffer\n */\nexport function CreateImageDataArrayBufferViews(data, info) {\n    info = normalizeEnvInfo(info);\n    const specularInfo = info.specular;\n    // Double checks the enclosed info\n    let mipmapsCount = Scalar.Log2(info.width);\n    mipmapsCount = Math.round(mipmapsCount) + 1;\n    if (specularInfo.mipmaps.length !== 6 * mipmapsCount) {\n        throw new Error(`Unsupported specular mipmaps number \"${specularInfo.mipmaps.length}\"`);\n    }\n    const imageData = new Array(mipmapsCount);\n    for (let i = 0; i < mipmapsCount; i++) {\n        imageData[i] = new Array(6);\n        for (let face = 0; face < 6; face++) {\n            const imageInfo = specularInfo.mipmaps[i * 6 + face];\n            imageData[i][face] = new Uint8Array(data.buffer, data.byteOffset + specularInfo.specularDataPosition + imageInfo.position, imageInfo.length);\n        }\n    }\n    return imageData;\n}\n/**\n * Uploads the texture info contained in the env file to the GPU.\n * @param texture defines the internal texture to upload to\n * @param data defines the data to load\n * @param info defines the texture info retrieved through the GetEnvInfo method\n * @returns a promise\n */\nexport function UploadEnvLevelsAsync(texture, data, info) {\n    info = normalizeEnvInfo(info);\n    const specularInfo = info.specular;\n    if (!specularInfo) {\n        // Nothing else parsed so far\n        return Promise.resolve();\n    }\n    texture._lodGenerationScale = specularInfo.lodGenerationScale;\n    const imageData = CreateImageDataArrayBufferViews(data, info);\n    return UploadLevelsAsync(texture, imageData, info.imageType);\n}\nfunction _OnImageReadyAsync(image, engine, expandTexture, rgbdPostProcess, url, face, i, generateNonLODTextures, lodTextures, cubeRtt, texture) {\n    return new Promise((resolve, reject) => {\n        if (expandTexture) {\n            const tempTexture = engine.createTexture(null, true, true, null, 1, null, (message) => {\n                reject(message);\n            }, image);\n            rgbdPostProcess.getEffect().executeWhenCompiled(() => {\n                // Uncompress the data to a RTT\n                rgbdPostProcess.externalTextureSamplerBinding = true;\n                rgbdPostProcess.onApply = (effect) => {\n                    effect._bindTexture(\"textureSampler\", tempTexture);\n                    effect.setFloat2(\"scale\", 1, engine._features.needsInvertingBitmap && image instanceof ImageBitmap ? -1 : 1);\n                };\n                if (!engine.scenes.length) {\n                    return;\n                }\n                engine.scenes[0].postProcessManager.directRender([rgbdPostProcess], cubeRtt, true, face, i);\n                // Cleanup\n                engine.restoreDefaultFramebuffer();\n                tempTexture.dispose();\n                URL.revokeObjectURL(url);\n                resolve();\n            });\n        }\n        else {\n            engine._uploadImageToTexture(texture, image, face, i);\n            // Upload the face to the non lod texture support\n            if (generateNonLODTextures) {\n                const lodTexture = lodTextures[i];\n                if (lodTexture) {\n                    engine._uploadImageToTexture(lodTexture._texture, image, face, 0);\n                }\n            }\n            resolve();\n        }\n    });\n}\n/**\n * Uploads the levels of image data to the GPU.\n * @param texture defines the internal texture to upload to\n * @param imageData defines the array buffer views of image data [mipmap][face]\n * @param imageType the mime type of the image data\n * @returns a promise\n */\nexport function UploadLevelsAsync(texture, imageData, imageType = DefaultEnvironmentTextureImageType) {\n    if (!Tools.IsExponentOfTwo(texture.width)) {\n        throw new Error(\"Texture size must be a power of two\");\n    }\n    const mipmapsCount = Scalar.ILog2(texture.width) + 1;\n    // Gets everything ready.\n    const engine = texture.getEngine();\n    let expandTexture = false;\n    let generateNonLODTextures = false;\n    let rgbdPostProcess = null;\n    let cubeRtt = null;\n    let lodTextures = null;\n    const caps = engine.getCaps();\n    texture.format = 5;\n    texture.type = 0;\n    texture.generateMipMaps = true;\n    texture._cachedAnisotropicFilteringLevel = null;\n    engine.updateTextureSamplingMode(3, texture);\n    // Add extra process if texture lod is not supported\n    if (!caps.textureLOD) {\n        expandTexture = false;\n        generateNonLODTextures = true;\n        lodTextures = {};\n    }\n    // in webgl 1 there are no ways to either render or copy lod level information for float textures.\n    else if (!engine._features.supportRenderAndCopyToLodForFloatTextures) {\n        expandTexture = false;\n    }\n    // If half float available we can uncompress the texture\n    else if (caps.textureHalfFloatRender && caps.textureHalfFloatLinearFiltering) {\n        expandTexture = true;\n        texture.type = 2;\n    }\n    // If full float available we can uncompress the texture\n    else if (caps.textureFloatRender && caps.textureFloatLinearFiltering) {\n        expandTexture = true;\n        texture.type = 1;\n    }\n    // Expand the texture if possible\n    if (expandTexture) {\n        // Simply run through the decode PP\n        rgbdPostProcess = new PostProcess(\"rgbdDecode\", \"rgbdDecode\", null, null, 1, null, 3, engine, false, undefined, texture.type, undefined, null, false);\n        texture._isRGBD = false;\n        texture.invertY = false;\n        cubeRtt = engine.createRenderTargetCubeTexture(texture.width, {\n            generateDepthBuffer: false,\n            generateMipMaps: true,\n            generateStencilBuffer: false,\n            samplingMode: 3,\n            type: texture.type,\n            format: 5,\n        });\n    }\n    else {\n        texture._isRGBD = true;\n        texture.invertY = true;\n        // In case of missing support, applies the same patch than DDS files.\n        if (generateNonLODTextures) {\n            const mipSlices = 3;\n            const scale = texture._lodGenerationScale;\n            const offset = texture._lodGenerationOffset;\n            for (let i = 0; i < mipSlices; i++) {\n                //compute LOD from even spacing in smoothness (matching shader calculation)\n                const smoothness = i / (mipSlices - 1);\n                const roughness = 1 - smoothness;\n                const minLODIndex = offset; // roughness = 0\n                const maxLODIndex = (mipmapsCount - 1) * scale + offset; // roughness = 1 (mipmaps start from 0)\n                const lodIndex = minLODIndex + (maxLODIndex - minLODIndex) * roughness;\n                const mipmapIndex = Math.round(Math.min(Math.max(lodIndex, 0), maxLODIndex));\n                const glTextureFromLod = new InternalTexture(engine, InternalTextureSource.Temp);\n                glTextureFromLod.isCube = true;\n                glTextureFromLod.invertY = true;\n                glTextureFromLod.generateMipMaps = false;\n                engine.updateTextureSamplingMode(2, glTextureFromLod);\n                // Wrap in a base texture for easy binding.\n                const lodTexture = new BaseTexture(null);\n                lodTexture._isCube = true;\n                lodTexture._texture = glTextureFromLod;\n                lodTextures[mipmapIndex] = lodTexture;\n                switch (i) {\n                    case 0:\n                        texture._lodTextureLow = lodTexture;\n                        break;\n                    case 1:\n                        texture._lodTextureMid = lodTexture;\n                        break;\n                    case 2:\n                        texture._lodTextureHigh = lodTexture;\n                        break;\n                }\n            }\n        }\n    }\n    const promises = [];\n    // All mipmaps up to provided number of images\n    for (let i = 0; i < imageData.length; i++) {\n        // All faces\n        for (let face = 0; face < 6; face++) {\n            // Constructs an image element from image data\n            const bytes = imageData[i][face];\n            const blob = new Blob([bytes], { type: imageType });\n            const url = URL.createObjectURL(blob);\n            let promise;\n            if (typeof Image === \"undefined\" || engine._features.forceBitmapOverHTMLImageElement) {\n                promise = engine.createImageBitmap(blob, { premultiplyAlpha: \"none\" }).then((img) => {\n                    return _OnImageReadyAsync(img, engine, expandTexture, rgbdPostProcess, url, face, i, generateNonLODTextures, lodTextures, cubeRtt, texture);\n                });\n            }\n            else {\n                const image = new Image();\n                image.src = url;\n                // Enqueue promise to upload to the texture.\n                promise = new Promise((resolve, reject) => {\n                    image.onload = () => {\n                        _OnImageReadyAsync(image, engine, expandTexture, rgbdPostProcess, url, face, i, generateNonLODTextures, lodTextures, cubeRtt, texture)\n                            .then(() => resolve())\n                            .catch((reason) => {\n                            reject(reason);\n                        });\n                    };\n                    image.onerror = (error) => {\n                        reject(error);\n                    };\n                });\n            }\n            promises.push(promise);\n        }\n    }\n    // Fill remaining mipmaps with black textures.\n    if (imageData.length < mipmapsCount) {\n        let data;\n        const size = Math.pow(2, mipmapsCount - 1 - imageData.length);\n        const dataLength = size * size * 4;\n        switch (texture.type) {\n            case 0: {\n                data = new Uint8Array(dataLength);\n                break;\n            }\n            case 2: {\n                data = new Uint16Array(dataLength);\n                break;\n            }\n            case 1: {\n                data = new Float32Array(dataLength);\n                break;\n            }\n        }\n        for (let i = imageData.length; i < mipmapsCount; i++) {\n            for (let face = 0; face < 6; face++) {\n                engine._uploadArrayBufferViewToTexture(texture, data, face, i);\n            }\n        }\n    }\n    // Once all done, finishes the cleanup and return\n    return Promise.all(promises).then(() => {\n        // Release temp RTT.\n        if (cubeRtt) {\n            engine._releaseTexture(texture);\n            cubeRtt._swapAndDie(texture);\n        }\n        // Release temp Post Process.\n        if (rgbdPostProcess) {\n            rgbdPostProcess.dispose();\n        }\n        // Flag internal texture as ready in case they are in use.\n        if (generateNonLODTextures) {\n            if (texture._lodTextureHigh && texture._lodTextureHigh._texture) {\n                texture._lodTextureHigh._texture.isReady = true;\n            }\n            if (texture._lodTextureMid && texture._lodTextureMid._texture) {\n                texture._lodTextureMid._texture.isReady = true;\n            }\n            if (texture._lodTextureLow && texture._lodTextureLow._texture) {\n                texture._lodTextureLow._texture.isReady = true;\n            }\n        }\n    });\n}\n/**\n * Uploads spherical polynomials information to the texture.\n * @param texture defines the texture we are trying to upload the information to\n * @param info defines the environment texture info retrieved through the GetEnvInfo method\n */\nexport function UploadEnvSpherical(texture, info) {\n    info = normalizeEnvInfo(info);\n    const irradianceInfo = info.irradiance;\n    if (!irradianceInfo) {\n        return;\n    }\n    const sp = new SphericalPolynomial();\n    Vector3.FromArrayToRef(irradianceInfo.x, 0, sp.x);\n    Vector3.FromArrayToRef(irradianceInfo.y, 0, sp.y);\n    Vector3.FromArrayToRef(irradianceInfo.z, 0, sp.z);\n    Vector3.FromArrayToRef(irradianceInfo.xx, 0, sp.xx);\n    Vector3.FromArrayToRef(irradianceInfo.yy, 0, sp.yy);\n    Vector3.FromArrayToRef(irradianceInfo.zz, 0, sp.zz);\n    Vector3.FromArrayToRef(irradianceInfo.yz, 0, sp.yz);\n    Vector3.FromArrayToRef(irradianceInfo.zx, 0, sp.zx);\n    Vector3.FromArrayToRef(irradianceInfo.xy, 0, sp.xy);\n    texture._sphericalPolynomial = sp;\n}\n/**\n * @internal\n */\nexport function _UpdateRGBDAsync(internalTexture, data, sphericalPolynomial, lodScale, lodOffset) {\n    const proxy = internalTexture\n        .getEngine()\n        .createRawCubeTexture(null, internalTexture.width, internalTexture.format, internalTexture.type, internalTexture.generateMipMaps, internalTexture.invertY, internalTexture.samplingMode, internalTexture._compression);\n    const proxyPromise = UploadLevelsAsync(proxy, data).then(() => internalTexture);\n    internalTexture.onRebuildCallback = (_internalTexture) => {\n        return {\n            proxy: proxyPromise,\n            isReady: true,\n            isAsync: true,\n        };\n    };\n    internalTexture._source = InternalTextureSource.CubeRawRGBD;\n    internalTexture._bufferViewArrayArray = data;\n    internalTexture._lodGenerationScale = lodScale;\n    internalTexture._lodGenerationOffset = lodOffset;\n    internalTexture._sphericalPolynomial = sphericalPolynomial;\n    return UploadLevelsAsync(internalTexture, data).then(() => {\n        internalTexture.isReady = true;\n        return internalTexture;\n    });\n}\n/**\n * Sets of helpers addressing the serialization and deserialization of environment texture\n * stored in a BabylonJS env file.\n * Those files are usually stored as .env files.\n */\nexport const EnvironmentTextureTools = {\n    /**\n     * Gets the environment info from an env file.\n     * @param data The array buffer containing the .env bytes.\n     * @returns the environment file info (the json header) if successfully parsed, normalized to the latest supported version.\n     */\n    GetEnvInfo,\n    /**\n     * Creates an environment texture from a loaded cube texture.\n     * @param texture defines the cube texture to convert in env file\n     * @param options options for the conversion process\n     * @param options.imageType the mime type for the encoded images, with support for \"image/png\" (default) and \"image/webp\"\n     * @param options.imageQuality the image quality of encoded WebP images.\n     * @returns a promise containing the environment data if successful.\n     */\n    CreateEnvTextureAsync,\n    /**\n     * Creates the ArrayBufferViews used for initializing environment texture image data.\n     * @param data the image data\n     * @param info parameters that determine what views will be created for accessing the underlying buffer\n     * @returns the views described by info providing access to the underlying buffer\n     */\n    CreateImageDataArrayBufferViews,\n    /**\n     * Uploads the texture info contained in the env file to the GPU.\n     * @param texture defines the internal texture to upload to\n     * @param data defines the data to load\n     * @param info defines the texture info retrieved through the GetEnvInfo method\n     * @returns a promise\n     */\n    UploadEnvLevelsAsync,\n    /**\n     * Uploads the levels of image data to the GPU.\n     * @param texture defines the internal texture to upload to\n     * @param imageData defines the array buffer views of image data [mipmap][face]\n     * @param imageType the mime type of the image data\n     * @returns a promise\n     */\n    UploadLevelsAsync,\n    /**\n     * Uploads spherical polynomials information to the texture.\n     * @param texture defines the texture we are trying to upload the information to\n     * @param info defines the environment texture info retrieved through the GetEnvInfo method\n     */\n    UploadEnvSpherical,\n};\n//# sourceMappingURL=environmentTextureTools.js.map","/* eslint-disable @typescript-eslint/naming-convention */\n/**\n * Base error. Due to limitations of typedoc-check and missing documentation\n * in lib.es5.d.ts, cannot extend Error directly for RuntimeError.\n * @ignore\n */\nexport class BaseError extends Error {\n}\n// See https://stackoverflow.com/questions/12915412/how-do-i-extend-a-host-object-e-g-error-in-typescript\n// and https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work\n// Polyfill for Object.setPrototypeOf if necessary.\nBaseError._setPrototypeOf = Object.setPrototypeOf ||\n    ((o, proto) => {\n        o.__proto__ = proto;\n        return o;\n    });\n/* IMP! DO NOT CHANGE THE NUMBERING OF EXISTING ERROR CODES */\n/**\n * Error codes for BaseError\n */\nexport const ErrorCodes = {\n    // Mesh errors 0-999\n    /** Invalid or empty mesh vertex positions. */\n    MeshInvalidPositionsError: 0,\n    // Texture errors 1000-1999\n    /** Unsupported texture found. */\n    UnsupportedTextureError: 1000,\n    // GLTFLoader errors 2000-2999\n    /** Unexpected magic number found in GLTF file header. */\n    GLTFLoaderUnexpectedMagicError: 2000,\n    // SceneLoader errors 3000-3999\n    /** SceneLoader generic error code. Ideally wraps the inner exception. */\n    SceneLoaderError: 3000,\n    // File related errors 4000-4999\n    /** Load file error */\n    LoadFileError: 4000,\n    /** Request file error */\n    RequestFileError: 4001,\n    /** Read file error */\n    ReadFileError: 4002,\n};\n/**\n * Application runtime error\n */\nexport class RuntimeError extends BaseError {\n    /**\n     * Creates a new RuntimeError\n     * @param message defines the message of the error\n     * @param errorCode the error code\n     * @param innerError the error that caused the outer error\n     */\n    constructor(message, errorCode, innerError) {\n        super(message);\n        this.errorCode = errorCode;\n        this.innerError = innerError;\n        this.name = \"RuntimeError\";\n        BaseError._setPrototypeOf(this, RuntimeError.prototype);\n    }\n}\n//# sourceMappingURL=error.js.map","/* eslint-disable @typescript-eslint/naming-convention */\nimport { WebRequest } from \"./webRequest.js\";\nimport { IsWindowObjectExist } from \"./domManagement.js\";\nimport { Observable } from \"./observable.js\";\nimport { FilesInputStore } from \"./filesInputStore.js\";\nimport { RetryStrategy } from \"./retryStrategy.js\";\nimport { BaseError, ErrorCodes, RuntimeError } from \"./error.js\";\nimport { DecodeBase64ToBinary, DecodeBase64ToString, EncodeArrayBufferToBase64 } from \"./stringTools.js\";\nimport { ShaderProcessor } from \"../Engines/Processors/shaderProcessor.js\";\nimport { ThinEngine } from \"../Engines/thinEngine.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\nimport { Logger } from \"./logger.js\";\nimport { TimingTools } from \"./timingTools.js\";\nconst Base64DataUrlRegEx = new RegExp(/^data:([^,]+\\/[^,]+)?;base64,/i);\n/** @ignore */\nexport class LoadFileError extends RuntimeError {\n    /**\n     * Creates a new LoadFileError\n     * @param message defines the message of the error\n     * @param object defines the optional web request\n     */\n    constructor(message, object) {\n        super(message, ErrorCodes.LoadFileError);\n        this.name = \"LoadFileError\";\n        BaseError._setPrototypeOf(this, LoadFileError.prototype);\n        if (object instanceof WebRequest) {\n            this.request = object;\n        }\n        else {\n            this.file = object;\n        }\n    }\n}\n/** @ignore */\nexport class RequestFileError extends RuntimeError {\n    /**\n     * Creates a new LoadFileError\n     * @param message defines the message of the error\n     * @param request defines the optional web request\n     */\n    constructor(message, request) {\n        super(message, ErrorCodes.RequestFileError);\n        this.request = request;\n        this.name = \"RequestFileError\";\n        BaseError._setPrototypeOf(this, RequestFileError.prototype);\n    }\n}\n/** @ignore */\nexport class ReadFileError extends RuntimeError {\n    /**\n     * Creates a new ReadFileError\n     * @param message defines the message of the error\n     * @param file defines the optional file\n     */\n    constructor(message, file) {\n        super(message, ErrorCodes.ReadFileError);\n        this.file = file;\n        this.name = \"ReadFileError\";\n        BaseError._setPrototypeOf(this, ReadFileError.prototype);\n    }\n}\n/**\n * @internal\n */\nexport const FileToolsOptions = {\n    /**\n     * Gets or sets the retry strategy to apply when an error happens while loading an asset.\n     * When defining this function, return the wait time before trying again or return -1 to\n     * stop retrying and error out.\n     */\n    DefaultRetryStrategy: RetryStrategy.ExponentialBackoff(),\n    /**\n     * Gets or sets the base URL to use to load assets\n     */\n    BaseUrl: \"\",\n    /**\n     * Default behaviour for cors in the application.\n     * It can be a string if the expected behavior is identical in the entire app.\n     * Or a callback to be able to set it per url or on a group of them (in case of Video source for instance)\n     */\n    CorsBehavior: \"anonymous\",\n    /**\n     * Gets or sets a function used to pre-process url before using them to load assets\n     * @param url\n     */\n    PreprocessUrl: (url) => {\n        return url;\n    }\n};\n/**\n * Removes unwanted characters from an url\n * @param url defines the url to clean\n * @returns the cleaned url\n */\nconst _CleanUrl = (url) => {\n    url = url.replace(/#/gm, \"%23\");\n    return url;\n};\n/**\n * Sets the cors behavior on a dom element. This will add the required Tools.CorsBehavior to the element.\n * @param url define the url we are trying\n * @param element define the dom element where to configure the cors policy\n * @internal\n */\nexport const SetCorsBehavior = (url, element) => {\n    if (url && url.indexOf(\"data:\") === 0) {\n        return;\n    }\n    if (FileToolsOptions.CorsBehavior) {\n        if (typeof FileToolsOptions.CorsBehavior === \"string\" || FileToolsOptions.CorsBehavior instanceof String) {\n            element.crossOrigin = FileToolsOptions.CorsBehavior;\n        }\n        else {\n            const result = FileToolsOptions.CorsBehavior(url);\n            if (result) {\n                element.crossOrigin = result;\n            }\n        }\n    }\n};\n/**\n * Loads an image as an HTMLImageElement.\n * @param input url string, ArrayBuffer, or Blob to load\n * @param onLoad callback called when the image successfully loads\n * @param onError callback called when the image fails to load\n * @param offlineProvider offline provider for caching\n * @param mimeType optional mime type\n * @param imageBitmapOptions\n * @returns the HTMLImageElement of the loaded image\n * @internal\n */\nexport const LoadImage = (input, onLoad, onError, offlineProvider, mimeType = \"\", imageBitmapOptions) => {\n    var _a;\n    let url;\n    let usingObjectURL = false;\n    if (input instanceof ArrayBuffer || ArrayBuffer.isView(input)) {\n        if (typeof Blob !== \"undefined\" && typeof URL !== \"undefined\") {\n            url = URL.createObjectURL(new Blob([input], { type: mimeType }));\n            usingObjectURL = true;\n        }\n        else {\n            url = `data:${mimeType};base64,` + EncodeArrayBufferToBase64(input);\n        }\n    }\n    else if (input instanceof Blob) {\n        url = URL.createObjectURL(input);\n        usingObjectURL = true;\n    }\n    else {\n        url = _CleanUrl(input);\n        url = FileToolsOptions.PreprocessUrl(input);\n    }\n    const engine = EngineStore.LastCreatedEngine;\n    const onErrorHandler = (exception) => {\n        if (onError) {\n            const inputText = url || input.toString();\n            onError(`Error while trying to load image: ${inputText.indexOf(\"http\") === 0 || inputText.length <= 128 ? inputText : inputText.slice(0, 128) + \"...\"}`, exception);\n        }\n    };\n    if (typeof Image === \"undefined\" || ((_a = engine === null || engine === void 0 ? void 0 : engine._features.forceBitmapOverHTMLImageElement) !== null && _a !== void 0 ? _a : false)) {\n        LoadFile(url, (data) => {\n            engine\n                .createImageBitmap(new Blob([data], { type: mimeType }), { premultiplyAlpha: \"none\", ...imageBitmapOptions })\n                .then((imgBmp) => {\n                onLoad(imgBmp);\n                if (usingObjectURL) {\n                    URL.revokeObjectURL(url);\n                }\n            })\n                .catch((reason) => {\n                if (onError) {\n                    onError(\"Error while trying to load image: \" + input, reason);\n                }\n            });\n        }, undefined, offlineProvider || undefined, true, (request, exception) => {\n            onErrorHandler(exception);\n        });\n        return null;\n    }\n    const img = new Image();\n    SetCorsBehavior(url, img);\n    const handlersList = [];\n    const loadHandlersList = () => {\n        handlersList.forEach((handler) => {\n            handler.target.addEventListener(handler.name, handler.handler);\n        });\n    };\n    const unloadHandlersList = () => {\n        handlersList.forEach((handler) => {\n            handler.target.removeEventListener(handler.name, handler.handler);\n        });\n        handlersList.length = 0;\n    };\n    const loadHandler = () => {\n        unloadHandlersList();\n        onLoad(img);\n        // Must revoke the URL after calling onLoad to avoid security exceptions in\n        // certain scenarios (e.g. when hosted in vscode).\n        if (usingObjectURL && img.src) {\n            URL.revokeObjectURL(img.src);\n        }\n    };\n    const errorHandler = (err) => {\n        unloadHandlersList();\n        onErrorHandler(err);\n        if (usingObjectURL && img.src) {\n            URL.revokeObjectURL(img.src);\n        }\n    };\n    const cspHandler = (err) => {\n        unloadHandlersList();\n        const cspException = new Error(`CSP violation of policy ${err.effectiveDirective} ${err.blockedURI}. Current policy is ${err.originalPolicy}`);\n        EngineStore.UseFallbackTexture = false;\n        onErrorHandler(cspException);\n        if (usingObjectURL && img.src) {\n            URL.revokeObjectURL(img.src);\n        }\n        img.src = \"\";\n    };\n    handlersList.push({ target: img, name: \"load\", handler: loadHandler });\n    handlersList.push({ target: img, name: \"error\", handler: errorHandler });\n    handlersList.push({ target: document, name: \"securitypolicyviolation\", handler: cspHandler });\n    loadHandlersList();\n    const fromBlob = url.substring(0, 5) === \"blob:\";\n    const fromData = url.substring(0, 5) === \"data:\";\n    const noOfflineSupport = () => {\n        if (fromBlob || fromData) {\n            img.src = url;\n        }\n        else {\n            LoadFile(url, (data, _, contentType) => {\n                const type = !mimeType && contentType ? contentType : mimeType;\n                const blob = new Blob([data], { type });\n                const url = URL.createObjectURL(blob);\n                usingObjectURL = true;\n                img.src = url;\n            }, undefined, offlineProvider || undefined, true, (request, exception) => {\n                onErrorHandler(exception);\n            });\n        }\n    };\n    const loadFromOfflineSupport = () => {\n        if (offlineProvider) {\n            offlineProvider.loadImage(url, img);\n        }\n    };\n    if (!fromBlob && !fromData && offlineProvider && offlineProvider.enableTexturesOffline) {\n        offlineProvider.open(loadFromOfflineSupport, noOfflineSupport);\n    }\n    else {\n        if (url.indexOf(\"file:\") !== -1) {\n            const textureName = decodeURIComponent(url.substring(5).toLowerCase());\n            if (FilesInputStore.FilesToLoad[textureName] && typeof URL !== \"undefined\") {\n                try {\n                    let blobURL;\n                    try {\n                        blobURL = URL.createObjectURL(FilesInputStore.FilesToLoad[textureName]);\n                    }\n                    catch (ex) {\n                        // Chrome doesn't support oneTimeOnly parameter\n                        blobURL = URL.createObjectURL(FilesInputStore.FilesToLoad[textureName]);\n                    }\n                    img.src = blobURL;\n                    usingObjectURL = true;\n                }\n                catch (e) {\n                    img.src = \"\";\n                }\n                return img;\n            }\n        }\n        noOfflineSupport();\n    }\n    return img;\n};\n/**\n * Reads a file from a File object\n * @param file defines the file to load\n * @param onSuccess defines the callback to call when data is loaded\n * @param onProgress defines the callback to call during loading process\n * @param useArrayBuffer defines a boolean indicating that data must be returned as an ArrayBuffer\n * @param onError defines the callback to call when an error occurs\n * @returns a file request object\n * @internal\n */\nexport const ReadFile = (file, onSuccess, onProgress, useArrayBuffer, onError) => {\n    const reader = new FileReader();\n    const fileRequest = {\n        onCompleteObservable: new Observable(),\n        abort: () => reader.abort()\n    };\n    reader.onloadend = () => fileRequest.onCompleteObservable.notifyObservers(fileRequest);\n    if (onError) {\n        reader.onerror = () => {\n            onError(new ReadFileError(`Unable to read ${file.name}`, file));\n        };\n    }\n    reader.onload = (e) => {\n        //target doesn't have result from ts 1.3\n        onSuccess(e.target[\"result\"]);\n    };\n    if (onProgress) {\n        reader.onprogress = onProgress;\n    }\n    if (!useArrayBuffer) {\n        // Asynchronous read\n        reader.readAsText(file);\n    }\n    else {\n        reader.readAsArrayBuffer(file);\n    }\n    return fileRequest;\n};\n/**\n * Loads a file from a url, a data url, or a file url\n * @param fileOrUrl file, url, data url, or file url to load\n * @param onSuccess callback called when the file successfully loads\n * @param onProgress callback called while file is loading (if the server supports this mode)\n * @param offlineProvider defines the offline provider for caching\n * @param useArrayBuffer defines a boolean indicating that date must be returned as ArrayBuffer\n * @param onError callback called when the file fails to load\n * @param onOpened\n * @returns a file request object\n * @internal\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport const LoadFile = (fileOrUrl, onSuccess, onProgress, offlineProvider, useArrayBuffer, onError, onOpened) => {\n    if (fileOrUrl.name) {\n        return ReadFile(fileOrUrl, onSuccess, onProgress, useArrayBuffer, onError\n            ? (error) => {\n                onError(undefined, error);\n            }\n            : undefined);\n    }\n    const url = fileOrUrl;\n    // If file and file input are set\n    if (url.indexOf(\"file:\") !== -1) {\n        let fileName = decodeURIComponent(url.substring(5).toLowerCase());\n        if (fileName.indexOf(\"./\") === 0) {\n            fileName = fileName.substring(2);\n        }\n        const file = FilesInputStore.FilesToLoad[fileName];\n        if (file) {\n            return ReadFile(file, onSuccess, onProgress, useArrayBuffer, onError ? (error) => onError(undefined, new LoadFileError(error.message, error.file)) : undefined);\n        }\n    }\n    // For a Base64 Data URL\n    const { match, type } = TestBase64DataUrl(url);\n    if (match) {\n        const fileRequest = {\n            onCompleteObservable: new Observable(),\n            abort: () => () => { }\n        };\n        try {\n            const data = useArrayBuffer ? DecodeBase64UrlToBinary(url) : DecodeBase64UrlToString(url);\n            onSuccess(data, undefined, type);\n        }\n        catch (error) {\n            if (onError) {\n                onError(undefined, error);\n            }\n            else {\n                Logger.Error(error.message || \"Failed to parse the Data URL\");\n            }\n        }\n        TimingTools.SetImmediate(() => {\n            fileRequest.onCompleteObservable.notifyObservers(fileRequest);\n        });\n        return fileRequest;\n    }\n    return RequestFile(url, (data, request) => {\n        onSuccess(data, request === null || request === void 0 ? void 0 : request.responseURL, request === null || request === void 0 ? void 0 : request.getResponseHeader(\"content-type\"));\n    }, onProgress, offlineProvider, useArrayBuffer, onError\n        ? (error) => {\n            onError(error.request, new LoadFileError(error.message, error.request));\n        }\n        : undefined, onOpened);\n};\n/**\n * Loads a file from a url\n * @param url url to load\n * @param onSuccess callback called when the file successfully loads\n * @param onProgress callback called while file is loading (if the server supports this mode)\n * @param offlineProvider defines the offline provider for caching\n * @param useArrayBuffer defines a boolean indicating that date must be returned as ArrayBuffer\n * @param onError callback called when the file fails to load\n * @param onOpened callback called when the web request is opened\n * @returns a file request object\n * @internal\n */\nexport const RequestFile = (url, onSuccess, onProgress, offlineProvider, useArrayBuffer, onError, onOpened) => {\n    url = _CleanUrl(url);\n    url = FileToolsOptions.PreprocessUrl(url);\n    const loadUrl = FileToolsOptions.BaseUrl + url;\n    let aborted = false;\n    const fileRequest = {\n        onCompleteObservable: new Observable(),\n        abort: () => (aborted = true)\n    };\n    const requestFile = () => {\n        let request = new WebRequest();\n        let retryHandle = null;\n        let onReadyStateChange;\n        const unbindEvents = () => {\n            if (!request) {\n                return;\n            }\n            if (onProgress) {\n                request.removeEventListener(\"progress\", onProgress);\n            }\n            if (onReadyStateChange) {\n                request.removeEventListener(\"readystatechange\", onReadyStateChange);\n            }\n            request.removeEventListener(\"loadend\", onLoadEnd);\n        };\n        let onLoadEnd = () => {\n            unbindEvents();\n            fileRequest.onCompleteObservable.notifyObservers(fileRequest);\n            fileRequest.onCompleteObservable.clear();\n            onProgress = undefined;\n            onReadyStateChange = null;\n            onLoadEnd = null;\n            onError = undefined;\n            onOpened = undefined;\n            onSuccess = undefined;\n        };\n        fileRequest.abort = () => {\n            aborted = true;\n            if (onLoadEnd) {\n                onLoadEnd();\n            }\n            if (request && request.readyState !== (XMLHttpRequest.DONE || 4)) {\n                request.abort();\n            }\n            if (retryHandle !== null) {\n                clearTimeout(retryHandle);\n                retryHandle = null;\n            }\n            request = null;\n        };\n        const handleError = (error) => {\n            const message = error.message || \"Unknown error\";\n            if (onError && request) {\n                onError(new RequestFileError(message, request));\n            }\n            else {\n                Logger.Error(message);\n            }\n        };\n        const retryLoop = (retryIndex) => {\n            if (!request) {\n                return;\n            }\n            request.open(\"GET\", loadUrl);\n            if (onOpened) {\n                try {\n                    onOpened(request);\n                }\n                catch (e) {\n                    handleError(e);\n                    return;\n                }\n            }\n            if (useArrayBuffer) {\n                request.responseType = \"arraybuffer\";\n            }\n            if (onProgress) {\n                request.addEventListener(\"progress\", onProgress);\n            }\n            if (onLoadEnd) {\n                request.addEventListener(\"loadend\", onLoadEnd);\n            }\n            onReadyStateChange = () => {\n                if (aborted || !request) {\n                    return;\n                }\n                // In case of undefined state in some browsers.\n                if (request.readyState === (XMLHttpRequest.DONE || 4)) {\n                    // Some browsers have issues where onreadystatechange can be called multiple times with the same value.\n                    if (onReadyStateChange) {\n                        request.removeEventListener(\"readystatechange\", onReadyStateChange);\n                    }\n                    if ((request.status >= 200 && request.status < 300) || (request.status === 0 && (!IsWindowObjectExist() || IsFileURL()))) {\n                        try {\n                            if (onSuccess) {\n                                onSuccess(useArrayBuffer ? request.response : request.responseText, request);\n                            }\n                        }\n                        catch (e) {\n                            handleError(e);\n                        }\n                        return;\n                    }\n                    const retryStrategy = FileToolsOptions.DefaultRetryStrategy;\n                    if (retryStrategy) {\n                        const waitTime = retryStrategy(loadUrl, request, retryIndex);\n                        if (waitTime !== -1) {\n                            // Prevent the request from completing for retry.\n                            unbindEvents();\n                            request = new WebRequest();\n                            retryHandle = setTimeout(() => retryLoop(retryIndex + 1), waitTime);\n                            return;\n                        }\n                    }\n                    const error = new RequestFileError(\"Error status: \" + request.status + \" \" + request.statusText + \" - Unable to load \" + loadUrl, request);\n                    if (onError) {\n                        onError(error);\n                    }\n                }\n            };\n            request.addEventListener(\"readystatechange\", onReadyStateChange);\n            request.send();\n        };\n        retryLoop(0);\n    };\n    // Caching all files\n    if (offlineProvider && offlineProvider.enableSceneOffline) {\n        const noOfflineSupport = (request) => {\n            if (request && request.status > 400) {\n                if (onError) {\n                    onError(request);\n                }\n            }\n            else {\n                requestFile();\n            }\n        };\n        const loadFromOfflineSupport = () => {\n            // TODO: database needs to support aborting and should return a IFileRequest\n            if (offlineProvider) {\n                offlineProvider.loadFile(FileToolsOptions.BaseUrl + url, (data) => {\n                    if (!aborted && onSuccess) {\n                        onSuccess(data);\n                    }\n                    fileRequest.onCompleteObservable.notifyObservers(fileRequest);\n                }, onProgress\n                    ? (event) => {\n                        if (!aborted && onProgress) {\n                            onProgress(event);\n                        }\n                    }\n                    : undefined, noOfflineSupport, useArrayBuffer);\n            }\n        };\n        offlineProvider.open(loadFromOfflineSupport, noOfflineSupport);\n    }\n    else {\n        requestFile();\n    }\n    return fileRequest;\n};\n/**\n * Checks if the loaded document was accessed via `file:`-Protocol.\n * @returns boolean\n * @internal\n */\nexport const IsFileURL = () => {\n    return typeof location !== \"undefined\" && location.protocol === \"file:\";\n};\n/**\n * Test if the given uri is a valid base64 data url\n * @param uri The uri to test\n * @returns True if the uri is a base64 data url or false otherwise\n * @internal\n */\nexport const IsBase64DataUrl = (uri) => {\n    return Base64DataUrlRegEx.test(uri);\n};\nexport const TestBase64DataUrl = (uri) => {\n    const results = Base64DataUrlRegEx.exec(uri);\n    if (results === null || results.length === 0) {\n        return { match: false, type: \"\" };\n    }\n    else {\n        const type = results[0].replace(\"data:\", \"\").replace(\"base64,\", \"\");\n        return { match: true, type };\n    }\n};\n/**\n * Decode the given base64 uri.\n * @param uri The uri to decode\n * @returns The decoded base64 data.\n * @internal\n */\nexport function DecodeBase64UrlToBinary(uri) {\n    return DecodeBase64ToBinary(uri.split(\",\")[1]);\n}\n/**\n * Decode the given base64 uri into a UTF-8 encoded string.\n * @param uri The uri to decode\n * @returns The decoded base64 data.\n * @internal\n */\nexport const DecodeBase64UrlToString = (uri) => {\n    return DecodeBase64ToString(uri.split(\",\")[1]);\n};\n/**\n * This will be executed automatically for UMD and es5.\n * If esm dev wants the side effects to execute they will have to run it manually\n * Once we build native modules those need to be exported.\n * @internal\n */\nconst initSideEffects = () => {\n    ThinEngine._FileToolsLoadImage = LoadImage;\n    ThinEngine._FileToolsLoadFile = LoadFile;\n    ShaderProcessor._FileToolsLoadFile = LoadFile;\n};\ninitSideEffects();\n/**\n* FileTools defined as any.\n* This should not be imported or used in future releases or in any module in the framework\n* @internal\n* @deprecated import the needed function from fileTools.ts\n*/\nexport let FileTools;\n/**\n * @param DecodeBase64UrlToBinary\n * @param DecodeBase64UrlToString\n * @param FileToolsOptions\n * @internal\n */\nexport const _injectLTSFileTools = (DecodeBase64UrlToBinary, DecodeBase64UrlToString, FileToolsOptions, IsBase64DataUrl, IsFileURL, LoadFile, LoadImage, ReadFile, RequestFile, SetCorsBehavior) => {\n    /**\n     * Backwards compatibility.\n     * @internal\n     * @deprecated\n     */\n    FileTools = {\n        DecodeBase64UrlToBinary,\n        DecodeBase64UrlToString,\n        DefaultRetryStrategy: FileToolsOptions.DefaultRetryStrategy,\n        BaseUrl: FileToolsOptions.BaseUrl,\n        CorsBehavior: FileToolsOptions.CorsBehavior,\n        PreprocessUrl: FileToolsOptions.PreprocessUrl,\n        IsBase64DataUrl,\n        IsFileURL,\n        LoadFile,\n        LoadImage,\n        ReadFile,\n        RequestFile,\n        SetCorsBehavior\n    };\n    Object.defineProperty(FileTools, \"DefaultRetryStrategy\", {\n        get: function () {\n            return FileToolsOptions.DefaultRetryStrategy;\n        },\n        set: function (value) {\n            FileToolsOptions.DefaultRetryStrategy = value;\n        }\n    });\n    Object.defineProperty(FileTools, \"BaseUrl\", {\n        get: function () {\n            return FileToolsOptions.BaseUrl;\n        },\n        set: function (value) {\n            FileToolsOptions.BaseUrl = value;\n        }\n    });\n    Object.defineProperty(FileTools, \"PreprocessUrl\", {\n        get: function () {\n            return FileToolsOptions.PreprocessUrl;\n        },\n        set: function (value) {\n            FileToolsOptions.PreprocessUrl = value;\n        }\n    });\n    Object.defineProperty(FileTools, \"CorsBehavior\", {\n        get: function () {\n            return FileToolsOptions.CorsBehavior;\n        },\n        set: function (value) {\n            FileToolsOptions.CorsBehavior = value;\n        }\n    });\n};\n_injectLTSFileTools(DecodeBase64UrlToBinary, DecodeBase64UrlToString, FileToolsOptions, IsBase64DataUrl, IsFileURL, LoadFile, LoadImage, ReadFile, RequestFile, SetCorsBehavior);\n//# sourceMappingURL=fileTools.js.map","import { SceneLoader } from \"../Loading/sceneLoader.js\";\nimport { Logger } from \"../Misc/logger.js\";\nimport { FilesInputStore } from \"./filesInputStore.js\";\n/**\n * Class used to help managing file picking and drag-n-drop\n */\nexport class FilesInput {\n    /**\n     * List of files ready to be loaded\n     */\n    static get FilesToLoad() {\n        return FilesInputStore.FilesToLoad;\n    }\n    /**\n     * Creates a new FilesInput\n     * @param engine defines the rendering engine\n     * @param scene defines the hosting scene\n     * @param sceneLoadedCallback callback called when scene is loaded\n     * @param progressCallback callback called to track progress\n     * @param additionalRenderLoopLogicCallback callback called to add user logic to the rendering loop\n     * @param textureLoadingCallback callback called when a texture is loading\n     * @param startingProcessingFilesCallback callback called when the system is about to process all files\n     * @param onReloadCallback callback called when a reload is requested\n     * @param errorCallback callback call if an error occurs\n     */\n    constructor(engine, scene, sceneLoadedCallback, progressCallback, additionalRenderLoopLogicCallback, textureLoadingCallback, startingProcessingFilesCallback, onReloadCallback, errorCallback) {\n        /**\n         * Callback called when a file is processed\n         */\n        this.onProcessFileCallback = () => {\n            return true;\n        };\n        /**\n         * Function used when loading the scene file\n         * @param sceneFile\n         * @param onProgress\n         */\n        this.loadAsync = (sceneFile, onProgress) => SceneLoader.LoadAsync(\"file:\", sceneFile, this._engine, onProgress);\n        this._engine = engine;\n        this._currentScene = scene;\n        this._sceneLoadedCallback = sceneLoadedCallback;\n        this._progressCallback = progressCallback;\n        this._additionalRenderLoopLogicCallback = additionalRenderLoopLogicCallback;\n        this._textureLoadingCallback = textureLoadingCallback;\n        this._startingProcessingFilesCallback = startingProcessingFilesCallback;\n        this._onReloadCallback = onReloadCallback;\n        this._errorCallback = errorCallback;\n    }\n    /**\n     * Calls this function to listen to drag'n'drop events on a specific DOM element\n     * @param elementToMonitor defines the DOM element to track\n     */\n    monitorElementForDragNDrop(elementToMonitor) {\n        if (elementToMonitor) {\n            this._elementToMonitor = elementToMonitor;\n            this._dragEnterHandler = (e) => {\n                this._drag(e);\n            };\n            this._dragOverHandler = (e) => {\n                this._drag(e);\n            };\n            this._dropHandler = (e) => {\n                this._drop(e);\n            };\n            this._elementToMonitor.addEventListener(\"dragenter\", this._dragEnterHandler, false);\n            this._elementToMonitor.addEventListener(\"dragover\", this._dragOverHandler, false);\n            this._elementToMonitor.addEventListener(\"drop\", this._dropHandler, false);\n        }\n    }\n    /** Gets the current list of files to load */\n    get filesToLoad() {\n        return this._filesToLoad;\n    }\n    /**\n     * Release all associated resources\n     */\n    dispose() {\n        if (!this._elementToMonitor) {\n            return;\n        }\n        this._elementToMonitor.removeEventListener(\"dragenter\", this._dragEnterHandler);\n        this._elementToMonitor.removeEventListener(\"dragover\", this._dragOverHandler);\n        this._elementToMonitor.removeEventListener(\"drop\", this._dropHandler);\n    }\n    _renderFunction() {\n        if (this._additionalRenderLoopLogicCallback) {\n            this._additionalRenderLoopLogicCallback();\n        }\n        if (this._currentScene) {\n            if (this._textureLoadingCallback) {\n                const remaining = this._currentScene.getWaitingItemsCount();\n                if (remaining > 0) {\n                    this._textureLoadingCallback(remaining);\n                }\n            }\n            this._currentScene.render();\n        }\n    }\n    _drag(e) {\n        e.stopPropagation();\n        e.preventDefault();\n    }\n    _drop(eventDrop) {\n        eventDrop.stopPropagation();\n        eventDrop.preventDefault();\n        this.loadFiles(eventDrop);\n    }\n    _traverseFolder(folder, files, remaining, callback) {\n        const reader = folder.createReader();\n        const relativePath = folder.fullPath.replace(/^\\//, \"\").replace(/(.+?)\\/?$/, \"$1/\");\n        reader.readEntries((entries) => {\n            remaining.count += entries.length;\n            for (const entry of entries) {\n                if (entry.isFile) {\n                    entry.file((file) => {\n                        file.correctName = relativePath + file.name;\n                        files.push(file);\n                        if (--remaining.count === 0) {\n                            callback();\n                        }\n                    });\n                }\n                else if (entry.isDirectory) {\n                    this._traverseFolder(entry, files, remaining, callback);\n                }\n            }\n            if (--remaining.count === 0) {\n                callback();\n            }\n        });\n    }\n    _processFiles(files) {\n        for (let i = 0; i < files.length; i++) {\n            const name = files[i].correctName.toLowerCase();\n            const extension = name.split(\".\").pop();\n            if (!this.onProcessFileCallback(files[i], name, extension, (sceneFile) => (this._sceneFileToLoad = sceneFile))) {\n                continue;\n            }\n            if (SceneLoader.IsPluginForExtensionAvailable(\".\" + extension)) {\n                this._sceneFileToLoad = files[i];\n            }\n            FilesInput.FilesToLoad[name] = files[i];\n        }\n    }\n    /**\n     * Load files from a drop event\n     * @param event defines the drop event to use as source\n     */\n    loadFiles(event) {\n        // Handling data transfer via drag'n'drop\n        if (event && event.dataTransfer && event.dataTransfer.files) {\n            this._filesToLoad = event.dataTransfer.files;\n        }\n        // Handling files from input files\n        if (event && event.target && event.target.files) {\n            this._filesToLoad = event.target.files;\n        }\n        if (!this._filesToLoad || this._filesToLoad.length === 0) {\n            return;\n        }\n        if (this._startingProcessingFilesCallback) {\n            this._startingProcessingFilesCallback(this._filesToLoad);\n        }\n        if (this._filesToLoad && this._filesToLoad.length > 0) {\n            const files = new Array();\n            const folders = [];\n            const items = event.dataTransfer ? event.dataTransfer.items : null;\n            for (let i = 0; i < this._filesToLoad.length; i++) {\n                const fileToLoad = this._filesToLoad[i];\n                const name = fileToLoad.name.toLowerCase();\n                let entry;\n                fileToLoad.correctName = name;\n                if (items) {\n                    const item = items[i];\n                    if (item.getAsEntry) {\n                        entry = item.getAsEntry();\n                    }\n                    else if (item.webkitGetAsEntry) {\n                        entry = item.webkitGetAsEntry();\n                    }\n                }\n                if (!entry) {\n                    files.push(fileToLoad);\n                }\n                else {\n                    if (entry.isDirectory) {\n                        folders.push(entry);\n                    }\n                    else {\n                        files.push(fileToLoad);\n                    }\n                }\n            }\n            if (folders.length === 0) {\n                this._processFiles(files);\n                this._processReload();\n            }\n            else {\n                const remaining = { count: folders.length };\n                for (const folder of folders) {\n                    this._traverseFolder(folder, files, remaining, () => {\n                        this._processFiles(files);\n                        if (remaining.count === 0) {\n                            this._processReload();\n                        }\n                    });\n                }\n            }\n        }\n    }\n    _processReload() {\n        if (this._onReloadCallback) {\n            this._onReloadCallback(this._sceneFileToLoad);\n        }\n        else {\n            this.reload();\n        }\n    }\n    /**\n     * Reload the current scene from the loaded files\n     */\n    reload() {\n        // If a scene file has been provided\n        if (this._sceneFileToLoad) {\n            if (this._currentScene) {\n                if (Logger.errorsCount > 0) {\n                    Logger.ClearLogCache();\n                }\n                this._engine.stopRenderLoop();\n            }\n            SceneLoader.ShowLoadingScreen = false;\n            this._engine.displayLoadingUI();\n            this.loadAsync(this._sceneFileToLoad, this._progressCallback)\n                .then((scene) => {\n                if (this._currentScene) {\n                    this._currentScene.dispose();\n                }\n                this._currentScene = scene;\n                if (this._sceneLoadedCallback) {\n                    this._sceneLoadedCallback(this._sceneFileToLoad, this._currentScene);\n                }\n                // Wait for textures and shaders to be ready\n                this._currentScene.executeWhenReady(() => {\n                    this._engine.hideLoadingUI();\n                    this._engine.runRenderLoop(() => {\n                        this._renderFunction();\n                    });\n                });\n            })\n                .catch((error) => {\n                this._engine.hideLoadingUI();\n                if (this._errorCallback) {\n                    this._errorCallback(this._sceneFileToLoad, this._currentScene, error.message);\n                }\n            });\n        }\n        else {\n            Logger.Error(\"Please provide a valid .babylon file.\");\n        }\n    }\n}\n//# sourceMappingURL=filesInput.js.map","/**\n * Class used to help managing file picking and drag'n'drop\n * File Storage\n */\nexport class FilesInputStore {\n}\n/**\n * List of files ready to be loaded\n */\nFilesInputStore.FilesToLoad = {};\n//# sourceMappingURL=filesInputStore.js.map","import { Color4 } from \"../Maths/math.color.js\";\n/** Class used to store color4 gradient */\nexport class ColorGradient {\n    /**\n     * Creates a new color4 gradient\n     * @param gradient gets or sets the gradient value (between 0 and 1)\n     * @param color1 gets or sets first associated color\n     * @param color2 gets or sets first second color\n     */\n    constructor(\n    /**\n     * Gets or sets the gradient value (between 0 and 1)\n     */\n    gradient, \n    /**\n     * Gets or sets first associated color\n     */\n    color1, \n    /**\n     * Gets or sets second associated color\n     */\n    color2) {\n        this.gradient = gradient;\n        this.color1 = color1;\n        this.color2 = color2;\n    }\n    /**\n     * Will get a color picked randomly between color1 and color2.\n     * If color2 is undefined then color1 will be used\n     * @param result defines the target Color4 to store the result in\n     */\n    getColorToRef(result) {\n        if (!this.color2) {\n            result.copyFrom(this.color1);\n            return;\n        }\n        Color4.LerpToRef(this.color1, this.color2, Math.random(), result);\n    }\n}\n/** Class used to store color 3 gradient */\nexport class Color3Gradient {\n    /**\n     * Creates a new color3 gradient\n     * @param gradient gets or sets the gradient value (between 0 and 1)\n     * @param color gets or sets associated color\n     */\n    constructor(\n    /**\n     * Gets or sets the gradient value (between 0 and 1)\n     */\n    gradient, \n    /**\n     * Gets or sets the associated color\n     */\n    color) {\n        this.gradient = gradient;\n        this.color = color;\n    }\n}\n/** Class used to store factor gradient */\nexport class FactorGradient {\n    /**\n     * Creates a new factor gradient\n     * @param gradient gets or sets the gradient value (between 0 and 1)\n     * @param factor1 gets or sets first associated factor\n     * @param factor2 gets or sets second associated factor\n     */\n    constructor(\n    /**\n     * Gets or sets the gradient value (between 0 and 1)\n     */\n    gradient, \n    /**\n     * Gets or sets first associated factor\n     */\n    factor1, \n    /**\n     * Gets or sets second associated factor\n     */\n    factor2) {\n        this.gradient = gradient;\n        this.factor1 = factor1;\n        this.factor2 = factor2;\n    }\n    /**\n     * Will get a number picked randomly between factor1 and factor2.\n     * If factor2 is undefined then factor1 will be used\n     * @returns the picked number\n     */\n    getFactor() {\n        if (this.factor2 === undefined || this.factor2 === this.factor1) {\n            return this.factor1;\n        }\n        return this.factor1 + (this.factor2 - this.factor1) * Math.random();\n    }\n}\n/**\n * Helper used to simplify some generic gradient tasks\n */\nexport class GradientHelper {\n    /**\n     * Gets the current gradient from an array of IValueGradient\n     * @param ratio defines the current ratio to get\n     * @param gradients defines the array of IValueGradient\n     * @param updateFunc defines the callback function used to get the final value from the selected gradients\n     */\n    static GetCurrentGradient(ratio, gradients, updateFunc) {\n        // Use last index if over\n        if (gradients[0].gradient > ratio) {\n            updateFunc(gradients[0], gradients[0], 1.0);\n            return;\n        }\n        for (let gradientIndex = 0; gradientIndex < gradients.length - 1; gradientIndex++) {\n            const currentGradient = gradients[gradientIndex];\n            const nextGradient = gradients[gradientIndex + 1];\n            if (ratio >= currentGradient.gradient && ratio <= nextGradient.gradient) {\n                const scale = (ratio - currentGradient.gradient) / (nextGradient.gradient - currentGradient.gradient);\n                updateFunc(currentGradient, nextGradient, scale);\n                return;\n            }\n        }\n        // Use last index if over\n        const lastIndex = gradients.length - 1;\n        updateFunc(gradients[lastIndex], gradients[lastIndex], 1.0);\n    }\n}\n//# sourceMappingURL=gradients.js.map","/**\n * Implementation from http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/2117523#answer-2117523\n * Be aware Math.random() could cause collisions, but:\n * \"All but 6 of the 128 bits of the ID are randomly generated, which means that for any two ids, there's a 1 in 2^^122 (or 5.3x10^^36) chance they'll collide\"\n * @returns a pseudo random id\n */\nexport function RandomGUID() {\n    return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, (c) => {\n        const r = (Math.random() * 16) | 0, v = c === \"x\" ? r : (r & 0x3) | 0x8;\n        return v.toString(16);\n    });\n}\n/**\n * Class used to manipulate GUIDs\n */\nexport const GUID = {\n    /**\n     * Implementation from http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/2117523#answer-2117523\n     * Be aware Math.random() could cause collisions, but:\n     * \"All but 6 of the 128 bits of the ID are randomly generated, which means that for any two ids, there's a 1 in 2^^122 (or 5.3x10^^36) chance they'll collide\"\n     * @returns a pseudo random id\n     */\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    RandomId: RandomGUID,\n};\n//# sourceMappingURL=guid.js.map","import { Observable } from \"./observable.js\";\n/**\n * Represent a list of observers registered to multiple Observables object.\n */\nexport class MultiObserver {\n    /**\n     * Release associated resources\n     */\n    dispose() {\n        if (this._observers && this._observables) {\n            for (let index = 0; index < this._observers.length; index++) {\n                this._observables[index].remove(this._observers[index]);\n            }\n        }\n        this._observers = null;\n        this._observables = null;\n    }\n    /**\n     * Raise a callback when one of the observable will notify\n     * @param observables defines a list of observables to watch\n     * @param callback defines the callback to call on notification\n     * @param mask defines the mask used to filter notifications\n     * @param scope defines the current scope used to restore the JS context\n     * @returns the new MultiObserver\n     */\n    static Watch(observables, callback, mask = -1, scope = null) {\n        const result = new MultiObserver();\n        result._observers = new Array();\n        result._observables = observables;\n        for (const observable of observables) {\n            const observer = observable.add(callback, mask, false, scope);\n            if (observer) {\n                result._observers.push(observer);\n            }\n        }\n        return result;\n    }\n}\nObservable.prototype.notifyObserversWithPromise = async function (eventData, mask = -1, target, currentTarget, userInfo) {\n    // create an empty promise\n    let p = Promise.resolve(eventData);\n    // no observers? return this promise.\n    if (!this.observers.length) {\n        return p;\n    }\n    const state = this._eventState;\n    state.mask = mask;\n    state.target = target;\n    state.currentTarget = currentTarget;\n    state.skipNextObservers = false;\n    state.userInfo = userInfo;\n    // execute one callback after another (not using Promise.all, the order is important)\n    this.observers.forEach((obs) => {\n        if (state.skipNextObservers) {\n            return;\n        }\n        if (obs._willBeUnregistered) {\n            return;\n        }\n        if (obs.mask & mask) {\n            if (obs.scope) {\n                p = p.then((lastReturnedValue) => {\n                    state.lastReturnValue = lastReturnedValue;\n                    return obs.callback.apply(obs.scope, [eventData, state]);\n                });\n            }\n            else {\n                p = p.then((lastReturnedValue) => {\n                    state.lastReturnValue = lastReturnedValue;\n                    return obs.callback(eventData, state);\n                });\n            }\n            if (obs.unregisterOnNextCall) {\n                this._deferUnregister(obs);\n            }\n        }\n    });\n    // return the eventData\n    await p;\n    return eventData;\n};\n//# sourceMappingURL=observable.extensions.js.map","import { EngineStore } from \"../Engines/engineStore.js\";\nimport { Mesh } from \"../Meshes/mesh.js\";\nimport { Observable } from \"./observable.js\";\n/**\n * Defines the root class used to create scene optimization to use with SceneOptimizer\n * @description More details at https://doc.babylonjs.com/features/featuresDeepDive/scene/sceneOptimizer\n */\nexport class SceneOptimization {\n    /**\n     * Gets a string describing the action executed by the current optimization\n     * @returns description string\n     */\n    getDescription() {\n        return \"\";\n    }\n    /**\n     * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization\n     * @param scene defines the current scene where to apply this optimization\n     * @param optimizer defines the current optimizer\n     * @returns true if everything that can be done was applied\n     */\n    apply(scene, optimizer) {\n        return true;\n    }\n    /**\n     * Creates the SceneOptimization object\n     * @param priority defines the priority of this optimization (0 by default which means first in the list)\n     */\n    constructor(\n    /**\n     * Defines the priority of this optimization (0 by default which means first in the list)\n     */\n    priority = 0) {\n        this.priority = priority;\n    }\n}\n/**\n * Defines an optimization used to reduce the size of render target textures\n * @description More details at https://doc.babylonjs.com/features/featuresDeepDive/scene/sceneOptimizer\n */\nexport class TextureOptimization extends SceneOptimization {\n    /**\n     * Gets a string describing the action executed by the current optimization\n     * @returns description string\n     */\n    getDescription() {\n        return \"Reducing render target texture size to \" + this.maximumSize;\n    }\n    /**\n     * Creates the TextureOptimization object\n     * @param priority defines the priority of this optimization (0 by default which means first in the list)\n     * @param maximumSize defines the maximum sized allowed for textures (1024 is the default value). If a texture is bigger, it will be scaled down using a factor defined by the step parameter\n     * @param step defines the factor (0.5 by default) used to scale down textures bigger than maximum sized allowed.\n     */\n    constructor(\n    /**\n     * Defines the priority of this optimization (0 by default which means first in the list)\n     */\n    priority = 0, \n    /**\n     * Defines the maximum sized allowed for textures (1024 is the default value). If a texture is bigger, it will be scaled down using a factor defined by the step parameter\n     */\n    maximumSize = 1024, \n    /**\n     * Defines the factor (0.5 by default) used to scale down textures bigger than maximum sized allowed.\n     */\n    step = 0.5) {\n        super(priority);\n        this.priority = priority;\n        this.maximumSize = maximumSize;\n        this.step = step;\n    }\n    /**\n     * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization\n     * @param scene defines the current scene where to apply this optimization\n     * @param optimizer defines the current optimizer\n     * @returns true if everything that can be done was applied\n     */\n    apply(scene, optimizer) {\n        let allDone = true;\n        for (let index = 0; index < scene.textures.length; index++) {\n            const texture = scene.textures[index];\n            if (!texture.canRescale || texture.getContext) {\n                continue;\n            }\n            const currentSize = texture.getSize();\n            const maxDimension = Math.max(currentSize.width, currentSize.height);\n            if (maxDimension > this.maximumSize) {\n                texture.scale(this.step);\n                allDone = false;\n            }\n        }\n        return allDone;\n    }\n}\n/**\n * Defines an optimization used to increase or decrease the rendering resolution\n * @description More details at https://doc.babylonjs.com/features/featuresDeepDive/scene/sceneOptimizer\n */\nexport class HardwareScalingOptimization extends SceneOptimization {\n    /**\n     * Gets a string describing the action executed by the current optimization\n     * @returns description string\n     */\n    getDescription() {\n        return \"Setting hardware scaling level to \" + this._currentScale;\n    }\n    /**\n     * Creates the HardwareScalingOptimization object\n     * @param priority defines the priority of this optimization (0 by default which means first in the list)\n     * @param maximumScale defines the maximum scale to use (2 by default)\n     * @param step defines the step to use between two passes (0.5 by default)\n     */\n    constructor(\n    /**\n     * Defines the priority of this optimization (0 by default which means first in the list)\n     */\n    priority = 0, \n    /**\n     * Defines the maximum scale to use (2 by default)\n     */\n    maximumScale = 2, \n    /**\n     * Defines the step to use between two passes (0.5 by default)\n     */\n    step = 0.25) {\n        super(priority);\n        this.priority = priority;\n        this.maximumScale = maximumScale;\n        this.step = step;\n        this._currentScale = -1;\n        this._directionOffset = 1;\n    }\n    /**\n     * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization\n     * @param scene defines the current scene where to apply this optimization\n     * @param optimizer defines the current optimizer\n     * @returns true if everything that can be done was applied\n     */\n    apply(scene, optimizer) {\n        if (this._currentScale === -1) {\n            this._currentScale = scene.getEngine().getHardwareScalingLevel();\n            if (this._currentScale > this.maximumScale) {\n                this._directionOffset = -1;\n            }\n        }\n        this._currentScale += this._directionOffset * this.step;\n        scene.getEngine().setHardwareScalingLevel(this._currentScale);\n        return this._directionOffset === 1 ? this._currentScale >= this.maximumScale : this._currentScale <= this.maximumScale;\n    }\n}\n/**\n * Defines an optimization used to remove shadows\n * @description More details at https://doc.babylonjs.com/features/featuresDeepDive/scene/sceneOptimizer\n */\nexport class ShadowsOptimization extends SceneOptimization {\n    /**\n     * Gets a string describing the action executed by the current optimization\n     * @returns description string\n     */\n    getDescription() {\n        return \"Turning shadows on/off\";\n    }\n    /**\n     * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization\n     * @param scene defines the current scene where to apply this optimization\n     * @param optimizer defines the current optimizer\n     * @returns true if everything that can be done was applied\n     */\n    apply(scene, optimizer) {\n        scene.shadowsEnabled = optimizer.isInImprovementMode;\n        return true;\n    }\n}\n/**\n * Defines an optimization used to turn post-processes off\n * @description More details at https://doc.babylonjs.com/features/featuresDeepDive/scene/sceneOptimizer\n */\nexport class PostProcessesOptimization extends SceneOptimization {\n    /**\n     * Gets a string describing the action executed by the current optimization\n     * @returns description string\n     */\n    getDescription() {\n        return \"Turning post-processes on/off\";\n    }\n    /**\n     * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization\n     * @param scene defines the current scene where to apply this optimization\n     * @param optimizer defines the current optimizer\n     * @returns true if everything that can be done was applied\n     */\n    apply(scene, optimizer) {\n        scene.postProcessesEnabled = optimizer.isInImprovementMode;\n        return true;\n    }\n}\n/**\n * Defines an optimization used to turn lens flares off\n * @description More details at https://doc.babylonjs.com/features/featuresDeepDive/scene/sceneOptimizer\n */\nexport class LensFlaresOptimization extends SceneOptimization {\n    /**\n     * Gets a string describing the action executed by the current optimization\n     * @returns description string\n     */\n    getDescription() {\n        return \"Turning lens flares on/off\";\n    }\n    /**\n     * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization\n     * @param scene defines the current scene where to apply this optimization\n     * @param optimizer defines the current optimizer\n     * @returns true if everything that can be done was applied\n     */\n    apply(scene, optimizer) {\n        scene.lensFlaresEnabled = optimizer.isInImprovementMode;\n        return true;\n    }\n}\n/**\n * Defines an optimization based on user defined callback.\n * @description More details at https://doc.babylonjs.com/features/featuresDeepDive/scene/sceneOptimizer\n */\nexport class CustomOptimization extends SceneOptimization {\n    /**\n     * Gets a string describing the action executed by the current optimization\n     * @returns description string\n     */\n    getDescription() {\n        if (this.onGetDescription) {\n            return this.onGetDescription();\n        }\n        return \"Running user defined callback\";\n    }\n    /**\n     * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization\n     * @param scene defines the current scene where to apply this optimization\n     * @param optimizer defines the current optimizer\n     * @returns true if everything that can be done was applied\n     */\n    apply(scene, optimizer) {\n        if (this.onApply) {\n            return this.onApply(scene, optimizer);\n        }\n        return true;\n    }\n}\n/**\n * Defines an optimization used to turn particles off\n * @description More details at https://doc.babylonjs.com/features/featuresDeepDive/scene/sceneOptimizer\n */\nexport class ParticlesOptimization extends SceneOptimization {\n    /**\n     * Gets a string describing the action executed by the current optimization\n     * @returns description string\n     */\n    getDescription() {\n        return \"Turning particles on/off\";\n    }\n    /**\n     * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization\n     * @param scene defines the current scene where to apply this optimization\n     * @param optimizer defines the current optimizer\n     * @returns true if everything that can be done was applied\n     */\n    apply(scene, optimizer) {\n        scene.particlesEnabled = optimizer.isInImprovementMode;\n        return true;\n    }\n}\n/**\n * Defines an optimization used to turn render targets off\n * @description More details at https://doc.babylonjs.com/features/featuresDeepDive/scene/sceneOptimizer\n */\nexport class RenderTargetsOptimization extends SceneOptimization {\n    /**\n     * Gets a string describing the action executed by the current optimization\n     * @returns description string\n     */\n    getDescription() {\n        return \"Turning render targets off\";\n    }\n    /**\n     * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization\n     * @param scene defines the current scene where to apply this optimization\n     * @param optimizer defines the current optimizer\n     * @returns true if everything that can be done was applied\n     */\n    apply(scene, optimizer) {\n        scene.renderTargetsEnabled = optimizer.isInImprovementMode;\n        return true;\n    }\n}\n/**\n * Defines an optimization used to merge meshes with compatible materials\n * @description More details at https://doc.babylonjs.com/features/featuresDeepDive/scene/sceneOptimizer\n */\nexport class MergeMeshesOptimization extends SceneOptimization {\n    constructor() {\n        super(...arguments);\n        this._canBeMerged = (abstractMesh) => {\n            if (!(abstractMesh instanceof Mesh)) {\n                return false;\n            }\n            const mesh = abstractMesh;\n            if (mesh.isDisposed()) {\n                return false;\n            }\n            if (!mesh.isVisible || !mesh.isEnabled()) {\n                return false;\n            }\n            if (mesh.instances.length > 0) {\n                return false;\n            }\n            if (mesh.skeleton || mesh.hasLODLevels) {\n                return false;\n            }\n            return true;\n        };\n    }\n    /**\n     * Gets or sets a boolean which defines if optimization octree has to be updated\n     */\n    static get UpdateSelectionTree() {\n        return MergeMeshesOptimization._UpdateSelectionTree;\n    }\n    /**\n     * Gets or sets a boolean which defines if optimization octree has to be updated\n     */\n    static set UpdateSelectionTree(value) {\n        MergeMeshesOptimization._UpdateSelectionTree = value;\n    }\n    /**\n     * Gets a string describing the action executed by the current optimization\n     * @returns description string\n     */\n    getDescription() {\n        return \"Merging similar meshes together\";\n    }\n    /**\n     * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization\n     * @param scene defines the current scene where to apply this optimization\n     * @param optimizer defines the current optimizer\n     * @param updateSelectionTree defines that the selection octree has to be updated (false by default)\n     * @returns true if everything that can be done was applied\n     */\n    apply(scene, optimizer, updateSelectionTree) {\n        const globalPool = scene.meshes.slice(0);\n        let globalLength = globalPool.length;\n        for (let index = 0; index < globalLength; index++) {\n            const currentPool = new Array();\n            const current = globalPool[index];\n            // Checks\n            if (!this._canBeMerged(current)) {\n                continue;\n            }\n            currentPool.push(current);\n            // Find compatible meshes\n            for (let subIndex = index + 1; subIndex < globalLength; subIndex++) {\n                const otherMesh = globalPool[subIndex];\n                if (!this._canBeMerged(otherMesh)) {\n                    continue;\n                }\n                if (otherMesh.material !== current.material) {\n                    continue;\n                }\n                if (otherMesh.checkCollisions !== current.checkCollisions) {\n                    continue;\n                }\n                currentPool.push(otherMesh);\n                globalLength--;\n                globalPool.splice(subIndex, 1);\n                subIndex--;\n            }\n            if (currentPool.length < 2) {\n                continue;\n            }\n            // Merge meshes\n            Mesh.MergeMeshes(currentPool, undefined, true);\n        }\n        // Call the octree system optimization if it is defined.\n        const sceneAsAny = scene;\n        if (sceneAsAny.createOrUpdateSelectionOctree) {\n            if (updateSelectionTree != undefined) {\n                if (updateSelectionTree) {\n                    sceneAsAny.createOrUpdateSelectionOctree();\n                }\n            }\n            else if (MergeMeshesOptimization.UpdateSelectionTree) {\n                sceneAsAny.createOrUpdateSelectionOctree();\n            }\n        }\n        return true;\n    }\n}\nMergeMeshesOptimization._UpdateSelectionTree = false;\n/**\n * Defines a list of options used by SceneOptimizer\n * @description More details at https://doc.babylonjs.com/features/featuresDeepDive/scene/sceneOptimizer\n */\nexport class SceneOptimizerOptions {\n    /**\n     * Creates a new list of options used by SceneOptimizer\n     * @param targetFrameRate defines the target frame rate to reach (60 by default)\n     * @param trackerDuration defines the interval between two checks (2000ms by default)\n     */\n    constructor(\n    /**\n     * Defines the target frame rate to reach (60 by default)\n     */\n    targetFrameRate = 60, \n    /**\n     * Defines the interval between two checks (2000ms by default)\n     */\n    trackerDuration = 2000) {\n        this.targetFrameRate = targetFrameRate;\n        this.trackerDuration = trackerDuration;\n        /**\n         * Gets the list of optimizations to apply\n         */\n        this.optimizations = new Array();\n    }\n    /**\n     * Add a new optimization\n     * @param optimization defines the SceneOptimization to add to the list of active optimizations\n     * @returns the current SceneOptimizerOptions\n     */\n    addOptimization(optimization) {\n        this.optimizations.push(optimization);\n        return this;\n    }\n    /**\n     * Add a new custom optimization\n     * @param onApply defines the callback called to apply the custom optimization (true if everything that can be done was applied)\n     * @param onGetDescription defines the callback called to get the description attached with the optimization.\n     * @param priority defines the priority of this optimization (0 by default which means first in the list)\n     * @returns the current SceneOptimizerOptions\n     */\n    addCustomOptimization(onApply, onGetDescription, priority = 0) {\n        const optimization = new CustomOptimization(priority);\n        optimization.onApply = onApply;\n        optimization.onGetDescription = onGetDescription;\n        this.optimizations.push(optimization);\n        return this;\n    }\n    /**\n     * Creates a list of pre-defined optimizations aimed to reduce the visual impact on the scene\n     * @param targetFrameRate defines the target frame rate (60 by default)\n     * @returns a SceneOptimizerOptions object\n     */\n    static LowDegradationAllowed(targetFrameRate) {\n        const result = new SceneOptimizerOptions(targetFrameRate);\n        let priority = 0;\n        result.addOptimization(new MergeMeshesOptimization(priority));\n        result.addOptimization(new ShadowsOptimization(priority));\n        result.addOptimization(new LensFlaresOptimization(priority));\n        // Next priority\n        priority++;\n        result.addOptimization(new PostProcessesOptimization(priority));\n        result.addOptimization(new ParticlesOptimization(priority));\n        // Next priority\n        priority++;\n        result.addOptimization(new TextureOptimization(priority, 1024));\n        return result;\n    }\n    /**\n     * Creates a list of pre-defined optimizations aimed to have a moderate impact on the scene visual\n     * @param targetFrameRate defines the target frame rate (60 by default)\n     * @returns a SceneOptimizerOptions object\n     */\n    static ModerateDegradationAllowed(targetFrameRate) {\n        const result = new SceneOptimizerOptions(targetFrameRate);\n        let priority = 0;\n        result.addOptimization(new MergeMeshesOptimization(priority));\n        result.addOptimization(new ShadowsOptimization(priority));\n        result.addOptimization(new LensFlaresOptimization(priority));\n        // Next priority\n        priority++;\n        result.addOptimization(new PostProcessesOptimization(priority));\n        result.addOptimization(new ParticlesOptimization(priority));\n        // Next priority\n        priority++;\n        result.addOptimization(new TextureOptimization(priority, 512));\n        // Next priority\n        priority++;\n        result.addOptimization(new RenderTargetsOptimization(priority));\n        // Next priority\n        priority++;\n        result.addOptimization(new HardwareScalingOptimization(priority, 2));\n        return result;\n    }\n    /**\n     * Creates a list of pre-defined optimizations aimed to have a big impact on the scene visual\n     * @param targetFrameRate defines the target frame rate (60 by default)\n     * @returns a SceneOptimizerOptions object\n     */\n    static HighDegradationAllowed(targetFrameRate) {\n        const result = new SceneOptimizerOptions(targetFrameRate);\n        let priority = 0;\n        result.addOptimization(new MergeMeshesOptimization(priority));\n        result.addOptimization(new ShadowsOptimization(priority));\n        result.addOptimization(new LensFlaresOptimization(priority));\n        // Next priority\n        priority++;\n        result.addOptimization(new PostProcessesOptimization(priority));\n        result.addOptimization(new ParticlesOptimization(priority));\n        // Next priority\n        priority++;\n        result.addOptimization(new TextureOptimization(priority, 256));\n        // Next priority\n        priority++;\n        result.addOptimization(new RenderTargetsOptimization(priority));\n        // Next priority\n        priority++;\n        result.addOptimization(new HardwareScalingOptimization(priority, 4));\n        return result;\n    }\n}\n/**\n * Class used to run optimizations in order to reach a target frame rate\n * @description More details at https://doc.babylonjs.com/features/featuresDeepDive/scene/sceneOptimizer\n */\nexport class SceneOptimizer {\n    /**\n     * Gets or sets a boolean indicating if the optimizer is in improvement mode\n     */\n    get isInImprovementMode() {\n        return this._improvementMode;\n    }\n    set isInImprovementMode(value) {\n        this._improvementMode = value;\n    }\n    /**\n     * Gets the current priority level (0 at start)\n     */\n    get currentPriorityLevel() {\n        return this._currentPriorityLevel;\n    }\n    /**\n     * Gets the current frame rate checked by the SceneOptimizer\n     */\n    get currentFrameRate() {\n        return this._currentFrameRate;\n    }\n    /**\n     * Gets or sets the current target frame rate (60 by default)\n     */\n    get targetFrameRate() {\n        return this._targetFrameRate;\n    }\n    /**\n     * Gets or sets the current target frame rate (60 by default)\n     */\n    set targetFrameRate(value) {\n        this._targetFrameRate = value;\n    }\n    /**\n     * Gets or sets the current interval between two checks (every 2000ms by default)\n     */\n    get trackerDuration() {\n        return this._trackerDuration;\n    }\n    /**\n     * Gets or sets the current interval between two checks (every 2000ms by default)\n     */\n    set trackerDuration(value) {\n        this._trackerDuration = value;\n    }\n    /**\n     * Gets the list of active optimizations\n     */\n    get optimizations() {\n        return this._options.optimizations;\n    }\n    /**\n     * Creates a new SceneOptimizer\n     * @param scene defines the scene to work on\n     * @param options defines the options to use with the SceneOptimizer\n     * @param autoGeneratePriorities defines if priorities must be generated and not read from SceneOptimization property (true by default)\n     * @param improvementMode defines if the scene optimizer must run the maximum optimization while staying over a target frame instead of trying to reach the target framerate (false by default)\n     */\n    constructor(scene, options, autoGeneratePriorities = true, improvementMode = false) {\n        this._isRunning = false;\n        this._currentPriorityLevel = 0;\n        this._targetFrameRate = 60;\n        this._trackerDuration = 2000;\n        this._currentFrameRate = 0;\n        this._improvementMode = false;\n        /**\n         * Defines an observable called when the optimizer reaches the target frame rate\n         */\n        this.onSuccessObservable = new Observable();\n        /**\n         * Defines an observable called when the optimizer enables an optimization\n         */\n        this.onNewOptimizationAppliedObservable = new Observable();\n        /**\n         * Defines an observable called when the optimizer is not able to reach the target frame rate\n         */\n        this.onFailureObservable = new Observable();\n        if (!options) {\n            this._options = new SceneOptimizerOptions();\n        }\n        else {\n            this._options = options;\n        }\n        if (this._options.targetFrameRate) {\n            this._targetFrameRate = this._options.targetFrameRate;\n        }\n        if (this._options.trackerDuration) {\n            this._trackerDuration = this._options.trackerDuration;\n        }\n        if (autoGeneratePriorities) {\n            let priority = 0;\n            for (const optim of this._options.optimizations) {\n                optim.priority = priority++;\n            }\n        }\n        this._improvementMode = improvementMode;\n        this._scene = scene || EngineStore.LastCreatedScene;\n        this._sceneDisposeObserver = this._scene.onDisposeObservable.add(() => {\n            this._sceneDisposeObserver = null;\n            this.dispose();\n        });\n    }\n    /**\n     * Stops the current optimizer\n     */\n    stop() {\n        this._isRunning = false;\n    }\n    /**\n     * Reset the optimizer to initial step (current priority level = 0)\n     */\n    reset() {\n        this._currentPriorityLevel = 0;\n    }\n    /**\n     * Start the optimizer. By default it will try to reach a specific framerate\n     * but if the optimizer is set with improvementMode === true then it will run all optimization while frame rate is above the target frame rate\n     */\n    start() {\n        if (this._isRunning) {\n            return;\n        }\n        this._isRunning = true;\n        // Let's wait for the scene to be ready before running our check\n        this._scene.executeWhenReady(() => {\n            setTimeout(() => {\n                this._checkCurrentState();\n            }, this._trackerDuration);\n        });\n    }\n    _checkCurrentState() {\n        if (!this._isRunning) {\n            return;\n        }\n        const scene = this._scene;\n        const options = this._options;\n        this._currentFrameRate = Math.round(scene.getEngine().getFps());\n        if ((this._improvementMode && this._currentFrameRate <= this._targetFrameRate) || (!this._improvementMode && this._currentFrameRate >= this._targetFrameRate)) {\n            this._isRunning = false;\n            this.onSuccessObservable.notifyObservers(this);\n            return;\n        }\n        // Apply current level of optimizations\n        let allDone = true;\n        let noOptimizationApplied = true;\n        for (let index = 0; index < options.optimizations.length; index++) {\n            const optimization = options.optimizations[index];\n            if (optimization.priority === this._currentPriorityLevel) {\n                noOptimizationApplied = false;\n                allDone = allDone && optimization.apply(scene, this);\n                this.onNewOptimizationAppliedObservable.notifyObservers(optimization);\n            }\n        }\n        // If no optimization was applied, this is a failure :(\n        if (noOptimizationApplied) {\n            this._isRunning = false;\n            this.onFailureObservable.notifyObservers(this);\n            return;\n        }\n        // If all optimizations were done, move to next level\n        if (allDone) {\n            this._currentPriorityLevel++;\n        }\n        // Let's the system running for a specific amount of time before checking FPS\n        scene.executeWhenReady(() => {\n            setTimeout(() => {\n                this._checkCurrentState();\n            }, this._trackerDuration);\n        });\n    }\n    /**\n     * Release all resources\n     */\n    dispose() {\n        this.stop();\n        this.onSuccessObservable.clear();\n        this.onFailureObservable.clear();\n        this.onNewOptimizationAppliedObservable.clear();\n        if (this._sceneDisposeObserver) {\n            this._scene.onDisposeObservable.remove(this._sceneDisposeObserver);\n        }\n    }\n    /**\n     * Helper function to create a SceneOptimizer with one single line of code\n     * @param scene defines the scene to work on\n     * @param options defines the options to use with the SceneOptimizer\n     * @param onSuccess defines a callback to call on success\n     * @param onFailure defines a callback to call on failure\n     * @returns the new SceneOptimizer object\n     */\n    static OptimizeAsync(scene, options, onSuccess, onFailure) {\n        const optimizer = new SceneOptimizer(scene, options || SceneOptimizerOptions.ModerateDegradationAllowed(), false);\n        if (onSuccess) {\n            optimizer.onSuccessObservable.add(() => {\n                onSuccess();\n            });\n        }\n        if (onFailure) {\n            optimizer.onFailureObservable.add(() => {\n                onFailure();\n            });\n        }\n        optimizer.start();\n        return optimizer;\n    }\n}\n//# sourceMappingURL=sceneOptimizer.js.map","import { Mesh } from \"../Meshes/mesh.js\";\n\nimport { MultiMaterial } from \"../Materials/multiMaterial.js\";\nimport { SerializationHelper } from \"./decorators.js\";\nimport { Texture } from \"../Materials/Textures/texture.js\";\nlet serializedGeometries = [];\nconst SerializeGeometry = (geometry, serializationGeometries) => {\n    if (geometry.doNotSerialize) {\n        return;\n    }\n    serializationGeometries.vertexData.push(geometry.serializeVerticeData());\n    serializedGeometries[geometry.id] = true;\n};\nconst SerializeMesh = (mesh, serializationScene) => {\n    const serializationObject = {};\n    // Geometry\n    const geometry = mesh._geometry;\n    if (geometry) {\n        if (!mesh.getScene().getGeometryById(geometry.id)) {\n            // Geometry was in the memory but not added to the scene, nevertheless it's better to serialize to be able to reload the mesh with its geometry\n            SerializeGeometry(geometry, serializationScene.geometries);\n        }\n    }\n    // Custom\n    if (mesh.serialize) {\n        mesh.serialize(serializationObject);\n    }\n    return serializationObject;\n};\nconst FinalizeSingleMesh = (mesh, serializationObject) => {\n    //only works if the mesh is already loaded\n    if (mesh.delayLoadState === 1 || mesh.delayLoadState === 0) {\n        const serializeMaterial = (material) => {\n            serializationObject.materials = serializationObject.materials || [];\n            if (mesh.material && !serializationObject.materials.some((mat) => mat.id === mesh.material.id)) {\n                serializationObject.materials.push(material.serialize());\n            }\n        };\n        //serialize material\n        if (mesh.material && !mesh.material.doNotSerialize) {\n            if (mesh.material instanceof MultiMaterial) {\n                serializationObject.multiMaterials = serializationObject.multiMaterials || [];\n                if (!serializationObject.multiMaterials.some((mat) => mat.id === mesh.material.id)) {\n                    serializationObject.multiMaterials.push(mesh.material.serialize());\n                    for (const submaterial of mesh.material.subMaterials) {\n                        if (submaterial) {\n                            serializeMaterial(submaterial);\n                        }\n                    }\n                }\n            }\n            else {\n                serializeMaterial(mesh.material);\n            }\n        }\n        else if (!mesh.material) {\n            serializeMaterial(mesh.getScene().defaultMaterial);\n        }\n        //serialize geometry\n        const geometry = mesh._geometry;\n        if (geometry) {\n            if (!serializationObject.geometries) {\n                serializationObject.geometries = {};\n                serializationObject.geometries.boxes = [];\n                serializationObject.geometries.spheres = [];\n                serializationObject.geometries.cylinders = [];\n                serializationObject.geometries.toruses = [];\n                serializationObject.geometries.grounds = [];\n                serializationObject.geometries.planes = [];\n                serializationObject.geometries.torusKnots = [];\n                serializationObject.geometries.vertexData = [];\n            }\n            SerializeGeometry(geometry, serializationObject.geometries);\n        }\n        // Skeletons\n        if (mesh.skeleton && !mesh.skeleton.doNotSerialize) {\n            serializationObject.skeletons = serializationObject.skeletons || [];\n            serializationObject.skeletons.push(mesh.skeleton.serialize());\n        }\n        //serialize the actual mesh\n        serializationObject.meshes = serializationObject.meshes || [];\n        serializationObject.meshes.push(SerializeMesh(mesh, serializationObject));\n    }\n};\n/**\n * Class used to serialize a scene into a string\n */\nexport class SceneSerializer {\n    /**\n     * Clear cache used by a previous serialization\n     */\n    static ClearCache() {\n        serializedGeometries = [];\n    }\n    /**\n     * Serialize a scene into a JSON compatible object\n     * Note that if the current engine does not support synchronous texture reading (like WebGPU), you should use SerializeAsync instead\n     * as else you may not retrieve the proper base64 encoded texture data (when using the Texture.ForceSerializeBuffers flag)\n     * @param scene defines the scene to serialize\n     * @returns a JSON compatible object\n     */\n    static Serialize(scene) {\n        return SceneSerializer._Serialize(scene);\n    }\n    static _Serialize(scene, checkSyncReadSupported = true) {\n        const serializationObject = {};\n        if (checkSyncReadSupported && !scene.getEngine()._features.supportSyncTextureRead && Texture.ForceSerializeBuffers) {\n            console.warn(\"The serialization object may not contain the proper base64 encoded texture data! You should use the SerializeAsync method instead.\");\n        }\n        SceneSerializer.ClearCache();\n        // Scene\n        serializationObject.useDelayedTextureLoading = scene.useDelayedTextureLoading;\n        serializationObject.autoClear = scene.autoClear;\n        serializationObject.clearColor = scene.clearColor.asArray();\n        serializationObject.ambientColor = scene.ambientColor.asArray();\n        serializationObject.gravity = scene.gravity.asArray();\n        serializationObject.collisionsEnabled = scene.collisionsEnabled;\n        serializationObject.useRightHandedSystem = scene.useRightHandedSystem;\n        // Fog\n        if (scene.fogMode && scene.fogMode !== 0) {\n            serializationObject.fogMode = scene.fogMode;\n            serializationObject.fogColor = scene.fogColor.asArray();\n            serializationObject.fogStart = scene.fogStart;\n            serializationObject.fogEnd = scene.fogEnd;\n            serializationObject.fogDensity = scene.fogDensity;\n        }\n        //Physics\n        if (scene.isPhysicsEnabled()) {\n            const physicEngine = scene.getPhysicsEngine();\n            if (physicEngine) {\n                serializationObject.physicsEnabled = true;\n                serializationObject.physicsGravity = physicEngine.gravity.asArray();\n                serializationObject.physicsEngine = physicEngine.getPhysicsPluginName();\n            }\n        }\n        // Metadata\n        if (scene.metadata) {\n            serializationObject.metadata = scene.metadata;\n        }\n        // Morph targets\n        serializationObject.morphTargetManagers = [];\n        for (const abstractMesh of scene.meshes) {\n            const manager = abstractMesh.morphTargetManager;\n            if (manager) {\n                serializationObject.morphTargetManagers.push(manager.serialize());\n            }\n        }\n        // Lights\n        serializationObject.lights = [];\n        let index;\n        let light;\n        for (index = 0; index < scene.lights.length; index++) {\n            light = scene.lights[index];\n            if (!light.doNotSerialize) {\n                serializationObject.lights.push(light.serialize());\n            }\n        }\n        // Cameras\n        serializationObject.cameras = [];\n        for (index = 0; index < scene.cameras.length; index++) {\n            const camera = scene.cameras[index];\n            if (!camera.doNotSerialize) {\n                serializationObject.cameras.push(camera.serialize());\n            }\n        }\n        if (scene.activeCamera) {\n            serializationObject.activeCameraID = scene.activeCamera.id;\n        }\n        // Animations\n        SerializationHelper.AppendSerializedAnimations(scene, serializationObject);\n        // Animation Groups\n        if (scene.animationGroups && scene.animationGroups.length > 0) {\n            serializationObject.animationGroups = [];\n            for (let animationGroupIndex = 0; animationGroupIndex < scene.animationGroups.length; animationGroupIndex++) {\n                const animationGroup = scene.animationGroups[animationGroupIndex];\n                serializationObject.animationGroups.push(animationGroup.serialize());\n            }\n        }\n        // Reflection probes\n        if (scene.reflectionProbes && scene.reflectionProbes.length > 0) {\n            serializationObject.reflectionProbes = [];\n            for (index = 0; index < scene.reflectionProbes.length; index++) {\n                const reflectionProbe = scene.reflectionProbes[index];\n                serializationObject.reflectionProbes.push(reflectionProbe.serialize());\n            }\n        }\n        // Materials\n        serializationObject.materials = [];\n        serializationObject.multiMaterials = [];\n        let material;\n        for (index = 0; index < scene.materials.length; index++) {\n            material = scene.materials[index];\n            if (!material.doNotSerialize) {\n                serializationObject.materials.push(material.serialize());\n            }\n        }\n        // MultiMaterials\n        serializationObject.multiMaterials = [];\n        for (index = 0; index < scene.multiMaterials.length; index++) {\n            const multiMaterial = scene.multiMaterials[index];\n            serializationObject.multiMaterials.push(multiMaterial.serialize());\n        }\n        // Environment texture\n        if (scene.environmentTexture) {\n            if (scene.environmentTexture._files) {\n                serializationObject.environmentTexture = scene.environmentTexture.serialize();\n            }\n            else {\n                serializationObject.environmentTexture = scene.environmentTexture.name;\n                serializationObject.environmentTextureRotationY = scene.environmentTexture.rotationY;\n            }\n        }\n        // Environment Intensity\n        serializationObject.environmentIntensity = scene.environmentIntensity;\n        // Skeletons\n        serializationObject.skeletons = [];\n        for (index = 0; index < scene.skeletons.length; index++) {\n            const skeleton = scene.skeletons[index];\n            if (!skeleton.doNotSerialize) {\n                serializationObject.skeletons.push(skeleton.serialize());\n            }\n        }\n        // Transform nodes\n        serializationObject.transformNodes = [];\n        for (index = 0; index < scene.transformNodes.length; index++) {\n            if (!scene.transformNodes[index].doNotSerialize) {\n                serializationObject.transformNodes.push(scene.transformNodes[index].serialize());\n            }\n        }\n        // Geometries\n        serializationObject.geometries = {};\n        serializationObject.geometries.boxes = [];\n        serializationObject.geometries.spheres = [];\n        serializationObject.geometries.cylinders = [];\n        serializationObject.geometries.toruses = [];\n        serializationObject.geometries.grounds = [];\n        serializationObject.geometries.planes = [];\n        serializationObject.geometries.torusKnots = [];\n        serializationObject.geometries.vertexData = [];\n        serializedGeometries = [];\n        const geometries = scene.getGeometries();\n        for (index = 0; index < geometries.length; index++) {\n            const geometry = geometries[index];\n            if (geometry.isReady()) {\n                SerializeGeometry(geometry, serializationObject.geometries);\n            }\n        }\n        // Meshes\n        serializationObject.meshes = [];\n        for (index = 0; index < scene.meshes.length; index++) {\n            const abstractMesh = scene.meshes[index];\n            if (abstractMesh instanceof Mesh) {\n                const mesh = abstractMesh;\n                if (!mesh.doNotSerialize) {\n                    if (mesh.delayLoadState === 1 || mesh.delayLoadState === 0) {\n                        serializationObject.meshes.push(SerializeMesh(mesh, serializationObject));\n                    }\n                }\n            }\n        }\n        // Particles Systems\n        serializationObject.particleSystems = [];\n        for (index = 0; index < scene.particleSystems.length; index++) {\n            serializationObject.particleSystems.push(scene.particleSystems[index].serialize(false));\n        }\n        // Post processes\n        serializationObject.postProcesses = [];\n        for (index = 0; index < scene.postProcesses.length; index++) {\n            serializationObject.postProcesses.push(scene.postProcesses[index].serialize());\n        }\n        // Action Manager\n        if (scene.actionManager) {\n            serializationObject.actions = scene.actionManager.serialize(\"scene\");\n        }\n        // Components\n        for (const component of scene._serializableComponents) {\n            component.serialize(serializationObject);\n        }\n        return serializationObject;\n    }\n    /**\n     * Serialize a scene into a JSON compatible object\n     * @param scene defines the scene to serialize\n     * @returns a JSON promise compatible object\n     */\n    static SerializeAsync(scene) {\n        const serializationObject = SceneSerializer._Serialize(scene, false);\n        const promises = [];\n        this._CollectPromises(serializationObject, promises);\n        return Promise.all(promises).then(() => serializationObject);\n    }\n    static _CollectPromises(obj, promises) {\n        if (Array.isArray(obj)) {\n            for (let i = 0; i < obj.length; ++i) {\n                const o = obj[i];\n                if (o instanceof Promise) {\n                    promises.push(o.then((res) => (obj[i] = res)));\n                }\n                else if (o instanceof Object || Array.isArray(o)) {\n                    this._CollectPromises(o, promises);\n                }\n            }\n        }\n        else if (obj instanceof Object) {\n            for (const name in obj) {\n                if (Object.prototype.hasOwnProperty.call(obj, name)) {\n                    const o = obj[name];\n                    if (o instanceof Promise) {\n                        promises.push(o.then((res) => (obj[name] = res)));\n                    }\n                    else if (o instanceof Object || Array.isArray(o)) {\n                        this._CollectPromises(o, promises);\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * Serialize a mesh into a JSON compatible object\n     * @param toSerialize defines the mesh to serialize\n     * @param withParents defines if parents must be serialized as well\n     * @param withChildren defines if children must be serialized as well\n     * @returns a JSON compatible object\n     */\n    static SerializeMesh(toSerialize /* Mesh || Mesh[] */, withParents = false, withChildren = false) {\n        const serializationObject = {};\n        SceneSerializer.ClearCache();\n        toSerialize = toSerialize instanceof Array ? toSerialize : [toSerialize];\n        if (withParents || withChildren) {\n            //deliberate for loop! not for each, appended should be processed as well.\n            for (let i = 0; i < toSerialize.length; ++i) {\n                if (withChildren) {\n                    toSerialize[i].getDescendants().forEach((node) => {\n                        if (node instanceof Mesh && toSerialize.indexOf(node) < 0 && !node.doNotSerialize) {\n                            toSerialize.push(node);\n                        }\n                    });\n                }\n                //make sure the array doesn't contain the object already\n                if (withParents && toSerialize[i].parent && toSerialize.indexOf(toSerialize[i].parent) < 0 && !toSerialize[i].parent.doNotSerialize) {\n                    toSerialize.push(toSerialize[i].parent);\n                }\n            }\n        }\n        toSerialize.forEach((mesh) => {\n            FinalizeSingleMesh(mesh, serializationObject);\n        });\n        return serializationObject;\n    }\n}\n//# sourceMappingURL=sceneSerializer.js.map","import { Tools } from \"./tools.js\";\n/**\n * This can help with recording videos from BabylonJS.\n * This is based on the available WebRTC functionalities of the browser.\n *\n * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/renderToVideo\n */\nexport class VideoRecorder {\n    /**\n     * Returns whether or not the VideoRecorder is available in your browser.\n     * @param engine Defines the Babylon Engine.\n     * @returns true if supported otherwise false.\n     */\n    static IsSupported(engine) {\n        const canvas = engine.getRenderingCanvas();\n        return !!canvas && typeof canvas.captureStream === \"function\";\n    }\n    /**\n     * True when a recording is already in progress.\n     */\n    get isRecording() {\n        return !!this._canvas && this._canvas.isRecording;\n    }\n    /**\n     * Create a new VideoCapture object which can help converting what you see in Babylon to a video file.\n     * @param engine Defines the BabylonJS Engine you wish to record.\n     * @param options Defines options that can be used to customize the capture.\n     */\n    constructor(engine, options = {}) {\n        if (!VideoRecorder.IsSupported(engine)) {\n            throw \"Your browser does not support recording so far.\";\n        }\n        const canvas = engine.getRenderingCanvas();\n        if (!canvas) {\n            throw \"The babylon engine must have a canvas to be recorded\";\n        }\n        this._canvas = canvas;\n        this._canvas.isRecording = false;\n        this._options = {\n            ...VideoRecorder._DefaultOptions,\n            ...options,\n        };\n        const stream = this._canvas.captureStream(this._options.fps);\n        if (this._options.audioTracks) {\n            for (const track of this._options.audioTracks) {\n                stream.addTrack(track);\n            }\n        }\n        this._mediaRecorder = new MediaRecorder(stream, { mimeType: this._options.mimeType });\n        this._mediaRecorder.ondataavailable = this._handleDataAvailable.bind(this);\n        this._mediaRecorder.onerror = this._handleError.bind(this);\n        this._mediaRecorder.onstop = this._handleStop.bind(this);\n    }\n    /**\n     * Stops the current recording before the default capture timeout passed in the startRecording function.\n     */\n    stopRecording() {\n        if (!this._canvas || !this._mediaRecorder) {\n            return;\n        }\n        if (!this.isRecording) {\n            return;\n        }\n        this._canvas.isRecording = false;\n        this._mediaRecorder.stop();\n    }\n    /**\n     * Starts recording the canvas for a max duration specified in parameters.\n     * @param fileName Defines the name of the file to be downloaded when the recording stop.\n     * If null no automatic download will start and you can rely on the promise to get the data back.\n     * @param maxDuration Defines the maximum recording time in seconds.\n     * It defaults to 7 seconds. A value of zero will not stop automatically, you would need to call stopRecording manually.\n     * @returns A promise callback at the end of the recording with the video data in Blob.\n     */\n    startRecording(fileName = \"babylonjs.webm\", maxDuration = 7) {\n        if (!this._canvas || !this._mediaRecorder) {\n            throw \"Recorder has already been disposed\";\n        }\n        if (this.isRecording) {\n            throw \"Recording already in progress\";\n        }\n        if (maxDuration > 0) {\n            setTimeout(() => {\n                this.stopRecording();\n            }, maxDuration * 1000);\n        }\n        this._fileName = fileName;\n        this._recordedChunks = [];\n        this._resolve = null;\n        this._reject = null;\n        this._canvas.isRecording = true;\n        this._mediaRecorder.start(this._options.recordChunckSize);\n        return new Promise((resolve, reject) => {\n            this._resolve = resolve;\n            this._reject = reject;\n        });\n    }\n    /**\n     * Releases internal resources used during the recording.\n     */\n    dispose() {\n        this._canvas = null;\n        this._mediaRecorder = null;\n        this._recordedChunks = [];\n        this._fileName = null;\n        this._resolve = null;\n        this._reject = null;\n    }\n    _handleDataAvailable(event) {\n        if (event.data.size > 0) {\n            this._recordedChunks.push(event.data);\n        }\n    }\n    _handleError(event) {\n        this.stopRecording();\n        if (this._reject) {\n            this._reject(event.error);\n        }\n        else {\n            throw new event.error();\n        }\n    }\n    _handleStop() {\n        this.stopRecording();\n        const superBuffer = new Blob(this._recordedChunks);\n        if (this._resolve) {\n            this._resolve(superBuffer);\n        }\n        window.URL.createObjectURL(superBuffer);\n        if (this._fileName) {\n            Tools.Download(superBuffer, this._fileName);\n        }\n    }\n}\nVideoRecorder._DefaultOptions = {\n    mimeType: \"video/webm\",\n    fps: 25,\n    recordChunckSize: 3000,\n};\n//# sourceMappingURL=videoRecorder.js.map","/**\n * Enum that determines the text-wrapping mode to use.\n */\nexport var InspectableType;\n(function (InspectableType) {\n    /**\n     * Checkbox for booleans\n     */\n    InspectableType[InspectableType[\"Checkbox\"] = 0] = \"Checkbox\";\n    /**\n     * Sliders for numbers\n     */\n    InspectableType[InspectableType[\"Slider\"] = 1] = \"Slider\";\n    /**\n     * Vector3\n     */\n    InspectableType[InspectableType[\"Vector3\"] = 2] = \"Vector3\";\n    /**\n     * Quaternions\n     */\n    InspectableType[InspectableType[\"Quaternion\"] = 3] = \"Quaternion\";\n    /**\n     * Color3\n     */\n    InspectableType[InspectableType[\"Color3\"] = 4] = \"Color3\";\n    /**\n     * String\n     */\n    InspectableType[InspectableType[\"String\"] = 5] = \"String\";\n    /**\n     * Button\n     */\n    InspectableType[InspectableType[\"Button\"] = 6] = \"Button\";\n    /**\n     * Options\n     */\n    InspectableType[InspectableType[\"Options\"] = 7] = \"Options\";\n    /**\n     * Tab\n     */\n    InspectableType[InspectableType[\"Tab\"] = 8] = \"Tab\";\n    /**\n     * File button\n     */\n    InspectableType[InspectableType[\"FileButton\"] = 9] = \"FileButton\";\n    /**\n     * Vector2\n     */\n    InspectableType[InspectableType[\"Vector2\"] = 10] = \"Vector2\";\n})(InspectableType || (InspectableType = {}));\n//# sourceMappingURL=iInspectable.js.map","/**\n * Class for storing data to local storage if available or in-memory storage otherwise\n */\nexport class DataStorage {\n    static _GetStorage() {\n        try {\n            localStorage.setItem(\"test\", \"\");\n            localStorage.removeItem(\"test\");\n            return localStorage;\n        }\n        catch (_a) {\n            const inMemoryStorage = {};\n            return {\n                getItem: (key) => {\n                    const value = inMemoryStorage[key];\n                    return value === undefined ? null : value;\n                },\n                setItem: (key, value) => {\n                    inMemoryStorage[key] = value;\n                },\n            };\n        }\n    }\n    /**\n     * Reads a string from the data storage\n     * @param key The key to read\n     * @param defaultValue The value if the key doesn't exist\n     * @returns The string value\n     */\n    static ReadString(key, defaultValue) {\n        const value = this._Storage.getItem(key);\n        return value !== null ? value : defaultValue;\n    }\n    /**\n     * Writes a string to the data storage\n     * @param key The key to write\n     * @param value The value to write\n     */\n    static WriteString(key, value) {\n        this._Storage.setItem(key, value);\n    }\n    /**\n     * Reads a boolean from the data storage\n     * @param key The key to read\n     * @param defaultValue The value if the key doesn't exist\n     * @returns The boolean value\n     */\n    static ReadBoolean(key, defaultValue) {\n        const value = this._Storage.getItem(key);\n        return value !== null ? value === \"true\" : defaultValue;\n    }\n    /**\n     * Writes a boolean to the data storage\n     * @param key The key to write\n     * @param value The value to write\n     */\n    static WriteBoolean(key, value) {\n        this._Storage.setItem(key, value ? \"true\" : \"false\");\n    }\n    /**\n     * Reads a number from the data storage\n     * @param key The key to read\n     * @param defaultValue The value if the key doesn't exist\n     * @returns The number value\n     */\n    static ReadNumber(key, defaultValue) {\n        const value = this._Storage.getItem(key);\n        return value !== null ? parseFloat(value) : defaultValue;\n    }\n    /**\n     * Writes a number to the data storage\n     * @param key The key to write\n     * @param value The value to write\n     */\n    static WriteNumber(key, value) {\n        this._Storage.setItem(key, value.toString());\n    }\n}\nDataStorage._Storage = DataStorage._GetStorage();\n//# sourceMappingURL=dataStorage.js.map","import { Matrix, Vector3 } from \"../Maths/math.vector.js\";\n// This implementation was based on the original MIT-licensed TRACE repository\n// from https://github.com/septagon/TRACE.\n/**\n * Generic implementation of Levenshtein distance.\n */\nvar Levenshtein;\n(function (Levenshtein) {\n    /**\n     * Alphabet from which to construct sequences to be compared using Levenshtein\n     * distance.\n     */\n    class Alphabet {\n        /**\n         * Serialize the Alphabet to JSON string.\n         * @returns JSON serialization\n         */\n        serialize() {\n            const jsonObject = {};\n            const characters = new Array(this._characterToIdx.size);\n            this._characterToIdx.forEach((v, k) => {\n                characters[v] = k;\n            });\n            jsonObject[\"characters\"] = characters;\n            jsonObject[\"insertionCosts\"] = this._insertionCosts;\n            jsonObject[\"deletionCosts\"] = this._deletionCosts;\n            jsonObject[\"substitutionCosts\"] = this._substitutionCosts;\n            return JSON.stringify(jsonObject);\n        }\n        /**\n         * Parse an Alphabet from a JSON serialization.\n         * @param json JSON string to deserialize\n         * @returns deserialized Alphabet\n         */\n        static Deserialize(json) {\n            const jsonObject = JSON.parse(json);\n            const alphabet = new Alphabet(jsonObject[\"characters\"]);\n            alphabet._insertionCosts = jsonObject[\"insertionCosts\"];\n            alphabet._deletionCosts = jsonObject[\"deletionCosts\"];\n            alphabet._substitutionCosts = jsonObject[\"substitutionCosts\"];\n            return alphabet;\n        }\n        /**\n         * Create a new Alphabet.\n         * @param characters characters of the alphabet\n         * @param charToInsertionCost function mapping characters to insertion costs\n         * @param charToDeletionCost function mapping characters to deletion costs\n         * @param charsToSubstitutionCost function mapping character pairs to substitution costs\n         */\n        constructor(characters, charToInsertionCost = null, charToDeletionCost = null, charsToSubstitutionCost = null) {\n            charToInsertionCost = charToInsertionCost !== null && charToInsertionCost !== void 0 ? charToInsertionCost : (() => 1);\n            charToDeletionCost = charToDeletionCost !== null && charToDeletionCost !== void 0 ? charToDeletionCost : (() => 1);\n            charsToSubstitutionCost = charsToSubstitutionCost !== null && charsToSubstitutionCost !== void 0 ? charsToSubstitutionCost : ((a, b) => (a === b ? 0 : 1));\n            this._characterToIdx = new Map();\n            this._insertionCosts = new Array(characters.length);\n            this._deletionCosts = new Array(characters.length);\n            this._substitutionCosts = new Array(characters.length);\n            let c;\n            for (let outerIdx = 0; outerIdx < characters.length; ++outerIdx) {\n                c = characters[outerIdx];\n                this._characterToIdx.set(c, outerIdx);\n                this._insertionCosts[outerIdx] = charToInsertionCost(c);\n                this._deletionCosts[outerIdx] = charToDeletionCost(c);\n                this._substitutionCosts[outerIdx] = new Array(characters.length);\n                for (let innerIdx = outerIdx; innerIdx < characters.length; ++innerIdx) {\n                    this._substitutionCosts[outerIdx][innerIdx] = charsToSubstitutionCost(c, characters[innerIdx]);\n                }\n            }\n        }\n        /**\n         * Get the index (internally-assigned number) for a character.\n         * @param char character\n         * @returns index\n         */\n        getCharacterIdx(char) {\n            return this._characterToIdx.get(char);\n        }\n        /**\n         * Get the insertion cost of a character from its index.\n         * @param idx character index\n         * @returns insertion cost\n         */\n        getInsertionCost(idx) {\n            return this._insertionCosts[idx];\n        }\n        /**\n         * Get the deletion cost of a character from its index.\n         * @param idx character index\n         * @returns deletion cost\n         */\n        getDeletionCost(idx) {\n            return this._deletionCosts[idx];\n        }\n        /**\n         * Gets the cost to substitute two characters. NOTE: this cost is\n         * required to be bi-directional, meaning it cannot matter which of\n         * the provided characters is being removed and which is being inserted.\n         * @param idx1 the first character index\n         * @param idx2 the second character index\n         * @returns substitution cost\n         */\n        getSubstitutionCost(idx1, idx2) {\n            const min = Math.min(idx1, idx2);\n            const max = Math.max(idx1, idx2);\n            return this._substitutionCosts[min][max];\n        }\n    }\n    Levenshtein.Alphabet = Alphabet;\n    /**\n     * Character sequence intended to be compared against other Sequences created\n     * with the same Alphabet in order to compute Levenshtein distance.\n     */\n    class Sequence {\n        /**\n         * Serialize to JSON string. JSON representation does NOT include the Alphabet\n         * from which this Sequence was created; Alphabet must be independently\n         * serialized.\n         * @returns JSON string\n         */\n        serialize() {\n            return JSON.stringify(this._characters);\n        }\n        /**\n         * Deserialize from JSON string and Alphabet. This should be the same Alphabet\n         * from which the Sequence was originally created, which must be serialized and\n         * deserialized independently so that it can be passed in here.\n         * @param json JSON string representation of Sequence\n         * @param alphabet Alphabet from which Sequence was originally created\n         * @returns Sequence\n         */\n        static Deserialize(json, alphabet) {\n            const sequence = new Sequence([], alphabet);\n            sequence._characters = JSON.parse(json);\n            return sequence;\n        }\n        /**\n         * Create a new Sequence.\n         * @param characters characters in the new Sequence\n         * @param alphabet Alphabet, which must include all used characters\n         */\n        constructor(characters, alphabet) {\n            if (characters.length > Sequence._MAX_SEQUENCE_LENGTH) {\n                throw new Error(\"Sequences longer than \" + Sequence._MAX_SEQUENCE_LENGTH + \" not supported.\");\n            }\n            this._alphabet = alphabet;\n            this._characters = characters.map((c) => this._alphabet.getCharacterIdx(c));\n        }\n        /**\n         * Get the distance between this Sequence and another.\n         * @param other sequence to compare to\n         * @returns Levenshtein distance\n         */\n        distance(other) {\n            return Sequence._Distance(this, other);\n        }\n        /**\n         * Compute the Levenshtein distance between two Sequences.\n         * @param a first Sequence\n         * @param b second Sequence\n         * @returns Levenshtein distance\n         */\n        static _Distance(a, b) {\n            const alphabet = a._alphabet;\n            if (alphabet !== b._alphabet) {\n                throw new Error(\"Cannot Levenshtein compare Sequences built from different alphabets.\");\n            }\n            const aChars = a._characters;\n            const bChars = b._characters;\n            const aLength = aChars.length;\n            const bLength = bChars.length;\n            const costMatrix = Sequence._CostMatrix;\n            costMatrix[0][0] = 0;\n            for (let idx = 0; idx < aLength; ++idx) {\n                costMatrix[idx + 1][0] = costMatrix[idx][0] + alphabet.getInsertionCost(aChars[idx]);\n            }\n            for (let idx = 0; idx < bLength; ++idx) {\n                costMatrix[0][idx + 1] = costMatrix[0][idx] + alphabet.getInsertionCost(bChars[idx]);\n            }\n            for (let aIdx = 0; aIdx < aLength; ++aIdx) {\n                for (let bIdx = 0; bIdx < bLength; ++bIdx) {\n                    Sequence._InsertionCost = costMatrix[aIdx + 1][bIdx] + alphabet.getInsertionCost(bChars[bIdx]);\n                    Sequence._DeletionCost = costMatrix[aIdx][bIdx + 1] + alphabet.getDeletionCost(aChars[aIdx]);\n                    Sequence._SubstitutionCost = costMatrix[aIdx][bIdx] + alphabet.getSubstitutionCost(aChars[aIdx], bChars[bIdx]);\n                    costMatrix[aIdx + 1][bIdx + 1] = Math.min(Sequence._InsertionCost, Sequence._DeletionCost, Sequence._SubstitutionCost);\n                }\n            }\n            return costMatrix[aLength][bLength];\n        }\n    }\n    // Scratch values\n    Sequence._MAX_SEQUENCE_LENGTH = 256;\n    Sequence._CostMatrix = [...Array(Sequence._MAX_SEQUENCE_LENGTH + 1)].map(() => new Array(Sequence._MAX_SEQUENCE_LENGTH + 1));\n    Levenshtein.Sequence = Sequence;\n})(Levenshtein || (Levenshtein = {}));\n/**\n * A 3D trajectory consisting of an order list of vectors describing a\n * path of motion through 3D space.\n */\nexport class Trajectory {\n    /**\n     * Serialize to JSON.\n     * @returns serialized JSON string\n     */\n    serialize() {\n        return JSON.stringify(this);\n    }\n    /**\n     * Deserialize from JSON.\n     * @param json serialized JSON string\n     * @returns deserialized Trajectory\n     */\n    static Deserialize(json) {\n        const jsonObject = JSON.parse(json);\n        const trajectory = new Trajectory(jsonObject[\"_segmentLength\"]);\n        trajectory._points = jsonObject[\"_points\"].map((pt) => {\n            return new Vector3(pt[\"_x\"], pt[\"_y\"], pt[\"_z\"]);\n        });\n        return trajectory;\n    }\n    /**\n     * Create a new empty Trajectory.\n     * @param segmentLength radius of discretization for Trajectory points\n     */\n    constructor(segmentLength = 0.01) {\n        this._points = [];\n        this._segmentLength = segmentLength;\n    }\n    /**\n     * Get the length of the Trajectory.\n     * @returns length of the Trajectory\n     */\n    getLength() {\n        return this._points.length * this._segmentLength;\n    }\n    /**\n     * Append a new point to the Trajectory.\n     * NOTE: This implementation has many allocations.\n     * @param point point to append to the Trajectory\n     */\n    add(point) {\n        let numPoints = this._points.length;\n        if (numPoints === 0) {\n            this._points.push(point.clone());\n        }\n        else {\n            const getT = () => this._segmentLength / Vector3.Distance(this._points[numPoints - 1], point);\n            for (let t = getT(); t <= 1.0; t = getT()) {\n                const newPoint = this._points[numPoints - 1].scale(1.0 - t);\n                point.scaleAndAddToRef(t, newPoint);\n                this._points.push(newPoint);\n                ++numPoints;\n            }\n        }\n    }\n    /**\n     * Create a new Trajectory with a segment length chosen to make it\n     * probable that the new Trajectory will have a specified number of\n     * segments. This operation is imprecise.\n     * @param targetResolution number of segments desired\n     * @returns new Trajectory with approximately the requested number of segments\n     */\n    resampleAtTargetResolution(targetResolution) {\n        const resampled = new Trajectory(this.getLength() / targetResolution);\n        this._points.forEach((pt) => {\n            resampled.add(pt);\n        });\n        return resampled;\n    }\n    /**\n     * Convert Trajectory segments into tokenized representation. This\n     * representation is an array of numbers where each nth number is the\n     * index of the token which is most similar to the nth segment of the\n     * Trajectory.\n     * @param tokens list of vectors which serve as discrete tokens\n     * @returns list of indices of most similar token per segment\n     */\n    tokenize(tokens) {\n        const tokenization = [];\n        const segmentDir = new Vector3();\n        for (let idx = 2; idx < this._points.length; ++idx) {\n            if (Trajectory._TransformSegmentDirToRef(this._points[idx - 2], this._points[idx - 1], this._points[idx], segmentDir)) {\n                tokenization.push(Trajectory._TokenizeSegment(segmentDir, tokens));\n            }\n        }\n        return tokenization;\n    }\n    /**\n     * Transform the rotation (i.e., direction) of a segment to isolate\n     * the relative transformation represented by the segment. This operation\n     * may or may not succeed due to singularities in the equations that define\n     * motion relativity in this context.\n     * @param priorVec the origin of the prior segment\n     * @param fromVec the origin of the current segment\n     * @param toVec the destination of the current segment\n     * @param result reference to output variable\n     * @returns whether or not transformation was successful\n     */\n    static _TransformSegmentDirToRef(priorVec, fromVec, toVec, result) {\n        const DOT_PRODUCT_SAMPLE_REJECTION_THRESHOLD = 0.98;\n        fromVec.subtractToRef(priorVec, Trajectory._ForwardDir);\n        Trajectory._ForwardDir.normalize();\n        fromVec.scaleToRef(-1, Trajectory._InverseFromVec);\n        Trajectory._InverseFromVec.normalize();\n        if (Math.abs(Vector3.Dot(Trajectory._ForwardDir, Trajectory._InverseFromVec)) > DOT_PRODUCT_SAMPLE_REJECTION_THRESHOLD) {\n            return false;\n        }\n        Vector3.CrossToRef(Trajectory._ForwardDir, Trajectory._InverseFromVec, Trajectory._UpDir);\n        Trajectory._UpDir.normalize();\n        Matrix.LookAtLHToRef(priorVec, fromVec, Trajectory._UpDir, Trajectory._LookMatrix);\n        toVec.subtractToRef(fromVec, Trajectory._FromToVec);\n        Trajectory._FromToVec.normalize();\n        Vector3.TransformNormalToRef(Trajectory._FromToVec, Trajectory._LookMatrix, result);\n        return true;\n    }\n    /**\n     * Determine which token vector is most similar to the\n     * segment vector.\n     * @param segment segment vector\n     * @param tokens token vector list\n     * @returns index of the most similar token to the segment\n     */\n    static _TokenizeSegment(segment, tokens) {\n        Trajectory._BestMatch = 0;\n        Trajectory._Score = Vector3.Dot(segment, tokens[0]);\n        Trajectory._BestScore = Trajectory._Score;\n        for (let idx = 1; idx < tokens.length; ++idx) {\n            Trajectory._Score = Vector3.Dot(segment, tokens[idx]);\n            if (Trajectory._Score > Trajectory._BestScore) {\n                Trajectory._BestMatch = idx;\n                Trajectory._BestScore = Trajectory._Score;\n            }\n        }\n        return Trajectory._BestMatch;\n    }\n}\nTrajectory._ForwardDir = new Vector3();\nTrajectory._InverseFromVec = new Vector3();\nTrajectory._UpDir = new Vector3();\nTrajectory._FromToVec = new Vector3();\nTrajectory._LookMatrix = new Matrix();\n/**\n * Collection of vectors intended to be used as the basis of Trajectory\n * tokenization for Levenshtein distance comparison. Canonically, a\n * Vector3Alphabet will resemble a \"spikeball\" of vectors distributed\n * roughly evenly over the surface of the unit sphere.\n */\nclass Vector3Alphabet {\n    /**\n     * Helper method to create new \"spikeball\" Vector3Alphabets. Uses a naive\n     * optimize-from-random strategy to space points around the unit sphere\n     * surface as a simple alternative to really doing the math to tile the\n     * sphere.\n     * @param alphabetSize size of the desired alphabet\n     * @param iterations number of iterations over which to optimize the \"spikeball\"\n     * @param startingStepSize distance factor to move points in early optimization iterations\n     * @param endingStepSize distance factor to move points in late optimization iterations\n     * @param fixedValues alphabet \"characters\" that are required and cannot be moved by optimization\n     * @returns a new randomly generated and optimized Vector3Alphabet of the specified size\n     */\n    static Generate(alphabetSize = 64, iterations = 256, startingStepSize = 0.1, endingStepSize = 0.001, fixedValues = []) {\n        const EPSILON = 0.001;\n        const EPSILON_SQUARED = EPSILON * EPSILON;\n        const alphabet = new Vector3Alphabet(alphabetSize);\n        for (let idx = 0; idx < alphabetSize; ++idx) {\n            alphabet.chars[idx] = new Vector3(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5);\n            alphabet.chars[idx].normalize();\n        }\n        for (let idx = 0; idx < fixedValues.length; ++idx) {\n            alphabet.chars[idx].copyFrom(fixedValues[idx]);\n        }\n        let stepSize;\n        let distSq;\n        const force = new Vector3();\n        const scratch = new Vector3();\n        const lerp = (l, r, t) => (1.0 - t) * l + t * r;\n        for (let iteration = 0; iteration < iterations; ++iteration) {\n            stepSize = lerp(startingStepSize, endingStepSize, iteration / (iterations - 1));\n            for (let idx = fixedValues.length; idx < alphabet.chars.length; ++idx) {\n                force.copyFromFloats(0, 0, 0);\n                alphabet.chars.forEach((pt) => {\n                    alphabet.chars[idx].subtractToRef(pt, scratch);\n                    distSq = scratch.lengthSquared();\n                    if (distSq > EPSILON_SQUARED) {\n                        scratch.scaleAndAddToRef(1 / (scratch.lengthSquared() * distSq), force);\n                    }\n                });\n                force.scaleInPlace(stepSize);\n                alphabet.chars[idx].addInPlace(force);\n                alphabet.chars[idx].normalize();\n            }\n        }\n        return alphabet;\n    }\n    /**\n     * Serialize to JSON.\n     * @returns JSON serialization\n     */\n    serialize() {\n        return JSON.stringify(this.chars);\n    }\n    /**\n     * Deserialize from JSON.\n     * @param json JSON serialization\n     * @returns deserialized Vector3Alphabet\n     */\n    static Deserialize(json) {\n        const jsonObject = JSON.parse(json);\n        const alphabet = new Vector3Alphabet(jsonObject.length);\n        for (let idx = 0; idx < jsonObject.length; ++idx) {\n            alphabet.chars[idx] = new Vector3(jsonObject[idx][\"_x\"], jsonObject[idx][\"_y\"], jsonObject[idx][\"_z\"]);\n        }\n        return alphabet;\n    }\n    constructor(size) {\n        this.chars = new Array(size);\n    }\n}\n/**\n * Class which formalizes the manner in which a Vector3Alphabet is used to tokenize and\n * describe a Trajectory. This class houses the functionality which determines what\n * attributes of Trajectories are and are not considered important, such as scale.\n */\nclass TrajectoryDescriptor {\n    /**\n     * Serialize to JSON.\n     * @returns JSON serialization\n     */\n    serialize() {\n        return JSON.stringify(this._sequences.map((sequence) => sequence.serialize()));\n    }\n    /**\n     * Deserialize from JSON string and Alphabet. This should be the same Alphabet\n     * from which the descriptor was originally created, which must be serialized and\n     * deserialized independently so that it can be passed in here.\n     * @param json JSON serialization\n     * @param alphabet Alphabet from which descriptor was originally created\n     * @returns deserialized TrajectoryDescriptor\n     */\n    static Deserialize(json, alphabet) {\n        const descriptor = new TrajectoryDescriptor();\n        descriptor._sequences = JSON.parse(json).map((s) => Levenshtein.Sequence.Deserialize(s, alphabet));\n        return descriptor;\n    }\n    /**\n     * Create a new TrajectoryDescriptor to describe a provided Trajectory according\n     * to the provided alphabets.\n     * @param trajectory Trajectory to be described\n     * @param vector3Alphabet Vector3Alphabet to be used to tokenize the Trajectory\n     * @param levenshteinAlphabet Levenshtein.Alphabet to be used as basis for comparison with other descriptors\n     * @returns TrajectoryDescriptor describing provided Trajectory\n     */\n    static CreateFromTrajectory(trajectory, vector3Alphabet, levenshteinAlphabet) {\n        return TrajectoryDescriptor.CreateFromTokenizationPyramid(TrajectoryDescriptor._GetTokenizationPyramid(trajectory, vector3Alphabet), levenshteinAlphabet);\n    }\n    /**\n     * Create a new TrajectoryDescriptor from a pre-existing pyramid of tokens.\n     * NOTE: This function exists to support an outdated serialization mechanism and should\n     * be deleted if it is no longer useful.\n     * @param pyramid tokenization pyramid\n     * @param levenshteinAlphabet Levenshtein.Alphabet to be uses as basis for comparison with other descriptors\n     * @returns TrajectoryDescriptor describing the Trajectory from which the pyramid was built\n     */\n    static CreateFromTokenizationPyramid(pyramid, levenshteinAlphabet) {\n        const descriptor = new TrajectoryDescriptor();\n        descriptor._sequences = pyramid.map((tokens) => new Levenshtein.Sequence(tokens, levenshteinAlphabet));\n        return descriptor;\n    }\n    constructor() {\n        this._sequences = [];\n    }\n    /**\n     * Create the tokenization pyramid for the provided Trajectory according to the given\n     * Vector3Alphabet.\n     * @param trajectory Trajectory to be tokenized\n     * @param alphabet Vector3Alphabet containing tokens\n     * @param targetResolution finest resolution of descriptor\n     * @returns tokenization pyramid for Trajectory\n     */\n    static _GetTokenizationPyramid(trajectory, alphabet, targetResolution = TrajectoryDescriptor._FINEST_DESCRIPTOR_RESOLUTION) {\n        const pyramid = [];\n        for (let res = targetResolution; res > 4; res = Math.floor(res / 2)) {\n            pyramid.push(trajectory.resampleAtTargetResolution(res).tokenize(alphabet.chars));\n        }\n        return pyramid;\n    }\n    /**\n     * Calculate a distance metric between this TrajectoryDescriptor and another. This is\n     * essentially a similarity score and does not directly represent Euclidean distance,\n     * edit distance, or any other formal distance metric.\n     * @param other TrajectoryDescriptor from which to determine distance\n     * @returns distance, a nonnegative similarity score where larger values indicate dissimilarity\n     */\n    distance(other) {\n        let totalDistance = 0;\n        let weight;\n        for (let idx = 0; idx < this._sequences.length; ++idx) {\n            weight = Math.pow(2, idx);\n            totalDistance += weight * this._sequences[idx].distance(other._sequences[idx]);\n        }\n        return totalDistance;\n    }\n}\nTrajectoryDescriptor._FINEST_DESCRIPTOR_RESOLUTION = 32;\n/**\n * A set of TrajectoryDescriptors defined to be \"the same.\" This is essentially a helper\n * class to facilitate methods of Trajectory clustering.\n */\nclass TrajectoryClass {\n    /**\n     * Serialize to JSON.\n     * @returns JSON serialization\n     */\n    serialize() {\n        const jsonObject = {};\n        jsonObject.descriptors = this._descriptors.map((desc) => desc.serialize());\n        jsonObject.centroidIdx = this._centroidIdx;\n        jsonObject.averageDistance = this._averageDistance;\n        return JSON.stringify(jsonObject);\n    }\n    /**\n     * Deserialize from JSON string and Alphabet. This should be the same Alphabet\n     * from which the descriptors were originally created, which must be serialized and\n     * deserialized independently so that it can be passed in here.\n     * @param json JSON string representation\n     * @param alphabet Alphabet from which TrajectoryDescriptors were originally created\n     * @returns deserialized TrajectoryDescriptor\n     */\n    static Deserialize(json, alphabet) {\n        const jsonObject = JSON.parse(json);\n        const described = new TrajectoryClass();\n        described._descriptors = jsonObject.descriptors.map((s) => TrajectoryDescriptor.Deserialize(s, alphabet));\n        described._centroidIdx = jsonObject.centroidIdx;\n        described._averageDistance = jsonObject.averageDistance;\n        return described;\n    }\n    /**\n     * Create a new DescribedTrajectory.\n     * @param descriptors currently-known TrajectoryDescriptors, if any\n     */\n    constructor(descriptors = []) {\n        this._descriptors = descriptors;\n        this._centroidIdx = -1;\n        this._averageDistance = 0;\n        this._refreshDescription();\n    }\n    /**\n     * Add a new TrajectoryDescriptor to the list of descriptors known to describe\n     * this same DescribedTrajectory.\n     * @param descriptor descriptor to be added\n     */\n    add(descriptor) {\n        this._descriptors.push(descriptor);\n        this._refreshDescription();\n    }\n    /**\n     * Compute the cost, which is inversely related to the likelihood that the provided\n     * TrajectoryDescriptor describes a Trajectory that is considered to be the same as\n     * the class represented by this DescribedTrajectory.\n     * @param descriptor the descriptor to be costed\n     * @returns cost of the match, which is a nonnegative similarity metric where larger values indicate dissimilarity\n     */\n    getMatchCost(descriptor) {\n        return descriptor.distance(this._descriptors[this._centroidIdx]) / this._averageDistance;\n    }\n    /**\n     * Compute the minimum distance between the queried TrajectoryDescriptor and a\n     * descriptor which is a member of this collection. This is an alternative way of\n     * conceptualizing match cost from getMatchCost(), and it serves a different function.\n     * @param descriptor the descriptor to find the minimum distance to\n     * @returns minimum descriptor distance to a member descriptor of this DescribedTrajectory\n     */\n    getMatchMinimumDistance(descriptor) {\n        return Math.min(...this._descriptors.map((desc) => desc.distance(descriptor)));\n    }\n    /**\n     * Refreshes the internal representation of this DescribedTrajectory.\n     */\n    _refreshDescription() {\n        this._centroidIdx = -1;\n        let sum;\n        const distances = this._descriptors.map((a) => {\n            sum = 0;\n            this._descriptors.forEach((b) => {\n                sum += a.distance(b);\n            });\n            return sum;\n        });\n        for (let idx = 0; idx < distances.length; ++idx) {\n            if (this._centroidIdx < 0 || distances[idx] < distances[this._centroidIdx]) {\n                this._centroidIdx = idx;\n            }\n        }\n        this._averageDistance = 0;\n        this._descriptors.forEach((desc) => {\n            this._averageDistance += desc.distance(this._descriptors[this._centroidIdx]);\n        });\n        if (this._descriptors.length > 0) {\n            this._averageDistance = Math.max(this._averageDistance / this._descriptors.length, TrajectoryClass._MIN_AVERAGE_DISTANCE);\n        }\n    }\n}\nTrajectoryClass._MIN_AVERAGE_DISTANCE = 1;\n/**\n * Class representing a set of known, named trajectories to which Trajectories can be\n * added and using which Trajectories can be recognized.\n */\nexport class TrajectoryClassifier {\n    /**\n     * Serialize to JSON.\n     * @returns JSON serialization\n     */\n    serialize() {\n        const jsonObject = {};\n        jsonObject.maximumAllowableMatchCost = this._maximumAllowableMatchCost;\n        jsonObject.vector3Alphabet = this._vector3Alphabet.serialize();\n        jsonObject.levenshteinAlphabet = this._levenshteinAlphabet.serialize();\n        jsonObject.nameToDescribedTrajectory = [];\n        this._nameToDescribedTrajectory.forEach((described, name) => {\n            jsonObject.nameToDescribedTrajectory.push(name);\n            jsonObject.nameToDescribedTrajectory.push(described.serialize());\n        });\n        return JSON.stringify(jsonObject);\n    }\n    /**\n     * Deserialize from JSON.\n     * @param json JSON serialization\n     * @returns deserialized TrajectorySet\n     */\n    static Deserialize(json) {\n        const jsonObject = JSON.parse(json);\n        const classifier = new TrajectoryClassifier();\n        classifier._maximumAllowableMatchCost = jsonObject.maximumAllowableMatchCost;\n        classifier._vector3Alphabet = Vector3Alphabet.Deserialize(jsonObject.vector3Alphabet);\n        classifier._levenshteinAlphabet = Levenshtein.Alphabet.Deserialize(jsonObject.levenshteinAlphabet);\n        for (let idx = 0; idx < jsonObject.nameToDescribedTrajectory.length; idx += 2) {\n            classifier._nameToDescribedTrajectory.set(jsonObject.nameToDescribedTrajectory[idx], TrajectoryClass.Deserialize(jsonObject.nameToDescribedTrajectory[idx + 1], classifier._levenshteinAlphabet));\n        }\n        return classifier;\n    }\n    /**\n     * Initialize a new empty TrajectorySet with auto-generated Alphabets.\n     * VERY naive, need to be generating these things from known\n     * sets. Better version later, probably eliminating this one.\n     * @returns auto-generated TrajectorySet\n     */\n    static Generate() {\n        const vecs = Vector3Alphabet.Generate(64, 256, 0.1, 0.001, [Vector3.Forward()]);\n        const charIdxs = new Array(vecs.chars.length);\n        for (let idx = 0; idx < charIdxs.length; ++idx) {\n            charIdxs[idx] = idx;\n        }\n        const alphabet = new Levenshtein.Alphabet(charIdxs, (idx) => (idx === 0 ? 0 : 1), (idx) => (idx === 0 ? 0 : 1), (a, b) => Math.min(1 - Vector3.Dot(vecs.chars[a], vecs.chars[b]), 1));\n        const trajectorySet = new TrajectoryClassifier();\n        trajectorySet._vector3Alphabet = vecs;\n        trajectorySet._levenshteinAlphabet = alphabet;\n        return trajectorySet;\n    }\n    constructor() {\n        this._maximumAllowableMatchCost = 4;\n        this._nameToDescribedTrajectory = new Map();\n    }\n    /**\n     * Add a new Trajectory to the set with a given name.\n     * @param trajectory new Trajectory to be added\n     * @param classification name to which to add the Trajectory\n     */\n    addTrajectoryToClassification(trajectory, classification) {\n        if (!this._nameToDescribedTrajectory.has(classification)) {\n            this._nameToDescribedTrajectory.set(classification, new TrajectoryClass());\n        }\n        this._nameToDescribedTrajectory.get(classification).add(TrajectoryDescriptor.CreateFromTrajectory(trajectory, this._vector3Alphabet, this._levenshteinAlphabet));\n    }\n    /**\n     * Remove a known named trajectory and all Trajectories associated with it.\n     * @param classification name to remove\n     * @returns whether anything was removed\n     */\n    deleteClassification(classification) {\n        return this._nameToDescribedTrajectory.delete(classification);\n    }\n    /**\n     * Attempt to recognize a Trajectory from among all the classifications\n     * already known to the classifier.\n     * @param trajectory Trajectory to be recognized\n     * @returns classification of Trajectory if recognized, null otherwise\n     */\n    classifyTrajectory(trajectory) {\n        const descriptor = TrajectoryDescriptor.CreateFromTrajectory(trajectory, this._vector3Alphabet, this._levenshteinAlphabet);\n        const allowableMatches = [];\n        this._nameToDescribedTrajectory.forEach((trajectoryClass, classification) => {\n            if (trajectoryClass.getMatchCost(descriptor) < this._maximumAllowableMatchCost) {\n                allowableMatches.push(classification);\n            }\n        });\n        if (allowableMatches.length === 0) {\n            return null;\n        }\n        let bestIdx = 0;\n        let bestMatch = this._nameToDescribedTrajectory.get(allowableMatches[bestIdx]).getMatchMinimumDistance(descriptor);\n        let match;\n        for (let idx = 0; idx < allowableMatches.length; ++idx) {\n            match = this._nameToDescribedTrajectory.get(allowableMatches[idx]).getMatchMinimumDistance(descriptor);\n            if (match < bestMatch) {\n                bestMatch = match;\n                bestIdx = idx;\n            }\n        }\n        return allowableMatches[bestIdx];\n    }\n}\n//# sourceMappingURL=trajectoryClassifier.js.map","import { Logger } from \"./logger.js\";\nimport { SceneSerializer } from \"./sceneSerializer.js\";\n/**\n * Class used to connect with the reflector zone of the sandbox via the reflector bridge\n * @since 5.0.0\n */\nexport class Reflector {\n    /**\n     * Constructs a reflector object.\n     * @param scene The scene to use\n     * @param hostname The hostname of the reflector bridge\n     * @param port The port of the reflector bridge\n     */\n    constructor(scene, hostname, port) {\n        this._scene = scene;\n        Logger.Log(`[Reflector] Connecting to ws://${hostname}:${port}`);\n        this._webSocket = new WebSocket(`ws://${hostname}:${port}`);\n        this._webSocket.onmessage = (event) => {\n            const message = event.data;\n            if (message.startsWith(Reflector._SERVER_PREFIX)) {\n                const serverMessage = message.substr(Reflector._SERVER_PREFIX.length);\n                Logger.Log(`[Reflector] Received server message: ${serverMessage.substr(0, 64)}`);\n                this._handleServerMessage(serverMessage);\n                return;\n            }\n            else {\n                Logger.Log(`[Reflector] Received client message: ${message.substr(0, 64)}`);\n                this._handleClientMessage();\n            }\n        };\n        this._webSocket.onclose = (event) => {\n            Logger.Log(`[Reflector] Disconnected ${event.code} ${event.reason}`);\n        };\n    }\n    /**\n     * Closes the reflector connection\n     */\n    close() {\n        this._webSocket.close();\n    }\n    _handleServerMessage(message) {\n        switch (message) {\n            case \"connected\": {\n                SceneSerializer.SerializeAsync(this._scene).then((serialized) => {\n                    this._webSocket.send(`load|${JSON.stringify(serialized)}`);\n                });\n                break;\n            }\n        }\n    }\n    _handleClientMessage() {\n        // do nothing\n    }\n}\nReflector._SERVER_PREFIX = \"$$\";\n//# sourceMappingURL=reflector.js.map","const growthFactor = 1.5;\n/**\n * A class acting as a dynamic float32array used in the performance viewer\n */\nexport class DynamicFloat32Array {\n    /**\n     * Creates a new DynamicFloat32Array with the desired item capacity.\n     * @param itemCapacity The initial item capacity you would like to set for the array.\n     */\n    constructor(itemCapacity) {\n        this._view = new Float32Array(itemCapacity);\n        this._itemLength = 0;\n    }\n    /**\n     * The number of items currently in the array.\n     */\n    get itemLength() {\n        return this._itemLength;\n    }\n    /**\n     * Gets value at index, NaN if no such index exists.\n     * @param index the index to get the value at.\n     * @returns the value at the index provided.\n     */\n    at(index) {\n        if (index < 0 || index >= this._itemLength) {\n            return NaN;\n        }\n        return this._view[index];\n    }\n    /**\n     * Gets a view of the original array from start to end (exclusive of end).\n     * @param start starting index.\n     * @param end ending index.\n     * @returns a subarray of the original array.\n     */\n    subarray(start, end) {\n        if (start >= end || start < 0) {\n            return new Float32Array(0);\n        }\n        if (end > this._itemLength) {\n            end = this._itemLength;\n        }\n        return this._view.subarray(start, end);\n    }\n    /**\n     * Pushes items to the end of the array.\n     * @param item The item to push into the array.\n     */\n    push(item) {\n        this._view[this._itemLength] = item;\n        this._itemLength++;\n        if (this._itemLength >= this._view.length) {\n            this._growArray();\n        }\n    }\n    /**\n     * Grows the array by the growth factor when necessary.\n     */\n    _growArray() {\n        const newCapacity = Math.floor(this._view.length * growthFactor);\n        const view = new Float32Array(newCapacity);\n        view.set(this._view);\n        this._view = view;\n    }\n}\n//# sourceMappingURL=dynamicFloat32Array.js.map","import { EventState, Observable } from \"../observable.js\";\nimport { PrecisionDate } from \"../precisionDate.js\";\nimport { Tools } from \"../tools.js\";\nimport { DynamicFloat32Array } from \"./dynamicFloat32Array.js\";\n// the initial size of our array, should be a multiple of two!\nconst InitialArraySize = 1800;\n// three octets in a hexcode. #[AA][BB][CC], i.e. 24 bits of data.\nconst NumberOfBitsInHexcode = 24;\n// Allows single numeral hex numbers to be appended by a 0.\nconst HexPadding = \"0\";\n// header for the timestamp column\nconst TimestampColHeader = \"timestamp\";\n// header for the numPoints column\nconst NumPointsColHeader = \"numPoints\";\n// regex to capture all carriage returns in the string.\nconst CarriageReturnRegex = /\\r/g;\n// string to use as separator when exporting extra information along with the dataset id\nconst ExportedDataSeparator = \"@\";\n/**\n * The collector class handles the collection and storage of data into the appropriate array.\n * The collector also handles notifying any observers of any updates.\n */\nexport class PerformanceViewerCollector {\n    /**\n     * The offset for when actual data values start appearing inside a slice.\n     */\n    static get SliceDataOffset() {\n        return 2;\n    }\n    /**\n     * The offset for the value of the number of points inside a slice.\n     */\n    static get NumberOfPointsOffset() {\n        return 1;\n    }\n    /**\n     * Handles the creation of a performance viewer collector.\n     * @param _scene the scene to collect on.\n     * @param _enabledStrategyCallbacks the list of data to collect with callbacks for initialization purposes.\n     */\n    constructor(_scene, _enabledStrategyCallbacks) {\n        this._scene = _scene;\n        /**\n         * Collects data for every dataset by using the appropriate strategy. This is called every frame.\n         * This method will then notify all observers with the latest slice.\n         */\n        this._collectDataAtFrame = () => {\n            const timestamp = PrecisionDate.Now - this._startingTimestamp;\n            const numPoints = this.datasets.ids.length;\n            // add the starting index for the slice\n            const numberOfIndices = this.datasets.startingIndices.itemLength;\n            let startingIndex = 0;\n            if (numberOfIndices > 0) {\n                const previousStartingIndex = this.datasets.startingIndices.at(numberOfIndices - 1);\n                startingIndex =\n                    previousStartingIndex + this.datasets.data.at(previousStartingIndex + PerformanceViewerCollector.NumberOfPointsOffset) + PerformanceViewerCollector.SliceDataOffset;\n            }\n            this.datasets.startingIndices.push(startingIndex);\n            // add the first 2 items in our slice.\n            this.datasets.data.push(timestamp);\n            this.datasets.data.push(numPoints);\n            // add the values inside the slice.\n            this.datasets.ids.forEach((id) => {\n                const strategy = this._strategies.get(id);\n                if (!strategy) {\n                    return;\n                }\n                this.datasets.data.push(strategy.getData());\n            });\n            if (this.datasetObservable.hasObservers()) {\n                const slice = [timestamp, numPoints];\n                for (let i = 0; i < numPoints; i++) {\n                    slice.push(this.datasets.data.at(startingIndex + PerformanceViewerCollector.SliceDataOffset + i));\n                }\n                this.datasetObservable.notifyObservers(slice);\n            }\n        };\n        this.datasets = {\n            ids: [],\n            data: new DynamicFloat32Array(InitialArraySize),\n            startingIndices: new DynamicFloat32Array(InitialArraySize),\n        };\n        this._strategies = new Map();\n        this._datasetMeta = new Map();\n        this._eventRestoreSet = new Set();\n        this._customEventObservable = new Observable();\n        this.datasetObservable = new Observable();\n        this.metadataObservable = new Observable((observer) => observer.callback(this._datasetMeta, new EventState(0)));\n        if (_enabledStrategyCallbacks) {\n            this.addCollectionStrategies(..._enabledStrategyCallbacks);\n        }\n    }\n    /**\n     * Registers a custom string event which will be callable via sendEvent. This method returns an event object which will contain the id of the event.\n     * The user can set a value optionally, which will be used in the sendEvent method. If the value is set, we will record this value at the end of each frame,\n     * if not we will increment our counter and record the value of the counter at the end of each frame. The value recorded is 0 if no sendEvent method is called, within a frame.\n     * @param name The name of the event to register\n     * @param forceUpdate if the code should force add an event, and replace the last one.\n     * @param category the category for that event\n     * @returns The event registered, used in sendEvent\n     */\n    registerEvent(name, forceUpdate, category) {\n        var _a;\n        if (this._strategies.has(name) && !forceUpdate) {\n            return;\n        }\n        if (this._strategies.has(name) && forceUpdate) {\n            (_a = this._strategies.get(name)) === null || _a === void 0 ? void 0 : _a.dispose();\n            this._strategies.delete(name);\n        }\n        const strategy = (scene) => {\n            let counter = 0;\n            let value = 0;\n            const afterRenderObserver = scene.onAfterRenderObservable.add(() => {\n                value = counter;\n                counter = 0;\n            });\n            const stringObserver = this._customEventObservable.add((eventVal) => {\n                if (name !== eventVal.name) {\n                    return;\n                }\n                if (eventVal.value !== undefined) {\n                    counter = eventVal.value;\n                }\n                else {\n                    counter++;\n                }\n            });\n            return {\n                id: name,\n                getData: () => value,\n                dispose: () => {\n                    scene.onAfterRenderObservable.remove(afterRenderObserver);\n                    this._customEventObservable.remove(stringObserver);\n                },\n            };\n        };\n        const event = {\n            name,\n        };\n        this._eventRestoreSet.add(name);\n        this.addCollectionStrategies({ strategyCallback: strategy, category });\n        return event;\n    }\n    /**\n     * Lets the perf collector handle an event, occurences or event value depending on if the event.value params is set.\n     * @param event the event to handle an occurence for\n     */\n    sendEvent(event) {\n        this._customEventObservable.notifyObservers(event);\n    }\n    /**\n     * This event restores all custom string events if necessary.\n     */\n    _restoreStringEvents() {\n        if (this._eventRestoreSet.size !== this._customEventObservable.observers.length) {\n            this._eventRestoreSet.forEach((event) => {\n                this.registerEvent(event, true);\n            });\n        }\n    }\n    /**\n     * This method adds additional collection strategies for data collection purposes.\n     * @param strategyCallbacks the list of data to collect with callbacks.\n     */\n    addCollectionStrategies(...strategyCallbacks) {\n        // eslint-disable-next-line prefer-const\n        for (let { strategyCallback, category, hidden } of strategyCallbacks) {\n            const strategy = strategyCallback(this._scene);\n            if (this._strategies.has(strategy.id)) {\n                strategy.dispose();\n                continue;\n            }\n            this.datasets.ids.push(strategy.id);\n            if (category) {\n                category = category.replace(new RegExp(ExportedDataSeparator, \"g\"), \"\");\n            }\n            this._datasetMeta.set(strategy.id, {\n                color: this._getHexColorFromId(strategy.id),\n                category,\n                hidden,\n            });\n            this._strategies.set(strategy.id, strategy);\n        }\n        this.metadataObservable.notifyObservers(this._datasetMeta);\n    }\n    /**\n     * Gets a 6 character hexcode representing the colour from a passed in string.\n     * @param id the string to get a hex code for.\n     * @returns a hexcode hashed from the id.\n     */\n    _getHexColorFromId(id) {\n        // this first bit is just a known way of hashing a string.\n        let hash = 0;\n        for (let i = 0; i < id.length; i++) {\n            // (hash << 5) - hash is the same as hash * 31\n            hash = id.charCodeAt(i) + ((hash << 5) - hash);\n        }\n        // then we build the string octet by octet.\n        let hex = \"#\";\n        for (let i = 0; i < NumberOfBitsInHexcode; i += 8) {\n            const octet = (hash >> i) & 0xff;\n            hex += (HexPadding + octet.toString(16)).substr(-2);\n        }\n        return hex;\n    }\n    /**\n     * Collects and then sends the latest slice to any observers by using the appropriate strategy when the user wants.\n     * The slice will be of the form [timestamp, numberOfPoints, value1, value2...]\n     * This method does not add onto the collected data accessible via the datasets variable.\n     */\n    getCurrentSlice() {\n        const timestamp = PrecisionDate.Now - this._startingTimestamp;\n        const numPoints = this.datasets.ids.length;\n        const slice = [timestamp, numPoints];\n        // add the values inside the slice.\n        this.datasets.ids.forEach((id) => {\n            const strategy = this._strategies.get(id);\n            if (!strategy) {\n                return;\n            }\n            if (this.datasetObservable.hasObservers()) {\n                slice.push(strategy.getData());\n            }\n        });\n        if (this.datasetObservable.hasObservers()) {\n            this.datasetObservable.notifyObservers(slice);\n        }\n    }\n    /**\n     * Updates a property for a dataset's metadata with the value provided.\n     * @param id the id of the dataset which needs its metadata updated.\n     * @param prop the property to update.\n     * @param value the value to update the property with.\n     */\n    updateMetadata(id, prop, value) {\n        const meta = this._datasetMeta.get(id);\n        if (!meta) {\n            return;\n        }\n        meta[prop] = value;\n        this.metadataObservable.notifyObservers(this._datasetMeta);\n    }\n    /**\n     * Completely clear, data, ids, and strategies saved to this performance collector.\n     * @param preserveStringEventsRestore if it should preserve the string events, by default will clear string events registered when called.\n     */\n    clear(preserveStringEventsRestore) {\n        this.datasets.data = new DynamicFloat32Array(InitialArraySize);\n        this.datasets.ids.length = 0;\n        this.datasets.startingIndices = new DynamicFloat32Array(InitialArraySize);\n        this._datasetMeta.clear();\n        this._strategies.forEach((strategy) => strategy.dispose());\n        this._strategies.clear();\n        if (!preserveStringEventsRestore) {\n            this._eventRestoreSet.clear();\n        }\n        this._hasLoadedData = false;\n    }\n    /**\n     * Accessor which lets the caller know if the performance collector has data loaded from a file or not!\n     * Call clear() to reset this value.\n     * @returns true if the data is loaded from a file, false otherwise.\n     */\n    get hasLoadedData() {\n        return this._hasLoadedData;\n    }\n    /**\n     * Given a string containing file data, this function parses the file data into the datasets object.\n     * It returns a boolean to indicate if this object was successfully loaded with the data.\n     * @param data string content representing the file data.\n     * @param keepDatasetMeta if it should use reuse the existing dataset metadata\n     * @returns true if the data was successfully loaded, false otherwise.\n     */\n    loadFromFileData(data, keepDatasetMeta) {\n        const lines = data\n            .replace(CarriageReturnRegex, \"\")\n            .split(\"\\n\")\n            .map((line) => line.split(\",\").filter((s) => s.length > 0))\n            .filter((line) => line.length > 0);\n        const timestampIndex = 0;\n        const numPointsIndex = PerformanceViewerCollector.NumberOfPointsOffset;\n        if (lines.length < 2) {\n            return false;\n        }\n        const parsedDatasets = {\n            ids: [],\n            data: new DynamicFloat32Array(InitialArraySize),\n            startingIndices: new DynamicFloat32Array(InitialArraySize),\n        };\n        // parse first line separately to populate ids!\n        const [firstLine, ...dataLines] = lines;\n        // make sure we have the correct beginning headers\n        if (firstLine.length < 2 || firstLine[timestampIndex] !== TimestampColHeader || firstLine[numPointsIndex] !== NumPointsColHeader) {\n            return false;\n        }\n        const idCategoryMap = new Map();\n        // populate the ids.\n        for (let i = PerformanceViewerCollector.SliceDataOffset; i < firstLine.length; i++) {\n            const [id, category] = firstLine[i].split(ExportedDataSeparator);\n            parsedDatasets.ids.push(id);\n            idCategoryMap.set(id, category);\n        }\n        let startingIndex = 0;\n        for (const line of dataLines) {\n            if (line.length < 2) {\n                return false;\n            }\n            const timestamp = parseFloat(line[timestampIndex]);\n            const numPoints = parseInt(line[numPointsIndex]);\n            if (isNaN(numPoints) || isNaN(timestamp)) {\n                return false;\n            }\n            parsedDatasets.data.push(timestamp);\n            parsedDatasets.data.push(numPoints);\n            if (numPoints + PerformanceViewerCollector.SliceDataOffset !== line.length) {\n                return false;\n            }\n            for (let i = PerformanceViewerCollector.SliceDataOffset; i < line.length; i++) {\n                const val = parseFloat(line[i]);\n                if (isNaN(val)) {\n                    return false;\n                }\n                parsedDatasets.data.push(val);\n            }\n            parsedDatasets.startingIndices.push(startingIndex);\n            startingIndex += line.length;\n        }\n        this.datasets.ids = parsedDatasets.ids;\n        this.datasets.data = parsedDatasets.data;\n        this.datasets.startingIndices = parsedDatasets.startingIndices;\n        if (!keepDatasetMeta) {\n            this._datasetMeta.clear();\n        }\n        this._strategies.forEach((strategy) => strategy.dispose());\n        this._strategies.clear();\n        // populate metadata.\n        if (!keepDatasetMeta) {\n            for (const id of this.datasets.ids) {\n                const category = idCategoryMap.get(id);\n                this._datasetMeta.set(id, { category, color: this._getHexColorFromId(id) });\n            }\n        }\n        this.metadataObservable.notifyObservers(this._datasetMeta);\n        this._hasLoadedData = true;\n        return true;\n    }\n    /**\n     * Exports the datasets inside of the collector to a csv.\n     */\n    exportDataToCsv() {\n        let csvContent = \"\";\n        // create the header line.\n        csvContent += `${TimestampColHeader},${NumPointsColHeader}`;\n        for (let i = 0; i < this.datasets.ids.length; i++) {\n            csvContent += `,${this.datasets.ids[i]}`;\n            if (this._datasetMeta) {\n                const meta = this._datasetMeta.get(this.datasets.ids[i]);\n                if (meta === null || meta === void 0 ? void 0 : meta.category) {\n                    csvContent += `${ExportedDataSeparator}${meta.category}`;\n                }\n            }\n        }\n        csvContent += \"\\n\";\n        // create the data lines\n        for (let i = 0; i < this.datasets.startingIndices.itemLength; i++) {\n            const startingIndex = this.datasets.startingIndices.at(i);\n            const timestamp = this.datasets.data.at(startingIndex);\n            const numPoints = this.datasets.data.at(startingIndex + PerformanceViewerCollector.NumberOfPointsOffset);\n            csvContent += `${timestamp},${numPoints}`;\n            for (let offset = 0; offset < numPoints; offset++) {\n                csvContent += `,${this.datasets.data.at(startingIndex + PerformanceViewerCollector.SliceDataOffset + offset)}`;\n            }\n            // add extra commas.\n            for (let diff = 0; diff < this.datasets.ids.length - numPoints; diff++) {\n                csvContent += \",\";\n            }\n            csvContent += \"\\n\";\n        }\n        const fileName = `${new Date().toISOString()}-perfdata.csv`;\n        Tools.Download(new Blob([csvContent], { type: \"text/csv\" }), fileName);\n    }\n    /**\n     * Starts the realtime collection of data.\n     * @param shouldPreserve optional boolean param, if set will preserve the dataset between calls of start.\n     */\n    start(shouldPreserve) {\n        if (!shouldPreserve) {\n            this.datasets.data = new DynamicFloat32Array(InitialArraySize);\n            this.datasets.startingIndices = new DynamicFloat32Array(InitialArraySize);\n            this._startingTimestamp = PrecisionDate.Now;\n        }\n        else if (this._startingTimestamp === undefined) {\n            this._startingTimestamp = PrecisionDate.Now;\n        }\n        this._scene.onAfterRenderObservable.add(this._collectDataAtFrame);\n        this._restoreStringEvents();\n        this._isStarted = true;\n    }\n    /**\n     * Stops the collection of data.\n     */\n    stop() {\n        this._scene.onAfterRenderObservable.removeCallback(this._collectDataAtFrame);\n        this._isStarted = false;\n    }\n    /**\n     * Returns if the perf collector has been started or not.\n     */\n    get isStarted() {\n        return this._isStarted;\n    }\n    /**\n     * Disposes of the object\n     */\n    dispose() {\n        this._scene.onAfterRenderObservable.removeCallback(this._collectDataAtFrame);\n        this._datasetMeta.clear();\n        this._strategies.forEach((strategy) => {\n            strategy.dispose();\n        });\n        this.datasetObservable.clear();\n        this.metadataObservable.clear();\n        this._isStarted = false;\n        this.datasets = null;\n    }\n}\n//# sourceMappingURL=performanceViewerCollector.js.map","import { Scene } from \"../../scene.js\";\nimport { PerformanceViewerCollector } from \"./performanceViewerCollector.js\";\nScene.prototype.getPerfCollector = function () {\n    if (!this._perfCollector) {\n        this._perfCollector = new PerformanceViewerCollector(this);\n    }\n    return this._perfCollector;\n};\n//# sourceMappingURL=performanceViewerSceneExtension.js.map","import { Observable } from \"./observable.js\";\nimport { runCoroutineAsync, inlineScheduler } from \"./coroutine.js\";\nfunction CreateObservableScheduler(observable) {\n    const coroutines = new Array();\n    const onSteps = new Array();\n    const onErrors = new Array();\n    const observer = observable.add(() => {\n        const count = coroutines.length;\n        for (let i = 0; i < count; i++) {\n            inlineScheduler(coroutines.shift(), onSteps.shift(), onErrors.shift());\n        }\n    });\n    const scheduler = (coroutine, onStep, onError) => {\n        coroutines.push(coroutine);\n        onSteps.push(onStep);\n        onErrors.push(onError);\n    };\n    return {\n        scheduler: scheduler,\n        dispose: () => {\n            observable.remove(observer);\n        },\n    };\n}\nObservable.prototype.runCoroutineAsync = function (coroutine) {\n    if (!this._coroutineScheduler) {\n        const schedulerAndDispose = CreateObservableScheduler(this);\n        this._coroutineScheduler = schedulerAndDispose.scheduler;\n        this._coroutineSchedulerDispose = schedulerAndDispose.dispose;\n    }\n    return runCoroutineAsync(coroutine, this._coroutineScheduler);\n};\nObservable.prototype.cancelAllCoroutines = function () {\n    if (this._coroutineSchedulerDispose) {\n        this._coroutineSchedulerDispose();\n    }\n    this._coroutineScheduler = undefined;\n    this._coroutineSchedulerDispose = undefined;\n};\n//# sourceMappingURL=observableCoroutine.js.map","import { Logger } from \"./logger.js\";\nimport { GetClass } from \"./typeStore.js\";\n/**\n * Class used to enable instantiation of objects by class name\n */\nexport class InstantiationTools {\n    /**\n     * Tries to instantiate a new object from a given class name\n     * @param className defines the class name to instantiate\n     * @returns the new object or null if the system was not able to do the instantiation\n     */\n    static Instantiate(className) {\n        if (this.RegisteredExternalClasses && this.RegisteredExternalClasses[className]) {\n            return this.RegisteredExternalClasses[className];\n        }\n        const internalClass = GetClass(className);\n        if (internalClass) {\n            return internalClass;\n        }\n        Logger.Warn(className + \" not found, you may have missed an import.\");\n        const arr = className.split(\".\");\n        let fn = window || this;\n        for (let i = 0, len = arr.length; i < len; i++) {\n            fn = fn[arr[i]];\n        }\n        if (typeof fn !== \"function\") {\n            return null;\n        }\n        return fn;\n    }\n}\n/**\n * Use this object to register external classes like custom textures or material\n * to allow the loaders to instantiate them\n */\nInstantiationTools.RegisteredExternalClasses = {};\n//# sourceMappingURL=instantiationTools.js.map","/* eslint-disable @typescript-eslint/naming-convention */\nimport { Logger } from \"../Misc/logger.js\";\n/**\n * for description see https://www.khronos.org/opengles/sdk/tools/KTX/\n * for file layout see https://www.khronos.org/opengles/sdk/tools/KTX/file_format_spec/\n */\nexport class KhronosTextureContainer {\n    /**\n     * Creates a new KhronosTextureContainer\n     * @param data contents of the KTX container file\n     * @param facesExpected should be either 1 or 6, based whether a cube texture or or\n     */\n    constructor(\n    /** contents of the KTX container file */\n    data, facesExpected) {\n        this.data = data;\n        /**\n         * If the container has been made invalid (eg. constructor failed to correctly load array buffer)\n         */\n        this.isInvalid = false;\n        if (!KhronosTextureContainer.IsValid(data)) {\n            this.isInvalid = true;\n            Logger.Error(\"texture missing KTX identifier\");\n            return;\n        }\n        // load the reset of the header in native 32 bit uint\n        const dataSize = Uint32Array.BYTES_PER_ELEMENT;\n        const headerDataView = new DataView(this.data.buffer, this.data.byteOffset + 12, 13 * dataSize);\n        const endianness = headerDataView.getUint32(0, true);\n        const littleEndian = endianness === 0x04030201;\n        this.glType = headerDataView.getUint32(1 * dataSize, littleEndian); // must be 0 for compressed textures\n        this.glTypeSize = headerDataView.getUint32(2 * dataSize, littleEndian); // must be 1 for compressed textures\n        this.glFormat = headerDataView.getUint32(3 * dataSize, littleEndian); // must be 0 for compressed textures\n        this.glInternalFormat = headerDataView.getUint32(4 * dataSize, littleEndian); // the value of arg passed to gl.compressedTexImage2D(,,x,,,,)\n        this.glBaseInternalFormat = headerDataView.getUint32(5 * dataSize, littleEndian); // specify GL_RGB, GL_RGBA, GL_ALPHA, etc (un-compressed only)\n        this.pixelWidth = headerDataView.getUint32(6 * dataSize, littleEndian); // level 0 value of arg passed to gl.compressedTexImage2D(,,,x,,,)\n        this.pixelHeight = headerDataView.getUint32(7 * dataSize, littleEndian); // level 0 value of arg passed to gl.compressedTexImage2D(,,,,x,,)\n        this.pixelDepth = headerDataView.getUint32(8 * dataSize, littleEndian); // level 0 value of arg passed to gl.compressedTexImage3D(,,,,,x,,)\n        this.numberOfArrayElements = headerDataView.getUint32(9 * dataSize, littleEndian); // used for texture arrays\n        this.numberOfFaces = headerDataView.getUint32(10 * dataSize, littleEndian); // used for cubemap textures, should either be 1 or 6\n        this.numberOfMipmapLevels = headerDataView.getUint32(11 * dataSize, littleEndian); // number of levels; disregard possibility of 0 for compressed textures\n        this.bytesOfKeyValueData = headerDataView.getUint32(12 * dataSize, littleEndian); // the amount of space after the header for meta-data\n        // Make sure we have a compressed type.  Not only reduces work, but probably better to let dev know they are not compressing.\n        if (this.glType !== 0) {\n            Logger.Error(\"only compressed formats currently supported\");\n            return;\n        }\n        else {\n            // value of zero is an indication to generate mipmaps @ runtime.  Not usually allowed for compressed, so disregard.\n            this.numberOfMipmapLevels = Math.max(1, this.numberOfMipmapLevels);\n        }\n        if (this.pixelHeight === 0 || this.pixelDepth !== 0) {\n            Logger.Error(\"only 2D textures currently supported\");\n            return;\n        }\n        if (this.numberOfArrayElements !== 0) {\n            Logger.Error(\"texture arrays not currently supported\");\n            return;\n        }\n        if (this.numberOfFaces !== facesExpected) {\n            Logger.Error(\"number of faces expected\" + facesExpected + \", but found \" + this.numberOfFaces);\n            return;\n        }\n        // we now have a completely validated file, so could use existence of loadType as success\n        // would need to make this more elaborate & adjust checks above to support more than one load type\n        this.loadType = KhronosTextureContainer.COMPRESSED_2D;\n    }\n    /**\n     * Uploads KTX content to a Babylon Texture.\n     * It is assumed that the texture has already been created & is currently bound\n     * @internal\n     */\n    uploadLevels(texture, loadMipmaps) {\n        switch (this.loadType) {\n            case KhronosTextureContainer.COMPRESSED_2D:\n                this._upload2DCompressedLevels(texture, loadMipmaps);\n                break;\n            case KhronosTextureContainer.TEX_2D:\n            case KhronosTextureContainer.COMPRESSED_3D:\n            case KhronosTextureContainer.TEX_3D:\n        }\n    }\n    _upload2DCompressedLevels(texture, loadMipmaps) {\n        // initialize width & height for level 1\n        let dataOffset = KhronosTextureContainer.HEADER_LEN + this.bytesOfKeyValueData;\n        let width = this.pixelWidth;\n        let height = this.pixelHeight;\n        const mipmapCount = loadMipmaps ? this.numberOfMipmapLevels : 1;\n        for (let level = 0; level < mipmapCount; level++) {\n            const imageSize = new Int32Array(this.data.buffer, this.data.byteOffset + dataOffset, 1)[0]; // size per face, since not supporting array cubemaps\n            dataOffset += 4; //image data starts from next multiple of 4 offset. Each face refers to same imagesize field above.\n            for (let face = 0; face < this.numberOfFaces; face++) {\n                const byteArray = new Uint8Array(this.data.buffer, this.data.byteOffset + dataOffset, imageSize);\n                const engine = texture.getEngine();\n                engine._uploadCompressedDataToTextureDirectly(texture, texture.format, width, height, byteArray, face, level);\n                dataOffset += imageSize; // add size of the image for the next face/mipmap\n                dataOffset += 3 - ((imageSize + 3) % 4); // add padding for odd sized image\n            }\n            width = Math.max(1.0, width * 0.5);\n            height = Math.max(1.0, height * 0.5);\n        }\n    }\n    /**\n     * Checks if the given data starts with a KTX file identifier.\n     * @param data the data to check\n     * @returns true if the data is a KTX file or false otherwise\n     */\n    static IsValid(data) {\n        if (data.byteLength >= 12) {\n            // '', 'K', 'T', 'X', ' ', '1', '1', '', '\\r', '\\n', '\\x1A', '\\n'\n            const identifier = new Uint8Array(data.buffer, data.byteOffset, 12);\n            if (identifier[0] === 0xab &&\n                identifier[1] === 0x4b &&\n                identifier[2] === 0x54 &&\n                identifier[3] === 0x58 &&\n                identifier[4] === 0x20 &&\n                identifier[5] === 0x31 &&\n                identifier[6] === 0x31 &&\n                identifier[7] === 0xbb &&\n                identifier[8] === 0x0d &&\n                identifier[9] === 0x0a &&\n                identifier[10] === 0x1a &&\n                identifier[11] === 0x0a) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\nKhronosTextureContainer.HEADER_LEN = 12 + 13 * 4; // identifier + header elements (not including key value meta-data pairs)\n// load types\nKhronosTextureContainer.COMPRESSED_2D = 0; // uses a gl.compressedTexImage2D()\nKhronosTextureContainer.COMPRESSED_3D = 1; // uses a gl.compressedTexImage3D()\nKhronosTextureContainer.TEX_2D = 2; // uses a gl.texImage2D()\nKhronosTextureContainer.TEX_3D = 3; // uses a gl.texImage3D()\n//# sourceMappingURL=khronosTextureContainer.js.map","\nimport { AutoReleaseWorkerPool } from \"./workerPool.js\";\nimport { Tools } from \"./tools.js\";\nimport { EngineFormat, TranscodeTarget } from \"../Materials/Textures/ktx2decoderTypes.js\";\nfunction getAbsoluteUrlOrNull(url) {\n    return url ? Tools.GetAbsoluteUrl(url) : null;\n}\nfunction applyConfig(urls) {\n    if (urls.wasmUASTCToASTC !== null) {\n        KTX2DECODER.LiteTranscoder_UASTC_ASTC.WasmModuleURL = urls.wasmUASTCToASTC;\n    }\n    if (urls.wasmUASTCToBC7 !== null) {\n        KTX2DECODER.LiteTranscoder_UASTC_BC7.WasmModuleURL = urls.wasmUASTCToBC7;\n    }\n    if (urls.wasmUASTCToRGBA_UNORM !== null) {\n        KTX2DECODER.LiteTranscoder_UASTC_RGBA_UNORM.WasmModuleURL = urls.wasmUASTCToRGBA_UNORM;\n    }\n    if (urls.wasmUASTCToRGBA_SRGB !== null) {\n        KTX2DECODER.LiteTranscoder_UASTC_RGBA_SRGB.WasmModuleURL = urls.wasmUASTCToRGBA_SRGB;\n    }\n    if (urls.wasmUASTCToR8_UNORM !== null) {\n        KTX2DECODER.LiteTranscoder_UASTC_R8_UNORM.WasmModuleURL = urls.wasmUASTCToR8_UNORM;\n    }\n    if (urls.wasmUASTCToRG8_UNORM !== null) {\n        KTX2DECODER.LiteTranscoder_UASTC_RG8_UNORM.WasmModuleURL = urls.wasmUASTCToRG8_UNORM;\n    }\n    if (urls.jsMSCTranscoder !== null) {\n        KTX2DECODER.MSCTranscoder.JSModuleURL = urls.jsMSCTranscoder;\n    }\n    if (urls.wasmMSCTranscoder !== null) {\n        KTX2DECODER.MSCTranscoder.WasmModuleURL = urls.wasmMSCTranscoder;\n    }\n    if (urls.wasmZSTDDecoder !== null) {\n        KTX2DECODER.ZSTDDecoder.WasmModuleURL = urls.wasmZSTDDecoder;\n    }\n}\n/**\n * Class that defines the default KTX2 decoder options.\n *\n * This class is useful for providing options to the KTX2 decoder to control how the source data is transcoded.\n */\nexport class DefaultKTX2DecoderOptions {\n    constructor() {\n        this._isDirty = true;\n        this._useRGBAIfOnlyBC1BC3AvailableWhenUASTC = true;\n        this._ktx2DecoderOptions = {};\n    }\n    /**\n     * Gets the dirty flag\n     */\n    get isDirty() {\n        return this._isDirty;\n    }\n    /**\n     * force a (uncompressed) RGBA transcoded format if transcoding a UASTC source format and ASTC + BC7 are not available as a compressed transcoded format\n     */\n    get useRGBAIfASTCBC7NotAvailableWhenUASTC() {\n        return this._useRGBAIfASTCBC7NotAvailableWhenUASTC;\n    }\n    set useRGBAIfASTCBC7NotAvailableWhenUASTC(value) {\n        if (this._useRGBAIfASTCBC7NotAvailableWhenUASTC === value) {\n            return;\n        }\n        this._useRGBAIfASTCBC7NotAvailableWhenUASTC = value;\n        this._isDirty = true;\n    }\n    /**\n     * force a (uncompressed) RGBA transcoded format if transcoding a UASTC source format and only BC1 or BC3 are available as a compressed transcoded format.\n     * This property is true by default to favor speed over memory, because currently transcoding from UASTC to BC1/3 is slow because the transcoder transcodes\n     * to uncompressed and then recompresses the texture\n     */\n    get useRGBAIfOnlyBC1BC3AvailableWhenUASTC() {\n        return this._useRGBAIfOnlyBC1BC3AvailableWhenUASTC;\n    }\n    set useRGBAIfOnlyBC1BC3AvailableWhenUASTC(value) {\n        if (this._useRGBAIfOnlyBC1BC3AvailableWhenUASTC === value) {\n            return;\n        }\n        this._useRGBAIfOnlyBC1BC3AvailableWhenUASTC = value;\n        this._isDirty = true;\n    }\n    /**\n     * force to always use (uncompressed) RGBA for transcoded format\n     */\n    get forceRGBA() {\n        return this._forceRGBA;\n    }\n    set forceRGBA(value) {\n        if (this._forceRGBA === value) {\n            return;\n        }\n        this._forceRGBA = value;\n        this._isDirty = true;\n    }\n    /**\n     * force to always use (uncompressed) R8 for transcoded format\n     */\n    get forceR8() {\n        return this._forceR8;\n    }\n    set forceR8(value) {\n        if (this._forceR8 === value) {\n            return;\n        }\n        this._forceR8 = value;\n        this._isDirty = true;\n    }\n    /**\n     * force to always use (uncompressed) RG8 for transcoded format\n     */\n    get forceRG8() {\n        return this._forceRG8;\n    }\n    set forceRG8(value) {\n        if (this._forceRG8 === value) {\n            return;\n        }\n        this._forceRG8 = value;\n        this._isDirty = true;\n    }\n    /**\n     * list of transcoders to bypass when looking for a suitable transcoder. The available transcoders are:\n     *      UniversalTranscoder_UASTC_ASTC\n     *      UniversalTranscoder_UASTC_BC7\n     *      UniversalTranscoder_UASTC_RGBA_UNORM\n     *      UniversalTranscoder_UASTC_RGBA_SRGB\n     *      UniversalTranscoder_UASTC_R8_UNORM\n     *      UniversalTranscoder_UASTC_RG8_UNORM\n     *      MSCTranscoder\n     */\n    get bypassTranscoders() {\n        return this._bypassTranscoders;\n    }\n    set bypassTranscoders(value) {\n        if (this._bypassTranscoders === value) {\n            return;\n        }\n        this._bypassTranscoders = value;\n        this._isDirty = true;\n    }\n    /** @internal */\n    _getKTX2DecoderOptions() {\n        if (!this._isDirty) {\n            return this._ktx2DecoderOptions;\n        }\n        this._isDirty = false;\n        const options = {\n            useRGBAIfASTCBC7NotAvailableWhenUASTC: this._useRGBAIfASTCBC7NotAvailableWhenUASTC,\n            forceRGBA: this._forceRGBA,\n            forceR8: this._forceR8,\n            forceRG8: this._forceRG8,\n            bypassTranscoders: this._bypassTranscoders,\n        };\n        if (this.useRGBAIfOnlyBC1BC3AvailableWhenUASTC) {\n            options.transcodeFormatDecisionTree = {\n                UASTC: {\n                    transcodeFormat: [TranscodeTarget.BC1_RGB, TranscodeTarget.BC3_RGBA],\n                    yes: {\n                        transcodeFormat: TranscodeTarget.RGBA32,\n                        engineFormat: EngineFormat.RGBA8Format,\n                        roundToMultiple4: false,\n                    },\n                },\n            };\n        }\n        this._ktx2DecoderOptions = options;\n        return options;\n    }\n}\n/**\n * Class for loading KTX2 files\n */\nexport class KhronosTextureContainer2 {\n    static GetDefaultNumWorkers() {\n        if (typeof navigator !== \"object\" || !navigator.hardwareConcurrency) {\n            return 1;\n        }\n        // Use 50% of the available logical processors but capped at 4.\n        return Math.min(Math.floor(navigator.hardwareConcurrency * 0.5), 4);\n    }\n    static _Initialize(numWorkers) {\n        if (KhronosTextureContainer2._WorkerPoolPromise || KhronosTextureContainer2._DecoderModulePromise) {\n            return;\n        }\n        const urls = {\n            jsDecoderModule: Tools.GetAbsoluteUrl(this.URLConfig.jsDecoderModule),\n            wasmUASTCToASTC: getAbsoluteUrlOrNull(this.URLConfig.wasmUASTCToASTC),\n            wasmUASTCToBC7: getAbsoluteUrlOrNull(this.URLConfig.wasmUASTCToBC7),\n            wasmUASTCToRGBA_UNORM: getAbsoluteUrlOrNull(this.URLConfig.wasmUASTCToRGBA_UNORM),\n            wasmUASTCToRGBA_SRGB: getAbsoluteUrlOrNull(this.URLConfig.wasmUASTCToRGBA_SRGB),\n            wasmUASTCToR8_UNORM: getAbsoluteUrlOrNull(this.URLConfig.wasmUASTCToR8_UNORM),\n            wasmUASTCToRG8_UNORM: getAbsoluteUrlOrNull(this.URLConfig.wasmUASTCToRG8_UNORM),\n            jsMSCTranscoder: getAbsoluteUrlOrNull(this.URLConfig.jsMSCTranscoder),\n            wasmMSCTranscoder: getAbsoluteUrlOrNull(this.URLConfig.wasmMSCTranscoder),\n            wasmZSTDDecoder: getAbsoluteUrlOrNull(this.URLConfig.wasmZSTDDecoder),\n        };\n        if (numWorkers && typeof Worker === \"function\" && typeof URL !== \"undefined\") {\n            KhronosTextureContainer2._WorkerPoolPromise = new Promise((resolve) => {\n                const workerContent = `${applyConfig}(${workerFunc})()`;\n                const workerBlobUrl = URL.createObjectURL(new Blob([workerContent], { type: \"application/javascript\" }));\n                resolve(new AutoReleaseWorkerPool(numWorkers, () => new Promise((resolve, reject) => {\n                    const worker = new Worker(workerBlobUrl);\n                    const onError = (error) => {\n                        worker.removeEventListener(\"error\", onError);\n                        worker.removeEventListener(\"message\", onMessage);\n                        reject(error);\n                    };\n                    const onMessage = (message) => {\n                        if (message.data.action === \"init\") {\n                            worker.removeEventListener(\"error\", onError);\n                            worker.removeEventListener(\"message\", onMessage);\n                            resolve(worker);\n                        }\n                    };\n                    worker.addEventListener(\"error\", onError);\n                    worker.addEventListener(\"message\", onMessage);\n                    worker.postMessage({\n                        action: \"init\",\n                        urls: urls,\n                    });\n                })));\n            });\n        }\n        else if (typeof KTX2DECODER === \"undefined\") {\n            KhronosTextureContainer2._DecoderModulePromise = Tools.LoadScriptAsync(urls.jsDecoderModule).then(() => {\n                KTX2DECODER.MSCTranscoder.UseFromWorkerThread = false;\n                KTX2DECODER.WASMMemoryManager.LoadBinariesFromCurrentThread = true;\n                applyConfig(urls);\n                return new KTX2DECODER.KTX2Decoder();\n            });\n        }\n        else {\n            KTX2DECODER.MSCTranscoder.UseFromWorkerThread = false;\n            KTX2DECODER.WASMMemoryManager.LoadBinariesFromCurrentThread = true;\n            KhronosTextureContainer2._DecoderModulePromise = Promise.resolve(new KTX2DECODER.KTX2Decoder());\n        }\n    }\n    /**\n     * Constructor\n     * @param engine The engine to use\n     * @param numWorkers The number of workers for async operations. Specify `0` to disable web workers and run synchronously in the current context.\n     */\n    constructor(engine, numWorkers = KhronosTextureContainer2.DefaultNumWorkers) {\n        this._engine = engine;\n        KhronosTextureContainer2._Initialize(numWorkers);\n    }\n    /**\n     * @internal\n     */\n    uploadAsync(data, internalTexture, options) {\n        const caps = this._engine.getCaps();\n        const compressedTexturesCaps = {\n            astc: !!caps.astc,\n            bptc: !!caps.bptc,\n            s3tc: !!caps.s3tc,\n            pvrtc: !!caps.pvrtc,\n            etc2: !!caps.etc2,\n            etc1: !!caps.etc1,\n        };\n        if (KhronosTextureContainer2._WorkerPoolPromise) {\n            return KhronosTextureContainer2._WorkerPoolPromise.then((workerPool) => {\n                return new Promise((resolve, reject) => {\n                    workerPool.push((worker, onComplete) => {\n                        const onError = (error) => {\n                            worker.removeEventListener(\"error\", onError);\n                            worker.removeEventListener(\"message\", onMessage);\n                            reject(error);\n                            onComplete();\n                        };\n                        const onMessage = (message) => {\n                            if (message.data.action === \"decoded\") {\n                                worker.removeEventListener(\"error\", onError);\n                                worker.removeEventListener(\"message\", onMessage);\n                                if (!message.data.success) {\n                                    reject({ message: message.data.msg });\n                                }\n                                else {\n                                    try {\n                                        this._createTexture(message.data.decodedData, internalTexture, options);\n                                        resolve();\n                                    }\n                                    catch (err) {\n                                        reject({ message: err });\n                                    }\n                                }\n                                onComplete();\n                            }\n                        };\n                        worker.addEventListener(\"error\", onError);\n                        worker.addEventListener(\"message\", onMessage);\n                        if (KhronosTextureContainer2.DefaultDecoderOptions.isDirty) {\n                            worker.postMessage({ action: \"setDefaultDecoderOptions\", options: KhronosTextureContainer2.DefaultDecoderOptions._getKTX2DecoderOptions() });\n                        }\n                        const dataCopy = new Uint8Array(data.byteLength);\n                        dataCopy.set(new Uint8Array(data.buffer, data.byteOffset, data.byteLength));\n                        worker.postMessage({ action: \"decode\", data: dataCopy, caps: compressedTexturesCaps, options }, [dataCopy.buffer]);\n                    });\n                });\n            });\n        }\n        else if (KhronosTextureContainer2._DecoderModulePromise) {\n            return KhronosTextureContainer2._DecoderModulePromise.then((decoder) => {\n                return new Promise((resolve, reject) => {\n                    decoder\n                        .decode(data, caps)\n                        .then((data) => {\n                        this._createTexture(data, internalTexture);\n                        resolve();\n                    })\n                        .catch((reason) => {\n                        reject({ message: reason });\n                    });\n                });\n            });\n        }\n        throw new Error(\"KTX2 decoder module is not available\");\n    }\n    _createTexture(data, internalTexture, options) {\n        const oglTexture2D = 3553; // gl.TEXTURE_2D\n        this._engine._bindTextureDirectly(oglTexture2D, internalTexture);\n        if (options) {\n            // return back some information about the decoded data\n            options.transcodedFormat = data.transcodedFormat;\n            options.isInGammaSpace = data.isInGammaSpace;\n            options.hasAlpha = data.hasAlpha;\n            options.transcoderName = data.transcoderName;\n        }\n        let isUncompressedFormat = true;\n        switch (data.transcodedFormat) {\n            case 0x8058 /* RGBA8 */:\n                internalTexture.type = 0;\n                internalTexture.format = 5;\n                break;\n            case 0x8229 /* R8 */:\n                internalTexture.type = 0;\n                internalTexture.format = 6;\n                break;\n            case 0x822b /* RG8 */:\n                internalTexture.type = 0;\n                internalTexture.format = 7;\n                break;\n            default:\n                internalTexture.format = data.transcodedFormat;\n                isUncompressedFormat = false;\n                break;\n        }\n        internalTexture._gammaSpace = data.isInGammaSpace;\n        internalTexture.generateMipMaps = data.mipmaps.length > 1;\n        if (data.errors) {\n            throw new Error(\"KTX2 container - could not transcode the data. \" + data.errors);\n        }\n        for (let t = 0; t < data.mipmaps.length; ++t) {\n            const mipmap = data.mipmaps[t];\n            if (!mipmap || !mipmap.data) {\n                throw new Error(\"KTX2 container - could not transcode one of the image\");\n            }\n            if (isUncompressedFormat) {\n                // uncompressed RGBA / R8 / RG8\n                internalTexture.width = mipmap.width; // need to set width/height so that the call to _uploadDataToTextureDirectly uses the right dimensions\n                internalTexture.height = mipmap.height;\n                this._engine._uploadDataToTextureDirectly(internalTexture, mipmap.data, 0, t, undefined, true);\n            }\n            else {\n                this._engine._uploadCompressedDataToTextureDirectly(internalTexture, data.transcodedFormat, mipmap.width, mipmap.height, mipmap.data, 0, t);\n            }\n        }\n        internalTexture._extension = \".ktx2\";\n        internalTexture.width = data.mipmaps[0].width;\n        internalTexture.height = data.mipmaps[0].height;\n        internalTexture.isReady = true;\n        this._engine._bindTextureDirectly(oglTexture2D, null);\n    }\n    /**\n     * Checks if the given data starts with a KTX2 file identifier.\n     * @param data the data to check\n     * @returns true if the data is a KTX2 file or false otherwise\n     */\n    static IsValid(data) {\n        if (data.byteLength >= 12) {\n            // '', 'K', 'T', 'X', ' ', '2', '0', '', '\\r', '\\n', '\\x1A', '\\n'\n            const identifier = new Uint8Array(data.buffer, data.byteOffset, 12);\n            if (identifier[0] === 0xab &&\n                identifier[1] === 0x4b &&\n                identifier[2] === 0x54 &&\n                identifier[3] === 0x58 &&\n                identifier[4] === 0x20 &&\n                identifier[5] === 0x32 &&\n                identifier[6] === 0x30 &&\n                identifier[7] === 0xbb &&\n                identifier[8] === 0x0d &&\n                identifier[9] === 0x0a &&\n                identifier[10] === 0x1a &&\n                identifier[11] === 0x0a) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n/**\n * URLs to use when loading the KTX2 decoder module as well as its dependencies\n * If a url is null, the default url is used (pointing to https://preview.babylonjs.com)\n * Note that jsDecoderModule can't be null and that the other dependencies will only be loaded if necessary\n * Urls you can change:\n *     URLConfig.jsDecoderModule\n *     URLConfig.wasmUASTCToASTC\n *     URLConfig.wasmUASTCToBC7\n *     URLConfig.wasmUASTCToRGBA_UNORM\n *     URLConfig.wasmUASTCToRGBA_SRGB\n *     URLConfig.wasmUASTCToR8_UNORM\n *     URLConfig.wasmUASTCToRG8_UNORM\n *     URLConfig.jsMSCTranscoder\n *     URLConfig.wasmMSCTranscoder\n *     URLConfig.wasmZSTDDecoder\n * You can see their default values in this PG: https://playground.babylonjs.com/#EIJH8L#29\n */\nKhronosTextureContainer2.URLConfig = {\n    jsDecoderModule: \"https://preview.babylonjs.com/babylon.ktx2Decoder.js\",\n    wasmUASTCToASTC: null,\n    wasmUASTCToBC7: null,\n    wasmUASTCToRGBA_UNORM: null,\n    wasmUASTCToRGBA_SRGB: null,\n    wasmUASTCToR8_UNORM: null,\n    wasmUASTCToRG8_UNORM: null,\n    jsMSCTranscoder: null,\n    wasmMSCTranscoder: null,\n    wasmZSTDDecoder: null,\n};\n/**\n * Default number of workers used to handle data decoding\n */\nKhronosTextureContainer2.DefaultNumWorkers = KhronosTextureContainer2.GetDefaultNumWorkers();\n/**\n * Default configuration for the KTX2 decoder.\n * The options defined in this way have priority over those passed when creating a KTX2 texture with new Texture(...).\n */\nKhronosTextureContainer2.DefaultDecoderOptions = new DefaultKTX2DecoderOptions();\nfunction workerFunc() {\n    let ktx2Decoder;\n    onmessage = (event) => {\n        if (!event.data) {\n            return;\n        }\n        switch (event.data.action) {\n            case \"init\": {\n                const urls = event.data.urls;\n                importScripts(urls.jsDecoderModule);\n                applyConfig(urls);\n                ktx2Decoder = new KTX2DECODER.KTX2Decoder();\n                postMessage({ action: \"init\" });\n                break;\n            }\n            case \"setDefaultDecoderOptions\": {\n                KTX2DECODER.KTX2Decoder.DefaultDecoderOptions = event.data.options;\n                break;\n            }\n            case \"decode\":\n                ktx2Decoder\n                    .decode(event.data.data, event.data.caps, event.data.options)\n                    .then((data) => {\n                    const buffers = [];\n                    for (let mip = 0; mip < data.mipmaps.length; ++mip) {\n                        const mipmap = data.mipmaps[mip];\n                        if (mipmap && mipmap.data) {\n                            buffers.push(mipmap.data.buffer);\n                        }\n                    }\n                    postMessage({ action: \"decoded\", success: true, decodedData: data }, buffers);\n                })\n                    .catch((reason) => {\n                    postMessage({ action: \"decoded\", success: false, msg: reason });\n                });\n                break;\n        }\n    };\n}\n//# sourceMappingURL=khronosTextureContainer2.js.map","/**\n * Logger used throughout the application to allow configuration of\n * the log level required for the messages.\n */\nexport class Logger {\n    static _CheckLimit(message, limit) {\n        let entry = Logger._LogLimitOutputs[message];\n        if (!entry) {\n            entry = { limit, current: 1 };\n            Logger._LogLimitOutputs[message] = entry;\n        }\n        else {\n            entry.current++;\n        }\n        return entry.current <= entry.limit;\n    }\n    static _GenerateLimitMessage(message, level = 1) {\n        var _a;\n        const entry = Logger._LogLimitOutputs[message];\n        if (!entry || !Logger.MessageLimitReached) {\n            return;\n        }\n        const type = this._Levels[level];\n        if (entry.current === entry.limit) {\n            Logger[type.name](Logger.MessageLimitReached.replace(/%LIMIT%/g, \"\" + entry.limit).replace(/%TYPE%/g, (_a = type.name) !== null && _a !== void 0 ? _a : \"\"));\n        }\n    }\n    static _AddLogEntry(entry) {\n        Logger._LogCache = entry + Logger._LogCache;\n        if (Logger.OnNewCacheEntry) {\n            Logger.OnNewCacheEntry(entry);\n        }\n    }\n    static _FormatMessage(message) {\n        const padStr = (i) => (i < 10 ? \"0\" + i : \"\" + i);\n        const date = new Date();\n        return \"[\" + padStr(date.getHours()) + \":\" + padStr(date.getMinutes()) + \":\" + padStr(date.getSeconds()) + \"]: \" + message;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    static _LogDisabled(message, limit) {\n        // nothing to do\n    }\n    static _LogEnabled(level = 1, message, limit) {\n        if (limit !== undefined && !Logger._CheckLimit(message, limit)) {\n            return;\n        }\n        const formattedMessage = Logger._FormatMessage(message);\n        const type = this._Levels[level];\n        type.logFunc && type.logFunc(\"BJS - \" + formattedMessage);\n        const entry = `<div style='color:${type.color}'>${formattedMessage}</div><br>`;\n        Logger._AddLogEntry(entry);\n        Logger._GenerateLimitMessage(message, level);\n    }\n    /**\n     * Gets current log cache (list of logs)\n     */\n    static get LogCache() {\n        return Logger._LogCache;\n    }\n    /**\n     * Clears the log cache\n     */\n    static ClearLogCache() {\n        Logger._LogCache = \"\";\n        Logger._LogLimitOutputs = {};\n        Logger.errorsCount = 0;\n    }\n    /**\n     * Sets the current log level (MessageLogLevel / WarningLogLevel / ErrorLogLevel)\n     */\n    static set LogLevels(level) {\n        Logger.Log = Logger._LogDisabled;\n        Logger.Warn = Logger._LogDisabled;\n        Logger.Error = Logger._LogDisabled;\n        [Logger.MessageLogLevel, Logger.WarningLogLevel, Logger.ErrorLogLevel].forEach((l) => {\n            if ((level & l) === l) {\n                const type = this._Levels[l];\n                Logger[type.name] = Logger._LogEnabled.bind(Logger, l);\n            }\n        });\n    }\n}\n/**\n * No log\n */\nLogger.NoneLogLevel = 0;\n/**\n * Only message logs\n */\nLogger.MessageLogLevel = 1;\n/**\n * Only warning logs\n */\nLogger.WarningLogLevel = 2;\n/**\n * Only error logs\n */\nLogger.ErrorLogLevel = 4;\n/**\n * All logs\n */\nLogger.AllLogLevel = 7;\n/**\n * Message to display when a message has been logged too many times\n */\nLogger.MessageLimitReached = \"Too many %TYPE%s (%LIMIT%), no more %TYPE%s will be reported for this message.\";\nLogger._LogCache = \"\";\nLogger._LogLimitOutputs = {};\n// levels according to the (binary) numbering.\nLogger._Levels = [\n    {},\n    { color: \"white\", logFunc: console.log, name: \"Log\" },\n    { color: \"orange\", logFunc: console.warn, name: \"Warn\" },\n    {},\n    { color: \"red\", logFunc: console.error, name: \"Error\" },\n];\n/**\n * Gets a value indicating the number of loading errors\n * @ignorenaming\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nLogger.errorsCount = 0;\n/**\n * Log a message to the console\n */\nLogger.Log = Logger._LogEnabled.bind(Logger, Logger.MessageLogLevel);\n/**\n * Write a warning message to the console\n */\nLogger.Warn = Logger._LogEnabled.bind(Logger, Logger.WarningLogLevel);\n/**\n * Write an error message to the console\n */\nLogger.Error = Logger._LogEnabled.bind(Logger, Logger.ErrorLogLevel);\n//# sourceMappingURL=logger.js.map","\nimport { Observable } from \"./observable.js\";\nimport { PostProcess } from \"../PostProcesses/postProcess.js\";\nimport { PostProcessManager } from \"../PostProcesses/postProcessManager.js\";\nimport \"../Shaders/minmaxRedux.fragment.js\";\n/**\n * This class computes a min/max reduction from a texture: it means it computes the minimum\n * and maximum values from all values of the texture.\n * It is performed on the GPU for better performances, thanks to a succession of post processes.\n * The source values are read from the red channel of the texture.\n */\nexport class MinMaxReducer {\n    /**\n     * Creates a min/max reducer\n     * @param camera The camera to use for the post processes\n     */\n    constructor(camera) {\n        /**\n         * Observable triggered when the computation has been performed\n         */\n        this.onAfterReductionPerformed = new Observable();\n        this._forceFullscreenViewport = true;\n        this._activated = false;\n        this._camera = camera;\n        this._postProcessManager = new PostProcessManager(camera.getScene());\n        this._onContextRestoredObserver = camera.getEngine().onContextRestoredObservable.add(() => {\n            this._postProcessManager._rebuild();\n        });\n    }\n    /**\n     * Gets the texture used to read the values from.\n     */\n    get sourceTexture() {\n        return this._sourceTexture;\n    }\n    /**\n     * Sets the source texture to read the values from.\n     * One must indicate if the texture is a depth texture or not through the depthRedux parameter\n     * because in such textures '1' value must not be taken into account to compute the maximum\n     * as this value is used to clear the texture.\n     * Note that the computation is not activated by calling this function, you must call activate() for that!\n     * @param sourceTexture The texture to read the values from. The values should be in the red channel.\n     * @param depthRedux Indicates if the texture is a depth texture or not\n     * @param type The type of the textures created for the reduction (defaults to TEXTURETYPE_HALF_FLOAT)\n     * @param forceFullscreenViewport Forces the post processes used for the reduction to be applied without taking into account viewport (defaults to true)\n     */\n    setSourceTexture(sourceTexture, depthRedux, type = 2, forceFullscreenViewport = true) {\n        if (sourceTexture === this._sourceTexture) {\n            return;\n        }\n        this.dispose(false);\n        this._sourceTexture = sourceTexture;\n        this._reductionSteps = [];\n        this._forceFullscreenViewport = forceFullscreenViewport;\n        const scene = this._camera.getScene();\n        // create the first step\n        const reductionInitial = new PostProcess(\"Initial reduction phase\", \"minmaxRedux\", // shader\n        [\"texSize\"], [\"sourceTexture\"], // textures\n        1.0, // options\n        null, // camera\n        1, // sampling\n        scene.getEngine(), // engine\n        false, // reusable\n        \"#define INITIAL\" + (depthRedux ? \"\\n#define DEPTH_REDUX\" : \"\"), // defines\n        type, undefined, undefined, undefined, 7);\n        reductionInitial.autoClear = false;\n        reductionInitial.forceFullscreenViewport = forceFullscreenViewport;\n        let w = this._sourceTexture.getRenderWidth(), h = this._sourceTexture.getRenderHeight();\n        reductionInitial.onApply = ((w, h) => {\n            return (effect) => {\n                effect.setTexture(\"sourceTexture\", this._sourceTexture);\n                effect.setFloat2(\"texSize\", w, h);\n            };\n        })(w, h);\n        this._reductionSteps.push(reductionInitial);\n        let index = 1;\n        // create the additional steps\n        while (w > 1 || h > 1) {\n            w = Math.max(Math.round(w / 2), 1);\n            h = Math.max(Math.round(h / 2), 1);\n            const reduction = new PostProcess(\"Reduction phase \" + index, \"minmaxRedux\", // shader\n            [\"texSize\"], null, { width: w, height: h }, // options\n            null, // camera\n            1, // sampling\n            scene.getEngine(), // engine\n            false, // reusable\n            \"#define \" + (w == 1 && h == 1 ? \"LAST\" : w == 1 || h == 1 ? \"ONEBEFORELAST\" : \"MAIN\"), // defines\n            type, undefined, undefined, undefined, 7);\n            reduction.autoClear = false;\n            reduction.forceFullscreenViewport = forceFullscreenViewport;\n            reduction.onApply = ((w, h) => {\n                return (effect) => {\n                    if (w == 1 || h == 1) {\n                        effect.setInt2(\"texSize\", w, h);\n                    }\n                    else {\n                        effect.setFloat2(\"texSize\", w, h);\n                    }\n                };\n            })(w, h);\n            this._reductionSteps.push(reduction);\n            index++;\n            if (w == 1 && h == 1) {\n                const func = (w, h, reduction) => {\n                    const buffer = new Float32Array(4 * w * h), minmax = { min: 0, max: 0 };\n                    return () => {\n                        scene.getEngine()._readTexturePixels(reduction.inputTexture.texture, w, h, -1, 0, buffer, false);\n                        minmax.min = buffer[0];\n                        minmax.max = buffer[1];\n                        this.onAfterReductionPerformed.notifyObservers(minmax);\n                    };\n                };\n                reduction.onAfterRenderObservable.add(func(w, h, reduction));\n            }\n        }\n    }\n    /**\n     * Defines the refresh rate of the computation.\n     * Use 0 to compute just once, 1 to compute on every frame, 2 to compute every two frames and so on...\n     */\n    get refreshRate() {\n        return this._sourceTexture ? this._sourceTexture.refreshRate : -1;\n    }\n    set refreshRate(value) {\n        if (this._sourceTexture) {\n            this._sourceTexture.refreshRate = value;\n        }\n    }\n    /**\n     * Gets the activation status of the reducer\n     */\n    get activated() {\n        return this._activated;\n    }\n    /**\n     * Activates the reduction computation.\n     * When activated, the observers registered in onAfterReductionPerformed are\n     * called after the computation is performed\n     */\n    activate() {\n        if (this._onAfterUnbindObserver || !this._sourceTexture) {\n            return;\n        }\n        this._onAfterUnbindObserver = this._sourceTexture.onAfterUnbindObservable.add(() => {\n            var _a, _b;\n            const engine = this._camera.getScene().getEngine();\n            (_a = engine._debugPushGroup) === null || _a === void 0 ? void 0 : _a.call(engine, `min max reduction`, 1);\n            this._reductionSteps[0].activate(this._camera);\n            this._postProcessManager.directRender(this._reductionSteps, this._reductionSteps[0].inputTexture, this._forceFullscreenViewport);\n            engine.unBindFramebuffer(this._reductionSteps[0].inputTexture, false);\n            (_b = engine._debugPopGroup) === null || _b === void 0 ? void 0 : _b.call(engine, 1);\n        });\n        this._activated = true;\n    }\n    /**\n     * Deactivates the reduction computation.\n     */\n    deactivate() {\n        if (!this._onAfterUnbindObserver || !this._sourceTexture) {\n            return;\n        }\n        this._sourceTexture.onAfterUnbindObservable.remove(this._onAfterUnbindObserver);\n        this._onAfterUnbindObserver = null;\n        this._activated = false;\n    }\n    /**\n     * Disposes the min/max reducer\n     * @param disposeAll true to dispose all the resources. You should always call this function with true as the parameter (or without any parameter as it is the default one). This flag is meant to be used internally.\n     */\n    dispose(disposeAll = true) {\n        if (disposeAll) {\n            this.onAfterReductionPerformed.clear();\n            if (this._onContextRestoredObserver) {\n                this._camera.getEngine().onContextRestoredObservable.remove(this._onContextRestoredObserver);\n                this._onContextRestoredObserver = null;\n            }\n        }\n        this.deactivate();\n        if (this._reductionSteps) {\n            for (let i = 0; i < this._reductionSteps.length; ++i) {\n                this._reductionSteps[i].dispose();\n            }\n            this._reductionSteps = null;\n        }\n        if (this._postProcessManager && disposeAll) {\n            this._postProcessManager.dispose();\n        }\n        this._sourceTexture = null;\n    }\n}\n//# sourceMappingURL=minMaxReducer.js.map","/**\n * A class serves as a medium between the observable and its observers\n */\nexport class EventState {\n    /**\n     * Create a new EventState\n     * @param mask defines the mask associated with this state\n     * @param skipNextObservers defines a flag which will instruct the observable to skip following observers when set to true\n     * @param target defines the original target of the state\n     * @param currentTarget defines the current target of the state\n     */\n    constructor(mask, skipNextObservers = false, target, currentTarget) {\n        this.initialize(mask, skipNextObservers, target, currentTarget);\n    }\n    /**\n     * Initialize the current event state\n     * @param mask defines the mask associated with this state\n     * @param skipNextObservers defines a flag which will instruct the observable to skip following observers when set to true\n     * @param target defines the original target of the state\n     * @param currentTarget defines the current target of the state\n     * @returns the current event state\n     */\n    initialize(mask, skipNextObservers = false, target, currentTarget) {\n        this.mask = mask;\n        this.skipNextObservers = skipNextObservers;\n        this.target = target;\n        this.currentTarget = currentTarget;\n        return this;\n    }\n}\n/**\n * Represent an Observer registered to a given Observable object.\n */\nexport class Observer {\n    /**\n     * Creates a new observer\n     * @param callback defines the callback to call when the observer is notified\n     * @param mask defines the mask of the observer (used to filter notifications)\n     * @param scope defines the current scope used to restore the JS context\n     */\n    constructor(\n    /**\n     * Defines the callback to call when the observer is notified\n     */\n    callback, \n    /**\n     * Defines the mask of the observer (used to filter notifications)\n     */\n    mask, \n    /**\n     * Defines the current scope used to restore the JS context\n     */\n    scope = null) {\n        this.callback = callback;\n        this.mask = mask;\n        this.scope = scope;\n        /** @internal */\n        this._willBeUnregistered = false;\n        /**\n         * Gets or sets a property defining that the observer as to be unregistered after the next notification\n         */\n        this.unregisterOnNextCall = false;\n    }\n}\n/**\n * The Observable class is a simple implementation of the Observable pattern.\n *\n * There's one slight particularity though: a given Observable can notify its observer using a particular mask value, only the Observers registered with this mask value will be notified.\n * This enable a more fine grained execution without having to rely on multiple different Observable objects.\n * For instance you may have a given Observable that have four different types of notifications: Move (mask = 0x01), Stop (mask = 0x02), Turn Right (mask = 0X04), Turn Left (mask = 0X08).\n * A given observer can register itself with only Move and Stop (mask = 0x03), then it will only be notified when one of these two occurs and will never be for Turn Left/Right.\n */\nexport class Observable {\n    /**\n     * Create an observable from a Promise.\n     * @param promise a promise to observe for fulfillment.\n     * @param onErrorObservable an observable to notify if a promise was rejected.\n     * @returns the new Observable\n     */\n    static FromPromise(promise, onErrorObservable) {\n        const observable = new Observable();\n        promise\n            .then((ret) => {\n            observable.notifyObservers(ret);\n        })\n            .catch((err) => {\n            if (onErrorObservable) {\n                onErrorObservable.notifyObservers(err);\n            }\n            else {\n                throw err;\n            }\n        });\n        return observable;\n    }\n    /**\n     * Gets the list of observers\n     * Note that observers that were recently deleted may still be present in the list because they are only really deleted on the next javascript tick!\n     */\n    get observers() {\n        return this._observers;\n    }\n    /**\n     * Creates a new observable\n     * @param onObserverAdded defines a callback to call when a new observer is added\n     */\n    constructor(onObserverAdded) {\n        this._observers = new Array();\n        this._numObserversMarkedAsDeleted = 0;\n        this._eventState = new EventState(0);\n        if (onObserverAdded) {\n            this._onObserverAdded = onObserverAdded;\n        }\n    }\n    /**\n     * Create a new Observer with the specified callback\n     * @param callback the callback that will be executed for that Observer\n     * @param mask the mask used to filter observers\n     * @param insertFirst if true the callback will be inserted at the first position, hence executed before the others ones. If false (default behavior) the callback will be inserted at the last position, executed after all the others already present.\n     * @param scope optional scope for the callback to be called from\n     * @param unregisterOnFirstCall defines if the observer as to be unregistered after the next notification\n     * @returns the new observer created for the callback\n     */\n    add(callback, mask = -1, insertFirst = false, scope = null, unregisterOnFirstCall = false) {\n        if (!callback) {\n            return null;\n        }\n        const observer = new Observer(callback, mask, scope);\n        observer.unregisterOnNextCall = unregisterOnFirstCall;\n        if (insertFirst) {\n            this._observers.unshift(observer);\n        }\n        else {\n            this._observers.push(observer);\n        }\n        if (this._onObserverAdded) {\n            this._onObserverAdded(observer);\n        }\n        return observer;\n    }\n    /**\n     * Create a new Observer with the specified callback and unregisters after the next notification\n     * @param callback the callback that will be executed for that Observer\n     * @returns the new observer created for the callback\n     */\n    addOnce(callback) {\n        return this.add(callback, undefined, undefined, undefined, true);\n    }\n    /**\n     * Remove an Observer from the Observable object\n     * @param observer the instance of the Observer to remove\n     * @returns false if it doesn't belong to this Observable\n     */\n    remove(observer) {\n        if (!observer) {\n            return false;\n        }\n        const index = this._observers.indexOf(observer);\n        if (index !== -1) {\n            this._deferUnregister(observer);\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Remove a callback from the Observable object\n     * @param callback the callback to remove\n     * @param scope optional scope. If used only the callbacks with this scope will be removed\n     * @returns false if it doesn't belong to this Observable\n     */\n    removeCallback(callback, scope) {\n        for (let index = 0; index < this._observers.length; index++) {\n            const observer = this._observers[index];\n            if (observer._willBeUnregistered) {\n                continue;\n            }\n            if (observer.callback === callback && (!scope || scope === observer.scope)) {\n                this._deferUnregister(observer);\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * @internal\n     */\n    _deferUnregister(observer) {\n        this._numObserversMarkedAsDeleted++;\n        observer.unregisterOnNextCall = false;\n        observer._willBeUnregistered = true;\n        setTimeout(() => {\n            this._remove(observer);\n        }, 0);\n    }\n    // This should only be called when not iterating over _observers to avoid callback skipping.\n    // Removes an observer from the _observer Array.\n    _remove(observer, updateCounter = true) {\n        if (!observer) {\n            return false;\n        }\n        const index = this._observers.indexOf(observer);\n        if (index !== -1) {\n            if (updateCounter) {\n                this._numObserversMarkedAsDeleted--;\n            }\n            this._observers.splice(index, 1);\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Moves the observable to the top of the observer list making it get called first when notified\n     * @param observer the observer to move\n     */\n    makeObserverTopPriority(observer) {\n        this._remove(observer, false);\n        this._observers.unshift(observer);\n    }\n    /**\n     * Moves the observable to the bottom of the observer list making it get called last when notified\n     * @param observer the observer to move\n     */\n    makeObserverBottomPriority(observer) {\n        this._remove(observer, false);\n        this._observers.push(observer);\n    }\n    /**\n     * Notify all Observers by calling their respective callback with the given data\n     * Will return true if all observers were executed, false if an observer set skipNextObservers to true, then prevent the subsequent ones to execute\n     * @param eventData defines the data to send to all observers\n     * @param mask defines the mask of the current notification (observers with incompatible mask (ie mask & observer.mask === 0) will not be notified)\n     * @param target defines the original target of the state\n     * @param currentTarget defines the current target of the state\n     * @param userInfo defines any user info to send to observers\n     * @returns false if the complete observer chain was not processed (because one observer set the skipNextObservers to true)\n     */\n    notifyObservers(eventData, mask = -1, target, currentTarget, userInfo) {\n        if (!this._observers.length) {\n            return true;\n        }\n        const state = this._eventState;\n        state.mask = mask;\n        state.target = target;\n        state.currentTarget = currentTarget;\n        state.skipNextObservers = false;\n        state.lastReturnValue = eventData;\n        state.userInfo = userInfo;\n        for (const obs of this._observers) {\n            if (obs._willBeUnregistered) {\n                continue;\n            }\n            if (obs.mask & mask) {\n                if (obs.unregisterOnNextCall) {\n                    this._deferUnregister(obs);\n                }\n                if (obs.scope) {\n                    state.lastReturnValue = obs.callback.apply(obs.scope, [eventData, state]);\n                }\n                else {\n                    state.lastReturnValue = obs.callback(eventData, state);\n                }\n            }\n            if (state.skipNextObservers) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Notify a specific observer\n     * @param observer defines the observer to notify\n     * @param eventData defines the data to be sent to each callback\n     * @param mask is used to filter observers defaults to -1\n     */\n    notifyObserver(observer, eventData, mask = -1) {\n        if (observer._willBeUnregistered) {\n            return;\n        }\n        const state = this._eventState;\n        state.mask = mask;\n        state.skipNextObservers = false;\n        if (observer.unregisterOnNextCall) {\n            this._deferUnregister(observer);\n        }\n        observer.callback(eventData, state);\n    }\n    /**\n     * Gets a boolean indicating if the observable has at least one observer\n     * @returns true is the Observable has at least one Observer registered\n     */\n    hasObservers() {\n        return this._observers.length - this._numObserversMarkedAsDeleted > 0;\n    }\n    /**\n     * Clear the list of observers\n     */\n    clear() {\n        this._observers = new Array();\n        this._onObserverAdded = null;\n        this._numObserversMarkedAsDeleted = 0;\n    }\n    /**\n     * Clone the current observable\n     * @returns a new observable\n     */\n    clone() {\n        const result = new Observable();\n        result._observers = this._observers.slice(0);\n        return result;\n    }\n    /**\n     * Does this observable handles observer registered with a given mask\n     * @param mask defines the mask to be tested\n     * @returns whether or not one observer registered with the given mask is handled\n     **/\n    hasSpecificMask(mask = -1) {\n        for (const obs of this._observers) {\n            if (obs.mask & mask || obs.mask === mask) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n//# sourceMappingURL=observable.js.map","import { PrecisionDate } from \"./precisionDate.js\";\n/**\n * This class is used to track a performance counter which is number based.\n * The user has access to many properties which give statistics of different nature.\n *\n * The implementer can track two kinds of Performance Counter: time and count.\n * For time you can optionally call fetchNewFrame() to notify the start of a new frame to monitor, then call beginMonitoring() to start and endMonitoring() to record the lapsed time. endMonitoring takes a newFrame parameter for you to specify if the monitored time should be set for a new frame or accumulated to the current frame being monitored.\n * For count you first have to call fetchNewFrame() to notify the start of a new frame to monitor, then call addCount() how many time required to increment the count value you monitor.\n */\nexport class PerfCounter {\n    /**\n     * Returns the smallest value ever\n     */\n    get min() {\n        return this._min;\n    }\n    /**\n     * Returns the biggest value ever\n     */\n    get max() {\n        return this._max;\n    }\n    /**\n     * Returns the average value since the performance counter is running\n     */\n    get average() {\n        return this._average;\n    }\n    /**\n     * Returns the average value of the last second the counter was monitored\n     */\n    get lastSecAverage() {\n        return this._lastSecAverage;\n    }\n    /**\n     * Returns the current value\n     */\n    get current() {\n        return this._current;\n    }\n    /**\n     * Gets the accumulated total\n     */\n    get total() {\n        return this._totalAccumulated;\n    }\n    /**\n     * Gets the total value count\n     */\n    get count() {\n        return this._totalValueCount;\n    }\n    /**\n     * Creates a new counter\n     */\n    constructor() {\n        this._startMonitoringTime = 0;\n        this._min = 0;\n        this._max = 0;\n        this._average = 0;\n        this._lastSecAverage = 0;\n        this._current = 0;\n        this._totalValueCount = 0;\n        this._totalAccumulated = 0;\n        this._lastSecAccumulated = 0;\n        this._lastSecTime = 0;\n        this._lastSecValueCount = 0;\n    }\n    /**\n     * Call this method to start monitoring a new frame.\n     * This scenario is typically used when you accumulate monitoring time many times for a single frame, you call this method at the start of the frame, then beginMonitoring to start recording and endMonitoring(false) to accumulated the recorded time to the PerfCounter or addCount() to accumulate a monitored count.\n     */\n    fetchNewFrame() {\n        this._totalValueCount++;\n        this._current = 0;\n        this._lastSecValueCount++;\n    }\n    /**\n     * Call this method to monitor a count of something (e.g. mesh drawn in viewport count)\n     * @param newCount the count value to add to the monitored count\n     * @param fetchResult true when it's the last time in the frame you add to the counter and you wish to update the statistics properties (min/max/average), false if you only want to update statistics.\n     */\n    addCount(newCount, fetchResult) {\n        if (!PerfCounter.Enabled) {\n            return;\n        }\n        this._current += newCount;\n        if (fetchResult) {\n            this._fetchResult();\n        }\n    }\n    /**\n     * Start monitoring this performance counter\n     */\n    beginMonitoring() {\n        if (!PerfCounter.Enabled) {\n            return;\n        }\n        this._startMonitoringTime = PrecisionDate.Now;\n    }\n    /**\n     * Compute the time lapsed since the previous beginMonitoring() call.\n     * @param newFrame true by default to fetch the result and monitor a new frame, if false the time monitored will be added to the current frame counter\n     */\n    endMonitoring(newFrame = true) {\n        if (!PerfCounter.Enabled) {\n            return;\n        }\n        if (newFrame) {\n            this.fetchNewFrame();\n        }\n        const currentTime = PrecisionDate.Now;\n        this._current = currentTime - this._startMonitoringTime;\n        if (newFrame) {\n            this._fetchResult();\n        }\n    }\n    _fetchResult() {\n        this._totalAccumulated += this._current;\n        this._lastSecAccumulated += this._current;\n        // Min/Max update\n        this._min = Math.min(this._min, this._current);\n        this._max = Math.max(this._max, this._current);\n        this._average = this._totalAccumulated / this._totalValueCount;\n        // Reset last sec?\n        const now = PrecisionDate.Now;\n        if (now - this._lastSecTime > 1000) {\n            this._lastSecAverage = this._lastSecAccumulated / this._lastSecValueCount;\n            this._lastSecTime = now;\n            this._lastSecAccumulated = 0;\n            this._lastSecValueCount = 0;\n        }\n    }\n}\n/**\n * Gets or sets a global boolean to turn on and off all the counters\n */\nPerfCounter.Enabled = true;\n//# sourceMappingURL=perfCounter.js.map","import { PrecisionDate } from \"./precisionDate.js\";\n/**\n * Performance monitor tracks rolling average frame-time and frame-time variance over a user defined sliding-window\n */\nexport class PerformanceMonitor {\n    /**\n     * constructor\n     * @param frameSampleSize The number of samples required to saturate the sliding window\n     */\n    constructor(frameSampleSize = 30) {\n        this._enabled = true;\n        this._rollingFrameTime = new RollingAverage(frameSampleSize);\n    }\n    /**\n     * Samples current frame\n     * @param timeMs A timestamp in milliseconds of the current frame to compare with other frames\n     */\n    sampleFrame(timeMs = PrecisionDate.Now) {\n        if (!this._enabled) {\n            return;\n        }\n        if (this._lastFrameTimeMs != null) {\n            const dt = timeMs - this._lastFrameTimeMs;\n            this._rollingFrameTime.add(dt);\n        }\n        this._lastFrameTimeMs = timeMs;\n    }\n    /**\n     * Returns the average frame time in milliseconds over the sliding window (or the subset of frames sampled so far)\n     */\n    get averageFrameTime() {\n        return this._rollingFrameTime.average;\n    }\n    /**\n     * Returns the variance frame time in milliseconds over the sliding window (or the subset of frames sampled so far)\n     */\n    get averageFrameTimeVariance() {\n        return this._rollingFrameTime.variance;\n    }\n    /**\n     * Returns the frame time of the most recent frame\n     */\n    get instantaneousFrameTime() {\n        return this._rollingFrameTime.history(0);\n    }\n    /**\n     * Returns the average framerate in frames per second over the sliding window (or the subset of frames sampled so far)\n     */\n    get averageFPS() {\n        return 1000.0 / this._rollingFrameTime.average;\n    }\n    /**\n     * Returns the average framerate in frames per second using the most recent frame time\n     */\n    get instantaneousFPS() {\n        const history = this._rollingFrameTime.history(0);\n        if (history === 0) {\n            return 0;\n        }\n        return 1000.0 / history;\n    }\n    /**\n     * Returns true if enough samples have been taken to completely fill the sliding window\n     */\n    get isSaturated() {\n        return this._rollingFrameTime.isSaturated();\n    }\n    /**\n     * Enables contributions to the sliding window sample set\n     */\n    enable() {\n        this._enabled = true;\n    }\n    /**\n     * Disables contributions to the sliding window sample set\n     * Samples will not be interpolated over the disabled period\n     */\n    disable() {\n        this._enabled = false;\n        //clear last sample to avoid interpolating over the disabled period when next enabled\n        this._lastFrameTimeMs = null;\n    }\n    /**\n     * Returns true if sampling is enabled\n     */\n    get isEnabled() {\n        return this._enabled;\n    }\n    /**\n     * Resets performance monitor\n     */\n    reset() {\n        //clear last sample to avoid interpolating over the disabled period when next enabled\n        this._lastFrameTimeMs = null;\n        //wipe record\n        this._rollingFrameTime.reset();\n    }\n}\n/**\n * RollingAverage\n *\n * Utility to efficiently compute the rolling average and variance over a sliding window of samples\n */\nexport class RollingAverage {\n    /**\n     * constructor\n     * @param length The number of samples required to saturate the sliding window\n     */\n    constructor(length) {\n        this._samples = new Array(length);\n        this.reset();\n    }\n    /**\n     * Adds a sample to the sample set\n     * @param v The sample value\n     */\n    add(v) {\n        //http://en.wikipedia.org/wiki/Algorithms_for_calculating_variance\n        let delta;\n        //we need to check if we've already wrapped round\n        if (this.isSaturated()) {\n            //remove bottom of stack from mean\n            const bottomValue = this._samples[this._pos];\n            delta = bottomValue - this.average;\n            this.average -= delta / (this._sampleCount - 1);\n            this._m2 -= delta * (bottomValue - this.average);\n        }\n        else {\n            this._sampleCount++;\n        }\n        //add new value to mean\n        delta = v - this.average;\n        this.average += delta / this._sampleCount;\n        this._m2 += delta * (v - this.average);\n        //set the new variance\n        this.variance = this._m2 / (this._sampleCount - 1);\n        this._samples[this._pos] = v;\n        this._pos++;\n        this._pos %= this._samples.length; //positive wrap around\n    }\n    /**\n     * Returns previously added values or null if outside of history or outside the sliding window domain\n     * @param i Index in history. For example, pass 0 for the most recent value and 1 for the value before that\n     * @returns Value previously recorded with add() or null if outside of range\n     */\n    history(i) {\n        if (i >= this._sampleCount || i >= this._samples.length) {\n            return 0;\n        }\n        const i0 = this._wrapPosition(this._pos - 1.0);\n        return this._samples[this._wrapPosition(i0 - i)];\n    }\n    /**\n     * Returns true if enough samples have been taken to completely fill the sliding window\n     * @returns true if sample-set saturated\n     */\n    isSaturated() {\n        return this._sampleCount >= this._samples.length;\n    }\n    /**\n     * Resets the rolling average (equivalent to 0 samples taken so far)\n     */\n    reset() {\n        this.average = 0;\n        this.variance = 0;\n        this._sampleCount = 0;\n        this._pos = 0;\n        this._m2 = 0;\n    }\n    /**\n     * Wraps a value around the sample range boundaries\n     * @param i Position in sample range, for example if the sample length is 5, and i is -3, then 2 will be returned.\n     * @returns Wrapped position in sample range\n     */\n    _wrapPosition(i) {\n        const max = this._samples.length;\n        return ((i % max) + max) % max;\n    }\n}\n//# sourceMappingURL=performanceMonitor.js.map","import { Vector3, Matrix } from \"../Maths/math.vector.js\";\n/**\n * Class containing a set of static utilities functions for managing Pivots\n * @internal\n */\nexport class PivotTools {\n    /**\n     * @internal\n     */\n    static _RemoveAndStorePivotPoint(mesh) {\n        if (mesh && PivotTools._PivotCached === 0) {\n            // Save old pivot and set pivot to 0,0,0\n            mesh.getPivotPointToRef(PivotTools._OldPivotPoint);\n            PivotTools._PivotPostMultiplyPivotMatrix = mesh._postMultiplyPivotMatrix;\n            if (!PivotTools._OldPivotPoint.equalsToFloats(0, 0, 0)) {\n                mesh.setPivotMatrix(Matrix.IdentityReadOnly);\n                PivotTools._OldPivotPoint.subtractToRef(mesh.getPivotPoint(), PivotTools._PivotTranslation);\n                PivotTools._PivotTmpVector.copyFromFloats(1, 1, 1);\n                PivotTools._PivotTmpVector.subtractInPlace(mesh.scaling);\n                PivotTools._PivotTmpVector.multiplyInPlace(PivotTools._PivotTranslation);\n                mesh.position.addInPlace(PivotTools._PivotTmpVector);\n            }\n        }\n        PivotTools._PivotCached++;\n    }\n    /**\n     * @internal\n     */\n    static _RestorePivotPoint(mesh) {\n        if (mesh && !PivotTools._OldPivotPoint.equalsToFloats(0, 0, 0) && PivotTools._PivotCached === 1) {\n            mesh.setPivotPoint(PivotTools._OldPivotPoint);\n            mesh._postMultiplyPivotMatrix = PivotTools._PivotPostMultiplyPivotMatrix;\n            PivotTools._PivotTmpVector.copyFromFloats(1, 1, 1);\n            PivotTools._PivotTmpVector.subtractInPlace(mesh.scaling);\n            PivotTools._PivotTmpVector.multiplyInPlace(PivotTools._PivotTranslation);\n            mesh.position.subtractInPlace(PivotTools._PivotTmpVector);\n        }\n        this._PivotCached--;\n    }\n}\n// Stores the state of the pivot cache (_oldPivotPoint, _pivotTranslation)\n// store/remove pivot point should only be applied during their outermost calls\nPivotTools._PivotCached = 0;\nPivotTools._OldPivotPoint = new Vector3();\nPivotTools._PivotTranslation = new Vector3();\nPivotTools._PivotTmpVector = new Vector3();\nPivotTools._PivotPostMultiplyPivotMatrix = false;\n//# sourceMappingURL=pivotTools.js.map","import { DomManagement } from \"./domManagement.js\";\n/**\n * Class containing a set of static utilities functions for precision date\n */\nexport class PrecisionDate {\n    /**\n     * Gets either window.performance.now() if supported or Date.now() else\n     */\n    static get Now() {\n        if (DomManagement.IsWindowObjectExist() && window.performance && window.performance.now) {\n            return window.performance.now();\n        }\n        return Date.now();\n    }\n}\n//# sourceMappingURL=precisionDate.js.map","/**\n * Class used to define a retry strategy when error happens while loading assets\n */\nexport class RetryStrategy {\n    /**\n     * Function used to defines an exponential back off strategy\n     * @param maxRetries defines the maximum number of retries (3 by default)\n     * @param baseInterval defines the interval between retries\n     * @returns the strategy function to use\n     */\n    static ExponentialBackoff(maxRetries = 3, baseInterval = 500) {\n        return (url, request, retryIndex) => {\n            if (request.status !== 0 || retryIndex >= maxRetries || url.indexOf(\"file:\") !== -1) {\n                return -1;\n            }\n            return Math.pow(2, retryIndex) * baseInterval;\n        };\n    }\n}\n//# sourceMappingURL=retryStrategy.js.map","\nimport { PostProcess } from \"../PostProcesses/postProcess.js\";\nimport \"../Shaders/rgbdDecode.fragment.js\";\nimport \"../Engines/Extensions/engine.renderTarget.js\";\nimport { ApplyPostProcess } from \"./textureTools.js\";\n/**\n * Class used to host RGBD texture specific utilities\n */\nexport class RGBDTextureTools {\n    /**\n     * Expand the RGBD Texture from RGBD to Half Float if possible.\n     * @param texture the texture to expand.\n     */\n    static ExpandRGBDTexture(texture) {\n        const internalTexture = texture._texture;\n        if (!internalTexture || !texture.isRGBD) {\n            return;\n        }\n        // Gets everything ready.\n        const engine = internalTexture.getEngine();\n        const caps = engine.getCaps();\n        const isReady = internalTexture.isReady;\n        let expandTexture = false;\n        // If half float available we can uncompress the texture\n        if (caps.textureHalfFloatRender && caps.textureHalfFloatLinearFiltering) {\n            expandTexture = true;\n            internalTexture.type = 2;\n        }\n        // If full float available we can uncompress the texture\n        else if (caps.textureFloatRender && caps.textureFloatLinearFiltering) {\n            expandTexture = true;\n            internalTexture.type = 1;\n        }\n        if (expandTexture) {\n            // Do not use during decode.\n            internalTexture.isReady = false;\n            internalTexture._isRGBD = false;\n            internalTexture.invertY = false;\n        }\n        const expandRGBDTexture = () => {\n            // Expand the texture if possible\n            if (expandTexture) {\n                // Simply run through the decode PP.\n                const rgbdPostProcess = new PostProcess(\"rgbdDecode\", \"rgbdDecode\", null, null, 1, null, 3, engine, false, undefined, internalTexture.type, undefined, null, false);\n                rgbdPostProcess.externalTextureSamplerBinding = true;\n                // Hold the output of the decoding.\n                const expandedTexture = engine.createRenderTargetTexture(internalTexture.width, {\n                    generateDepthBuffer: false,\n                    generateMipMaps: false,\n                    generateStencilBuffer: false,\n                    samplingMode: internalTexture.samplingMode,\n                    type: internalTexture.type,\n                    format: 5,\n                });\n                rgbdPostProcess.getEffect().executeWhenCompiled(() => {\n                    // PP Render Pass\n                    rgbdPostProcess.onApply = (effect) => {\n                        effect._bindTexture(\"textureSampler\", internalTexture);\n                        effect.setFloat2(\"scale\", 1, 1);\n                    };\n                    texture.getScene().postProcessManager.directRender([rgbdPostProcess], expandedTexture, true);\n                    // Cleanup\n                    engine.restoreDefaultFramebuffer();\n                    engine._releaseTexture(internalTexture);\n                    if (rgbdPostProcess) {\n                        rgbdPostProcess.dispose();\n                    }\n                    // Internal Swap\n                    expandedTexture._swapAndDie(internalTexture);\n                    // Ready to get rolling again.\n                    internalTexture.isReady = true;\n                });\n            }\n        };\n        if (isReady) {\n            expandRGBDTexture();\n        }\n        else {\n            texture.onLoadObservable.addOnce(expandRGBDTexture);\n        }\n    }\n    /**\n     * Encode the texture to RGBD if possible.\n     * @param internalTexture the texture to encode\n     * @param scene the scene hosting the texture\n     * @param outputTextureType type of the texture in which the encoding is performed\n     * @returns a promise with the internalTexture having its texture replaced by the result of the processing\n     */\n    static EncodeTextureToRGBD(internalTexture, scene, outputTextureType = 0) {\n        return ApplyPostProcess(\"rgbdEncode\", internalTexture, scene, outputTextureType, 1, 5);\n    }\n}\n//# sourceMappingURL=rgbdTextureTools.js.map","import { Texture } from \"../Materials/Textures/texture.js\";\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture.js\";\nimport { FxaaPostProcess } from \"../PostProcesses/fxaaPostProcess.js\";\n\nimport { Logger } from \"./logger.js\";\nimport { Tools } from \"./tools.js\";\nimport { DumpTools } from \"./dumpTools.js\";\nlet screenshotCanvas = null;\n/**\n * Captures a screenshot of the current rendering\n * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/renderToPNG\n * @param engine defines the rendering engine\n * @param camera defines the source camera\n * @param size This parameter can be set to a single number or to an object with the\n * following (optional) properties: precision, width, height. If a single number is passed,\n * it will be used for both width and height. If an object is passed, the screenshot size\n * will be derived from the parameters. The precision property is a multiplier allowing\n * rendering at a higher or lower resolution\n * @param successCallback defines the callback receives a single parameter which contains the\n * screenshot as a string of base64-encoded characters. This string can be assigned to the\n * src parameter of an <img> to display it\n * @param mimeType defines the MIME type of the screenshot image (default: image/png).\n * Check your browser for supported MIME types\n * @param forceDownload force the system to download the image even if a successCallback is provided\n */\nexport function CreateScreenshot(engine, camera, size, successCallback, mimeType = \"image/png\", forceDownload = false) {\n    const { height, width } = _GetScreenshotSize(engine, camera, size);\n    if (!(height && width)) {\n        Logger.Error(\"Invalid 'size' parameter !\");\n        return;\n    }\n    if (!screenshotCanvas) {\n        screenshotCanvas = document.createElement(\"canvas\");\n    }\n    screenshotCanvas.width = width;\n    screenshotCanvas.height = height;\n    const renderContext = screenshotCanvas.getContext(\"2d\");\n    const ratio = engine.getRenderWidth() / engine.getRenderHeight();\n    let newWidth = width;\n    let newHeight = newWidth / ratio;\n    if (newHeight > height) {\n        newHeight = height;\n        newWidth = newHeight * ratio;\n    }\n    const offsetX = Math.max(0, width - newWidth) / 2;\n    const offsetY = Math.max(0, height - newHeight) / 2;\n    const scene = camera.getScene();\n    if (scene.activeCamera !== camera) {\n        CreateScreenshotUsingRenderTarget(engine, camera, size, (data) => {\n            if (forceDownload) {\n                const blob = new Blob([data]);\n                Tools.DownloadBlob(blob);\n                if (successCallback) {\n                    successCallback(\"\");\n                }\n            }\n            else if (successCallback) {\n                successCallback(data);\n            }\n        }, mimeType, 1, engine.getCreationOptions().antialias);\n    }\n    else {\n        engine.onEndFrameObservable.addOnce(() => {\n            const renderingCanvas = engine.getRenderingCanvas();\n            if (renderContext && renderingCanvas) {\n                renderContext.drawImage(renderingCanvas, offsetX, offsetY, newWidth, newHeight);\n            }\n            if (screenshotCanvas) {\n                if (forceDownload) {\n                    Tools.EncodeScreenshotCanvasData(screenshotCanvas, undefined, mimeType);\n                    if (successCallback) {\n                        successCallback(\"\");\n                    }\n                }\n                else {\n                    Tools.EncodeScreenshotCanvasData(screenshotCanvas, successCallback, mimeType);\n                }\n            }\n        });\n    }\n}\n/**\n * Captures a screenshot of the current rendering\n * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/renderToPNG\n * @param engine defines the rendering engine\n * @param camera defines the source camera\n * @param size This parameter can be set to a single number or to an object with the\n * following (optional) properties: precision, width, height. If a single number is passed,\n * it will be used for both width and height. If an object is passed, the screenshot size\n * will be derived from the parameters. The precision property is a multiplier allowing\n * rendering at a higher or lower resolution\n * @param mimeType defines the MIME type of the screenshot image (default: image/png).\n * Check your browser for supported MIME types\n * @returns screenshot as a string of base64-encoded characters. This string can be assigned\n * to the src parameter of an <img> to display it\n */\nexport function CreateScreenshotAsync(engine, camera, size, mimeType = \"image/png\") {\n    return new Promise((resolve, reject) => {\n        CreateScreenshot(engine, camera, size, (data) => {\n            if (typeof data !== \"undefined\") {\n                resolve(data);\n            }\n            else {\n                reject(new Error(\"Data is undefined\"));\n            }\n        }, mimeType);\n    });\n}\n/**\n * Captures a screenshot of the current rendering for a specific size. This will render the entire canvas but will generate a blink (due to canvas resize)\n * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/renderToPNG\n * @param engine defines the rendering engine\n * @param camera defines the source camera\n * @param width defines the expected width\n * @param height defines the expected height\n * @param mimeType defines the MIME type of the screenshot image (default: image/png).\n * Check your browser for supported MIME types\n * @returns screenshot as a string of base64-encoded characters. This string can be assigned\n * to the src parameter of an <img> to display it\n */\nexport function CreateScreenshotWithResizeAsync(engine, camera, width, height, mimeType = \"image/png\") {\n    return new Promise((resolve) => {\n        CreateScreenshot(engine, camera, { width: width, height: height }, () => {\n            resolve();\n        }, mimeType, true);\n    });\n}\n/**\n * Generates an image screenshot from the specified camera.\n * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/renderToPNG\n * @param engine The engine to use for rendering\n * @param camera The camera to use for rendering\n * @param size This parameter can be set to a single number or to an object with the\n * following (optional) properties: precision, width, height. If a single number is passed,\n * it will be used for both width and height. If an object is passed, the screenshot size\n * will be derived from the parameters. The precision property is a multiplier allowing\n * rendering at a higher or lower resolution\n * @param successCallback The callback receives a single parameter which contains the\n * screenshot as a string of base64-encoded characters. This string can be assigned to the\n * src parameter of an <img> to display it\n * @param mimeType The MIME type of the screenshot image (default: image/png).\n * Check your browser for supported MIME types\n * @param samples Texture samples (default: 1)\n * @param antialiasing Whether antialiasing should be turned on or not (default: false)\n * @param fileName A name for for the downloaded file.\n * @param renderSprites Whether the sprites should be rendered or not (default: false)\n * @param enableStencilBuffer Whether the stencil buffer should be enabled or not (default: false)\n * @param useLayerMask if the camera's layer mask should be used to filter what should be rendered (default: true)\n */\nexport function CreateScreenshotUsingRenderTarget(engine, camera, size, successCallback, mimeType = \"image/png\", samples = 1, antialiasing = false, fileName, renderSprites = false, enableStencilBuffer = false, useLayerMask = true) {\n    const { height, width } = _GetScreenshotSize(engine, camera, size);\n    const targetTextureSize = { width, height };\n    if (!(height && width)) {\n        Logger.Error(\"Invalid 'size' parameter !\");\n        return;\n    }\n    const originalSize = { width: engine.getRenderWidth(), height: engine.getRenderHeight() };\n    engine.setSize(width, height); // we need this call to trigger onResizeObservable with the screenshot width/height on all the subsystems that are observing this event and that needs to (re)create some resources with the right dimensions\n    const scene = camera.getScene();\n    // At this point size can be a number, or an object (according to engine.prototype.createRenderTargetTexture method)\n    const texture = new RenderTargetTexture(\"screenShot\", targetTextureSize, scene, false, false, 0, false, Texture.NEAREST_SAMPLINGMODE, undefined, enableStencilBuffer, undefined, undefined, undefined, samples);\n    texture.renderList = scene.meshes.slice();\n    texture.samples = samples;\n    texture.renderSprites = renderSprites;\n    texture.activeCamera = camera;\n    texture.forceLayerMaskCheck = useLayerMask;\n    const renderToTexture = () => {\n        engine.onEndFrameObservable.addOnce(() => {\n            texture.readPixels(undefined, undefined, undefined, false).then((data) => {\n                DumpTools.DumpData(width, height, data, successCallback, mimeType, fileName, true);\n                texture.dispose();\n            });\n        });\n        // render the RTT\n        scene.incrementRenderId();\n        scene.resetCachedMaterial();\n        texture.render(true);\n        // re-render the scene after the camera has been reset to the original camera to avoid a flicker that could occur\n        // if the camera used for the RTT rendering stays in effect for the next frame (and if that camera was different from the original camera)\n        scene.incrementRenderId();\n        scene.resetCachedMaterial();\n        engine.setSize(originalSize.width, originalSize.height);\n        camera.getProjectionMatrix(true); // Force cache refresh;\n        scene.render();\n    };\n    if (antialiasing) {\n        const fxaaPostProcess = new FxaaPostProcess(\"antialiasing\", 1.0, scene.activeCamera);\n        texture.addPostProcess(fxaaPostProcess);\n        // Async Shader Compilation can lead to none ready effects in synchronous code\n        if (!fxaaPostProcess.getEffect().isReady()) {\n            fxaaPostProcess.getEffect().onCompiled = () => {\n                renderToTexture();\n            };\n        }\n        // The effect is ready we can render\n        else {\n            renderToTexture();\n        }\n    }\n    else {\n        // No need to wait for extra resources to be ready\n        renderToTexture();\n    }\n}\n/**\n * Generates an image screenshot from the specified camera.\n * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/renderToPNG\n * @param engine The engine to use for rendering\n * @param camera The camera to use for rendering\n * @param size This parameter can be set to a single number or to an object with the\n * following (optional) properties: precision, width, height. If a single number is passed,\n * it will be used for both width and height. If an object is passed, the screenshot size\n * will be derived from the parameters. The precision property is a multiplier allowing\n * rendering at a higher or lower resolution\n * @param mimeType The MIME type of the screenshot image (default: image/png).\n * Check your browser for supported MIME types\n * @param samples Texture samples (default: 1)\n * @param antialiasing Whether antialiasing should be turned on or not (default: false)\n * @param fileName A name for for the downloaded file.\n * @param renderSprites Whether the sprites should be rendered or not (default: false)\n * @param enableStencilBuffer Whether the stencil buffer should be enabled or not (default: false)\n * @param useLayerMask if the camera's layer mask should be used to filter what should be rendered (default: true)\n * @returns screenshot as a string of base64-encoded characters. This string can be assigned\n * to the src parameter of an <img> to display it\n */\nexport function CreateScreenshotUsingRenderTargetAsync(engine, camera, size, mimeType = \"image/png\", samples = 1, antialiasing = false, fileName, renderSprites = false, enableStencilBuffer = false, useLayerMask = true) {\n    return new Promise((resolve, reject) => {\n        CreateScreenshotUsingRenderTarget(engine, camera, size, (data) => {\n            if (typeof data !== \"undefined\") {\n                resolve(data);\n            }\n            else {\n                reject(new Error(\"Data is undefined\"));\n            }\n        }, mimeType, samples, antialiasing, fileName, renderSprites, enableStencilBuffer, useLayerMask);\n    });\n}\n/**\n * Gets height and width for screenshot size\n * @param engine\n * @param camera\n * @param size\n * @private\n */\nfunction _GetScreenshotSize(engine, camera, size) {\n    let height = 0;\n    let width = 0;\n    //If a size value defined as object\n    if (typeof size === \"object\") {\n        const precision = size.precision\n            ? Math.abs(size.precision) // prevent GL_INVALID_VALUE : glViewport: negative width/height\n            : 1;\n        //If a width and height values is specified\n        if (size.width && size.height) {\n            height = size.height * precision;\n            width = size.width * precision;\n        }\n        //If passing only width, computing height to keep display canvas ratio.\n        else if (size.width && !size.height) {\n            width = size.width * precision;\n            height = Math.round(width / engine.getAspectRatio(camera));\n        }\n        //If passing only height, computing width to keep display canvas ratio.\n        else if (size.height && !size.width) {\n            height = size.height * precision;\n            width = Math.round(height * engine.getAspectRatio(camera));\n        }\n        else {\n            width = Math.round(engine.getRenderWidth() * precision);\n            height = Math.round(width / engine.getAspectRatio(camera));\n        }\n    }\n    //Assuming here that \"size\" parameter is a number\n    else if (!isNaN(size)) {\n        height = size;\n        width = size;\n    }\n    // When creating the image data from the CanvasRenderingContext2D, the width and height is clamped to the size of the _gl context\n    // On certain GPUs, it seems as if the _gl context truncates to an integer automatically. Therefore, if a user tries to pass the width of their canvas element\n    // and it happens to be a float (1000.5 x 600.5 px), the engine.readPixels will return a different size array than context.createImageData\n    // to resolve this, we truncate the floats here to ensure the same size\n    if (width) {\n        width = Math.floor(width);\n    }\n    if (height) {\n        height = Math.floor(height);\n    }\n    return { height: height | 0, width: width | 0 };\n}\n/**\n * Class containing a set of static utilities functions for screenshots\n */\nexport const ScreenshotTools = {\n    /**\n     * Captures a screenshot of the current rendering\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/renderToPNG\n     * @param engine defines the rendering engine\n     * @param camera defines the source camera\n     * @param size This parameter can be set to a single number or to an object with the\n     * following (optional) properties: precision, width, height. If a single number is passed,\n     * it will be used for both width and height. If an object is passed, the screenshot size\n     * will be derived from the parameters. The precision property is a multiplier allowing\n     * rendering at a higher or lower resolution\n     * @param successCallback defines the callback receives a single parameter which contains the\n     * screenshot as a string of base64-encoded characters. This string can be assigned to the\n     * src parameter of an <img> to display it\n     * @param mimeType defines the MIME type of the screenshot image (default: image/png).\n     * Check your browser for supported MIME types\n     * @param forceDownload force the system to download the image even if a successCallback is provided\n     */\n    CreateScreenshot,\n    /**\n     * Captures a screenshot of the current rendering\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/renderToPNG\n     * @param engine defines the rendering engine\n     * @param camera defines the source camera\n     * @param size This parameter can be set to a single number or to an object with the\n     * following (optional) properties: precision, width, height. If a single number is passed,\n     * it will be used for both width and height. If an object is passed, the screenshot size\n     * will be derived from the parameters. The precision property is a multiplier allowing\n     * rendering at a higher or lower resolution\n     * @param mimeType defines the MIME type of the screenshot image (default: image/png).\n     * Check your browser for supported MIME types\n     * @returns screenshot as a string of base64-encoded characters. This string can be assigned\n     * to the src parameter of an <img> to display it\n     */\n    CreateScreenshotAsync,\n    /**\n     * Captures a screenshot of the current rendering for a specific size. This will render the entire canvas but will generate a blink (due to canvas resize)\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/renderToPNG\n     * @param engine defines the rendering engine\n     * @param camera defines the source camera\n     * @param width defines the expected width\n     * @param height defines the expected height\n     * @param mimeType defines the MIME type of the screenshot image (default: image/png).\n     * Check your browser for supported MIME types\n     * @returns screenshot as a string of base64-encoded characters. This string can be assigned\n     * to the src parameter of an <img> to display it\n     */\n    CreateScreenshotWithResizeAsync,\n    /**\n     * Generates an image screenshot from the specified camera.\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/renderToPNG\n     * @param engine The engine to use for rendering\n     * @param camera The camera to use for rendering\n     * @param size This parameter can be set to a single number or to an object with the\n     * following (optional) properties: precision, width, height. If a single number is passed,\n     * it will be used for both width and height. If an object is passed, the screenshot size\n     * will be derived from the parameters. The precision property is a multiplier allowing\n     * rendering at a higher or lower resolution\n     * @param successCallback The callback receives a single parameter which contains the\n     * screenshot as a string of base64-encoded characters. This string can be assigned to the\n     * src parameter of an <img> to display it\n     * @param mimeType The MIME type of the screenshot image (default: image/png).\n     * Check your browser for supported MIME types\n     * @param samples Texture samples (default: 1)\n     * @param antialiasing Whether antialiasing should be turned on or not (default: false)\n     * @param fileName A name for for the downloaded file.\n     * @param renderSprites Whether the sprites should be rendered or not (default: false)\n     * @param enableStencilBuffer Whether the stencil buffer should be enabled or not (default: false)\n     */\n    CreateScreenshotUsingRenderTarget,\n    /**\n     * Generates an image screenshot from the specified camera.\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/renderToPNG\n     * @param engine The engine to use for rendering\n     * @param camera The camera to use for rendering\n     * @param size This parameter can be set to a single number or to an object with the\n     * following (optional) properties: precision, width, height. If a single number is passed,\n     * it will be used for both width and height. If an object is passed, the screenshot size\n     * will be derived from the parameters. The precision property is a multiplier allowing\n     * rendering at a higher or lower resolution\n     * @param mimeType The MIME type of the screenshot image (default: image/png).\n     * Check your browser for supported MIME types\n     * @param samples Texture samples (default: 1)\n     * @param antialiasing Whether antialiasing should be turned on or not (default: false)\n     * @param fileName A name for for the downloaded file.\n     * @param renderSprites Whether the sprites should be rendered or not (default: false)\n     * @returns screenshot as a string of base64-encoded characters. This string can be assigned\n     * to the src parameter of an <img> to display it\n     */\n    CreateScreenshotUsingRenderTargetAsync,\n};\n/**\n * This will be executed automatically for UMD and es5.\n * If esm dev wants the side effects to execute they will have to run it manually\n * Once we build native modules those need to be exported.\n * @internal\n */\nconst initSideEffects = () => {\n    // References the dependencies.\n    Tools.CreateScreenshot = CreateScreenshot;\n    Tools.CreateScreenshotAsync = CreateScreenshotAsync;\n    Tools.CreateScreenshotUsingRenderTarget = CreateScreenshotUsingRenderTarget;\n    Tools.CreateScreenshotUsingRenderTargetAsync = CreateScreenshotUsingRenderTargetAsync;\n};\ninitSideEffects();\n//# sourceMappingURL=screenshotTools.js.map","/**\n * Defines an GC Friendly array where the backfield array do not shrink to prevent over allocations.\n */\nexport class SmartArray {\n    /**\n     * Instantiates a Smart Array.\n     * @param capacity defines the default capacity of the array.\n     */\n    constructor(capacity) {\n        /**\n         * The active length of the array.\n         */\n        this.length = 0;\n        this.data = new Array(capacity);\n        this._id = SmartArray._GlobalId++;\n    }\n    /**\n     * Pushes a value at the end of the active data.\n     * @param value defines the object to push in the array.\n     */\n    push(value) {\n        this.data[this.length++] = value;\n        if (this.length > this.data.length) {\n            this.data.length *= 2;\n        }\n    }\n    /**\n     * Iterates over the active data and apply the lambda to them.\n     * @param func defines the action to apply on each value.\n     */\n    forEach(func) {\n        for (let index = 0; index < this.length; index++) {\n            func(this.data[index]);\n        }\n    }\n    /**\n     * Sorts the full sets of data.\n     * @param compareFn defines the comparison function to apply.\n     */\n    sort(compareFn) {\n        this.data.sort(compareFn);\n    }\n    /**\n     * Resets the active data to an empty array.\n     */\n    reset() {\n        this.length = 0;\n    }\n    /**\n     * Releases all the data from the array as well as the array.\n     */\n    dispose() {\n        this.reset();\n        if (this.data) {\n            this.data.length = 0;\n        }\n    }\n    /**\n     * Concats the active data with a given array.\n     * @param array defines the data to concatenate with.\n     */\n    concat(array) {\n        if (array.length === 0) {\n            return;\n        }\n        if (this.length + array.length > this.data.length) {\n            this.data.length = (this.length + array.length) * 2;\n        }\n        for (let index = 0; index < array.length; index++) {\n            this.data[this.length++] = (array.data || array)[index];\n        }\n    }\n    /**\n     * Returns the position of a value in the active data.\n     * @param value defines the value to find the index for\n     * @returns the index if found in the active data otherwise -1\n     */\n    indexOf(value) {\n        const position = this.data.indexOf(value);\n        if (position >= this.length) {\n            return -1;\n        }\n        return position;\n    }\n    /**\n     * Returns whether an element is part of the active data.\n     * @param value defines the value to look for\n     * @returns true if found in the active data otherwise false\n     */\n    contains(value) {\n        return this.indexOf(value) !== -1;\n    }\n}\n// Statics\nSmartArray._GlobalId = 0;\n/**\n * Defines an GC Friendly array where the backfield array do not shrink to prevent over allocations.\n * The data in this array can only be present once\n */\nexport class SmartArrayNoDuplicate extends SmartArray {\n    constructor() {\n        super(...arguments);\n        this._duplicateId = 0;\n    }\n    /**\n     * Pushes a value at the end of the active data.\n     * THIS DOES NOT PREVENT DUPPLICATE DATA\n     * @param value defines the object to push in the array.\n     */\n    push(value) {\n        super.push(value);\n        if (!value.__smartArrayFlags) {\n            value.__smartArrayFlags = {};\n        }\n        value.__smartArrayFlags[this._id] = this._duplicateId;\n    }\n    /**\n     * Pushes a value at the end of the active data.\n     * If the data is already present, it won t be added again\n     * @param value defines the object to push in the array.\n     * @returns true if added false if it was already present\n     */\n    pushNoDuplicate(value) {\n        if (value.__smartArrayFlags && value.__smartArrayFlags[this._id] === this._duplicateId) {\n            return false;\n        }\n        this.push(value);\n        return true;\n    }\n    /**\n     * Resets the active data to an empty array.\n     */\n    reset() {\n        super.reset();\n        this._duplicateId++;\n    }\n    /**\n     * Concats the active data with a given array.\n     * This ensures no duplicate will be present in the result.\n     * @param array defines the data to concatenate with.\n     */\n    concatWithNoDuplicate(array) {\n        if (array.length === 0) {\n            return;\n        }\n        if (this.length + array.length > this.data.length) {\n            this.data.length = (this.length + array.length) * 2;\n        }\n        for (let index = 0; index < array.length; index++) {\n            const item = (array.data || array)[index];\n            this.pushNoDuplicate(item);\n        }\n    }\n}\n//# sourceMappingURL=smartArray.js.map","/**\n * This class implement a typical dictionary using a string as key and the generic type T as value.\n * The underlying implementation relies on an associative array to ensure the best performances.\n * The value can be anything including 'null' but except 'undefined'\n */\nexport class StringDictionary {\n    constructor() {\n        this._count = 0;\n        this._data = {};\n    }\n    /**\n     * This will clear this dictionary and copy the content from the 'source' one.\n     * If the T value is a custom object, it won't be copied/cloned, the same object will be used\n     * @param source the dictionary to take the content from and copy to this dictionary\n     */\n    copyFrom(source) {\n        this.clear();\n        source.forEach((t, v) => this.add(t, v));\n    }\n    /**\n     * Get a value based from its key\n     * @param key the given key to get the matching value from\n     * @returns the value if found, otherwise undefined is returned\n     */\n    get(key) {\n        const val = this._data[key];\n        if (val !== undefined) {\n            return val;\n        }\n        return undefined;\n    }\n    /**\n     * Get a value from its key or add it if it doesn't exist.\n     * This method will ensure you that a given key/data will be present in the dictionary.\n     * @param key the given key to get the matching value from\n     * @param factory the factory that will create the value if the key is not present in the dictionary.\n     * The factory will only be invoked if there's no data for the given key.\n     * @returns the value corresponding to the key.\n     */\n    getOrAddWithFactory(key, factory) {\n        let val = this.get(key);\n        if (val !== undefined) {\n            return val;\n        }\n        val = factory(key);\n        if (val) {\n            this.add(key, val);\n        }\n        return val;\n    }\n    /**\n     * Get a value from its key if present in the dictionary otherwise add it\n     * @param key the key to get the value from\n     * @param val if there's no such key/value pair in the dictionary add it with this value\n     * @returns the value corresponding to the key\n     */\n    getOrAdd(key, val) {\n        const curVal = this.get(key);\n        if (curVal !== undefined) {\n            return curVal;\n        }\n        this.add(key, val);\n        return val;\n    }\n    /**\n     * Check if there's a given key in the dictionary\n     * @param key the key to check for\n     * @returns true if the key is present, false otherwise\n     */\n    contains(key) {\n        return this._data[key] !== undefined;\n    }\n    /**\n     * Add a new key and its corresponding value\n     * @param key the key to add\n     * @param value the value corresponding to the key\n     * @returns true if the operation completed successfully, false if we couldn't insert the key/value because there was already this key in the dictionary\n     */\n    add(key, value) {\n        if (this._data[key] !== undefined) {\n            return false;\n        }\n        this._data[key] = value;\n        ++this._count;\n        return true;\n    }\n    /**\n     * Update a specific value associated to a key\n     * @param key defines the key to use\n     * @param value defines the value to store\n     * @returns true if the value was updated (or false if the key was not found)\n     */\n    set(key, value) {\n        if (this._data[key] === undefined) {\n            return false;\n        }\n        this._data[key] = value;\n        return true;\n    }\n    /**\n     * Get the element of the given key and remove it from the dictionary\n     * @param key defines the key to search\n     * @returns the value associated with the key or null if not found\n     */\n    getAndRemove(key) {\n        const val = this.get(key);\n        if (val !== undefined) {\n            delete this._data[key];\n            --this._count;\n            return val;\n        }\n        return null;\n    }\n    /**\n     * Remove a key/value from the dictionary.\n     * @param key the key to remove\n     * @returns true if the item was successfully deleted, false if no item with such key exist in the dictionary\n     */\n    remove(key) {\n        if (this.contains(key)) {\n            delete this._data[key];\n            --this._count;\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Clear the whole content of the dictionary\n     */\n    clear() {\n        this._data = {};\n        this._count = 0;\n    }\n    /**\n     * Gets the current count\n     */\n    get count() {\n        return this._count;\n    }\n    /**\n     * Execute a callback on each key/val of the dictionary.\n     * Note that you can remove any element in this dictionary in the callback implementation\n     * @param callback the callback to execute on a given key/value pair\n     */\n    forEach(callback) {\n        for (const cur in this._data) {\n            const val = this._data[cur];\n            callback(cur, val);\n        }\n    }\n    /**\n     * Execute a callback on every occurrence of the dictionary until it returns a valid TRes object.\n     * If the callback returns null or undefined the method will iterate to the next key/value pair\n     * Note that you can remove any element in this dictionary in the callback implementation\n     * @param callback the callback to execute, if it return a valid T instanced object the enumeration will stop and the object will be returned\n     * @returns the first item\n     */\n    first(callback) {\n        for (const cur in this._data) {\n            const val = this._data[cur];\n            const res = callback(cur, val);\n            if (res) {\n                return res;\n            }\n        }\n        return null;\n    }\n}\n//# sourceMappingURL=stringDictionary.js.map","/* eslint-disable @typescript-eslint/naming-convention */\n/**\n * Checks for a matching suffix at the end of a string (for ES5 and lower)\n * @param str Source string\n * @param suffix Suffix to search for in the source string\n * @returns Boolean indicating whether the suffix was found (true) or not (false)\n * @deprecated Please use native string function instead\n */\nexport const EndsWith = (str, suffix) => {\n    return str.endsWith(suffix);\n};\n/**\n * Checks for a matching suffix at the beginning of a string (for ES5 and lower)\n * @param str Source string\n * @param suffix Suffix to search for in the source string\n * @returns Boolean indicating whether the suffix was found (true) or not (false)\n * @deprecated Please use native string function instead\n */\nexport const StartsWith = (str, suffix) => {\n    if (!str) {\n        return false;\n    }\n    return str.startsWith(suffix);\n};\n/**\n * Decodes a buffer into a string\n * @param buffer The buffer to decode\n * @returns The decoded string\n */\nexport const Decode = (buffer) => {\n    if (typeof TextDecoder !== \"undefined\") {\n        return new TextDecoder().decode(buffer);\n    }\n    let result = \"\";\n    for (let i = 0; i < buffer.byteLength; i++) {\n        result += String.fromCharCode(buffer[i]);\n    }\n    return result;\n};\n/**\n * Encode a buffer to a base64 string\n * @param buffer defines the buffer to encode\n * @returns the encoded string\n */\nexport const EncodeArrayBufferToBase64 = (buffer) => {\n    const keyStr = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\n    let output = \"\";\n    let chr1, chr2, chr3, enc1, enc2, enc3, enc4;\n    let i = 0;\n    const bytes = ArrayBuffer.isView(buffer) ? new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength) : new Uint8Array(buffer);\n    while (i < bytes.length) {\n        chr1 = bytes[i++];\n        chr2 = i < bytes.length ? bytes[i++] : Number.NaN;\n        chr3 = i < bytes.length ? bytes[i++] : Number.NaN;\n        enc1 = chr1 >> 2;\n        enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);\n        enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);\n        enc4 = chr3 & 63;\n        if (isNaN(chr2)) {\n            enc3 = enc4 = 64;\n        }\n        else if (isNaN(chr3)) {\n            enc4 = 64;\n        }\n        output += keyStr.charAt(enc1) + keyStr.charAt(enc2) + keyStr.charAt(enc3) + keyStr.charAt(enc4);\n    }\n    return output;\n};\n/**\n * Converts a given base64 string as an ASCII encoded stream of data\n * @param base64Data The base64 encoded string to decode\n * @returns Decoded ASCII string\n */\nexport const DecodeBase64ToString = (base64Data) => {\n    return atob(base64Data);\n};\n/**\n * Converts a given base64 string into an ArrayBuffer of raw byte data\n * @param base64Data The base64 encoded string to decode\n * @returns ArrayBuffer of byte data\n */\nexport const DecodeBase64ToBinary = (base64Data) => {\n    const decodedString = DecodeBase64ToString(base64Data);\n    const bufferLength = decodedString.length;\n    const bufferView = new Uint8Array(new ArrayBuffer(bufferLength));\n    for (let i = 0; i < bufferLength; i++) {\n        bufferView[i] = decodedString.charCodeAt(i);\n    }\n    return bufferView.buffer;\n};\n/**\n * Converts a number to string and pads with preceding zeroes until it is of specified length.\n * @param num the number to convert and pad\n * @param length the expected length of the string\n * @returns the padded string\n */\nexport const PadNumber = (num, length) => {\n    let str = String(num);\n    while (str.length < length) {\n        str = \"0\" + str;\n    }\n    return str;\n};\n/**\n * Helper to manipulate strings\n */\nexport const StringTools = {\n    EndsWith,\n    StartsWith,\n    Decode,\n    EncodeArrayBufferToBase64,\n    DecodeBase64ToString,\n    DecodeBase64ToBinary,\n    PadNumber,\n};\n//# sourceMappingURL=stringTools.js.map","import { AndOrNotEvaluator } from \"./andOrNotEvaluator.js\";\n/**\n * Class used to store custom tags\n */\nexport class Tags {\n    /**\n     * Adds support for tags on the given object\n     * @param obj defines the object to use\n     */\n    static EnableFor(obj) {\n        obj._tags = obj._tags || {};\n        obj.hasTags = () => {\n            return Tags.HasTags(obj);\n        };\n        obj.addTags = (tagsString) => {\n            return Tags.AddTagsTo(obj, tagsString);\n        };\n        obj.removeTags = (tagsString) => {\n            return Tags.RemoveTagsFrom(obj, tagsString);\n        };\n        obj.matchesTagsQuery = (tagsQuery) => {\n            return Tags.MatchesQuery(obj, tagsQuery);\n        };\n    }\n    /**\n     * Removes tags support\n     * @param obj defines the object to use\n     */\n    static DisableFor(obj) {\n        delete obj._tags;\n        delete obj.hasTags;\n        delete obj.addTags;\n        delete obj.removeTags;\n        delete obj.matchesTagsQuery;\n    }\n    /**\n     * Gets a boolean indicating if the given object has tags\n     * @param obj defines the object to use\n     * @returns a boolean\n     */\n    static HasTags(obj) {\n        if (!obj._tags) {\n            return false;\n        }\n        const tags = obj._tags;\n        for (const i in tags) {\n            if (Object.prototype.hasOwnProperty.call(tags, i)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * Gets the tags available on a given object\n     * @param obj defines the object to use\n     * @param asString defines if the tags must be returned as a string instead of an array of strings\n     * @returns the tags\n     */\n    static GetTags(obj, asString = true) {\n        if (!obj._tags) {\n            return null;\n        }\n        if (asString) {\n            const tagsArray = [];\n            for (const tag in obj._tags) {\n                if (Object.prototype.hasOwnProperty.call(obj._tags, tag) && obj._tags[tag] === true) {\n                    tagsArray.push(tag);\n                }\n            }\n            return tagsArray.join(\" \");\n        }\n        else {\n            return obj._tags;\n        }\n    }\n    /**\n     * Adds tags to an object\n     * @param obj defines the object to use\n     * @param tagsString defines the tag string. The tags 'true' and 'false' are reserved and cannot be used as tags.\n     * A tag cannot start with '||', '&&', and '!'. It cannot contain whitespaces\n     */\n    static AddTagsTo(obj, tagsString) {\n        if (!tagsString) {\n            return;\n        }\n        if (typeof tagsString !== \"string\") {\n            return;\n        }\n        const tags = tagsString.split(\" \");\n        tags.forEach(function (tag) {\n            Tags._AddTagTo(obj, tag);\n        });\n    }\n    /**\n     * @internal\n     */\n    static _AddTagTo(obj, tag) {\n        tag = tag.trim();\n        if (tag === \"\" || tag === \"true\" || tag === \"false\") {\n            return;\n        }\n        if (tag.match(/[\\s]/) || tag.match(/^([!]|([|]|[&]){2})/)) {\n            return;\n        }\n        Tags.EnableFor(obj);\n        obj._tags[tag] = true;\n    }\n    /**\n     * Removes specific tags from a specific object\n     * @param obj defines the object to use\n     * @param tagsString defines the tags to remove\n     */\n    static RemoveTagsFrom(obj, tagsString) {\n        if (!Tags.HasTags(obj)) {\n            return;\n        }\n        const tags = tagsString.split(\" \");\n        for (const t in tags) {\n            Tags._RemoveTagFrom(obj, tags[t]);\n        }\n    }\n    /**\n     * @internal\n     */\n    static _RemoveTagFrom(obj, tag) {\n        delete obj._tags[tag];\n    }\n    /**\n     * Defines if tags hosted on an object match a given query\n     * @param obj defines the object to use\n     * @param tagsQuery defines the tag query\n     * @returns a boolean\n     */\n    static MatchesQuery(obj, tagsQuery) {\n        if (tagsQuery === undefined) {\n            return true;\n        }\n        if (tagsQuery === \"\") {\n            return Tags.HasTags(obj);\n        }\n        return AndOrNotEvaluator.Eval(tagsQuery, (r) => Tags.HasTags(obj) && obj._tags[r]);\n    }\n}\n//# sourceMappingURL=tags.js.map","import { Texture } from \"../Materials/Textures/texture.js\";\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture.js\";\nimport { PassPostProcess } from \"../PostProcesses/passPostProcess.js\";\n\nimport { PostProcess } from \"../PostProcesses/postProcess.js\";\n/**\n * Uses the GPU to create a copy texture rescaled at a given size\n * @param texture Texture to copy from\n * @param width defines the desired width\n * @param height defines the desired height\n * @param useBilinearMode defines if bilinear mode has to be used\n * @returns the generated texture\n */\nexport function CreateResizedCopy(texture, width, height, useBilinearMode = true) {\n    const scene = texture.getScene();\n    const engine = scene.getEngine();\n    const rtt = new RenderTargetTexture(\"resized\" + texture.name, { width: width, height: height }, scene, !texture.noMipmap, true, texture._texture.type, false, texture.samplingMode, false);\n    rtt.wrapU = texture.wrapU;\n    rtt.wrapV = texture.wrapV;\n    rtt.uOffset = texture.uOffset;\n    rtt.vOffset = texture.vOffset;\n    rtt.uScale = texture.uScale;\n    rtt.vScale = texture.vScale;\n    rtt.uAng = texture.uAng;\n    rtt.vAng = texture.vAng;\n    rtt.wAng = texture.wAng;\n    rtt.coordinatesIndex = texture.coordinatesIndex;\n    rtt.level = texture.level;\n    rtt.anisotropicFilteringLevel = texture.anisotropicFilteringLevel;\n    rtt._texture.isReady = false;\n    texture.wrapU = Texture.CLAMP_ADDRESSMODE;\n    texture.wrapV = Texture.CLAMP_ADDRESSMODE;\n    const passPostProcess = new PassPostProcess(\"pass\", 1, null, useBilinearMode ? Texture.BILINEAR_SAMPLINGMODE : Texture.NEAREST_SAMPLINGMODE, engine, false, 0);\n    passPostProcess.externalTextureSamplerBinding = true;\n    passPostProcess.getEffect().executeWhenCompiled(() => {\n        passPostProcess.onApply = function (effect) {\n            effect.setTexture(\"textureSampler\", texture);\n        };\n        const internalTexture = rtt.renderTarget;\n        if (internalTexture) {\n            scene.postProcessManager.directRender([passPostProcess], internalTexture);\n            engine.unBindFramebuffer(internalTexture);\n            rtt.disposeFramebufferObjects();\n            passPostProcess.dispose();\n            rtt.getInternalTexture().isReady = true;\n        }\n    });\n    return rtt;\n}\n/**\n * Apply a post process to a texture\n * @param postProcessName name of the fragment post process\n * @param internalTexture the texture to encode\n * @param scene the scene hosting the texture\n * @param type type of the output texture. If not provided, use the one from internalTexture\n * @param samplingMode sampling mode to use to sample the source texture. If not provided, use the one from internalTexture\n * @param format format of the output texture. If not provided, use the one from internalTexture\n * @returns a promise with the internalTexture having its texture replaced by the result of the processing\n */\nexport function ApplyPostProcess(postProcessName, internalTexture, scene, type, samplingMode, format) {\n    // Gets everything ready.\n    const engine = internalTexture.getEngine();\n    internalTexture.isReady = false;\n    samplingMode = samplingMode !== null && samplingMode !== void 0 ? samplingMode : internalTexture.samplingMode;\n    type = type !== null && type !== void 0 ? type : internalTexture.type;\n    format = format !== null && format !== void 0 ? format : internalTexture.format;\n    if (type === -1) {\n        type = 0;\n    }\n    return new Promise((resolve) => {\n        // Create the post process\n        const postProcess = new PostProcess(\"postprocess\", postProcessName, null, null, 1, null, samplingMode, engine, false, undefined, type, undefined, null, false, format);\n        postProcess.externalTextureSamplerBinding = true;\n        // Hold the output of the decoding.\n        const encodedTexture = engine.createRenderTargetTexture({ width: internalTexture.width, height: internalTexture.height }, {\n            generateDepthBuffer: false,\n            generateMipMaps: false,\n            generateStencilBuffer: false,\n            samplingMode,\n            type,\n            format,\n        });\n        postProcess.getEffect().executeWhenCompiled(() => {\n            // PP Render Pass\n            postProcess.onApply = (effect) => {\n                effect._bindTexture(\"textureSampler\", internalTexture);\n                effect.setFloat2(\"scale\", 1, 1);\n            };\n            scene.postProcessManager.directRender([postProcess], encodedTexture, true);\n            // Cleanup\n            engine.restoreDefaultFramebuffer();\n            engine._releaseTexture(internalTexture);\n            if (postProcess) {\n                postProcess.dispose();\n            }\n            // Internal Swap\n            encodedTexture._swapAndDie(internalTexture);\n            // Ready to get rolling again.\n            internalTexture.type = type;\n            internalTexture.format = 5;\n            internalTexture.isReady = true;\n            resolve(internalTexture);\n        });\n    });\n}\n// ref: http://stackoverflow.com/questions/32633585/how-do-you-convert-to-half-floats-in-javascript\nlet floatView;\nlet int32View;\n/**\n * Converts a number to half float\n * @param value number to convert\n * @returns converted number\n */\nexport function ToHalfFloat(value) {\n    if (!floatView) {\n        floatView = new Float32Array(1);\n        int32View = new Int32Array(floatView.buffer);\n    }\n    floatView[0] = value;\n    const x = int32View[0];\n    let bits = (x >> 16) & 0x8000; /* Get the sign */\n    let m = (x >> 12) & 0x07ff; /* Keep one extra bit for rounding */\n    const e = (x >> 23) & 0xff; /* Using int is faster here */\n    /* If zero, or denormal, or exponent underflows too much for a denormal\n     * half, return signed zero. */\n    if (e < 103) {\n        return bits;\n    }\n    /* If NaN, return NaN. If Inf or exponent overflow, return Inf. */\n    if (e > 142) {\n        bits |= 0x7c00;\n        /* If exponent was 0xff and one mantissa bit was set, it means NaN,\n         * not Inf, so make sure we set one mantissa bit too. */\n        bits |= (e == 255 ? 0 : 1) && x & 0x007fffff;\n        return bits;\n    }\n    /* If exponent underflows but not too much, return a denormal */\n    if (e < 113) {\n        m |= 0x0800;\n        /* Extra rounding may overflow and set mantissa to 0 and exponent\n         * to 1, which is OK. */\n        bits |= (m >> (114 - e)) + ((m >> (113 - e)) & 1);\n        return bits;\n    }\n    bits |= ((e - 112) << 10) | (m >> 1);\n    bits += m & 1;\n    return bits;\n}\n/**\n * Converts a half float to a number\n * @param value half float to convert\n * @returns converted half float\n */\nexport function FromHalfFloat(value) {\n    const s = (value & 0x8000) >> 15;\n    const e = (value & 0x7c00) >> 10;\n    const f = value & 0x03ff;\n    if (e === 0) {\n        return (s ? -1 : 1) * Math.pow(2, -14) * (f / Math.pow(2, 10));\n    }\n    else if (e == 0x1f) {\n        return f ? NaN : (s ? -1 : 1) * Infinity;\n    }\n    return (s ? -1 : 1) * Math.pow(2, e - 15) * (1 + f / Math.pow(2, 10));\n}\n/**\n * Class used to host texture specific utilities\n */\nexport const TextureTools = {\n    /**\n     * Uses the GPU to create a copy texture rescaled at a given size\n     * @param texture Texture to copy from\n     * @param width defines the desired width\n     * @param height defines the desired height\n     * @param useBilinearMode defines if bilinear mode has to be used\n     * @returns the generated texture\n     */\n    CreateResizedCopy,\n    /**\n     * Apply a post process to a texture\n     * @param postProcessName name of the fragment post process\n     * @param internalTexture the texture to encode\n     * @param scene the scene hosting the texture\n     * @param type type of the output texture. If not provided, use the one from internalTexture\n     * @param samplingMode sampling mode to use to sample the source texture. If not provided, use the one from internalTexture\n     * @param format format of the output texture. If not provided, use the one from internalTexture\n     * @returns a promise with the internalTexture having its texture replaced by the result of the processing\n     */\n    ApplyPostProcess,\n    /**\n     * Converts a number to half float\n     * @param value number to convert\n     * @returns converted number\n     */\n    ToHalfFloat,\n    /**\n     * Converts a half float to a number\n     * @param value half float to convert\n     * @returns converted half float\n     */\n    FromHalfFloat,\n};\n//# sourceMappingURL=textureTools.js.map","import { Logger } from \"../Misc/logger.js\";\n//private static _TYPE_NO_DATA = 0;\nconst _TYPE_INDEXED = 1;\nconst _TYPE_RGB = 2;\nconst _TYPE_GREY = 3;\nconst _TYPE_RLE_INDEXED = 9;\nconst _TYPE_RLE_RGB = 10;\nconst _TYPE_RLE_GREY = 11;\nconst _ORIGIN_MASK = 0x30;\nconst _ORIGIN_SHIFT = 0x04;\nconst _ORIGIN_BL = 0x00;\nconst _ORIGIN_BR = 0x01;\nconst _ORIGIN_UL = 0x02;\nconst _ORIGIN_UR = 0x03;\n/**\n * Gets the header of a TGA file\n * @param data defines the TGA data\n * @returns the header\n */\nexport function GetTGAHeader(data) {\n    let offset = 0;\n    const header = {\n        id_length: data[offset++],\n        colormap_type: data[offset++],\n        image_type: data[offset++],\n        colormap_index: data[offset++] | (data[offset++] << 8),\n        colormap_length: data[offset++] | (data[offset++] << 8),\n        colormap_size: data[offset++],\n        origin: [data[offset++] | (data[offset++] << 8), data[offset++] | (data[offset++] << 8)],\n        width: data[offset++] | (data[offset++] << 8),\n        height: data[offset++] | (data[offset++] << 8),\n        pixel_size: data[offset++],\n        flags: data[offset++],\n    };\n    return header;\n}\n/**\n * Uploads TGA content to a Babylon Texture\n * @internal\n */\nexport function UploadContent(texture, data) {\n    // Not enough data to contain header ?\n    if (data.length < 19) {\n        Logger.Error(\"Unable to load TGA file - Not enough data to contain header\");\n        return;\n    }\n    // Read Header\n    let offset = 18;\n    const header = GetTGAHeader(data);\n    // Assume it's a valid Targa file.\n    if (header.id_length + offset > data.length) {\n        Logger.Error(\"Unable to load TGA file - Not enough data\");\n        return;\n    }\n    // Skip not needed data\n    offset += header.id_length;\n    let use_rle = false;\n    let use_pal = false;\n    let use_grey = false;\n    // Get some informations.\n    switch (header.image_type) {\n        case _TYPE_RLE_INDEXED:\n            use_rle = true;\n        // eslint-disable-next-line no-fallthrough\n        case _TYPE_INDEXED:\n            use_pal = true;\n            break;\n        case _TYPE_RLE_RGB:\n            use_rle = true;\n        // eslint-disable-next-line no-fallthrough\n        case _TYPE_RGB:\n            // use_rgb = true;\n            break;\n        case _TYPE_RLE_GREY:\n            use_rle = true;\n        // eslint-disable-next-line no-fallthrough\n        case _TYPE_GREY:\n            use_grey = true;\n            break;\n    }\n    let pixel_data;\n    // var numAlphaBits = header.flags & 0xf;\n    const pixel_size = header.pixel_size >> 3;\n    const pixel_total = header.width * header.height * pixel_size;\n    // Read palettes\n    let palettes;\n    if (use_pal) {\n        palettes = data.subarray(offset, (offset += header.colormap_length * (header.colormap_size >> 3)));\n    }\n    // Read LRE\n    if (use_rle) {\n        pixel_data = new Uint8Array(pixel_total);\n        let c, count, i;\n        let localOffset = 0;\n        const pixels = new Uint8Array(pixel_size);\n        while (offset < pixel_total && localOffset < pixel_total) {\n            c = data[offset++];\n            count = (c & 0x7f) + 1;\n            // RLE pixels\n            if (c & 0x80) {\n                // Bind pixel tmp array\n                for (i = 0; i < pixel_size; ++i) {\n                    pixels[i] = data[offset++];\n                }\n                // Copy pixel array\n                for (i = 0; i < count; ++i) {\n                    pixel_data.set(pixels, localOffset + i * pixel_size);\n                }\n                localOffset += pixel_size * count;\n            }\n            // Raw pixels\n            else {\n                count *= pixel_size;\n                for (i = 0; i < count; ++i) {\n                    pixel_data[localOffset + i] = data[offset++];\n                }\n                localOffset += count;\n            }\n        }\n    }\n    // RAW Pixels\n    else {\n        pixel_data = data.subarray(offset, (offset += use_pal ? header.width * header.height : pixel_total));\n    }\n    // Load to texture\n    let x_start, y_start, x_step, y_step, y_end, x_end;\n    switch ((header.flags & _ORIGIN_MASK) >> _ORIGIN_SHIFT) {\n        default:\n        case _ORIGIN_UL:\n            x_start = 0;\n            x_step = 1;\n            x_end = header.width;\n            y_start = 0;\n            y_step = 1;\n            y_end = header.height;\n            break;\n        case _ORIGIN_BL:\n            x_start = 0;\n            x_step = 1;\n            x_end = header.width;\n            y_start = header.height - 1;\n            y_step = -1;\n            y_end = -1;\n            break;\n        case _ORIGIN_UR:\n            x_start = header.width - 1;\n            x_step = -1;\n            x_end = -1;\n            y_start = 0;\n            y_step = 1;\n            y_end = header.height;\n            break;\n        case _ORIGIN_BR:\n            x_start = header.width - 1;\n            x_step = -1;\n            x_end = -1;\n            y_start = header.height - 1;\n            y_step = -1;\n            y_end = -1;\n            break;\n    }\n    // Load the specify method\n    const func = \"_getImageData\" + (use_grey ? \"Grey\" : \"\") + header.pixel_size + \"bits\";\n    const imageData = TGATools[func](header, palettes, pixel_data, y_start, y_step, y_end, x_start, x_step, x_end);\n    const engine = texture.getEngine();\n    engine._uploadDataToTextureDirectly(texture, imageData);\n}\n/**\n * @internal\n */\nfunction _getImageData8bits(header, palettes, pixel_data, y_start, y_step, y_end, x_start, x_step, x_end) {\n    const image = pixel_data, colormap = palettes;\n    const width = header.width, height = header.height;\n    let color, i = 0, x, y;\n    const imageData = new Uint8Array(width * height * 4);\n    for (y = y_start; y !== y_end; y += y_step) {\n        for (x = x_start; x !== x_end; x += x_step, i++) {\n            color = image[i];\n            imageData[(x + width * y) * 4 + 3] = 255;\n            imageData[(x + width * y) * 4 + 2] = colormap[color * 3 + 0];\n            imageData[(x + width * y) * 4 + 1] = colormap[color * 3 + 1];\n            imageData[(x + width * y) * 4 + 0] = colormap[color * 3 + 2];\n        }\n    }\n    return imageData;\n}\n/**\n * @internal\n */\nfunction _getImageData16bits(header, palettes, pixel_data, y_start, y_step, y_end, x_start, x_step, x_end) {\n    const image = pixel_data;\n    const width = header.width, height = header.height;\n    let color, i = 0, x, y;\n    const imageData = new Uint8Array(width * height * 4);\n    for (y = y_start; y !== y_end; y += y_step) {\n        for (x = x_start; x !== x_end; x += x_step, i += 2) {\n            color = image[i + 0] + (image[i + 1] << 8); // Inversed ?\n            const r = ((((color & 0x7c00) >> 10) * 255) / 0x1f) | 0;\n            const g = ((((color & 0x03e0) >> 5) * 255) / 0x1f) | 0;\n            const b = (((color & 0x001f) * 255) / 0x1f) | 0;\n            imageData[(x + width * y) * 4 + 0] = r;\n            imageData[(x + width * y) * 4 + 1] = g;\n            imageData[(x + width * y) * 4 + 2] = b;\n            imageData[(x + width * y) * 4 + 3] = color & 0x8000 ? 0 : 255;\n        }\n    }\n    return imageData;\n}\n/**\n * @internal\n */\nfunction _getImageData24bits(header, palettes, pixel_data, y_start, y_step, y_end, x_start, x_step, x_end) {\n    const image = pixel_data;\n    const width = header.width, height = header.height;\n    let i = 0, x, y;\n    const imageData = new Uint8Array(width * height * 4);\n    for (y = y_start; y !== y_end; y += y_step) {\n        for (x = x_start; x !== x_end; x += x_step, i += 3) {\n            imageData[(x + width * y) * 4 + 3] = 255;\n            imageData[(x + width * y) * 4 + 2] = image[i + 0];\n            imageData[(x + width * y) * 4 + 1] = image[i + 1];\n            imageData[(x + width * y) * 4 + 0] = image[i + 2];\n        }\n    }\n    return imageData;\n}\n/**\n * @internal\n */\nfunction _getImageData32bits(header, palettes, pixel_data, y_start, y_step, y_end, x_start, x_step, x_end) {\n    const image = pixel_data;\n    const width = header.width, height = header.height;\n    let i = 0, x, y;\n    const imageData = new Uint8Array(width * height * 4);\n    for (y = y_start; y !== y_end; y += y_step) {\n        for (x = x_start; x !== x_end; x += x_step, i += 4) {\n            imageData[(x + width * y) * 4 + 2] = image[i + 0];\n            imageData[(x + width * y) * 4 + 1] = image[i + 1];\n            imageData[(x + width * y) * 4 + 0] = image[i + 2];\n            imageData[(x + width * y) * 4 + 3] = image[i + 3];\n        }\n    }\n    return imageData;\n}\n/**\n * @internal\n */\nfunction _getImageDataGrey8bits(header, palettes, pixel_data, y_start, y_step, y_end, x_start, x_step, x_end) {\n    const image = pixel_data;\n    const width = header.width, height = header.height;\n    let color, i = 0, x, y;\n    const imageData = new Uint8Array(width * height * 4);\n    for (y = y_start; y !== y_end; y += y_step) {\n        for (x = x_start; x !== x_end; x += x_step, i++) {\n            color = image[i];\n            imageData[(x + width * y) * 4 + 0] = color;\n            imageData[(x + width * y) * 4 + 1] = color;\n            imageData[(x + width * y) * 4 + 2] = color;\n            imageData[(x + width * y) * 4 + 3] = 255;\n        }\n    }\n    return imageData;\n}\n/**\n * @internal\n */\nfunction _getImageDataGrey16bits(header, palettes, pixel_data, y_start, y_step, y_end, x_start, x_step, x_end) {\n    const image = pixel_data;\n    const width = header.width, height = header.height;\n    let i = 0, x, y;\n    const imageData = new Uint8Array(width * height * 4);\n    for (y = y_start; y !== y_end; y += y_step) {\n        for (x = x_start; x !== x_end; x += x_step, i += 2) {\n            imageData[(x + width * y) * 4 + 0] = image[i + 0];\n            imageData[(x + width * y) * 4 + 1] = image[i + 0];\n            imageData[(x + width * y) * 4 + 2] = image[i + 0];\n            imageData[(x + width * y) * 4 + 3] = image[i + 1];\n        }\n    }\n    return imageData;\n}\n/**\n * Based on jsTGALoader - Javascript loader for TGA file\n * By Vincent Thibault\n * @see http://blog.robrowser.com/javascript-tga-loader.html\n */\nexport const TGATools = {\n    /**\n     * Gets the header of a TGA file\n     * @param data defines the TGA data\n     * @returns the header\n     */\n    GetTGAHeader,\n    /**\n     * Uploads TGA content to a Babylon Texture\n     * @internal\n     */\n    UploadContent,\n    /** @internal */\n    _getImageData8bits,\n    /** @internal */\n    _getImageData16bits,\n    /** @internal */\n    _getImageData24bits,\n    /** @internal */\n    _getImageData32bits,\n    /** @internal */\n    _getImageDataGrey8bits,\n    /** @internal */\n    _getImageDataGrey16bits,\n};\n//# sourceMappingURL=tga.js.map","import { Observable } from \"../Misc/observable.js\";\n/**\n * The current state of the timer\n */\nexport var TimerState;\n(function (TimerState) {\n    /**\n     * Timer initialized, not yet started\n     */\n    TimerState[TimerState[\"INIT\"] = 0] = \"INIT\";\n    /**\n     * Timer started and counting\n     */\n    TimerState[TimerState[\"STARTED\"] = 1] = \"STARTED\";\n    /**\n     * Timer ended (whether aborted or time reached)\n     */\n    TimerState[TimerState[\"ENDED\"] = 2] = \"ENDED\";\n})(TimerState || (TimerState = {}));\n/**\n * A simple version of the timer. Will take options and start the timer immediately after calling it\n *\n * @param options options with which to initialize this timer\n */\nexport function setAndStartTimer(options) {\n    var _a;\n    let timer = 0;\n    const startTime = Date.now();\n    options.observableParameters = (_a = options.observableParameters) !== null && _a !== void 0 ? _a : {};\n    const observer = options.contextObservable.add((payload) => {\n        const now = Date.now();\n        timer = now - startTime;\n        const data = {\n            startTime,\n            currentTime: now,\n            deltaTime: timer,\n            completeRate: timer / options.timeout,\n            payload,\n        };\n        options.onTick && options.onTick(data);\n        if (options.breakCondition && options.breakCondition()) {\n            options.contextObservable.remove(observer);\n            options.onAborted && options.onAborted(data);\n        }\n        if (timer >= options.timeout) {\n            options.contextObservable.remove(observer);\n            options.onEnded && options.onEnded(data);\n        }\n    }, options.observableParameters.mask, options.observableParameters.insertFirst, options.observableParameters.scope);\n    return observer;\n}\n/**\n * An advanced implementation of a timer class\n */\nexport class AdvancedTimer {\n    /**\n     * Will construct a new advanced timer based on the options provided. Timer will not start until start() is called.\n     * @param options construction options for this advanced timer\n     */\n    constructor(options) {\n        var _a, _b;\n        /**\n         * Will notify each time the timer calculates the remaining time\n         */\n        this.onEachCountObservable = new Observable();\n        /**\n         * Will trigger when the timer was aborted due to the break condition\n         */\n        this.onTimerAbortedObservable = new Observable();\n        /**\n         * Will trigger when the timer ended successfully\n         */\n        this.onTimerEndedObservable = new Observable();\n        /**\n         * Will trigger when the timer state has changed\n         */\n        this.onStateChangedObservable = new Observable();\n        this._observer = null;\n        this._breakOnNextTick = false;\n        this._tick = (payload) => {\n            const now = Date.now();\n            this._timer = now - this._startTime;\n            const data = {\n                startTime: this._startTime,\n                currentTime: now,\n                deltaTime: this._timer,\n                completeRate: this._timer / this._timeToEnd,\n                payload,\n            };\n            const shouldBreak = this._breakOnNextTick || this._breakCondition(data);\n            if (shouldBreak || this._timer >= this._timeToEnd) {\n                this._stop(data, shouldBreak);\n            }\n            else {\n                this.onEachCountObservable.notifyObservers(data);\n            }\n        };\n        this._setState(TimerState.INIT);\n        this._contextObservable = options.contextObservable;\n        this._observableParameters = (_a = options.observableParameters) !== null && _a !== void 0 ? _a : {};\n        this._breakCondition = (_b = options.breakCondition) !== null && _b !== void 0 ? _b : (() => false);\n        this._timeToEnd = options.timeout;\n        if (options.onEnded) {\n            this.onTimerEndedObservable.add(options.onEnded);\n        }\n        if (options.onTick) {\n            this.onEachCountObservable.add(options.onTick);\n        }\n        if (options.onAborted) {\n            this.onTimerAbortedObservable.add(options.onAborted);\n        }\n    }\n    /**\n     * set a breaking condition for this timer. Default is to never break during count\n     * @param predicate the new break condition. Returns true to break, false otherwise\n     */\n    set breakCondition(predicate) {\n        this._breakCondition = predicate;\n    }\n    /**\n     * Reset ALL associated observables in this advanced timer\n     */\n    clearObservables() {\n        this.onEachCountObservable.clear();\n        this.onTimerAbortedObservable.clear();\n        this.onTimerEndedObservable.clear();\n        this.onStateChangedObservable.clear();\n    }\n    /**\n     * Will start a new iteration of this timer. Only one instance of this timer can run at a time.\n     *\n     * @param timeToEnd how much time to measure until timer ended\n     */\n    start(timeToEnd = this._timeToEnd) {\n        if (this._state === TimerState.STARTED) {\n            throw new Error(\"Timer already started. Please stop it before starting again\");\n        }\n        this._timeToEnd = timeToEnd;\n        this._startTime = Date.now();\n        this._timer = 0;\n        this._observer = this._contextObservable.add(this._tick, this._observableParameters.mask, this._observableParameters.insertFirst, this._observableParameters.scope);\n        this._setState(TimerState.STARTED);\n    }\n    /**\n     * Will force a stop on the next tick.\n     */\n    stop() {\n        if (this._state !== TimerState.STARTED) {\n            return;\n        }\n        this._breakOnNextTick = true;\n    }\n    /**\n     * Dispose this timer, clearing all resources\n     */\n    dispose() {\n        if (this._observer) {\n            this._contextObservable.remove(this._observer);\n        }\n        this.clearObservables();\n    }\n    _setState(newState) {\n        this._state = newState;\n        this.onStateChangedObservable.notifyObservers(this._state);\n    }\n    _stop(data, aborted = false) {\n        this._contextObservable.remove(this._observer);\n        this._setState(TimerState.ENDED);\n        if (aborted) {\n            this.onTimerAbortedObservable.notifyObservers(data);\n        }\n        else {\n            this.onTimerEndedObservable.notifyObservers(data);\n        }\n    }\n}\n//# sourceMappingURL=timer.js.map","import { IsWindowObjectExist } from \"./domManagement.js\";\n/**\n * Class used to provide helper for timing\n */\nexport class TimingTools {\n    /**\n     * Polyfill for setImmediate\n     * @param action defines the action to execute after the current execution block\n     */\n    static SetImmediate(action) {\n        if (IsWindowObjectExist() && window.setImmediate) {\n            window.setImmediate(action);\n        }\n        else {\n            setTimeout(action, 1);\n        }\n    }\n}\n//# sourceMappingURL=timingTools.js.map","import { Observable } from \"./observable.js\";\nimport { GetDOMTextContent, IsNavigatorAvailable, IsWindowObjectExist } from \"./domManagement.js\";\nimport { Logger } from \"./logger.js\";\nimport { DeepCopier } from \"./deepCopier.js\";\nimport { PrecisionDate } from \"./precisionDate.js\";\nimport { _WarnImport } from \"./devTools.js\";\nimport { WebRequest } from \"./webRequest.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\nimport { FileToolsOptions, DecodeBase64UrlToBinary, IsBase64DataUrl, LoadFile as FileToolsLoadFile, LoadImage as FileToolLoadImage, ReadFile as FileToolsReadFile, SetCorsBehavior, } from \"./fileTools.js\";\nimport { TimingTools } from \"./timingTools.js\";\nimport { InstantiationTools } from \"./instantiationTools.js\";\nimport { RandomGUID } from \"./guid.js\";\n/**\n * Class containing a set of static utilities functions\n */\nexport class Tools {\n    /**\n     * Gets or sets the base URL to use to load assets\n     */\n    static get BaseUrl() {\n        return FileToolsOptions.BaseUrl;\n    }\n    static set BaseUrl(value) {\n        FileToolsOptions.BaseUrl = value;\n    }\n    /**\n     * Gets or sets the retry strategy to apply when an error happens while loading an asset\n     */\n    static get DefaultRetryStrategy() {\n        return FileToolsOptions.DefaultRetryStrategy;\n    }\n    static set DefaultRetryStrategy(strategy) {\n        FileToolsOptions.DefaultRetryStrategy = strategy;\n    }\n    /**\n     * Default behaviour for cors in the application.\n     * It can be a string if the expected behavior is identical in the entire app.\n     * Or a callback to be able to set it per url or on a group of them (in case of Video source for instance)\n     */\n    static get CorsBehavior() {\n        return FileToolsOptions.CorsBehavior;\n    }\n    static set CorsBehavior(value) {\n        FileToolsOptions.CorsBehavior = value;\n    }\n    /**\n     * Gets or sets a global variable indicating if fallback texture must be used when a texture cannot be loaded\n     * @ignorenaming\n     */\n    static get UseFallbackTexture() {\n        return EngineStore.UseFallbackTexture;\n    }\n    static set UseFallbackTexture(value) {\n        EngineStore.UseFallbackTexture = value;\n    }\n    /**\n     * Use this object to register external classes like custom textures or material\n     * to allow the loaders to instantiate them\n     */\n    static get RegisteredExternalClasses() {\n        return InstantiationTools.RegisteredExternalClasses;\n    }\n    static set RegisteredExternalClasses(classes) {\n        InstantiationTools.RegisteredExternalClasses = classes;\n    }\n    /**\n     * Texture content used if a texture cannot loaded\n     * @ignorenaming\n     */\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    static get fallbackTexture() {\n        return EngineStore.FallbackTexture;\n    }\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    static set fallbackTexture(value) {\n        EngineStore.FallbackTexture = value;\n    }\n    /**\n     * Read the content of a byte array at a specified coordinates (taking in account wrapping)\n     * @param u defines the coordinate on X axis\n     * @param v defines the coordinate on Y axis\n     * @param width defines the width of the source data\n     * @param height defines the height of the source data\n     * @param pixels defines the source byte array\n     * @param color defines the output color\n     */\n    static FetchToRef(u, v, width, height, pixels, color) {\n        const wrappedU = (Math.abs(u) * width) % width | 0;\n        const wrappedV = (Math.abs(v) * height) % height | 0;\n        const position = (wrappedU + wrappedV * width) * 4;\n        color.r = pixels[position] / 255;\n        color.g = pixels[position + 1] / 255;\n        color.b = pixels[position + 2] / 255;\n        color.a = pixels[position + 3] / 255;\n    }\n    /**\n     * Interpolates between a and b via alpha\n     * @param a The lower value (returned when alpha = 0)\n     * @param b The upper value (returned when alpha = 1)\n     * @param alpha The interpolation-factor\n     * @returns The mixed value\n     */\n    static Mix(a, b, alpha) {\n        return a * (1 - alpha) + b * alpha;\n    }\n    /**\n     * Tries to instantiate a new object from a given class name\n     * @param className defines the class name to instantiate\n     * @returns the new object or null if the system was not able to do the instantiation\n     */\n    static Instantiate(className) {\n        return InstantiationTools.Instantiate(className);\n    }\n    /**\n     * Polyfill for setImmediate\n     * @param action defines the action to execute after the current execution block\n     */\n    static SetImmediate(action) {\n        TimingTools.SetImmediate(action);\n    }\n    /**\n     * Function indicating if a number is an exponent of 2\n     * @param value defines the value to test\n     * @returns true if the value is an exponent of 2\n     */\n    static IsExponentOfTwo(value) {\n        let count = 1;\n        do {\n            count *= 2;\n        } while (count < value);\n        return count === value;\n    }\n    /**\n     * Returns the nearest 32-bit single precision float representation of a Number\n     * @param value A Number.  If the parameter is of a different type, it will get converted\n     * to a number or to NaN if it cannot be converted\n     * @returns number\n     */\n    static FloatRound(value) {\n        if (Math.fround) {\n            return Math.fround(value);\n        }\n        return (Tools._TmpFloatArray[0] = value), Tools._TmpFloatArray[0];\n    }\n    /**\n     * Extracts the filename from a path\n     * @param path defines the path to use\n     * @returns the filename\n     */\n    static GetFilename(path) {\n        const index = path.lastIndexOf(\"/\");\n        if (index < 0) {\n            return path;\n        }\n        return path.substring(index + 1);\n    }\n    /**\n     * Extracts the \"folder\" part of a path (everything before the filename).\n     * @param uri The URI to extract the info from\n     * @param returnUnchangedIfNoSlash Do not touch the URI if no slashes are present\n     * @returns The \"folder\" part of the path\n     */\n    static GetFolderPath(uri, returnUnchangedIfNoSlash = false) {\n        const index = uri.lastIndexOf(\"/\");\n        if (index < 0) {\n            if (returnUnchangedIfNoSlash) {\n                return uri;\n            }\n            return \"\";\n        }\n        return uri.substring(0, index + 1);\n    }\n    /**\n     * Convert an angle in radians to degrees\n     * @param angle defines the angle to convert\n     * @returns the angle in degrees\n     */\n    static ToDegrees(angle) {\n        return (angle * 180) / Math.PI;\n    }\n    /**\n     * Convert an angle in degrees to radians\n     * @param angle defines the angle to convert\n     * @returns the angle in radians\n     */\n    static ToRadians(angle) {\n        return (angle * Math.PI) / 180;\n    }\n    /**\n     * Smooth angle changes (kind of low-pass filter), in particular for device orientation \"shaking\"\n     * Use trigonometric functions to avoid discontinuity (0/360, -180/180)\n     * @param previousAngle defines last angle value, in degrees\n     * @param newAngle defines new angle value, in degrees\n     * @param smoothFactor defines smoothing sensitivity; min 0: no smoothing, max 1: new data ignored\n     * @returns the angle in degrees\n     */\n    static SmoothAngleChange(previousAngle, newAngle, smoothFactor = 0.9) {\n        const previousAngleRad = this.ToRadians(previousAngle);\n        const newAngleRad = this.ToRadians(newAngle);\n        return this.ToDegrees(Math.atan2((1 - smoothFactor) * Math.sin(newAngleRad) + smoothFactor * Math.sin(previousAngleRad), (1 - smoothFactor) * Math.cos(newAngleRad) + smoothFactor * Math.cos(previousAngleRad)));\n    }\n    /**\n     * Returns an array if obj is not an array\n     * @param obj defines the object to evaluate as an array\n     * @param allowsNullUndefined defines a boolean indicating if obj is allowed to be null or undefined\n     * @returns either obj directly if obj is an array or a new array containing obj\n     */\n    static MakeArray(obj, allowsNullUndefined) {\n        if (allowsNullUndefined !== true && (obj === undefined || obj == null)) {\n            return null;\n        }\n        return Array.isArray(obj) ? obj : [obj];\n    }\n    /**\n     * Gets the pointer prefix to use\n     * @param engine defines the engine we are finding the prefix for\n     * @returns \"pointer\" if touch is enabled. Else returns \"mouse\"\n     */\n    static GetPointerPrefix(engine) {\n        let eventPrefix = \"pointer\";\n        // Check if pointer events are supported\n        if (IsWindowObjectExist() && !window.PointerEvent) {\n            eventPrefix = \"mouse\";\n        }\n        // Special Fallback MacOS Safari...\n        if (engine._badDesktopOS &&\n            !engine._badOS &&\n            // And not ipad pros who claim to be macs...\n            !(document && \"ontouchend\" in document)) {\n            eventPrefix = \"mouse\";\n        }\n        return eventPrefix;\n    }\n    /**\n     * Sets the cors behavior on a dom element. This will add the required Tools.CorsBehavior to the element.\n     * @param url define the url we are trying\n     * @param element define the dom element where to configure the cors policy\n     * @param element.crossOrigin\n     */\n    static SetCorsBehavior(url, element) {\n        SetCorsBehavior(url, element);\n    }\n    /**\n     * Sets the referrerPolicy behavior on a dom element.\n     * @param referrerPolicy define the referrer policy to use\n     * @param element define the dom element where to configure the referrer policy\n     * @param element.referrerPolicy\n     */\n    static SetReferrerPolicyBehavior(referrerPolicy, element) {\n        element.referrerPolicy = referrerPolicy;\n    }\n    // External files\n    /**\n     * Removes unwanted characters from an url\n     * @param url defines the url to clean\n     * @returns the cleaned url\n     */\n    static CleanUrl(url) {\n        url = url.replace(/#/gm, \"%23\");\n        return url;\n    }\n    /**\n     * Gets or sets a function used to pre-process url before using them to load assets\n     */\n    static get PreprocessUrl() {\n        return FileToolsOptions.PreprocessUrl;\n    }\n    static set PreprocessUrl(processor) {\n        FileToolsOptions.PreprocessUrl = processor;\n    }\n    /**\n     * Loads an image as an HTMLImageElement.\n     * @param input url string, ArrayBuffer, or Blob to load\n     * @param onLoad callback called when the image successfully loads\n     * @param onError callback called when the image fails to load\n     * @param offlineProvider offline provider for caching\n     * @param mimeType optional mime type\n     * @param imageBitmapOptions optional the options to use when creating an ImageBitmap\n     * @returns the HTMLImageElement of the loaded image\n     */\n    static LoadImage(input, onLoad, onError, offlineProvider, mimeType, imageBitmapOptions) {\n        return FileToolLoadImage(input, onLoad, onError, offlineProvider, mimeType, imageBitmapOptions);\n    }\n    /**\n     * Loads a file from a url\n     * @param url url string, ArrayBuffer, or Blob to load\n     * @param onSuccess callback called when the file successfully loads\n     * @param onProgress callback called while file is loading (if the server supports this mode)\n     * @param offlineProvider defines the offline provider for caching\n     * @param useArrayBuffer defines a boolean indicating that date must be returned as ArrayBuffer\n     * @param onError callback called when the file fails to load\n     * @returns a file request object\n     */\n    static LoadFile(url, onSuccess, onProgress, offlineProvider, useArrayBuffer, onError) {\n        return FileToolsLoadFile(url, onSuccess, onProgress, offlineProvider, useArrayBuffer, onError);\n    }\n    /**\n     * Loads a file from a url\n     * @param url the file url to load\n     * @param useArrayBuffer defines a boolean indicating that date must be returned as ArrayBuffer\n     * @returns a promise containing an ArrayBuffer corresponding to the loaded file\n     */\n    static LoadFileAsync(url, useArrayBuffer = true) {\n        return new Promise((resolve, reject) => {\n            FileToolsLoadFile(url, (data) => {\n                resolve(data);\n            }, undefined, undefined, useArrayBuffer, (request, exception) => {\n                reject(exception);\n            });\n        });\n    }\n    /**\n     * Load a script (identified by an url). When the url returns, the\n     * content of this file is added into a new script element, attached to the DOM (body element)\n     * @param scriptUrl defines the url of the script to laod\n     * @param onSuccess defines the callback called when the script is loaded\n     * @param onError defines the callback to call if an error occurs\n     * @param scriptId defines the id of the script element\n     */\n    static LoadScript(scriptUrl, onSuccess, onError, scriptId) {\n        if (typeof importScripts === \"function\") {\n            try {\n                importScripts(scriptUrl);\n                onSuccess();\n            }\n            catch (e) {\n                onError === null || onError === void 0 ? void 0 : onError(`Unable to load script '${scriptUrl}' in worker`, e);\n            }\n            return;\n        }\n        else if (!IsWindowObjectExist()) {\n            onError === null || onError === void 0 ? void 0 : onError(`Cannot load script '${scriptUrl}' outside of a window or a worker`);\n            return;\n        }\n        const head = document.getElementsByTagName(\"head\")[0];\n        const script = document.createElement(\"script\");\n        script.setAttribute(\"type\", \"text/javascript\");\n        script.setAttribute(\"src\", scriptUrl);\n        if (scriptId) {\n            script.id = scriptId;\n        }\n        script.onload = () => {\n            if (onSuccess) {\n                onSuccess();\n            }\n        };\n        script.onerror = (e) => {\n            if (onError) {\n                onError(`Unable to load script '${scriptUrl}'`, e);\n            }\n        };\n        head.appendChild(script);\n    }\n    /**\n     * Load an asynchronous script (identified by an url). When the url returns, the\n     * content of this file is added into a new script element, attached to the DOM (body element)\n     * @param scriptUrl defines the url of the script to laod\n     * @returns a promise request object\n     */\n    static LoadScriptAsync(scriptUrl) {\n        return new Promise((resolve, reject) => {\n            this.LoadScript(scriptUrl, () => {\n                resolve();\n            }, (message, exception) => {\n                reject(exception || new Error(message));\n            });\n        });\n    }\n    /**\n     * Loads a file from a blob\n     * @param fileToLoad defines the blob to use\n     * @param callback defines the callback to call when data is loaded\n     * @param progressCallback defines the callback to call during loading process\n     * @returns a file request object\n     */\n    static ReadFileAsDataURL(fileToLoad, callback, progressCallback) {\n        const reader = new FileReader();\n        const request = {\n            onCompleteObservable: new Observable(),\n            abort: () => reader.abort(),\n        };\n        reader.onloadend = () => {\n            request.onCompleteObservable.notifyObservers(request);\n        };\n        reader.onload = (e) => {\n            //target doesn't have result from ts 1.3\n            callback(e.target[\"result\"]);\n        };\n        reader.onprogress = progressCallback;\n        reader.readAsDataURL(fileToLoad);\n        return request;\n    }\n    /**\n     * Reads a file from a File object\n     * @param file defines the file to load\n     * @param onSuccess defines the callback to call when data is loaded\n     * @param onProgress defines the callback to call during loading process\n     * @param useArrayBuffer defines a boolean indicating that data must be returned as an ArrayBuffer\n     * @param onError defines the callback to call when an error occurs\n     * @returns a file request object\n     */\n    static ReadFile(file, onSuccess, onProgress, useArrayBuffer, onError) {\n        return FileToolsReadFile(file, onSuccess, onProgress, useArrayBuffer, onError);\n    }\n    /**\n     * Creates a data url from a given string content\n     * @param content defines the content to convert\n     * @returns the new data url link\n     */\n    static FileAsURL(content) {\n        const fileBlob = new Blob([content]);\n        const url = window.URL;\n        const link = url.createObjectURL(fileBlob);\n        return link;\n    }\n    /**\n     * Format the given number to a specific decimal format\n     * @param value defines the number to format\n     * @param decimals defines the number of decimals to use\n     * @returns the formatted string\n     */\n    static Format(value, decimals = 2) {\n        return value.toFixed(decimals);\n    }\n    /**\n     * Tries to copy an object by duplicating every property\n     * @param source defines the source object\n     * @param destination defines the target object\n     * @param doNotCopyList defines a list of properties to avoid\n     * @param mustCopyList defines a list of properties to copy (even if they start with _)\n     */\n    static DeepCopy(source, destination, doNotCopyList, mustCopyList) {\n        DeepCopier.DeepCopy(source, destination, doNotCopyList, mustCopyList);\n    }\n    /**\n     * Gets a boolean indicating if the given object has no own property\n     * @param obj defines the object to test\n     * @returns true if object has no own property\n     */\n    static IsEmpty(obj) {\n        for (const i in obj) {\n            if (Object.prototype.hasOwnProperty.call(obj, i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Function used to register events at window level\n     * @param windowElement defines the Window object to use\n     * @param events defines the events to register\n     */\n    static RegisterTopRootEvents(windowElement, events) {\n        for (let index = 0; index < events.length; index++) {\n            const event = events[index];\n            windowElement.addEventListener(event.name, event.handler, false);\n            try {\n                if (window.parent) {\n                    window.parent.addEventListener(event.name, event.handler, false);\n                }\n            }\n            catch (e) {\n                // Silently fails...\n            }\n        }\n    }\n    /**\n     * Function used to unregister events from window level\n     * @param windowElement defines the Window object to use\n     * @param events defines the events to unregister\n     */\n    static UnregisterTopRootEvents(windowElement, events) {\n        for (let index = 0; index < events.length; index++) {\n            const event = events[index];\n            windowElement.removeEventListener(event.name, event.handler);\n            try {\n                if (windowElement.parent) {\n                    windowElement.parent.removeEventListener(event.name, event.handler);\n                }\n            }\n            catch (e) {\n                // Silently fails...\n            }\n        }\n    }\n    /**\n     * Dumps the current bound framebuffer\n     * @param width defines the rendering width\n     * @param height defines the rendering height\n     * @param engine defines the hosting engine\n     * @param successCallback defines the callback triggered once the data are available\n     * @param mimeType defines the mime type of the result\n     * @param fileName defines the filename to download. If present, the result will automatically be downloaded\n     * @returns a void promise\n     */\n    static async DumpFramebuffer(width, height, engine, successCallback, mimeType = \"image/png\", fileName) {\n        throw _WarnImport(\"DumpTools\");\n    }\n    /**\n     * Dumps an array buffer\n     * @param width defines the rendering width\n     * @param height defines the rendering height\n     * @param data the data array\n     * @param successCallback defines the callback triggered once the data are available\n     * @param mimeType defines the mime type of the result\n     * @param fileName defines the filename to download. If present, the result will automatically be downloaded\n     * @param invertY true to invert the picture in the Y dimension\n     * @param toArrayBuffer true to convert the data to an ArrayBuffer (encoded as `mimeType`) instead of a base64 string\n     * @param quality defines the quality of the result\n     */\n    static DumpData(width, height, data, successCallback, mimeType = \"image/png\", fileName, invertY = false, toArrayBuffer = false, quality) {\n        throw _WarnImport(\"DumpTools\");\n    }\n    /**\n     * Dumps an array buffer\n     * @param width defines the rendering width\n     * @param height defines the rendering height\n     * @param data the data array\n     * @param mimeType defines the mime type of the result\n     * @param fileName defines the filename to download. If present, the result will automatically be downloaded\n     * @param invertY true to invert the picture in the Y dimension\n     * @param toArrayBuffer true to convert the data to an ArrayBuffer (encoded as `mimeType`) instead of a base64 string\n     * @param quality defines the quality of the result\n     * @returns a promise that resolve to the final data\n     */\n    static DumpDataAsync(width, height, data, mimeType = \"image/png\", fileName, invertY = false, toArrayBuffer = false, quality) {\n        throw _WarnImport(\"DumpTools\");\n    }\n    /**\n     * Converts the canvas data to blob.\n     * This acts as a polyfill for browsers not supporting the to blob function.\n     * @param canvas Defines the canvas to extract the data from\n     * @param successCallback Defines the callback triggered once the data are available\n     * @param mimeType Defines the mime type of the result\n     * @param quality defines the quality of the result\n     */\n    static ToBlob(canvas, successCallback, mimeType = \"image/png\", quality) {\n        // We need HTMLCanvasElement.toBlob for HD screenshots\n        if (!canvas.toBlob) {\n            //  low performance polyfill based on toDataURL (https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob)\n            canvas.toBlob = function (callback, type, quality) {\n                setTimeout(() => {\n                    const binStr = atob(this.toDataURL(type, quality).split(\",\")[1]), len = binStr.length, arr = new Uint8Array(len);\n                    for (let i = 0; i < len; i++) {\n                        arr[i] = binStr.charCodeAt(i);\n                    }\n                    callback(new Blob([arr]));\n                });\n            };\n        }\n        canvas.toBlob(function (blob) {\n            successCallback(blob);\n        }, mimeType, quality);\n    }\n    /**\n     * Download a Blob object\n     * @param blob the Blob object\n     * @param fileName the file name to download\n     * @returns\n     */\n    static DownloadBlob(blob, fileName) {\n        //Creating a link if the browser have the download attribute on the a tag, to automatically start download generated image.\n        if (\"download\" in document.createElement(\"a\")) {\n            if (!fileName) {\n                const date = new Date();\n                const stringDate = (date.getFullYear() + \"-\" + (date.getMonth() + 1)).slice(2) + \"-\" + date.getDate() + \"_\" + date.getHours() + \"-\" + (\"0\" + date.getMinutes()).slice(-2);\n                fileName = \"screenshot_\" + stringDate + \".png\";\n            }\n            Tools.Download(blob, fileName);\n        }\n        else {\n            if (blob && typeof URL !== \"undefined\") {\n                const url = URL.createObjectURL(blob);\n                const newWindow = window.open(\"\");\n                if (!newWindow) {\n                    return;\n                }\n                const img = newWindow.document.createElement(\"img\");\n                img.onload = function () {\n                    // no longer need to read the blob so it's revoked\n                    URL.revokeObjectURL(url);\n                };\n                img.src = url;\n                newWindow.document.body.appendChild(img);\n            }\n        }\n    }\n    /**\n     * Encodes the canvas data to base 64 or automatically download the result if filename is defined\n     * @param canvas canvas to get the data from.\n     * @param successCallback defines the callback triggered once the data are available\n     * @param mimeType defines the mime type of the result\n     * @param fileName defines he filename to download. If present, the result will automatically be downloaded\n     * @param quality defines the quality of the result\n     */\n    static EncodeScreenshotCanvasData(canvas, successCallback, mimeType = \"image/png\", fileName, quality) {\n        if (successCallback) {\n            const base64Image = canvas.toDataURL(mimeType, quality);\n            successCallback(base64Image);\n        }\n        else {\n            this.ToBlob(canvas, function (blob) {\n                if (blob) {\n                    Tools.DownloadBlob(blob, fileName);\n                }\n            }, mimeType, quality);\n        }\n    }\n    /**\n     * Downloads a blob in the browser\n     * @param blob defines the blob to download\n     * @param fileName defines the name of the downloaded file\n     */\n    static Download(blob, fileName) {\n        if (typeof URL === \"undefined\") {\n            return;\n        }\n        const url = window.URL.createObjectURL(blob);\n        const a = document.createElement(\"a\");\n        document.body.appendChild(a);\n        a.style.display = \"none\";\n        a.href = url;\n        a.download = fileName;\n        a.addEventListener(\"click\", () => {\n            if (a.parentElement) {\n                a.parentElement.removeChild(a);\n            }\n        });\n        a.click();\n        window.URL.revokeObjectURL(url);\n    }\n    /**\n     * Will return the right value of the noPreventDefault variable\n     * Needed to keep backwards compatibility to the old API.\n     *\n     * @param args arguments passed to the attachControl function\n     * @returns the correct value for noPreventDefault\n     */\n    static BackCompatCameraNoPreventDefault(args) {\n        // is it used correctly?\n        if (typeof args[0] === \"boolean\") {\n            return args[0];\n        }\n        else if (typeof args[1] === \"boolean\") {\n            return args[1];\n        }\n        return false;\n    }\n    /**\n     * Captures a screenshot of the current rendering\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/renderToPNG\n     * @param engine defines the rendering engine\n     * @param camera defines the source camera\n     * @param size This parameter can be set to a single number or to an object with the\n     * following (optional) properties: precision, width, height. If a single number is passed,\n     * it will be used for both width and height. If an object is passed, the screenshot size\n     * will be derived from the parameters. The precision property is a multiplier allowing\n     * rendering at a higher or lower resolution\n     * @param successCallback defines the callback receives a single parameter which contains the\n     * screenshot as a string of base64-encoded characters. This string can be assigned to the\n     * src parameter of an <img> to display it\n     * @param mimeType defines the MIME type of the screenshot image (default: image/png).\n     * Check your browser for supported MIME types\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    static CreateScreenshot(engine, camera, size, successCallback, mimeType = \"image/png\") {\n        throw _WarnImport(\"ScreenshotTools\");\n    }\n    /**\n     * Captures a screenshot of the current rendering\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/renderToPNG\n     * @param engine defines the rendering engine\n     * @param camera defines the source camera\n     * @param size This parameter can be set to a single number or to an object with the\n     * following (optional) properties: precision, width, height. If a single number is passed,\n     * it will be used for both width and height. If an object is passed, the screenshot size\n     * will be derived from the parameters. The precision property is a multiplier allowing\n     * rendering at a higher or lower resolution\n     * @param mimeType defines the MIME type of the screenshot image (default: image/png).\n     * Check your browser for supported MIME types\n     * @returns screenshot as a string of base64-encoded characters. This string can be assigned\n     * to the src parameter of an <img> to display it\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    static CreateScreenshotAsync(engine, camera, size, mimeType = \"image/png\") {\n        throw _WarnImport(\"ScreenshotTools\");\n    }\n    /**\n     * Generates an image screenshot from the specified camera.\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/renderToPNG\n     * @param engine The engine to use for rendering\n     * @param camera The camera to use for rendering\n     * @param size This parameter can be set to a single number or to an object with the\n     * following (optional) properties: precision, width, height. If a single number is passed,\n     * it will be used for both width and height. If an object is passed, the screenshot size\n     * will be derived from the parameters. The precision property is a multiplier allowing\n     * rendering at a higher or lower resolution\n     * @param successCallback The callback receives a single parameter which contains the\n     * screenshot as a string of base64-encoded characters. This string can be assigned to the\n     * src parameter of an <img> to display it\n     * @param mimeType The MIME type of the screenshot image (default: image/png).\n     * Check your browser for supported MIME types\n     * @param samples Texture samples (default: 1)\n     * @param antialiasing Whether antialiasing should be turned on or not (default: false)\n     * @param fileName A name for for the downloaded file.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    static CreateScreenshotUsingRenderTarget(engine, camera, size, successCallback, mimeType = \"image/png\", samples = 1, antialiasing = false, fileName) {\n        throw _WarnImport(\"ScreenshotTools\");\n    }\n    /**\n     * Generates an image screenshot from the specified camera.\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/renderToPNG\n     * @param engine The engine to use for rendering\n     * @param camera The camera to use for rendering\n     * @param size This parameter can be set to a single number or to an object with the\n     * following (optional) properties: precision, width, height. If a single number is passed,\n     * it will be used for both width and height. If an object is passed, the screenshot size\n     * will be derived from the parameters. The precision property is a multiplier allowing\n     * rendering at a higher or lower resolution\n     * @param mimeType The MIME type of the screenshot image (default: image/png).\n     * Check your browser for supported MIME types\n     * @param samples Texture samples (default: 1)\n     * @param antialiasing Whether antialiasing should be turned on or not (default: false)\n     * @param fileName A name for for the downloaded file.\n     * @returns screenshot as a string of base64-encoded characters. This string can be assigned\n     * to the src parameter of an <img> to display it\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    static CreateScreenshotUsingRenderTargetAsync(engine, camera, size, mimeType = \"image/png\", samples = 1, antialiasing = false, fileName) {\n        throw _WarnImport(\"ScreenshotTools\");\n    }\n    /**\n     * Implementation from http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/2117523#answer-2117523\n     * Be aware Math.random() could cause collisions, but:\n     * \"All but 6 of the 128 bits of the ID are randomly generated, which means that for any two ids, there's a 1 in 2^^122 (or 5.3x10^^36) chance they'll collide\"\n     * @returns a pseudo random id\n     */\n    static RandomId() {\n        return RandomGUID();\n    }\n    /**\n     * Test if the given uri is a base64 string\n     * @deprecated Please use FileTools.IsBase64DataUrl instead.\n     * @param uri The uri to test\n     * @returns True if the uri is a base64 string or false otherwise\n     */\n    static IsBase64(uri) {\n        return IsBase64DataUrl(uri);\n    }\n    /**\n     * Decode the given base64 uri.\n     * @deprecated Please use FileTools.DecodeBase64UrlToBinary instead.\n     * @param uri The uri to decode\n     * @returns The decoded base64 data.\n     */\n    static DecodeBase64(uri) {\n        return DecodeBase64UrlToBinary(uri);\n    }\n    /**\n     * Gets a value indicating the number of loading errors\n     * @ignorenaming\n     */\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    static get errorsCount() {\n        return Logger.errorsCount;\n    }\n    /**\n     * Log a message to the console\n     * @param message defines the message to log\n     */\n    static Log(message) {\n        Logger.Log(message);\n    }\n    /**\n     * Write a warning message to the console\n     * @param message defines the message to log\n     */\n    static Warn(message) {\n        Logger.Warn(message);\n    }\n    /**\n     * Write an error message to the console\n     * @param message defines the message to log\n     */\n    static Error(message) {\n        Logger.Error(message);\n    }\n    /**\n     * Gets current log cache (list of logs)\n     */\n    static get LogCache() {\n        return Logger.LogCache;\n    }\n    /**\n     * Clears the log cache\n     */\n    static ClearLogCache() {\n        Logger.ClearLogCache();\n    }\n    /**\n     * Sets the current log level (MessageLogLevel / WarningLogLevel / ErrorLogLevel)\n     */\n    static set LogLevels(level) {\n        Logger.LogLevels = level;\n    }\n    /**\n     * Sets the current performance log level\n     */\n    static set PerformanceLogLevel(level) {\n        if ((level & Tools.PerformanceUserMarkLogLevel) === Tools.PerformanceUserMarkLogLevel) {\n            Tools.StartPerformanceCounter = Tools._StartUserMark;\n            Tools.EndPerformanceCounter = Tools._EndUserMark;\n            return;\n        }\n        if ((level & Tools.PerformanceConsoleLogLevel) === Tools.PerformanceConsoleLogLevel) {\n            Tools.StartPerformanceCounter = Tools._StartPerformanceConsole;\n            Tools.EndPerformanceCounter = Tools._EndPerformanceConsole;\n            return;\n        }\n        Tools.StartPerformanceCounter = Tools._StartPerformanceCounterDisabled;\n        Tools.EndPerformanceCounter = Tools._EndPerformanceCounterDisabled;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    static _StartPerformanceCounterDisabled(counterName, condition) { }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    static _EndPerformanceCounterDisabled(counterName, condition) { }\n    static _StartUserMark(counterName, condition = true) {\n        if (!Tools._Performance) {\n            if (!IsWindowObjectExist()) {\n                return;\n            }\n            Tools._Performance = window.performance;\n        }\n        if (!condition || !Tools._Performance.mark) {\n            return;\n        }\n        Tools._Performance.mark(counterName + \"-Begin\");\n    }\n    static _EndUserMark(counterName, condition = true) {\n        if (!condition || !Tools._Performance.mark) {\n            return;\n        }\n        Tools._Performance.mark(counterName + \"-End\");\n        Tools._Performance.measure(counterName, counterName + \"-Begin\", counterName + \"-End\");\n    }\n    static _StartPerformanceConsole(counterName, condition = true) {\n        if (!condition) {\n            return;\n        }\n        Tools._StartUserMark(counterName, condition);\n        if (console.time) {\n            console.time(counterName);\n        }\n    }\n    static _EndPerformanceConsole(counterName, condition = true) {\n        if (!condition) {\n            return;\n        }\n        Tools._EndUserMark(counterName, condition);\n        console.timeEnd(counterName);\n    }\n    /**\n     * Gets either window.performance.now() if supported or Date.now() else\n     */\n    static get Now() {\n        return PrecisionDate.Now;\n    }\n    /**\n     * This method will return the name of the class used to create the instance of the given object.\n     * It will works only on Javascript basic data types (number, string, ...) and instance of class declared with the @className decorator.\n     * @param object the object to get the class name from\n     * @param isType defines if the object is actually a type\n     * @returns the name of the class, will be \"object\" for a custom data type not using the @className decorator\n     */\n    static GetClassName(object, isType = false) {\n        let name = null;\n        if (!isType && object.getClassName) {\n            name = object.getClassName();\n        }\n        else {\n            if (object instanceof Object) {\n                const classObj = isType ? object : Object.getPrototypeOf(object);\n                name = classObj.constructor[\"__bjsclassName__\"];\n            }\n            if (!name) {\n                name = typeof object;\n            }\n        }\n        return name;\n    }\n    /**\n     * Gets the first element of an array satisfying a given predicate\n     * @param array defines the array to browse\n     * @param predicate defines the predicate to use\n     * @returns null if not found or the element\n     */\n    static First(array, predicate) {\n        for (const el of array) {\n            if (predicate(el)) {\n                return el;\n            }\n        }\n        return null;\n    }\n    /**\n     * This method will return the name of the full name of the class, including its owning module (if any).\n     * It will works only on Javascript basic data types (number, string, ...) and instance of class declared with the @className decorator or implementing a method getClassName():string (in which case the module won't be specified).\n     * @param object the object to get the class name from\n     * @param isType defines if the object is actually a type\n     * @returns a string that can have two forms: \"moduleName.className\" if module was specified when the class' Name was registered or \"className\" if there was not module specified.\n     * @ignorenaming\n     */\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    static getFullClassName(object, isType = false) {\n        let className = null;\n        let moduleName = null;\n        if (!isType && object.getClassName) {\n            className = object.getClassName();\n        }\n        else {\n            if (object instanceof Object) {\n                const classObj = isType ? object : Object.getPrototypeOf(object);\n                className = classObj.constructor[\"__bjsclassName__\"];\n                moduleName = classObj.constructor[\"__bjsmoduleName__\"];\n            }\n            if (!className) {\n                className = typeof object;\n            }\n        }\n        if (!className) {\n            return null;\n        }\n        return (moduleName != null ? moduleName + \".\" : \"\") + className;\n    }\n    /**\n     * Returns a promise that resolves after the given amount of time.\n     * @param delay Number of milliseconds to delay\n     * @returns Promise that resolves after the given amount of time\n     */\n    static DelayAsync(delay) {\n        return new Promise((resolve) => {\n            setTimeout(() => {\n                resolve();\n            }, delay);\n        });\n    }\n    /**\n     * Utility function to detect if the current user agent is Safari\n     * @returns whether or not the current user agent is safari\n     */\n    static IsSafari() {\n        if (!IsNavigatorAvailable()) {\n            return false;\n        }\n        return /^((?!chrome|android).)*safari/i.test(navigator.userAgent);\n    }\n}\n/**\n * Enable/Disable Custom HTTP Request Headers globally.\n * default = false\n * @see CustomRequestHeaders\n */\nTools.UseCustomRequestHeaders = false;\n/**\n * Custom HTTP Request Headers to be sent with XMLHttpRequests\n * i.e. when loading files, where the server/service expects an Authorization header\n */\nTools.CustomRequestHeaders = WebRequest.CustomRequestHeaders;\nTools._TmpFloatArray = new Float32Array(1);\n/**\n * Extracts text content from a DOM element hierarchy\n * Back Compat only, please use GetDOMTextContent instead.\n */\nTools.GetDOMTextContent = GetDOMTextContent;\nTools.GetAbsoluteUrl = typeof document === \"object\"\n    ? (url) => {\n        const a = document.createElement(\"a\");\n        a.href = url;\n        return a.href;\n    }\n    : typeof URL === \"function\" && typeof location === \"object\"\n        ? (url) => new URL(url, location.origin).href\n        : () => {\n            throw new Error(\"Unable to get absolute URL. Override BABYLON.Tools.GetAbsoluteUrl to a custom implementation for the current context.\");\n        };\n// Logs\n/**\n * No log\n */\nTools.NoneLogLevel = Logger.NoneLogLevel;\n/**\n * Only message logs\n */\nTools.MessageLogLevel = Logger.MessageLogLevel;\n/**\n * Only warning logs\n */\nTools.WarningLogLevel = Logger.WarningLogLevel;\n/**\n * Only error logs\n */\nTools.ErrorLogLevel = Logger.ErrorLogLevel;\n/**\n * All logs\n */\nTools.AllLogLevel = Logger.AllLogLevel;\n/**\n * Checks if the window object exists\n * Back Compat only, please use IsWindowObjectExist instead.\n */\nTools.IsWindowObjectExist = IsWindowObjectExist;\n// Performances\n/**\n * No performance log\n */\nTools.PerformanceNoneLogLevel = 0;\n/**\n * Use user marks to log performance\n */\nTools.PerformanceUserMarkLogLevel = 1;\n/**\n * Log performance to the console\n */\nTools.PerformanceConsoleLogLevel = 2;\n/**\n * Starts a performance counter\n */\nTools.StartPerformanceCounter = Tools._StartPerformanceCounterDisabled;\n/**\n * Ends a specific performance counter\n */\nTools.EndPerformanceCounter = Tools._EndPerformanceCounterDisabled;\n/**\n * Use this className as a decorator on a given class definition to add it a name and optionally its module.\n * You can then use the Tools.getClassName(obj) on an instance to retrieve its class name.\n * This method is the only way to get it done in all cases, even if the .js file declaring the class is minified\n * @param name The name of the class, case should be preserved\n * @param module The name of the Module hosting the class, optional, but strongly recommended to specify if possible. Case should be preserved.\n */\nexport function className(name, module) {\n    return (target) => {\n        target[\"__bjsclassName__\"] = name;\n        target[\"__bjsmoduleName__\"] = module != null ? module : null;\n    };\n}\n/**\n * An implementation of a loop for asynchronous functions.\n */\nexport class AsyncLoop {\n    /**\n     * Constructor.\n     * @param iterations the number of iterations.\n     * @param func the function to run each iteration\n     * @param successCallback the callback that will be called upon successful execution\n     * @param offset starting offset.\n     */\n    constructor(\n    /**\n     * Defines the number of iterations for the loop\n     */\n    iterations, func, successCallback, offset = 0) {\n        this.iterations = iterations;\n        this.index = offset - 1;\n        this._done = false;\n        this._fn = func;\n        this._successCallback = successCallback;\n    }\n    /**\n     * Execute the next iteration. Must be called after the last iteration was finished.\n     */\n    executeNext() {\n        if (!this._done) {\n            if (this.index + 1 < this.iterations) {\n                ++this.index;\n                this._fn(this);\n            }\n            else {\n                this.breakLoop();\n            }\n        }\n    }\n    /**\n     * Break the loop and run the success callback.\n     */\n    breakLoop() {\n        this._done = true;\n        this._successCallback();\n    }\n    /**\n     * Create and run an async loop.\n     * @param iterations the number of iterations.\n     * @param fn the function to run each iteration\n     * @param successCallback the callback that will be called upon successful execution\n     * @param offset starting offset.\n     * @returns the created async loop object\n     */\n    static Run(iterations, fn, successCallback, offset = 0) {\n        const loop = new AsyncLoop(iterations, fn, successCallback, offset);\n        loop.executeNext();\n        return loop;\n    }\n    /**\n     * A for-loop that will run a given number of iterations synchronous and the rest async.\n     * @param iterations total number of iterations\n     * @param syncedIterations number of synchronous iterations in each async iteration.\n     * @param fn the function to call each iteration.\n     * @param callback a success call back that will be called when iterating stops.\n     * @param breakFunction a break condition (optional)\n     * @param timeout timeout settings for the setTimeout function. default - 0.\n     * @returns the created async loop object\n     */\n    static SyncAsyncForLoop(iterations, syncedIterations, fn, callback, breakFunction, timeout = 0) {\n        return AsyncLoop.Run(Math.ceil(iterations / syncedIterations), (loop) => {\n            if (breakFunction && breakFunction()) {\n                loop.breakLoop();\n            }\n            else {\n                setTimeout(() => {\n                    for (let i = 0; i < syncedIterations; ++i) {\n                        const iteration = loop.index * syncedIterations + i;\n                        if (iteration >= iterations) {\n                            break;\n                        }\n                        fn(iteration);\n                        if (breakFunction && breakFunction()) {\n                            loop.breakLoop();\n                            break;\n                        }\n                    }\n                    loop.executeNext();\n                }, timeout);\n            }\n        }, callback);\n    }\n}\n// Will only be define if Tools is imported freeing up some space when only engine is required\nEngineStore.FallbackTexture =\n    \"data:image/jpg;base64,/9j/4AAQSkZJRgABAQEAYABgAAD/4QBmRXhpZgAATU0AKgAAAAgABAEaAAUAAAABAAAAPgEbAAUAAAABAAAARgEoAAMAAAABAAIAAAExAAIAAAAQAAAATgAAAAAAAABgAAAAAQAAAGAAAAABcGFpbnQubmV0IDQuMC41AP/bAEMABAIDAwMCBAMDAwQEBAQFCQYFBQUFCwgIBgkNCw0NDQsMDA4QFBEODxMPDAwSGBITFRYXFxcOERkbGRYaFBYXFv/bAEMBBAQEBQUFCgYGChYPDA8WFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFv/AABEIAQABAAMBIgACEQEDEQH/xAAfAAABBQEBAQEBAQAAAAAAAAAAAQIDBAUGBwgJCgv/xAC1EAACAQMDAgQDBQUEBAAAAX0BAgMABBEFEiExQQYTUWEHInEUMoGRoQgjQrHBFVLR8CQzYnKCCQoWFxgZGiUmJygpKjQ1Njc4OTpDREVGR0hJSlNUVVZXWFlaY2RlZmdoaWpzdHV2d3h5eoOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4eLj5OXm5+jp6vHy8/T19vf4+fr/xAAfAQADAQEBAQEBAQEBAAAAAAAAAQIDBAUGBwgJCgv/xAC1EQACAQIEBAMEBwUEBAABAncAAQIDEQQFITEGEkFRB2FxEyIygQgUQpGhscEJIzNS8BVictEKFiQ04SXxFxgZGiYnKCkqNTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqCg4SFhoeIiYqSk5SVlpeYmZqio6Slpqeoqaqys7S1tre4ubrCw8TFxsfIycrS09TV1tfY2dri4+Tl5ufo6ery8/T19vf4+fr/2gAMAwEAAhEDEQA/APH6KKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FCiiigD6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++gooooA+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gUKKKKAPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76CiiigD5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BQooooA+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/voKKKKAPl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FCiiigD6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++gooooA+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gUKKKKAPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76CiiigD5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BQooooA+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/voKKKKAPl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FCiiigD6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++gooooA+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gUKKKKAPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76P//Z\";\n//# sourceMappingURL=tools.js.map","/** @internal */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nconst _RegisteredTypes = {};\n/**\n * @internal\n */\nexport function RegisterClass(className, type) {\n    _RegisteredTypes[className] = type;\n}\n/**\n * @internal\n */\nexport function GetClass(fqdn) {\n    return _RegisteredTypes[fqdn];\n}\n//# sourceMappingURL=typeStore.js.map","/**\n * Helper class used to generate session unique ID\n */\nexport class UniqueIdGenerator {\n    /**\n     * Gets an unique (relatively to the current scene) Id\n     */\n    static get UniqueId() {\n        const result = this._UniqueIdCounter;\n        this._UniqueIdCounter++;\n        return result;\n    }\n}\n// Statics\nUniqueIdGenerator._UniqueIdCounter = 1;\n//# sourceMappingURL=uniqueIdGenerator.js.map","import { Vector3, Vector2 } from \"../Maths/math.vector.js\";\nimport { StringDictionary } from \"./stringDictionary.js\";\n// Mainly based on these 2 articles :\n// Creating an universal virtual touch joystick working for all Touch models thanks to Hand.JS : http://blogs.msdn.com/b/davrous/archive/2013/02/22/creating-an-universal-virtual-touch-joystick-working-for-all-touch-models-thanks-to-hand-js.aspx\n// & on Seb Lee-Delisle original work: http://seb.ly/2011/04/multi-touch-game-controller-in-javascripthtml5-for-ipad/\n/**\n * Defines the potential axis of a Joystick\n */\nexport var JoystickAxis;\n(function (JoystickAxis) {\n    /** X axis */\n    JoystickAxis[JoystickAxis[\"X\"] = 0] = \"X\";\n    /** Y axis */\n    JoystickAxis[JoystickAxis[\"Y\"] = 1] = \"Y\";\n    /** Z axis */\n    JoystickAxis[JoystickAxis[\"Z\"] = 2] = \"Z\";\n})(JoystickAxis || (JoystickAxis = {}));\n/**\n * Class used to define virtual joystick (used in touch mode)\n */\nexport class VirtualJoystick {\n    static _GetDefaultOptions() {\n        return {\n            puckSize: 40,\n            containerSize: 60,\n            color: \"cyan\",\n            puckImage: undefined,\n            containerImage: undefined,\n            position: undefined,\n            alwaysVisible: false,\n            limitToContainer: false,\n        };\n    }\n    /**\n     * Creates a new virtual joystick\n     * @param leftJoystick defines that the joystick is for left hand (false by default)\n     * @param customizations Defines the options we want to customize the VirtualJoystick\n     */\n    constructor(leftJoystick, customizations) {\n        this._released = false;\n        const options = {\n            ...VirtualJoystick._GetDefaultOptions(),\n            ...customizations,\n        };\n        if (leftJoystick) {\n            this._leftJoystick = true;\n        }\n        else {\n            this._leftJoystick = false;\n        }\n        VirtualJoystick._GlobalJoystickIndex++;\n        // By default left & right arrow keys are moving the X\n        // and up & down keys are moving the Y\n        this._axisTargetedByLeftAndRight = JoystickAxis.X;\n        this._axisTargetedByUpAndDown = JoystickAxis.Y;\n        this.reverseLeftRight = false;\n        this.reverseUpDown = false;\n        // collections of pointers\n        this._touches = new StringDictionary();\n        this.deltaPosition = Vector3.Zero();\n        this._joystickSensibility = 25;\n        this._inversedSensibility = 1 / (this._joystickSensibility / 1000);\n        this._onResize = () => {\n            VirtualJoystick._VJCanvasWidth = window.innerWidth;\n            VirtualJoystick._VJCanvasHeight = window.innerHeight;\n            if (VirtualJoystick.Canvas) {\n                VirtualJoystick.Canvas.width = VirtualJoystick._VJCanvasWidth;\n                VirtualJoystick.Canvas.height = VirtualJoystick._VJCanvasHeight;\n            }\n            VirtualJoystick._HalfWidth = VirtualJoystick._VJCanvasWidth / 2;\n        };\n        // injecting a canvas element on top of the canvas 3D game\n        if (!VirtualJoystick.Canvas) {\n            window.addEventListener(\"resize\", this._onResize, false);\n            VirtualJoystick.Canvas = document.createElement(\"canvas\");\n            VirtualJoystick._VJCanvasWidth = window.innerWidth;\n            VirtualJoystick._VJCanvasHeight = window.innerHeight;\n            VirtualJoystick.Canvas.width = window.innerWidth;\n            VirtualJoystick.Canvas.height = window.innerHeight;\n            VirtualJoystick.Canvas.style.width = \"100%\";\n            VirtualJoystick.Canvas.style.height = \"100%\";\n            VirtualJoystick.Canvas.style.position = \"absolute\";\n            VirtualJoystick.Canvas.style.backgroundColor = \"transparent\";\n            VirtualJoystick.Canvas.style.top = \"0px\";\n            VirtualJoystick.Canvas.style.left = \"0px\";\n            VirtualJoystick.Canvas.style.zIndex = \"5\";\n            VirtualJoystick.Canvas.style.touchAction = \"none\"; // fix https://forum.babylonjs.com/t/virtualjoystick-needs-to-set-style-touch-action-none-explicitly/9562\n            // Support for jQuery PEP polyfill\n            VirtualJoystick.Canvas.setAttribute(\"touch-action\", \"none\");\n            const context = VirtualJoystick.Canvas.getContext(\"2d\");\n            if (!context) {\n                throw new Error(\"Unable to create canvas for virtual joystick\");\n            }\n            VirtualJoystick._VJCanvasContext = context;\n            VirtualJoystick._VJCanvasContext.strokeStyle = \"#ffffff\";\n            VirtualJoystick._VJCanvasContext.lineWidth = 2;\n            document.body.appendChild(VirtualJoystick.Canvas);\n        }\n        VirtualJoystick._HalfWidth = VirtualJoystick.Canvas.width / 2;\n        this.pressed = false;\n        this.limitToContainer = options.limitToContainer;\n        // default joystick color\n        this._joystickColor = options.color;\n        // default joystick size\n        this.containerSize = options.containerSize;\n        this.puckSize = options.puckSize;\n        if (options.position) {\n            this.setPosition(options.position.x, options.position.y);\n        }\n        if (options.puckImage) {\n            this.setPuckImage(options.puckImage);\n        }\n        if (options.containerImage) {\n            this.setContainerImage(options.containerImage);\n        }\n        if (options.alwaysVisible) {\n            VirtualJoystick._AlwaysVisibleSticks++;\n        }\n        // must come after position potentially set\n        this.alwaysVisible = options.alwaysVisible;\n        this._joystickPointerId = -1;\n        // current joystick position\n        this._joystickPointerPos = new Vector2(0, 0);\n        this._joystickPreviousPointerPos = new Vector2(0, 0);\n        // origin joystick position\n        this._joystickPointerStartPos = new Vector2(0, 0);\n        this._deltaJoystickVector = new Vector2(0, 0);\n        this._onPointerDownHandlerRef = (evt) => {\n            this._onPointerDown(evt);\n        };\n        this._onPointerMoveHandlerRef = (evt) => {\n            this._onPointerMove(evt);\n        };\n        this._onPointerUpHandlerRef = (evt) => {\n            this._onPointerUp(evt);\n        };\n        VirtualJoystick.Canvas.addEventListener(\"pointerdown\", this._onPointerDownHandlerRef, false);\n        VirtualJoystick.Canvas.addEventListener(\"pointermove\", this._onPointerMoveHandlerRef, false);\n        VirtualJoystick.Canvas.addEventListener(\"pointerup\", this._onPointerUpHandlerRef, false);\n        VirtualJoystick.Canvas.addEventListener(\"pointerout\", this._onPointerUpHandlerRef, false);\n        VirtualJoystick.Canvas.addEventListener(\"contextmenu\", (evt) => {\n            evt.preventDefault(); // Disables system menu\n        }, false);\n        requestAnimationFrame(() => {\n            this._drawVirtualJoystick();\n        });\n    }\n    /**\n     * Defines joystick sensibility (ie. the ratio between a physical move and virtual joystick position change)\n     * @param newJoystickSensibility defines the new sensibility\n     */\n    setJoystickSensibility(newJoystickSensibility) {\n        this._joystickSensibility = newJoystickSensibility;\n        this._inversedSensibility = 1 / (this._joystickSensibility / 1000);\n    }\n    _onPointerDown(e) {\n        let positionOnScreenCondition;\n        e.preventDefault();\n        if (this._leftJoystick === true) {\n            positionOnScreenCondition = e.clientX < VirtualJoystick._HalfWidth;\n        }\n        else {\n            positionOnScreenCondition = e.clientX > VirtualJoystick._HalfWidth;\n        }\n        if (positionOnScreenCondition && this._joystickPointerId < 0) {\n            // First contact will be dedicated to the virtual joystick\n            this._joystickPointerId = e.pointerId;\n            if (this._joystickPosition) {\n                this._joystickPointerStartPos = this._joystickPosition.clone();\n                this._joystickPointerPos = this._joystickPosition.clone();\n                this._joystickPreviousPointerPos = this._joystickPosition.clone();\n                // in case the user only clicks down && doesn't move:\n                // this ensures the delta is properly set\n                this._onPointerMove(e);\n            }\n            else {\n                this._joystickPointerStartPos.x = e.clientX;\n                this._joystickPointerStartPos.y = e.clientY;\n                this._joystickPointerPos = this._joystickPointerStartPos.clone();\n                this._joystickPreviousPointerPos = this._joystickPointerStartPos.clone();\n            }\n            this._deltaJoystickVector.x = 0;\n            this._deltaJoystickVector.y = 0;\n            this.pressed = true;\n            this._touches.add(e.pointerId.toString(), e);\n        }\n        else {\n            // You can only trigger the action buttons with a joystick declared\n            if (VirtualJoystick._GlobalJoystickIndex < 2 && this._action) {\n                this._action();\n                this._touches.add(e.pointerId.toString(), { x: e.clientX, y: e.clientY, prevX: e.clientX, prevY: e.clientY });\n            }\n        }\n    }\n    _onPointerMove(e) {\n        // If the current pointer is the one associated to the joystick (first touch contact)\n        if (this._joystickPointerId == e.pointerId) {\n            // limit to container if need be\n            if (this.limitToContainer) {\n                const vector = new Vector2(e.clientX - this._joystickPointerStartPos.x, e.clientY - this._joystickPointerStartPos.y);\n                const distance = vector.length();\n                if (distance > this.containerSize) {\n                    vector.scaleInPlace(this.containerSize / distance);\n                }\n                this._joystickPointerPos.x = this._joystickPointerStartPos.x + vector.x;\n                this._joystickPointerPos.y = this._joystickPointerStartPos.y + vector.y;\n            }\n            else {\n                this._joystickPointerPos.x = e.clientX;\n                this._joystickPointerPos.y = e.clientY;\n            }\n            // create delta vector\n            this._deltaJoystickVector = this._joystickPointerPos.clone();\n            this._deltaJoystickVector = this._deltaJoystickVector.subtract(this._joystickPointerStartPos);\n            // if a joystick is always visible, there will be clipping issues if\n            // you drag the puck from one over the container of the other\n            if (0 < VirtualJoystick._AlwaysVisibleSticks) {\n                if (this._leftJoystick) {\n                    this._joystickPointerPos.x = Math.min(VirtualJoystick._HalfWidth, this._joystickPointerPos.x);\n                }\n                else {\n                    this._joystickPointerPos.x = Math.max(VirtualJoystick._HalfWidth, this._joystickPointerPos.x);\n                }\n            }\n            const directionLeftRight = this.reverseLeftRight ? -1 : 1;\n            const deltaJoystickX = (directionLeftRight * this._deltaJoystickVector.x) / this._inversedSensibility;\n            switch (this._axisTargetedByLeftAndRight) {\n                case JoystickAxis.X:\n                    this.deltaPosition.x = Math.min(1, Math.max(-1, deltaJoystickX));\n                    break;\n                case JoystickAxis.Y:\n                    this.deltaPosition.y = Math.min(1, Math.max(-1, deltaJoystickX));\n                    break;\n                case JoystickAxis.Z:\n                    this.deltaPosition.z = Math.min(1, Math.max(-1, deltaJoystickX));\n                    break;\n            }\n            const directionUpDown = this.reverseUpDown ? 1 : -1;\n            const deltaJoystickY = (directionUpDown * this._deltaJoystickVector.y) / this._inversedSensibility;\n            switch (this._axisTargetedByUpAndDown) {\n                case JoystickAxis.X:\n                    this.deltaPosition.x = Math.min(1, Math.max(-1, deltaJoystickY));\n                    break;\n                case JoystickAxis.Y:\n                    this.deltaPosition.y = Math.min(1, Math.max(-1, deltaJoystickY));\n                    break;\n                case JoystickAxis.Z:\n                    this.deltaPosition.z = Math.min(1, Math.max(-1, deltaJoystickY));\n                    break;\n            }\n        }\n        else {\n            const data = this._touches.get(e.pointerId.toString());\n            if (data) {\n                data.x = e.clientX;\n                data.y = e.clientY;\n            }\n        }\n    }\n    _onPointerUp(e) {\n        if (this._joystickPointerId == e.pointerId) {\n            this._clearPreviousDraw();\n            this._joystickPointerId = -1;\n            this.pressed = false;\n        }\n        else {\n            const touch = this._touches.get(e.pointerId.toString());\n            if (touch) {\n                VirtualJoystick._VJCanvasContext.clearRect(touch.prevX - 44, touch.prevY - 44, 88, 88);\n            }\n        }\n        this._deltaJoystickVector.x = 0;\n        this._deltaJoystickVector.y = 0;\n        this._touches.remove(e.pointerId.toString());\n    }\n    /**\n     * Change the color of the virtual joystick\n     * @param newColor a string that must be a CSS color value (like \"red\") or the hexa value (like \"#FF0000\")\n     */\n    setJoystickColor(newColor) {\n        this._joystickColor = newColor;\n    }\n    /**\n     * Size of the joystick's container\n     */\n    set containerSize(newSize) {\n        this._joystickContainerSize = newSize;\n        this._clearContainerSize = ~~(this._joystickContainerSize * 2.1);\n        this._clearContainerSizeOffset = ~~(this._clearContainerSize / 2);\n    }\n    get containerSize() {\n        return this._joystickContainerSize;\n    }\n    /**\n     * Size of the joystick's puck\n     */\n    set puckSize(newSize) {\n        this._joystickPuckSize = newSize;\n        this._clearPuckSize = ~~(this._joystickPuckSize * 2.1);\n        this._clearPuckSizeOffset = ~~(this._clearPuckSize / 2);\n    }\n    get puckSize() {\n        return this._joystickPuckSize;\n    }\n    /**\n     * Clears the set position of the joystick\n     */\n    clearPosition() {\n        this.alwaysVisible = false;\n        this._joystickPosition = null;\n    }\n    /**\n     * Defines whether or not the joystick container is always visible\n     */\n    set alwaysVisible(value) {\n        if (this._alwaysVisible === value) {\n            return;\n        }\n        if (value && this._joystickPosition) {\n            VirtualJoystick._AlwaysVisibleSticks++;\n            this._alwaysVisible = true;\n        }\n        else {\n            VirtualJoystick._AlwaysVisibleSticks--;\n            this._alwaysVisible = false;\n        }\n    }\n    get alwaysVisible() {\n        return this._alwaysVisible;\n    }\n    /**\n     * Sets the constant position of the Joystick container\n     * @param x X axis coordinate\n     * @param y Y axis coordinate\n     */\n    setPosition(x, y) {\n        // just in case position is moved while the container is visible\n        if (this._joystickPointerStartPos) {\n            this._clearPreviousDraw();\n        }\n        this._joystickPosition = new Vector2(x, y);\n    }\n    /**\n     * Defines a callback to call when the joystick is touched\n     * @param action defines the callback\n     */\n    setActionOnTouch(action) {\n        this._action = action;\n    }\n    /**\n     * Defines which axis you'd like to control for left & right\n     * @param axis defines the axis to use\n     */\n    setAxisForLeftRight(axis) {\n        switch (axis) {\n            case JoystickAxis.X:\n            case JoystickAxis.Y:\n            case JoystickAxis.Z:\n                this._axisTargetedByLeftAndRight = axis;\n                break;\n            default:\n                this._axisTargetedByLeftAndRight = JoystickAxis.X;\n                break;\n        }\n    }\n    /**\n     * Defines which axis you'd like to control for up & down\n     * @param axis defines the axis to use\n     */\n    setAxisForUpDown(axis) {\n        switch (axis) {\n            case JoystickAxis.X:\n            case JoystickAxis.Y:\n            case JoystickAxis.Z:\n                this._axisTargetedByUpAndDown = axis;\n                break;\n            default:\n                this._axisTargetedByUpAndDown = JoystickAxis.Y;\n                break;\n        }\n    }\n    /**\n     * Clears the canvas from the previous puck / container draw\n     */\n    _clearPreviousDraw() {\n        const jp = this._joystickPosition || this._joystickPointerStartPos;\n        // clear container pixels\n        VirtualJoystick._VJCanvasContext.clearRect(jp.x - this._clearContainerSizeOffset, jp.y - this._clearContainerSizeOffset, this._clearContainerSize, this._clearContainerSize);\n        // clear puck pixels\n        VirtualJoystick._VJCanvasContext.clearRect(this._joystickPreviousPointerPos.x - this._clearPuckSizeOffset, this._joystickPreviousPointerPos.y - this._clearPuckSizeOffset, this._clearPuckSize, this._clearPuckSize);\n    }\n    /**\n     * Loads `urlPath` to be used for the container's image\n     * @param urlPath defines the urlPath of an image to use\n     */\n    setContainerImage(urlPath) {\n        const image = new Image();\n        image.src = urlPath;\n        image.onload = () => (this._containerImage = image);\n    }\n    /**\n     * Loads `urlPath` to be used for the puck's image\n     * @param urlPath defines the urlPath of an image to use\n     */\n    setPuckImage(urlPath) {\n        const image = new Image();\n        image.src = urlPath;\n        image.onload = () => (this._puckImage = image);\n    }\n    /**\n     * Draws the Virtual Joystick's container\n     */\n    _drawContainer() {\n        const jp = this._joystickPosition || this._joystickPointerStartPos;\n        this._clearPreviousDraw();\n        if (this._containerImage) {\n            VirtualJoystick._VJCanvasContext.drawImage(this._containerImage, jp.x - this.containerSize, jp.y - this.containerSize, this.containerSize * 2, this.containerSize * 2);\n        }\n        else {\n            // outer container\n            VirtualJoystick._VJCanvasContext.beginPath();\n            VirtualJoystick._VJCanvasContext.strokeStyle = this._joystickColor;\n            VirtualJoystick._VJCanvasContext.lineWidth = 2;\n            VirtualJoystick._VJCanvasContext.arc(jp.x, jp.y, this.containerSize, 0, Math.PI * 2, true);\n            VirtualJoystick._VJCanvasContext.stroke();\n            VirtualJoystick._VJCanvasContext.closePath();\n            // inner container\n            VirtualJoystick._VJCanvasContext.beginPath();\n            VirtualJoystick._VJCanvasContext.lineWidth = 6;\n            VirtualJoystick._VJCanvasContext.strokeStyle = this._joystickColor;\n            VirtualJoystick._VJCanvasContext.arc(jp.x, jp.y, this.puckSize, 0, Math.PI * 2, true);\n            VirtualJoystick._VJCanvasContext.stroke();\n            VirtualJoystick._VJCanvasContext.closePath();\n        }\n    }\n    /**\n     * Draws the Virtual Joystick's puck\n     */\n    _drawPuck() {\n        if (this._puckImage) {\n            VirtualJoystick._VJCanvasContext.drawImage(this._puckImage, this._joystickPointerPos.x - this.puckSize, this._joystickPointerPos.y - this.puckSize, this.puckSize * 2, this.puckSize * 2);\n        }\n        else {\n            VirtualJoystick._VJCanvasContext.beginPath();\n            VirtualJoystick._VJCanvasContext.strokeStyle = this._joystickColor;\n            VirtualJoystick._VJCanvasContext.lineWidth = 2;\n            VirtualJoystick._VJCanvasContext.arc(this._joystickPointerPos.x, this._joystickPointerPos.y, this.puckSize, 0, Math.PI * 2, true);\n            VirtualJoystick._VJCanvasContext.stroke();\n            VirtualJoystick._VJCanvasContext.closePath();\n        }\n    }\n    _drawVirtualJoystick() {\n        // canvas released? don't continue iterating\n        if (this._released) {\n            return;\n        }\n        if (this.alwaysVisible) {\n            this._drawContainer();\n        }\n        if (this.pressed) {\n            this._touches.forEach((key, touch) => {\n                if (touch.pointerId === this._joystickPointerId) {\n                    if (!this.alwaysVisible) {\n                        this._drawContainer();\n                    }\n                    this._drawPuck();\n                    // store current pointer for next clear\n                    this._joystickPreviousPointerPos = this._joystickPointerPos.clone();\n                }\n                else {\n                    VirtualJoystick._VJCanvasContext.clearRect(touch.prevX - 44, touch.prevY - 44, 88, 88);\n                    VirtualJoystick._VJCanvasContext.beginPath();\n                    VirtualJoystick._VJCanvasContext.fillStyle = \"white\";\n                    VirtualJoystick._VJCanvasContext.beginPath();\n                    VirtualJoystick._VJCanvasContext.strokeStyle = \"red\";\n                    VirtualJoystick._VJCanvasContext.lineWidth = 6;\n                    VirtualJoystick._VJCanvasContext.arc(touch.x, touch.y, 40, 0, Math.PI * 2, true);\n                    VirtualJoystick._VJCanvasContext.stroke();\n                    VirtualJoystick._VJCanvasContext.closePath();\n                    touch.prevX = touch.x;\n                    touch.prevY = touch.y;\n                }\n            });\n        }\n        requestAnimationFrame(() => {\n            this._drawVirtualJoystick();\n        });\n    }\n    /**\n     * Release internal HTML canvas\n     */\n    releaseCanvas() {\n        if (VirtualJoystick.Canvas) {\n            VirtualJoystick.Canvas.removeEventListener(\"pointerdown\", this._onPointerDownHandlerRef);\n            VirtualJoystick.Canvas.removeEventListener(\"pointermove\", this._onPointerMoveHandlerRef);\n            VirtualJoystick.Canvas.removeEventListener(\"pointerup\", this._onPointerUpHandlerRef);\n            VirtualJoystick.Canvas.removeEventListener(\"pointerout\", this._onPointerUpHandlerRef);\n            window.removeEventListener(\"resize\", this._onResize);\n            document.body.removeChild(VirtualJoystick.Canvas);\n            VirtualJoystick.Canvas = null;\n        }\n        this._released = true;\n    }\n}\n// Used to draw the virtual joystick inside a 2D canvas on top of the WebGL rendering canvas\nVirtualJoystick._GlobalJoystickIndex = 0;\nVirtualJoystick._AlwaysVisibleSticks = 0;\n//# sourceMappingURL=virtualJoystick.js.map","/** @internal */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nfunction createXMLHttpRequest() {\n    // If running in Babylon Native, then defer to the native XMLHttpRequest, which has the same public contract\n    if (typeof _native !== \"undefined\" && _native.XMLHttpRequest) {\n        return new _native.XMLHttpRequest();\n    }\n    else {\n        return new XMLHttpRequest();\n    }\n}\n/**\n * Extended version of XMLHttpRequest with support for customizations (headers, ...)\n */\nexport class WebRequest {\n    constructor() {\n        this._xhr = createXMLHttpRequest();\n        this._requestURL = \"\";\n    }\n    _injectCustomRequestHeaders() {\n        if (this._shouldSkipRequestModifications(this._requestURL)) {\n            return;\n        }\n        for (const key in WebRequest.CustomRequestHeaders) {\n            const val = WebRequest.CustomRequestHeaders[key];\n            if (val) {\n                this._xhr.setRequestHeader(key, val);\n            }\n        }\n    }\n    _shouldSkipRequestModifications(url) {\n        return WebRequest.SkipRequestModificationForBabylonCDN && (url.includes(\"preview.babylonjs.com\") || url.includes(\"cdn.babylonjs.com\"));\n    }\n    /**\n     * Gets or sets a function to be called when loading progress changes\n     */\n    get onprogress() {\n        return this._xhr.onprogress;\n    }\n    set onprogress(value) {\n        this._xhr.onprogress = value;\n    }\n    /**\n     * Returns client's state\n     */\n    get readyState() {\n        return this._xhr.readyState;\n    }\n    /**\n     * Returns client's status\n     */\n    get status() {\n        return this._xhr.status;\n    }\n    /**\n     * Returns client's status as a text\n     */\n    get statusText() {\n        return this._xhr.statusText;\n    }\n    /**\n     * Returns client's response\n     */\n    get response() {\n        return this._xhr.response;\n    }\n    /**\n     * Returns client's response url\n     */\n    get responseURL() {\n        return this._xhr.responseURL;\n    }\n    /**\n     * Returns client's response as text\n     */\n    get responseText() {\n        return this._xhr.responseText;\n    }\n    /**\n     * Gets or sets the expected response type\n     */\n    get responseType() {\n        return this._xhr.responseType;\n    }\n    set responseType(value) {\n        this._xhr.responseType = value;\n    }\n    /**\n     * Gets or sets the timeout value in milliseconds\n     */\n    get timeout() {\n        return this._xhr.timeout;\n    }\n    set timeout(value) {\n        this._xhr.timeout = value;\n    }\n    addEventListener(type, listener, options) {\n        this._xhr.addEventListener(type, listener, options);\n    }\n    removeEventListener(type, listener, options) {\n        this._xhr.removeEventListener(type, listener, options);\n    }\n    /**\n     * Cancels any network activity\n     */\n    abort() {\n        this._xhr.abort();\n    }\n    /**\n     * Initiates the request. The optional argument provides the request body. The argument is ignored if request method is GET or HEAD\n     * @param body defines an optional request body\n     */\n    send(body) {\n        if (WebRequest.CustomRequestHeaders) {\n            this._injectCustomRequestHeaders();\n        }\n        this._xhr.send(body);\n    }\n    /**\n     * Sets the request method, request URL\n     * @param method defines the method to use (GET, POST, etc..)\n     * @param url defines the url to connect with\n     */\n    open(method, url) {\n        for (const update of WebRequest.CustomRequestModifiers) {\n            if (this._shouldSkipRequestModifications(url)) {\n                return;\n            }\n            update(this._xhr, url);\n        }\n        // Clean url\n        url = url.replace(\"file:http:\", \"http:\");\n        url = url.replace(\"file:https:\", \"https:\");\n        this._requestURL = url;\n        return this._xhr.open(method, url, true);\n    }\n    /**\n     * Sets the value of a request header.\n     * @param name The name of the header whose value is to be set\n     * @param value The value to set as the body of the header\n     */\n    setRequestHeader(name, value) {\n        this._xhr.setRequestHeader(name, value);\n    }\n    /**\n     * Get the string containing the text of a particular header's value.\n     * @param name The name of the header\n     * @returns The string containing the text of the given header name\n     */\n    getResponseHeader(name) {\n        return this._xhr.getResponseHeader(name);\n    }\n}\n/**\n * Custom HTTP Request Headers to be sent with XMLHttpRequests\n * i.e. when loading files, where the server/service expects an Authorization header\n */\nWebRequest.CustomRequestHeaders = {};\n/**\n * Add callback functions in this array to update all the requests before they get sent to the network\n */\nWebRequest.CustomRequestModifiers = new Array();\nWebRequest.SkipRequestModificationForBabylonCDN = true;\n//# sourceMappingURL=webRequest.js.map","/**\n * Helper class to push actions to a pool of workers.\n */\nexport class WorkerPool {\n    /**\n     * Constructor\n     * @param workers Array of workers to use for actions\n     */\n    constructor(workers) {\n        this._pendingActions = new Array();\n        this._workerInfos = workers.map((worker) => ({\n            workerPromise: Promise.resolve(worker),\n            idle: true,\n        }));\n    }\n    /**\n     * Terminates all workers and clears any pending actions.\n     */\n    dispose() {\n        for (const workerInfo of this._workerInfos) {\n            workerInfo.workerPromise.then((worker) => {\n                worker.terminate();\n            });\n        }\n        this._workerInfos.length = 0;\n        this._pendingActions.length = 0;\n    }\n    /**\n     * Pushes an action to the worker pool. If all the workers are active, the action will be\n     * pended until a worker has completed its action.\n     * @param action The action to perform. Call onComplete when the action is complete.\n     */\n    push(action) {\n        if (!this._executeOnIdleWorker(action)) {\n            this._pendingActions.push(action);\n        }\n    }\n    _executeOnIdleWorker(action) {\n        for (const workerInfo of this._workerInfos) {\n            if (workerInfo.idle) {\n                this._execute(workerInfo, action);\n                return true;\n            }\n        }\n        return false;\n    }\n    _execute(workerInfo, action) {\n        workerInfo.idle = false;\n        workerInfo.workerPromise.then((worker) => {\n            action(worker, () => {\n                const nextAction = this._pendingActions.shift();\n                if (nextAction) {\n                    this._execute(workerInfo, nextAction);\n                }\n                else {\n                    workerInfo.idle = true;\n                }\n            });\n        });\n    }\n}\n/**\n * Similar to the WorkerPool class except it creates and destroys workers automatically with a maximum of `maxWorkers` workers.\n * Workers are terminated when it is idle for at least `idleTimeElapsedBeforeRelease` milliseconds.\n */\nexport class AutoReleaseWorkerPool extends WorkerPool {\n    constructor(maxWorkers, createWorkerAsync, options = AutoReleaseWorkerPool.DefaultOptions) {\n        super([]);\n        this._maxWorkers = maxWorkers;\n        this._createWorkerAsync = createWorkerAsync;\n        this._options = options;\n    }\n    push(action) {\n        if (!this._executeOnIdleWorker(action)) {\n            if (this._workerInfos.length < this._maxWorkers) {\n                const workerInfo = {\n                    workerPromise: this._createWorkerAsync(),\n                    idle: false,\n                };\n                this._workerInfos.push(workerInfo);\n                this._execute(workerInfo, action);\n            }\n            else {\n                this._pendingActions.push(action);\n            }\n        }\n    }\n    _execute(workerInfo, action) {\n        // Reset the idle timeout.\n        if (workerInfo.timeoutId) {\n            clearTimeout(workerInfo.timeoutId);\n            delete workerInfo.timeoutId;\n        }\n        super._execute(workerInfo, (worker, onComplete) => {\n            action(worker, () => {\n                onComplete();\n                if (workerInfo.idle) {\n                    // Schedule the worker to be terminated after the elapsed time.\n                    workerInfo.timeoutId = setTimeout(() => {\n                        workerInfo.workerPromise.then((worker) => {\n                            worker.terminate();\n                        });\n                        const indexOf = this._workerInfos.indexOf(workerInfo);\n                        if (indexOf !== -1) {\n                            this._workerInfos.splice(indexOf, 1);\n                        }\n                    }, this._options.idleTimeElapsedBeforeRelease);\n                }\n            });\n        });\n    }\n}\n/**\n * Default options for the constructor.\n * Override to change the defaults.\n */\nAutoReleaseWorkerPool.DefaultOptions = {\n    idleTimeElapsedBeforeRelease: 1000,\n};\n//# sourceMappingURL=workerPool.js.map","import { __decorate } from \"../tslib.es6.js\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\nimport { VertexBuffer } from \"../Buffers/buffer.js\";\nimport { serialize, SerializationHelper } from \"../Misc/decorators.js\";\nimport { GetClass } from \"../Misc/typeStore.js\";\n/**\n * Defines a target to use with MorphTargetManager\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/morphTargets\n */\nexport class MorphTarget {\n    /**\n     * Gets or sets the influence of this target (ie. its weight in the overall morphing)\n     */\n    get influence() {\n        return this._influence;\n    }\n    set influence(influence) {\n        if (this._influence === influence) {\n            return;\n        }\n        const previous = this._influence;\n        this._influence = influence;\n        if (this.onInfluenceChanged.hasObservers()) {\n            this.onInfluenceChanged.notifyObservers(previous === 0 || influence === 0);\n        }\n    }\n    /**\n     * Gets or sets the animation properties override\n     */\n    get animationPropertiesOverride() {\n        if (!this._animationPropertiesOverride && this._scene) {\n            return this._scene.animationPropertiesOverride;\n        }\n        return this._animationPropertiesOverride;\n    }\n    set animationPropertiesOverride(value) {\n        this._animationPropertiesOverride = value;\n    }\n    /**\n     * Creates a new MorphTarget\n     * @param name defines the name of the target\n     * @param influence defines the influence to use\n     * @param scene defines the scene the morphtarget belongs to\n     */\n    constructor(\n    /** defines the name of the target */\n    name, influence = 0, scene = null) {\n        this.name = name;\n        /**\n         * Gets or sets the list of animations\n         */\n        this.animations = new Array();\n        this._positions = null;\n        this._normals = null;\n        this._tangents = null;\n        this._uvs = null;\n        this._uniqueId = 0;\n        /**\n         * Observable raised when the influence changes\n         */\n        this.onInfluenceChanged = new Observable();\n        /** @internal */\n        this._onDataLayoutChanged = new Observable();\n        this._animationPropertiesOverride = null;\n        this._scene = scene || EngineStore.LastCreatedScene;\n        this.influence = influence;\n        if (this._scene) {\n            this._uniqueId = this._scene.getUniqueId();\n        }\n    }\n    /**\n     * Gets the unique ID of this manager\n     */\n    get uniqueId() {\n        return this._uniqueId;\n    }\n    /**\n     * Gets a boolean defining if the target contains position data\n     */\n    get hasPositions() {\n        return !!this._positions;\n    }\n    /**\n     * Gets a boolean defining if the target contains normal data\n     */\n    get hasNormals() {\n        return !!this._normals;\n    }\n    /**\n     * Gets a boolean defining if the target contains tangent data\n     */\n    get hasTangents() {\n        return !!this._tangents;\n    }\n    /**\n     * Gets a boolean defining if the target contains texture coordinates data\n     */\n    get hasUVs() {\n        return !!this._uvs;\n    }\n    /**\n     * Affects position data to this target\n     * @param data defines the position data to use\n     */\n    setPositions(data) {\n        const hadPositions = this.hasPositions;\n        this._positions = data;\n        if (hadPositions !== this.hasPositions) {\n            this._onDataLayoutChanged.notifyObservers(undefined);\n        }\n    }\n    /**\n     * Gets the position data stored in this target\n     * @returns a FloatArray containing the position data (or null if not present)\n     */\n    getPositions() {\n        return this._positions;\n    }\n    /**\n     * Affects normal data to this target\n     * @param data defines the normal data to use\n     */\n    setNormals(data) {\n        const hadNormals = this.hasNormals;\n        this._normals = data;\n        if (hadNormals !== this.hasNormals) {\n            this._onDataLayoutChanged.notifyObservers(undefined);\n        }\n    }\n    /**\n     * Gets the normal data stored in this target\n     * @returns a FloatArray containing the normal data (or null if not present)\n     */\n    getNormals() {\n        return this._normals;\n    }\n    /**\n     * Affects tangent data to this target\n     * @param data defines the tangent data to use\n     */\n    setTangents(data) {\n        const hadTangents = this.hasTangents;\n        this._tangents = data;\n        if (hadTangents !== this.hasTangents) {\n            this._onDataLayoutChanged.notifyObservers(undefined);\n        }\n    }\n    /**\n     * Gets the tangent data stored in this target\n     * @returns a FloatArray containing the tangent data (or null if not present)\n     */\n    getTangents() {\n        return this._tangents;\n    }\n    /**\n     * Affects texture coordinates data to this target\n     * @param data defines the texture coordinates data to use\n     */\n    setUVs(data) {\n        const hadUVs = this.hasUVs;\n        this._uvs = data;\n        if (hadUVs !== this.hasUVs) {\n            this._onDataLayoutChanged.notifyObservers(undefined);\n        }\n    }\n    /**\n     * Gets the texture coordinates data stored in this target\n     * @returns a FloatArray containing the texture coordinates data (or null if not present)\n     */\n    getUVs() {\n        return this._uvs;\n    }\n    /**\n     * Clone the current target\n     * @returns a new MorphTarget\n     */\n    clone() {\n        const newOne = SerializationHelper.Clone(() => new MorphTarget(this.name, this.influence, this._scene), this);\n        newOne._positions = this._positions;\n        newOne._normals = this._normals;\n        newOne._tangents = this._tangents;\n        newOne._uvs = this._uvs;\n        return newOne;\n    }\n    /**\n     * Serializes the current target into a Serialization object\n     * @returns the serialized object\n     */\n    serialize() {\n        const serializationObject = {};\n        serializationObject.name = this.name;\n        serializationObject.influence = this.influence;\n        serializationObject.positions = Array.prototype.slice.call(this.getPositions());\n        if (this.id != null) {\n            serializationObject.id = this.id;\n        }\n        if (this.hasNormals) {\n            serializationObject.normals = Array.prototype.slice.call(this.getNormals());\n        }\n        if (this.hasTangents) {\n            serializationObject.tangents = Array.prototype.slice.call(this.getTangents());\n        }\n        if (this.hasUVs) {\n            serializationObject.uvs = Array.prototype.slice.call(this.getUVs());\n        }\n        // Animations\n        SerializationHelper.AppendSerializedAnimations(this, serializationObject);\n        return serializationObject;\n    }\n    /**\n     * Returns the string \"MorphTarget\"\n     * @returns \"MorphTarget\"\n     */\n    getClassName() {\n        return \"MorphTarget\";\n    }\n    // Statics\n    /**\n     * Creates a new target from serialized data\n     * @param serializationObject defines the serialized data to use\n     * @param scene defines the hosting scene\n     * @returns a new MorphTarget\n     */\n    static Parse(serializationObject, scene) {\n        const result = new MorphTarget(serializationObject.name, serializationObject.influence);\n        result.setPositions(serializationObject.positions);\n        if (serializationObject.id != null) {\n            result.id = serializationObject.id;\n        }\n        if (serializationObject.normals) {\n            result.setNormals(serializationObject.normals);\n        }\n        if (serializationObject.tangents) {\n            result.setTangents(serializationObject.tangents);\n        }\n        if (serializationObject.uvs) {\n            result.setUVs(serializationObject.uvs);\n        }\n        // Animations\n        if (serializationObject.animations) {\n            for (let animationIndex = 0; animationIndex < serializationObject.animations.length; animationIndex++) {\n                const parsedAnimation = serializationObject.animations[animationIndex];\n                const internalClass = GetClass(\"BABYLON.Animation\");\n                if (internalClass) {\n                    result.animations.push(internalClass.Parse(parsedAnimation));\n                }\n            }\n            if (serializationObject.autoAnimate && scene) {\n                scene.beginAnimation(result, serializationObject.autoAnimateFrom, serializationObject.autoAnimateTo, serializationObject.autoAnimateLoop, serializationObject.autoAnimateSpeed || 1.0);\n            }\n        }\n        return result;\n    }\n    /**\n     * Creates a MorphTarget from mesh data\n     * @param mesh defines the source mesh\n     * @param name defines the name to use for the new target\n     * @param influence defines the influence to attach to the target\n     * @returns a new MorphTarget\n     */\n    static FromMesh(mesh, name, influence) {\n        if (!name) {\n            name = mesh.name;\n        }\n        const result = new MorphTarget(name, influence, mesh.getScene());\n        result.setPositions(mesh.getVerticesData(VertexBuffer.PositionKind));\n        if (mesh.isVerticesDataPresent(VertexBuffer.NormalKind)) {\n            result.setNormals(mesh.getVerticesData(VertexBuffer.NormalKind));\n        }\n        if (mesh.isVerticesDataPresent(VertexBuffer.TangentKind)) {\n            result.setTangents(mesh.getVerticesData(VertexBuffer.TangentKind));\n        }\n        if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {\n            result.setUVs(mesh.getVerticesData(VertexBuffer.UVKind));\n        }\n        return result;\n    }\n}\n__decorate([\n    serialize()\n], MorphTarget.prototype, \"id\", void 0);\n//# sourceMappingURL=morphTarget.js.map","import { SmartArray } from \"../Misc/smartArray.js\";\nimport { Logger } from \"../Misc/logger.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\nimport { MorphTarget } from \"./morphTarget.js\";\n\nimport { RawTexture2DArray } from \"../Materials/Textures/rawTexture2DArray.js\";\n/**\n * This class is used to deform meshes using morphing between different targets\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/morphTargets\n */\nexport class MorphTargetManager {\n    /**\n     * Sets a boolean indicating that adding new target or updating an existing target will not update the underlying data buffers\n     */\n    set areUpdatesFrozen(block) {\n        if (block) {\n            this._blockCounter++;\n        }\n        else {\n            this._blockCounter--;\n            if (this._blockCounter <= 0) {\n                this._blockCounter = 0;\n                this._syncActiveTargets(true);\n            }\n        }\n    }\n    get areUpdatesFrozen() {\n        return this._blockCounter > 0;\n    }\n    /**\n     * Creates a new MorphTargetManager\n     * @param scene defines the current scene\n     */\n    constructor(scene = null) {\n        this._targets = new Array();\n        this._targetInfluenceChangedObservers = new Array();\n        this._targetDataLayoutChangedObservers = new Array();\n        this._activeTargets = new SmartArray(16);\n        this._supportsNormals = false;\n        this._supportsTangents = false;\n        this._supportsUVs = false;\n        this._vertexCount = 0;\n        this._textureVertexStride = 0;\n        this._textureWidth = 0;\n        this._textureHeight = 1;\n        this._uniqueId = 0;\n        this._tempInfluences = new Array();\n        this._canUseTextureForTargets = false;\n        this._blockCounter = 0;\n        /** @internal */\n        this._parentContainer = null;\n        /**\n         * Gets or sets a boolean indicating if influencers must be optimized (eg. recompiling the shader if less influencers are used)\n         */\n        this.optimizeInfluencers = true;\n        /**\n         * Gets or sets a boolean indicating if normals must be morphed\n         */\n        this.enableNormalMorphing = true;\n        /**\n         * Gets or sets a boolean indicating if tangents must be morphed\n         */\n        this.enableTangentMorphing = true;\n        /**\n         * Gets or sets a boolean indicating if UV must be morphed\n         */\n        this.enableUVMorphing = true;\n        this._useTextureToStoreTargets = true;\n        if (!scene) {\n            scene = EngineStore.LastCreatedScene;\n        }\n        this._scene = scene;\n        if (this._scene) {\n            this._scene.morphTargetManagers.push(this);\n            this._uniqueId = this._scene.getUniqueId();\n            const engineCaps = this._scene.getEngine().getCaps();\n            this._canUseTextureForTargets =\n                engineCaps.canUseGLVertexID && engineCaps.textureFloat && engineCaps.maxVertexTextureImageUnits > 0 && engineCaps.texture2DArrayMaxLayerCount > 1;\n        }\n    }\n    /**\n     * Gets the unique ID of this manager\n     */\n    get uniqueId() {\n        return this._uniqueId;\n    }\n    /**\n     * Gets the number of vertices handled by this manager\n     */\n    get vertexCount() {\n        return this._vertexCount;\n    }\n    /**\n     * Gets a boolean indicating if this manager supports morphing of normals\n     */\n    get supportsNormals() {\n        return this._supportsNormals && this.enableNormalMorphing;\n    }\n    /**\n     * Gets a boolean indicating if this manager supports morphing of tangents\n     */\n    get supportsTangents() {\n        return this._supportsTangents && this.enableTangentMorphing;\n    }\n    /**\n     * Gets a boolean indicating if this manager supports morphing of texture coordinates\n     */\n    get supportsUVs() {\n        return this._supportsUVs && this.enableUVMorphing;\n    }\n    /**\n     * Gets the number of targets stored in this manager\n     */\n    get numTargets() {\n        return this._targets.length;\n    }\n    /**\n     * Gets the number of influencers (ie. the number of targets with influences > 0)\n     */\n    get numInfluencers() {\n        return this._activeTargets.length;\n    }\n    /**\n     * Gets the list of influences (one per target)\n     */\n    get influences() {\n        return this._influences;\n    }\n    /**\n     * Gets or sets a boolean indicating that targets should be stored as a texture instead of using vertex attributes (default is true).\n     * Please note that this option is not available if the hardware does not support it\n     */\n    get useTextureToStoreTargets() {\n        return this._useTextureToStoreTargets;\n    }\n    set useTextureToStoreTargets(value) {\n        this._useTextureToStoreTargets = value;\n    }\n    /**\n     * Gets a boolean indicating that the targets are stored into a texture (instead of as attributes)\n     */\n    get isUsingTextureForTargets() {\n        return MorphTargetManager.EnableTextureStorage && this.useTextureToStoreTargets && this._canUseTextureForTargets;\n    }\n    /**\n     * Gets the active target at specified index. An active target is a target with an influence > 0\n     * @param index defines the index to check\n     * @returns the requested target\n     */\n    getActiveTarget(index) {\n        return this._activeTargets.data[index];\n    }\n    /**\n     * Gets the target at specified index\n     * @param index defines the index to check\n     * @returns the requested target\n     */\n    getTarget(index) {\n        return this._targets[index];\n    }\n    /**\n     * Add a new target to this manager\n     * @param target defines the target to add\n     */\n    addTarget(target) {\n        this._targets.push(target);\n        this._targetInfluenceChangedObservers.push(target.onInfluenceChanged.add((needUpdate) => {\n            this._syncActiveTargets(needUpdate);\n        }));\n        this._targetDataLayoutChangedObservers.push(target._onDataLayoutChanged.add(() => {\n            this._syncActiveTargets(true);\n        }));\n        this._syncActiveTargets(true);\n    }\n    /**\n     * Removes a target from the manager\n     * @param target defines the target to remove\n     */\n    removeTarget(target) {\n        const index = this._targets.indexOf(target);\n        if (index >= 0) {\n            this._targets.splice(index, 1);\n            target.onInfluenceChanged.remove(this._targetInfluenceChangedObservers.splice(index, 1)[0]);\n            target._onDataLayoutChanged.remove(this._targetDataLayoutChangedObservers.splice(index, 1)[0]);\n            this._syncActiveTargets(true);\n        }\n    }\n    /**\n     * @internal\n     */\n    _bind(effect) {\n        effect.setFloat3(\"morphTargetTextureInfo\", this._textureVertexStride, this._textureWidth, this._textureHeight);\n        effect.setFloatArray(\"morphTargetTextureIndices\", this._morphTargetTextureIndices);\n        effect.setTexture(\"morphTargets\", this._targetStoreTexture);\n    }\n    /**\n     * Clone the current manager\n     * @returns a new MorphTargetManager\n     */\n    clone() {\n        const copy = new MorphTargetManager(this._scene);\n        for (const target of this._targets) {\n            copy.addTarget(target.clone());\n        }\n        copy.enableNormalMorphing = this.enableNormalMorphing;\n        copy.enableTangentMorphing = this.enableTangentMorphing;\n        copy.enableUVMorphing = this.enableUVMorphing;\n        return copy;\n    }\n    /**\n     * Serializes the current manager into a Serialization object\n     * @returns the serialized object\n     */\n    serialize() {\n        const serializationObject = {};\n        serializationObject.id = this.uniqueId;\n        serializationObject.targets = [];\n        for (const target of this._targets) {\n            serializationObject.targets.push(target.serialize());\n        }\n        return serializationObject;\n    }\n    _syncActiveTargets(needUpdate) {\n        if (this.areUpdatesFrozen) {\n            return;\n        }\n        let influenceCount = 0;\n        this._activeTargets.reset();\n        this._supportsNormals = true;\n        this._supportsTangents = true;\n        this._supportsUVs = true;\n        this._vertexCount = 0;\n        if (this._scene && this._targets.length > this._scene.getEngine().getCaps().texture2DArrayMaxLayerCount) {\n            this.useTextureToStoreTargets = false;\n        }\n        if (!this._morphTargetTextureIndices || this._morphTargetTextureIndices.length !== this._targets.length) {\n            this._morphTargetTextureIndices = new Float32Array(this._targets.length);\n        }\n        let targetIndex = -1;\n        for (const target of this._targets) {\n            targetIndex++;\n            if (target.influence === 0 && this.optimizeInfluencers) {\n                continue;\n            }\n            if (this._activeTargets.length >= MorphTargetManager.MaxActiveMorphTargetsInVertexAttributeMode && !this.isUsingTextureForTargets) {\n                break;\n            }\n            this._activeTargets.push(target);\n            this._morphTargetTextureIndices[influenceCount] = targetIndex;\n            this._tempInfluences[influenceCount++] = target.influence;\n            this._supportsNormals = this._supportsNormals && target.hasNormals;\n            this._supportsTangents = this._supportsTangents && target.hasTangents;\n            this._supportsUVs = this._supportsUVs && target.hasUVs;\n            const positions = target.getPositions();\n            if (positions) {\n                const vertexCount = positions.length / 3;\n                if (this._vertexCount === 0) {\n                    this._vertexCount = vertexCount;\n                }\n                else if (this._vertexCount !== vertexCount) {\n                    Logger.Error(\"Incompatible target. Targets must all have the same vertices count.\");\n                    return;\n                }\n            }\n        }\n        if (!this._influences || this._influences.length !== influenceCount) {\n            this._influences = new Float32Array(influenceCount);\n        }\n        for (let index = 0; index < influenceCount; index++) {\n            this._influences[index] = this._tempInfluences[index];\n        }\n        if (needUpdate) {\n            this.synchronize();\n        }\n    }\n    /**\n     * Synchronize the targets with all the meshes using this morph target manager\n     */\n    synchronize() {\n        if (!this._scene || this.areUpdatesFrozen) {\n            return;\n        }\n        if (this.isUsingTextureForTargets && this._vertexCount) {\n            this._textureVertexStride = 1;\n            if (this._supportsNormals) {\n                this._textureVertexStride++;\n            }\n            if (this._supportsTangents) {\n                this._textureVertexStride++;\n            }\n            if (this._supportsUVs) {\n                this._textureVertexStride++;\n            }\n            this._textureWidth = this._vertexCount * this._textureVertexStride;\n            this._textureHeight = 1;\n            const maxTextureSize = this._scene.getEngine().getCaps().maxTextureSize;\n            if (this._textureWidth > maxTextureSize) {\n                this._textureHeight = Math.ceil(this._textureWidth / maxTextureSize);\n                this._textureWidth = maxTextureSize;\n            }\n            let mustUpdateTexture = true;\n            if (this._targetStoreTexture) {\n                const textureSize = this._targetStoreTexture.getSize();\n                if (textureSize.width === this._textureWidth && textureSize.height === this._textureHeight && this._targetStoreTexture.depth === this._targets.length) {\n                    mustUpdateTexture = false;\n                }\n            }\n            if (mustUpdateTexture) {\n                if (this._targetStoreTexture) {\n                    this._targetStoreTexture.dispose();\n                }\n                const targetCount = this._targets.length;\n                const data = new Float32Array(targetCount * this._textureWidth * this._textureHeight * 4);\n                let offset = 0;\n                for (let index = 0; index < targetCount; index++) {\n                    const target = this._targets[index];\n                    const positions = target.getPositions();\n                    const normals = target.getNormals();\n                    const uvs = target.getUVs();\n                    const tangents = target.getTangents();\n                    if (!positions) {\n                        if (index === 0) {\n                            Logger.Error(\"Invalid morph target. Target must have positions.\");\n                        }\n                        return;\n                    }\n                    offset = index * this._textureWidth * this._textureHeight * 4;\n                    for (let vertex = 0; vertex < this._vertexCount; vertex++) {\n                        data[offset] = positions[vertex * 3];\n                        data[offset + 1] = positions[vertex * 3 + 1];\n                        data[offset + 2] = positions[vertex * 3 + 2];\n                        offset += 4;\n                        if (normals) {\n                            data[offset] = normals[vertex * 3];\n                            data[offset + 1] = normals[vertex * 3 + 1];\n                            data[offset + 2] = normals[vertex * 3 + 2];\n                            offset += 4;\n                        }\n                        if (uvs) {\n                            data[offset] = uvs[vertex * 2];\n                            data[offset + 1] = uvs[vertex * 2 + 1];\n                            offset += 4;\n                        }\n                        if (tangents) {\n                            data[offset] = tangents[vertex * 3];\n                            data[offset + 1] = tangents[vertex * 3 + 1];\n                            data[offset + 2] = tangents[vertex * 3 + 2];\n                            offset += 4;\n                        }\n                    }\n                }\n                this._targetStoreTexture = RawTexture2DArray.CreateRGBATexture(data, this._textureWidth, this._textureHeight, targetCount, this._scene, false, false, 1, 1);\n            }\n        }\n        // Flag meshes as dirty to resync with the active targets\n        for (const mesh of this._scene.meshes) {\n            if (mesh.morphTargetManager === this) {\n                mesh._syncGeometryWithMorphTargetManager();\n            }\n        }\n    }\n    /**\n     * Release all resources\n     */\n    dispose() {\n        if (this._targetStoreTexture) {\n            this._targetStoreTexture.dispose();\n        }\n        this._targetStoreTexture = null;\n        // Remove from scene\n        if (this._scene) {\n            this._scene.removeMorphTargetManager(this);\n            if (this._parentContainer) {\n                const index = this._parentContainer.morphTargetManagers.indexOf(this);\n                if (index > -1) {\n                    this._parentContainer.morphTargetManagers.splice(index, 1);\n                }\n                this._parentContainer = null;\n            }\n        }\n    }\n    // Statics\n    /**\n     * Creates a new MorphTargetManager from serialized data\n     * @param serializationObject defines the serialized data\n     * @param scene defines the hosting scene\n     * @returns the new MorphTargetManager\n     */\n    static Parse(serializationObject, scene) {\n        const result = new MorphTargetManager(scene);\n        result._uniqueId = serializationObject.id;\n        for (const targetData of serializationObject.targets) {\n            result.addTarget(MorphTarget.Parse(targetData, scene));\n        }\n        return result;\n    }\n}\n/** Enable storing morph target data into textures when set to true (true by default) */\nMorphTargetManager.EnableTextureStorage = true;\n/** Maximum number of active morph targets supported in the \"vertex attribute\" mode (i.e., not the \"texture\" mode) */\nMorphTargetManager.MaxActiveMorphTargetsInVertexAttributeMode = 8;\n//# sourceMappingURL=morphTargetManager.js.map","import { Tools } from \"../Misc/tools.js\";\nimport { Logger } from \"../Misc/logger.js\";\nimport { GetTGAHeader } from \"../Misc/tga.js\";\nimport { Engine } from \"../Engines/engine.js\";\nimport { WebRequest } from \"../Misc/webRequest.js\";\n// Sets the default offline provider to Babylon.js\nEngine.OfflineProviderFactory = (urlToScene, callbackManifestChecked, disableManifestCheck = false) => {\n    return new Database(urlToScene, callbackManifestChecked, disableManifestCheck);\n};\n/**\n * Class used to enable access to IndexedDB\n * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/optimizeCached\n */\nexport class Database {\n    /**\n     * Gets a boolean indicating if scene must be saved in the database\n     */\n    get enableSceneOffline() {\n        return this._enableSceneOffline;\n    }\n    /**\n     * Gets a boolean indicating if textures must be saved in the database\n     */\n    get enableTexturesOffline() {\n        return this._enableTexturesOffline;\n    }\n    /**\n     * Creates a new Database\n     * @param urlToScene defines the url to load the scene\n     * @param callbackManifestChecked defines the callback to use when manifest is checked\n     * @param disableManifestCheck defines a boolean indicating that we want to skip the manifest validation (it will be considered validated and up to date)\n     */\n    constructor(urlToScene, callbackManifestChecked, disableManifestCheck = false) {\n        // Handling various flavors of prefixed version of IndexedDB\n        this._idbFactory = (typeof indexedDB !== \"undefined\" ? indexedDB : undefined);\n        this._currentSceneUrl = Database._ReturnFullUrlLocation(urlToScene);\n        this._db = null;\n        this._enableSceneOffline = false;\n        this._enableTexturesOffline = false;\n        this._manifestVersionFound = 0;\n        this._mustUpdateRessources = false;\n        this._hasReachedQuota = false;\n        if (!Database.IDBStorageEnabled) {\n            callbackManifestChecked(true);\n        }\n        else {\n            if (disableManifestCheck) {\n                this._enableSceneOffline = true;\n                this._enableTexturesOffline = true;\n                this._manifestVersionFound = 1;\n                Tools.SetImmediate(() => {\n                    callbackManifestChecked(true);\n                });\n            }\n            else {\n                this._checkManifestFile(callbackManifestChecked);\n            }\n        }\n    }\n    _checkManifestFile(callbackManifestChecked) {\n        const noManifestFile = () => {\n            this._enableSceneOffline = false;\n            this._enableTexturesOffline = false;\n            callbackManifestChecked(false);\n        };\n        const createManifestURL = () => {\n            try {\n                // make sure we have a valid URL.\n                if (typeof URL === \"function\" && this._currentSceneUrl.indexOf(\"http\") === 0) {\n                    // we don't have the base url, so the URL string must have a protocol\n                    const url = new URL(this._currentSceneUrl);\n                    url.pathname += \".manifest\";\n                    return url.toString();\n                }\n            }\n            catch (e) {\n                // defensive - if this fails for any reason, fall back to the older method\n            }\n            return `${this._currentSceneUrl}.manifest`;\n        };\n        let timeStampUsed = false;\n        let manifestURL = createManifestURL();\n        const xhr = new WebRequest();\n        if (navigator.onLine) {\n            // Adding a timestamp to by-pass browsers' cache\n            timeStampUsed = true;\n            manifestURL = manifestURL + (manifestURL.match(/\\?/) == null ? \"?\" : \"&\") + Date.now();\n        }\n        xhr.open(\"GET\", manifestURL);\n        xhr.addEventListener(\"load\", () => {\n            if (xhr.status === 200 || Database._ValidateXHRData(xhr, 1)) {\n                try {\n                    const manifestFile = JSON.parse(xhr.response);\n                    this._enableSceneOffline = manifestFile.enableSceneOffline;\n                    this._enableTexturesOffline = manifestFile.enableTexturesOffline && Database._IsUASupportingBlobStorage;\n                    if (manifestFile.version && !isNaN(parseInt(manifestFile.version))) {\n                        this._manifestVersionFound = manifestFile.version;\n                    }\n                    callbackManifestChecked(true);\n                }\n                catch (ex) {\n                    noManifestFile();\n                }\n            }\n            else {\n                noManifestFile();\n            }\n        }, false);\n        xhr.addEventListener(\"error\", () => {\n            if (timeStampUsed) {\n                timeStampUsed = false;\n                // Let's retry without the timeStamp\n                // It could fail when coupled with HTML5 Offline API\n                const retryManifestURL = createManifestURL();\n                xhr.open(\"GET\", retryManifestURL);\n                xhr.send();\n            }\n            else {\n                noManifestFile();\n            }\n        }, false);\n        try {\n            xhr.send();\n        }\n        catch (ex) {\n            Logger.Error(\"Error on XHR send request.\");\n            callbackManifestChecked(false);\n        }\n    }\n    /**\n     * Open the database and make it available\n     * @param successCallback defines the callback to call on success\n     * @param errorCallback defines the callback to call on error\n     */\n    open(successCallback, errorCallback) {\n        const handleError = () => {\n            this._isSupported = false;\n            if (errorCallback) {\n                errorCallback();\n            }\n        };\n        if (!this._idbFactory || !(this._enableSceneOffline || this._enableTexturesOffline)) {\n            // Your browser doesn't support IndexedDB\n            this._isSupported = false;\n            if (errorCallback) {\n                errorCallback();\n            }\n        }\n        else {\n            // If the DB hasn't been opened or created yet\n            if (!this._db) {\n                this._hasReachedQuota = false;\n                this._isSupported = true;\n                const request = this._idbFactory.open(\"babylonjs\", 1);\n                // Could occur if user is blocking the quota for the DB and/or doesn't grant access to IndexedDB\n                request.onerror = () => {\n                    handleError();\n                };\n                // executes when a version change transaction cannot complete due to other active transactions\n                request.onblocked = () => {\n                    Logger.Error(\"IDB request blocked. Please reload the page.\");\n                    handleError();\n                };\n                // DB has been opened successfully\n                request.onsuccess = () => {\n                    this._db = request.result;\n                    successCallback();\n                };\n                // Initialization of the DB. Creating Scenes & Textures stores\n                request.onupgradeneeded = (event) => {\n                    this._db = event.target.result;\n                    if (this._db) {\n                        try {\n                            this._db.createObjectStore(\"scenes\", { keyPath: \"sceneUrl\" });\n                            this._db.createObjectStore(\"versions\", { keyPath: \"sceneUrl\" });\n                            this._db.createObjectStore(\"textures\", { keyPath: \"textureUrl\" });\n                        }\n                        catch (ex) {\n                            Logger.Error(\"Error while creating object stores. Exception: \" + ex.message);\n                            handleError();\n                        }\n                    }\n                };\n            }\n            // DB has already been created and opened\n            else {\n                if (successCallback) {\n                    successCallback();\n                }\n            }\n        }\n    }\n    /**\n     * Loads an image from the database\n     * @param url defines the url to load from\n     * @param image defines the target DOM image\n     */\n    loadImage(url, image) {\n        const completeURL = Database._ReturnFullUrlLocation(url);\n        const saveAndLoadImage = () => {\n            if (!this._hasReachedQuota && this._db !== null) {\n                // the texture is not yet in the DB, let's try to save it\n                this._saveImageIntoDBAsync(completeURL, image);\n            }\n            // If the texture is not in the DB and we've reached the DB quota limit\n            // let's load it directly from the web\n            else {\n                image.src = url;\n            }\n        };\n        if (!this._mustUpdateRessources) {\n            this._loadImageFromDBAsync(completeURL, image, saveAndLoadImage);\n        }\n        // First time we're download the images or update requested in the manifest file by a version change\n        else {\n            saveAndLoadImage();\n        }\n    }\n    _loadImageFromDBAsync(url, image, notInDBCallback) {\n        if (this._isSupported && this._db !== null) {\n            let texture;\n            const transaction = this._db.transaction([\"textures\"]);\n            transaction.onabort = () => {\n                image.src = url;\n            };\n            transaction.oncomplete = () => {\n                let blobTextureURL;\n                if (texture && typeof URL === \"function\") {\n                    blobTextureURL = URL.createObjectURL(texture.data);\n                    image.onerror = () => {\n                        Logger.Error(\"Error loading image from blob URL: \" + blobTextureURL + \" switching back to web url: \" + url);\n                        image.src = url;\n                    };\n                    image.src = blobTextureURL;\n                }\n                else {\n                    notInDBCallback();\n                }\n            };\n            const getRequest = transaction.objectStore(\"textures\").get(url);\n            getRequest.onsuccess = (event) => {\n                texture = event.target.result;\n            };\n            getRequest.onerror = () => {\n                Logger.Error(\"Error loading texture \" + url + \" from DB.\");\n                image.src = url;\n            };\n        }\n        else {\n            Logger.Error(\"Error: IndexedDB not supported by your browser or BabylonJS Database is not open.\");\n            image.src = url;\n        }\n    }\n    _saveImageIntoDBAsync(url, image) {\n        let blob;\n        if (this._isSupported) {\n            // In case of error (type not supported or quota exceeded), we're at least sending back XHR data to allow texture loading later on\n            const generateBlobUrl = () => {\n                let blobTextureURL;\n                if (blob && typeof URL === \"function\") {\n                    try {\n                        blobTextureURL = URL.createObjectURL(blob);\n                    }\n                    catch (ex) {\n                        // Chrome is raising a type error if we're setting the oneTimeOnly parameter\n                        blobTextureURL = URL.createObjectURL(blob);\n                    }\n                }\n                if (blobTextureURL) {\n                    image.src = blobTextureURL;\n                }\n            };\n            if (Database._IsUASupportingBlobStorage) {\n                // Create XHR\n                const xhr = new WebRequest();\n                xhr.open(\"GET\", url);\n                xhr.responseType = \"blob\";\n                xhr.addEventListener(\"load\", () => {\n                    if (xhr.status === 200 && this._db) {\n                        // Blob as response\n                        blob = xhr.response;\n                        const transaction = this._db.transaction([\"textures\"], \"readwrite\");\n                        // the transaction could abort because of a QuotaExceededError error\n                        transaction.onabort = (event) => {\n                            try {\n                                //backwards compatibility with ts 1.0, srcElement doesn't have an \"error\" according to ts 1.3\n                                const srcElement = event.target;\n                                const error = srcElement.error;\n                                if (error && error.name === \"QuotaExceededError\") {\n                                    this._hasReachedQuota = true;\n                                }\n                            }\n                            catch (ex) { }\n                            generateBlobUrl();\n                        };\n                        transaction.oncomplete = () => {\n                            generateBlobUrl();\n                        };\n                        const newTexture = { textureUrl: url, data: blob };\n                        try {\n                            // Put the blob into the dabase\n                            const addRequest = transaction.objectStore(\"textures\").put(newTexture);\n                            addRequest.onsuccess = () => { };\n                            addRequest.onerror = () => {\n                                generateBlobUrl();\n                            };\n                        }\n                        catch (ex) {\n                            // \"DataCloneError\" generated by Chrome when you try to inject blob into IndexedDB\n                            if (ex.code === 25) {\n                                Database._IsUASupportingBlobStorage = false;\n                                this._enableTexturesOffline = false;\n                            }\n                            image.src = url;\n                        }\n                    }\n                    else {\n                        image.src = url;\n                    }\n                }, false);\n                xhr.addEventListener(\"error\", () => {\n                    Logger.Error(\"Error in XHR request in BABYLON.Database.\");\n                    image.src = url;\n                }, false);\n                xhr.send();\n            }\n            else {\n                image.src = url;\n            }\n        }\n        else {\n            Logger.Error(\"Error: IndexedDB not supported by your browser or Babylon.js database is not open.\");\n            image.src = url;\n        }\n    }\n    _checkVersionFromDB(url, versionLoaded) {\n        const updateVersion = () => {\n            // the version is not yet in the DB or we need to update it\n            this._saveVersionIntoDBAsync(url, versionLoaded);\n        };\n        this._loadVersionFromDBAsync(url, versionLoaded, updateVersion);\n    }\n    _loadVersionFromDBAsync(url, callback, updateInDBCallback) {\n        if (this._isSupported && this._db) {\n            let version;\n            try {\n                const transaction = this._db.transaction([\"versions\"]);\n                transaction.oncomplete = () => {\n                    if (version) {\n                        // If the version in the JSON file is different from the version in DB\n                        if (this._manifestVersionFound !== version.data) {\n                            this._mustUpdateRessources = true;\n                            updateInDBCallback();\n                        }\n                        else {\n                            callback(version.data);\n                        }\n                    }\n                    // version was not found in DB\n                    else {\n                        this._mustUpdateRessources = true;\n                        updateInDBCallback();\n                    }\n                };\n                transaction.onabort = () => {\n                    callback(-1);\n                };\n                const getRequest = transaction.objectStore(\"versions\").get(url);\n                getRequest.onsuccess = (event) => {\n                    version = event.target.result;\n                };\n                getRequest.onerror = () => {\n                    Logger.Error(\"Error loading version for scene \" + url + \" from DB.\");\n                    callback(-1);\n                };\n            }\n            catch (ex) {\n                Logger.Error(\"Error while accessing 'versions' object store (READ OP). Exception: \" + ex.message);\n                callback(-1);\n            }\n        }\n        else {\n            Logger.Error(\"Error: IndexedDB not supported by your browser or Babylon.js database is not open.\");\n            callback(-1);\n        }\n    }\n    _saveVersionIntoDBAsync(url, callback) {\n        if (this._isSupported && !this._hasReachedQuota && this._db) {\n            try {\n                // Open a transaction to the database\n                const transaction = this._db.transaction([\"versions\"], \"readwrite\");\n                // the transaction could abort because of a QuotaExceededError error\n                transaction.onabort = (event) => {\n                    try {\n                        //backwards compatibility with ts 1.0, srcElement doesn't have an \"error\" according to ts 1.3\n                        const error = event.target[\"error\"];\n                        if (error && error.name === \"QuotaExceededError\") {\n                            this._hasReachedQuota = true;\n                        }\n                    }\n                    catch (ex) { }\n                    callback(-1);\n                };\n                transaction.oncomplete = () => {\n                    callback(this._manifestVersionFound);\n                };\n                const newVersion = { sceneUrl: url, data: this._manifestVersionFound };\n                // Put the scene into the database\n                const addRequest = transaction.objectStore(\"versions\").put(newVersion);\n                addRequest.onsuccess = () => { };\n                addRequest.onerror = () => {\n                    Logger.Error(\"Error in DB add version request in BABYLON.Database.\");\n                };\n            }\n            catch (ex) {\n                Logger.Error(\"Error while accessing 'versions' object store (WRITE OP). Exception: \" + ex.message);\n                callback(-1);\n            }\n        }\n        else {\n            callback(-1);\n        }\n    }\n    /**\n     * Loads a file from database\n     * @param url defines the URL to load from\n     * @param sceneLoaded defines a callback to call on success\n     * @param progressCallBack defines a callback to call when progress changed\n     * @param errorCallback defines a callback to call on error\n     * @param useArrayBuffer defines a boolean to use array buffer instead of text string\n     */\n    loadFile(url, sceneLoaded, progressCallBack, errorCallback, useArrayBuffer) {\n        const completeUrl = Database._ReturnFullUrlLocation(url);\n        const saveAndLoadFile = () => {\n            // the scene is not yet in the DB, let's try to save it\n            this._saveFileAsync(completeUrl, sceneLoaded, progressCallBack, useArrayBuffer, errorCallback);\n        };\n        this._checkVersionFromDB(completeUrl, (version) => {\n            if (version !== -1) {\n                if (!this._mustUpdateRessources) {\n                    this._loadFileAsync(completeUrl, sceneLoaded, saveAndLoadFile);\n                }\n                else {\n                    this._saveFileAsync(completeUrl, sceneLoaded, progressCallBack, useArrayBuffer, errorCallback);\n                }\n            }\n            else {\n                if (errorCallback) {\n                    errorCallback();\n                }\n            }\n        });\n    }\n    _loadFileAsync(url, callback, notInDBCallback) {\n        if (this._isSupported && this._db) {\n            let targetStore;\n            if (url.indexOf(\".babylon\") !== -1) {\n                targetStore = \"scenes\";\n            }\n            else {\n                targetStore = \"textures\";\n            }\n            let file;\n            const transaction = this._db.transaction([targetStore]);\n            transaction.oncomplete = () => {\n                if (file) {\n                    callback(file.data);\n                }\n                // file was not found in DB\n                else {\n                    notInDBCallback();\n                }\n            };\n            transaction.onabort = () => {\n                notInDBCallback();\n            };\n            const getRequest = transaction.objectStore(targetStore).get(url);\n            getRequest.onsuccess = (event) => {\n                file = event.target.result;\n            };\n            getRequest.onerror = () => {\n                Logger.Error(\"Error loading file \" + url + \" from DB.\");\n                notInDBCallback();\n            };\n        }\n        else {\n            Logger.Error(\"Error: IndexedDB not supported by your browser or BabylonJS Database is not open.\");\n            callback();\n        }\n    }\n    _saveFileAsync(url, callback, progressCallback, useArrayBuffer, errorCallback) {\n        if (this._isSupported) {\n            let targetStore;\n            if (url.indexOf(\".babylon\") !== -1) {\n                targetStore = \"scenes\";\n            }\n            else {\n                targetStore = \"textures\";\n            }\n            // Create XHR\n            const xhr = new WebRequest();\n            let fileData;\n            xhr.open(\"GET\", url + (url.match(/\\?/) == null ? \"?\" : \"&\") + Date.now());\n            if (useArrayBuffer) {\n                xhr.responseType = \"arraybuffer\";\n            }\n            if (progressCallback) {\n                xhr.onprogress = progressCallback;\n            }\n            xhr.addEventListener(\"load\", () => {\n                if (xhr.status === 200 || (xhr.status < 400 && Database._ValidateXHRData(xhr, !useArrayBuffer ? 1 : 6))) {\n                    // Blob as response\n                    fileData = !useArrayBuffer ? xhr.responseText : xhr.response;\n                    if (!this._hasReachedQuota && this._db) {\n                        // Open a transaction to the database\n                        const transaction = this._db.transaction([targetStore], \"readwrite\");\n                        // the transaction could abort because of a QuotaExceededError error\n                        transaction.onabort = (event) => {\n                            try {\n                                //backwards compatibility with ts 1.0, srcElement doesn't have an \"error\" according to ts 1.3\n                                const error = event.target[\"error\"];\n                                if (error && error.name === \"QuotaExceededError\") {\n                                    this._hasReachedQuota = true;\n                                }\n                            }\n                            catch (ex) { }\n                            callback(fileData);\n                        };\n                        transaction.oncomplete = () => {\n                            callback(fileData);\n                        };\n                        let newFile;\n                        if (targetStore === \"scenes\") {\n                            newFile = { sceneUrl: url, data: fileData, version: this._manifestVersionFound };\n                        }\n                        else {\n                            newFile = { textureUrl: url, data: fileData };\n                        }\n                        try {\n                            // Put the scene into the database\n                            const addRequest = transaction.objectStore(targetStore).put(newFile);\n                            addRequest.onsuccess = () => { };\n                            addRequest.onerror = () => {\n                                Logger.Error(\"Error in DB add file request in BABYLON.Database.\");\n                            };\n                        }\n                        catch (ex) {\n                            callback(fileData);\n                        }\n                    }\n                    else {\n                        callback(fileData);\n                    }\n                }\n                else {\n                    if (xhr.status >= 400 && errorCallback) {\n                        errorCallback(xhr);\n                    }\n                    else {\n                        callback();\n                    }\n                }\n            }, false);\n            xhr.addEventListener(\"error\", () => {\n                Logger.Error(\"error on XHR request.\");\n                errorCallback && errorCallback();\n            }, false);\n            xhr.send();\n        }\n        else {\n            Logger.Error(\"Error: IndexedDB not supported by your browser or Babylon.js database is not open.\");\n            errorCallback && errorCallback();\n        }\n    }\n    /**\n     * Validates if xhr data is correct\n     * @param xhr defines the request to validate\n     * @param dataType defines the expected data type\n     * @returns true if data is correct\n     */\n    static _ValidateXHRData(xhr, dataType = 7) {\n        // 1 for text (.babylon, manifest and shaders), 2 for TGA, 4 for DDS, 7 for all\n        try {\n            if (dataType & 1) {\n                if (xhr.responseText && xhr.responseText.length > 0) {\n                    return true;\n                }\n                else if (dataType === 1) {\n                    return false;\n                }\n            }\n            if (dataType & 2) {\n                // Check header width and height since there is no \"TGA\" magic number\n                const tgaHeader = GetTGAHeader(xhr.response);\n                if (tgaHeader.width && tgaHeader.height && tgaHeader.width > 0 && tgaHeader.height > 0) {\n                    return true;\n                }\n                else if (dataType === 2) {\n                    return false;\n                }\n            }\n            if (dataType & 4) {\n                // Check for the \"DDS\" magic number\n                const ddsHeader = new Uint8Array(xhr.response, 0, 3);\n                if (ddsHeader[0] === 68 && ddsHeader[1] === 68 && ddsHeader[2] === 83) {\n                    return true;\n                }\n                else {\n                    return false;\n                }\n            }\n        }\n        catch (e) {\n            // Global protection\n        }\n        return false;\n    }\n}\n/** Gets a boolean indicating if the user agent supports blob storage (this value will be updated after creating the first Database object) */\nDatabase._IsUASupportingBlobStorage = true;\n/**\n * Gets a boolean indicating if Database storage is enabled (off by default)\n */\nDatabase.IDBStorageEnabled = false;\nDatabase._ParseURL = (url) => {\n    const a = document.createElement(\"a\");\n    a.href = url;\n    const urlWithoutHash = url.substring(0, url.lastIndexOf(\"#\"));\n    const fileName = url.substring(urlWithoutHash.lastIndexOf(\"/\") + 1, url.length);\n    const absLocation = url.substring(0, url.indexOf(fileName, 0));\n    return absLocation;\n};\nDatabase._ReturnFullUrlLocation = (url) => {\n    if (url.indexOf(\"http:/\") === -1 && url.indexOf(\"https:/\") === -1 && typeof window !== \"undefined\") {\n        return Database._ParseURL(window.location.href) + url;\n    }\n    else {\n        return url;\n    }\n};\n//# sourceMappingURL=database.js.map"],"names":["FileFaceOrientation","constructor","name","worldAxisForNormal","worldAxisForFileX","worldAxisForFileY","this","CubeMapToSphericalPolynomialTools","static","texture","_a","isCube","getScene","getEngine","flushFramebuffer","size","getSize","width","rightPromise","readPixels","undefined","leftPromise","upPromise","downPromise","isRenderTarget","frontPromise","backPromise","gammaSpace","type","textureType","Promise","resolve","all","then","left","right","up","down","front","back","cubeInfo","format","ConvertCubeMapToSphericalPolynomial","x","y","Math","atan2","sqrt","sphericalHarmonics","totalSolidAngle","du","dv","halfTexel","minUV","faceIndex","fileFace","_FileFaces","dataArray","v","stride","u","worldDirection","scale","add","normalize","deltaSolidAngle","_AreaElement","r","g","b","isNaN","pow","max","color","addLight","correctionFactor","PI","scaleInPlace","convertIncidentRadianceToIrradiance","convertIrradianceToLambertianRadiance","HDRTools","mantissa","exponent","float32array","red","green","blue","index","_Ldexp","uint8array","startIndex","line","character","i","length","String","fromCharCode","height","_ReadStringLine","endOfHeader","findFormat","lineIndex","match","exec","parseInt","dataPosition","buffer","Uint8Array","hdrInfo","RGBE_ReadHeader","data","RGBE_ReadPixels","_RGBEReadPixelsRLE","num_scanlines","scanline_width","a","c","d","count","dataIndex","endIndex","scanLineArrayBuffer","ArrayBuffer","scanLineArray","resultBuffer","resultArray","Float32Array","_RGBEReadPixelsNOTRLE","j","_Rgbe2float","PanoramaToCubeMapTools","float32Array","inputWidth","inputHeight","CreateCubemapTexture","FACE_FRONT","FACE_BACK","FACE_LEFT","FACE_RIGHT","FACE_UP","FACE_DOWN","texSize","faceData","textureArray","rotDX1","subtract","rotDX2","dy","fy","xv1","xv2","CalcProjectionSpherical","vDir","theta","z","phi","acos","dx","px","round","py","inputY","AndOrNotEvaluator","query","evaluateCallback","replace","slice","_HandleParenthesisContent","Eval","parenthesisContent","result","or","split","Object","prototype","hasOwnProperty","call","ori","_SimplifyNegation","trim","and","andj","substring","booleanString","ArrayTools","itemBuilder","push","BuildArray","observedArrayFunctions","_ObserveArray","array","callback","unObserveFunctions","map","object","functionName","oldFunction","newFunction","previousLength","returnValue","previous","apply","arguments","next","_observeArrayfunction","forEach","unObserveFunction","AssetTaskState","AbstractAssetTask","_isCompleted","_taskState","INIT","isCompleted","taskState","errorObject","_errorObject","_setErrorObject","message","exception","run","scene","onSuccess","onError","RUNNING","runTask","_onDoneCallback","msg","_onErrorCallback","Error","reset","ERROR","DONE","e","AssetsProgressEvent","remainingCount","totalCount","task","ContainerAssetTask","meshesNames","rootUrl","sceneFilename","extension","super","container","loadedContainer","loadedMeshes","meshes","loadedTransformNodes","transformNodes","loadedParticleSystems","particleSystems","loadedSkeletons","skeletons","loadedAnimationGroups","animationGroups","MeshAssetTask","TextFileAssetTask","url","_loadFile","text","request","status","statusText","BinaryFileAssetTask","ImageAssetTask","img","Image","onload","image","onerror","err","src","TextureAssetTask","noMipmap","invertY","samplingMode","CubeTextureAssetTask","extensions","files","prefiltered","HDRCubeTextureAssetTask","generateHarmonics","reserved","EquiRectangularCubeTextureAssetTask","AssetsManager","_isLoading","_tasks","Array","_waitingTasksCount","_totalTasksCount","onTaskSuccessObservable","onTaskErrorObservable","onTasksDoneObservable","onProgressObservable","useDefaultLoadingScreen","autoHideLoadingUI","_scene","addContainerTask","taskName","addMeshTask","addTextFileTask","addBinaryFileTask","addImageTask","addTextureTask","addCubeTextureTask","addHDRCubeTextureTask","addEquiRectangularCubeTextureAssetTask","removeTask","indexOf","splice","_decreaseWaitingTasksCount","onProgress","notifyObservers","currentTasks","onFinish","hideLoadingUI","_runTask","error","onTaskError","_formatTaskErrorMessage","onTaskSuccess","errorMessage","load","displayLoadingUI","loadAsync","reject","addOnce","remainingTasks","BASIS_FORMATS","BasisToolsOptions","JSModuleURL","WasmModuleURL","_WorkerPromise","_Worker","_actionId","TranscodeAsync","config","dataView","res","rej","wasmBinary","URL","workerBlobUrl","createObjectURL","Blob","workerFunc","Worker","initHandler","action","removeEventListener","addEventListener","postMessage","catch","actionId","messageHandler","id","success","dataViewCopy","byteLength","set","byteOffset","imageData","ignoreSupportedFormats","BindTexture","engine","_b","target","_gl","TEXTURE_2D","TEXTURE_CUBE_MAP","_bindTextureDirectly","LoadTextureFromTranscodeResult","transcodeResult","fileInfo","images","rootImage","levels","_invertVScale","cTFRGB565","_features","basisNeedsPOT","_uploadDataToTextureDirectly","Uint16Array","transcodedPixels","source","_rescaleTexture","scenes","_getInternalFormat","_releaseTexture","generateMipMaps","BasisTools","GetInternalFormatFromBasisFormat","level","_uploadCompressedDataToTextureDirectly","_cachedWrapU","_cachedWrapV","basisFormat","cTFETC1","cTFBC1","cTFBC4","cTFASTC_4x4","cTFETC2","cTFBC7","_BASIS_FORMAT","transcoderModulePromise","TranscodeLevel","loadedFile","imageIndex","levelIndex","convertToRgb565","dstSize","getImageTranscodedSizeInBytes","dst","transcodeImage","srcByteOffset","blockWidth","blockHeight","blockY","blockX","row","m","dstI","ConvertDxtToRgb565","getImageWidth","getImageHeight","onmessage","event","importScripts","BASIS","initializeBasis","imgData","BasisFile","basisFile","hasAlpha","getHasAlpha","imageCount","getNumImages","imageInfo","levelCount","getNumLevels","levelInfo","GetFileInfo","supportedCompressionFormats","astc","bc7","s3tc","pvrtc","etc2","etc1","GetSupportedTranscodeFormat","needsConversion","startTranscoding","buffers","loadSingleImage","mipCount","loadMipmapLevels","pixels","close","delete","defineProperty","get","value","_instanceNumber","GetEnvironmentBRDFTexture","environmentBRDFTexture","useDelayedTextureLoading","previousState","_blockEntityCollection","texturesCache","getLoadedTexturesCache","getInternalTexture","isRGBD","wrapU","wrapV","observer","onContextRestoredObservable","checkReady","isReady","onDisposeObservable","remove","ExtractBetweenMarkers","markerOpen","markerClose","block","currPos","openMarkers","waitForChar","currChar","charAt","nextChar","SkipWhitespaces","s","IsIdentifierChar","charCodeAt","RemoveComments","inComments","join","FindBackward","EscapeRegExp","ConversionMode","CopyTextureToTexture","_textureIsInternal","isDepthTexture","_engine","_isDepthTexture","_renderer","_effectWrapper","fragmentShader","useShaderStore","uniformNames","samplerNames","defines","onApplyObservable","setState","setDepthBuffer","depthCullingState","depthMask","depthFunc","_source","effect","_bindTexture","setTexture","setFloat","_conversion","copy","destination","conversion","None","engineDepthFunc","render","dispose","GenerateBase64StringFromPixelData","len","BYTES_PER_ELEMENT","npixels","val","canvas","document","createElement","ctx","getContext","createImageData","putImageData","canvas2","ctx2","translate","drawImage","toDataURL","GenerateBase64StringFromTexture","internalTexture","_readPixelsSync","async","GenerateBase64StringFromTextureAsync","inlineScheduler","coroutine","onStep","step","done","createYieldingScheduler","yieldAfterMS","startTime","currentTime","performance","now","setTimeout","runCoroutine","scheduler","abortSignal","resume","reschedule","stepResult","aborted","runCoroutineSync","runCoroutineAsync","makeSyncFunction","coroutineFactory","params","DataReader","readAsync","_dataView","DataView","_dataByteOffset","readUint32","getUint32","readUint8Array","readString","skipBytes","DDSD_MIPMAPCOUNT","DDPF_LUMINANCE","FourCCToInt32","FOURCC_DXT1","FOURCC_DXT3","FOURCC_DXT5","FOURCC_DX10","DDSTools","header","Int32Array","extendedHeader","headerLengthInt","mipmapCount","fourCC","dxgiFormat","isFourCC","isRGB","isLuminance","isCompressed","dataOffset","dataLength","arrayBuffer","lod","destArray","srcData","srcPos","StoreLODInAlphaChannel","rOffset","gOffset","bOffset","aOffset","byteArray","_ExtractLongWordOrder","info","loadMipmaps","faces","lodIndex","currentFace","destTypeMustBeFilterable","sphericalPolynomialFaces","sphericalPolynomial","ext","getCaps","mip","internalCompressedFormat","blockBytes","bpp","computeFormats","supported","console","_getRGBABufferInternalSizedFormat","startFace","caps","face","floatArray","_badOS","_badDesktopOS","textureHalfFloat","textureFloat","_GetFloatAsUIntRGBAArrayBuffer","_GetFloatRGBAArrayBuffer","_GetHalfFloatAsUIntRGBAArrayBuffer","_GetHalfFloatAsFloatRGBAArrayBuffer","floatAvailable","textureFloatLinearFiltering","halfFloatAvailable","textureHalfFloatLinearFiltering","destType","dataGetter","dataGetterPolynomial","_GetFloatAsHalfFloatRGBAArrayBuffer","_GetHalfFloatRGBAArrayBuffer","_GetRGBArrayBuffer","_GetRGBAArrayBuffer","unpackAlignment","_getUnpackAlignement","unpaddedRowSize","floor","_GetLuminanceArrayBuffer","lodScale","lodOffset","onLoad","forcedExtension","createPolynomials","createCubeTexture","loadData","_sphericalPolynomial","textureLOD","gl","textures","roughness","minLODIndex","maxLODIndex","mipmapIndex","min","glTextureFromLod","texParameteri","TEXTURE_MAG_FILTER","LINEAR","TEXTURE_MIN_FILTER","TEXTURE_WRAP_S","CLAMP_TO_EDGE","TEXTURE_WRAP_T","isDDS","_unpackFlipY","UploadDDSLevels","lodTexture","_isCube","_texture","_lodTextureHigh","_lodTextureMid","_lodTextureLow","__decoratorInitialStore","__mergedStore","_copySource","creationFunction","instanciate","tags","classStore","getMergedStore","property","propertyDescriptor","sourceProperty","propertyType","SerializationHelper","AllowLoadingUniqueId","clone","classKey","getClassName","store","currentTarget","currentKey","initialStore","parent","getPrototypeOf","generateSerializableMember","sourceName","propertyKey","getDirectStore","expandToProperty","targetKey","setCallback","key","equals","enumerable","configurable","generateExpandMember","serialize","serializeAsTexture","serializeAsColor3","serializeAsFresnelParameters","serializeAsVector2","serializeAsVector3","serializeAsMeshReference","serializeAsColorCurves","serializeAsColor4","serializeAsImageProcessingConfiguration","serializeAsQuaternion","serializeAsMatrix","serializeAsCameraReference","animations","animationIndex","animation","entity","serializationObject","serializedProperties","targetPropertyName","asArray","dest","_TextureParser","_FresnelParametersParser","getLastMeshById","_ColorCurvesParser","_ImageProcessingConfigurationParser","getCameraById","nativeOverride","descriptor","predicate","jsFunc","func","_native","nativeFunc","filter","CloneValue","destinationObject","DeepCopier","doNotCopyList","mustCopyList","properties","obj","props","getOwnPropertyNames","prop","GetAllPropertyNames","endsWith","sourceValue","typeOfSourceValue","clonedValue","Deferred","_resolve","_reject","promise","DepthReducer","depthRenderer","_depthRenderer","camera","setDepthRenderer","forceFullscreenViewport","_camera","_depthRendererId","enabled","setSourceTexture","getDepthMap","sourceTexture","depthRedux","activate","deactivate","disposeAll","_WarnImport","IsWindowObjectExist","window","IsNavigatorAvailable","navigator","IsDocumentAvailable","GetDOMTextContent","element","child","firstChild","nodeType","textContent","nextSibling","DomManagement","DumpTools","_DumpToolsEngine","preserveDrawingBuffer","depth","stencil","alpha","premultipliedAlpha","antialias","failIfMajorPerformanceCaveat","parallelShaderCompile","renderer","wrapper","successCallback","mimeType","fileName","bufferView","DumpData","toArrayBuffer","quality","_CreateDumpRenderer","setSize","data2","n","createRawTexture","setViewport","applyEffectWrapper","draw","blob","fileReader","FileReader","readAsArrayBuffer","DumpDataAsync","DumpFramebuffer","DefaultEnvironmentTextureImageType","MagicBytes","GetEnvInfo","pos","getUint8","manifestString","charCode","manifest","JSON","parse","normalizeEnvInfo","specular","specularDataPosition","lodGenerationScale","version","imageType","CreateImageDataArrayBufferViews","specularInfo","mipmapsCount","mipmaps","position","UploadEnvLevelsAsync","_lodGenerationScale","UploadLevelsAsync","_OnImageReadyAsync","expandTexture","rgbdPostProcess","generateNonLODTextures","lodTextures","cubeRtt","tempTexture","createTexture","getEffect","executeWhenCompiled","externalTextureSamplerBinding","onApply","setFloat2","needsInvertingBitmap","ImageBitmap","postProcessManager","directRender","restoreDefaultFramebuffer","revokeObjectURL","_uploadImageToTexture","_cachedAnisotropicFilteringLevel","updateTextureSamplingMode","supportRenderAndCopyToLodForFloatTextures","textureHalfFloatRender","textureFloatRender","_isRGBD","createRenderTargetCubeTexture","generateDepthBuffer","generateStencilBuffer","mipSlices","offset","_lodGenerationOffset","promises","bytes","forceBitmapOverHTMLImageElement","createImageBitmap","premultiplyAlpha","reason","_uploadArrayBufferViewToTexture","_swapAndDie","UploadEnvSpherical","irradianceInfo","irradiance","sp","xx","yy","zz","yz","zx","xy","_UpdateRGBDAsync","proxyPromise","createRawCubeTexture","_compression","onRebuildCallback","_internalTexture","proxy","isAsync","_bufferViewArrayArray","BaseError","_setPrototypeOf","setPrototypeOf","o","proto","__proto__","ErrorCodes","MeshInvalidPositionsError","UnsupportedTextureError","GLTFLoaderUnexpectedMagicError","SceneLoaderError","LoadFileError","RequestFileError","ReadFileError","RuntimeError","errorCode","innerError","Base64DataUrlRegEx","RegExp","file","FileToolsOptions","DefaultRetryStrategy","BaseUrl","CorsBehavior","PreprocessUrl","_CleanUrl","SetCorsBehavior","crossOrigin","LoadImage","input","offlineProvider","imageBitmapOptions","usingObjectURL","isView","onErrorHandler","inputText","toString","LoadFile","imgBmp","handlersList","unloadHandlersList","handler","cspException","effectiveDirective","blockedURI","originalPolicy","fromBlob","fromData","noOfflineSupport","_","contentType","loadFromOfflineSupport","loadImage","enableTexturesOffline","open","textureName","decodeURIComponent","toLowerCase","blobURL","ex","ReadFile","useArrayBuffer","reader","fileRequest","onCompleteObservable","abort","onloadend","onprogress","readAsText","fileOrUrl","onOpened","TestBase64DataUrl","DecodeBase64UrlToBinary","DecodeBase64UrlToString","RequestFile","responseURL","getResponseHeader","loadUrl","requestFile","onReadyStateChange","retryHandle","unbindEvents","onLoadEnd","clear","readyState","XMLHttpRequest","clearTimeout","handleError","retryLoop","retryIndex","responseType","IsFileURL","response","responseText","retryStrategy","waitTime","send","enableSceneOffline","loadFile","location","protocol","IsBase64DataUrl","uri","test","results","FileTools","_injectLTSFileTools","FilesInput","FilesToLoad","sceneLoadedCallback","progressCallback","additionalRenderLoopLogicCallback","textureLoadingCallback","startingProcessingFilesCallback","onReloadCallback","errorCallback","onProcessFileCallback","sceneFile","_currentScene","_sceneLoadedCallback","_progressCallback","_additionalRenderLoopLogicCallback","_textureLoadingCallback","_startingProcessingFilesCallback","_onReloadCallback","_errorCallback","monitorElementForDragNDrop","elementToMonitor","_elementToMonitor","_dragEnterHandler","_drag","_dragOverHandler","_dropHandler","_drop","filesToLoad","_filesToLoad","_renderFunction","remaining","getWaitingItemsCount","stopPropagation","preventDefault","eventDrop","loadFiles","_traverseFolder","folder","createReader","relativePath","fullPath","readEntries","entries","entry","isFile","correctName","isDirectory","_processFiles","pop","_sceneFileToLoad","dataTransfer","folders","items","fileToLoad","item","getAsEntry","webkitGetAsEntry","_processReload","reload","stopRenderLoop","executeWhenReady","runRenderLoop","FilesInputStore","ColorGradient","gradient","color1","color2","getColorToRef","random","copyFrom","Color3Gradient","FactorGradient","factor1","factor2","getFactor","GradientHelper","ratio","gradients","updateFunc","gradientIndex","currentGradient","nextGradient","lastIndex","RandomGUID","eventData","mask","userInfo","p","observers","state","_eventState","skipNextObservers","obs","_willBeUnregistered","scope","lastReturnedValue","lastReturnValue","unregisterOnNextCall","_deferUnregister","SceneOptimization","getDescription","optimizer","priority","MergeMeshesOptimization","_canBeMerged","abstractMesh","mesh","isDisposed","isVisible","isEnabled","instances","skeleton","hasLODLevels","UpdateSelectionTree","_UpdateSelectionTree","updateSelectionTree","globalPool","globalLength","currentPool","current","subIndex","otherMesh","material","checkCollisions","sceneAsAny","createOrUpdateSelectionOctree","serializedGeometries","SerializeGeometry","geometry","serializationGeometries","doNotSerialize","vertexData","serializeVerticeData","SerializeMesh","serializationScene","_geometry","getGeometryById","geometries","_Serialize","checkSyncReadSupported","supportSyncTextureRead","warn","ClearCache","autoClear","clearColor","ambientColor","gravity","collisionsEnabled","useRightHandedSystem","fogMode","fogColor","fogStart","fogEnd","fogDensity","isPhysicsEnabled","physicEngine","getPhysicsEngine","physicsEnabled","physicsGravity","physicsEngine","getPhysicsPluginName","metadata","morphTargetManagers","manager","morphTargetManager","light","lights","cameras","activeCamera","activeCameraID","animationGroupIndex","animationGroup","reflectionProbes","reflectionProbe","materials","multiMaterials","multiMaterial","environmentTexture","_files","environmentTextureRotationY","rotationY","environmentIntensity","boxes","spheres","cylinders","toruses","grounds","planes","torusKnots","getGeometries","delayLoadState","postProcesses","actionManager","actions","component","_serializableComponents","_CollectPromises","isArray","toSerialize","withParents","withChildren","getDescendants","node","serializeMaterial","some","mat","submaterial","subMaterials","defaultMaterial","FinalizeSingleMesh","VideoRecorder","getRenderingCanvas","captureStream","isRecording","_canvas","options","IsSupported","_options","_DefaultOptions","stream","fps","audioTracks","track","addTrack","_mediaRecorder","MediaRecorder","ondataavailable","_handleDataAvailable","bind","_handleError","onstop","_handleStop","stopRecording","stop","startRecording","maxDuration","_fileName","_recordedChunks","start","recordChunckSize","superBuffer","InspectableType","DataStorage","localStorage","setItem","removeItem","inMemoryStorage","getItem","defaultValue","_Storage","parseFloat","_GetStorage","Levenshtein","Alphabet","jsonObject","characters","_characterToIdx","k","_insertionCosts","_deletionCosts","_substitutionCosts","stringify","json","alphabet","charToInsertionCost","charToDeletionCost","charsToSubstitutionCost","Map","outerIdx","innerIdx","getCharacterIdx","char","getInsertionCost","idx","getDeletionCost","getSubstitutionCost","idx1","idx2","Sequence","_characters","sequence","_MAX_SEQUENCE_LENGTH","_alphabet","distance","other","_Distance","aChars","bChars","aLength","bLength","costMatrix","_CostMatrix","aIdx","bIdx","_InsertionCost","_DeletionCost","_SubstitutionCost","Trajectory","trajectory","_points","pt","segmentLength","_segmentLength","getLength","point","numPoints","getT","t","newPoint","scaleAndAddToRef","resampleAtTargetResolution","targetResolution","resampled","tokenize","tokens","tokenization","segmentDir","_TransformSegmentDirToRef","_TokenizeSegment","priorVec","fromVec","toVec","subtractToRef","_ForwardDir","scaleToRef","_InverseFromVec","abs","_UpDir","_LookMatrix","_FromToVec","segment","_BestMatch","_Score","_BestScore","TrajectoryDescriptor","_sequences","Deserialize","vector3Alphabet","levenshteinAlphabet","CreateFromTokenizationPyramid","_GetTokenizationPyramid","pyramid","_FINEST_DESCRIPTOR_RESOLUTION","chars","weight","totalDistance","TrajectoryClass","descriptors","_descriptors","desc","centroidIdx","_centroidIdx","averageDistance","_averageDistance","described","_refreshDescription","getMatchCost","getMatchMinimumDistance","sum","distances","_MIN_AVERAGE_DISTANCE","Reflector","hostname","port","Log","_webSocket","WebSocket","startsWith","_SERVER_PREFIX","serverMessage","substr","_handleServerMessage","_handleClientMessage","onclose","code","serialized","DynamicFloat32Array","itemCapacity","_view","_itemLength","itemLength","at","NaN","subarray","end","_growArray","newCapacity","view","InitialArraySize","TimestampColHeader","NumPointsColHeader","CarriageReturnRegex","PerformanceViewerCollector","SliceDataOffset","NumberOfPointsOffset","_enabledStrategyCallbacks","_collectDataAtFrame","timestamp","_startingTimestamp","datasets","ids","numberOfIndices","startingIndices","startingIndex","previousStartingIndex","strategy","_strategies","getData","datasetObservable","hasObservers","_datasetMeta","_eventRestoreSet","Set","_customEventObservable","metadataObservable","addCollectionStrategies","registerEvent","forceUpdate","category","has","strategyCallback","counter","afterRenderObserver","onAfterRenderObservable","stringObserver","eventVal","sendEvent","_restoreStringEvents","strategyCallbacks","hidden","_getHexColorFromId","hash","hex","getCurrentSlice","updateMetadata","meta","preserveStringEventsRestore","_hasLoadedData","hasLoadedData","loadFromFileData","keepDatasetMeta","lines","numPointsIndex","parsedDatasets","firstLine","dataLines","idCategoryMap","exportDataToCsv","csvContent","diff","Date","toISOString","shouldPreserve","_isStarted","removeCallback","isStarted","_perfCollector","_coroutineScheduler","schedulerAndDispose","observable","coroutines","onSteps","onErrors","shift","CreateObservableScheduler","_coroutineSchedulerDispose","InstantiationTools","className","RegisteredExternalClasses","internalClass","arr","fn","KhronosTextureContainer","facesExpected","isInvalid","IsValid","dataSize","Uint32Array","headerDataView","littleEndian","glType","glTypeSize","glFormat","glInternalFormat","glBaseInternalFormat","pixelWidth","pixelHeight","pixelDepth","numberOfArrayElements","numberOfFaces","numberOfMipmapLevels","bytesOfKeyValueData","loadType","COMPRESSED_2D","uploadLevels","_upload2DCompressedLevels","TEX_2D","COMPRESSED_3D","TEX_3D","HEADER_LEN","imageSize","identifier","getAbsoluteUrlOrNull","applyConfig","urls","wasmUASTCToASTC","KTX2DECODER","LiteTranscoder_UASTC_ASTC","wasmUASTCToBC7","LiteTranscoder_UASTC_BC7","wasmUASTCToRGBA_UNORM","LiteTranscoder_UASTC_RGBA_UNORM","wasmUASTCToRGBA_SRGB","LiteTranscoder_UASTC_RGBA_SRGB","wasmUASTCToR8_UNORM","LiteTranscoder_UASTC_R8_UNORM","wasmUASTCToRG8_UNORM","LiteTranscoder_UASTC_RG8_UNORM","jsMSCTranscoder","MSCTranscoder","wasmMSCTranscoder","wasmZSTDDecoder","ZSTDDecoder","KhronosTextureContainer2","hardwareConcurrency","numWorkers","_WorkerPoolPromise","_DecoderModulePromise","jsDecoderModule","URLConfig","workerContent","worker","onMessage","UseFromWorkerThread","WASMMemoryManager","LoadBinariesFromCurrentThread","KTX2Decoder","DefaultNumWorkers","_Initialize","uploadAsync","compressedTexturesCaps","bptc","workerPool","onComplete","_createTexture","decodedData","DefaultDecoderOptions","isDirty","_getKTX2DecoderOptions","dataCopy","decoder","decode","transcodedFormat","isInGammaSpace","transcoderName","isUncompressedFormat","_gammaSpace","errors","mipmap","_extension","ktx2Decoder","GetDefaultNumWorkers","_isDirty","_useRGBAIfOnlyBC1BC3AvailableWhenUASTC","_ktx2DecoderOptions","useRGBAIfASTCBC7NotAvailableWhenUASTC","_useRGBAIfASTCBC7NotAvailableWhenUASTC","useRGBAIfOnlyBC1BC3AvailableWhenUASTC","forceRGBA","_forceRGBA","forceR8","_forceR8","forceRG8","_forceRG8","bypassTranscoders","_bypassTranscoders","transcodeFormatDecisionTree","UASTC","transcodeFormat","yes","engineFormat","roundToMultiple4","Logger","limit","_LogLimitOutputs","MessageLimitReached","_Levels","_LogCache","OnNewCacheEntry","padStr","date","getHours","getMinutes","getSeconds","_CheckLimit","formattedMessage","_FormatMessage","logFunc","_AddLogEntry","_GenerateLimitMessage","LogCache","errorsCount","LogLevels","_LogDisabled","Warn","MessageLogLevel","WarningLogLevel","ErrorLogLevel","l","_LogEnabled","NoneLogLevel","AllLogLevel","log","MinMaxReducer","onAfterReductionPerformed","_forceFullscreenViewport","_activated","_postProcessManager","_onContextRestoredObserver","_rebuild","_sourceTexture","_reductionSteps","reductionInitial","w","getRenderWidth","h","getRenderHeight","reduction","setInt2","minmax","_readTexturePixels","inputTexture","refreshRate","activated","_onAfterUnbindObserver","onAfterUnbindObservable","_debugPushGroup","unBindFramebuffer","_debugPopGroup","EventState","initialize","Observer","Observable","onErrorObservable","ret","_observers","onObserverAdded","_numObserversMarkedAsDeleted","_onObserverAdded","insertFirst","unregisterOnFirstCall","unshift","_remove","updateCounter","makeObserverTopPriority","makeObserverBottomPriority","notifyObserver","hasSpecificMask","PerfCounter","_min","_max","average","_average","lastSecAverage","_lastSecAverage","_current","total","_totalAccumulated","_totalValueCount","_startMonitoringTime","_lastSecAccumulated","_lastSecTime","_lastSecValueCount","fetchNewFrame","addCount","newCount","fetchResult","Enabled","_fetchResult","beginMonitoring","endMonitoring","newFrame","PerformanceMonitor","frameSampleSize","_enabled","_rollingFrameTime","RollingAverage","sampleFrame","timeMs","_lastFrameTimeMs","dt","averageFrameTime","averageFrameTimeVariance","variance","instantaneousFrameTime","history","averageFPS","instantaneousFPS","isSaturated","enable","disable","_samples","delta","bottomValue","_pos","_sampleCount","_m2","i0","_wrapPosition","PivotTools","_PivotCached","getPivotPointToRef","_OldPivotPoint","_PivotPostMultiplyPivotMatrix","_postMultiplyPivotMatrix","equalsToFloats","setPivotMatrix","getPivotPoint","_PivotTranslation","_PivotTmpVector","copyFromFloats","subtractInPlace","scaling","multiplyInPlace","addInPlace","setPivotPoint","PrecisionDate","Now","RetryStrategy","maxRetries","baseInterval","RGBDTextureTools","expandRGBDTexture","expandedTexture","createRenderTargetTexture","onLoadObservable","outputTextureType","screenshotCanvas","CreateScreenshot","forceDownload","_GetScreenshotSize","renderContext","newWidth","newHeight","offsetX","offsetY","CreateScreenshotUsingRenderTarget","getCreationOptions","onEndFrameObservable","renderingCanvas","CreateScreenshotAsync","samples","antialiasing","renderSprites","enableStencilBuffer","useLayerMask","targetTextureSize","originalSize","renderList","forceLayerMaskCheck","renderToTexture","incrementRenderId","resetCachedMaterial","getProjectionMatrix","fxaaPostProcess","addPostProcess","onCompiled","CreateScreenshotUsingRenderTargetAsync","precision","getAspectRatio","SmartArray","capacity","_id","_GlobalId","sort","compareFn","concat","contains","SmartArrayNoDuplicate","_duplicateId","__smartArrayFlags","pushNoDuplicate","concatWithNoDuplicate","StringDictionary","_count","_data","getOrAddWithFactory","factory","getOrAdd","curVal","getAndRemove","cur","first","Decode","TextDecoder","EncodeArrayBufferToBase64","keyStr","chr1","chr2","chr3","enc1","enc2","enc3","enc4","output","Number","DecodeBase64ToString","base64Data","atob","DecodeBase64ToBinary","decodedString","bufferLength","StringTools","EndsWith","str","suffix","StartsWith","PadNumber","num","Tags","_tags","hasTags","HasTags","addTags","tagsString","AddTagsTo","removeTags","RemoveTagsFrom","matchesTagsQuery","tagsQuery","MatchesQuery","asString","tagsArray","tag","_AddTagTo","EnableFor","_RemoveTagFrom","ApplyPostProcess","postProcessName","postProcess","encodedTexture","floatView","int32View","ToHalfFloat","bits","FromHalfFloat","f","Infinity","GetTGAHeader","id_length","colormap_type","image_type","colormap_index","colormap_length","colormap_size","origin","pixel_size","flags","UploadContent","pixel_data","use_rle","use_pal","use_grey","pixel_total","palettes","x_start","y_start","x_step","y_step","y_end","x_end","localOffset","TGATools","_getImageData8bits","colormap","_getImageData16bits","_getImageData24bits","_getImageData32bits","_getImageDataGrey8bits","_getImageDataGrey16bits","TimerState","setAndStartTimer","timer","observableParameters","contextObservable","payload","deltaTime","completeRate","timeout","onTick","breakCondition","onAborted","onEnded","TimingTools","setImmediate","Tools","UseFallbackTexture","classes","fallbackTexture","fround","_TmpFloatArray","path","lastIndexOf","returnUnchangedIfNoSlash","angle","previousAngle","newAngle","smoothFactor","previousAngleRad","ToRadians","newAngleRad","ToDegrees","sin","cos","allowsNullUndefined","eventPrefix","PointerEvent","referrerPolicy","processor","scriptUrl","scriptId","head","getElementsByTagName","script","setAttribute","appendChild","LoadScript","readAsDataURL","content","fileBlob","decimals","toFixed","windowElement","events","toBlob","binStr","getFullYear","getMonth","getDate","Download","newWindow","body","ToBlob","DownloadBlob","style","display","href","download","parentElement","removeChild","click","args","PerformanceLogLevel","PerformanceUserMarkLogLevel","StartPerformanceCounter","_StartUserMark","EndPerformanceCounter","_EndUserMark","PerformanceConsoleLogLevel","_StartPerformanceConsole","_EndPerformanceConsole","_StartPerformanceCounterDisabled","_EndPerformanceCounterDisabled","counterName","condition","_Performance","mark","measure","time","timeEnd","isType","el","moduleName","classObj","delay","userAgent","UseCustomRequestHeaders","CustomRequestHeaders","GetAbsoluteUrl","PerformanceNoneLogLevel","AsyncLoop","iterations","_done","_fn","_successCallback","executeNext","breakLoop","loop","syncedIterations","breakFunction","Run","ceil","iteration","_RegisteredTypes","RegisterClass","GetClass","fqdn","UniqueIdGenerator","UniqueId","_UniqueIdCounter","JoystickAxis","VirtualJoystick","puckSize","containerSize","puckImage","containerImage","alwaysVisible","limitToContainer","leftJoystick","customizations","_released","_GetDefaultOptions","_leftJoystick","_GlobalJoystickIndex","_axisTargetedByLeftAndRight","X","_axisTargetedByUpAndDown","Y","reverseLeftRight","reverseUpDown","_touches","deltaPosition","_joystickSensibility","_inversedSensibility","_onResize","_VJCanvasWidth","innerWidth","_VJCanvasHeight","innerHeight","Canvas","_HalfWidth","backgroundColor","top","zIndex","touchAction","context","_VJCanvasContext","strokeStyle","lineWidth","pressed","_joystickColor","setPosition","setPuckImage","setContainerImage","_AlwaysVisibleSticks","_joystickPointerId","_joystickPointerPos","_joystickPreviousPointerPos","_joystickPointerStartPos","_deltaJoystickVector","_onPointerDownHandlerRef","evt","_onPointerDown","_onPointerMoveHandlerRef","_onPointerMove","_onPointerUpHandlerRef","_onPointerUp","requestAnimationFrame","_drawVirtualJoystick","setJoystickSensibility","newJoystickSensibility","positionOnScreenCondition","clientX","pointerId","_joystickPosition","clientY","_action","prevX","prevY","vector","deltaJoystickX","Z","deltaJoystickY","_clearPreviousDraw","touch","clearRect","setJoystickColor","newColor","newSize","_joystickContainerSize","_clearContainerSize","_clearContainerSizeOffset","_joystickPuckSize","_clearPuckSize","_clearPuckSizeOffset","clearPosition","_alwaysVisible","setActionOnTouch","setAxisForLeftRight","axis","setAxisForUpDown","jp","urlPath","_containerImage","_puckImage","_drawContainer","beginPath","arc","stroke","closePath","_drawPuck","fillStyle","releaseCanvas","WebRequest","_xhr","_requestURL","_injectCustomRequestHeaders","_shouldSkipRequestModifications","setRequestHeader","SkipRequestModificationForBabylonCDN","includes","listener","method","update","CustomRequestModifiers","AutoReleaseWorkerPool","workers","_pendingActions","_workerInfos","workerPromise","idle","workerInfo","terminate","_executeOnIdleWorker","_execute","nextAction","maxWorkers","createWorkerAsync","DefaultOptions","_maxWorkers","_createWorkerAsync","timeoutId","idleTimeElapsedBeforeRelease","MorphTarget","influence","_influence","onInfluenceChanged","animationPropertiesOverride","_animationPropertiesOverride","_positions","_normals","_tangents","_uvs","_uniqueId","_onDataLayoutChanged","getUniqueId","uniqueId","hasPositions","hasNormals","hasTangents","hasUVs","setPositions","hadPositions","getPositions","setNormals","hadNormals","getNormals","setTangents","hadTangents","getTangents","setUVs","hadUVs","getUVs","newOne","positions","normals","tangents","uvs","parsedAnimation","Parse","autoAnimate","beginAnimation","autoAnimateFrom","autoAnimateTo","autoAnimateLoop","autoAnimateSpeed","getVerticesData","isVerticesDataPresent","MorphTargetManager","areUpdatesFrozen","_blockCounter","_syncActiveTargets","_targets","_targetInfluenceChangedObservers","_targetDataLayoutChangedObservers","_activeTargets","_supportsNormals","_supportsTangents","_supportsUVs","_vertexCount","_textureVertexStride","_textureWidth","_textureHeight","_tempInfluences","_canUseTextureForTargets","_parentContainer","optimizeInfluencers","enableNormalMorphing","enableTangentMorphing","enableUVMorphing","_useTextureToStoreTargets","engineCaps","canUseGLVertexID","maxVertexTextureImageUnits","texture2DArrayMaxLayerCount","vertexCount","supportsNormals","supportsTangents","supportsUVs","numTargets","numInfluencers","influences","_influences","useTextureToStoreTargets","isUsingTextureForTargets","EnableTextureStorage","getActiveTarget","getTarget","addTarget","needUpdate","removeTarget","_bind","setFloat3","setFloatArray","_morphTargetTextureIndices","_targetStoreTexture","targets","influenceCount","targetIndex","MaxActiveMorphTargetsInVertexAttributeMode","synchronize","maxTextureSize","mustUpdateTexture","textureSize","targetCount","vertex","_syncGeometryWithMorphTargetManager","removeMorphTargetManager","targetData","urlToScene","callbackManifestChecked","disableManifestCheck","Database","_enableSceneOffline","_enableTexturesOffline","_idbFactory","indexedDB","_currentSceneUrl","_ReturnFullUrlLocation","_db","_manifestVersionFound","_mustUpdateRessources","_hasReachedQuota","IDBStorageEnabled","_checkManifestFile","noManifestFile","createManifestURL","pathname","timeStampUsed","manifestURL","xhr","onLine","_ValidateXHRData","manifestFile","_IsUASupportingBlobStorage","retryManifestURL","_isSupported","onblocked","onsuccess","onupgradeneeded","createObjectStore","keyPath","completeURL","saveAndLoadImage","_saveImageIntoDBAsync","_loadImageFromDBAsync","notInDBCallback","transaction","onabort","oncomplete","blobTextureURL","getRequest","objectStore","generateBlobUrl","newTexture","textureUrl","addRequest","put","_checkVersionFromDB","versionLoaded","_loadVersionFromDBAsync","_saveVersionIntoDBAsync","updateInDBCallback","newVersion","sceneUrl","sceneLoaded","progressCallBack","completeUrl","saveAndLoadFile","_saveFileAsync","_loadFileAsync","targetStore","fileData","newFile","dataType","tgaHeader","ddsHeader","_ParseURL","urlWithoutHash"],"sourceRoot":""}