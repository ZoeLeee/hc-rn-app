{"version":3,"file":"js/vender~afc65bed.fcbdb86b.js","mappings":"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","sources":["webpack:///../../../node_modules/@babylonjs/core/Materials/PBR/pbrBaseSimpleMaterial.js","webpack:///../../../node_modules/@babylonjs/core/Materials/PBR/pbrMetallicRoughnessMaterial.js","webpack:///../../../node_modules/@babylonjs/core/Materials/PBR/pbrSpecularGlossinessMaterial.js","webpack:///../../../node_modules/@babylonjs/core/Materials/PBR/pbrAnisotropicConfiguration.js","webpack:///../../../node_modules/@babylonjs/core/Materials/PBR/pbrBRDFConfiguration.js","webpack:///../../../node_modules/@babylonjs/core/Materials/PBR/pbrBaseMaterial.js","webpack:///../../../node_modules/@babylonjs/core/Materials/PBR/pbrClearCoatConfiguration.js","webpack:///../../../node_modules/@babylonjs/core/Materials/PBR/pbrIridescenceConfiguration.js","webpack:///../../../node_modules/@babylonjs/core/Materials/PBR/pbrMaterial.js","webpack:///../../../node_modules/@babylonjs/core/Materials/PBR/pbrSheenConfiguration.js","webpack:///../../../node_modules/@babylonjs/core/Materials/PBR/pbrSubSurfaceConfiguration.js","webpack:///../../../node_modules/@babylonjs/core/Materials/Textures/Filtering/hdrFiltering.js","webpack:///../../../node_modules/@babylonjs/core/Materials/Textures/Loaders/ddsTextureLoader.js","webpack:///../../../node_modules/@babylonjs/core/Materials/Textures/Loaders/envTextureLoader.js","webpack:///../../../node_modules/@babylonjs/core/Materials/Textures/Loaders/ktxTextureLoader.js","webpack:///../../../node_modules/@babylonjs/core/Materials/Textures/MultiviewRenderTarget.js","webpack:///../../../node_modules/@babylonjs/core/Materials/Textures/Procedurals/proceduralTexture.js","webpack:///../../../node_modules/@babylonjs/core/Materials/Textures/Procedurals/proceduralTextureSceneComponent.js","webpack:///../../../node_modules/@babylonjs/core/Materials/Textures/baseTexture.js","webpack:///../../../node_modules/@babylonjs/core/Materials/Textures/baseTexture.polynomial.js","webpack:///../../../node_modules/@babylonjs/core/Materials/Textures/cubeTexture.js","webpack:///../../../node_modules/@babylonjs/core/Materials/Textures/dynamicTexture.js","webpack:///../../../node_modules/@babylonjs/core/Materials/Textures/equiRectangularCubeTexture.js","webpack:///../../../node_modules/@babylonjs/core/Materials/Textures/externalTexture.js","webpack:///../../../node_modules/@babylonjs/core/Materials/Textures/hdrCubeTexture.js","webpack:///../../../node_modules/@babylonjs/core/Materials/Textures/colorGradingTexture.js","webpack:///../../../node_modules/@babylonjs/core/Materials/Textures/htmlElementTexture.js","webpack:///../../../node_modules/@babylonjs/core/Materials/Textures/Loaders/tgaTextureLoader.js","webpack:///../../../node_modules/@babylonjs/core/Materials/Textures/Loaders/hdrTextureLoader.js","webpack:///../../../node_modules/@babylonjs/core/Materials/Textures/Loaders/basisTextureLoader.js","webpack:///../../../node_modules/@babylonjs/core/Materials/Textures/Packer/frame.js","webpack:///../../../node_modules/@babylonjs/core/Materials/Textures/Packer/packer.js","webpack:///../../../node_modules/@babylonjs/core/Materials/Textures/Procedurals/noiseProceduralTexture.js","webpack:///../../../node_modules/@babylonjs/core/Materials/Textures/internalTexture.js","webpack:///../../../node_modules/@babylonjs/core/Materials/Textures/ktx2decoderTypes.js","webpack:///../../../node_modules/@babylonjs/core/Materials/Textures/mirrorTexture.js","webpack:///../../../node_modules/@babylonjs/core/Materials/Textures/multiRenderTarget.js","webpack:///../../../node_modules/@babylonjs/core/Materials/Textures/prePassRenderTarget.js","webpack:///../../../node_modules/@babylonjs/core/Materials/Textures/rawCubeTexture.js","webpack:///../../../node_modules/@babylonjs/core/Materials/Textures/rawTexture.js","webpack:///../../../node_modules/@babylonjs/core/Materials/Textures/rawTexture2DArray.js","webpack:///../../../node_modules/@babylonjs/core/Materials/Textures/renderTargetTexture.js","webpack:///../../../node_modules/@babylonjs/core/Materials/Textures/textureSampler.js"],"sourcesContent":["import { __decorate } from \"../../tslib.es6.js\";\nimport { serialize, serializeAsColor3, expandToProperty, serializeAsTexture } from \"../../Misc/decorators.js\";\nimport { Color3 } from \"../../Maths/math.color.js\";\nimport { PBRBaseMaterial } from \"./pbrBaseMaterial.js\";\n/**\n * The Physically based simple base material of BJS.\n *\n * This enables better naming and convention enforcements on top of the pbrMaterial.\n * It is used as the base class for both the specGloss and metalRough conventions.\n */\nexport class PBRBaseSimpleMaterial extends PBRBaseMaterial {\n    /**\n     * Gets the current double sided mode.\n     */\n    get doubleSided() {\n        return this._twoSidedLighting;\n    }\n    /**\n     * If sets to true and backfaceCulling is false, normals will be flipped on the backside.\n     */\n    set doubleSided(value) {\n        if (this._twoSidedLighting === value) {\n            return;\n        }\n        this._twoSidedLighting = value;\n        this.backFaceCulling = !value;\n        this._markAllSubMeshesAsTexturesDirty();\n    }\n    /**\n     * Instantiates a new PBRMaterial instance.\n     *\n     * @param name The material name\n     * @param scene The scene the material will be use in.\n     */\n    constructor(name, scene) {\n        super(name, scene);\n        /**\n         * Number of Simultaneous lights allowed on the material.\n         */\n        this.maxSimultaneousLights = 4;\n        /**\n         * If sets to true, disables all the lights affecting the material.\n         */\n        this.disableLighting = false;\n        /**\n         * If sets to true, x component of normal map value will invert (x = 1.0 - x).\n         */\n        this.invertNormalMapX = false;\n        /**\n         * If sets to true, y component of normal map value will invert (y = 1.0 - y).\n         */\n        this.invertNormalMapY = false;\n        /**\n         * Emissivie color used to self-illuminate the model.\n         */\n        this.emissiveColor = new Color3(0, 0, 0);\n        /**\n         * Occlusion Channel Strength.\n         */\n        this.occlusionStrength = 1.0;\n        /**\n         * If true, the light map contains occlusion information instead of lighting info.\n         */\n        this.useLightmapAsShadowmap = false;\n        this._useAlphaFromAlbedoTexture = true;\n        this._useAmbientInGrayScale = true;\n    }\n    getClassName() {\n        return \"PBRBaseSimpleMaterial\";\n    }\n}\n__decorate([\n    serialize(),\n    expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\n], PBRBaseSimpleMaterial.prototype, \"maxSimultaneousLights\", void 0);\n__decorate([\n    serialize(),\n    expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\n], PBRBaseSimpleMaterial.prototype, \"disableLighting\", void 0);\n__decorate([\n    serializeAsTexture(),\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\", \"_reflectionTexture\")\n], PBRBaseSimpleMaterial.prototype, \"environmentTexture\", void 0);\n__decorate([\n    serialize(),\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], PBRBaseSimpleMaterial.prototype, \"invertNormalMapX\", void 0);\n__decorate([\n    serialize(),\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], PBRBaseSimpleMaterial.prototype, \"invertNormalMapY\", void 0);\n__decorate([\n    serializeAsTexture(),\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\", \"_bumpTexture\")\n], PBRBaseSimpleMaterial.prototype, \"normalTexture\", void 0);\n__decorate([\n    serializeAsColor3(\"emissive\"),\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], PBRBaseSimpleMaterial.prototype, \"emissiveColor\", void 0);\n__decorate([\n    serializeAsTexture(),\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], PBRBaseSimpleMaterial.prototype, \"emissiveTexture\", void 0);\n__decorate([\n    serialize(),\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\", \"_ambientTextureStrength\")\n], PBRBaseSimpleMaterial.prototype, \"occlusionStrength\", void 0);\n__decorate([\n    serializeAsTexture(),\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\", \"_ambientTexture\")\n], PBRBaseSimpleMaterial.prototype, \"occlusionTexture\", void 0);\n__decorate([\n    serialize(),\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\", \"_alphaCutOff\")\n], PBRBaseSimpleMaterial.prototype, \"alphaCutOff\", void 0);\n__decorate([\n    serialize()\n], PBRBaseSimpleMaterial.prototype, \"doubleSided\", null);\n__decorate([\n    serializeAsTexture(),\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\", null)\n], PBRBaseSimpleMaterial.prototype, \"lightmapTexture\", void 0);\n__decorate([\n    serialize(),\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], PBRBaseSimpleMaterial.prototype, \"useLightmapAsShadowmap\", void 0);\n//# sourceMappingURL=pbrBaseSimpleMaterial.js.map","import { __decorate } from \"../../tslib.es6.js\";\nimport { serialize, SerializationHelper, serializeAsColor3, expandToProperty, serializeAsTexture } from \"../../Misc/decorators.js\";\nimport { PBRBaseSimpleMaterial } from \"./pbrBaseSimpleMaterial.js\";\nimport { RegisterClass } from \"../../Misc/typeStore.js\";\n/**\n * The PBR material of BJS following the metal roughness convention.\n *\n * This fits to the PBR convention in the GLTF definition:\n * https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Archived/KHR_materials_pbrSpecularGlossiness/README.md\n */\nexport class PBRMetallicRoughnessMaterial extends PBRBaseSimpleMaterial {\n    /**\n     * Instantiates a new PBRMetalRoughnessMaterial instance.\n     *\n     * @param name The material name\n     * @param scene The scene the material will be use in.\n     */\n    constructor(name, scene) {\n        super(name, scene);\n        this._useRoughnessFromMetallicTextureAlpha = false;\n        this._useRoughnessFromMetallicTextureGreen = true;\n        this._useMetallnessFromMetallicTextureBlue = true;\n        this.metallic = 1.0;\n        this.roughness = 1.0;\n    }\n    /**\n     * Return the current class name of the material.\n     */\n    getClassName() {\n        return \"PBRMetallicRoughnessMaterial\";\n    }\n    /**\n     * Makes a duplicate of the current material.\n     * @param name - name to use for the new material.\n     */\n    clone(name) {\n        const clone = SerializationHelper.Clone(() => new PBRMetallicRoughnessMaterial(name, this.getScene()), this);\n        clone.id = name;\n        clone.name = name;\n        this.clearCoat.copyTo(clone.clearCoat);\n        this.anisotropy.copyTo(clone.anisotropy);\n        this.brdf.copyTo(clone.brdf);\n        this.sheen.copyTo(clone.sheen);\n        this.subSurface.copyTo(clone.subSurface);\n        return clone;\n    }\n    /**\n     * Serialize the material to a parsable JSON object.\n     */\n    serialize() {\n        const serializationObject = SerializationHelper.Serialize(this);\n        serializationObject.customType = \"BABYLON.PBRMetallicRoughnessMaterial\";\n        serializationObject.clearCoat = this.clearCoat.serialize();\n        serializationObject.anisotropy = this.anisotropy.serialize();\n        serializationObject.brdf = this.brdf.serialize();\n        serializationObject.sheen = this.sheen.serialize();\n        serializationObject.subSurface = this.subSurface.serialize();\n        serializationObject.iridescence = this.iridescence.serialize();\n        return serializationObject;\n    }\n    /**\n     * Parses a JSON object corresponding to the serialize function.\n     * @param source\n     * @param scene\n     * @param rootUrl\n     */\n    static Parse(source, scene, rootUrl) {\n        const material = SerializationHelper.Parse(() => new PBRMetallicRoughnessMaterial(source.name, scene), source, scene, rootUrl);\n        if (source.clearCoat) {\n            material.clearCoat.parse(source.clearCoat, scene, rootUrl);\n        }\n        if (source.anisotropy) {\n            material.anisotropy.parse(source.anisotropy, scene, rootUrl);\n        }\n        if (source.brdf) {\n            material.brdf.parse(source.brdf, scene, rootUrl);\n        }\n        if (source.sheen) {\n            material.sheen.parse(source.sheen, scene, rootUrl);\n        }\n        if (source.subSurface) {\n            material.subSurface.parse(source.subSurface, scene, rootUrl);\n        }\n        if (source.iridescence) {\n            material.iridescence.parse(source.iridescence, scene, rootUrl);\n        }\n        return material;\n    }\n}\n__decorate([\n    serializeAsColor3(),\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\", \"_albedoColor\")\n], PBRMetallicRoughnessMaterial.prototype, \"baseColor\", void 0);\n__decorate([\n    serializeAsTexture(),\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\", \"_albedoTexture\")\n], PBRMetallicRoughnessMaterial.prototype, \"baseTexture\", void 0);\n__decorate([\n    serialize(),\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], PBRMetallicRoughnessMaterial.prototype, \"metallic\", void 0);\n__decorate([\n    serialize(),\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], PBRMetallicRoughnessMaterial.prototype, \"roughness\", void 0);\n__decorate([\n    serializeAsTexture(),\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\", \"_metallicTexture\")\n], PBRMetallicRoughnessMaterial.prototype, \"metallicRoughnessTexture\", void 0);\nRegisterClass(\"BABYLON.PBRMetallicRoughnessMaterial\", PBRMetallicRoughnessMaterial);\n//# sourceMappingURL=pbrMetallicRoughnessMaterial.js.map","import { __decorate } from \"../../tslib.es6.js\";\nimport { serialize, SerializationHelper, serializeAsColor3, expandToProperty, serializeAsTexture } from \"../../Misc/decorators.js\";\nimport { PBRBaseSimpleMaterial } from \"./pbrBaseSimpleMaterial.js\";\nimport { RegisterClass } from \"../../Misc/typeStore.js\";\n/**\n * The PBR material of BJS following the specular glossiness convention.\n *\n * This fits to the PBR convention in the GLTF definition:\n * https://github.com/KhronosGroup/glTF/tree/2.0/extensions/Khronos/KHR_materials_pbrSpecularGlossiness\n */\nexport class PBRSpecularGlossinessMaterial extends PBRBaseSimpleMaterial {\n    /**\n     * Specifies if the reflectivity texture contains the glossiness information in its alpha channel.\n     */\n    get useMicroSurfaceFromReflectivityMapAlpha() {\n        return this._useMicroSurfaceFromReflectivityMapAlpha;\n    }\n    /**\n     * Instantiates a new PBRSpecularGlossinessMaterial instance.\n     *\n     * @param name The material name\n     * @param scene The scene the material will be use in.\n     */\n    constructor(name, scene) {\n        super(name, scene);\n        this._useMicroSurfaceFromReflectivityMapAlpha = true;\n    }\n    /**\n     * Return the current class name of the material.\n     */\n    getClassName() {\n        return \"PBRSpecularGlossinessMaterial\";\n    }\n    /**\n     * Makes a duplicate of the current material.\n     * @param name - name to use for the new material.\n     */\n    clone(name) {\n        const clone = SerializationHelper.Clone(() => new PBRSpecularGlossinessMaterial(name, this.getScene()), this);\n        clone.id = name;\n        clone.name = name;\n        this.clearCoat.copyTo(clone.clearCoat);\n        this.anisotropy.copyTo(clone.anisotropy);\n        this.brdf.copyTo(clone.brdf);\n        this.sheen.copyTo(clone.sheen);\n        this.subSurface.copyTo(clone.subSurface);\n        return clone;\n    }\n    /**\n     * Serialize the material to a parsable JSON object.\n     */\n    serialize() {\n        const serializationObject = SerializationHelper.Serialize(this);\n        serializationObject.customType = \"BABYLON.PBRSpecularGlossinessMaterial\";\n        serializationObject.clearCoat = this.clearCoat.serialize();\n        serializationObject.anisotropy = this.anisotropy.serialize();\n        serializationObject.brdf = this.brdf.serialize();\n        serializationObject.sheen = this.sheen.serialize();\n        serializationObject.subSurface = this.subSurface.serialize();\n        serializationObject.iridescence = this.iridescence.serialize();\n        return serializationObject;\n    }\n    /**\n     * Parses a JSON object corresponding to the serialize function.\n     * @param source\n     * @param scene\n     * @param rootUrl\n     */\n    static Parse(source, scene, rootUrl) {\n        const material = SerializationHelper.Parse(() => new PBRSpecularGlossinessMaterial(source.name, scene), source, scene, rootUrl);\n        if (source.clearCoat) {\n            material.clearCoat.parse(source.clearCoat, scene, rootUrl);\n        }\n        if (source.anisotropy) {\n            material.anisotropy.parse(source.anisotropy, scene, rootUrl);\n        }\n        if (source.brdf) {\n            material.brdf.parse(source.brdf, scene, rootUrl);\n        }\n        if (source.sheen) {\n            material.sheen.parse(source.sheen, scene, rootUrl);\n        }\n        if (source.subSurface) {\n            material.subSurface.parse(source.subSurface, scene, rootUrl);\n        }\n        if (source.iridescence) {\n            material.iridescence.parse(source.iridescence, scene, rootUrl);\n        }\n        return material;\n    }\n}\n__decorate([\n    serializeAsColor3(\"diffuse\"),\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\", \"_albedoColor\")\n], PBRSpecularGlossinessMaterial.prototype, \"diffuseColor\", void 0);\n__decorate([\n    serializeAsTexture(),\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\", \"_albedoTexture\")\n], PBRSpecularGlossinessMaterial.prototype, \"diffuseTexture\", void 0);\n__decorate([\n    serializeAsColor3(\"specular\"),\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\", \"_reflectivityColor\")\n], PBRSpecularGlossinessMaterial.prototype, \"specularColor\", void 0);\n__decorate([\n    serialize(),\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\", \"_microSurface\")\n], PBRSpecularGlossinessMaterial.prototype, \"glossiness\", void 0);\n__decorate([\n    serializeAsTexture(),\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\", \"_reflectivityTexture\")\n], PBRSpecularGlossinessMaterial.prototype, \"specularGlossinessTexture\", void 0);\nRegisterClass(\"BABYLON.PBRSpecularGlossinessMaterial\", PBRSpecularGlossinessMaterial);\n//# sourceMappingURL=pbrSpecularGlossinessMaterial.js.map","import { __decorate } from \"../../tslib.es6.js\";\n/* eslint-disable @typescript-eslint/naming-convention */\nimport { serialize, expandToProperty, serializeAsVector2, serializeAsTexture } from \"../../Misc/decorators.js\";\nimport { VertexBuffer } from \"../../Buffers/buffer.js\";\nimport { Vector2 } from \"../../Maths/math.vector.js\";\nimport { MaterialFlags } from \"../../Materials/materialFlags.js\";\nimport { MaterialHelper } from \"../../Materials/materialHelper.js\";\nimport { MaterialPluginBase } from \"../materialPluginBase.js\";\n\nimport { MaterialDefines } from \"../materialDefines.js\";\n/**\n * @internal\n */\nexport class MaterialAnisotropicDefines extends MaterialDefines {\n    constructor() {\n        super(...arguments);\n        this.ANISOTROPIC = false;\n        this.ANISOTROPIC_TEXTURE = false;\n        this.ANISOTROPIC_TEXTUREDIRECTUV = 0;\n        this.MAINUV1 = false;\n    }\n}\n/**\n * Plugin that implements the anisotropic component of the PBR material\n */\nexport class PBRAnisotropicConfiguration extends MaterialPluginBase {\n    /** @internal */\n    _markAllSubMeshesAsTexturesDirty() {\n        this._enable(this._isEnabled);\n        this._internalMarkAllSubMeshesAsTexturesDirty();\n    }\n    constructor(material, addToPluginList = true) {\n        super(material, \"PBRAnisotropic\", 110, new MaterialAnisotropicDefines(), addToPluginList);\n        this._isEnabled = false;\n        /**\n         * Defines if the anisotropy is enabled in the material.\n         */\n        this.isEnabled = false;\n        /**\n         * Defines the anisotropy strength (between 0 and 1) it defaults to 1.\n         */\n        this.intensity = 1;\n        /**\n         * Defines if the effect is along the tangents, bitangents or in between.\n         * By default, the effect is \"stretching\" the highlights along the tangents.\n         */\n        this.direction = new Vector2(1, 0);\n        this._texture = null;\n        /**\n         * Stores the anisotropy values in a texture.\n         * rg is direction (like normal from -1 to 1)\n         * b is a intensity\n         */\n        this.texture = null;\n        this._internalMarkAllSubMeshesAsTexturesDirty = material._dirtyCallbacks[1];\n    }\n    isReadyForSubMesh(defines, scene) {\n        if (!this._isEnabled) {\n            return true;\n        }\n        if (defines._areTexturesDirty) {\n            if (scene.texturesEnabled) {\n                if (this._texture && MaterialFlags.AnisotropicTextureEnabled) {\n                    if (!this._texture.isReadyOrNotBlocking()) {\n                        return false;\n                    }\n                }\n            }\n        }\n        return true;\n    }\n    prepareDefinesBeforeAttributes(defines, scene, mesh) {\n        if (this._isEnabled) {\n            defines.ANISOTROPIC = this._isEnabled;\n            if (this._isEnabled && !mesh.isVerticesDataPresent(VertexBuffer.TangentKind)) {\n                defines._needUVs = true;\n                defines.MAINUV1 = true;\n            }\n            if (defines._areTexturesDirty) {\n                if (scene.texturesEnabled) {\n                    if (this._texture && MaterialFlags.AnisotropicTextureEnabled) {\n                        MaterialHelper.PrepareDefinesForMergedUV(this._texture, defines, \"ANISOTROPIC_TEXTURE\");\n                    }\n                    else {\n                        defines.ANISOTROPIC_TEXTURE = false;\n                    }\n                }\n            }\n        }\n        else {\n            defines.ANISOTROPIC = false;\n            defines.ANISOTROPIC_TEXTURE = false;\n            defines.ANISOTROPIC_TEXTUREDIRECTUV = 0;\n            defines.MAINUV1 = false;\n        }\n    }\n    bindForSubMesh(uniformBuffer, scene) {\n        if (!this._isEnabled) {\n            return;\n        }\n        const isFrozen = this._material.isFrozen;\n        if (!uniformBuffer.useUbo || !isFrozen || !uniformBuffer.isSync) {\n            if (this._texture && MaterialFlags.AnisotropicTextureEnabled) {\n                uniformBuffer.updateFloat2(\"vAnisotropyInfos\", this._texture.coordinatesIndex, this._texture.level);\n                MaterialHelper.BindTextureMatrix(this._texture, uniformBuffer, \"anisotropy\");\n            }\n            // Anisotropy\n            uniformBuffer.updateFloat3(\"vAnisotropy\", this.direction.x, this.direction.y, this.intensity);\n        }\n        // Textures\n        if (scene.texturesEnabled) {\n            if (this._texture && MaterialFlags.AnisotropicTextureEnabled) {\n                uniformBuffer.setTexture(\"anisotropySampler\", this._texture);\n            }\n        }\n    }\n    hasTexture(texture) {\n        if (this._texture === texture) {\n            return true;\n        }\n        return false;\n    }\n    getActiveTextures(activeTextures) {\n        if (this._texture) {\n            activeTextures.push(this._texture);\n        }\n    }\n    getAnimatables(animatables) {\n        if (this._texture && this._texture.animations && this._texture.animations.length > 0) {\n            animatables.push(this._texture);\n        }\n    }\n    dispose(forceDisposeTextures) {\n        if (forceDisposeTextures) {\n            if (this._texture) {\n                this._texture.dispose();\n            }\n        }\n    }\n    getClassName() {\n        return \"PBRAnisotropicConfiguration\";\n    }\n    addFallbacks(defines, fallbacks, currentRank) {\n        if (defines.ANISOTROPIC) {\n            fallbacks.addFallback(currentRank++, \"ANISOTROPIC\");\n        }\n        return currentRank;\n    }\n    getSamplers(samplers) {\n        samplers.push(\"anisotropySampler\");\n    }\n    getUniforms() {\n        return {\n            ubo: [\n                { name: \"vAnisotropy\", size: 3, type: \"vec3\" },\n                { name: \"vAnisotropyInfos\", size: 2, type: \"vec2\" },\n                { name: \"anisotropyMatrix\", size: 16, type: \"mat4\" },\n            ],\n        };\n    }\n}\n__decorate([\n    serialize(),\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], PBRAnisotropicConfiguration.prototype, \"isEnabled\", void 0);\n__decorate([\n    serialize()\n], PBRAnisotropicConfiguration.prototype, \"intensity\", void 0);\n__decorate([\n    serializeAsVector2()\n], PBRAnisotropicConfiguration.prototype, \"direction\", void 0);\n__decorate([\n    serializeAsTexture(),\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], PBRAnisotropicConfiguration.prototype, \"texture\", void 0);\n//# sourceMappingURL=pbrAnisotropicConfiguration.js.map","import { __decorate } from \"../../tslib.es6.js\";\n/* eslint-disable @typescript-eslint/naming-convention */\n\nimport { serialize, expandToProperty } from \"../../Misc/decorators.js\";\nimport { MaterialDefines } from \"../materialDefines.js\";\nimport { MaterialPluginBase } from \"../materialPluginBase.js\";\n/**\n * @internal\n */\nexport class MaterialBRDFDefines extends MaterialDefines {\n    constructor() {\n        super(...arguments);\n        this.BRDF_V_HEIGHT_CORRELATED = false;\n        this.MS_BRDF_ENERGY_CONSERVATION = false;\n        this.SPHERICAL_HARMONICS = false;\n        this.SPECULAR_GLOSSINESS_ENERGY_CONSERVATION = false;\n    }\n}\n/**\n * Plugin that implements the BRDF component of the PBR material\n */\nexport class PBRBRDFConfiguration extends MaterialPluginBase {\n    /** @internal */\n    _markAllSubMeshesAsMiscDirty() {\n        this._internalMarkAllSubMeshesAsMiscDirty();\n    }\n    constructor(material, addToPluginList = true) {\n        super(material, \"PBRBRDF\", 90, new MaterialBRDFDefines(), addToPluginList);\n        this._useEnergyConservation = PBRBRDFConfiguration.DEFAULT_USE_ENERGY_CONSERVATION;\n        /**\n         * Defines if the material uses energy conservation.\n         */\n        this.useEnergyConservation = PBRBRDFConfiguration.DEFAULT_USE_ENERGY_CONSERVATION;\n        this._useSmithVisibilityHeightCorrelated = PBRBRDFConfiguration.DEFAULT_USE_SMITH_VISIBILITY_HEIGHT_CORRELATED;\n        /**\n         * LEGACY Mode set to false\n         * Defines if the material uses height smith correlated visibility term.\n         * If you intent to not use our default BRDF, you need to load a separate BRDF Texture for the PBR\n         * You can either load https://assets.babylonjs.com/environments/uncorrelatedBRDF.png\n         * or https://assets.babylonjs.com/environments/uncorrelatedBRDF.dds to have more precision\n         * Not relying on height correlated will also disable energy conservation.\n         */\n        this.useSmithVisibilityHeightCorrelated = PBRBRDFConfiguration.DEFAULT_USE_SMITH_VISIBILITY_HEIGHT_CORRELATED;\n        this._useSphericalHarmonics = PBRBRDFConfiguration.DEFAULT_USE_SPHERICAL_HARMONICS;\n        /**\n         * LEGACY Mode set to false\n         * Defines if the material uses spherical harmonics vs spherical polynomials for the\n         * diffuse part of the IBL.\n         * The harmonics despite a tiny bigger cost has been proven to provide closer results\n         * to the ground truth.\n         */\n        this.useSphericalHarmonics = PBRBRDFConfiguration.DEFAULT_USE_SPHERICAL_HARMONICS;\n        this._useSpecularGlossinessInputEnergyConservation = PBRBRDFConfiguration.DEFAULT_USE_SPECULAR_GLOSSINESS_INPUT_ENERGY_CONSERVATION;\n        /**\n         * Defines if the material uses energy conservation, when the specular workflow is active.\n         * If activated, the albedo color is multiplied with (1. - maxChannel(specular color)).\n         * If deactivated, a material is only physically plausible, when (albedo color + specular color) < 1.\n         * In the deactivated case, the material author has to ensure energy conservation, for a physically plausible rendering.\n         */\n        this.useSpecularGlossinessInputEnergyConservation = PBRBRDFConfiguration.DEFAULT_USE_SPECULAR_GLOSSINESS_INPUT_ENERGY_CONSERVATION;\n        this._internalMarkAllSubMeshesAsMiscDirty = material._dirtyCallbacks[16];\n        this._enable(true);\n    }\n    prepareDefines(defines) {\n        defines.BRDF_V_HEIGHT_CORRELATED = this._useSmithVisibilityHeightCorrelated;\n        defines.MS_BRDF_ENERGY_CONSERVATION = this._useEnergyConservation && this._useSmithVisibilityHeightCorrelated;\n        defines.SPHERICAL_HARMONICS = this._useSphericalHarmonics;\n        defines.SPECULAR_GLOSSINESS_ENERGY_CONSERVATION = this._useSpecularGlossinessInputEnergyConservation;\n    }\n    getClassName() {\n        return \"PBRBRDFConfiguration\";\n    }\n}\n/**\n * Default value used for the energy conservation.\n * This should only be changed to adapt to the type of texture in scene.environmentBRDFTexture.\n */\nPBRBRDFConfiguration.DEFAULT_USE_ENERGY_CONSERVATION = true;\n/**\n * Default value used for the Smith Visibility Height Correlated mode.\n * This should only be changed to adapt to the type of texture in scene.environmentBRDFTexture.\n */\nPBRBRDFConfiguration.DEFAULT_USE_SMITH_VISIBILITY_HEIGHT_CORRELATED = true;\n/**\n * Default value used for the IBL diffuse part.\n * This can help switching back to the polynomials mode globally which is a tiny bit\n * less GPU intensive at the drawback of a lower quality.\n */\nPBRBRDFConfiguration.DEFAULT_USE_SPHERICAL_HARMONICS = true;\n/**\n * Default value used for activating energy conservation for the specular workflow.\n * If activated, the albedo color is multiplied with (1. - maxChannel(specular color)).\n * If deactivated, a material is only physically plausible, when (albedo color + specular color) < 1.\n */\nPBRBRDFConfiguration.DEFAULT_USE_SPECULAR_GLOSSINESS_INPUT_ENERGY_CONSERVATION = true;\n__decorate([\n    serialize(),\n    expandToProperty(\"_markAllSubMeshesAsMiscDirty\")\n], PBRBRDFConfiguration.prototype, \"useEnergyConservation\", void 0);\n__decorate([\n    serialize(),\n    expandToProperty(\"_markAllSubMeshesAsMiscDirty\")\n], PBRBRDFConfiguration.prototype, \"useSmithVisibilityHeightCorrelated\", void 0);\n__decorate([\n    serialize(),\n    expandToProperty(\"_markAllSubMeshesAsMiscDirty\")\n], PBRBRDFConfiguration.prototype, \"useSphericalHarmonics\", void 0);\n__decorate([\n    serialize(),\n    expandToProperty(\"_markAllSubMeshesAsMiscDirty\")\n], PBRBRDFConfiguration.prototype, \"useSpecularGlossinessInputEnergyConservation\", void 0);\n//# sourceMappingURL=pbrBRDFConfiguration.js.map","import { __decorate } from \"../../tslib.es6.js\";\n/* eslint-disable @typescript-eslint/naming-convention */\nimport { serialize, serializeAsImageProcessingConfiguration, expandToProperty } from \"../../Misc/decorators.js\";\nimport { Logger } from \"../../Misc/logger.js\";\nimport { SmartArray } from \"../../Misc/smartArray.js\";\nimport { GetEnvironmentBRDFTexture } from \"../../Misc/brdfTextureTools.js\";\nimport { Scene, ScenePerformancePriority } from \"../../scene.js\";\nimport { Vector4 } from \"../../Maths/math.vector.js\";\nimport { VertexBuffer } from \"../../Buffers/buffer.js\";\nimport { PBRBRDFConfiguration } from \"./pbrBRDFConfiguration.js\";\nimport { PrePassConfiguration } from \"../prePassConfiguration.js\";\nimport { Color3, TmpColors } from \"../../Maths/math.color.js\";\nimport { Scalar } from \"../../Maths/math.scalar.js\";\nimport { ImageProcessingConfiguration } from \"../../Materials/imageProcessingConfiguration.js\";\nimport { Material } from \"../../Materials/material.js\";\nimport { MaterialPluginEvent } from \"../materialPluginEvent.js\";\nimport { MaterialDefines } from \"../../Materials/materialDefines.js\";\nimport { PushMaterial } from \"../../Materials/pushMaterial.js\";\nimport { MaterialHelper } from \"../../Materials/materialHelper.js\";\nimport { Texture } from \"../../Materials/Textures/texture.js\";\nimport { MaterialFlags } from \"../materialFlags.js\";\n\nimport \"../../Materials/Textures/baseTexture.polynomial.js\";\nimport \"../../Shaders/pbr.fragment.js\";\nimport \"../../Shaders/pbr.vertex.js\";\nimport { EffectFallbacks } from \"../effectFallbacks.js\";\nimport { PBRClearCoatConfiguration } from \"./pbrClearCoatConfiguration.js\";\nimport { PBRIridescenceConfiguration } from \"./pbrIridescenceConfiguration.js\";\nimport { PBRAnisotropicConfiguration } from \"./pbrAnisotropicConfiguration.js\";\nimport { PBRSheenConfiguration } from \"./pbrSheenConfiguration.js\";\nimport { PBRSubSurfaceConfiguration } from \"./pbrSubSurfaceConfiguration.js\";\nimport { DetailMapConfiguration } from \"../material.detailMapConfiguration.js\";\nimport { addClipPlaneUniforms, bindClipPlane } from \"../clipPlaneMaterialHelper.js\";\nconst onCreatedEffectParameters = { effect: null, subMesh: null };\n/**\n * Manages the defines for the PBR Material.\n * @internal\n */\nexport class PBRMaterialDefines extends MaterialDefines {\n    /**\n     * Initializes the PBR Material defines.\n     * @param externalProperties The external properties\n     */\n    constructor(externalProperties) {\n        super(externalProperties);\n        this.PBR = true;\n        this.NUM_SAMPLES = \"0\";\n        this.REALTIME_FILTERING = false;\n        this.MAINUV1 = false;\n        this.MAINUV2 = false;\n        this.MAINUV3 = false;\n        this.MAINUV4 = false;\n        this.MAINUV5 = false;\n        this.MAINUV6 = false;\n        this.UV1 = false;\n        this.UV2 = false;\n        this.UV3 = false;\n        this.UV4 = false;\n        this.UV5 = false;\n        this.UV6 = false;\n        this.ALBEDO = false;\n        this.GAMMAALBEDO = false;\n        this.ALBEDODIRECTUV = 0;\n        this.VERTEXCOLOR = false;\n        this.BAKED_VERTEX_ANIMATION_TEXTURE = false;\n        this.AMBIENT = false;\n        this.AMBIENTDIRECTUV = 0;\n        this.AMBIENTINGRAYSCALE = false;\n        this.OPACITY = false;\n        this.VERTEXALPHA = false;\n        this.OPACITYDIRECTUV = 0;\n        this.OPACITYRGB = false;\n        this.ALPHATEST = false;\n        this.DEPTHPREPASS = false;\n        this.ALPHABLEND = false;\n        this.ALPHAFROMALBEDO = false;\n        this.ALPHATESTVALUE = \"0.5\";\n        this.SPECULAROVERALPHA = false;\n        this.RADIANCEOVERALPHA = false;\n        this.ALPHAFRESNEL = false;\n        this.LINEARALPHAFRESNEL = false;\n        this.PREMULTIPLYALPHA = false;\n        this.EMISSIVE = false;\n        this.EMISSIVEDIRECTUV = 0;\n        this.GAMMAEMISSIVE = false;\n        this.REFLECTIVITY = false;\n        this.REFLECTIVITY_GAMMA = false;\n        this.REFLECTIVITYDIRECTUV = 0;\n        this.SPECULARTERM = false;\n        this.MICROSURFACEFROMREFLECTIVITYMAP = false;\n        this.MICROSURFACEAUTOMATIC = false;\n        this.LODBASEDMICROSFURACE = false;\n        this.MICROSURFACEMAP = false;\n        this.MICROSURFACEMAPDIRECTUV = 0;\n        this.METALLICWORKFLOW = false;\n        this.ROUGHNESSSTOREINMETALMAPALPHA = false;\n        this.ROUGHNESSSTOREINMETALMAPGREEN = false;\n        this.METALLNESSSTOREINMETALMAPBLUE = false;\n        this.AOSTOREINMETALMAPRED = false;\n        this.METALLIC_REFLECTANCE = false;\n        this.METALLIC_REFLECTANCE_GAMMA = false;\n        this.METALLIC_REFLECTANCEDIRECTUV = 0;\n        this.METALLIC_REFLECTANCE_USE_ALPHA_ONLY = false;\n        this.REFLECTANCE = false;\n        this.REFLECTANCE_GAMMA = false;\n        this.REFLECTANCEDIRECTUV = 0;\n        this.ENVIRONMENTBRDF = false;\n        this.ENVIRONMENTBRDF_RGBD = false;\n        this.NORMAL = false;\n        this.TANGENT = false;\n        this.BUMP = false;\n        this.BUMPDIRECTUV = 0;\n        this.OBJECTSPACE_NORMALMAP = false;\n        this.PARALLAX = false;\n        this.PARALLAXOCCLUSION = false;\n        this.NORMALXYSCALE = true;\n        this.LIGHTMAP = false;\n        this.LIGHTMAPDIRECTUV = 0;\n        this.USELIGHTMAPASSHADOWMAP = false;\n        this.GAMMALIGHTMAP = false;\n        this.RGBDLIGHTMAP = false;\n        this.REFLECTION = false;\n        this.REFLECTIONMAP_3D = false;\n        this.REFLECTIONMAP_SPHERICAL = false;\n        this.REFLECTIONMAP_PLANAR = false;\n        this.REFLECTIONMAP_CUBIC = false;\n        this.USE_LOCAL_REFLECTIONMAP_CUBIC = false;\n        this.REFLECTIONMAP_PROJECTION = false;\n        this.REFLECTIONMAP_SKYBOX = false;\n        this.REFLECTIONMAP_EXPLICIT = false;\n        this.REFLECTIONMAP_EQUIRECTANGULAR = false;\n        this.REFLECTIONMAP_EQUIRECTANGULAR_FIXED = false;\n        this.REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED = false;\n        this.INVERTCUBICMAP = false;\n        this.USESPHERICALFROMREFLECTIONMAP = false;\n        this.USEIRRADIANCEMAP = false;\n        this.USESPHERICALINVERTEX = false;\n        this.REFLECTIONMAP_OPPOSITEZ = false;\n        this.LODINREFLECTIONALPHA = false;\n        this.GAMMAREFLECTION = false;\n        this.RGBDREFLECTION = false;\n        this.LINEARSPECULARREFLECTION = false;\n        this.RADIANCEOCCLUSION = false;\n        this.HORIZONOCCLUSION = false;\n        this.INSTANCES = false;\n        this.THIN_INSTANCES = false;\n        this.INSTANCESCOLOR = false;\n        this.PREPASS = false;\n        this.PREPASS_IRRADIANCE = false;\n        this.PREPASS_IRRADIANCE_INDEX = -1;\n        this.PREPASS_ALBEDO_SQRT = false;\n        this.PREPASS_ALBEDO_SQRT_INDEX = -1;\n        this.PREPASS_DEPTH = false;\n        this.PREPASS_DEPTH_INDEX = -1;\n        this.PREPASS_NORMAL = false;\n        this.PREPASS_NORMAL_INDEX = -1;\n        this.PREPASS_POSITION = false;\n        this.PREPASS_POSITION_INDEX = -1;\n        this.PREPASS_VELOCITY = false;\n        this.PREPASS_VELOCITY_INDEX = -1;\n        this.PREPASS_REFLECTIVITY = false;\n        this.PREPASS_REFLECTIVITY_INDEX = -1;\n        this.SCENE_MRT_COUNT = 0;\n        this.NUM_BONE_INFLUENCERS = 0;\n        this.BonesPerMesh = 0;\n        this.BONETEXTURE = false;\n        this.BONES_VELOCITY_ENABLED = false;\n        this.NONUNIFORMSCALING = false;\n        this.MORPHTARGETS = false;\n        this.MORPHTARGETS_NORMAL = false;\n        this.MORPHTARGETS_TANGENT = false;\n        this.MORPHTARGETS_UV = false;\n        this.NUM_MORPH_INFLUENCERS = 0;\n        this.MORPHTARGETS_TEXTURE = false;\n        this.IMAGEPROCESSING = false;\n        this.VIGNETTE = false;\n        this.VIGNETTEBLENDMODEMULTIPLY = false;\n        this.VIGNETTEBLENDMODEOPAQUE = false;\n        this.TONEMAPPING = false;\n        this.TONEMAPPING_ACES = false;\n        this.CONTRAST = false;\n        this.COLORCURVES = false;\n        this.COLORGRADING = false;\n        this.COLORGRADING3D = false;\n        this.SAMPLER3DGREENDEPTH = false;\n        this.SAMPLER3DBGRMAP = false;\n        this.DITHER = false;\n        this.IMAGEPROCESSINGPOSTPROCESS = false;\n        this.SKIPFINALCOLORCLAMP = false;\n        this.EXPOSURE = false;\n        this.MULTIVIEW = false;\n        this.ORDER_INDEPENDENT_TRANSPARENCY = false;\n        this.ORDER_INDEPENDENT_TRANSPARENCY_16BITS = false;\n        this.USEPHYSICALLIGHTFALLOFF = false;\n        this.USEGLTFLIGHTFALLOFF = false;\n        this.TWOSIDEDLIGHTING = false;\n        this.SHADOWFLOAT = false;\n        this.CLIPPLANE = false;\n        this.CLIPPLANE2 = false;\n        this.CLIPPLANE3 = false;\n        this.CLIPPLANE4 = false;\n        this.CLIPPLANE5 = false;\n        this.CLIPPLANE6 = false;\n        this.POINTSIZE = false;\n        this.FOG = false;\n        this.LOGARITHMICDEPTH = false;\n        this.CAMERA_ORTHOGRAPHIC = false;\n        this.CAMERA_PERSPECTIVE = false;\n        this.FORCENORMALFORWARD = false;\n        this.SPECULARAA = false;\n        this.UNLIT = false;\n        this.DEBUGMODE = 0;\n        this.rebuild();\n    }\n    /**\n     * Resets the PBR Material defines.\n     */\n    reset() {\n        super.reset();\n        this.ALPHATESTVALUE = \"0.5\";\n        this.PBR = true;\n        this.NORMALXYSCALE = true;\n    }\n}\n/**\n * The Physically based material base class of BJS.\n *\n * This offers the main features of a standard PBR material.\n * For more information, please refer to the documentation :\n * https://doc.babylonjs.com/features/featuresDeepDive/materials/using/introToPBR\n */\nexport class PBRBaseMaterial extends PushMaterial {\n    /**\n     * Enables realtime filtering on the texture.\n     */\n    get realTimeFiltering() {\n        return this._realTimeFiltering;\n    }\n    set realTimeFiltering(b) {\n        this._realTimeFiltering = b;\n        this.markAsDirty(1);\n    }\n    /**\n     * Quality switch for realtime filtering\n     */\n    get realTimeFilteringQuality() {\n        return this._realTimeFilteringQuality;\n    }\n    set realTimeFilteringQuality(n) {\n        this._realTimeFilteringQuality = n;\n        this.markAsDirty(1);\n    }\n    /**\n     * Can this material render to several textures at once\n     */\n    get canRenderToMRT() {\n        return true;\n    }\n    /**\n     * Attaches a new image processing configuration to the PBR Material.\n     * @param configuration\n     */\n    _attachImageProcessingConfiguration(configuration) {\n        if (configuration === this._imageProcessingConfiguration) {\n            return;\n        }\n        // Detaches observer.\n        if (this._imageProcessingConfiguration && this._imageProcessingObserver) {\n            this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);\n        }\n        // Pick the scene configuration if needed.\n        if (!configuration) {\n            this._imageProcessingConfiguration = this.getScene().imageProcessingConfiguration;\n        }\n        else {\n            this._imageProcessingConfiguration = configuration;\n        }\n        // Attaches observer.\n        if (this._imageProcessingConfiguration) {\n            this._imageProcessingObserver = this._imageProcessingConfiguration.onUpdateParameters.add(() => {\n                this._markAllSubMeshesAsImageProcessingDirty();\n            });\n        }\n    }\n    /**\n     * Instantiates a new PBRMaterial instance.\n     *\n     * @param name The material name\n     * @param scene The scene the material will be use in.\n     */\n    constructor(name, scene) {\n        super(name, scene);\n        /**\n         * Intensity of the direct lights e.g. the four lights available in your scene.\n         * This impacts both the direct diffuse and specular highlights.\n         * @internal\n         */\n        this._directIntensity = 1.0;\n        /**\n         * Intensity of the emissive part of the material.\n         * This helps controlling the emissive effect without modifying the emissive color.\n         * @internal\n         */\n        this._emissiveIntensity = 1.0;\n        /**\n         * Intensity of the environment e.g. how much the environment will light the object\n         * either through harmonics for rough material or through the reflection for shiny ones.\n         * @internal\n         */\n        this._environmentIntensity = 1.0;\n        /**\n         * This is a special control allowing the reduction of the specular highlights coming from the\n         * four lights of the scene. Those highlights may not be needed in full environment lighting.\n         * @internal\n         */\n        this._specularIntensity = 1.0;\n        /**\n         * This stores the direct, emissive, environment, and specular light intensities into a Vector4.\n         */\n        this._lightingInfos = new Vector4(this._directIntensity, this._emissiveIntensity, this._environmentIntensity, this._specularIntensity);\n        /**\n         * Debug Control allowing disabling the bump map on this material.\n         * @internal\n         */\n        this._disableBumpMap = false;\n        /**\n         * AKA Diffuse Texture in standard nomenclature.\n         * @internal\n         */\n        this._albedoTexture = null;\n        /**\n         * AKA Occlusion Texture in other nomenclature.\n         * @internal\n         */\n        this._ambientTexture = null;\n        /**\n         * AKA Occlusion Texture Intensity in other nomenclature.\n         * @internal\n         */\n        this._ambientTextureStrength = 1.0;\n        /**\n         * Defines how much the AO map is occluding the analytical lights (point spot...).\n         * 1 means it completely occludes it\n         * 0 mean it has no impact\n         * @internal\n         */\n        this._ambientTextureImpactOnAnalyticalLights = PBRBaseMaterial.DEFAULT_AO_ON_ANALYTICAL_LIGHTS;\n        /**\n         * Stores the alpha values in a texture.\n         * @internal\n         */\n        this._opacityTexture = null;\n        /**\n         * Stores the reflection values in a texture.\n         * @internal\n         */\n        this._reflectionTexture = null;\n        /**\n         * Stores the emissive values in a texture.\n         * @internal\n         */\n        this._emissiveTexture = null;\n        /**\n         * AKA Specular texture in other nomenclature.\n         * @internal\n         */\n        this._reflectivityTexture = null;\n        /**\n         * Used to switch from specular/glossiness to metallic/roughness workflow.\n         * @internal\n         */\n        this._metallicTexture = null;\n        /**\n         * Specifies the metallic scalar of the metallic/roughness workflow.\n         * Can also be used to scale the metalness values of the metallic texture.\n         * @internal\n         */\n        this._metallic = null;\n        /**\n         * Specifies the roughness scalar of the metallic/roughness workflow.\n         * Can also be used to scale the roughness values of the metallic texture.\n         * @internal\n         */\n        this._roughness = null;\n        /**\n         * In metallic workflow, specifies an F0 factor to help configuring the material F0.\n         * By default the indexOfrefraction is used to compute F0;\n         *\n         * This is used as a factor against the default reflectance at normal incidence to tweak it.\n         *\n         * F0 = defaultF0 * metallicF0Factor * metallicReflectanceColor;\n         * F90 = metallicReflectanceColor;\n         * @internal\n         */\n        this._metallicF0Factor = 1;\n        /**\n         * In metallic workflow, specifies an F90 color to help configuring the material F90.\n         * By default the F90 is always 1;\n         *\n         * Please note that this factor is also used as a factor against the default reflectance at normal incidence.\n         *\n         * F0 = defaultF0 * metallicF0Factor * metallicReflectanceColor\n         * F90 = metallicReflectanceColor;\n         * @internal\n         */\n        this._metallicReflectanceColor = Color3.White();\n        /**\n         * Specifies that only the A channel from _metallicReflectanceTexture should be used.\n         * If false, both RGB and A channels will be used\n         * @internal\n         */\n        this._useOnlyMetallicFromMetallicReflectanceTexture = false;\n        /**\n         * Defines to store metallicReflectanceColor in RGB and metallicF0Factor in A\n         * This is multiply against the scalar values defined in the material.\n         * @internal\n         */\n        this._metallicReflectanceTexture = null;\n        /**\n         * Defines to store reflectanceColor in RGB\n         * This is multiplied against the scalar values defined in the material.\n         * If both _reflectanceTexture and _metallicReflectanceTexture textures are provided and _useOnlyMetallicFromMetallicReflectanceTexture\n         * is false, _metallicReflectanceTexture takes precedence and _reflectanceTexture is not used\n         * @internal\n         */\n        this._reflectanceTexture = null;\n        /**\n         * Used to enable roughness/glossiness fetch from a separate channel depending on the current mode.\n         * Gray Scale represents roughness in metallic mode and glossiness in specular mode.\n         * @internal\n         */\n        this._microSurfaceTexture = null;\n        /**\n         * Stores surface normal data used to displace a mesh in a texture.\n         * @internal\n         */\n        this._bumpTexture = null;\n        /**\n         * Stores the pre-calculated light information of a mesh in a texture.\n         * @internal\n         */\n        this._lightmapTexture = null;\n        /**\n         * The color of a material in ambient lighting.\n         * @internal\n         */\n        this._ambientColor = new Color3(0, 0, 0);\n        /**\n         * AKA Diffuse Color in other nomenclature.\n         * @internal\n         */\n        this._albedoColor = new Color3(1, 1, 1);\n        /**\n         * AKA Specular Color in other nomenclature.\n         * @internal\n         */\n        this._reflectivityColor = new Color3(1, 1, 1);\n        /**\n         * The color applied when light is reflected from a material.\n         * @internal\n         */\n        this._reflectionColor = new Color3(1, 1, 1);\n        /**\n         * The color applied when light is emitted from a material.\n         * @internal\n         */\n        this._emissiveColor = new Color3(0, 0, 0);\n        /**\n         * AKA Glossiness in other nomenclature.\n         * @internal\n         */\n        this._microSurface = 0.9;\n        /**\n         * Specifies that the material will use the light map as a show map.\n         * @internal\n         */\n        this._useLightmapAsShadowmap = false;\n        /**\n         * This parameters will enable/disable Horizon occlusion to prevent normal maps to look shiny when the normal\n         * makes the reflect vector face the model (under horizon).\n         * @internal\n         */\n        this._useHorizonOcclusion = true;\n        /**\n         * This parameters will enable/disable radiance occlusion by preventing the radiance to lit\n         * too much the area relying on ambient texture to define their ambient occlusion.\n         * @internal\n         */\n        this._useRadianceOcclusion = true;\n        /**\n         * Specifies that the alpha is coming form the albedo channel alpha channel for alpha blending.\n         * @internal\n         */\n        this._useAlphaFromAlbedoTexture = false;\n        /**\n         * Specifies that the material will keeps the specular highlights over a transparent surface (only the most luminous ones).\n         * A car glass is a good example of that. When sun reflects on it you can not see what is behind.\n         * @internal\n         */\n        this._useSpecularOverAlpha = true;\n        /**\n         * Specifies if the reflectivity texture contains the glossiness information in its alpha channel.\n         * @internal\n         */\n        this._useMicroSurfaceFromReflectivityMapAlpha = false;\n        /**\n         * Specifies if the metallic texture contains the roughness information in its alpha channel.\n         * @internal\n         */\n        this._useRoughnessFromMetallicTextureAlpha = true;\n        /**\n         * Specifies if the metallic texture contains the roughness information in its green channel.\n         * @internal\n         */\n        this._useRoughnessFromMetallicTextureGreen = false;\n        /**\n         * Specifies if the metallic texture contains the metallness information in its blue channel.\n         * @internal\n         */\n        this._useMetallnessFromMetallicTextureBlue = false;\n        /**\n         * Specifies if the metallic texture contains the ambient occlusion information in its red channel.\n         * @internal\n         */\n        this._useAmbientOcclusionFromMetallicTextureRed = false;\n        /**\n         * Specifies if the ambient texture contains the ambient occlusion information in its red channel only.\n         * @internal\n         */\n        this._useAmbientInGrayScale = false;\n        /**\n         * In case the reflectivity map does not contain the microsurface information in its alpha channel,\n         * The material will try to infer what glossiness each pixel should be.\n         * @internal\n         */\n        this._useAutoMicroSurfaceFromReflectivityMap = false;\n        /**\n         * Defines the  falloff type used in this material.\n         * It by default is Physical.\n         * @internal\n         */\n        this._lightFalloff = PBRBaseMaterial.LIGHTFALLOFF_PHYSICAL;\n        /**\n         * Specifies that the material will keeps the reflection highlights over a transparent surface (only the most luminous ones).\n         * A car glass is a good example of that. When the street lights reflects on it you can not see what is behind.\n         * @internal\n         */\n        this._useRadianceOverAlpha = true;\n        /**\n         * Allows using an object space normal map (instead of tangent space).\n         * @internal\n         */\n        this._useObjectSpaceNormalMap = false;\n        /**\n         * Allows using the bump map in parallax mode.\n         * @internal\n         */\n        this._useParallax = false;\n        /**\n         * Allows using the bump map in parallax occlusion mode.\n         * @internal\n         */\n        this._useParallaxOcclusion = false;\n        /**\n         * Controls the scale bias of the parallax mode.\n         * @internal\n         */\n        this._parallaxScaleBias = 0.05;\n        /**\n         * If sets to true, disables all the lights affecting the material.\n         * @internal\n         */\n        this._disableLighting = false;\n        /**\n         * Number of Simultaneous lights allowed on the material.\n         * @internal\n         */\n        this._maxSimultaneousLights = 4;\n        /**\n         * If sets to true, x component of normal map value will be inverted (x = 1.0 - x).\n         * @internal\n         */\n        this._invertNormalMapX = false;\n        /**\n         * If sets to true, y component of normal map value will be inverted (y = 1.0 - y).\n         * @internal\n         */\n        this._invertNormalMapY = false;\n        /**\n         * If sets to true and backfaceCulling is false, normals will be flipped on the backside.\n         * @internal\n         */\n        this._twoSidedLighting = false;\n        /**\n         * Defines the alpha limits in alpha test mode.\n         * @internal\n         */\n        this._alphaCutOff = 0.4;\n        /**\n         * Enforces alpha test in opaque or blend mode in order to improve the performances of some situations.\n         * @internal\n         */\n        this._forceAlphaTest = false;\n        /**\n         * A fresnel is applied to the alpha of the model to ensure grazing angles edges are not alpha tested.\n         * And/Or occlude the blended part. (alpha is converted to gamma to compute the fresnel)\n         * @internal\n         */\n        this._useAlphaFresnel = false;\n        /**\n         * A fresnel is applied to the alpha of the model to ensure grazing angles edges are not alpha tested.\n         * And/Or occlude the blended part. (alpha stays linear to compute the fresnel)\n         * @internal\n         */\n        this._useLinearAlphaFresnel = false;\n        /**\n         * Specifies the environment BRDF texture used to compute the scale and offset roughness values\n         * from cos theta and roughness:\n         * http://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf\n         * @internal\n         */\n        this._environmentBRDFTexture = null;\n        /**\n         * Force the shader to compute irradiance in the fragment shader in order to take bump in account.\n         * @internal\n         */\n        this._forceIrradianceInFragment = false;\n        this._realTimeFiltering = false;\n        this._realTimeFilteringQuality = 8;\n        /**\n         * Force normal to face away from face.\n         * @internal\n         */\n        this._forceNormalForward = false;\n        /**\n         * Enables specular anti aliasing in the PBR shader.\n         * It will both interacts on the Geometry for analytical and IBL lighting.\n         * It also prefilter the roughness map based on the bump values.\n         * @internal\n         */\n        this._enableSpecularAntiAliasing = false;\n        /**\n         * Keep track of the image processing observer to allow dispose and replace.\n         */\n        this._imageProcessingObserver = null;\n        /**\n         * Stores the available render targets.\n         */\n        this._renderTargets = new SmartArray(16);\n        /**\n         * Sets the global ambient color for the material used in lighting calculations.\n         */\n        this._globalAmbientColor = new Color3(0, 0, 0);\n        /**\n         * Enables the use of logarithmic depth buffers, which is good for wide depth buffers.\n         */\n        this._useLogarithmicDepth = false;\n        /**\n         * If set to true, no lighting calculations will be applied.\n         */\n        this._unlit = false;\n        this._debugMode = 0;\n        /**\n         * @internal\n         * This is reserved for the inspector.\n         * Defines the material debug mode.\n         * It helps seeing only some components of the material while troubleshooting.\n         */\n        this.debugMode = 0;\n        /**\n         * @internal\n         * This is reserved for the inspector.\n         * Specify from where on screen the debug mode should start.\n         * The value goes from -1 (full screen) to 1 (not visible)\n         * It helps with side by side comparison against the final render\n         * This defaults to -1\n         */\n        this._debugLimit = -1;\n        /**\n         * @internal\n         * This is reserved for the inspector.\n         * As the default viewing range might not be enough (if the ambient is really small for instance)\n         * You can use the factor to better multiply the final value.\n         */\n        this._debugFactor = 1;\n        this._cacheHasRenderTargetTextures = false;\n        this.brdf = new PBRBRDFConfiguration(this);\n        this.clearCoat = new PBRClearCoatConfiguration(this);\n        this.iridescence = new PBRIridescenceConfiguration(this);\n        this.anisotropy = new PBRAnisotropicConfiguration(this);\n        this.sheen = new PBRSheenConfiguration(this);\n        this.subSurface = new PBRSubSurfaceConfiguration(this);\n        this.detailMap = new DetailMapConfiguration(this);\n        // Setup the default processing configuration to the scene.\n        this._attachImageProcessingConfiguration(null);\n        this.getRenderTargetTextures = () => {\n            this._renderTargets.reset();\n            if (MaterialFlags.ReflectionTextureEnabled && this._reflectionTexture && this._reflectionTexture.isRenderTarget) {\n                this._renderTargets.push(this._reflectionTexture);\n            }\n            this._eventInfo.renderTargets = this._renderTargets;\n            this._callbackPluginEventFillRenderTargetTextures(this._eventInfo);\n            return this._renderTargets;\n        };\n        this._environmentBRDFTexture = GetEnvironmentBRDFTexture(this.getScene());\n        this.prePassConfiguration = new PrePassConfiguration();\n    }\n    /**\n     * Gets a boolean indicating that current material needs to register RTT\n     */\n    get hasRenderTargetTextures() {\n        if (MaterialFlags.ReflectionTextureEnabled && this._reflectionTexture && this._reflectionTexture.isRenderTarget) {\n            return true;\n        }\n        return this._cacheHasRenderTargetTextures;\n    }\n    /**\n     * Can this material render to prepass\n     */\n    get isPrePassCapable() {\n        return !this.disableDepthWrite;\n    }\n    /**\n     * Gets the name of the material class.\n     */\n    getClassName() {\n        return \"PBRBaseMaterial\";\n    }\n    /**\n     * Enabled the use of logarithmic depth buffers, which is good for wide depth buffers.\n     */\n    get useLogarithmicDepth() {\n        return this._useLogarithmicDepth;\n    }\n    /**\n     * Enabled the use of logarithmic depth buffers, which is good for wide depth buffers.\n     */\n    set useLogarithmicDepth(value) {\n        this._useLogarithmicDepth = value && this.getScene().getEngine().getCaps().fragmentDepthSupported;\n    }\n    /**\n     * Returns true if alpha blending should be disabled.\n     */\n    get _disableAlphaBlending() {\n        var _a;\n        return (this._transparencyMode === PBRBaseMaterial.PBRMATERIAL_OPAQUE ||\n            this._transparencyMode === PBRBaseMaterial.PBRMATERIAL_ALPHATEST ||\n            ((_a = this.subSurface) === null || _a === void 0 ? void 0 : _a.disableAlphaBlending));\n    }\n    /**\n     * Specifies whether or not this material should be rendered in alpha blend mode.\n     */\n    needAlphaBlending() {\n        if (this._disableAlphaBlending) {\n            return false;\n        }\n        return this.alpha < 1.0 || this._opacityTexture != null || this._shouldUseAlphaFromAlbedoTexture();\n    }\n    /**\n     * Specifies whether or not this material should be rendered in alpha test mode.\n     */\n    needAlphaTesting() {\n        var _a;\n        if (this._forceAlphaTest) {\n            return true;\n        }\n        if ((_a = this.subSurface) === null || _a === void 0 ? void 0 : _a.disableAlphaBlending) {\n            return false;\n        }\n        return this._hasAlphaChannel() && (this._transparencyMode == null || this._transparencyMode === PBRBaseMaterial.PBRMATERIAL_ALPHATEST);\n    }\n    /**\n     * Specifies whether or not the alpha value of the albedo texture should be used for alpha blending.\n     */\n    _shouldUseAlphaFromAlbedoTexture() {\n        return this._albedoTexture != null && this._albedoTexture.hasAlpha && this._useAlphaFromAlbedoTexture && this._transparencyMode !== PBRBaseMaterial.PBRMATERIAL_OPAQUE;\n    }\n    /**\n     * Specifies whether or not there is a usable alpha channel for transparency.\n     */\n    _hasAlphaChannel() {\n        return (this._albedoTexture != null && this._albedoTexture.hasAlpha) || this._opacityTexture != null;\n    }\n    /**\n     * Gets the texture used for the alpha test.\n     */\n    getAlphaTestTexture() {\n        return this._albedoTexture;\n    }\n    /**\n     * Specifies that the submesh is ready to be used.\n     * @param mesh - BJS mesh.\n     * @param subMesh - A submesh of the BJS mesh.  Used to check if it is ready.\n     * @param useInstances - Specifies that instances should be used.\n     * @returns - boolean indicating that the submesh is ready or not.\n     */\n    isReadyForSubMesh(mesh, subMesh, useInstances) {\n        if (!this._uniformBufferLayoutBuilt) {\n            this.buildUniformLayout();\n        }\n        if (subMesh.effect && this.isFrozen) {\n            if (subMesh.effect._wasPreviouslyReady && subMesh.effect._wasPreviouslyUsingInstances === useInstances) {\n                return true;\n            }\n        }\n        if (!subMesh.materialDefines) {\n            this._callbackPluginEventGeneric(MaterialPluginEvent.GetDefineNames, this._eventInfo);\n            subMesh.materialDefines = new PBRMaterialDefines(this._eventInfo.defineNames);\n        }\n        const defines = subMesh.materialDefines;\n        if (this._isReadyForSubMesh(subMesh)) {\n            return true;\n        }\n        const scene = this.getScene();\n        const engine = scene.getEngine();\n        if (defines._areTexturesDirty) {\n            this._eventInfo.hasRenderTargetTextures = false;\n            this._callbackPluginEventHasRenderTargetTextures(this._eventInfo);\n            this._cacheHasRenderTargetTextures = this._eventInfo.hasRenderTargetTextures;\n            if (scene.texturesEnabled) {\n                if (this._albedoTexture && MaterialFlags.DiffuseTextureEnabled) {\n                    if (!this._albedoTexture.isReadyOrNotBlocking()) {\n                        return false;\n                    }\n                }\n                if (this._ambientTexture && MaterialFlags.AmbientTextureEnabled) {\n                    if (!this._ambientTexture.isReadyOrNotBlocking()) {\n                        return false;\n                    }\n                }\n                if (this._opacityTexture && MaterialFlags.OpacityTextureEnabled) {\n                    if (!this._opacityTexture.isReadyOrNotBlocking()) {\n                        return false;\n                    }\n                }\n                const reflectionTexture = this._getReflectionTexture();\n                if (reflectionTexture && MaterialFlags.ReflectionTextureEnabled) {\n                    if (!reflectionTexture.isReadyOrNotBlocking()) {\n                        return false;\n                    }\n                    if (reflectionTexture.irradianceTexture && !reflectionTexture.irradianceTexture.isReadyOrNotBlocking()) {\n                        return false;\n                    }\n                }\n                if (this._lightmapTexture && MaterialFlags.LightmapTextureEnabled) {\n                    if (!this._lightmapTexture.isReadyOrNotBlocking()) {\n                        return false;\n                    }\n                }\n                if (this._emissiveTexture && MaterialFlags.EmissiveTextureEnabled) {\n                    if (!this._emissiveTexture.isReadyOrNotBlocking()) {\n                        return false;\n                    }\n                }\n                if (MaterialFlags.SpecularTextureEnabled) {\n                    if (this._metallicTexture) {\n                        if (!this._metallicTexture.isReadyOrNotBlocking()) {\n                            return false;\n                        }\n                    }\n                    else if (this._reflectivityTexture) {\n                        if (!this._reflectivityTexture.isReadyOrNotBlocking()) {\n                            return false;\n                        }\n                    }\n                    if (this._metallicReflectanceTexture) {\n                        if (!this._metallicReflectanceTexture.isReadyOrNotBlocking()) {\n                            return false;\n                        }\n                    }\n                    if (this._reflectanceTexture) {\n                        if (!this._reflectanceTexture.isReadyOrNotBlocking()) {\n                            return false;\n                        }\n                    }\n                    if (this._microSurfaceTexture) {\n                        if (!this._microSurfaceTexture.isReadyOrNotBlocking()) {\n                            return false;\n                        }\n                    }\n                }\n                if (engine.getCaps().standardDerivatives && this._bumpTexture && MaterialFlags.BumpTextureEnabled && !this._disableBumpMap) {\n                    // Bump texture cannot be not blocking.\n                    if (!this._bumpTexture.isReady()) {\n                        return false;\n                    }\n                }\n                if (this._environmentBRDFTexture && MaterialFlags.ReflectionTextureEnabled) {\n                    // This is blocking.\n                    if (!this._environmentBRDFTexture.isReady()) {\n                        return false;\n                    }\n                }\n            }\n        }\n        this._eventInfo.isReadyForSubMesh = true;\n        this._eventInfo.defines = defines;\n        this._callbackPluginEventIsReadyForSubMesh(this._eventInfo);\n        if (!this._eventInfo.isReadyForSubMesh) {\n            return false;\n        }\n        if (defines._areImageProcessingDirty && this._imageProcessingConfiguration) {\n            if (!this._imageProcessingConfiguration.isReady()) {\n                return false;\n            }\n        }\n        if (!engine.getCaps().standardDerivatives && !mesh.isVerticesDataPresent(VertexBuffer.NormalKind)) {\n            mesh.createNormals(true);\n            Logger.Warn(\"PBRMaterial: Normals have been created for the mesh: \" + mesh.name);\n        }\n        const previousEffect = subMesh.effect;\n        const lightDisposed = defines._areLightsDisposed;\n        let effect = this._prepareEffect(mesh, defines, this.onCompiled, this.onError, useInstances, null, subMesh.getRenderingMesh().hasThinInstances);\n        let forceWasNotReadyPreviously = false;\n        if (effect) {\n            if (this._onEffectCreatedObservable) {\n                onCreatedEffectParameters.effect = effect;\n                onCreatedEffectParameters.subMesh = subMesh;\n                this._onEffectCreatedObservable.notifyObservers(onCreatedEffectParameters);\n            }\n            // Use previous effect while new one is compiling\n            if (this.allowShaderHotSwapping && previousEffect && !effect.isReady()) {\n                effect = previousEffect;\n                defines.markAsUnprocessed();\n                forceWasNotReadyPreviously = this.isFrozen;\n                if (lightDisposed) {\n                    // re register in case it takes more than one frame.\n                    defines._areLightsDisposed = true;\n                    return false;\n                }\n            }\n            else {\n                scene.resetCachedMaterial();\n                subMesh.setEffect(effect, defines, this._materialContext);\n            }\n        }\n        if (!subMesh.effect || !subMesh.effect.isReady()) {\n            return false;\n        }\n        defines._renderId = scene.getRenderId();\n        subMesh.effect._wasPreviouslyReady = forceWasNotReadyPreviously ? false : true;\n        subMesh.effect._wasPreviouslyUsingInstances = !!useInstances;\n        if (scene.performancePriority !== ScenePerformancePriority.BackwardCompatible) {\n            this.checkReadyOnlyOnce = true;\n        }\n        return true;\n    }\n    /**\n     * Specifies if the material uses metallic roughness workflow.\n     * @returns boolean specifying if the material uses metallic roughness workflow.\n     */\n    isMetallicWorkflow() {\n        if (this._metallic != null || this._roughness != null || this._metallicTexture) {\n            return true;\n        }\n        return false;\n    }\n    _prepareEffect(mesh, defines, onCompiled = null, onError = null, useInstances = null, useClipPlane = null, useThinInstances) {\n        this._prepareDefines(mesh, defines, useInstances, useClipPlane, useThinInstances);\n        if (!defines.isDirty) {\n            return null;\n        }\n        defines.markAsProcessed();\n        const scene = this.getScene();\n        const engine = scene.getEngine();\n        // Fallbacks\n        const fallbacks = new EffectFallbacks();\n        let fallbackRank = 0;\n        if (defines.USESPHERICALINVERTEX) {\n            fallbacks.addFallback(fallbackRank++, \"USESPHERICALINVERTEX\");\n        }\n        if (defines.FOG) {\n            fallbacks.addFallback(fallbackRank, \"FOG\");\n        }\n        if (defines.SPECULARAA) {\n            fallbacks.addFallback(fallbackRank, \"SPECULARAA\");\n        }\n        if (defines.POINTSIZE) {\n            fallbacks.addFallback(fallbackRank, \"POINTSIZE\");\n        }\n        if (defines.LOGARITHMICDEPTH) {\n            fallbacks.addFallback(fallbackRank, \"LOGARITHMICDEPTH\");\n        }\n        if (defines.PARALLAX) {\n            fallbacks.addFallback(fallbackRank, \"PARALLAX\");\n        }\n        if (defines.PARALLAXOCCLUSION) {\n            fallbacks.addFallback(fallbackRank++, \"PARALLAXOCCLUSION\");\n        }\n        if (defines.ENVIRONMENTBRDF) {\n            fallbacks.addFallback(fallbackRank++, \"ENVIRONMENTBRDF\");\n        }\n        if (defines.TANGENT) {\n            fallbacks.addFallback(fallbackRank++, \"TANGENT\");\n        }\n        if (defines.BUMP) {\n            fallbacks.addFallback(fallbackRank++, \"BUMP\");\n        }\n        fallbackRank = MaterialHelper.HandleFallbacksForShadows(defines, fallbacks, this._maxSimultaneousLights, fallbackRank++);\n        if (defines.SPECULARTERM) {\n            fallbacks.addFallback(fallbackRank++, \"SPECULARTERM\");\n        }\n        if (defines.USESPHERICALFROMREFLECTIONMAP) {\n            fallbacks.addFallback(fallbackRank++, \"USESPHERICALFROMREFLECTIONMAP\");\n        }\n        if (defines.USEIRRADIANCEMAP) {\n            fallbacks.addFallback(fallbackRank++, \"USEIRRADIANCEMAP\");\n        }\n        if (defines.LIGHTMAP) {\n            fallbacks.addFallback(fallbackRank++, \"LIGHTMAP\");\n        }\n        if (defines.NORMAL) {\n            fallbacks.addFallback(fallbackRank++, \"NORMAL\");\n        }\n        if (defines.AMBIENT) {\n            fallbacks.addFallback(fallbackRank++, \"AMBIENT\");\n        }\n        if (defines.EMISSIVE) {\n            fallbacks.addFallback(fallbackRank++, \"EMISSIVE\");\n        }\n        if (defines.VERTEXCOLOR) {\n            fallbacks.addFallback(fallbackRank++, \"VERTEXCOLOR\");\n        }\n        if (defines.MORPHTARGETS) {\n            fallbacks.addFallback(fallbackRank++, \"MORPHTARGETS\");\n        }\n        if (defines.MULTIVIEW) {\n            fallbacks.addFallback(0, \"MULTIVIEW\");\n        }\n        //Attributes\n        const attribs = [VertexBuffer.PositionKind];\n        if (defines.NORMAL) {\n            attribs.push(VertexBuffer.NormalKind);\n        }\n        if (defines.TANGENT) {\n            attribs.push(VertexBuffer.TangentKind);\n        }\n        for (let i = 1; i <= 6; ++i) {\n            if (defines[\"UV\" + i]) {\n                attribs.push(`uv${i === 1 ? \"\" : i}`);\n            }\n        }\n        if (defines.VERTEXCOLOR) {\n            attribs.push(VertexBuffer.ColorKind);\n        }\n        if (defines.INSTANCESCOLOR) {\n            attribs.push(VertexBuffer.ColorInstanceKind);\n        }\n        MaterialHelper.PrepareAttributesForBones(attribs, mesh, defines, fallbacks);\n        MaterialHelper.PrepareAttributesForInstances(attribs, defines);\n        MaterialHelper.PrepareAttributesForMorphTargets(attribs, mesh, defines);\n        MaterialHelper.PrepareAttributesForBakedVertexAnimation(attribs, mesh, defines);\n        let shaderName = \"pbr\";\n        const uniforms = [\n            \"world\",\n            \"view\",\n            \"viewProjection\",\n            \"vEyePosition\",\n            \"vLightsType\",\n            \"vAmbientColor\",\n            \"vAlbedoColor\",\n            \"vReflectivityColor\",\n            \"vMetallicReflectanceFactors\",\n            \"vEmissiveColor\",\n            \"visibility\",\n            \"vReflectionColor\",\n            \"vFogInfos\",\n            \"vFogColor\",\n            \"pointSize\",\n            \"vAlbedoInfos\",\n            \"vAmbientInfos\",\n            \"vOpacityInfos\",\n            \"vReflectionInfos\",\n            \"vReflectionPosition\",\n            \"vReflectionSize\",\n            \"vEmissiveInfos\",\n            \"vReflectivityInfos\",\n            \"vReflectionFilteringInfo\",\n            \"vMetallicReflectanceInfos\",\n            \"vReflectanceInfos\",\n            \"vMicroSurfaceSamplerInfos\",\n            \"vBumpInfos\",\n            \"vLightmapInfos\",\n            \"mBones\",\n            \"albedoMatrix\",\n            \"ambientMatrix\",\n            \"opacityMatrix\",\n            \"reflectionMatrix\",\n            \"emissiveMatrix\",\n            \"reflectivityMatrix\",\n            \"normalMatrix\",\n            \"microSurfaceSamplerMatrix\",\n            \"bumpMatrix\",\n            \"lightmapMatrix\",\n            \"metallicReflectanceMatrix\",\n            \"reflectanceMatrix\",\n            \"vLightingIntensity\",\n            \"logarithmicDepthConstant\",\n            \"vSphericalX\",\n            \"vSphericalY\",\n            \"vSphericalZ\",\n            \"vSphericalXX_ZZ\",\n            \"vSphericalYY_ZZ\",\n            \"vSphericalZZ\",\n            \"vSphericalXY\",\n            \"vSphericalYZ\",\n            \"vSphericalZX\",\n            \"vSphericalL00\",\n            \"vSphericalL1_1\",\n            \"vSphericalL10\",\n            \"vSphericalL11\",\n            \"vSphericalL2_2\",\n            \"vSphericalL2_1\",\n            \"vSphericalL20\",\n            \"vSphericalL21\",\n            \"vSphericalL22\",\n            \"vReflectionMicrosurfaceInfos\",\n            \"vTangentSpaceParams\",\n            \"boneTextureWidth\",\n            \"vDebugMode\",\n            \"morphTargetTextureInfo\",\n            \"morphTargetTextureIndices\",\n        ];\n        const samplers = [\n            \"albedoSampler\",\n            \"reflectivitySampler\",\n            \"ambientSampler\",\n            \"emissiveSampler\",\n            \"bumpSampler\",\n            \"lightmapSampler\",\n            \"opacitySampler\",\n            \"reflectionSampler\",\n            \"reflectionSamplerLow\",\n            \"reflectionSamplerHigh\",\n            \"irradianceSampler\",\n            \"microSurfaceSampler\",\n            \"environmentBrdfSampler\",\n            \"boneSampler\",\n            \"metallicReflectanceSampler\",\n            \"reflectanceSampler\",\n            \"morphTargets\",\n            \"oitDepthSampler\",\n            \"oitFrontColorSampler\",\n        ];\n        const uniformBuffers = [\"Material\", \"Scene\", \"Mesh\"];\n        this._eventInfo.fallbacks = fallbacks;\n        this._eventInfo.fallbackRank = fallbackRank;\n        this._eventInfo.defines = defines;\n        this._eventInfo.uniforms = uniforms;\n        this._eventInfo.attributes = attribs;\n        this._eventInfo.samplers = samplers;\n        this._eventInfo.uniformBuffersNames = uniformBuffers;\n        this._eventInfo.customCode = undefined;\n        this._eventInfo.mesh = mesh;\n        this._callbackPluginEventGeneric(MaterialPluginEvent.PrepareEffect, this._eventInfo);\n        PrePassConfiguration.AddUniforms(uniforms);\n        PrePassConfiguration.AddSamplers(samplers);\n        addClipPlaneUniforms(uniforms);\n        if (ImageProcessingConfiguration) {\n            ImageProcessingConfiguration.PrepareUniforms(uniforms, defines);\n            ImageProcessingConfiguration.PrepareSamplers(samplers, defines);\n        }\n        MaterialHelper.PrepareUniformsAndSamplersList({\n            uniformsNames: uniforms,\n            uniformBuffersNames: uniformBuffers,\n            samplers: samplers,\n            defines: defines,\n            maxSimultaneousLights: this._maxSimultaneousLights,\n        });\n        const csnrOptions = {};\n        if (this.customShaderNameResolve) {\n            shaderName = this.customShaderNameResolve(shaderName, uniforms, uniformBuffers, samplers, defines, attribs, csnrOptions);\n        }\n        const join = defines.toString();\n        const effect = engine.createEffect(shaderName, {\n            attributes: attribs,\n            uniformsNames: uniforms,\n            uniformBuffersNames: uniformBuffers,\n            samplers: samplers,\n            defines: join,\n            fallbacks: fallbacks,\n            onCompiled: onCompiled,\n            onError: onError,\n            indexParameters: { maxSimultaneousLights: this._maxSimultaneousLights, maxSimultaneousMorphTargets: defines.NUM_MORPH_INFLUENCERS },\n            processFinalCode: csnrOptions.processFinalCode,\n            processCodeAfterIncludes: this._eventInfo.customCode,\n            multiTarget: defines.PREPASS,\n        }, engine);\n        this._eventInfo.customCode = undefined;\n        return effect;\n    }\n    _prepareDefines(mesh, defines, useInstances = null, useClipPlane = null, useThinInstances = false) {\n        var _a;\n        const scene = this.getScene();\n        const engine = scene.getEngine();\n        // Lights\n        MaterialHelper.PrepareDefinesForLights(scene, mesh, defines, true, this._maxSimultaneousLights, this._disableLighting);\n        defines._needNormals = true;\n        // Multiview\n        MaterialHelper.PrepareDefinesForMultiview(scene, defines);\n        // PrePass\n        const oit = this.needAlphaBlendingForMesh(mesh) && this.getScene().useOrderIndependentTransparency;\n        MaterialHelper.PrepareDefinesForPrePass(scene, defines, this.canRenderToMRT && !oit);\n        // Order independant transparency\n        MaterialHelper.PrepareDefinesForOIT(scene, defines, oit);\n        // Textures\n        defines.METALLICWORKFLOW = this.isMetallicWorkflow();\n        if (defines._areTexturesDirty) {\n            defines._needUVs = false;\n            if (scene.texturesEnabled) {\n                defines.ALBEDODIRECTUV = 0;\n                defines.AMBIENTDIRECTUV = 0;\n                defines.OPACITYDIRECTUV = 0;\n                defines.EMISSIVEDIRECTUV = 0;\n                defines.REFLECTIVITYDIRECTUV = 0;\n                defines.MICROSURFACEMAPDIRECTUV = 0;\n                defines.METALLIC_REFLECTANCEDIRECTUV = 0;\n                defines.REFLECTANCEDIRECTUV = 0;\n                defines.BUMPDIRECTUV = 0;\n                defines.LIGHTMAPDIRECTUV = 0;\n                if (engine.getCaps().textureLOD) {\n                    defines.LODBASEDMICROSFURACE = true;\n                }\n                if (this._albedoTexture && MaterialFlags.DiffuseTextureEnabled) {\n                    MaterialHelper.PrepareDefinesForMergedUV(this._albedoTexture, defines, \"ALBEDO\");\n                    defines.GAMMAALBEDO = this._albedoTexture.gammaSpace;\n                }\n                else {\n                    defines.ALBEDO = false;\n                }\n                if (this._ambientTexture && MaterialFlags.AmbientTextureEnabled) {\n                    MaterialHelper.PrepareDefinesForMergedUV(this._ambientTexture, defines, \"AMBIENT\");\n                    defines.AMBIENTINGRAYSCALE = this._useAmbientInGrayScale;\n                }\n                else {\n                    defines.AMBIENT = false;\n                }\n                if (this._opacityTexture && MaterialFlags.OpacityTextureEnabled) {\n                    MaterialHelper.PrepareDefinesForMergedUV(this._opacityTexture, defines, \"OPACITY\");\n                    defines.OPACITYRGB = this._opacityTexture.getAlphaFromRGB;\n                }\n                else {\n                    defines.OPACITY = false;\n                }\n                const reflectionTexture = this._getReflectionTexture();\n                if (reflectionTexture && MaterialFlags.ReflectionTextureEnabled) {\n                    defines.REFLECTION = true;\n                    defines.GAMMAREFLECTION = reflectionTexture.gammaSpace;\n                    defines.RGBDREFLECTION = reflectionTexture.isRGBD;\n                    defines.LODINREFLECTIONALPHA = reflectionTexture.lodLevelInAlpha;\n                    defines.LINEARSPECULARREFLECTION = reflectionTexture.linearSpecularLOD;\n                    if (this.realTimeFiltering && this.realTimeFilteringQuality > 0) {\n                        defines.NUM_SAMPLES = \"\" + this.realTimeFilteringQuality;\n                        if (engine._features.needTypeSuffixInShaderConstants) {\n                            defines.NUM_SAMPLES = defines.NUM_SAMPLES + \"u\";\n                        }\n                        defines.REALTIME_FILTERING = true;\n                    }\n                    else {\n                        defines.REALTIME_FILTERING = false;\n                    }\n                    defines.INVERTCUBICMAP = reflectionTexture.coordinatesMode === Texture.INVCUBIC_MODE;\n                    defines.REFLECTIONMAP_3D = reflectionTexture.isCube;\n                    defines.REFLECTIONMAP_OPPOSITEZ = defines.REFLECTIONMAP_3D && this.getScene().useRightHandedSystem ? !reflectionTexture.invertZ : reflectionTexture.invertZ;\n                    defines.REFLECTIONMAP_CUBIC = false;\n                    defines.REFLECTIONMAP_EXPLICIT = false;\n                    defines.REFLECTIONMAP_PLANAR = false;\n                    defines.REFLECTIONMAP_PROJECTION = false;\n                    defines.REFLECTIONMAP_SKYBOX = false;\n                    defines.REFLECTIONMAP_SPHERICAL = false;\n                    defines.REFLECTIONMAP_EQUIRECTANGULAR = false;\n                    defines.REFLECTIONMAP_EQUIRECTANGULAR_FIXED = false;\n                    defines.REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED = false;\n                    switch (reflectionTexture.coordinatesMode) {\n                        case Texture.EXPLICIT_MODE:\n                            defines.REFLECTIONMAP_EXPLICIT = true;\n                            break;\n                        case Texture.PLANAR_MODE:\n                            defines.REFLECTIONMAP_PLANAR = true;\n                            break;\n                        case Texture.PROJECTION_MODE:\n                            defines.REFLECTIONMAP_PROJECTION = true;\n                            break;\n                        case Texture.SKYBOX_MODE:\n                            defines.REFLECTIONMAP_SKYBOX = true;\n                            break;\n                        case Texture.SPHERICAL_MODE:\n                            defines.REFLECTIONMAP_SPHERICAL = true;\n                            break;\n                        case Texture.EQUIRECTANGULAR_MODE:\n                            defines.REFLECTIONMAP_EQUIRECTANGULAR = true;\n                            break;\n                        case Texture.FIXED_EQUIRECTANGULAR_MODE:\n                            defines.REFLECTIONMAP_EQUIRECTANGULAR_FIXED = true;\n                            break;\n                        case Texture.FIXED_EQUIRECTANGULAR_MIRRORED_MODE:\n                            defines.REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED = true;\n                            break;\n                        case Texture.CUBIC_MODE:\n                        case Texture.INVCUBIC_MODE:\n                        default:\n                            defines.REFLECTIONMAP_CUBIC = true;\n                            defines.USE_LOCAL_REFLECTIONMAP_CUBIC = reflectionTexture.boundingBoxSize ? true : false;\n                            break;\n                    }\n                    if (reflectionTexture.coordinatesMode !== Texture.SKYBOX_MODE) {\n                        if (reflectionTexture.irradianceTexture) {\n                            defines.USEIRRADIANCEMAP = true;\n                            defines.USESPHERICALFROMREFLECTIONMAP = false;\n                        }\n                        // Assume using spherical polynomial if the reflection texture is a cube map\n                        else if (reflectionTexture.isCube) {\n                            defines.USESPHERICALFROMREFLECTIONMAP = true;\n                            defines.USEIRRADIANCEMAP = false;\n                            if (this._forceIrradianceInFragment || this.realTimeFiltering || engine.getCaps().maxVaryingVectors <= 8) {\n                                defines.USESPHERICALINVERTEX = false;\n                            }\n                            else {\n                                defines.USESPHERICALINVERTEX = true;\n                            }\n                        }\n                    }\n                }\n                else {\n                    defines.REFLECTION = false;\n                    defines.REFLECTIONMAP_3D = false;\n                    defines.REFLECTIONMAP_SPHERICAL = false;\n                    defines.REFLECTIONMAP_PLANAR = false;\n                    defines.REFLECTIONMAP_CUBIC = false;\n                    defines.USE_LOCAL_REFLECTIONMAP_CUBIC = false;\n                    defines.REFLECTIONMAP_PROJECTION = false;\n                    defines.REFLECTIONMAP_SKYBOX = false;\n                    defines.REFLECTIONMAP_EXPLICIT = false;\n                    defines.REFLECTIONMAP_EQUIRECTANGULAR = false;\n                    defines.REFLECTIONMAP_EQUIRECTANGULAR_FIXED = false;\n                    defines.REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED = false;\n                    defines.INVERTCUBICMAP = false;\n                    defines.USESPHERICALFROMREFLECTIONMAP = false;\n                    defines.USEIRRADIANCEMAP = false;\n                    defines.USESPHERICALINVERTEX = false;\n                    defines.REFLECTIONMAP_OPPOSITEZ = false;\n                    defines.LODINREFLECTIONALPHA = false;\n                    defines.GAMMAREFLECTION = false;\n                    defines.RGBDREFLECTION = false;\n                    defines.LINEARSPECULARREFLECTION = false;\n                }\n                if (this._lightmapTexture && MaterialFlags.LightmapTextureEnabled) {\n                    MaterialHelper.PrepareDefinesForMergedUV(this._lightmapTexture, defines, \"LIGHTMAP\");\n                    defines.USELIGHTMAPASSHADOWMAP = this._useLightmapAsShadowmap;\n                    defines.GAMMALIGHTMAP = this._lightmapTexture.gammaSpace;\n                    defines.RGBDLIGHTMAP = this._lightmapTexture.isRGBD;\n                }\n                else {\n                    defines.LIGHTMAP = false;\n                }\n                if (this._emissiveTexture && MaterialFlags.EmissiveTextureEnabled) {\n                    MaterialHelper.PrepareDefinesForMergedUV(this._emissiveTexture, defines, \"EMISSIVE\");\n                    defines.GAMMAEMISSIVE = this._emissiveTexture.gammaSpace;\n                }\n                else {\n                    defines.EMISSIVE = false;\n                }\n                if (MaterialFlags.SpecularTextureEnabled) {\n                    if (this._metallicTexture) {\n                        MaterialHelper.PrepareDefinesForMergedUV(this._metallicTexture, defines, \"REFLECTIVITY\");\n                        defines.ROUGHNESSSTOREINMETALMAPALPHA = this._useRoughnessFromMetallicTextureAlpha;\n                        defines.ROUGHNESSSTOREINMETALMAPGREEN = !this._useRoughnessFromMetallicTextureAlpha && this._useRoughnessFromMetallicTextureGreen;\n                        defines.METALLNESSSTOREINMETALMAPBLUE = this._useMetallnessFromMetallicTextureBlue;\n                        defines.AOSTOREINMETALMAPRED = this._useAmbientOcclusionFromMetallicTextureRed;\n                        defines.REFLECTIVITY_GAMMA = false;\n                    }\n                    else if (this._reflectivityTexture) {\n                        MaterialHelper.PrepareDefinesForMergedUV(this._reflectivityTexture, defines, \"REFLECTIVITY\");\n                        defines.MICROSURFACEFROMREFLECTIVITYMAP = this._useMicroSurfaceFromReflectivityMapAlpha;\n                        defines.MICROSURFACEAUTOMATIC = this._useAutoMicroSurfaceFromReflectivityMap;\n                        defines.REFLECTIVITY_GAMMA = this._reflectivityTexture.gammaSpace;\n                    }\n                    else {\n                        defines.REFLECTIVITY = false;\n                    }\n                    if (this._metallicReflectanceTexture || this._reflectanceTexture) {\n                        const identicalTextures = this._metallicReflectanceTexture !== null &&\n                            this._metallicReflectanceTexture._texture === ((_a = this._reflectanceTexture) === null || _a === void 0 ? void 0 : _a._texture) &&\n                            this._metallicReflectanceTexture.checkTransformsAreIdentical(this._reflectanceTexture);\n                        defines.METALLIC_REFLECTANCE_USE_ALPHA_ONLY = this._useOnlyMetallicFromMetallicReflectanceTexture && !identicalTextures;\n                        if (this._metallicReflectanceTexture) {\n                            MaterialHelper.PrepareDefinesForMergedUV(this._metallicReflectanceTexture, defines, \"METALLIC_REFLECTANCE\");\n                            defines.METALLIC_REFLECTANCE_GAMMA = this._metallicReflectanceTexture.gammaSpace;\n                        }\n                        else {\n                            defines.METALLIC_REFLECTANCE = false;\n                        }\n                        if (this._reflectanceTexture &&\n                            !identicalTextures &&\n                            (!this._metallicReflectanceTexture || (this._metallicReflectanceTexture && this._useOnlyMetallicFromMetallicReflectanceTexture))) {\n                            MaterialHelper.PrepareDefinesForMergedUV(this._reflectanceTexture, defines, \"REFLECTANCE\");\n                            defines.REFLECTANCE_GAMMA = this._reflectanceTexture.gammaSpace;\n                        }\n                        else {\n                            defines.REFLECTANCE = false;\n                        }\n                    }\n                    else {\n                        defines.METALLIC_REFLECTANCE = false;\n                        defines.REFLECTANCE = false;\n                    }\n                    if (this._microSurfaceTexture) {\n                        MaterialHelper.PrepareDefinesForMergedUV(this._microSurfaceTexture, defines, \"MICROSURFACEMAP\");\n                    }\n                    else {\n                        defines.MICROSURFACEMAP = false;\n                    }\n                }\n                else {\n                    defines.REFLECTIVITY = false;\n                    defines.MICROSURFACEMAP = false;\n                }\n                if (engine.getCaps().standardDerivatives && this._bumpTexture && MaterialFlags.BumpTextureEnabled && !this._disableBumpMap) {\n                    MaterialHelper.PrepareDefinesForMergedUV(this._bumpTexture, defines, \"BUMP\");\n                    if (this._useParallax && this._albedoTexture && MaterialFlags.DiffuseTextureEnabled) {\n                        defines.PARALLAX = true;\n                        defines.PARALLAXOCCLUSION = !!this._useParallaxOcclusion;\n                    }\n                    else {\n                        defines.PARALLAX = false;\n                    }\n                    defines.OBJECTSPACE_NORMALMAP = this._useObjectSpaceNormalMap;\n                }\n                else {\n                    defines.BUMP = false;\n                    defines.PARALLAX = false;\n                    defines.PARALLAXOCCLUSION = false;\n                    defines.OBJECTSPACE_NORMALMAP = false;\n                }\n                if (this._environmentBRDFTexture && MaterialFlags.ReflectionTextureEnabled) {\n                    defines.ENVIRONMENTBRDF = true;\n                    defines.ENVIRONMENTBRDF_RGBD = this._environmentBRDFTexture.isRGBD;\n                }\n                else {\n                    defines.ENVIRONMENTBRDF = false;\n                    defines.ENVIRONMENTBRDF_RGBD = false;\n                }\n                if (this._shouldUseAlphaFromAlbedoTexture()) {\n                    defines.ALPHAFROMALBEDO = true;\n                }\n                else {\n                    defines.ALPHAFROMALBEDO = false;\n                }\n            }\n            defines.SPECULAROVERALPHA = this._useSpecularOverAlpha;\n            if (this._lightFalloff === PBRBaseMaterial.LIGHTFALLOFF_STANDARD) {\n                defines.USEPHYSICALLIGHTFALLOFF = false;\n                defines.USEGLTFLIGHTFALLOFF = false;\n            }\n            else if (this._lightFalloff === PBRBaseMaterial.LIGHTFALLOFF_GLTF) {\n                defines.USEPHYSICALLIGHTFALLOFF = false;\n                defines.USEGLTFLIGHTFALLOFF = true;\n            }\n            else {\n                defines.USEPHYSICALLIGHTFALLOFF = true;\n                defines.USEGLTFLIGHTFALLOFF = false;\n            }\n            defines.RADIANCEOVERALPHA = this._useRadianceOverAlpha;\n            if (!this.backFaceCulling && this._twoSidedLighting) {\n                defines.TWOSIDEDLIGHTING = true;\n            }\n            else {\n                defines.TWOSIDEDLIGHTING = false;\n            }\n            defines.SPECULARAA = engine.getCaps().standardDerivatives && this._enableSpecularAntiAliasing;\n        }\n        if (defines._areTexturesDirty || defines._areMiscDirty) {\n            defines.ALPHATESTVALUE = `${this._alphaCutOff}${this._alphaCutOff % 1 === 0 ? \".\" : \"\"}`;\n            defines.PREMULTIPLYALPHA = this.alphaMode === 7 || this.alphaMode === 8;\n            defines.ALPHABLEND = this.needAlphaBlendingForMesh(mesh);\n            defines.ALPHAFRESNEL = this._useAlphaFresnel || this._useLinearAlphaFresnel;\n            defines.LINEARALPHAFRESNEL = this._useLinearAlphaFresnel;\n        }\n        if (defines._areImageProcessingDirty && this._imageProcessingConfiguration) {\n            this._imageProcessingConfiguration.prepareDefines(defines);\n        }\n        defines.FORCENORMALFORWARD = this._forceNormalForward;\n        defines.RADIANCEOCCLUSION = this._useRadianceOcclusion;\n        defines.HORIZONOCCLUSION = this._useHorizonOcclusion;\n        // Misc.\n        if (defines._areMiscDirty) {\n            MaterialHelper.PrepareDefinesForMisc(mesh, scene, this._useLogarithmicDepth, this.pointsCloud, this.fogEnabled, this._shouldTurnAlphaTestOn(mesh) || this._forceAlphaTest, defines);\n            defines.UNLIT = this._unlit || ((this.pointsCloud || this.wireframe) && !mesh.isVerticesDataPresent(VertexBuffer.NormalKind));\n            defines.DEBUGMODE = this._debugMode;\n        }\n        // Values that need to be evaluated on every frame\n        MaterialHelper.PrepareDefinesForFrameBoundValues(scene, engine, this, defines, useInstances ? true : false, useClipPlane, useThinInstances);\n        // External config\n        this._eventInfo.defines = defines;\n        this._eventInfo.mesh = mesh;\n        this._callbackPluginEventPrepareDefinesBeforeAttributes(this._eventInfo);\n        // Attribs\n        MaterialHelper.PrepareDefinesForAttributes(mesh, defines, true, true, true, this._transparencyMode !== PBRBaseMaterial.PBRMATERIAL_OPAQUE);\n        // External config\n        this._callbackPluginEventPrepareDefines(this._eventInfo);\n    }\n    /**\n     * Force shader compilation\n     * @param mesh\n     * @param onCompiled\n     * @param options\n     */\n    forceCompilation(mesh, onCompiled, options) {\n        const localOptions = {\n            clipPlane: false,\n            useInstances: false,\n            ...options,\n        };\n        if (!this._uniformBufferLayoutBuilt) {\n            this.buildUniformLayout();\n        }\n        this._callbackPluginEventGeneric(MaterialPluginEvent.GetDefineNames, this._eventInfo);\n        const defines = new PBRMaterialDefines(this._eventInfo.defineNames);\n        const effect = this._prepareEffect(mesh, defines, undefined, undefined, localOptions.useInstances, localOptions.clipPlane, mesh.hasThinInstances);\n        if (this._onEffectCreatedObservable) {\n            onCreatedEffectParameters.effect = effect;\n            onCreatedEffectParameters.subMesh = null;\n            this._onEffectCreatedObservable.notifyObservers(onCreatedEffectParameters);\n        }\n        if (effect.isReady()) {\n            if (onCompiled) {\n                onCompiled(this);\n            }\n        }\n        else {\n            effect.onCompileObservable.add(() => {\n                if (onCompiled) {\n                    onCompiled(this);\n                }\n            });\n        }\n    }\n    /**\n     * Initializes the uniform buffer layout for the shader.\n     */\n    buildUniformLayout() {\n        // Order is important !\n        const ubo = this._uniformBuffer;\n        ubo.addUniform(\"vAlbedoInfos\", 2);\n        ubo.addUniform(\"vAmbientInfos\", 4);\n        ubo.addUniform(\"vOpacityInfos\", 2);\n        ubo.addUniform(\"vEmissiveInfos\", 2);\n        ubo.addUniform(\"vLightmapInfos\", 2);\n        ubo.addUniform(\"vReflectivityInfos\", 3);\n        ubo.addUniform(\"vMicroSurfaceSamplerInfos\", 2);\n        ubo.addUniform(\"vReflectionInfos\", 2);\n        ubo.addUniform(\"vReflectionFilteringInfo\", 2);\n        ubo.addUniform(\"vReflectionPosition\", 3);\n        ubo.addUniform(\"vReflectionSize\", 3);\n        ubo.addUniform(\"vBumpInfos\", 3);\n        ubo.addUniform(\"albedoMatrix\", 16);\n        ubo.addUniform(\"ambientMatrix\", 16);\n        ubo.addUniform(\"opacityMatrix\", 16);\n        ubo.addUniform(\"emissiveMatrix\", 16);\n        ubo.addUniform(\"lightmapMatrix\", 16);\n        ubo.addUniform(\"reflectivityMatrix\", 16);\n        ubo.addUniform(\"microSurfaceSamplerMatrix\", 16);\n        ubo.addUniform(\"bumpMatrix\", 16);\n        ubo.addUniform(\"vTangentSpaceParams\", 2);\n        ubo.addUniform(\"reflectionMatrix\", 16);\n        ubo.addUniform(\"vReflectionColor\", 3);\n        ubo.addUniform(\"vAlbedoColor\", 4);\n        ubo.addUniform(\"vLightingIntensity\", 4);\n        ubo.addUniform(\"vReflectionMicrosurfaceInfos\", 3);\n        ubo.addUniform(\"pointSize\", 1);\n        ubo.addUniform(\"vReflectivityColor\", 4);\n        ubo.addUniform(\"vEmissiveColor\", 3);\n        ubo.addUniform(\"vAmbientColor\", 3);\n        ubo.addUniform(\"vDebugMode\", 2);\n        ubo.addUniform(\"vMetallicReflectanceFactors\", 4);\n        ubo.addUniform(\"vMetallicReflectanceInfos\", 2);\n        ubo.addUniform(\"metallicReflectanceMatrix\", 16);\n        ubo.addUniform(\"vReflectanceInfos\", 2);\n        ubo.addUniform(\"reflectanceMatrix\", 16);\n        ubo.addUniform(\"vSphericalL00\", 3);\n        ubo.addUniform(\"vSphericalL1_1\", 3);\n        ubo.addUniform(\"vSphericalL10\", 3);\n        ubo.addUniform(\"vSphericalL11\", 3);\n        ubo.addUniform(\"vSphericalL2_2\", 3);\n        ubo.addUniform(\"vSphericalL2_1\", 3);\n        ubo.addUniform(\"vSphericalL20\", 3);\n        ubo.addUniform(\"vSphericalL21\", 3);\n        ubo.addUniform(\"vSphericalL22\", 3);\n        ubo.addUniform(\"vSphericalX\", 3);\n        ubo.addUniform(\"vSphericalY\", 3);\n        ubo.addUniform(\"vSphericalZ\", 3);\n        ubo.addUniform(\"vSphericalXX_ZZ\", 3);\n        ubo.addUniform(\"vSphericalYY_ZZ\", 3);\n        ubo.addUniform(\"vSphericalZZ\", 3);\n        ubo.addUniform(\"vSphericalXY\", 3);\n        ubo.addUniform(\"vSphericalYZ\", 3);\n        ubo.addUniform(\"vSphericalZX\", 3);\n        super.buildUniformLayout();\n    }\n    /**\n     * Binds the submesh data.\n     * @param world - The world matrix.\n     * @param mesh - The BJS mesh.\n     * @param subMesh - A submesh of the BJS mesh.\n     */\n    bindForSubMesh(world, mesh, subMesh) {\n        var _a, _b, _c, _d;\n        const scene = this.getScene();\n        const defines = subMesh.materialDefines;\n        if (!defines) {\n            return;\n        }\n        const effect = subMesh.effect;\n        if (!effect) {\n            return;\n        }\n        this._activeEffect = effect;\n        // Matrices Mesh.\n        mesh.getMeshUniformBuffer().bindToEffect(effect, \"Mesh\");\n        mesh.transferToEffect(world);\n        const engine = scene.getEngine();\n        // Binding unconditionally\n        this._uniformBuffer.bindToEffect(effect, \"Material\");\n        this.prePassConfiguration.bindForSubMesh(this._activeEffect, scene, mesh, world, this.isFrozen);\n        this._eventInfo.subMesh = subMesh;\n        this._callbackPluginEventHardBindForSubMesh(this._eventInfo);\n        // Normal Matrix\n        if (defines.OBJECTSPACE_NORMALMAP) {\n            world.toNormalMatrix(this._normalMatrix);\n            this.bindOnlyNormalMatrix(this._normalMatrix);\n        }\n        const mustRebind = effect._forceRebindOnNextCall || this._mustRebind(scene, effect, mesh.visibility);\n        // Bones\n        MaterialHelper.BindBonesParameters(mesh, this._activeEffect, this.prePassConfiguration);\n        let reflectionTexture = null;\n        const ubo = this._uniformBuffer;\n        if (mustRebind) {\n            this.bindViewProjection(effect);\n            reflectionTexture = this._getReflectionTexture();\n            if (!ubo.useUbo || !this.isFrozen || !ubo.isSync || effect._forceRebindOnNextCall) {\n                // Texture uniforms\n                if (scene.texturesEnabled) {\n                    if (this._albedoTexture && MaterialFlags.DiffuseTextureEnabled) {\n                        ubo.updateFloat2(\"vAlbedoInfos\", this._albedoTexture.coordinatesIndex, this._albedoTexture.level);\n                        MaterialHelper.BindTextureMatrix(this._albedoTexture, ubo, \"albedo\");\n                    }\n                    if (this._ambientTexture && MaterialFlags.AmbientTextureEnabled) {\n                        ubo.updateFloat4(\"vAmbientInfos\", this._ambientTexture.coordinatesIndex, this._ambientTexture.level, this._ambientTextureStrength, this._ambientTextureImpactOnAnalyticalLights);\n                        MaterialHelper.BindTextureMatrix(this._ambientTexture, ubo, \"ambient\");\n                    }\n                    if (this._opacityTexture && MaterialFlags.OpacityTextureEnabled) {\n                        ubo.updateFloat2(\"vOpacityInfos\", this._opacityTexture.coordinatesIndex, this._opacityTexture.level);\n                        MaterialHelper.BindTextureMatrix(this._opacityTexture, ubo, \"opacity\");\n                    }\n                    if (reflectionTexture && MaterialFlags.ReflectionTextureEnabled) {\n                        ubo.updateMatrix(\"reflectionMatrix\", reflectionTexture.getReflectionTextureMatrix());\n                        ubo.updateFloat2(\"vReflectionInfos\", reflectionTexture.level, 0);\n                        if (reflectionTexture.boundingBoxSize) {\n                            const cubeTexture = reflectionTexture;\n                            ubo.updateVector3(\"vReflectionPosition\", cubeTexture.boundingBoxPosition);\n                            ubo.updateVector3(\"vReflectionSize\", cubeTexture.boundingBoxSize);\n                        }\n                        if (this.realTimeFiltering) {\n                            const width = reflectionTexture.getSize().width;\n                            ubo.updateFloat2(\"vReflectionFilteringInfo\", width, Scalar.Log2(width));\n                        }\n                        if (!defines.USEIRRADIANCEMAP) {\n                            const polynomials = reflectionTexture.sphericalPolynomial;\n                            if (defines.USESPHERICALFROMREFLECTIONMAP && polynomials) {\n                                if (defines.SPHERICAL_HARMONICS) {\n                                    const preScaledHarmonics = polynomials.preScaledHarmonics;\n                                    ubo.updateVector3(\"vSphericalL00\", preScaledHarmonics.l00);\n                                    ubo.updateVector3(\"vSphericalL1_1\", preScaledHarmonics.l1_1);\n                                    ubo.updateVector3(\"vSphericalL10\", preScaledHarmonics.l10);\n                                    ubo.updateVector3(\"vSphericalL11\", preScaledHarmonics.l11);\n                                    ubo.updateVector3(\"vSphericalL2_2\", preScaledHarmonics.l2_2);\n                                    ubo.updateVector3(\"vSphericalL2_1\", preScaledHarmonics.l2_1);\n                                    ubo.updateVector3(\"vSphericalL20\", preScaledHarmonics.l20);\n                                    ubo.updateVector3(\"vSphericalL21\", preScaledHarmonics.l21);\n                                    ubo.updateVector3(\"vSphericalL22\", preScaledHarmonics.l22);\n                                }\n                                else {\n                                    ubo.updateFloat3(\"vSphericalX\", polynomials.x.x, polynomials.x.y, polynomials.x.z);\n                                    ubo.updateFloat3(\"vSphericalY\", polynomials.y.x, polynomials.y.y, polynomials.y.z);\n                                    ubo.updateFloat3(\"vSphericalZ\", polynomials.z.x, polynomials.z.y, polynomials.z.z);\n                                    ubo.updateFloat3(\"vSphericalXX_ZZ\", polynomials.xx.x - polynomials.zz.x, polynomials.xx.y - polynomials.zz.y, polynomials.xx.z - polynomials.zz.z);\n                                    ubo.updateFloat3(\"vSphericalYY_ZZ\", polynomials.yy.x - polynomials.zz.x, polynomials.yy.y - polynomials.zz.y, polynomials.yy.z - polynomials.zz.z);\n                                    ubo.updateFloat3(\"vSphericalZZ\", polynomials.zz.x, polynomials.zz.y, polynomials.zz.z);\n                                    ubo.updateFloat3(\"vSphericalXY\", polynomials.xy.x, polynomials.xy.y, polynomials.xy.z);\n                                    ubo.updateFloat3(\"vSphericalYZ\", polynomials.yz.x, polynomials.yz.y, polynomials.yz.z);\n                                    ubo.updateFloat3(\"vSphericalZX\", polynomials.zx.x, polynomials.zx.y, polynomials.zx.z);\n                                }\n                            }\n                        }\n                        ubo.updateFloat3(\"vReflectionMicrosurfaceInfos\", reflectionTexture.getSize().width, reflectionTexture.lodGenerationScale, reflectionTexture.lodGenerationOffset);\n                    }\n                    if (this._emissiveTexture && MaterialFlags.EmissiveTextureEnabled) {\n                        ubo.updateFloat2(\"vEmissiveInfos\", this._emissiveTexture.coordinatesIndex, this._emissiveTexture.level);\n                        MaterialHelper.BindTextureMatrix(this._emissiveTexture, ubo, \"emissive\");\n                    }\n                    if (this._lightmapTexture && MaterialFlags.LightmapTextureEnabled) {\n                        ubo.updateFloat2(\"vLightmapInfos\", this._lightmapTexture.coordinatesIndex, this._lightmapTexture.level);\n                        MaterialHelper.BindTextureMatrix(this._lightmapTexture, ubo, \"lightmap\");\n                    }\n                    if (MaterialFlags.SpecularTextureEnabled) {\n                        if (this._metallicTexture) {\n                            ubo.updateFloat3(\"vReflectivityInfos\", this._metallicTexture.coordinatesIndex, this._metallicTexture.level, this._ambientTextureStrength);\n                            MaterialHelper.BindTextureMatrix(this._metallicTexture, ubo, \"reflectivity\");\n                        }\n                        else if (this._reflectivityTexture) {\n                            ubo.updateFloat3(\"vReflectivityInfos\", this._reflectivityTexture.coordinatesIndex, this._reflectivityTexture.level, 1.0);\n                            MaterialHelper.BindTextureMatrix(this._reflectivityTexture, ubo, \"reflectivity\");\n                        }\n                        if (this._metallicReflectanceTexture) {\n                            ubo.updateFloat2(\"vMetallicReflectanceInfos\", this._metallicReflectanceTexture.coordinatesIndex, this._metallicReflectanceTexture.level);\n                            MaterialHelper.BindTextureMatrix(this._metallicReflectanceTexture, ubo, \"metallicReflectance\");\n                        }\n                        if (this._reflectanceTexture && defines.REFLECTANCE) {\n                            ubo.updateFloat2(\"vReflectanceInfos\", this._reflectanceTexture.coordinatesIndex, this._reflectanceTexture.level);\n                            MaterialHelper.BindTextureMatrix(this._reflectanceTexture, ubo, \"reflectance\");\n                        }\n                        if (this._microSurfaceTexture) {\n                            ubo.updateFloat2(\"vMicroSurfaceSamplerInfos\", this._microSurfaceTexture.coordinatesIndex, this._microSurfaceTexture.level);\n                            MaterialHelper.BindTextureMatrix(this._microSurfaceTexture, ubo, \"microSurfaceSampler\");\n                        }\n                    }\n                    if (this._bumpTexture && engine.getCaps().standardDerivatives && MaterialFlags.BumpTextureEnabled && !this._disableBumpMap) {\n                        ubo.updateFloat3(\"vBumpInfos\", this._bumpTexture.coordinatesIndex, this._bumpTexture.level, this._parallaxScaleBias);\n                        MaterialHelper.BindTextureMatrix(this._bumpTexture, ubo, \"bump\");\n                        if (scene._mirroredCameraPosition) {\n                            ubo.updateFloat2(\"vTangentSpaceParams\", this._invertNormalMapX ? 1.0 : -1.0, this._invertNormalMapY ? 1.0 : -1.0);\n                        }\n                        else {\n                            ubo.updateFloat2(\"vTangentSpaceParams\", this._invertNormalMapX ? -1.0 : 1.0, this._invertNormalMapY ? -1.0 : 1.0);\n                        }\n                    }\n                }\n                // Point size\n                if (this.pointsCloud) {\n                    ubo.updateFloat(\"pointSize\", this.pointSize);\n                }\n                // Colors\n                if (defines.METALLICWORKFLOW) {\n                    TmpColors.Color3[0].r = this._metallic === undefined || this._metallic === null ? 1 : this._metallic;\n                    TmpColors.Color3[0].g = this._roughness === undefined || this._roughness === null ? 1 : this._roughness;\n                    ubo.updateColor4(\"vReflectivityColor\", TmpColors.Color3[0], 1);\n                    const ior = (_b = (_a = this.subSurface) === null || _a === void 0 ? void 0 : _a._indexOfRefraction) !== null && _b !== void 0 ? _b : 1.5;\n                    const outsideIOR = 1; // consider air as clear coat and other layers would remap in the shader.\n                    // We are here deriving our default reflectance from a common value for none metallic surface.\n                    // Based of the schlick fresnel approximation model\n                    // for dielectrics.\n                    const f0 = Math.pow((ior - outsideIOR) / (ior + outsideIOR), 2);\n                    // Tweak the default F0 and F90 based on our given setup\n                    this._metallicReflectanceColor.scaleToRef(f0 * this._metallicF0Factor, TmpColors.Color3[0]);\n                    const metallicF90 = this._metallicF0Factor;\n                    ubo.updateColor4(\"vMetallicReflectanceFactors\", TmpColors.Color3[0], metallicF90);\n                }\n                else {\n                    ubo.updateColor4(\"vReflectivityColor\", this._reflectivityColor, this._microSurface);\n                }\n                ubo.updateColor3(\"vEmissiveColor\", MaterialFlags.EmissiveTextureEnabled ? this._emissiveColor : Color3.BlackReadOnly);\n                ubo.updateColor3(\"vReflectionColor\", this._reflectionColor);\n                if (!defines.SS_REFRACTION && ((_c = this.subSurface) === null || _c === void 0 ? void 0 : _c._linkRefractionWithTransparency)) {\n                    ubo.updateColor4(\"vAlbedoColor\", this._albedoColor, 1);\n                }\n                else {\n                    ubo.updateColor4(\"vAlbedoColor\", this._albedoColor, this.alpha);\n                }\n                // Misc\n                this._lightingInfos.x = this._directIntensity;\n                this._lightingInfos.y = this._emissiveIntensity;\n                this._lightingInfos.z = this._environmentIntensity * scene.environmentIntensity;\n                this._lightingInfos.w = this._specularIntensity;\n                ubo.updateVector4(\"vLightingIntensity\", this._lightingInfos);\n                // Colors\n                scene.ambientColor.multiplyToRef(this._ambientColor, this._globalAmbientColor);\n                ubo.updateColor3(\"vAmbientColor\", this._globalAmbientColor);\n                ubo.updateFloat2(\"vDebugMode\", this._debugLimit, this._debugFactor);\n            }\n            // Textures\n            if (scene.texturesEnabled) {\n                if (this._albedoTexture && MaterialFlags.DiffuseTextureEnabled) {\n                    ubo.setTexture(\"albedoSampler\", this._albedoTexture);\n                }\n                if (this._ambientTexture && MaterialFlags.AmbientTextureEnabled) {\n                    ubo.setTexture(\"ambientSampler\", this._ambientTexture);\n                }\n                if (this._opacityTexture && MaterialFlags.OpacityTextureEnabled) {\n                    ubo.setTexture(\"opacitySampler\", this._opacityTexture);\n                }\n                if (reflectionTexture && MaterialFlags.ReflectionTextureEnabled) {\n                    if (defines.LODBASEDMICROSFURACE) {\n                        ubo.setTexture(\"reflectionSampler\", reflectionTexture);\n                    }\n                    else {\n                        ubo.setTexture(\"reflectionSampler\", reflectionTexture._lodTextureMid || reflectionTexture);\n                        ubo.setTexture(\"reflectionSamplerLow\", reflectionTexture._lodTextureLow || reflectionTexture);\n                        ubo.setTexture(\"reflectionSamplerHigh\", reflectionTexture._lodTextureHigh || reflectionTexture);\n                    }\n                    if (defines.USEIRRADIANCEMAP) {\n                        ubo.setTexture(\"irradianceSampler\", reflectionTexture.irradianceTexture);\n                    }\n                }\n                if (defines.ENVIRONMENTBRDF) {\n                    ubo.setTexture(\"environmentBrdfSampler\", this._environmentBRDFTexture);\n                }\n                if (this._emissiveTexture && MaterialFlags.EmissiveTextureEnabled) {\n                    ubo.setTexture(\"emissiveSampler\", this._emissiveTexture);\n                }\n                if (this._lightmapTexture && MaterialFlags.LightmapTextureEnabled) {\n                    ubo.setTexture(\"lightmapSampler\", this._lightmapTexture);\n                }\n                if (MaterialFlags.SpecularTextureEnabled) {\n                    if (this._metallicTexture) {\n                        ubo.setTexture(\"reflectivitySampler\", this._metallicTexture);\n                    }\n                    else if (this._reflectivityTexture) {\n                        ubo.setTexture(\"reflectivitySampler\", this._reflectivityTexture);\n                    }\n                    if (this._metallicReflectanceTexture) {\n                        ubo.setTexture(\"metallicReflectanceSampler\", this._metallicReflectanceTexture);\n                    }\n                    if (this._reflectanceTexture && defines.REFLECTANCE) {\n                        ubo.setTexture(\"reflectanceSampler\", this._reflectanceTexture);\n                    }\n                    if (this._microSurfaceTexture) {\n                        ubo.setTexture(\"microSurfaceSampler\", this._microSurfaceTexture);\n                    }\n                }\n                if (this._bumpTexture && engine.getCaps().standardDerivatives && MaterialFlags.BumpTextureEnabled && !this._disableBumpMap) {\n                    ubo.setTexture(\"bumpSampler\", this._bumpTexture);\n                }\n            }\n            // OIT with depth peeling\n            if (this.getScene().useOrderIndependentTransparency && this.needAlphaBlendingForMesh(mesh)) {\n                this.getScene().depthPeelingRenderer.bind(effect);\n            }\n            this._eventInfo.subMesh = subMesh;\n            this._callbackPluginEventBindForSubMesh(this._eventInfo);\n            // Clip plane\n            bindClipPlane(this._activeEffect, this, scene);\n            this.bindEyePosition(effect);\n        }\n        else if (scene.getEngine()._features.needToAlwaysBindUniformBuffers) {\n            this._needToBindSceneUbo = true;\n        }\n        if (mustRebind || !this.isFrozen) {\n            // Lights\n            if (scene.lightsEnabled && !this._disableLighting) {\n                MaterialHelper.BindLights(scene, mesh, this._activeEffect, defines, this._maxSimultaneousLights);\n            }\n            // View\n            if ((scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE) || reflectionTexture || mesh.receiveShadows || defines.PREPASS) {\n                this.bindView(effect);\n            }\n            // Fog\n            MaterialHelper.BindFogParameters(scene, mesh, this._activeEffect, true);\n            // Morph targets\n            if (defines.NUM_MORPH_INFLUENCERS) {\n                MaterialHelper.BindMorphTargetParameters(mesh, this._activeEffect);\n            }\n            if (defines.BAKED_VERTEX_ANIMATION_TEXTURE) {\n                (_d = mesh.bakedVertexAnimationManager) === null || _d === void 0 ? void 0 : _d.bind(effect, defines.INSTANCES);\n            }\n            // image processing\n            this._imageProcessingConfiguration.bind(this._activeEffect);\n            // Log. depth\n            MaterialHelper.BindLogDepth(defines, this._activeEffect, scene);\n        }\n        this._afterBind(mesh, this._activeEffect);\n        ubo.update();\n    }\n    /**\n     * Returns the animatable textures.\n     * If material have animatable metallic texture, then reflectivity texture will not be returned, even if it has animations.\n     * @returns - Array of animatable textures.\n     */\n    getAnimatables() {\n        const results = super.getAnimatables();\n        if (this._albedoTexture && this._albedoTexture.animations && this._albedoTexture.animations.length > 0) {\n            results.push(this._albedoTexture);\n        }\n        if (this._ambientTexture && this._ambientTexture.animations && this._ambientTexture.animations.length > 0) {\n            results.push(this._ambientTexture);\n        }\n        if (this._opacityTexture && this._opacityTexture.animations && this._opacityTexture.animations.length > 0) {\n            results.push(this._opacityTexture);\n        }\n        if (this._reflectionTexture && this._reflectionTexture.animations && this._reflectionTexture.animations.length > 0) {\n            results.push(this._reflectionTexture);\n        }\n        if (this._emissiveTexture && this._emissiveTexture.animations && this._emissiveTexture.animations.length > 0) {\n            results.push(this._emissiveTexture);\n        }\n        if (this._metallicTexture && this._metallicTexture.animations && this._metallicTexture.animations.length > 0) {\n            results.push(this._metallicTexture);\n        }\n        else if (this._reflectivityTexture && this._reflectivityTexture.animations && this._reflectivityTexture.animations.length > 0) {\n            results.push(this._reflectivityTexture);\n        }\n        if (this._bumpTexture && this._bumpTexture.animations && this._bumpTexture.animations.length > 0) {\n            results.push(this._bumpTexture);\n        }\n        if (this._lightmapTexture && this._lightmapTexture.animations && this._lightmapTexture.animations.length > 0) {\n            results.push(this._lightmapTexture);\n        }\n        if (this._metallicReflectanceTexture && this._metallicReflectanceTexture.animations && this._metallicReflectanceTexture.animations.length > 0) {\n            results.push(this._metallicReflectanceTexture);\n        }\n        if (this._reflectanceTexture && this._reflectanceTexture.animations && this._reflectanceTexture.animations.length > 0) {\n            results.push(this._reflectanceTexture);\n        }\n        if (this._microSurfaceTexture && this._microSurfaceTexture.animations && this._microSurfaceTexture.animations.length > 0) {\n            results.push(this._microSurfaceTexture);\n        }\n        return results;\n    }\n    /**\n     * Returns the texture used for reflections.\n     * @returns - Reflection texture if present.  Otherwise, returns the environment texture.\n     */\n    _getReflectionTexture() {\n        if (this._reflectionTexture) {\n            return this._reflectionTexture;\n        }\n        return this.getScene().environmentTexture;\n    }\n    /**\n     * Returns an array of the actively used textures.\n     * @returns - Array of BaseTextures\n     */\n    getActiveTextures() {\n        const activeTextures = super.getActiveTextures();\n        if (this._albedoTexture) {\n            activeTextures.push(this._albedoTexture);\n        }\n        if (this._ambientTexture) {\n            activeTextures.push(this._ambientTexture);\n        }\n        if (this._opacityTexture) {\n            activeTextures.push(this._opacityTexture);\n        }\n        if (this._reflectionTexture) {\n            activeTextures.push(this._reflectionTexture);\n        }\n        if (this._emissiveTexture) {\n            activeTextures.push(this._emissiveTexture);\n        }\n        if (this._reflectivityTexture) {\n            activeTextures.push(this._reflectivityTexture);\n        }\n        if (this._metallicTexture) {\n            activeTextures.push(this._metallicTexture);\n        }\n        if (this._metallicReflectanceTexture) {\n            activeTextures.push(this._metallicReflectanceTexture);\n        }\n        if (this._reflectanceTexture) {\n            activeTextures.push(this._reflectanceTexture);\n        }\n        if (this._microSurfaceTexture) {\n            activeTextures.push(this._microSurfaceTexture);\n        }\n        if (this._bumpTexture) {\n            activeTextures.push(this._bumpTexture);\n        }\n        if (this._lightmapTexture) {\n            activeTextures.push(this._lightmapTexture);\n        }\n        return activeTextures;\n    }\n    /**\n     * Checks to see if a texture is used in the material.\n     * @param texture - Base texture to use.\n     * @returns - Boolean specifying if a texture is used in the material.\n     */\n    hasTexture(texture) {\n        if (super.hasTexture(texture)) {\n            return true;\n        }\n        if (this._albedoTexture === texture) {\n            return true;\n        }\n        if (this._ambientTexture === texture) {\n            return true;\n        }\n        if (this._opacityTexture === texture) {\n            return true;\n        }\n        if (this._reflectionTexture === texture) {\n            return true;\n        }\n        if (this._emissiveTexture === texture) {\n            return true;\n        }\n        if (this._reflectivityTexture === texture) {\n            return true;\n        }\n        if (this._metallicTexture === texture) {\n            return true;\n        }\n        if (this._metallicReflectanceTexture === texture) {\n            return true;\n        }\n        if (this._reflectanceTexture === texture) {\n            return true;\n        }\n        if (this._microSurfaceTexture === texture) {\n            return true;\n        }\n        if (this._bumpTexture === texture) {\n            return true;\n        }\n        if (this._lightmapTexture === texture) {\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Sets the required values to the prepass renderer.\n     * It can't be sets when subsurface scattering of this material is disabled.\n     * When scene have ability to enable subsurface prepass effect, it will enable.\n     */\n    setPrePassRenderer() {\n        var _a;\n        if (!((_a = this.subSurface) === null || _a === void 0 ? void 0 : _a.isScatteringEnabled)) {\n            return false;\n        }\n        const subSurfaceConfiguration = this.getScene().enableSubSurfaceForPrePass();\n        if (subSurfaceConfiguration) {\n            subSurfaceConfiguration.enabled = true;\n        }\n        return true;\n    }\n    /**\n     * Disposes the resources of the material.\n     * @param forceDisposeEffect - Forces the disposal of effects.\n     * @param forceDisposeTextures - Forces the disposal of all textures.\n     */\n    dispose(forceDisposeEffect, forceDisposeTextures) {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;\n        if (forceDisposeTextures) {\n            if (this._environmentBRDFTexture && this.getScene().environmentBRDFTexture !== this._environmentBRDFTexture) {\n                this._environmentBRDFTexture.dispose();\n            }\n            (_a = this._albedoTexture) === null || _a === void 0 ? void 0 : _a.dispose();\n            (_b = this._ambientTexture) === null || _b === void 0 ? void 0 : _b.dispose();\n            (_c = this._opacityTexture) === null || _c === void 0 ? void 0 : _c.dispose();\n            (_d = this._reflectionTexture) === null || _d === void 0 ? void 0 : _d.dispose();\n            (_e = this._emissiveTexture) === null || _e === void 0 ? void 0 : _e.dispose();\n            (_f = this._metallicTexture) === null || _f === void 0 ? void 0 : _f.dispose();\n            (_g = this._reflectivityTexture) === null || _g === void 0 ? void 0 : _g.dispose();\n            (_h = this._bumpTexture) === null || _h === void 0 ? void 0 : _h.dispose();\n            (_j = this._lightmapTexture) === null || _j === void 0 ? void 0 : _j.dispose();\n            (_k = this._metallicReflectanceTexture) === null || _k === void 0 ? void 0 : _k.dispose();\n            (_l = this._reflectanceTexture) === null || _l === void 0 ? void 0 : _l.dispose();\n            (_m = this._microSurfaceTexture) === null || _m === void 0 ? void 0 : _m.dispose();\n        }\n        this._renderTargets.dispose();\n        if (this._imageProcessingConfiguration && this._imageProcessingObserver) {\n            this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);\n        }\n        super.dispose(forceDisposeEffect, forceDisposeTextures);\n    }\n}\n/**\n * PBRMaterialTransparencyMode: No transparency mode, Alpha channel is not use.\n */\nPBRBaseMaterial.PBRMATERIAL_OPAQUE = Material.MATERIAL_OPAQUE;\n/**\n * PBRMaterialTransparencyMode: Alpha Test mode, pixel are discarded below a certain threshold defined by the alpha cutoff value.\n */\nPBRBaseMaterial.PBRMATERIAL_ALPHATEST = Material.MATERIAL_ALPHATEST;\n/**\n * PBRMaterialTransparencyMode: Pixels are blended (according to the alpha mode) with the already drawn pixels in the current frame buffer.\n */\nPBRBaseMaterial.PBRMATERIAL_ALPHABLEND = Material.MATERIAL_ALPHABLEND;\n/**\n * PBRMaterialTransparencyMode: Pixels are blended (according to the alpha mode) with the already drawn pixels in the current frame buffer.\n * They are also discarded below the alpha cutoff threshold to improve performances.\n */\nPBRBaseMaterial.PBRMATERIAL_ALPHATESTANDBLEND = Material.MATERIAL_ALPHATESTANDBLEND;\n/**\n * Defines the default value of how much AO map is occluding the analytical lights\n * (point spot...).\n */\nPBRBaseMaterial.DEFAULT_AO_ON_ANALYTICAL_LIGHTS = 0;\n/**\n * PBRMaterialLightFalloff Physical: light is falling off following the inverse squared distance law.\n */\nPBRBaseMaterial.LIGHTFALLOFF_PHYSICAL = 0;\n/**\n * PBRMaterialLightFalloff gltf: light is falling off as described in the gltf moving to PBR document\n * to enhance interoperability with other engines.\n */\nPBRBaseMaterial.LIGHTFALLOFF_GLTF = 1;\n/**\n * PBRMaterialLightFalloff Standard: light is falling off like in the standard material\n * to enhance interoperability with other materials.\n */\nPBRBaseMaterial.LIGHTFALLOFF_STANDARD = 2;\n__decorate([\n    serializeAsImageProcessingConfiguration()\n], PBRBaseMaterial.prototype, \"_imageProcessingConfiguration\", void 0);\n__decorate([\n    expandToProperty(\"_markAllSubMeshesAsMiscDirty\")\n], PBRBaseMaterial.prototype, \"debugMode\", void 0);\n__decorate([\n    serialize()\n], PBRBaseMaterial.prototype, \"useLogarithmicDepth\", null);\n//# sourceMappingURL=pbrBaseMaterial.js.map","import { __decorate } from \"../../tslib.es6.js\";\nimport { serialize, serializeAsTexture, expandToProperty, serializeAsColor3 } from \"../../Misc/decorators.js\";\nimport { Color3 } from \"../../Maths/math.color.js\";\nimport { MaterialFlags } from \"../materialFlags.js\";\nimport { MaterialHelper } from \"../../Materials/materialHelper.js\";\n\nimport { MaterialPluginBase } from \"../materialPluginBase.js\";\nimport { MaterialDefines } from \"../materialDefines.js\";\n/**\n * @internal\n */\nexport class MaterialClearCoatDefines extends MaterialDefines {\n    constructor() {\n        super(...arguments);\n        this.CLEARCOAT = false;\n        this.CLEARCOAT_DEFAULTIOR = false;\n        this.CLEARCOAT_TEXTURE = false;\n        this.CLEARCOAT_TEXTURE_ROUGHNESS = false;\n        this.CLEARCOAT_TEXTUREDIRECTUV = 0;\n        this.CLEARCOAT_TEXTURE_ROUGHNESSDIRECTUV = 0;\n        this.CLEARCOAT_BUMP = false;\n        this.CLEARCOAT_BUMPDIRECTUV = 0;\n        this.CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE = false;\n        this.CLEARCOAT_TEXTURE_ROUGHNESS_IDENTICAL = false;\n        this.CLEARCOAT_REMAP_F0 = false;\n        this.CLEARCOAT_TINT = false;\n        this.CLEARCOAT_TINT_TEXTURE = false;\n        this.CLEARCOAT_TINT_TEXTUREDIRECTUV = 0;\n        this.CLEARCOAT_TINT_GAMMATEXTURE = false;\n    }\n}\n/**\n * Plugin that implements the clear coat component of the PBR material\n */\nexport class PBRClearCoatConfiguration extends MaterialPluginBase {\n    /** @internal */\n    _markAllSubMeshesAsTexturesDirty() {\n        this._enable(this._isEnabled);\n        this._internalMarkAllSubMeshesAsTexturesDirty();\n    }\n    constructor(material, addToPluginList = true) {\n        super(material, \"PBRClearCoat\", 100, new MaterialClearCoatDefines(), addToPluginList);\n        this._isEnabled = false;\n        /**\n         * Defines if the clear coat is enabled in the material.\n         */\n        this.isEnabled = false;\n        /**\n         * Defines the clear coat layer strength (between 0 and 1) it defaults to 1.\n         */\n        this.intensity = 1;\n        /**\n         * Defines the clear coat layer roughness.\n         */\n        this.roughness = 0;\n        this._indexOfRefraction = PBRClearCoatConfiguration._DefaultIndexOfRefraction;\n        /**\n         * Defines the index of refraction of the clear coat.\n         * This defaults to 1.5 corresponding to a 0.04 f0 or a 4% reflectance at normal incidence\n         * The default fits with a polyurethane material.\n         * Changing the default value is more performance intensive.\n         */\n        this.indexOfRefraction = PBRClearCoatConfiguration._DefaultIndexOfRefraction;\n        this._texture = null;\n        /**\n         * Stores the clear coat values in a texture (red channel is intensity and green channel is roughness)\n         * If useRoughnessFromMainTexture is false, the green channel of texture is not used and the green channel of textureRoughness is used instead\n         * if textureRoughness is not empty, else no texture roughness is used\n         */\n        this.texture = null;\n        this._useRoughnessFromMainTexture = true;\n        /**\n         * Indicates that the green channel of the texture property will be used for roughness (default: true)\n         * If false, the green channel from textureRoughness is used for roughness\n         */\n        this.useRoughnessFromMainTexture = true;\n        this._textureRoughness = null;\n        /**\n         * Stores the clear coat roughness in a texture (green channel)\n         * Not used if useRoughnessFromMainTexture is true\n         */\n        this.textureRoughness = null;\n        this._remapF0OnInterfaceChange = true;\n        /**\n         * Defines if the F0 value should be remapped to account for the interface change in the material.\n         */\n        this.remapF0OnInterfaceChange = true;\n        this._bumpTexture = null;\n        /**\n         * Define the clear coat specific bump texture.\n         */\n        this.bumpTexture = null;\n        this._isTintEnabled = false;\n        /**\n         * Defines if the clear coat tint is enabled in the material.\n         */\n        this.isTintEnabled = false;\n        /**\n         * Defines the clear coat tint of the material.\n         * This is only use if tint is enabled\n         */\n        this.tintColor = Color3.White();\n        /**\n         * Defines the distance at which the tint color should be found in the\n         * clear coat media.\n         * This is only use if tint is enabled\n         */\n        this.tintColorAtDistance = 1;\n        /**\n         * Defines the clear coat layer thickness.\n         * This is only use if tint is enabled\n         */\n        this.tintThickness = 1;\n        this._tintTexture = null;\n        /**\n         * Stores the clear tint values in a texture.\n         * rgb is tint\n         * a is a thickness factor\n         */\n        this.tintTexture = null;\n        this._internalMarkAllSubMeshesAsTexturesDirty = material._dirtyCallbacks[1];\n    }\n    isReadyForSubMesh(defines, scene, engine) {\n        if (!this._isEnabled) {\n            return true;\n        }\n        const disableBumpMap = this._material._disableBumpMap;\n        if (defines._areTexturesDirty) {\n            if (scene.texturesEnabled) {\n                if (this._texture && MaterialFlags.ClearCoatTextureEnabled) {\n                    if (!this._texture.isReadyOrNotBlocking()) {\n                        return false;\n                    }\n                }\n                if (this._textureRoughness && MaterialFlags.ClearCoatTextureEnabled) {\n                    if (!this._textureRoughness.isReadyOrNotBlocking()) {\n                        return false;\n                    }\n                }\n                if (engine.getCaps().standardDerivatives && this._bumpTexture && MaterialFlags.ClearCoatBumpTextureEnabled && !disableBumpMap) {\n                    // Bump texture cannot be not blocking.\n                    if (!this._bumpTexture.isReady()) {\n                        return false;\n                    }\n                }\n                if (this._isTintEnabled && this._tintTexture && MaterialFlags.ClearCoatTintTextureEnabled) {\n                    if (!this._tintTexture.isReadyOrNotBlocking()) {\n                        return false;\n                    }\n                }\n            }\n        }\n        return true;\n    }\n    prepareDefinesBeforeAttributes(defines, scene) {\n        var _a;\n        if (this._isEnabled) {\n            defines.CLEARCOAT = true;\n            defines.CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE = this._useRoughnessFromMainTexture;\n            defines.CLEARCOAT_TEXTURE_ROUGHNESS_IDENTICAL =\n                this._texture !== null && this._texture._texture === ((_a = this._textureRoughness) === null || _a === void 0 ? void 0 : _a._texture) && this._texture.checkTransformsAreIdentical(this._textureRoughness);\n            defines.CLEARCOAT_REMAP_F0 = this._remapF0OnInterfaceChange;\n            if (defines._areTexturesDirty) {\n                if (scene.texturesEnabled) {\n                    if (this._texture && MaterialFlags.ClearCoatTextureEnabled) {\n                        MaterialHelper.PrepareDefinesForMergedUV(this._texture, defines, \"CLEARCOAT_TEXTURE\");\n                    }\n                    else {\n                        defines.CLEARCOAT_TEXTURE = false;\n                    }\n                    if (this._textureRoughness && MaterialFlags.ClearCoatTextureEnabled) {\n                        MaterialHelper.PrepareDefinesForMergedUV(this._textureRoughness, defines, \"CLEARCOAT_TEXTURE_ROUGHNESS\");\n                    }\n                    else {\n                        defines.CLEARCOAT_TEXTURE_ROUGHNESS = false;\n                    }\n                    if (this._bumpTexture && MaterialFlags.ClearCoatBumpTextureEnabled) {\n                        MaterialHelper.PrepareDefinesForMergedUV(this._bumpTexture, defines, \"CLEARCOAT_BUMP\");\n                    }\n                    else {\n                        defines.CLEARCOAT_BUMP = false;\n                    }\n                    defines.CLEARCOAT_DEFAULTIOR = this._indexOfRefraction === PBRClearCoatConfiguration._DefaultIndexOfRefraction;\n                    if (this._isTintEnabled) {\n                        defines.CLEARCOAT_TINT = true;\n                        if (this._tintTexture && MaterialFlags.ClearCoatTintTextureEnabled) {\n                            MaterialHelper.PrepareDefinesForMergedUV(this._tintTexture, defines, \"CLEARCOAT_TINT_TEXTURE\");\n                            defines.CLEARCOAT_TINT_GAMMATEXTURE = this._tintTexture.gammaSpace;\n                        }\n                        else {\n                            defines.CLEARCOAT_TINT_TEXTURE = false;\n                        }\n                    }\n                    else {\n                        defines.CLEARCOAT_TINT = false;\n                        defines.CLEARCOAT_TINT_TEXTURE = false;\n                    }\n                }\n            }\n        }\n        else {\n            defines.CLEARCOAT = false;\n            defines.CLEARCOAT_TEXTURE = false;\n            defines.CLEARCOAT_TEXTURE_ROUGHNESS = false;\n            defines.CLEARCOAT_BUMP = false;\n            defines.CLEARCOAT_TINT = false;\n            defines.CLEARCOAT_TINT_TEXTURE = false;\n            defines.CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE = false;\n            defines.CLEARCOAT_TEXTURE_ROUGHNESS_IDENTICAL = false;\n            defines.CLEARCOAT_DEFAULTIOR = false;\n            defines.CLEARCOAT_TEXTUREDIRECTUV = 0;\n            defines.CLEARCOAT_TEXTURE_ROUGHNESSDIRECTUV = 0;\n            defines.CLEARCOAT_BUMPDIRECTUV = 0;\n            defines.CLEARCOAT_REMAP_F0 = false;\n            defines.CLEARCOAT_TINT_TEXTUREDIRECTUV = 0;\n            defines.CLEARCOAT_TINT_GAMMATEXTURE = false;\n        }\n    }\n    bindForSubMesh(uniformBuffer, scene, engine, subMesh) {\n        var _a, _b, _c, _d, _e, _f, _g, _h;\n        if (!this._isEnabled) {\n            return;\n        }\n        const defines = subMesh.materialDefines;\n        const isFrozen = this._material.isFrozen;\n        const disableBumpMap = this._material._disableBumpMap;\n        const invertNormalMapX = this._material._invertNormalMapX;\n        const invertNormalMapY = this._material._invertNormalMapY;\n        const identicalTextures = defines.CLEARCOAT_TEXTURE_ROUGHNESS_IDENTICAL;\n        if (!uniformBuffer.useUbo || !isFrozen || !uniformBuffer.isSync) {\n            if (identicalTextures && MaterialFlags.ClearCoatTextureEnabled) {\n                uniformBuffer.updateFloat4(\"vClearCoatInfos\", this._texture.coordinatesIndex, this._texture.level, -1, -1);\n                MaterialHelper.BindTextureMatrix(this._texture, uniformBuffer, \"clearCoat\");\n            }\n            else if ((this._texture || this._textureRoughness) && MaterialFlags.ClearCoatTextureEnabled) {\n                uniformBuffer.updateFloat4(\"vClearCoatInfos\", (_b = (_a = this._texture) === null || _a === void 0 ? void 0 : _a.coordinatesIndex) !== null && _b !== void 0 ? _b : 0, (_d = (_c = this._texture) === null || _c === void 0 ? void 0 : _c.level) !== null && _d !== void 0 ? _d : 0, (_f = (_e = this._textureRoughness) === null || _e === void 0 ? void 0 : _e.coordinatesIndex) !== null && _f !== void 0 ? _f : 0, (_h = (_g = this._textureRoughness) === null || _g === void 0 ? void 0 : _g.level) !== null && _h !== void 0 ? _h : 0);\n                if (this._texture) {\n                    MaterialHelper.BindTextureMatrix(this._texture, uniformBuffer, \"clearCoat\");\n                }\n                if (this._textureRoughness && !identicalTextures && !defines.CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE) {\n                    MaterialHelper.BindTextureMatrix(this._textureRoughness, uniformBuffer, \"clearCoatRoughness\");\n                }\n            }\n            if (this._bumpTexture && engine.getCaps().standardDerivatives && MaterialFlags.ClearCoatTextureEnabled && !disableBumpMap) {\n                uniformBuffer.updateFloat2(\"vClearCoatBumpInfos\", this._bumpTexture.coordinatesIndex, this._bumpTexture.level);\n                MaterialHelper.BindTextureMatrix(this._bumpTexture, uniformBuffer, \"clearCoatBump\");\n                if (scene._mirroredCameraPosition) {\n                    uniformBuffer.updateFloat2(\"vClearCoatTangentSpaceParams\", invertNormalMapX ? 1.0 : -1.0, invertNormalMapY ? 1.0 : -1.0);\n                }\n                else {\n                    uniformBuffer.updateFloat2(\"vClearCoatTangentSpaceParams\", invertNormalMapX ? -1.0 : 1.0, invertNormalMapY ? -1.0 : 1.0);\n                }\n            }\n            if (this._tintTexture && MaterialFlags.ClearCoatTintTextureEnabled) {\n                uniformBuffer.updateFloat2(\"vClearCoatTintInfos\", this._tintTexture.coordinatesIndex, this._tintTexture.level);\n                MaterialHelper.BindTextureMatrix(this._tintTexture, uniformBuffer, \"clearCoatTint\");\n            }\n            // Clear Coat General params\n            uniformBuffer.updateFloat2(\"vClearCoatParams\", this.intensity, this.roughness);\n            // Clear Coat Refraction params\n            const a = 1 - this._indexOfRefraction;\n            const b = 1 + this._indexOfRefraction;\n            const f0 = Math.pow(-a / b, 2); // Schlicks approx: (ior1 - ior2) / (ior1 + ior2) where ior2 for air is close to vacuum = 1.\n            const eta = 1 / this._indexOfRefraction;\n            uniformBuffer.updateFloat4(\"vClearCoatRefractionParams\", f0, eta, a, b);\n            if (this._isTintEnabled) {\n                uniformBuffer.updateFloat4(\"vClearCoatTintParams\", this.tintColor.r, this.tintColor.g, this.tintColor.b, Math.max(0.00001, this.tintThickness));\n                uniformBuffer.updateFloat(\"clearCoatColorAtDistance\", Math.max(0.00001, this.tintColorAtDistance));\n            }\n        }\n        // Textures\n        if (scene.texturesEnabled) {\n            if (this._texture && MaterialFlags.ClearCoatTextureEnabled) {\n                uniformBuffer.setTexture(\"clearCoatSampler\", this._texture);\n            }\n            if (this._textureRoughness && !identicalTextures && !defines.CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE && MaterialFlags.ClearCoatTextureEnabled) {\n                uniformBuffer.setTexture(\"clearCoatRoughnessSampler\", this._textureRoughness);\n            }\n            if (this._bumpTexture && engine.getCaps().standardDerivatives && MaterialFlags.ClearCoatBumpTextureEnabled && !disableBumpMap) {\n                uniformBuffer.setTexture(\"clearCoatBumpSampler\", this._bumpTexture);\n            }\n            if (this._isTintEnabled && this._tintTexture && MaterialFlags.ClearCoatTintTextureEnabled) {\n                uniformBuffer.setTexture(\"clearCoatTintSampler\", this._tintTexture);\n            }\n        }\n    }\n    hasTexture(texture) {\n        if (this._texture === texture) {\n            return true;\n        }\n        if (this._textureRoughness === texture) {\n            return true;\n        }\n        if (this._bumpTexture === texture) {\n            return true;\n        }\n        if (this._tintTexture === texture) {\n            return true;\n        }\n        return false;\n    }\n    getActiveTextures(activeTextures) {\n        if (this._texture) {\n            activeTextures.push(this._texture);\n        }\n        if (this._textureRoughness) {\n            activeTextures.push(this._textureRoughness);\n        }\n        if (this._bumpTexture) {\n            activeTextures.push(this._bumpTexture);\n        }\n        if (this._tintTexture) {\n            activeTextures.push(this._tintTexture);\n        }\n    }\n    getAnimatables(animatables) {\n        if (this._texture && this._texture.animations && this._texture.animations.length > 0) {\n            animatables.push(this._texture);\n        }\n        if (this._textureRoughness && this._textureRoughness.animations && this._textureRoughness.animations.length > 0) {\n            animatables.push(this._textureRoughness);\n        }\n        if (this._bumpTexture && this._bumpTexture.animations && this._bumpTexture.animations.length > 0) {\n            animatables.push(this._bumpTexture);\n        }\n        if (this._tintTexture && this._tintTexture.animations && this._tintTexture.animations.length > 0) {\n            animatables.push(this._tintTexture);\n        }\n    }\n    dispose(forceDisposeTextures) {\n        var _a, _b, _c, _d;\n        if (forceDisposeTextures) {\n            (_a = this._texture) === null || _a === void 0 ? void 0 : _a.dispose();\n            (_b = this._textureRoughness) === null || _b === void 0 ? void 0 : _b.dispose();\n            (_c = this._bumpTexture) === null || _c === void 0 ? void 0 : _c.dispose();\n            (_d = this._tintTexture) === null || _d === void 0 ? void 0 : _d.dispose();\n        }\n    }\n    getClassName() {\n        return \"PBRClearCoatConfiguration\";\n    }\n    addFallbacks(defines, fallbacks, currentRank) {\n        if (defines.CLEARCOAT_BUMP) {\n            fallbacks.addFallback(currentRank++, \"CLEARCOAT_BUMP\");\n        }\n        if (defines.CLEARCOAT_TINT) {\n            fallbacks.addFallback(currentRank++, \"CLEARCOAT_TINT\");\n        }\n        if (defines.CLEARCOAT) {\n            fallbacks.addFallback(currentRank++, \"CLEARCOAT\");\n        }\n        return currentRank;\n    }\n    getSamplers(samplers) {\n        samplers.push(\"clearCoatSampler\", \"clearCoatRoughnessSampler\", \"clearCoatBumpSampler\", \"clearCoatTintSampler\");\n    }\n    getUniforms() {\n        return {\n            ubo: [\n                { name: \"vClearCoatParams\", size: 2, type: \"vec2\" },\n                { name: \"vClearCoatRefractionParams\", size: 4, type: \"vec4\" },\n                { name: \"vClearCoatInfos\", size: 4, type: \"vec4\" },\n                { name: \"clearCoatMatrix\", size: 16, type: \"mat4\" },\n                { name: \"clearCoatRoughnessMatrix\", size: 16, type: \"mat4\" },\n                { name: \"vClearCoatBumpInfos\", size: 2, type: \"vec2\" },\n                { name: \"vClearCoatTangentSpaceParams\", size: 2, type: \"vec2\" },\n                { name: \"clearCoatBumpMatrix\", size: 16, type: \"mat4\" },\n                { name: \"vClearCoatTintParams\", size: 4, type: \"vec4\" },\n                { name: \"clearCoatColorAtDistance\", size: 1, type: \"float\" },\n                { name: \"vClearCoatTintInfos\", size: 2, type: \"vec2\" },\n                { name: \"clearCoatTintMatrix\", size: 16, type: \"mat4\" },\n            ],\n        };\n    }\n}\n/**\n * This defaults to 1.5 corresponding to a 0.04 f0 or a 4% reflectance at normal incidence\n * The default fits with a polyurethane material.\n * @internal\n */\nPBRClearCoatConfiguration._DefaultIndexOfRefraction = 1.5;\n__decorate([\n    serialize(),\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], PBRClearCoatConfiguration.prototype, \"isEnabled\", void 0);\n__decorate([\n    serialize()\n], PBRClearCoatConfiguration.prototype, \"intensity\", void 0);\n__decorate([\n    serialize()\n], PBRClearCoatConfiguration.prototype, \"roughness\", void 0);\n__decorate([\n    serialize(),\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], PBRClearCoatConfiguration.prototype, \"indexOfRefraction\", void 0);\n__decorate([\n    serializeAsTexture(),\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], PBRClearCoatConfiguration.prototype, \"texture\", void 0);\n__decorate([\n    serialize(),\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], PBRClearCoatConfiguration.prototype, \"useRoughnessFromMainTexture\", void 0);\n__decorate([\n    serializeAsTexture(),\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], PBRClearCoatConfiguration.prototype, \"textureRoughness\", void 0);\n__decorate([\n    serialize(),\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], PBRClearCoatConfiguration.prototype, \"remapF0OnInterfaceChange\", void 0);\n__decorate([\n    serializeAsTexture(),\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], PBRClearCoatConfiguration.prototype, \"bumpTexture\", void 0);\n__decorate([\n    serialize(),\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], PBRClearCoatConfiguration.prototype, \"isTintEnabled\", void 0);\n__decorate([\n    serializeAsColor3()\n], PBRClearCoatConfiguration.prototype, \"tintColor\", void 0);\n__decorate([\n    serialize()\n], PBRClearCoatConfiguration.prototype, \"tintColorAtDistance\", void 0);\n__decorate([\n    serialize()\n], PBRClearCoatConfiguration.prototype, \"tintThickness\", void 0);\n__decorate([\n    serializeAsTexture(),\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], PBRClearCoatConfiguration.prototype, \"tintTexture\", void 0);\n//# sourceMappingURL=pbrClearCoatConfiguration.js.map","import { __decorate } from \"../../tslib.es6.js\";\nimport { serialize, serializeAsTexture, expandToProperty } from \"../../Misc/decorators.js\";\nimport { MaterialFlags } from \"../materialFlags.js\";\nimport { MaterialHelper } from \"../../Materials/materialHelper.js\";\n\nimport { MaterialPluginBase } from \"../materialPluginBase.js\";\nimport { MaterialDefines } from \"../materialDefines.js\";\n/**\n * @internal\n */\nexport class MaterialIridescenceDefines extends MaterialDefines {\n    constructor() {\n        super(...arguments);\n        this.IRIDESCENCE = false;\n        this.IRIDESCENCE_TEXTURE = false;\n        this.IRIDESCENCE_TEXTUREDIRECTUV = 0;\n        this.IRIDESCENCE_THICKNESS_TEXTURE = false;\n        this.IRIDESCENCE_THICKNESS_TEXTUREDIRECTUV = 0;\n        this.IRIDESCENCE_USE_THICKNESS_FROM_MAINTEXTURE = false;\n    }\n}\n/**\n * Plugin that implements the iridescence (thin film) component of the PBR material\n */\nexport class PBRIridescenceConfiguration extends MaterialPluginBase {\n    /** @internal */\n    _markAllSubMeshesAsTexturesDirty() {\n        this._enable(this._isEnabled);\n        this._internalMarkAllSubMeshesAsTexturesDirty();\n    }\n    constructor(material, addToPluginList = true) {\n        super(material, \"PBRIridescence\", 110, new MaterialIridescenceDefines(), addToPluginList);\n        this._isEnabled = false;\n        /**\n         * Defines if the iridescence is enabled in the material.\n         */\n        this.isEnabled = false;\n        /**\n         * Defines the iridescence layer strength (between 0 and 1) it defaults to 1.\n         */\n        this.intensity = 1;\n        /**\n         * Defines the minimum thickness of the thin-film layer given in nanometers (nm).\n         */\n        this.minimumThickness = PBRIridescenceConfiguration._DefaultMinimumThickness;\n        /**\n         * Defines the maximum thickness of the thin-film layer given in nanometers (nm). This will be the thickness used if not thickness texture has been set.\n         */\n        this.maximumThickness = PBRIridescenceConfiguration._DefaultMaximumThickness;\n        /**\n         * Defines the maximum thickness of the thin-film layer given in nanometers (nm).\n         */\n        this.indexOfRefraction = PBRIridescenceConfiguration._DefaultIndexOfRefraction;\n        this._texture = null;\n        /**\n         * Stores the iridescence intensity in a texture (red channel)\n         */\n        this.texture = null;\n        this._thicknessTexture = null;\n        /**\n         * Stores the iridescence thickness in a texture (green channel)\n         */\n        this.thicknessTexture = null;\n        this._internalMarkAllSubMeshesAsTexturesDirty = material._dirtyCallbacks[1];\n    }\n    isReadyForSubMesh(defines, scene) {\n        if (!this._isEnabled) {\n            return true;\n        }\n        if (defines._areTexturesDirty) {\n            if (scene.texturesEnabled) {\n                if (this._texture && MaterialFlags.IridescenceTextureEnabled) {\n                    if (!this._texture.isReadyOrNotBlocking()) {\n                        return false;\n                    }\n                }\n                if (this._thicknessTexture && MaterialFlags.IridescenceTextureEnabled) {\n                    if (!this._thicknessTexture.isReadyOrNotBlocking()) {\n                        return false;\n                    }\n                }\n            }\n        }\n        return true;\n    }\n    prepareDefinesBeforeAttributes(defines, scene) {\n        var _a;\n        if (this._isEnabled) {\n            defines.IRIDESCENCE = true;\n            defines.IRIDESCENCE_USE_THICKNESS_FROM_MAINTEXTURE =\n                this._texture !== null && this._texture._texture === ((_a = this._thicknessTexture) === null || _a === void 0 ? void 0 : _a._texture) && this._texture.checkTransformsAreIdentical(this._thicknessTexture);\n            if (defines._areTexturesDirty) {\n                if (scene.texturesEnabled) {\n                    if (this._texture && MaterialFlags.IridescenceTextureEnabled) {\n                        MaterialHelper.PrepareDefinesForMergedUV(this._texture, defines, \"IRIDESCENCE_TEXTURE\");\n                    }\n                    else {\n                        defines.IRIDESCENCE_TEXTURE = false;\n                    }\n                    if (!defines.IRIDESCENCE_USE_THICKNESS_FROM_MAINTEXTURE && this._thicknessTexture && MaterialFlags.IridescenceTextureEnabled) {\n                        MaterialHelper.PrepareDefinesForMergedUV(this._thicknessTexture, defines, \"IRIDESCENCE_THICKNESS_TEXTURE\");\n                    }\n                    else {\n                        defines.IRIDESCENCE_THICKNESS_TEXTURE = false;\n                    }\n                }\n            }\n        }\n        else {\n            defines.IRIDESCENCE = false;\n            defines.IRIDESCENCE_TEXTURE = false;\n            defines.IRIDESCENCE_THICKNESS_TEXTURE = false;\n            defines.IRIDESCENCE_USE_THICKNESS_FROM_MAINTEXTURE = false;\n            defines.IRIDESCENCE_TEXTUREDIRECTUV = 0;\n            defines.IRIDESCENCE_THICKNESS_TEXTUREDIRECTUV = 0;\n        }\n    }\n    bindForSubMesh(uniformBuffer, scene, engine, subMesh) {\n        var _a, _b, _c, _d, _e, _f, _g, _h;\n        if (!this._isEnabled) {\n            return;\n        }\n        const defines = subMesh.materialDefines;\n        const isFrozen = this._material.isFrozen;\n        const identicalTextures = defines.IRIDESCENCE_USE_THICKNESS_FROM_MAINTEXTURE;\n        if (!uniformBuffer.useUbo || !isFrozen || !uniformBuffer.isSync) {\n            if (identicalTextures && MaterialFlags.IridescenceTextureEnabled) {\n                uniformBuffer.updateFloat4(\"vIridescenceInfos\", this._texture.coordinatesIndex, this._texture.level, -1, -1);\n                MaterialHelper.BindTextureMatrix(this._texture, uniformBuffer, \"iridescence\");\n            }\n            else if ((this._texture || this._thicknessTexture) && MaterialFlags.IridescenceTextureEnabled) {\n                uniformBuffer.updateFloat4(\"vIridescenceInfos\", (_b = (_a = this._texture) === null || _a === void 0 ? void 0 : _a.coordinatesIndex) !== null && _b !== void 0 ? _b : 0, (_d = (_c = this._texture) === null || _c === void 0 ? void 0 : _c.level) !== null && _d !== void 0 ? _d : 0, (_f = (_e = this._thicknessTexture) === null || _e === void 0 ? void 0 : _e.coordinatesIndex) !== null && _f !== void 0 ? _f : 0, (_h = (_g = this._thicknessTexture) === null || _g === void 0 ? void 0 : _g.level) !== null && _h !== void 0 ? _h : 0);\n                if (this._texture) {\n                    MaterialHelper.BindTextureMatrix(this._texture, uniformBuffer, \"iridescence\");\n                }\n                if (this._thicknessTexture && !identicalTextures && !defines.IRIDESCENCE_USE_THICKNESS_FROM_MAINTEXTURE) {\n                    MaterialHelper.BindTextureMatrix(this._thicknessTexture, uniformBuffer, \"iridescenceThickness\");\n                }\n            }\n            // Clear Coat General params\n            uniformBuffer.updateFloat4(\"vIridescenceParams\", this.intensity, this.indexOfRefraction, this.minimumThickness, this.maximumThickness);\n        }\n        // Textures\n        if (scene.texturesEnabled) {\n            if (this._texture && MaterialFlags.IridescenceTextureEnabled) {\n                uniformBuffer.setTexture(\"iridescenceSampler\", this._texture);\n            }\n            if (this._thicknessTexture && !identicalTextures && !defines.IRIDESCENCE_USE_THICKNESS_FROM_MAINTEXTURE && MaterialFlags.IridescenceTextureEnabled) {\n                uniformBuffer.setTexture(\"iridescenceThicknessSampler\", this._thicknessTexture);\n            }\n        }\n    }\n    hasTexture(texture) {\n        if (this._texture === texture) {\n            return true;\n        }\n        if (this._thicknessTexture === texture) {\n            return true;\n        }\n        return false;\n    }\n    getActiveTextures(activeTextures) {\n        if (this._texture) {\n            activeTextures.push(this._texture);\n        }\n        if (this._thicknessTexture) {\n            activeTextures.push(this._thicknessTexture);\n        }\n    }\n    getAnimatables(animatables) {\n        if (this._texture && this._texture.animations && this._texture.animations.length > 0) {\n            animatables.push(this._texture);\n        }\n        if (this._thicknessTexture && this._thicknessTexture.animations && this._thicknessTexture.animations.length > 0) {\n            animatables.push(this._thicknessTexture);\n        }\n    }\n    dispose(forceDisposeTextures) {\n        var _a, _b;\n        if (forceDisposeTextures) {\n            (_a = this._texture) === null || _a === void 0 ? void 0 : _a.dispose();\n            (_b = this._thicknessTexture) === null || _b === void 0 ? void 0 : _b.dispose();\n        }\n    }\n    getClassName() {\n        return \"PBRIridescenceConfiguration\";\n    }\n    addFallbacks(defines, fallbacks, currentRank) {\n        if (defines.IRIDESCENCE) {\n            fallbacks.addFallback(currentRank++, \"IRIDESCENCE\");\n        }\n        return currentRank;\n    }\n    getSamplers(samplers) {\n        samplers.push(\"iridescenceSampler\", \"iridescenceThicknessSampler\");\n    }\n    getUniforms() {\n        return {\n            ubo: [\n                { name: \"vIridescenceParams\", size: 4, type: \"vec4\" },\n                { name: \"vIridescenceInfos\", size: 4, type: \"vec4\" },\n                { name: \"iridescenceMatrix\", size: 16, type: \"mat4\" },\n                { name: \"iridescenceThicknessMatrix\", size: 16, type: \"mat4\" },\n            ],\n        };\n    }\n}\n/**\n * The default minimum thickness of the thin-film layer given in nanometers (nm).\n * Defaults to 100 nm.\n * @internal\n */\nPBRIridescenceConfiguration._DefaultMinimumThickness = 100;\n/**\n * The default maximum thickness of the thin-film layer given in nanometers (nm).\n * Defaults to 400 nm.\n * @internal\n */\nPBRIridescenceConfiguration._DefaultMaximumThickness = 400;\n/**\n * The default index of refraction of the thin-film layer.\n * Defaults to 1.3\n * @internal\n */\nPBRIridescenceConfiguration._DefaultIndexOfRefraction = 1.3;\n__decorate([\n    serialize(),\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], PBRIridescenceConfiguration.prototype, \"isEnabled\", void 0);\n__decorate([\n    serialize()\n], PBRIridescenceConfiguration.prototype, \"intensity\", void 0);\n__decorate([\n    serialize()\n], PBRIridescenceConfiguration.prototype, \"minimumThickness\", void 0);\n__decorate([\n    serialize()\n], PBRIridescenceConfiguration.prototype, \"maximumThickness\", void 0);\n__decorate([\n    serialize()\n], PBRIridescenceConfiguration.prototype, \"indexOfRefraction\", void 0);\n__decorate([\n    serializeAsTexture(),\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], PBRIridescenceConfiguration.prototype, \"texture\", void 0);\n__decorate([\n    serializeAsTexture(),\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], PBRIridescenceConfiguration.prototype, \"thicknessTexture\", void 0);\n//# sourceMappingURL=pbrIridescenceConfiguration.js.map","import { __decorate } from \"../../tslib.es6.js\";\nimport { serialize, SerializationHelper, serializeAsColor3, expandToProperty, serializeAsTexture } from \"../../Misc/decorators.js\";\nimport { GetEnvironmentBRDFTexture } from \"../../Misc/brdfTextureTools.js\";\nimport { Color3 } from \"../../Maths/math.color.js\";\nimport { PBRBaseMaterial } from \"./pbrBaseMaterial.js\";\nimport { RegisterClass } from \"../../Misc/typeStore.js\";\n/**\n * The Physically based material of BJS.\n *\n * This offers the main features of a standard PBR material.\n * For more information, please refer to the documentation :\n * https://doc.babylonjs.com/features/featuresDeepDive/materials/using/introToPBR\n */\nexport class PBRMaterial extends PBRBaseMaterial {\n    /**\n     * Stores the refracted light information in a texture.\n     */\n    get refractionTexture() {\n        return this.subSurface.refractionTexture;\n    }\n    set refractionTexture(value) {\n        this.subSurface.refractionTexture = value;\n        if (value) {\n            this.subSurface.isRefractionEnabled = true;\n        }\n        else if (!this.subSurface.linkRefractionWithTransparency) {\n            this.subSurface.isRefractionEnabled = false;\n        }\n    }\n    /**\n     * Index of refraction of the material base layer.\n     * https://en.wikipedia.org/wiki/List_of_refractive_indices\n     *\n     * This does not only impact refraction but also the Base F0 of Dielectric Materials.\n     *\n     * From dielectric fresnel rules: F0 = square((iorT - iorI) / (iorT + iorI))\n     */\n    get indexOfRefraction() {\n        return this.subSurface.indexOfRefraction;\n    }\n    set indexOfRefraction(value) {\n        this.subSurface.indexOfRefraction = value;\n    }\n    /**\n     * Controls if refraction needs to be inverted on Y. This could be useful for procedural texture.\n     */\n    get invertRefractionY() {\n        return this.subSurface.invertRefractionY;\n    }\n    set invertRefractionY(value) {\n        this.subSurface.invertRefractionY = value;\n    }\n    /**\n     * This parameters will make the material used its opacity to control how much it is refracting against not.\n     * Materials half opaque for instance using refraction could benefit from this control.\n     */\n    get linkRefractionWithTransparency() {\n        return this.subSurface.linkRefractionWithTransparency;\n    }\n    set linkRefractionWithTransparency(value) {\n        this.subSurface.linkRefractionWithTransparency = value;\n        if (value) {\n            this.subSurface.isRefractionEnabled = true;\n        }\n    }\n    /**\n     * BJS is using an hardcoded light falloff based on a manually sets up range.\n     * In PBR, one way to represents the falloff is to use the inverse squared root algorithm.\n     * This parameter can help you switch back to the BJS mode in order to create scenes using both materials.\n     */\n    get usePhysicalLightFalloff() {\n        return this._lightFalloff === PBRBaseMaterial.LIGHTFALLOFF_PHYSICAL;\n    }\n    /**\n     * BJS is using an hardcoded light falloff based on a manually sets up range.\n     * In PBR, one way to represents the falloff is to use the inverse squared root algorithm.\n     * This parameter can help you switch back to the BJS mode in order to create scenes using both materials.\n     */\n    set usePhysicalLightFalloff(value) {\n        if (value !== this.usePhysicalLightFalloff) {\n            // Ensure the effect will be rebuilt.\n            this._markAllSubMeshesAsTexturesDirty();\n            if (value) {\n                this._lightFalloff = PBRBaseMaterial.LIGHTFALLOFF_PHYSICAL;\n            }\n            else {\n                this._lightFalloff = PBRBaseMaterial.LIGHTFALLOFF_STANDARD;\n            }\n        }\n    }\n    /**\n     * In order to support the falloff compatibility with gltf, a special mode has been added\n     * to reproduce the gltf light falloff.\n     */\n    get useGLTFLightFalloff() {\n        return this._lightFalloff === PBRBaseMaterial.LIGHTFALLOFF_GLTF;\n    }\n    /**\n     * In order to support the falloff compatibility with gltf, a special mode has been added\n     * to reproduce the gltf light falloff.\n     */\n    set useGLTFLightFalloff(value) {\n        if (value !== this.useGLTFLightFalloff) {\n            // Ensure the effect will be rebuilt.\n            this._markAllSubMeshesAsTexturesDirty();\n            if (value) {\n                this._lightFalloff = PBRBaseMaterial.LIGHTFALLOFF_GLTF;\n            }\n            else {\n                this._lightFalloff = PBRBaseMaterial.LIGHTFALLOFF_STANDARD;\n            }\n        }\n    }\n    /**\n     * Gets the image processing configuration used either in this material.\n     */\n    get imageProcessingConfiguration() {\n        return this._imageProcessingConfiguration;\n    }\n    /**\n     * Sets the Default image processing configuration used either in the this material.\n     *\n     * If sets to null, the scene one is in use.\n     */\n    set imageProcessingConfiguration(value) {\n        this._attachImageProcessingConfiguration(value);\n        // Ensure the effect will be rebuilt.\n        this._markAllSubMeshesAsTexturesDirty();\n    }\n    /**\n     * Gets whether the color curves effect is enabled.\n     */\n    get cameraColorCurvesEnabled() {\n        return this.imageProcessingConfiguration.colorCurvesEnabled;\n    }\n    /**\n     * Sets whether the color curves effect is enabled.\n     */\n    set cameraColorCurvesEnabled(value) {\n        this.imageProcessingConfiguration.colorCurvesEnabled = value;\n    }\n    /**\n     * Gets whether the color grading effect is enabled.\n     */\n    get cameraColorGradingEnabled() {\n        return this.imageProcessingConfiguration.colorGradingEnabled;\n    }\n    /**\n     * Gets whether the color grading effect is enabled.\n     */\n    set cameraColorGradingEnabled(value) {\n        this.imageProcessingConfiguration.colorGradingEnabled = value;\n    }\n    /**\n     * Gets whether tonemapping is enabled or not.\n     */\n    get cameraToneMappingEnabled() {\n        return this._imageProcessingConfiguration.toneMappingEnabled;\n    }\n    /**\n     * Sets whether tonemapping is enabled or not\n     */\n    set cameraToneMappingEnabled(value) {\n        this._imageProcessingConfiguration.toneMappingEnabled = value;\n    }\n    /**\n     * The camera exposure used on this material.\n     * This property is here and not in the camera to allow controlling exposure without full screen post process.\n     * This corresponds to a photographic exposure.\n     */\n    get cameraExposure() {\n        return this._imageProcessingConfiguration.exposure;\n    }\n    /**\n     * The camera exposure used on this material.\n     * This property is here and not in the camera to allow controlling exposure without full screen post process.\n     * This corresponds to a photographic exposure.\n     */\n    set cameraExposure(value) {\n        this._imageProcessingConfiguration.exposure = value;\n    }\n    /**\n     * Gets The camera contrast used on this material.\n     */\n    get cameraContrast() {\n        return this._imageProcessingConfiguration.contrast;\n    }\n    /**\n     * Sets The camera contrast used on this material.\n     */\n    set cameraContrast(value) {\n        this._imageProcessingConfiguration.contrast = value;\n    }\n    /**\n     * Gets the Color Grading 2D Lookup Texture.\n     */\n    get cameraColorGradingTexture() {\n        return this._imageProcessingConfiguration.colorGradingTexture;\n    }\n    /**\n     * Sets the Color Grading 2D Lookup Texture.\n     */\n    set cameraColorGradingTexture(value) {\n        this._imageProcessingConfiguration.colorGradingTexture = value;\n    }\n    /**\n     * The color grading curves provide additional color adjustment that is applied after any color grading transform (3D LUT).\n     * They allow basic adjustment of saturation and small exposure adjustments, along with color filter tinting to provide white balance adjustment or more stylistic effects.\n     * These are similar to controls found in many professional imaging or colorist software. The global controls are applied to the entire image. For advanced tuning, extra controls are provided to adjust the shadow, midtone and highlight areas of the image;\n     * corresponding to low luminance, medium luminance, and high luminance areas respectively.\n     */\n    get cameraColorCurves() {\n        return this._imageProcessingConfiguration.colorCurves;\n    }\n    /**\n     * The color grading curves provide additional color adjustment that is applied after any color grading transform (3D LUT).\n     * They allow basic adjustment of saturation and small exposure adjustments, along with color filter tinting to provide white balance adjustment or more stylistic effects.\n     * These are similar to controls found in many professional imaging or colorist software. The global controls are applied to the entire image. For advanced tuning, extra controls are provided to adjust the shadow, midtone and highlight areas of the image;\n     * corresponding to low luminance, medium luminance, and high luminance areas respectively.\n     */\n    set cameraColorCurves(value) {\n        this._imageProcessingConfiguration.colorCurves = value;\n    }\n    /**\n     * Instantiates a new PBRMaterial instance.\n     *\n     * @param name The material name\n     * @param scene The scene the material will be use in.\n     */\n    constructor(name, scene) {\n        super(name, scene);\n        /**\n         * Intensity of the direct lights e.g. the four lights available in your scene.\n         * This impacts both the direct diffuse and specular highlights.\n         */\n        this.directIntensity = 1.0;\n        /**\n         * Intensity of the emissive part of the material.\n         * This helps controlling the emissive effect without modifying the emissive color.\n         */\n        this.emissiveIntensity = 1.0;\n        /**\n         * Intensity of the environment e.g. how much the environment will light the object\n         * either through harmonics for rough material or through the reflection for shiny ones.\n         */\n        this.environmentIntensity = 1.0;\n        /**\n         * This is a special control allowing the reduction of the specular highlights coming from the\n         * four lights of the scene. Those highlights may not be needed in full environment lighting.\n         */\n        this.specularIntensity = 1.0;\n        /**\n         * Debug Control allowing disabling the bump map on this material.\n         */\n        this.disableBumpMap = false;\n        /**\n         * AKA Occlusion Texture Intensity in other nomenclature.\n         */\n        this.ambientTextureStrength = 1.0;\n        /**\n         * Defines how much the AO map is occluding the analytical lights (point spot...).\n         * 1 means it completely occludes it\n         * 0 mean it has no impact\n         */\n        this.ambientTextureImpactOnAnalyticalLights = PBRMaterial.DEFAULT_AO_ON_ANALYTICAL_LIGHTS;\n        /**\n         * In metallic workflow, specifies an F0 factor to help configuring the material F0.\n         * By default the indexOfrefraction is used to compute F0;\n         *\n         * This is used as a factor against the default reflectance at normal incidence to tweak it.\n         *\n         * F0 = defaultF0 * metallicF0Factor * metallicReflectanceColor;\n         * F90 = metallicReflectanceColor;\n         */\n        this.metallicF0Factor = 1;\n        /**\n         * In metallic workflow, specifies an F90 color to help configuring the material F90.\n         * By default the F90 is always 1;\n         *\n         * Please note that this factor is also used as a factor against the default reflectance at normal incidence.\n         *\n         * F0 = defaultF0 * metallicF0Factor * metallicReflectanceColor\n         * F90 = metallicReflectanceColor;\n         */\n        this.metallicReflectanceColor = Color3.White();\n        /**\n         * Specifies that only the A channel from metallicReflectanceTexture should be used.\n         * If false, both RGB and A channels will be used\n         */\n        this.useOnlyMetallicFromMetallicReflectanceTexture = false;\n        /**\n         * The color of a material in ambient lighting.\n         */\n        this.ambientColor = new Color3(0, 0, 0);\n        /**\n         * AKA Diffuse Color in other nomenclature.\n         */\n        this.albedoColor = new Color3(1, 1, 1);\n        /**\n         * AKA Specular Color in other nomenclature.\n         */\n        this.reflectivityColor = new Color3(1, 1, 1);\n        /**\n         * The color reflected from the material.\n         */\n        this.reflectionColor = new Color3(1.0, 1.0, 1.0);\n        /**\n         * The color emitted from the material.\n         */\n        this.emissiveColor = new Color3(0, 0, 0);\n        /**\n         * AKA Glossiness in other nomenclature.\n         */\n        this.microSurface = 1.0;\n        /**\n         * If true, the light map contains occlusion information instead of lighting info.\n         */\n        this.useLightmapAsShadowmap = false;\n        /**\n         * Specifies that the alpha is coming form the albedo channel alpha channel for alpha blending.\n         */\n        this.useAlphaFromAlbedoTexture = false;\n        /**\n         * Enforces alpha test in opaque or blend mode in order to improve the performances of some situations.\n         */\n        this.forceAlphaTest = false;\n        /**\n         * Defines the alpha limits in alpha test mode.\n         */\n        this.alphaCutOff = 0.4;\n        /**\n         * Specifies that the material will keep the specular highlights over a transparent surface (only the most luminous ones).\n         * A car glass is a good example of that. When sun reflects on it you can not see what is behind.\n         */\n        this.useSpecularOverAlpha = true;\n        /**\n         * Specifies if the reflectivity texture contains the glossiness information in its alpha channel.\n         */\n        this.useMicroSurfaceFromReflectivityMapAlpha = false;\n        /**\n         * Specifies if the metallic texture contains the roughness information in its alpha channel.\n         */\n        this.useRoughnessFromMetallicTextureAlpha = true;\n        /**\n         * Specifies if the metallic texture contains the roughness information in its green channel.\n         */\n        this.useRoughnessFromMetallicTextureGreen = false;\n        /**\n         * Specifies if the metallic texture contains the metallness information in its blue channel.\n         */\n        this.useMetallnessFromMetallicTextureBlue = false;\n        /**\n         * Specifies if the metallic texture contains the ambient occlusion information in its red channel.\n         */\n        this.useAmbientOcclusionFromMetallicTextureRed = false;\n        /**\n         * Specifies if the ambient texture contains the ambient occlusion information in its red channel only.\n         */\n        this.useAmbientInGrayScale = false;\n        /**\n         * In case the reflectivity map does not contain the microsurface information in its alpha channel,\n         * The material will try to infer what glossiness each pixel should be.\n         */\n        this.useAutoMicroSurfaceFromReflectivityMap = false;\n        /**\n         * Specifies that the material will keeps the reflection highlights over a transparent surface (only the most luminous ones).\n         * A car glass is a good example of that. When the street lights reflects on it you can not see what is behind.\n         */\n        this.useRadianceOverAlpha = true;\n        /**\n         * Allows using an object space normal map (instead of tangent space).\n         */\n        this.useObjectSpaceNormalMap = false;\n        /**\n         * Allows using the bump map in parallax mode.\n         */\n        this.useParallax = false;\n        /**\n         * Allows using the bump map in parallax occlusion mode.\n         */\n        this.useParallaxOcclusion = false;\n        /**\n         * Controls the scale bias of the parallax mode.\n         */\n        this.parallaxScaleBias = 0.05;\n        /**\n         * If sets to true, disables all the lights affecting the material.\n         */\n        this.disableLighting = false;\n        /**\n         * Force the shader to compute irradiance in the fragment shader in order to take bump in account.\n         */\n        this.forceIrradianceInFragment = false;\n        /**\n         * Number of Simultaneous lights allowed on the material.\n         */\n        this.maxSimultaneousLights = 4;\n        /**\n         * If sets to true, x component of normal map value will invert (x = 1.0 - x).\n         */\n        this.invertNormalMapX = false;\n        /**\n         * If sets to true, y component of normal map value will invert (y = 1.0 - y).\n         */\n        this.invertNormalMapY = false;\n        /**\n         * If sets to true and backfaceCulling is false, normals will be flipped on the backside.\n         */\n        this.twoSidedLighting = false;\n        /**\n         * A fresnel is applied to the alpha of the model to ensure grazing angles edges are not alpha tested.\n         * And/Or occlude the blended part. (alpha is converted to gamma to compute the fresnel)\n         */\n        this.useAlphaFresnel = false;\n        /**\n         * A fresnel is applied to the alpha of the model to ensure grazing angles edges are not alpha tested.\n         * And/Or occlude the blended part. (alpha stays linear to compute the fresnel)\n         */\n        this.useLinearAlphaFresnel = false;\n        /**\n         * Let user defines the brdf lookup texture used for IBL.\n         * A default 8bit version is embedded but you could point at :\n         * * Default texture: https://assets.babylonjs.com/environments/correlatedMSBRDF_RGBD.png\n         * * Default 16bit pixel depth texture: https://assets.babylonjs.com/environments/correlatedMSBRDF.dds\n         * * LEGACY Default None correlated https://assets.babylonjs.com/environments/uncorrelatedBRDF_RGBD.png\n         * * LEGACY Default None correlated 16bit pixel depth https://assets.babylonjs.com/environments/uncorrelatedBRDF.dds\n         */\n        this.environmentBRDFTexture = null;\n        /**\n         * Force normal to face away from face.\n         */\n        this.forceNormalForward = false;\n        /**\n         * Enables specular anti aliasing in the PBR shader.\n         * It will both interacts on the Geometry for analytical and IBL lighting.\n         * It also prefilter the roughness map based on the bump values.\n         */\n        this.enableSpecularAntiAliasing = false;\n        /**\n         * This parameters will enable/disable Horizon occlusion to prevent normal maps to look shiny when the normal\n         * makes the reflect vector face the model (under horizon).\n         */\n        this.useHorizonOcclusion = true;\n        /**\n         * This parameters will enable/disable radiance occlusion by preventing the radiance to lit\n         * too much the area relying on ambient texture to define their ambient occlusion.\n         */\n        this.useRadianceOcclusion = true;\n        /**\n         * If set to true, no lighting calculations will be applied.\n         */\n        this.unlit = false;\n        this._environmentBRDFTexture = GetEnvironmentBRDFTexture(this.getScene());\n    }\n    /**\n     * Returns the name of this material class.\n     */\n    getClassName() {\n        return \"PBRMaterial\";\n    }\n    /**\n     * Makes a duplicate of the current material.\n     * @param name - name to use for the new material.\n     */\n    clone(name) {\n        const clone = SerializationHelper.Clone(() => new PBRMaterial(name, this.getScene()), this);\n        clone.id = name;\n        clone.name = name;\n        this.stencil.copyTo(clone.stencil);\n        this.clearCoat.copyTo(clone.clearCoat);\n        this.anisotropy.copyTo(clone.anisotropy);\n        this.brdf.copyTo(clone.brdf);\n        this.sheen.copyTo(clone.sheen);\n        this.subSurface.copyTo(clone.subSurface);\n        return clone;\n    }\n    /**\n     * Serializes this PBR Material.\n     * @returns - An object with the serialized material.\n     */\n    serialize() {\n        const serializationObject = super.serialize();\n        serializationObject.customType = \"BABYLON.PBRMaterial\";\n        serializationObject.clearCoat = this.clearCoat.serialize();\n        serializationObject.anisotropy = this.anisotropy.serialize();\n        serializationObject.brdf = this.brdf.serialize();\n        serializationObject.sheen = this.sheen.serialize();\n        serializationObject.subSurface = this.subSurface.serialize();\n        serializationObject.iridescence = this.iridescence.serialize();\n        return serializationObject;\n    }\n    // Statics\n    /**\n     * Parses a PBR Material from a serialized object.\n     * @param source - Serialized object.\n     * @param scene - BJS scene instance.\n     * @param rootUrl - url for the scene object\n     * @returns - PBRMaterial\n     */\n    static Parse(source, scene, rootUrl) {\n        const material = SerializationHelper.Parse(() => new PBRMaterial(source.name, scene), source, scene, rootUrl);\n        if (source.stencil) {\n            material.stencil.parse(source.stencil, scene, rootUrl);\n        }\n        if (source.clearCoat) {\n            material.clearCoat.parse(source.clearCoat, scene, rootUrl);\n        }\n        if (source.anisotropy) {\n            material.anisotropy.parse(source.anisotropy, scene, rootUrl);\n        }\n        if (source.brdf) {\n            material.brdf.parse(source.brdf, scene, rootUrl);\n        }\n        if (source.sheen) {\n            material.sheen.parse(source.sheen, scene, rootUrl);\n        }\n        if (source.subSurface) {\n            material.subSurface.parse(source.subSurface, scene, rootUrl);\n        }\n        if (source.iridescence) {\n            material.iridescence.parse(source.iridescence, scene, rootUrl);\n        }\n        return material;\n    }\n}\n/**\n * PBRMaterialTransparencyMode: No transparency mode, Alpha channel is not use.\n */\nPBRMaterial.PBRMATERIAL_OPAQUE = PBRBaseMaterial.PBRMATERIAL_OPAQUE;\n/**\n * PBRMaterialTransparencyMode: Alpha Test mode, pixel are discarded below a certain threshold defined by the alpha cutoff value.\n */\nPBRMaterial.PBRMATERIAL_ALPHATEST = PBRBaseMaterial.PBRMATERIAL_ALPHATEST;\n/**\n * PBRMaterialTransparencyMode: Pixels are blended (according to the alpha mode) with the already drawn pixels in the current frame buffer.\n */\nPBRMaterial.PBRMATERIAL_ALPHABLEND = PBRBaseMaterial.PBRMATERIAL_ALPHABLEND;\n/**\n * PBRMaterialTransparencyMode: Pixels are blended (according to the alpha mode) with the already drawn pixels in the current frame buffer.\n * They are also discarded below the alpha cutoff threshold to improve performances.\n */\nPBRMaterial.PBRMATERIAL_ALPHATESTANDBLEND = PBRBaseMaterial.PBRMATERIAL_ALPHATESTANDBLEND;\n/**\n * Defines the default value of how much AO map is occluding the analytical lights\n * (point spot...).\n */\nPBRMaterial.DEFAULT_AO_ON_ANALYTICAL_LIGHTS = PBRBaseMaterial.DEFAULT_AO_ON_ANALYTICAL_LIGHTS;\n__decorate([\n    serialize(),\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], PBRMaterial.prototype, \"directIntensity\", void 0);\n__decorate([\n    serialize(),\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], PBRMaterial.prototype, \"emissiveIntensity\", void 0);\n__decorate([\n    serialize(),\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], PBRMaterial.prototype, \"environmentIntensity\", void 0);\n__decorate([\n    serialize(),\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], PBRMaterial.prototype, \"specularIntensity\", void 0);\n__decorate([\n    serialize(),\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], PBRMaterial.prototype, \"disableBumpMap\", void 0);\n__decorate([\n    serializeAsTexture(),\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], PBRMaterial.prototype, \"albedoTexture\", void 0);\n__decorate([\n    serializeAsTexture(),\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], PBRMaterial.prototype, \"ambientTexture\", void 0);\n__decorate([\n    serialize(),\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], PBRMaterial.prototype, \"ambientTextureStrength\", void 0);\n__decorate([\n    serialize(),\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], PBRMaterial.prototype, \"ambientTextureImpactOnAnalyticalLights\", void 0);\n__decorate([\n    serializeAsTexture(),\n    expandToProperty(\"_markAllSubMeshesAsTexturesAndMiscDirty\")\n], PBRMaterial.prototype, \"opacityTexture\", void 0);\n__decorate([\n    serializeAsTexture(),\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], PBRMaterial.prototype, \"reflectionTexture\", void 0);\n__decorate([\n    serializeAsTexture(),\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], PBRMaterial.prototype, \"emissiveTexture\", void 0);\n__decorate([\n    serializeAsTexture(),\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], PBRMaterial.prototype, \"reflectivityTexture\", void 0);\n__decorate([\n    serializeAsTexture(),\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], PBRMaterial.prototype, \"metallicTexture\", void 0);\n__decorate([\n    serialize(),\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], PBRMaterial.prototype, \"metallic\", void 0);\n__decorate([\n    serialize(),\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], PBRMaterial.prototype, \"roughness\", void 0);\n__decorate([\n    serialize(),\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], PBRMaterial.prototype, \"metallicF0Factor\", void 0);\n__decorate([\n    serializeAsColor3(),\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], PBRMaterial.prototype, \"metallicReflectanceColor\", void 0);\n__decorate([\n    serialize(),\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], PBRMaterial.prototype, \"useOnlyMetallicFromMetallicReflectanceTexture\", void 0);\n__decorate([\n    serializeAsTexture(),\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], PBRMaterial.prototype, \"metallicReflectanceTexture\", void 0);\n__decorate([\n    serializeAsTexture(),\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], PBRMaterial.prototype, \"reflectanceTexture\", void 0);\n__decorate([\n    serializeAsTexture(),\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], PBRMaterial.prototype, \"microSurfaceTexture\", void 0);\n__decorate([\n    serializeAsTexture(),\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], PBRMaterial.prototype, \"bumpTexture\", void 0);\n__decorate([\n    serializeAsTexture(),\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\", null)\n], PBRMaterial.prototype, \"lightmapTexture\", void 0);\n__decorate([\n    serializeAsColor3(\"ambient\"),\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], PBRMaterial.prototype, \"ambientColor\", void 0);\n__decorate([\n    serializeAsColor3(\"albedo\"),\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], PBRMaterial.prototype, \"albedoColor\", void 0);\n__decorate([\n    serializeAsColor3(\"reflectivity\"),\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], PBRMaterial.prototype, \"reflectivityColor\", void 0);\n__decorate([\n    serializeAsColor3(\"reflection\"),\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], PBRMaterial.prototype, \"reflectionColor\", void 0);\n__decorate([\n    serializeAsColor3(\"emissive\"),\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], PBRMaterial.prototype, \"emissiveColor\", void 0);\n__decorate([\n    serialize(),\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], PBRMaterial.prototype, \"microSurface\", void 0);\n__decorate([\n    serialize(),\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], PBRMaterial.prototype, \"useLightmapAsShadowmap\", void 0);\n__decorate([\n    serialize(),\n    expandToProperty(\"_markAllSubMeshesAsTexturesAndMiscDirty\")\n], PBRMaterial.prototype, \"useAlphaFromAlbedoTexture\", void 0);\n__decorate([\n    serialize(),\n    expandToProperty(\"_markAllSubMeshesAsTexturesAndMiscDirty\")\n], PBRMaterial.prototype, \"forceAlphaTest\", void 0);\n__decorate([\n    serialize(),\n    expandToProperty(\"_markAllSubMeshesAsTexturesAndMiscDirty\")\n], PBRMaterial.prototype, \"alphaCutOff\", void 0);\n__decorate([\n    serialize(),\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], PBRMaterial.prototype, \"useSpecularOverAlpha\", void 0);\n__decorate([\n    serialize(),\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], PBRMaterial.prototype, \"useMicroSurfaceFromReflectivityMapAlpha\", void 0);\n__decorate([\n    serialize(),\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], PBRMaterial.prototype, \"useRoughnessFromMetallicTextureAlpha\", void 0);\n__decorate([\n    serialize(),\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], PBRMaterial.prototype, \"useRoughnessFromMetallicTextureGreen\", void 0);\n__decorate([\n    serialize(),\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], PBRMaterial.prototype, \"useMetallnessFromMetallicTextureBlue\", void 0);\n__decorate([\n    serialize(),\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], PBRMaterial.prototype, \"useAmbientOcclusionFromMetallicTextureRed\", void 0);\n__decorate([\n    serialize(),\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], PBRMaterial.prototype, \"useAmbientInGrayScale\", void 0);\n__decorate([\n    serialize(),\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], PBRMaterial.prototype, \"useAutoMicroSurfaceFromReflectivityMap\", void 0);\n__decorate([\n    serialize()\n], PBRMaterial.prototype, \"usePhysicalLightFalloff\", null);\n__decorate([\n    serialize()\n], PBRMaterial.prototype, \"useGLTFLightFalloff\", null);\n__decorate([\n    serialize(),\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], PBRMaterial.prototype, \"useRadianceOverAlpha\", void 0);\n__decorate([\n    serialize(),\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], PBRMaterial.prototype, \"useObjectSpaceNormalMap\", void 0);\n__decorate([\n    serialize(),\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], PBRMaterial.prototype, \"useParallax\", void 0);\n__decorate([\n    serialize(),\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], PBRMaterial.prototype, \"useParallaxOcclusion\", void 0);\n__decorate([\n    serialize(),\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], PBRMaterial.prototype, \"parallaxScaleBias\", void 0);\n__decorate([\n    serialize(),\n    expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\n], PBRMaterial.prototype, \"disableLighting\", void 0);\n__decorate([\n    serialize(),\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], PBRMaterial.prototype, \"forceIrradianceInFragment\", void 0);\n__decorate([\n    serialize(),\n    expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\n], PBRMaterial.prototype, \"maxSimultaneousLights\", void 0);\n__decorate([\n    serialize(),\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], PBRMaterial.prototype, \"invertNormalMapX\", void 0);\n__decorate([\n    serialize(),\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], PBRMaterial.prototype, \"invertNormalMapY\", void 0);\n__decorate([\n    serialize(),\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], PBRMaterial.prototype, \"twoSidedLighting\", void 0);\n__decorate([\n    serialize(),\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], PBRMaterial.prototype, \"useAlphaFresnel\", void 0);\n__decorate([\n    serialize(),\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], PBRMaterial.prototype, \"useLinearAlphaFresnel\", void 0);\n__decorate([\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], PBRMaterial.prototype, \"environmentBRDFTexture\", void 0);\n__decorate([\n    serialize(),\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], PBRMaterial.prototype, \"forceNormalForward\", void 0);\n__decorate([\n    serialize(),\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], PBRMaterial.prototype, \"enableSpecularAntiAliasing\", void 0);\n__decorate([\n    serialize(),\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], PBRMaterial.prototype, \"useHorizonOcclusion\", void 0);\n__decorate([\n    serialize(),\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], PBRMaterial.prototype, \"useRadianceOcclusion\", void 0);\n__decorate([\n    serialize(),\n    expandToProperty(\"_markAllSubMeshesAsMiscDirty\")\n], PBRMaterial.prototype, \"unlit\", void 0);\nRegisterClass(\"BABYLON.PBRMaterial\", PBRMaterial);\n//# sourceMappingURL=pbrMaterial.js.map","import { __decorate } from \"../../tslib.es6.js\";\n/* eslint-disable @typescript-eslint/naming-convention */\nimport { serialize, expandToProperty, serializeAsColor3, serializeAsTexture } from \"../../Misc/decorators.js\";\nimport { Color3 } from \"../../Maths/math.color.js\";\nimport { MaterialFlags } from \"../../Materials/materialFlags.js\";\nimport { MaterialHelper } from \"../../Materials/materialHelper.js\";\n\nimport { MaterialPluginBase } from \"../materialPluginBase.js\";\nimport { MaterialDefines } from \"../materialDefines.js\";\n/**\n * @internal\n */\nexport class MaterialSheenDefines extends MaterialDefines {\n    constructor() {\n        super(...arguments);\n        this.SHEEN = false;\n        this.SHEEN_TEXTURE = false;\n        this.SHEEN_GAMMATEXTURE = false;\n        this.SHEEN_TEXTURE_ROUGHNESS = false;\n        this.SHEEN_TEXTUREDIRECTUV = 0;\n        this.SHEEN_TEXTURE_ROUGHNESSDIRECTUV = 0;\n        this.SHEEN_LINKWITHALBEDO = false;\n        this.SHEEN_ROUGHNESS = false;\n        this.SHEEN_ALBEDOSCALING = false;\n        this.SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE = false;\n        this.SHEEN_TEXTURE_ROUGHNESS_IDENTICAL = false;\n    }\n}\n/**\n * Plugin that implements the sheen component of the PBR material.\n */\nexport class PBRSheenConfiguration extends MaterialPluginBase {\n    /** @internal */\n    _markAllSubMeshesAsTexturesDirty() {\n        this._enable(this._isEnabled);\n        this._internalMarkAllSubMeshesAsTexturesDirty();\n    }\n    constructor(material, addToPluginList = true) {\n        super(material, \"Sheen\", 120, new MaterialSheenDefines(), addToPluginList);\n        this._isEnabled = false;\n        /**\n         * Defines if the material uses sheen.\n         */\n        this.isEnabled = false;\n        this._linkSheenWithAlbedo = false;\n        /**\n         * Defines if the sheen is linked to the sheen color.\n         */\n        this.linkSheenWithAlbedo = false;\n        /**\n         * Defines the sheen intensity.\n         */\n        this.intensity = 1;\n        /**\n         * Defines the sheen color.\n         */\n        this.color = Color3.White();\n        this._texture = null;\n        /**\n         * Stores the sheen tint values in a texture.\n         * rgb is tint\n         * a is a intensity or roughness if the roughness property has been defined and useRoughnessFromTexture is true (in that case, textureRoughness won't be used)\n         * If the roughness property has been defined and useRoughnessFromTexture is false then the alpha channel is not used to modulate roughness\n         */\n        this.texture = null;\n        this._useRoughnessFromMainTexture = true;\n        /**\n         * Indicates that the alpha channel of the texture property will be used for roughness.\n         * Has no effect if the roughness (and texture!) property is not defined\n         */\n        this.useRoughnessFromMainTexture = true;\n        this._roughness = null;\n        /**\n         * Defines the sheen roughness.\n         * It is not taken into account if linkSheenWithAlbedo is true.\n         * To stay backward compatible, material roughness is used instead if sheen roughness = null\n         */\n        this.roughness = null;\n        this._textureRoughness = null;\n        /**\n         * Stores the sheen roughness in a texture.\n         * alpha channel is the roughness. This texture won't be used if the texture property is not empty and useRoughnessFromTexture is true\n         */\n        this.textureRoughness = null;\n        this._albedoScaling = false;\n        /**\n         * If true, the sheen effect is layered above the base BRDF with the albedo-scaling technique.\n         * It allows the strength of the sheen effect to not depend on the base color of the material,\n         * making it easier to setup and tweak the effect\n         */\n        this.albedoScaling = false;\n        this._internalMarkAllSubMeshesAsTexturesDirty = material._dirtyCallbacks[1];\n    }\n    isReadyForSubMesh(defines, scene) {\n        if (!this._isEnabled) {\n            return true;\n        }\n        if (defines._areTexturesDirty) {\n            if (scene.texturesEnabled) {\n                if (this._texture && MaterialFlags.SheenTextureEnabled) {\n                    if (!this._texture.isReadyOrNotBlocking()) {\n                        return false;\n                    }\n                }\n                if (this._textureRoughness && MaterialFlags.SheenTextureEnabled) {\n                    if (!this._textureRoughness.isReadyOrNotBlocking()) {\n                        return false;\n                    }\n                }\n            }\n        }\n        return true;\n    }\n    prepareDefinesBeforeAttributes(defines, scene) {\n        var _a;\n        if (this._isEnabled) {\n            defines.SHEEN = true;\n            defines.SHEEN_LINKWITHALBEDO = this._linkSheenWithAlbedo;\n            defines.SHEEN_ROUGHNESS = this._roughness !== null;\n            defines.SHEEN_ALBEDOSCALING = this._albedoScaling;\n            defines.SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE = this._useRoughnessFromMainTexture;\n            defines.SHEEN_TEXTURE_ROUGHNESS_IDENTICAL =\n                this._texture !== null && this._texture._texture === ((_a = this._textureRoughness) === null || _a === void 0 ? void 0 : _a._texture) && this._texture.checkTransformsAreIdentical(this._textureRoughness);\n            if (defines._areTexturesDirty) {\n                if (scene.texturesEnabled) {\n                    if (this._texture && MaterialFlags.SheenTextureEnabled) {\n                        MaterialHelper.PrepareDefinesForMergedUV(this._texture, defines, \"SHEEN_TEXTURE\");\n                        defines.SHEEN_GAMMATEXTURE = this._texture.gammaSpace;\n                    }\n                    else {\n                        defines.SHEEN_TEXTURE = false;\n                    }\n                    if (this._textureRoughness && MaterialFlags.SheenTextureEnabled) {\n                        MaterialHelper.PrepareDefinesForMergedUV(this._textureRoughness, defines, \"SHEEN_TEXTURE_ROUGHNESS\");\n                    }\n                    else {\n                        defines.SHEEN_TEXTURE_ROUGHNESS = false;\n                    }\n                }\n            }\n        }\n        else {\n            defines.SHEEN = false;\n            defines.SHEEN_TEXTURE = false;\n            defines.SHEEN_TEXTURE_ROUGHNESS = false;\n            defines.SHEEN_LINKWITHALBEDO = false;\n            defines.SHEEN_ROUGHNESS = false;\n            defines.SHEEN_ALBEDOSCALING = false;\n            defines.SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE = false;\n            defines.SHEEN_TEXTURE_ROUGHNESS_IDENTICAL = false;\n            defines.SHEEN_GAMMATEXTURE = false;\n            defines.SHEEN_TEXTUREDIRECTUV = 0;\n            defines.SHEEN_TEXTURE_ROUGHNESSDIRECTUV = 0;\n        }\n    }\n    bindForSubMesh(uniformBuffer, scene, engine, subMesh) {\n        var _a, _b, _c, _d, _e, _f, _g, _h;\n        if (!this._isEnabled) {\n            return;\n        }\n        const defines = subMesh.materialDefines;\n        const isFrozen = this._material.isFrozen;\n        const identicalTextures = defines.SHEEN_TEXTURE_ROUGHNESS_IDENTICAL;\n        if (!uniformBuffer.useUbo || !isFrozen || !uniformBuffer.isSync) {\n            if (identicalTextures && MaterialFlags.SheenTextureEnabled) {\n                uniformBuffer.updateFloat4(\"vSheenInfos\", this._texture.coordinatesIndex, this._texture.level, -1, -1);\n                MaterialHelper.BindTextureMatrix(this._texture, uniformBuffer, \"sheen\");\n            }\n            else if ((this._texture || this._textureRoughness) && MaterialFlags.SheenTextureEnabled) {\n                uniformBuffer.updateFloat4(\"vSheenInfos\", (_b = (_a = this._texture) === null || _a === void 0 ? void 0 : _a.coordinatesIndex) !== null && _b !== void 0 ? _b : 0, (_d = (_c = this._texture) === null || _c === void 0 ? void 0 : _c.level) !== null && _d !== void 0 ? _d : 0, (_f = (_e = this._textureRoughness) === null || _e === void 0 ? void 0 : _e.coordinatesIndex) !== null && _f !== void 0 ? _f : 0, (_h = (_g = this._textureRoughness) === null || _g === void 0 ? void 0 : _g.level) !== null && _h !== void 0 ? _h : 0);\n                if (this._texture) {\n                    MaterialHelper.BindTextureMatrix(this._texture, uniformBuffer, \"sheen\");\n                }\n                if (this._textureRoughness && !identicalTextures && !defines.SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE) {\n                    MaterialHelper.BindTextureMatrix(this._textureRoughness, uniformBuffer, \"sheenRoughness\");\n                }\n            }\n            // Sheen\n            uniformBuffer.updateFloat4(\"vSheenColor\", this.color.r, this.color.g, this.color.b, this.intensity);\n            if (this._roughness !== null) {\n                uniformBuffer.updateFloat(\"vSheenRoughness\", this._roughness);\n            }\n        }\n        // Textures\n        if (scene.texturesEnabled) {\n            if (this._texture && MaterialFlags.SheenTextureEnabled) {\n                uniformBuffer.setTexture(\"sheenSampler\", this._texture);\n            }\n            if (this._textureRoughness && !identicalTextures && !defines.SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE && MaterialFlags.SheenTextureEnabled) {\n                uniformBuffer.setTexture(\"sheenRoughnessSampler\", this._textureRoughness);\n            }\n        }\n    }\n    hasTexture(texture) {\n        if (this._texture === texture) {\n            return true;\n        }\n        if (this._textureRoughness === texture) {\n            return true;\n        }\n        return false;\n    }\n    getActiveTextures(activeTextures) {\n        if (this._texture) {\n            activeTextures.push(this._texture);\n        }\n        if (this._textureRoughness) {\n            activeTextures.push(this._textureRoughness);\n        }\n    }\n    getAnimatables(animatables) {\n        if (this._texture && this._texture.animations && this._texture.animations.length > 0) {\n            animatables.push(this._texture);\n        }\n        if (this._textureRoughness && this._textureRoughness.animations && this._textureRoughness.animations.length > 0) {\n            animatables.push(this._textureRoughness);\n        }\n    }\n    dispose(forceDisposeTextures) {\n        var _a, _b;\n        if (forceDisposeTextures) {\n            (_a = this._texture) === null || _a === void 0 ? void 0 : _a.dispose();\n            (_b = this._textureRoughness) === null || _b === void 0 ? void 0 : _b.dispose();\n        }\n    }\n    getClassName() {\n        return \"PBRSheenConfiguration\";\n    }\n    addFallbacks(defines, fallbacks, currentRank) {\n        if (defines.SHEEN) {\n            fallbacks.addFallback(currentRank++, \"SHEEN\");\n        }\n        return currentRank;\n    }\n    getSamplers(samplers) {\n        samplers.push(\"sheenSampler\", \"sheenRoughnessSampler\");\n    }\n    getUniforms() {\n        return {\n            ubo: [\n                { name: \"vSheenColor\", size: 4, type: \"vec4\" },\n                { name: \"vSheenRoughness\", size: 1, type: \"float\" },\n                { name: \"vSheenInfos\", size: 4, type: \"vec4\" },\n                { name: \"sheenMatrix\", size: 16, type: \"mat4\" },\n                { name: \"sheenRoughnessMatrix\", size: 16, type: \"mat4\" },\n            ],\n        };\n    }\n}\n__decorate([\n    serialize(),\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], PBRSheenConfiguration.prototype, \"isEnabled\", void 0);\n__decorate([\n    serialize(),\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], PBRSheenConfiguration.prototype, \"linkSheenWithAlbedo\", void 0);\n__decorate([\n    serialize()\n], PBRSheenConfiguration.prototype, \"intensity\", void 0);\n__decorate([\n    serializeAsColor3()\n], PBRSheenConfiguration.prototype, \"color\", void 0);\n__decorate([\n    serializeAsTexture(),\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], PBRSheenConfiguration.prototype, \"texture\", void 0);\n__decorate([\n    serialize(),\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], PBRSheenConfiguration.prototype, \"useRoughnessFromMainTexture\", void 0);\n__decorate([\n    serialize(),\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], PBRSheenConfiguration.prototype, \"roughness\", void 0);\n__decorate([\n    serializeAsTexture(),\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], PBRSheenConfiguration.prototype, \"textureRoughness\", void 0);\n__decorate([\n    serialize(),\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], PBRSheenConfiguration.prototype, \"albedoScaling\", void 0);\n//# sourceMappingURL=pbrSheenConfiguration.js.map","import { __decorate } from \"../../tslib.es6.js\";\nimport { serialize, serializeAsTexture, expandToProperty, serializeAsColor3 } from \"../../Misc/decorators.js\";\nimport { Color3 } from \"../../Maths/math.color.js\";\nimport { MaterialFlags } from \"../materialFlags.js\";\nimport { MaterialHelper } from \"../../Materials/materialHelper.js\";\nimport { Scalar } from \"../../Maths/math.scalar.js\";\nimport { TmpVectors } from \"../../Maths/math.vector.js\";\nimport { MaterialPluginBase } from \"../materialPluginBase.js\";\n\nimport { MaterialDefines } from \"../materialDefines.js\";\n/**\n * @internal\n */\nexport class MaterialSubSurfaceDefines extends MaterialDefines {\n    constructor() {\n        super(...arguments);\n        this.SUBSURFACE = false;\n        this.SS_REFRACTION = false;\n        this.SS_REFRACTION_USE_INTENSITY_FROM_TEXTURE = false;\n        this.SS_TRANSLUCENCY = false;\n        this.SS_TRANSLUCENCY_USE_INTENSITY_FROM_TEXTURE = false;\n        this.SS_SCATTERING = false;\n        this.SS_THICKNESSANDMASK_TEXTURE = false;\n        this.SS_THICKNESSANDMASK_TEXTUREDIRECTUV = 0;\n        this.SS_HAS_THICKNESS = false;\n        this.SS_REFRACTIONINTENSITY_TEXTURE = false;\n        this.SS_REFRACTIONINTENSITY_TEXTUREDIRECTUV = 0;\n        this.SS_TRANSLUCENCYINTENSITY_TEXTURE = false;\n        this.SS_TRANSLUCENCYINTENSITY_TEXTUREDIRECTUV = 0;\n        this.SS_REFRACTIONMAP_3D = false;\n        this.SS_REFRACTIONMAP_OPPOSITEZ = false;\n        this.SS_LODINREFRACTIONALPHA = false;\n        this.SS_GAMMAREFRACTION = false;\n        this.SS_RGBDREFRACTION = false;\n        this.SS_LINEARSPECULARREFRACTION = false;\n        this.SS_LINKREFRACTIONTOTRANSPARENCY = false;\n        this.SS_ALBEDOFORREFRACTIONTINT = false;\n        this.SS_ALBEDOFORTRANSLUCENCYTINT = false;\n        this.SS_USE_LOCAL_REFRACTIONMAP_CUBIC = false;\n        this.SS_USE_THICKNESS_AS_DEPTH = false;\n        this.SS_MASK_FROM_THICKNESS_TEXTURE = false;\n        this.SS_USE_GLTF_TEXTURES = false;\n    }\n}\n/**\n * Plugin that implements the sub surface component of the PBR material\n */\nexport class PBRSubSurfaceConfiguration extends MaterialPluginBase {\n    /**\n     * Diffusion profile for subsurface scattering.\n     * Useful for better scattering in the skins or foliages.\n     */\n    get scatteringDiffusionProfile() {\n        if (!this._scene.subSurfaceConfiguration) {\n            return null;\n        }\n        return this._scene.subSurfaceConfiguration.ssDiffusionProfileColors[this._scatteringDiffusionProfileIndex];\n    }\n    set scatteringDiffusionProfile(c) {\n        if (!this._scene.enableSubSurfaceForPrePass()) {\n            // Not supported\n            return;\n        }\n        // addDiffusionProfile automatically checks for doubles\n        if (c) {\n            this._scatteringDiffusionProfileIndex = this._scene.subSurfaceConfiguration.addDiffusionProfile(c);\n        }\n    }\n    /**\n     * Index of refraction of the material's volume.\n     * https://en.wikipedia.org/wiki/List_of_refractive_indices\n     *\n     * This ONLY impacts refraction. If not provided or given a non-valid value,\n     * the volume will use the same IOR as the surface.\n     */\n    get volumeIndexOfRefraction() {\n        if (this._volumeIndexOfRefraction >= 1.0) {\n            return this._volumeIndexOfRefraction;\n        }\n        return this._indexOfRefraction;\n    }\n    set volumeIndexOfRefraction(value) {\n        if (value >= 1.0) {\n            this._volumeIndexOfRefraction = value;\n        }\n        else {\n            this._volumeIndexOfRefraction = -1.0;\n        }\n    }\n    /** @internal */\n    _markAllSubMeshesAsTexturesDirty() {\n        this._enable(this._isRefractionEnabled || this._isTranslucencyEnabled || this._isScatteringEnabled);\n        this._internalMarkAllSubMeshesAsTexturesDirty();\n    }\n    /** @internal */\n    _markScenePrePassDirty() {\n        this._internalMarkAllSubMeshesAsTexturesDirty();\n        this._internalMarkScenePrePassDirty();\n    }\n    constructor(material, addToPluginList = true) {\n        super(material, \"PBRSubSurface\", 130, new MaterialSubSurfaceDefines(), addToPluginList);\n        this._isRefractionEnabled = false;\n        /**\n         * Defines if the refraction is enabled in the material.\n         */\n        this.isRefractionEnabled = false;\n        this._isTranslucencyEnabled = false;\n        /**\n         * Defines if the translucency is enabled in the material.\n         */\n        this.isTranslucencyEnabled = false;\n        this._isScatteringEnabled = false;\n        /**\n         * Defines if the sub surface scattering is enabled in the material.\n         */\n        this.isScatteringEnabled = false;\n        this._scatteringDiffusionProfileIndex = 0;\n        /**\n         * Defines the refraction intensity of the material.\n         * The refraction when enabled replaces the Diffuse part of the material.\n         * The intensity helps transitioning between diffuse and refraction.\n         */\n        this.refractionIntensity = 1;\n        /**\n         * Defines the translucency intensity of the material.\n         * When translucency has been enabled, this defines how much of the \"translucency\"\n         * is added to the diffuse part of the material.\n         */\n        this.translucencyIntensity = 1;\n        /**\n         * When enabled, transparent surfaces will be tinted with the albedo colour (independent of thickness)\n         */\n        this.useAlbedoToTintRefraction = false;\n        /**\n         * When enabled, translucent surfaces will be tinted with the albedo colour (independent of thickness)\n         */\n        this.useAlbedoToTintTranslucency = false;\n        this._thicknessTexture = null;\n        /**\n         * Stores the average thickness of a mesh in a texture (The texture is holding the values linearly).\n         * The red (or green if useGltfStyleTextures=true) channel of the texture should contain the thickness remapped between 0 and 1.\n         * 0 would mean minimumThickness\n         * 1 would mean maximumThickness\n         * The other channels might be use as a mask to vary the different effects intensity.\n         */\n        this.thicknessTexture = null;\n        this._refractionTexture = null;\n        /**\n         * Defines the texture to use for refraction.\n         */\n        this.refractionTexture = null;\n        /** @internal */\n        this._indexOfRefraction = 1.5;\n        /**\n         * Index of refraction of the material base layer.\n         * https://en.wikipedia.org/wiki/List_of_refractive_indices\n         *\n         * This does not only impact refraction but also the Base F0 of Dielectric Materials.\n         *\n         * From dielectric fresnel rules: F0 = square((iorT - iorI) / (iorT + iorI))\n         */\n        this.indexOfRefraction = 1.5;\n        this._volumeIndexOfRefraction = -1.0;\n        this._invertRefractionY = false;\n        /**\n         * Controls if refraction needs to be inverted on Y. This could be useful for procedural texture.\n         */\n        this.invertRefractionY = false;\n        /** @internal */\n        this._linkRefractionWithTransparency = false;\n        /**\n         * This parameters will make the material used its opacity to control how much it is refracting against not.\n         * Materials half opaque for instance using refraction could benefit from this control.\n         */\n        this.linkRefractionWithTransparency = false;\n        /**\n         * Defines the minimum thickness stored in the thickness map.\n         * If no thickness map is defined, this value will be used to simulate thickness.\n         */\n        this.minimumThickness = 0;\n        /**\n         * Defines the maximum thickness stored in the thickness map.\n         */\n        this.maximumThickness = 1;\n        /**\n         * Defines that the thickness should be used as a measure of the depth volume.\n         */\n        this.useThicknessAsDepth = false;\n        /**\n         * Defines the volume tint of the material.\n         * This is used for both translucency and scattering.\n         */\n        this.tintColor = Color3.White();\n        /**\n         * Defines the distance at which the tint color should be found in the media.\n         * This is used for refraction only.\n         */\n        this.tintColorAtDistance = 1;\n        /**\n         * Defines how far each channel transmit through the media.\n         * It is defined as a color to simplify it selection.\n         */\n        this.diffusionDistance = Color3.White();\n        this._useMaskFromThicknessTexture = false;\n        /**\n         * Stores the intensity of the different subsurface effects in the thickness texture.\n         * Note that if refractionIntensityTexture and/or translucencyIntensityTexture is provided it takes precedence over thicknessTexture + useMaskFromThicknessTexture\n         * * the green (red if useGltfStyleTextures = true) channel is the refraction intensity.\n         * * the blue channel is the translucency intensity.\n         */\n        this.useMaskFromThicknessTexture = false;\n        this._refractionIntensityTexture = null;\n        /**\n         * Stores the intensity of the refraction. If provided, it takes precedence over thicknessTexture + useMaskFromThicknessTexture\n         * * the green (red if useGltfStyleTextures = true) channel is the refraction intensity.\n         */\n        this.refractionIntensityTexture = null;\n        this._translucencyIntensityTexture = null;\n        /**\n         * Stores the intensity of the translucency. If provided, it takes precedence over thicknessTexture + useMaskFromThicknessTexture\n         * * the blue channel is the translucency intensity.\n         */\n        this.translucencyIntensityTexture = null;\n        this._useGltfStyleTextures = false;\n        /**\n         * Use channels layout used by glTF:\n         * * thicknessTexture: the green (instead of red) channel is the thickness\n         * * thicknessTexture/refractionIntensityTexture: the red (instead of green) channel is the refraction intensity\n         * * thicknessTexture/translucencyIntensityTexture: no change, use the blue channel for the translucency intensity\n         */\n        this.useGltfStyleTextures = false;\n        this._scene = material.getScene();\n        this.registerForExtraEvents = true;\n        this._internalMarkAllSubMeshesAsTexturesDirty = material._dirtyCallbacks[1];\n        this._internalMarkScenePrePassDirty = material._dirtyCallbacks[32];\n    }\n    isReadyForSubMesh(defines, scene) {\n        if (!this._isRefractionEnabled && !this._isTranslucencyEnabled && !this._isScatteringEnabled) {\n            return true;\n        }\n        if (defines._areTexturesDirty) {\n            if (scene.texturesEnabled) {\n                if (this._thicknessTexture && MaterialFlags.ThicknessTextureEnabled) {\n                    if (!this._thicknessTexture.isReadyOrNotBlocking()) {\n                        return false;\n                    }\n                }\n                const refractionTexture = this._getRefractionTexture(scene);\n                if (refractionTexture && MaterialFlags.RefractionTextureEnabled) {\n                    if (!refractionTexture.isReadyOrNotBlocking()) {\n                        return false;\n                    }\n                }\n            }\n        }\n        return true;\n    }\n    prepareDefinesBeforeAttributes(defines, scene) {\n        if (!this._isRefractionEnabled && !this._isTranslucencyEnabled && !this._isScatteringEnabled) {\n            defines.SUBSURFACE = false;\n            defines.SS_TRANSLUCENCY = false;\n            defines.SS_SCATTERING = false;\n            defines.SS_REFRACTION = false;\n            defines.SS_REFRACTION_USE_INTENSITY_FROM_TEXTURE = false;\n            defines.SS_TRANSLUCENCY_USE_INTENSITY_FROM_TEXTURE = false;\n            defines.SS_THICKNESSANDMASK_TEXTURE = false;\n            defines.SS_THICKNESSANDMASK_TEXTUREDIRECTUV = 0;\n            defines.SS_HAS_THICKNESS = false;\n            defines.SS_REFRACTIONINTENSITY_TEXTURE = false;\n            defines.SS_REFRACTIONINTENSITY_TEXTUREDIRECTUV = 0;\n            defines.SS_TRANSLUCENCYINTENSITY_TEXTURE = false;\n            defines.SS_TRANSLUCENCYINTENSITY_TEXTUREDIRECTUV = 0;\n            defines.SS_REFRACTIONMAP_3D = false;\n            defines.SS_REFRACTIONMAP_OPPOSITEZ = false;\n            defines.SS_LODINREFRACTIONALPHA = false;\n            defines.SS_GAMMAREFRACTION = false;\n            defines.SS_RGBDREFRACTION = false;\n            defines.SS_LINEARSPECULARREFRACTION = false;\n            defines.SS_LINKREFRACTIONTOTRANSPARENCY = false;\n            defines.SS_ALBEDOFORREFRACTIONTINT = false;\n            defines.SS_ALBEDOFORTRANSLUCENCYTINT = false;\n            defines.SS_USE_LOCAL_REFRACTIONMAP_CUBIC = false;\n            defines.SS_USE_THICKNESS_AS_DEPTH = false;\n            defines.SS_MASK_FROM_THICKNESS_TEXTURE = false;\n            defines.SS_USE_GLTF_TEXTURES = false;\n            return;\n        }\n        if (defines._areTexturesDirty) {\n            defines.SUBSURFACE = true;\n            defines.SS_TRANSLUCENCY = this._isTranslucencyEnabled;\n            defines.SS_TRANSLUCENCY_USE_INTENSITY_FROM_TEXTURE = false;\n            defines.SS_SCATTERING = this._isScatteringEnabled;\n            defines.SS_THICKNESSANDMASK_TEXTURE = false;\n            defines.SS_REFRACTIONINTENSITY_TEXTURE = false;\n            defines.SS_TRANSLUCENCYINTENSITY_TEXTURE = false;\n            defines.SS_HAS_THICKNESS = false;\n            defines.SS_MASK_FROM_THICKNESS_TEXTURE = false;\n            defines.SS_USE_GLTF_TEXTURES = false;\n            defines.SS_REFRACTION = false;\n            defines.SS_REFRACTION_USE_INTENSITY_FROM_TEXTURE = false;\n            defines.SS_REFRACTIONMAP_3D = false;\n            defines.SS_GAMMAREFRACTION = false;\n            defines.SS_RGBDREFRACTION = false;\n            defines.SS_LINEARSPECULARREFRACTION = false;\n            defines.SS_REFRACTIONMAP_OPPOSITEZ = false;\n            defines.SS_LODINREFRACTIONALPHA = false;\n            defines.SS_LINKREFRACTIONTOTRANSPARENCY = false;\n            defines.SS_ALBEDOFORREFRACTIONTINT = false;\n            defines.SS_ALBEDOFORTRANSLUCENCYTINT = false;\n            defines.SS_USE_LOCAL_REFRACTIONMAP_CUBIC = false;\n            defines.SS_USE_THICKNESS_AS_DEPTH = false;\n            const refractionIntensityTextureIsThicknessTexture = !!this._thicknessTexture &&\n                !!this._refractionIntensityTexture &&\n                this._refractionIntensityTexture.checkTransformsAreIdentical(this._thicknessTexture) &&\n                this._refractionIntensityTexture._texture === this._thicknessTexture._texture;\n            const translucencyIntensityTextureIsThicknessTexture = !!this._thicknessTexture &&\n                !!this._translucencyIntensityTexture &&\n                this._translucencyIntensityTexture.checkTransformsAreIdentical(this._thicknessTexture) &&\n                this._translucencyIntensityTexture._texture === this._thicknessTexture._texture;\n            // if true, it means the refraction/translucency textures are the same than the thickness texture so there's no need to pass them to the shader, only thicknessTexture\n            const useOnlyThicknessTexture = (refractionIntensityTextureIsThicknessTexture || !this._refractionIntensityTexture) &&\n                (translucencyIntensityTextureIsThicknessTexture || !this._translucencyIntensityTexture);\n            if (defines._areTexturesDirty) {\n                if (scene.texturesEnabled) {\n                    if (this._thicknessTexture && MaterialFlags.ThicknessTextureEnabled) {\n                        MaterialHelper.PrepareDefinesForMergedUV(this._thicknessTexture, defines, \"SS_THICKNESSANDMASK_TEXTURE\");\n                    }\n                    if (this._refractionIntensityTexture && MaterialFlags.RefractionIntensityTextureEnabled && !useOnlyThicknessTexture) {\n                        MaterialHelper.PrepareDefinesForMergedUV(this._refractionIntensityTexture, defines, \"SS_REFRACTIONINTENSITY_TEXTURE\");\n                    }\n                    if (this._translucencyIntensityTexture && MaterialFlags.TranslucencyIntensityTextureEnabled && !useOnlyThicknessTexture) {\n                        MaterialHelper.PrepareDefinesForMergedUV(this._translucencyIntensityTexture, defines, \"SS_TRANSLUCENCYINTENSITY_TEXTURE\");\n                    }\n                }\n            }\n            defines.SS_HAS_THICKNESS = this.maximumThickness - this.minimumThickness !== 0.0;\n            defines.SS_MASK_FROM_THICKNESS_TEXTURE =\n                (this._useMaskFromThicknessTexture || !!this._refractionIntensityTexture || !!this._translucencyIntensityTexture) && useOnlyThicknessTexture;\n            defines.SS_USE_GLTF_TEXTURES = this._useGltfStyleTextures;\n            defines.SS_REFRACTION_USE_INTENSITY_FROM_TEXTURE = (this._useMaskFromThicknessTexture || !!this._refractionIntensityTexture) && useOnlyThicknessTexture;\n            defines.SS_TRANSLUCENCY_USE_INTENSITY_FROM_TEXTURE = (this._useMaskFromThicknessTexture || !!this._translucencyIntensityTexture) && useOnlyThicknessTexture;\n            if (this._isRefractionEnabled) {\n                if (scene.texturesEnabled) {\n                    const refractionTexture = this._getRefractionTexture(scene);\n                    if (refractionTexture && MaterialFlags.RefractionTextureEnabled) {\n                        defines.SS_REFRACTION = true;\n                        defines.SS_REFRACTIONMAP_3D = refractionTexture.isCube;\n                        defines.SS_GAMMAREFRACTION = refractionTexture.gammaSpace;\n                        defines.SS_RGBDREFRACTION = refractionTexture.isRGBD;\n                        defines.SS_LINEARSPECULARREFRACTION = refractionTexture.linearSpecularLOD;\n                        defines.SS_REFRACTIONMAP_OPPOSITEZ = refractionTexture.invertZ;\n                        defines.SS_LODINREFRACTIONALPHA = refractionTexture.lodLevelInAlpha;\n                        defines.SS_LINKREFRACTIONTOTRANSPARENCY = this._linkRefractionWithTransparency;\n                        defines.SS_ALBEDOFORREFRACTIONTINT = this.useAlbedoToTintRefraction;\n                        defines.SS_USE_LOCAL_REFRACTIONMAP_CUBIC = refractionTexture.isCube && refractionTexture.boundingBoxSize;\n                        defines.SS_USE_THICKNESS_AS_DEPTH = this.useThicknessAsDepth;\n                    }\n                }\n            }\n            if (this._isTranslucencyEnabled) {\n                defines.SS_ALBEDOFORTRANSLUCENCYTINT = this.useAlbedoToTintTranslucency;\n            }\n        }\n    }\n    /**\n     * Binds the material data (this function is called even if mustRebind() returns false)\n     * @param uniformBuffer defines the Uniform buffer to fill in.\n     * @param scene defines the scene the material belongs to.\n     * @param engine defines the engine the material belongs to.\n     * @param subMesh the submesh to bind data for\n     */\n    hardBindForSubMesh(uniformBuffer, scene, engine, subMesh) {\n        if (!this._isRefractionEnabled && !this._isTranslucencyEnabled && !this._isScatteringEnabled) {\n            return;\n        }\n        subMesh.getRenderingMesh().getWorldMatrix().decompose(TmpVectors.Vector3[0]);\n        const thicknessScale = Math.max(Math.abs(TmpVectors.Vector3[0].x), Math.abs(TmpVectors.Vector3[0].y), Math.abs(TmpVectors.Vector3[0].z));\n        uniformBuffer.updateFloat2(\"vThicknessParam\", this.minimumThickness * thicknessScale, (this.maximumThickness - this.minimumThickness) * thicknessScale);\n    }\n    bindForSubMesh(uniformBuffer, scene, engine, subMesh) {\n        if (!this._isRefractionEnabled && !this._isTranslucencyEnabled && !this._isScatteringEnabled) {\n            return;\n        }\n        const defines = subMesh.materialDefines;\n        const isFrozen = this._material.isFrozen;\n        const realTimeFiltering = this._material.realTimeFiltering;\n        const lodBasedMicrosurface = defines.LODBASEDMICROSFURACE;\n        const refractionTexture = this._getRefractionTexture(scene);\n        if (!uniformBuffer.useUbo || !isFrozen || !uniformBuffer.isSync) {\n            if (this._thicknessTexture && MaterialFlags.ThicknessTextureEnabled) {\n                uniformBuffer.updateFloat2(\"vThicknessInfos\", this._thicknessTexture.coordinatesIndex, this._thicknessTexture.level);\n                MaterialHelper.BindTextureMatrix(this._thicknessTexture, uniformBuffer, \"thickness\");\n            }\n            if (this._refractionIntensityTexture && MaterialFlags.RefractionIntensityTextureEnabled && defines.SS_REFRACTIONINTENSITY_TEXTURE) {\n                uniformBuffer.updateFloat2(\"vRefractionIntensityInfos\", this._refractionIntensityTexture.coordinatesIndex, this._refractionIntensityTexture.level);\n                MaterialHelper.BindTextureMatrix(this._refractionIntensityTexture, uniformBuffer, \"refractionIntensity\");\n            }\n            if (this._translucencyIntensityTexture && MaterialFlags.TranslucencyIntensityTextureEnabled && defines.SS_TRANSLUCENCYINTENSITY_TEXTURE) {\n                uniformBuffer.updateFloat2(\"vTranslucencyIntensityInfos\", this._translucencyIntensityTexture.coordinatesIndex, this._translucencyIntensityTexture.level);\n                MaterialHelper.BindTextureMatrix(this._translucencyIntensityTexture, uniformBuffer, \"translucencyIntensity\");\n            }\n            if (refractionTexture && MaterialFlags.RefractionTextureEnabled) {\n                uniformBuffer.updateMatrix(\"refractionMatrix\", refractionTexture.getReflectionTextureMatrix());\n                let depth = 1.0;\n                if (!refractionTexture.isCube) {\n                    if (refractionTexture.depth) {\n                        depth = refractionTexture.depth;\n                    }\n                }\n                const width = refractionTexture.getSize().width;\n                const refractionIor = this.volumeIndexOfRefraction;\n                uniformBuffer.updateFloat4(\"vRefractionInfos\", refractionTexture.level, 1 / refractionIor, depth, this._invertRefractionY ? -1 : 1);\n                uniformBuffer.updateFloat4(\"vRefractionMicrosurfaceInfos\", width, refractionTexture.lodGenerationScale, refractionTexture.lodGenerationOffset, 1.0 / this.indexOfRefraction);\n                if (realTimeFiltering) {\n                    uniformBuffer.updateFloat2(\"vRefractionFilteringInfo\", width, Scalar.Log2(width));\n                }\n                if (refractionTexture.boundingBoxSize) {\n                    const cubeTexture = refractionTexture;\n                    uniformBuffer.updateVector3(\"vRefractionPosition\", cubeTexture.boundingBoxPosition);\n                    uniformBuffer.updateVector3(\"vRefractionSize\", cubeTexture.boundingBoxSize);\n                }\n            }\n            if (this._isScatteringEnabled) {\n                uniformBuffer.updateFloat(\"scatteringDiffusionProfile\", this._scatteringDiffusionProfileIndex);\n            }\n            uniformBuffer.updateColor3(\"vDiffusionDistance\", this.diffusionDistance);\n            uniformBuffer.updateFloat4(\"vTintColor\", this.tintColor.r, this.tintColor.g, this.tintColor.b, Math.max(0.00001, this.tintColorAtDistance));\n            uniformBuffer.updateFloat3(\"vSubSurfaceIntensity\", this.refractionIntensity, this.translucencyIntensity, 0);\n        }\n        // Textures\n        if (scene.texturesEnabled) {\n            if (this._thicknessTexture && MaterialFlags.ThicknessTextureEnabled) {\n                uniformBuffer.setTexture(\"thicknessSampler\", this._thicknessTexture);\n            }\n            if (this._refractionIntensityTexture && MaterialFlags.RefractionIntensityTextureEnabled && defines.SS_REFRACTIONINTENSITY_TEXTURE) {\n                uniformBuffer.setTexture(\"refractionIntensitySampler\", this._refractionIntensityTexture);\n            }\n            if (this._translucencyIntensityTexture && MaterialFlags.TranslucencyIntensityTextureEnabled && defines.SS_TRANSLUCENCYINTENSITY_TEXTURE) {\n                uniformBuffer.setTexture(\"translucencyIntensitySampler\", this._translucencyIntensityTexture);\n            }\n            if (refractionTexture && MaterialFlags.RefractionTextureEnabled) {\n                if (lodBasedMicrosurface) {\n                    uniformBuffer.setTexture(\"refractionSampler\", refractionTexture);\n                }\n                else {\n                    uniformBuffer.setTexture(\"refractionSampler\", refractionTexture._lodTextureMid || refractionTexture);\n                    uniformBuffer.setTexture(\"refractionSamplerLow\", refractionTexture._lodTextureLow || refractionTexture);\n                    uniformBuffer.setTexture(\"refractionSamplerHigh\", refractionTexture._lodTextureHigh || refractionTexture);\n                }\n            }\n        }\n    }\n    /**\n     * Returns the texture used for refraction or null if none is used.\n     * @param scene defines the scene the material belongs to.\n     * @returns - Refraction texture if present.  If no refraction texture and refraction\n     * is linked with transparency, returns environment texture.  Otherwise, returns null.\n     */\n    _getRefractionTexture(scene) {\n        if (this._refractionTexture) {\n            return this._refractionTexture;\n        }\n        if (this._isRefractionEnabled) {\n            return scene.environmentTexture;\n        }\n        return null;\n    }\n    /**\n     * Returns true if alpha blending should be disabled.\n     */\n    get disableAlphaBlending() {\n        return this._isRefractionEnabled && this._linkRefractionWithTransparency;\n    }\n    /**\n     * Fills the list of render target textures.\n     * @param renderTargets the list of render targets to update\n     */\n    fillRenderTargetTextures(renderTargets) {\n        if (MaterialFlags.RefractionTextureEnabled && this._refractionTexture && this._refractionTexture.isRenderTarget) {\n            renderTargets.push(this._refractionTexture);\n        }\n    }\n    hasTexture(texture) {\n        if (this._thicknessTexture === texture) {\n            return true;\n        }\n        if (this._refractionTexture === texture) {\n            return true;\n        }\n        return false;\n    }\n    hasRenderTargetTextures() {\n        if (MaterialFlags.RefractionTextureEnabled && this._refractionTexture && this._refractionTexture.isRenderTarget) {\n            return true;\n        }\n        return false;\n    }\n    getActiveTextures(activeTextures) {\n        if (this._thicknessTexture) {\n            activeTextures.push(this._thicknessTexture);\n        }\n        if (this._refractionTexture) {\n            activeTextures.push(this._refractionTexture);\n        }\n    }\n    getAnimatables(animatables) {\n        if (this._thicknessTexture && this._thicknessTexture.animations && this._thicknessTexture.animations.length > 0) {\n            animatables.push(this._thicknessTexture);\n        }\n        if (this._refractionTexture && this._refractionTexture.animations && this._refractionTexture.animations.length > 0) {\n            animatables.push(this._refractionTexture);\n        }\n    }\n    dispose(forceDisposeTextures) {\n        if (forceDisposeTextures) {\n            if (this._thicknessTexture) {\n                this._thicknessTexture.dispose();\n            }\n            if (this._refractionTexture) {\n                this._refractionTexture.dispose();\n            }\n        }\n    }\n    getClassName() {\n        return \"PBRSubSurfaceConfiguration\";\n    }\n    addFallbacks(defines, fallbacks, currentRank) {\n        if (defines.SS_SCATTERING) {\n            fallbacks.addFallback(currentRank++, \"SS_SCATTERING\");\n        }\n        if (defines.SS_TRANSLUCENCY) {\n            fallbacks.addFallback(currentRank++, \"SS_TRANSLUCENCY\");\n        }\n        return currentRank;\n    }\n    getSamplers(samplers) {\n        samplers.push(\"thicknessSampler\", \"refractionIntensitySampler\", \"translucencyIntensitySampler\", \"refractionSampler\", \"refractionSamplerLow\", \"refractionSamplerHigh\");\n    }\n    getUniforms() {\n        return {\n            ubo: [\n                { name: \"vRefractionMicrosurfaceInfos\", size: 4, type: \"vec4\" },\n                { name: \"vRefractionFilteringInfo\", size: 2, type: \"vec2\" },\n                { name: \"vTranslucencyIntensityInfos\", size: 2, type: \"vec2\" },\n                { name: \"vRefractionInfos\", size: 4, type: \"vec4\" },\n                { name: \"refractionMatrix\", size: 16, type: \"mat4\" },\n                { name: \"vThicknessInfos\", size: 2, type: \"vec2\" },\n                { name: \"vRefractionIntensityInfos\", size: 2, type: \"vec2\" },\n                { name: \"thicknessMatrix\", size: 16, type: \"mat4\" },\n                { name: \"refractionIntensityMatrix\", size: 16, type: \"mat4\" },\n                { name: \"translucencyIntensityMatrix\", size: 16, type: \"mat4\" },\n                { name: \"vThicknessParam\", size: 2, type: \"vec2\" },\n                { name: \"vDiffusionDistance\", size: 3, type: \"vec3\" },\n                { name: \"vTintColor\", size: 4, type: \"vec4\" },\n                { name: \"vSubSurfaceIntensity\", size: 3, type: \"vec3\" },\n                { name: \"vRefractionPosition\", size: 3, type: \"vec3\" },\n                { name: \"vRefractionSize\", size: 3, type: \"vec3\" },\n                { name: \"scatteringDiffusionProfile\", size: 1, type: \"float\" },\n            ],\n        };\n    }\n}\n__decorate([\n    serialize(),\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], PBRSubSurfaceConfiguration.prototype, \"isRefractionEnabled\", void 0);\n__decorate([\n    serialize(),\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], PBRSubSurfaceConfiguration.prototype, \"isTranslucencyEnabled\", void 0);\n__decorate([\n    serialize(),\n    expandToProperty(\"_markScenePrePassDirty\")\n], PBRSubSurfaceConfiguration.prototype, \"isScatteringEnabled\", void 0);\n__decorate([\n    serialize()\n], PBRSubSurfaceConfiguration.prototype, \"_scatteringDiffusionProfileIndex\", void 0);\n__decorate([\n    serialize()\n], PBRSubSurfaceConfiguration.prototype, \"refractionIntensity\", void 0);\n__decorate([\n    serialize()\n], PBRSubSurfaceConfiguration.prototype, \"translucencyIntensity\", void 0);\n__decorate([\n    serialize()\n], PBRSubSurfaceConfiguration.prototype, \"useAlbedoToTintRefraction\", void 0);\n__decorate([\n    serialize()\n], PBRSubSurfaceConfiguration.prototype, \"useAlbedoToTintTranslucency\", void 0);\n__decorate([\n    serializeAsTexture(),\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], PBRSubSurfaceConfiguration.prototype, \"thicknessTexture\", void 0);\n__decorate([\n    serializeAsTexture(),\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], PBRSubSurfaceConfiguration.prototype, \"refractionTexture\", void 0);\n__decorate([\n    serialize(),\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], PBRSubSurfaceConfiguration.prototype, \"indexOfRefraction\", void 0);\n__decorate([\n    serialize()\n], PBRSubSurfaceConfiguration.prototype, \"_volumeIndexOfRefraction\", void 0);\n__decorate([\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], PBRSubSurfaceConfiguration.prototype, \"volumeIndexOfRefraction\", null);\n__decorate([\n    serialize(),\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], PBRSubSurfaceConfiguration.prototype, \"invertRefractionY\", void 0);\n__decorate([\n    serialize(),\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], PBRSubSurfaceConfiguration.prototype, \"linkRefractionWithTransparency\", void 0);\n__decorate([\n    serialize()\n], PBRSubSurfaceConfiguration.prototype, \"minimumThickness\", void 0);\n__decorate([\n    serialize()\n], PBRSubSurfaceConfiguration.prototype, \"maximumThickness\", void 0);\n__decorate([\n    serialize()\n], PBRSubSurfaceConfiguration.prototype, \"useThicknessAsDepth\", void 0);\n__decorate([\n    serializeAsColor3()\n], PBRSubSurfaceConfiguration.prototype, \"tintColor\", void 0);\n__decorate([\n    serialize()\n], PBRSubSurfaceConfiguration.prototype, \"tintColorAtDistance\", void 0);\n__decorate([\n    serializeAsColor3()\n], PBRSubSurfaceConfiguration.prototype, \"diffusionDistance\", void 0);\n__decorate([\n    serialize(),\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], PBRSubSurfaceConfiguration.prototype, \"useMaskFromThicknessTexture\", void 0);\n__decorate([\n    serializeAsTexture(),\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], PBRSubSurfaceConfiguration.prototype, \"refractionIntensityTexture\", void 0);\n__decorate([\n    serializeAsTexture(),\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], PBRSubSurfaceConfiguration.prototype, \"translucencyIntensityTexture\", void 0);\n__decorate([\n    serialize(),\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], PBRSubSurfaceConfiguration.prototype, \"useGltfStyleTextures\", void 0);\n//# sourceMappingURL=pbrSubSurfaceConfiguration.js.map","import { Vector3 } from \"../../../Maths/math.js\";\nimport { Scalar } from \"../../../Maths/math.scalar.js\";\n\nimport { EffectWrapper, EffectRenderer } from \"../../../Materials/effectRenderer.js\";\nimport \"../../../Shaders/hdrFiltering.vertex.js\";\nimport \"../../../Shaders/hdrFiltering.fragment.js\";\nimport { Logger } from \"../../../Misc/logger.js\";\n/**\n * Filters HDR maps to get correct renderings of PBR reflections\n */\nexport class HDRFiltering {\n    /**\n     * Instantiates HDR filter for reflection maps\n     *\n     * @param engine Thin engine\n     * @param options Options\n     */\n    constructor(engine, options = {}) {\n        this._lodGenerationOffset = 0;\n        this._lodGenerationScale = 0.8;\n        /**\n         * Quality switch for prefiltering. Should be set to `4096` unless\n         * you care about baking speed.\n         */\n        this.quality = 4096;\n        /**\n         * Scales pixel intensity for the input HDR map.\n         */\n        this.hdrScale = 1;\n        // pass\n        this._engine = engine;\n        this.hdrScale = options.hdrScale || this.hdrScale;\n        this.quality = options.quality || this.quality;\n    }\n    _createRenderTarget(size) {\n        let textureType = 0;\n        if (this._engine.getCaps().textureHalfFloatRender) {\n            textureType = 2;\n        }\n        else if (this._engine.getCaps().textureFloatRender) {\n            textureType = 1;\n        }\n        const rtWrapper = this._engine.createRenderTargetCubeTexture(size, {\n            format: 5,\n            type: textureType,\n            createMipMaps: true,\n            generateMipMaps: false,\n            generateDepthBuffer: false,\n            generateStencilBuffer: false,\n            samplingMode: 1,\n        });\n        this._engine.updateTextureWrappingMode(rtWrapper.texture, 0, 0, 0);\n        this._engine.updateTextureSamplingMode(3, rtWrapper.texture, true);\n        return rtWrapper;\n    }\n    _prefilterInternal(texture) {\n        const width = texture.getSize().width;\n        const mipmapsCount = Scalar.ILog2(width) + 1;\n        const effect = this._effectWrapper.effect;\n        const outputTexture = this._createRenderTarget(width);\n        this._effectRenderer.setViewport();\n        const intTexture = texture.getInternalTexture();\n        if (intTexture) {\n            // Just in case generate fresh clean mips.\n            this._engine.updateTextureSamplingMode(3, intTexture, true);\n        }\n        this._effectRenderer.applyEffectWrapper(this._effectWrapper);\n        const directions = [\n            [new Vector3(0, 0, -1), new Vector3(0, -1, 0), new Vector3(1, 0, 0)],\n            [new Vector3(0, 0, 1), new Vector3(0, -1, 0), new Vector3(-1, 0, 0)],\n            [new Vector3(1, 0, 0), new Vector3(0, 0, 1), new Vector3(0, 1, 0)],\n            [new Vector3(1, 0, 0), new Vector3(0, 0, -1), new Vector3(0, -1, 0)],\n            [new Vector3(1, 0, 0), new Vector3(0, -1, 0), new Vector3(0, 0, 1)],\n            [new Vector3(-1, 0, 0), new Vector3(0, -1, 0), new Vector3(0, 0, -1)], // NegativeZ\n        ];\n        effect.setFloat(\"hdrScale\", this.hdrScale);\n        effect.setFloat2(\"vFilteringInfo\", texture.getSize().width, mipmapsCount);\n        effect.setTexture(\"inputTexture\", texture);\n        for (let face = 0; face < 6; face++) {\n            effect.setVector3(\"up\", directions[face][0]);\n            effect.setVector3(\"right\", directions[face][1]);\n            effect.setVector3(\"front\", directions[face][2]);\n            for (let lod = 0; lod < mipmapsCount; lod++) {\n                this._engine.bindFramebuffer(outputTexture, face, undefined, undefined, true, lod);\n                this._effectRenderer.applyEffectWrapper(this._effectWrapper);\n                let alpha = Math.pow(2, (lod - this._lodGenerationOffset) / this._lodGenerationScale) / width;\n                if (lod === 0) {\n                    alpha = 0;\n                }\n                effect.setFloat(\"alphaG\", alpha);\n                this._effectRenderer.draw();\n            }\n        }\n        // Cleanup\n        this._effectRenderer.restoreStates();\n        this._engine.restoreDefaultFramebuffer();\n        this._engine._releaseTexture(texture._texture);\n        // Internal Swap\n        outputTexture._swapAndDie(texture._texture);\n        texture._prefiltered = true;\n        return texture;\n    }\n    _createEffect(texture, onCompiled) {\n        const defines = [];\n        if (texture.gammaSpace) {\n            defines.push(\"#define GAMMA_INPUT\");\n        }\n        defines.push(\"#define NUM_SAMPLES \" + this.quality + \"u\"); // unsigned int\n        const effectWrapper = new EffectWrapper({\n            engine: this._engine,\n            name: \"hdrFiltering\",\n            vertexShader: \"hdrFiltering\",\n            fragmentShader: \"hdrFiltering\",\n            samplerNames: [\"inputTexture\"],\n            uniformNames: [\"vSampleDirections\", \"vWeights\", \"up\", \"right\", \"front\", \"vFilteringInfo\", \"hdrScale\", \"alphaG\"],\n            useShaderStore: true,\n            defines,\n            onCompiled: onCompiled,\n        });\n        return effectWrapper;\n    }\n    /**\n     * Get a value indicating if the filter is ready to be used\n     * @param texture Texture to filter\n     * @returns true if the filter is ready\n     */\n    isReady(texture) {\n        return texture.isReady() && this._effectWrapper.effect.isReady();\n    }\n    /**\n     * Prefilters a cube texture to have mipmap levels representing roughness values.\n     * Prefiltering will be invoked at the end of next rendering pass.\n     * This has to be done once the map is loaded, and has not been prefiltered by a third party software.\n     * See http://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf for more information\n     * @param texture Texture to filter\n     * @param onFinished Callback when filtering is done\n     * @returns Promise called when prefiltering is done\n     */\n    prefilter(texture, onFinished = null) {\n        if (!this._engine._features.allowTexturePrefiltering) {\n            Logger.Warn(\"HDR prefiltering is not available in WebGL 1., you can use real time filtering instead.\");\n            return Promise.reject(\"HDR prefiltering is not available in WebGL 1., you can use real time filtering instead.\");\n        }\n        return new Promise((resolve) => {\n            this._effectRenderer = new EffectRenderer(this._engine);\n            this._effectWrapper = this._createEffect(texture);\n            this._effectWrapper.effect.executeWhenCompiled(() => {\n                this._prefilterInternal(texture);\n                this._effectRenderer.dispose();\n                this._effectWrapper.dispose();\n                resolve();\n                if (onFinished) {\n                    onFinished();\n                }\n            });\n        });\n    }\n}\n//# sourceMappingURL=hdrFiltering.js.map","import { SphericalPolynomial } from \"../../../Maths/sphericalPolynomial.js\";\nimport { Engine } from \"../../../Engines/engine.js\";\nimport { DDSTools } from \"../../../Misc/dds.js\";\n/**\n * Implementation of the DDS Texture Loader.\n * @internal\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport class _DDSTextureLoader {\n    constructor() {\n        /**\n         * Defines whether the loader supports cascade loading the different faces.\n         */\n        this.supportCascades = true;\n    }\n    /**\n     * This returns if the loader support the current file information.\n     * @param extension defines the file extension of the file being loaded\n     * @returns true if the loader can load the specified file\n     */\n    canLoad(extension) {\n        return extension.endsWith(\".dds\");\n    }\n    /**\n     * Uploads the cube texture data to the WebGL texture. It has already been bound.\n     * @param imgs contains the cube maps\n     * @param texture defines the BabylonJS internal texture\n     * @param createPolynomials will be true if polynomials have been requested\n     * @param onLoad defines the callback to trigger once the texture is ready\n     */\n    loadCubeData(imgs, texture, createPolynomials, onLoad) {\n        const engine = texture.getEngine();\n        let info;\n        let loadMipmap = false;\n        let maxLevel = 1000;\n        if (Array.isArray(imgs)) {\n            for (let index = 0; index < imgs.length; index++) {\n                const data = imgs[index];\n                info = DDSTools.GetDDSInfo(data);\n                texture.width = info.width;\n                texture.height = info.height;\n                loadMipmap = (info.isRGB || info.isLuminance || info.mipmapCount > 1) && texture.generateMipMaps;\n                engine._unpackFlipY(info.isCompressed);\n                DDSTools.UploadDDSLevels(engine, texture, data, info, loadMipmap, 6, -1, index);\n                if (!info.isFourCC && info.mipmapCount === 1) {\n                    engine.generateMipMapsForCubemap(texture);\n                }\n                else {\n                    maxLevel = info.mipmapCount - 1;\n                }\n            }\n        }\n        else {\n            const data = imgs;\n            info = DDSTools.GetDDSInfo(data);\n            texture.width = info.width;\n            texture.height = info.height;\n            if (createPolynomials) {\n                info.sphericalPolynomial = new SphericalPolynomial();\n            }\n            loadMipmap = (info.isRGB || info.isLuminance || info.mipmapCount > 1) && texture.generateMipMaps;\n            engine._unpackFlipY(info.isCompressed);\n            DDSTools.UploadDDSLevels(engine, texture, data, info, loadMipmap, 6);\n            if (!info.isFourCC && info.mipmapCount === 1) {\n                // Do not unbind as we still need to set the parameters.\n                engine.generateMipMapsForCubemap(texture, false);\n            }\n            else {\n                maxLevel = info.mipmapCount - 1;\n            }\n        }\n        engine._setCubeMapTextureParams(texture, loadMipmap, maxLevel);\n        texture.isReady = true;\n        texture.onLoadedObservable.notifyObservers(texture);\n        texture.onLoadedObservable.clear();\n        if (onLoad) {\n            onLoad({ isDDS: true, width: texture.width, info, data: imgs, texture });\n        }\n    }\n    /**\n     * Uploads the 2D texture data to the WebGL texture. It has already been bound once in the callback.\n     * @param data contains the texture data\n     * @param texture defines the BabylonJS internal texture\n     * @param callback defines the method to call once ready to upload\n     */\n    loadData(data, texture, callback) {\n        const info = DDSTools.GetDDSInfo(data);\n        const loadMipmap = (info.isRGB || info.isLuminance || info.mipmapCount > 1) && texture.generateMipMaps && info.width >> (info.mipmapCount - 1) === 1;\n        callback(info.width, info.height, loadMipmap, info.isFourCC, () => {\n            DDSTools.UploadDDSLevels(texture.getEngine(), texture, data, info, loadMipmap, 1);\n        });\n    }\n}\n// Register the loader.\nEngine._TextureLoaders.push(new _DDSTextureLoader());\n//# sourceMappingURL=ddsTextureLoader.js.map","import { GetEnvInfo, UploadEnvLevelsAsync, UploadEnvSpherical } from \"../../../Misc/environmentTextureTools.js\";\nimport { Engine } from \"../../../Engines/engine.js\";\n/**\n * Implementation of the ENV Texture Loader.\n * @internal\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport class _ENVTextureLoader {\n    constructor() {\n        /**\n         * Defines whether the loader supports cascade loading the different faces.\n         */\n        this.supportCascades = false;\n    }\n    /**\n     * This returns if the loader support the current file information.\n     * @param extension defines the file extension of the file being loaded\n     * @returns true if the loader can load the specified file\n     */\n    canLoad(extension) {\n        return extension.endsWith(\".env\");\n    }\n    /**\n     * Uploads the cube texture data to the WebGL texture. It has already been bound.\n     * @param data contains the texture data\n     * @param texture defines the BabylonJS internal texture\n     * @param createPolynomials will be true if polynomials have been requested\n     * @param onLoad defines the callback to trigger once the texture is ready\n     * @param onError defines the callback to trigger in case of error\n     */\n    loadCubeData(data, texture, createPolynomials, onLoad, onError) {\n        if (Array.isArray(data)) {\n            return;\n        }\n        const info = GetEnvInfo(data);\n        if (info) {\n            texture.width = info.width;\n            texture.height = info.width;\n            try {\n                UploadEnvSpherical(texture, info);\n                UploadEnvLevelsAsync(texture, data, info).then(() => {\n                    texture.isReady = true;\n                    texture.onLoadedObservable.notifyObservers(texture);\n                    texture.onLoadedObservable.clear();\n                    if (onLoad) {\n                        onLoad();\n                    }\n                }, (reason) => {\n                    onError === null || onError === void 0 ? void 0 : onError(\"Can not upload environment levels\", reason);\n                });\n            }\n            catch (e) {\n                onError === null || onError === void 0 ? void 0 : onError(\"Can not upload environment file\", e);\n            }\n        }\n        else if (onError) {\n            onError(\"Can not parse the environment file\", null);\n        }\n    }\n    /**\n     * Uploads the 2D texture data to the WebGL texture. It has already been bound once in the callback.\n     */\n    loadData() {\n        throw \".env not supported in 2d.\";\n    }\n}\n// Register the loader.\nEngine._TextureLoaders.push(new _ENVTextureLoader());\n//# sourceMappingURL=envTextureLoader.js.map","import { KhronosTextureContainer } from \"../../../Misc/khronosTextureContainer.js\";\nimport { KhronosTextureContainer2 } from \"../../../Misc/khronosTextureContainer2.js\";\nimport { Engine } from \"../../../Engines/engine.js\";\nimport { Logger } from \"../../../Misc/logger.js\";\n\nfunction mapSRGBToLinear(format) {\n    switch (format) {\n        case 35916:\n            return 33776;\n        case 35918:\n            return 33778;\n        case 35919:\n            return 33779;\n        case 37493:\n            return 37492;\n        case 37497:\n            return 37496;\n        case 37495:\n            return 37494;\n        case 37840:\n            return 37808;\n        case 36493:\n            return 36492;\n    }\n    return null;\n}\n/**\n * Implementation of the KTX Texture Loader.\n * @internal\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport class _KTXTextureLoader {\n    constructor() {\n        /**\n         * Defines whether the loader supports cascade loading the different faces.\n         */\n        this.supportCascades = false;\n    }\n    /**\n     * This returns if the loader support the current file information.\n     * @param extension defines the file extension of the file being loaded\n     * @param mimeType defines the optional mime type of the file being loaded\n     * @returns true if the loader can load the specified file\n     */\n    canLoad(extension, mimeType) {\n        // The \".ktx2\" file extension is still up for debate: https://github.com/KhronosGroup/KTX-Specification/issues/18\n        return extension.endsWith(\".ktx\") || extension.endsWith(\".ktx2\") || mimeType === \"image/ktx\" || mimeType === \"image/ktx2\";\n    }\n    /**\n     * Uploads the cube texture data to the WebGL texture. It has already been bound.\n     * @param data contains the texture data\n     * @param texture defines the BabylonJS internal texture\n     * @param createPolynomials will be true if polynomials have been requested\n     * @param onLoad defines the callback to trigger once the texture is ready\n     */\n    loadCubeData(data, texture, createPolynomials, onLoad) {\n        if (Array.isArray(data)) {\n            return;\n        }\n        // Need to invert vScale as invertY via UNPACK_FLIP_Y_WEBGL is not supported by compressed texture\n        texture._invertVScale = !texture.invertY;\n        const engine = texture.getEngine();\n        const ktx = new KhronosTextureContainer(data, 6);\n        const loadMipmap = ktx.numberOfMipmapLevels > 1 && texture.generateMipMaps;\n        engine._unpackFlipY(true);\n        ktx.uploadLevels(texture, texture.generateMipMaps);\n        texture.width = ktx.pixelWidth;\n        texture.height = ktx.pixelHeight;\n        engine._setCubeMapTextureParams(texture, loadMipmap, ktx.numberOfMipmapLevels - 1);\n        texture.isReady = true;\n        texture.onLoadedObservable.notifyObservers(texture);\n        texture.onLoadedObservable.clear();\n        if (onLoad) {\n            onLoad();\n        }\n    }\n    /**\n     * Uploads the 2D texture data to the WebGL texture. It has already been bound once in the callback.\n     * @param data contains the texture data\n     * @param texture defines the BabylonJS internal texture\n     * @param callback defines the method to call once ready to upload\n     * @param options\n     */\n    loadData(data, texture, callback, options) {\n        if (KhronosTextureContainer.IsValid(data)) {\n            // Need to invert vScale as invertY via UNPACK_FLIP_Y_WEBGL is not supported by compressed texture\n            texture._invertVScale = !texture.invertY;\n            const ktx = new KhronosTextureContainer(data, 1);\n            const mappedFormat = mapSRGBToLinear(ktx.glInternalFormat);\n            if (mappedFormat) {\n                texture.format = mappedFormat;\n                texture._useSRGBBuffer = texture.getEngine()._getUseSRGBBuffer(true, texture.generateMipMaps);\n                texture._gammaSpace = true;\n            }\n            else {\n                texture.format = ktx.glInternalFormat;\n            }\n            callback(ktx.pixelWidth, ktx.pixelHeight, texture.generateMipMaps, true, () => {\n                ktx.uploadLevels(texture, texture.generateMipMaps);\n            }, ktx.isInvalid);\n        }\n        else if (KhronosTextureContainer2.IsValid(data)) {\n            const ktx2 = new KhronosTextureContainer2(texture.getEngine());\n            ktx2.uploadAsync(data, texture, options).then(() => {\n                callback(texture.width, texture.height, texture.generateMipMaps, true, () => { }, false);\n            }, (error) => {\n                Logger.Warn(`Failed to load KTX2 texture data: ${error.message}`);\n                callback(0, 0, false, false, () => { }, true);\n            });\n        }\n        else {\n            Logger.Error(\"texture missing KTX identifier\");\n            callback(0, 0, false, false, () => { }, true);\n        }\n    }\n}\n// Register the loader.\nEngine._TextureLoaders.unshift(new _KTXTextureLoader());\n//# sourceMappingURL=ktxTextureLoader.js.map","import { RenderTargetTexture } from \"../Textures/renderTargetTexture.js\";\n\n/**\n * Renders to multiple views with a single draw call\n * @see https://www.khronos.org/registry/webgl/extensions/OVR_multiview2/\n */\nexport class MultiviewRenderTarget extends RenderTargetTexture {\n    set samples(value) {\n        // We override this setter because multisampling is handled by framebufferTextureMultisampleMultiviewOVR\n        this._samples = value;\n    }\n    get samples() {\n        return this._samples;\n    }\n    /**\n     * Creates a multiview render target\n     * @param scene scene used with the render target\n     * @param size the size of the render target (used for each view)\n     */\n    constructor(scene, size = 512) {\n        super(\"multiview rtt\", size, scene, false, true, 0, false, undefined, false, false, true, undefined, true);\n        this._renderTarget = this.getScene().getEngine().createMultiviewRenderTargetTexture(this.getRenderWidth(), this.getRenderHeight());\n        this._texture = this._renderTarget.texture;\n        this._texture.isMultiview = true;\n        this._texture.format = 5;\n        this.samples = this._getEngine().getCaps().maxSamples || this.samples;\n        this._texture.samples = this._samples;\n    }\n    /**\n     * @internal\n     */\n    _bindFrameBuffer() {\n        if (!this._renderTarget) {\n            return;\n        }\n        this.getScene().getEngine().bindMultiviewFramebuffer(this._renderTarget);\n    }\n    /**\n     * Gets the number of views the corresponding to the texture (eg. a MultiviewRenderTarget will have > 1)\n     * @returns the view count\n     */\n    getViewCount() {\n        return 2;\n    }\n}\n//# sourceMappingURL=MultiviewRenderTarget.js.map","import { __decorate } from \"../../../tslib.es6.js\";\nimport { serialize } from \"../../../Misc/decorators.js\";\nimport { Observable } from \"../../../Misc/observable.js\";\nimport { VertexBuffer } from \"../../../Buffers/buffer.js\";\nimport { SceneComponentConstants } from \"../../../sceneComponent.js\";\nimport { Material } from \"../../../Materials/material.js\";\nimport { Texture } from \"../../../Materials/Textures/texture.js\";\nimport { RenderTargetTexture } from \"../../../Materials/Textures/renderTargetTexture.js\";\nimport { ProceduralTextureSceneComponent } from \"./proceduralTextureSceneComponent.js\";\nimport \"../../../Engines/Extensions/engine.renderTarget.js\";\nimport \"../../../Engines/Extensions/engine.renderTargetCube.js\";\nimport \"../../../Shaders/procedural.vertex.js\";\nimport { RegisterClass } from \"../../../Misc/typeStore.js\";\nimport { EngineStore } from \"../../../Engines/engineStore.js\";\n\nimport { DrawWrapper } from \"../../drawWrapper.js\";\n/**\n * Procedural texturing is a way to programmatically create a texture. There are 2 types of procedural textures: code-only, and code that references some classic 2D images, sometimes calmpler' images.\n * This is the base class of any Procedural texture and contains most of the shareable code.\n * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/proceduralTextures\n */\nexport class ProceduralTexture extends Texture {\n    /**\n     * Instantiates a new procedural texture.\n     * Procedural texturing is a way to programmatically create a texture. There are 2 types of procedural textures: code-only, and code that references some classic 2D images, sometimes called 'refMaps' or 'sampler' images.\n     * This is the base class of any Procedural texture and contains most of the shareable code.\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/proceduralTextures\n     * @param name  Define the name of the texture\n     * @param size Define the size of the texture to create\n     * @param fragment Define the fragment shader to use to generate the texture or null if it is defined later\n     * @param scene Define the scene the texture belongs to\n     * @param fallbackTexture Define a fallback texture in case there were issues to create the custom texture\n     * @param generateMipMaps Define if the texture should creates mip maps or not\n     * @param isCube Define if the texture is a cube texture or not (this will render each faces of the cube)\n     * @param textureType The FBO internal texture type\n     */\n    constructor(name, size, fragment, scene, fallbackTexture = null, generateMipMaps = true, isCube = false, textureType = 0) {\n        super(null, scene, !generateMipMaps);\n        /**\n         * Define if the texture is enabled or not (disabled texture will not render)\n         */\n        this.isEnabled = true;\n        /**\n         * Define if the texture must be cleared before rendering (default is true)\n         */\n        this.autoClear = true;\n        /**\n         * Event raised when the texture is generated\n         */\n        this.onGeneratedObservable = new Observable();\n        /**\n         * Event raised before the texture is generated\n         */\n        this.onBeforeGenerationObservable = new Observable();\n        /**\n         * Gets or sets the node material used to create this texture (null if the texture was manually created)\n         */\n        this.nodeMaterialSource = null;\n        /** @internal */\n        this._textures = {};\n        this._currentRefreshId = -1;\n        this._frameId = -1;\n        this._refreshRate = 1;\n        this._vertexBuffers = {};\n        this._uniforms = new Array();\n        this._samplers = new Array();\n        this._floats = {};\n        this._ints = {};\n        this._floatsArrays = {};\n        this._colors3 = {};\n        this._colors4 = {};\n        this._vectors2 = {};\n        this._vectors3 = {};\n        this._matrices = {};\n        this._fallbackTextureUsed = false;\n        this._cachedDefines = null;\n        this._contentUpdateId = -1;\n        this._rtWrapper = null;\n        scene = this.getScene() || EngineStore.LastCreatedScene;\n        let component = scene._getComponent(SceneComponentConstants.NAME_PROCEDURALTEXTURE);\n        if (!component) {\n            component = new ProceduralTextureSceneComponent(scene);\n            scene._addComponent(component);\n        }\n        scene.proceduralTextures.push(this);\n        this._fullEngine = scene.getEngine();\n        this.name = name;\n        this.isRenderTarget = true;\n        this._size = size;\n        this._textureType = textureType;\n        this._generateMipMaps = generateMipMaps;\n        this._drawWrapper = new DrawWrapper(this._fullEngine);\n        this.setFragment(fragment);\n        this._fallbackTexture = fallbackTexture;\n        const rtWrapper = this._createRtWrapper(isCube, size, generateMipMaps, textureType);\n        this._texture = rtWrapper.texture;\n        // VBO\n        const vertices = [];\n        vertices.push(1, 1);\n        vertices.push(-1, 1);\n        vertices.push(-1, -1);\n        vertices.push(1, -1);\n        this._vertexBuffers[VertexBuffer.PositionKind] = new VertexBuffer(this._fullEngine, vertices, VertexBuffer.PositionKind, false, false, 2);\n        this._createIndexBuffer();\n    }\n    _createRtWrapper(isCube, size, generateMipMaps, textureType) {\n        if (isCube) {\n            this._rtWrapper = this._fullEngine.createRenderTargetCubeTexture(size, {\n                generateMipMaps: generateMipMaps,\n                generateDepthBuffer: false,\n                generateStencilBuffer: false,\n                type: textureType,\n            });\n            this.setFloat(\"face\", 0);\n        }\n        else {\n            this._rtWrapper = this._fullEngine.createRenderTargetTexture(size, {\n                generateMipMaps: generateMipMaps,\n                generateDepthBuffer: false,\n                generateStencilBuffer: false,\n                type: textureType,\n            });\n        }\n        return this._rtWrapper;\n    }\n    /**\n     * The effect that is created when initializing the post process.\n     * @returns The created effect corresponding the the postprocess.\n     */\n    getEffect() {\n        return this._drawWrapper.effect;\n    }\n    /**\n     * @internal*\n     */\n    _setEffect(effect) {\n        this._drawWrapper.effect = effect;\n    }\n    /**\n     * Gets texture content (Use this function wisely as reading from a texture can be slow)\n     * @returns an ArrayBufferView promise (Uint8Array or Float32Array)\n     */\n    getContent() {\n        if (this._contentData && this._frameId === this._contentUpdateId) {\n            return this._contentData;\n        }\n        if (this._contentData) {\n            this._contentData.then((buffer) => {\n                this._contentData = this.readPixels(0, 0, buffer);\n                this._contentUpdateId = this._frameId;\n            });\n        }\n        else {\n            this._contentData = this.readPixels(0, 0);\n            this._contentUpdateId = this._frameId;\n        }\n        return this._contentData;\n    }\n    _createIndexBuffer() {\n        const engine = this._fullEngine;\n        // Indices\n        const indices = [];\n        indices.push(0);\n        indices.push(1);\n        indices.push(2);\n        indices.push(0);\n        indices.push(2);\n        indices.push(3);\n        this._indexBuffer = engine.createIndexBuffer(indices);\n    }\n    /** @internal */\n    _rebuild() {\n        const vb = this._vertexBuffers[VertexBuffer.PositionKind];\n        if (vb) {\n            vb._rebuild();\n        }\n        this._createIndexBuffer();\n        if (this.refreshRate === RenderTargetTexture.REFRESHRATE_RENDER_ONCE) {\n            this.refreshRate = RenderTargetTexture.REFRESHRATE_RENDER_ONCE;\n        }\n    }\n    /**\n     * Resets the texture in order to recreate its associated resources.\n     * This can be called in case of context loss\n     */\n    reset() {\n        var _a;\n        (_a = this._drawWrapper.effect) === null || _a === void 0 ? void 0 : _a.dispose();\n    }\n    _getDefines() {\n        return \"\";\n    }\n    /**\n     * Is the texture ready to be used ? (rendered at least once)\n     * @returns true if ready, otherwise, false.\n     */\n    isReady() {\n        const engine = this._fullEngine;\n        let shaders;\n        if (this.nodeMaterialSource) {\n            return this._drawWrapper.effect.isReady();\n        }\n        if (!this._fragment) {\n            return false;\n        }\n        if (this._fallbackTextureUsed) {\n            return true;\n        }\n        if (!this._texture) {\n            return false;\n        }\n        const defines = this._getDefines();\n        if (this._drawWrapper.effect && defines === this._cachedDefines && this._drawWrapper.effect.isReady()) {\n            return true;\n        }\n        if (this._fragment.fragmentElement !== undefined) {\n            shaders = { vertex: \"procedural\", fragmentElement: this._fragment.fragmentElement };\n        }\n        else {\n            shaders = { vertex: \"procedural\", fragment: this._fragment };\n        }\n        if (this._cachedDefines !== defines) {\n            this._cachedDefines = defines;\n            this._drawWrapper.effect = engine.createEffect(shaders, [VertexBuffer.PositionKind], this._uniforms, this._samplers, defines, undefined, undefined, () => {\n                var _a;\n                (_a = this._rtWrapper) === null || _a === void 0 ? void 0 : _a.dispose();\n                this._rtWrapper = this._texture = null;\n                if (this._fallbackTexture) {\n                    this._texture = this._fallbackTexture._texture;\n                    if (this._texture) {\n                        this._texture.incrementReferences();\n                    }\n                }\n                this._fallbackTextureUsed = true;\n            });\n        }\n        return this._drawWrapper.effect.isReady();\n    }\n    /**\n     * Resets the refresh counter of the texture and start bak from scratch.\n     * Could be useful to regenerate the texture if it is setup to render only once.\n     */\n    resetRefreshCounter() {\n        this._currentRefreshId = -1;\n    }\n    /**\n     * Set the fragment shader to use in order to render the texture.\n     * @param fragment This can be set to a path (into the shader store) or to a json object containing a fragmentElement property.\n     */\n    setFragment(fragment) {\n        this._fragment = fragment;\n    }\n    /**\n     * Define the refresh rate of the texture or the rendering frequency.\n     * Use 0 to render just once, 1 to render on every frame, 2 to render every two frames and so on...\n     */\n    get refreshRate() {\n        return this._refreshRate;\n    }\n    set refreshRate(value) {\n        this._refreshRate = value;\n        this.resetRefreshCounter();\n    }\n    /** @internal */\n    _shouldRender() {\n        if (!this.isEnabled || !this.isReady() || !this._texture) {\n            if (this._texture) {\n                this._texture.isReady = false;\n            }\n            return false;\n        }\n        if (this._fallbackTextureUsed) {\n            return false;\n        }\n        if (this._currentRefreshId === -1) {\n            // At least render once\n            this._currentRefreshId = 1;\n            this._frameId++;\n            return true;\n        }\n        if (this.refreshRate === this._currentRefreshId) {\n            this._currentRefreshId = 1;\n            this._frameId++;\n            return true;\n        }\n        this._currentRefreshId++;\n        return false;\n    }\n    /**\n     * Get the size the texture is rendering at.\n     * @returns the size (on cube texture it is always squared)\n     */\n    getRenderSize() {\n        return this._size;\n    }\n    /**\n     * Resize the texture to new value.\n     * @param size Define the new size the texture should have\n     * @param generateMipMaps Define whether the new texture should create mip maps\n     */\n    resize(size, generateMipMaps) {\n        if (this._fallbackTextureUsed || !this._rtWrapper || !this._texture) {\n            return;\n        }\n        const isCube = this._texture.isCube;\n        this._rtWrapper.dispose();\n        const rtWrapper = this._createRtWrapper(isCube, size, generateMipMaps, this._textureType);\n        this._texture = rtWrapper.texture;\n        // Update properties\n        this._size = size;\n        this._generateMipMaps = generateMipMaps;\n    }\n    _checkUniform(uniformName) {\n        if (this._uniforms.indexOf(uniformName) === -1) {\n            this._uniforms.push(uniformName);\n        }\n    }\n    /**\n     * Set a texture in the shader program used to render.\n     * @param name Define the name of the uniform samplers as defined in the shader\n     * @param texture Define the texture to bind to this sampler\n     * @returns the texture itself allowing \"fluent\" like uniform updates\n     */\n    setTexture(name, texture) {\n        if (this._samplers.indexOf(name) === -1) {\n            this._samplers.push(name);\n        }\n        this._textures[name] = texture;\n        return this;\n    }\n    /**\n     * Set a float in the shader.\n     * @param name Define the name of the uniform as defined in the shader\n     * @param value Define the value to give to the uniform\n     * @returns the texture itself allowing \"fluent\" like uniform updates\n     */\n    setFloat(name, value) {\n        this._checkUniform(name);\n        this._floats[name] = value;\n        return this;\n    }\n    /**\n     * Set a int in the shader.\n     * @param name Define the name of the uniform as defined in the shader\n     * @param value Define the value to give to the uniform\n     * @returns the texture itself allowing \"fluent\" like uniform updates\n     */\n    setInt(name, value) {\n        this._checkUniform(name);\n        this._ints[name] = value;\n        return this;\n    }\n    /**\n     * Set an array of floats in the shader.\n     * @param name Define the name of the uniform as defined in the shader\n     * @param value Define the value to give to the uniform\n     * @returns the texture itself allowing \"fluent\" like uniform updates\n     */\n    setFloats(name, value) {\n        this._checkUniform(name);\n        this._floatsArrays[name] = value;\n        return this;\n    }\n    /**\n     * Set a vec3 in the shader from a Color3.\n     * @param name Define the name of the uniform as defined in the shader\n     * @param value Define the value to give to the uniform\n     * @returns the texture itself allowing \"fluent\" like uniform updates\n     */\n    setColor3(name, value) {\n        this._checkUniform(name);\n        this._colors3[name] = value;\n        return this;\n    }\n    /**\n     * Set a vec4 in the shader from a Color4.\n     * @param name Define the name of the uniform as defined in the shader\n     * @param value Define the value to give to the uniform\n     * @returns the texture itself allowing \"fluent\" like uniform updates\n     */\n    setColor4(name, value) {\n        this._checkUniform(name);\n        this._colors4[name] = value;\n        return this;\n    }\n    /**\n     * Set a vec2 in the shader from a Vector2.\n     * @param name Define the name of the uniform as defined in the shader\n     * @param value Define the value to give to the uniform\n     * @returns the texture itself allowing \"fluent\" like uniform updates\n     */\n    setVector2(name, value) {\n        this._checkUniform(name);\n        this._vectors2[name] = value;\n        return this;\n    }\n    /**\n     * Set a vec3 in the shader from a Vector3.\n     * @param name Define the name of the uniform as defined in the shader\n     * @param value Define the value to give to the uniform\n     * @returns the texture itself allowing \"fluent\" like uniform updates\n     */\n    setVector3(name, value) {\n        this._checkUniform(name);\n        this._vectors3[name] = value;\n        return this;\n    }\n    /**\n     * Set a mat4 in the shader from a MAtrix.\n     * @param name Define the name of the uniform as defined in the shader\n     * @param value Define the value to give to the uniform\n     * @returns the texture itself allowing \"fluent\" like uniform updates\n     */\n    setMatrix(name, value) {\n        this._checkUniform(name);\n        this._matrices[name] = value;\n        return this;\n    }\n    /**\n     * Render the texture to its associated render target.\n     * @param useCameraPostProcess Define if camera post process should be applied to the texture\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    render(useCameraPostProcess) {\n        var _a, _b;\n        const scene = this.getScene();\n        if (!scene) {\n            return;\n        }\n        const engine = this._fullEngine;\n        // Render\n        engine.enableEffect(this._drawWrapper);\n        this.onBeforeGenerationObservable.notifyObservers(this);\n        engine.setState(false);\n        if (!this.nodeMaterialSource) {\n            // Texture\n            for (const name in this._textures) {\n                this._drawWrapper.effect.setTexture(name, this._textures[name]);\n            }\n            // Float\n            for (const name in this._ints) {\n                this._drawWrapper.effect.setInt(name, this._ints[name]);\n            }\n            // Float\n            for (const name in this._floats) {\n                this._drawWrapper.effect.setFloat(name, this._floats[name]);\n            }\n            // Floats\n            for (const name in this._floatsArrays) {\n                this._drawWrapper.effect.setArray(name, this._floatsArrays[name]);\n            }\n            // Color3\n            for (const name in this._colors3) {\n                this._drawWrapper.effect.setColor3(name, this._colors3[name]);\n            }\n            // Color4\n            for (const name in this._colors4) {\n                const color = this._colors4[name];\n                this._drawWrapper.effect.setFloat4(name, color.r, color.g, color.b, color.a);\n            }\n            // Vector2\n            for (const name in this._vectors2) {\n                this._drawWrapper.effect.setVector2(name, this._vectors2[name]);\n            }\n            // Vector3\n            for (const name in this._vectors3) {\n                this._drawWrapper.effect.setVector3(name, this._vectors3[name]);\n            }\n            // Matrix\n            for (const name in this._matrices) {\n                this._drawWrapper.effect.setMatrix(name, this._matrices[name]);\n            }\n        }\n        if (!this._texture || !this._rtWrapper) {\n            return;\n        }\n        (_a = engine._debugPushGroup) === null || _a === void 0 ? void 0 : _a.call(engine, `procedural texture generation for ${this.name}`, 1);\n        const viewPort = engine.currentViewport;\n        if (this.isCube) {\n            for (let face = 0; face < 6; face++) {\n                engine.bindFramebuffer(this._rtWrapper, face, undefined, undefined, true);\n                // VBOs\n                engine.bindBuffers(this._vertexBuffers, this._indexBuffer, this._drawWrapper.effect);\n                this._drawWrapper.effect.setFloat(\"face\", face);\n                // Clear\n                if (this.autoClear) {\n                    engine.clear(scene.clearColor, true, false, false);\n                }\n                // Draw order\n                engine.drawElementsType(Material.TriangleFillMode, 0, 6);\n            }\n        }\n        else {\n            engine.bindFramebuffer(this._rtWrapper, 0, undefined, undefined, true);\n            // VBOs\n            engine.bindBuffers(this._vertexBuffers, this._indexBuffer, this._drawWrapper.effect);\n            // Clear\n            if (this.autoClear) {\n                engine.clear(scene.clearColor, true, false, false);\n            }\n            // Draw order\n            engine.drawElementsType(Material.TriangleFillMode, 0, 6);\n        }\n        // Unbind and restore viewport\n        engine.unBindFramebuffer(this._rtWrapper, this.isCube);\n        if (viewPort) {\n            engine.setViewport(viewPort);\n        }\n        // Mipmaps\n        if (this.isCube) {\n            engine.generateMipMapsForCubemap(this._texture);\n        }\n        (_b = engine._debugPopGroup) === null || _b === void 0 ? void 0 : _b.call(engine, 1);\n        if (this.onGenerated) {\n            this.onGenerated();\n        }\n        this.onGeneratedObservable.notifyObservers(this);\n    }\n    /**\n     * Clone the texture.\n     * @returns the cloned texture\n     */\n    clone() {\n        const textureSize = this.getSize();\n        const newTexture = new ProceduralTexture(this.name, textureSize.width, this._fragment, this.getScene(), this._fallbackTexture, this._generateMipMaps);\n        // Base texture\n        newTexture.hasAlpha = this.hasAlpha;\n        newTexture.level = this.level;\n        // RenderTarget Texture\n        newTexture.coordinatesMode = this.coordinatesMode;\n        return newTexture;\n    }\n    /**\n     * Dispose the texture and release its associated resources.\n     */\n    dispose() {\n        const scene = this.getScene();\n        if (!scene) {\n            return;\n        }\n        const index = scene.proceduralTextures.indexOf(this);\n        if (index >= 0) {\n            scene.proceduralTextures.splice(index, 1);\n        }\n        const vertexBuffer = this._vertexBuffers[VertexBuffer.PositionKind];\n        if (vertexBuffer) {\n            vertexBuffer.dispose();\n            this._vertexBuffers[VertexBuffer.PositionKind] = null;\n        }\n        if (this._indexBuffer && this._fullEngine._releaseBuffer(this._indexBuffer)) {\n            this._indexBuffer = null;\n        }\n        this.onGeneratedObservable.clear();\n        this.onBeforeGenerationObservable.clear();\n        super.dispose();\n    }\n}\n__decorate([\n    serialize()\n], ProceduralTexture.prototype, \"isEnabled\", void 0);\n__decorate([\n    serialize()\n], ProceduralTexture.prototype, \"autoClear\", void 0);\n__decorate([\n    serialize()\n], ProceduralTexture.prototype, \"_generateMipMaps\", void 0);\n__decorate([\n    serialize()\n], ProceduralTexture.prototype, \"_size\", void 0);\n__decorate([\n    serialize()\n], ProceduralTexture.prototype, \"refreshRate\", null);\nRegisterClass(\"BABYLON.ProceduralTexture\", ProceduralTexture);\n//# sourceMappingURL=proceduralTexture.js.map","import { Tools } from \"../../../Misc/tools.js\";\nimport { SceneComponentConstants } from \"../../../sceneComponent.js\";\n/**\n * Defines the Procedural Texture scene component responsible to manage any Procedural Texture\n * in a given scene.\n */\nexport class ProceduralTextureSceneComponent {\n    /**\n     * Creates a new instance of the component for the given scene\n     * @param scene Defines the scene to register the component in\n     */\n    constructor(scene) {\n        /**\n         * The component name helpful to identify the component in the list of scene components.\n         */\n        this.name = SceneComponentConstants.NAME_PROCEDURALTEXTURE;\n        this.scene = scene;\n        this.scene.proceduralTextures = new Array();\n    }\n    /**\n     * Registers the component in a given scene\n     */\n    register() {\n        this.scene._beforeClearStage.registerStep(SceneComponentConstants.STEP_BEFORECLEAR_PROCEDURALTEXTURE, this, this._beforeClear);\n    }\n    /**\n     * Rebuilds the elements related to this component in case of\n     * context lost for instance.\n     */\n    rebuild() {\n        // Nothing to do here.\n    }\n    /**\n     * Disposes the component and the associated resources.\n     */\n    dispose() {\n        // Nothing to do here.\n    }\n    _beforeClear() {\n        if (this.scene.proceduralTexturesEnabled) {\n            Tools.StartPerformanceCounter(\"Procedural textures\", this.scene.proceduralTextures.length > 0);\n            for (let proceduralIndex = 0; proceduralIndex < this.scene.proceduralTextures.length; proceduralIndex++) {\n                const proceduralTexture = this.scene.proceduralTextures[proceduralIndex];\n                if (proceduralTexture._shouldRender()) {\n                    proceduralTexture.render();\n                }\n            }\n            Tools.EndPerformanceCounter(\"Procedural textures\", this.scene.proceduralTextures.length > 0);\n        }\n    }\n}\n//# sourceMappingURL=proceduralTextureSceneComponent.js.map","import { __decorate } from \"../../tslib.es6.js\";\nimport { serialize, SerializationHelper, serializeAsTexture } from \"../../Misc/decorators.js\";\nimport { Observable } from \"../../Misc/observable.js\";\nimport { Matrix } from \"../../Maths/math.vector.js\";\nimport { EngineStore } from \"../../Engines/engineStore.js\";\n\nimport { RandomGUID } from \"../../Misc/guid.js\";\nimport \"../../Misc/fileTools.js\";\nimport { ThinTexture } from \"./thinTexture.js\";\n/**\n * Base class of all the textures in babylon.\n * It groups all the common properties the materials, post process, lights... might need\n * in order to make a correct use of the texture.\n */\nexport class BaseTexture extends ThinTexture {\n    /**\n     * Define if the texture is having a usable alpha value (can be use for transparency or glossiness for instance).\n     */\n    set hasAlpha(value) {\n        if (this._hasAlpha === value) {\n            return;\n        }\n        this._hasAlpha = value;\n        if (this._scene) {\n            this._scene.markAllMaterialsAsDirty(1, (mat) => {\n                return mat.hasTexture(this);\n            });\n        }\n    }\n    get hasAlpha() {\n        return this._hasAlpha;\n    }\n    /**\n     * Defines if the alpha value should be determined via the rgb values.\n     * If true the luminance of the pixel might be used to find the corresponding alpha value.\n     */\n    set getAlphaFromRGB(value) {\n        if (this._getAlphaFromRGB === value) {\n            return;\n        }\n        this._getAlphaFromRGB = value;\n        if (this._scene) {\n            this._scene.markAllMaterialsAsDirty(1, (mat) => {\n                return mat.hasTexture(this);\n            });\n        }\n    }\n    get getAlphaFromRGB() {\n        return this._getAlphaFromRGB;\n    }\n    /**\n     * Define the UV channel to use starting from 0 and defaulting to 0.\n     * This is part of the texture as textures usually maps to one uv set.\n     */\n    set coordinatesIndex(value) {\n        if (this._coordinatesIndex === value) {\n            return;\n        }\n        this._coordinatesIndex = value;\n        if (this._scene) {\n            this._scene.markAllMaterialsAsDirty(1, (mat) => {\n                return mat.hasTexture(this);\n            });\n        }\n    }\n    get coordinatesIndex() {\n        return this._coordinatesIndex;\n    }\n    /**\n     * How a texture is mapped.\n     *\n     * | Value | Type                                | Description |\n     * | ----- | ----------------------------------- | ----------- |\n     * | 0     | EXPLICIT_MODE                       |             |\n     * | 1     | SPHERICAL_MODE                      |             |\n     * | 2     | PLANAR_MODE                         |             |\n     * | 3     | CUBIC_MODE                          |             |\n     * | 4     | PROJECTION_MODE                     |             |\n     * | 5     | SKYBOX_MODE                         |             |\n     * | 6     | INVCUBIC_MODE                       |             |\n     * | 7     | EQUIRECTANGULAR_MODE                |             |\n     * | 8     | FIXED_EQUIRECTANGULAR_MODE          |             |\n     * | 9     | FIXED_EQUIRECTANGULAR_MIRRORED_MODE |             |\n     */\n    set coordinatesMode(value) {\n        if (this._coordinatesMode === value) {\n            return;\n        }\n        this._coordinatesMode = value;\n        if (this._scene) {\n            this._scene.markAllMaterialsAsDirty(1, (mat) => {\n                return mat.hasTexture(this);\n            });\n        }\n    }\n    get coordinatesMode() {\n        return this._coordinatesMode;\n    }\n    /**\n     * | Value | Type               | Description |\n     * | ----- | ------------------ | ----------- |\n     * | 0     | CLAMP_ADDRESSMODE  |             |\n     * | 1     | WRAP_ADDRESSMODE   |             |\n     * | 2     | MIRROR_ADDRESSMODE |             |\n     */\n    get wrapU() {\n        return this._wrapU;\n    }\n    set wrapU(value) {\n        this._wrapU = value;\n    }\n    /**\n     * | Value | Type               | Description |\n     * | ----- | ------------------ | ----------- |\n     * | 0     | CLAMP_ADDRESSMODE  |             |\n     * | 1     | WRAP_ADDRESSMODE   |             |\n     * | 2     | MIRROR_ADDRESSMODE |             |\n     */\n    get wrapV() {\n        return this._wrapV;\n    }\n    set wrapV(value) {\n        this._wrapV = value;\n    }\n    /**\n     * Define if the texture is a cube texture or if false a 2d texture.\n     */\n    get isCube() {\n        if (!this._texture) {\n            return this._isCube;\n        }\n        return this._texture.isCube;\n    }\n    set isCube(value) {\n        if (!this._texture) {\n            this._isCube = value;\n        }\n        else {\n            this._texture.isCube = value;\n        }\n    }\n    /**\n     * Define if the texture is a 3d texture (webgl 2) or if false a 2d texture.\n     */\n    get is3D() {\n        if (!this._texture) {\n            return false;\n        }\n        return this._texture.is3D;\n    }\n    set is3D(value) {\n        if (!this._texture) {\n            return;\n        }\n        this._texture.is3D = value;\n    }\n    /**\n     * Define if the texture is a 2d array texture (webgl 2) or if false a 2d texture.\n     */\n    get is2DArray() {\n        if (!this._texture) {\n            return false;\n        }\n        return this._texture.is2DArray;\n    }\n    set is2DArray(value) {\n        if (!this._texture) {\n            return;\n        }\n        this._texture.is2DArray = value;\n    }\n    /**\n     * Define if the texture contains data in gamma space (most of the png/jpg aside bump).\n     * HDR texture are usually stored in linear space.\n     * This only impacts the PBR and Background materials\n     */\n    get gammaSpace() {\n        if (!this._texture) {\n            return this._gammaSpace;\n        }\n        else {\n            if (this._texture._gammaSpace === null) {\n                this._texture._gammaSpace = this._gammaSpace;\n            }\n        }\n        return this._texture._gammaSpace && !this._texture._useSRGBBuffer;\n    }\n    set gammaSpace(gamma) {\n        if (!this._texture) {\n            if (this._gammaSpace === gamma) {\n                return;\n            }\n            this._gammaSpace = gamma;\n        }\n        else {\n            if (this._texture._gammaSpace === gamma) {\n                return;\n            }\n            this._texture._gammaSpace = gamma;\n        }\n        this._markAllSubMeshesAsTexturesDirty();\n    }\n    /**\n     * Gets or sets whether or not the texture contains RGBD data.\n     */\n    get isRGBD() {\n        return this._texture != null && this._texture._isRGBD;\n    }\n    set isRGBD(value) {\n        if (this._texture) {\n            this._texture._isRGBD = value;\n        }\n    }\n    /**\n     * Are mip maps generated for this texture or not.\n     */\n    get noMipmap() {\n        return false;\n    }\n    /**\n     * With prefiltered texture, defined the offset used during the prefiltering steps.\n     */\n    get lodGenerationOffset() {\n        if (this._texture) {\n            return this._texture._lodGenerationOffset;\n        }\n        return 0.0;\n    }\n    set lodGenerationOffset(value) {\n        if (this._texture) {\n            this._texture._lodGenerationOffset = value;\n        }\n    }\n    /**\n     * With prefiltered texture, defined the scale used during the prefiltering steps.\n     */\n    get lodGenerationScale() {\n        if (this._texture) {\n            return this._texture._lodGenerationScale;\n        }\n        return 0.0;\n    }\n    set lodGenerationScale(value) {\n        if (this._texture) {\n            this._texture._lodGenerationScale = value;\n        }\n    }\n    /**\n     * With prefiltered texture, defined if the specular generation is based on a linear ramp.\n     * By default we are using a log2 of the linear roughness helping to keep a better resolution for\n     * average roughness values.\n     */\n    get linearSpecularLOD() {\n        if (this._texture) {\n            return this._texture._linearSpecularLOD;\n        }\n        return false;\n    }\n    set linearSpecularLOD(value) {\n        if (this._texture) {\n            this._texture._linearSpecularLOD = value;\n        }\n    }\n    /**\n     * In case a better definition than spherical harmonics is required for the diffuse part of the environment.\n     * You can set the irradiance texture to rely on a texture instead of the spherical approach.\n     * This texture need to have the same characteristics than its parent (Cube vs 2d, coordinates mode, Gamma/Linear, RGBD).\n     */\n    get irradianceTexture() {\n        if (this._texture) {\n            return this._texture._irradianceTexture;\n        }\n        return null;\n    }\n    set irradianceTexture(value) {\n        if (this._texture) {\n            this._texture._irradianceTexture = value;\n        }\n    }\n    /**\n     * Define the unique id of the texture in the scene.\n     */\n    get uid() {\n        if (!this._uid) {\n            this._uid = RandomGUID();\n        }\n        return this._uid;\n    }\n    /**\n     * Return a string representation of the texture.\n     * @returns the texture as a string\n     */\n    toString() {\n        return this.name;\n    }\n    /**\n     * Get the class name of the texture.\n     * @returns \"BaseTexture\"\n     */\n    getClassName() {\n        return \"BaseTexture\";\n    }\n    /**\n     * Callback triggered when the texture has been disposed.\n     * Kept for back compatibility, you can use the onDisposeObservable instead.\n     */\n    set onDispose(callback) {\n        if (this._onDisposeObserver) {\n            this.onDisposeObservable.remove(this._onDisposeObserver);\n        }\n        this._onDisposeObserver = this.onDisposeObservable.add(callback);\n    }\n    /**\n     * Define if the texture is preventing a material to render or not.\n     * If not and the texture is not ready, the engine will use a default black texture instead.\n     */\n    get isBlocking() {\n        return true;\n    }\n    /**\n     * Was there any loading error?\n     */\n    get loadingError() {\n        return this._loadingError;\n    }\n    /**\n     * If a loading error occurred this object will be populated with information about the error.\n     */\n    get errorObject() {\n        return this._errorObject;\n    }\n    /**\n     * Instantiates a new BaseTexture.\n     * Base class of all the textures in babylon.\n     * It groups all the common properties the materials, post process, lights... might need\n     * in order to make a correct use of the texture.\n     * @param sceneOrEngine Define the scene or engine the texture belongs to\n     * @param internalTexture Define the internal texture associated with the texture\n     */\n    constructor(sceneOrEngine, internalTexture = null) {\n        super(null);\n        /**\n         * Gets or sets an object used to store user defined information.\n         */\n        this.metadata = null;\n        /**\n         * For internal use only. Please do not use.\n         */\n        this.reservedDataStore = null;\n        this._hasAlpha = false;\n        this._getAlphaFromRGB = false;\n        /**\n         * Intensity or strength of the texture.\n         * It is commonly used by materials to fine tune the intensity of the texture\n         */\n        this.level = 1;\n        this._coordinatesIndex = 0;\n        /**\n         * Gets or sets a boolean indicating that the texture should try to reduce shader code if there is no UV manipulation.\n         * (ie. when texture.getTextureMatrix().isIdentityAs3x2() returns true)\n         */\n        this.optimizeUVAllocation = true;\n        this._coordinatesMode = 0;\n        /**\n         * | Value | Type               | Description |\n         * | ----- | ------------------ | ----------- |\n         * | 0     | CLAMP_ADDRESSMODE  |             |\n         * | 1     | WRAP_ADDRESSMODE   |             |\n         * | 2     | MIRROR_ADDRESSMODE |             |\n         */\n        this.wrapR = 1;\n        /**\n         * With compliant hardware and browser (supporting anisotropic filtering)\n         * this defines the level of anisotropic filtering in the texture.\n         * The higher the better but the slower. This defaults to 4 as it seems to be the best tradeoff.\n         */\n        this.anisotropicFilteringLevel = BaseTexture.DEFAULT_ANISOTROPIC_FILTERING_LEVEL;\n        /** @internal */\n        this._isCube = false;\n        this._gammaSpace = true;\n        /**\n         * Is Z inverted in the texture (useful in a cube texture).\n         */\n        this.invertZ = false;\n        /**\n         * @internal\n         */\n        this.lodLevelInAlpha = false;\n        /**\n         * Define if the texture is a render target.\n         */\n        this.isRenderTarget = false;\n        /** @internal */\n        this._prefiltered = false;\n        /** @internal */\n        this._forceSerialize = false;\n        /**\n         * Define the list of animation attached to the texture.\n         */\n        this.animations = new Array();\n        /**\n         * An event triggered when the texture is disposed.\n         */\n        this.onDisposeObservable = new Observable();\n        this._onDisposeObserver = null;\n        this._scene = null;\n        /** @internal */\n        this._uid = null;\n        /** @internal */\n        this._parentContainer = null;\n        this._loadingError = false;\n        if (sceneOrEngine) {\n            if (BaseTexture._IsScene(sceneOrEngine)) {\n                this._scene = sceneOrEngine;\n            }\n            else {\n                this._engine = sceneOrEngine;\n            }\n        }\n        else {\n            this._scene = EngineStore.LastCreatedScene;\n        }\n        if (this._scene) {\n            this.uniqueId = this._scene.getUniqueId();\n            this._scene.addTexture(this);\n            this._engine = this._scene.getEngine();\n        }\n        this._texture = internalTexture;\n        this._uid = null;\n    }\n    /**\n     * Get the scene the texture belongs to.\n     * @returns the scene or null if undefined\n     */\n    getScene() {\n        return this._scene;\n    }\n    /** @internal */\n    _getEngine() {\n        return this._engine;\n    }\n    /**\n     * Checks if the texture has the same transform matrix than another texture\n     * @param texture texture to check against\n     * @returns true if the transforms are the same, else false\n     */\n    checkTransformsAreIdentical(texture) {\n        return texture !== null;\n    }\n    /**\n     * Get the texture transform matrix used to offset tile the texture for instance.\n     * @returns the transformation matrix\n     */\n    getTextureMatrix() {\n        return Matrix.IdentityReadOnly;\n    }\n    /**\n     * Get the texture reflection matrix used to rotate/transform the reflection.\n     * @returns the reflection matrix\n     */\n    getReflectionTextureMatrix() {\n        return Matrix.IdentityReadOnly;\n    }\n    /**\n     * Get if the texture is ready to be consumed (either it is ready or it is not blocking)\n     * @returns true if ready, not blocking or if there was an error loading the texture\n     */\n    isReadyOrNotBlocking() {\n        return !this.isBlocking || this.isReady() || this.loadingError;\n    }\n    /**\n     * Scales the texture if is `canRescale()`\n     * @param ratio the resize factor we want to use to rescale\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    scale(ratio) { }\n    /**\n     * Get if the texture can rescale.\n     */\n    get canRescale() {\n        return false;\n    }\n    /**\n     * @internal\n     */\n    _getFromCache(url, noMipmap, sampling, invertY, useSRGBBuffer, isCube) {\n        const engine = this._getEngine();\n        if (!engine) {\n            return null;\n        }\n        const correctedUseSRGBBuffer = engine._getUseSRGBBuffer(!!useSRGBBuffer, noMipmap);\n        const texturesCache = engine.getLoadedTexturesCache();\n        for (let index = 0; index < texturesCache.length; index++) {\n            const texturesCacheEntry = texturesCache[index];\n            if (useSRGBBuffer === undefined || correctedUseSRGBBuffer === texturesCacheEntry._useSRGBBuffer) {\n                if (invertY === undefined || invertY === texturesCacheEntry.invertY) {\n                    if (texturesCacheEntry.url === url && texturesCacheEntry.generateMipMaps === !noMipmap) {\n                        if (!sampling || sampling === texturesCacheEntry.samplingMode) {\n                            if (isCube === undefined || isCube === texturesCacheEntry.isCube) {\n                                texturesCacheEntry.incrementReferences();\n                                return texturesCacheEntry;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return null;\n    }\n    /** @internal */\n    _rebuild() { }\n    /**\n     * Clones the texture.\n     * @returns the cloned texture\n     */\n    clone() {\n        return null;\n    }\n    /**\n     * Get the texture underlying type (INT, FLOAT...)\n     */\n    get textureType() {\n        if (!this._texture) {\n            return 0;\n        }\n        return this._texture.type !== undefined ? this._texture.type : 0;\n    }\n    /**\n     * Get the texture underlying format (RGB, RGBA...)\n     */\n    get textureFormat() {\n        if (!this._texture) {\n            return 5;\n        }\n        return this._texture.format !== undefined ? this._texture.format : 5;\n    }\n    /**\n     * Indicates that textures need to be re-calculated for all materials\n     */\n    _markAllSubMeshesAsTexturesDirty() {\n        const scene = this.getScene();\n        if (!scene) {\n            return;\n        }\n        scene.markAllMaterialsAsDirty(1);\n    }\n    /**\n     * Reads the pixels stored in the webgl texture and returns them as an ArrayBuffer.\n     * This will returns an RGBA array buffer containing either in values (0-255) or\n     * float values (0-1) depending of the underlying buffer type.\n     * @param faceIndex defines the face of the texture to read (in case of cube texture)\n     * @param level defines the LOD level of the texture to read (in case of Mip Maps)\n     * @param buffer defines a user defined buffer to fill with data (can be null)\n     * @param flushRenderer true to flush the renderer from the pending commands before reading the pixels\n     * @param noDataConversion false to convert the data to Uint8Array (if texture type is UNSIGNED_BYTE) or to Float32Array (if texture type is anything but UNSIGNED_BYTE). If true, the type of the generated buffer (if buffer==null) will depend on the type of the texture\n     * @param x defines the region x coordinates to start reading from (default to 0)\n     * @param y defines the region y coordinates to start reading from (default to 0)\n     * @param width defines the region width to read from (default to the texture size at level)\n     * @param height defines the region width to read from (default to the texture size at level)\n     * @returns The Array buffer promise containing the pixels data.\n     */\n    readPixels(faceIndex = 0, level = 0, buffer = null, flushRenderer = true, noDataConversion = false, x = 0, y = 0, width = Number.MAX_VALUE, height = Number.MAX_VALUE) {\n        if (!this._texture) {\n            return null;\n        }\n        const engine = this._getEngine();\n        if (!engine) {\n            return null;\n        }\n        const size = this.getSize();\n        let maxWidth = size.width;\n        let maxHeight = size.height;\n        if (level !== 0) {\n            maxWidth = maxWidth / Math.pow(2, level);\n            maxHeight = maxHeight / Math.pow(2, level);\n            maxWidth = Math.round(maxWidth);\n            maxHeight = Math.round(maxHeight);\n        }\n        width = Math.min(maxWidth, width);\n        height = Math.min(maxHeight, height);\n        try {\n            if (this._texture.isCube) {\n                return engine._readTexturePixels(this._texture, width, height, faceIndex, level, buffer, flushRenderer, noDataConversion, x, y);\n            }\n            return engine._readTexturePixels(this._texture, width, height, -1, level, buffer, flushRenderer, noDataConversion, x, y);\n        }\n        catch (e) {\n            return null;\n        }\n    }\n    /**\n     * @internal\n     */\n    _readPixelsSync(faceIndex = 0, level = 0, buffer = null, flushRenderer = true, noDataConversion = false) {\n        if (!this._texture) {\n            return null;\n        }\n        const size = this.getSize();\n        let width = size.width;\n        let height = size.height;\n        const engine = this._getEngine();\n        if (!engine) {\n            return null;\n        }\n        if (level != 0) {\n            width = width / Math.pow(2, level);\n            height = height / Math.pow(2, level);\n            width = Math.round(width);\n            height = Math.round(height);\n        }\n        try {\n            if (this._texture.isCube) {\n                return engine._readTexturePixelsSync(this._texture, width, height, faceIndex, level, buffer, flushRenderer, noDataConversion);\n            }\n            return engine._readTexturePixelsSync(this._texture, width, height, -1, level, buffer, flushRenderer, noDataConversion);\n        }\n        catch (e) {\n            return null;\n        }\n    }\n    /** @internal */\n    get _lodTextureHigh() {\n        if (this._texture) {\n            return this._texture._lodTextureHigh;\n        }\n        return null;\n    }\n    /** @internal */\n    get _lodTextureMid() {\n        if (this._texture) {\n            return this._texture._lodTextureMid;\n        }\n        return null;\n    }\n    /** @internal */\n    get _lodTextureLow() {\n        if (this._texture) {\n            return this._texture._lodTextureLow;\n        }\n        return null;\n    }\n    /**\n     * Dispose the texture and release its associated resources.\n     */\n    dispose() {\n        if (this._scene) {\n            // Animations\n            if (this._scene.stopAnimation) {\n                this._scene.stopAnimation(this);\n            }\n            // Remove from scene\n            this._scene.removePendingData(this);\n            const index = this._scene.textures.indexOf(this);\n            if (index >= 0) {\n                this._scene.textures.splice(index, 1);\n            }\n            this._scene.onTextureRemovedObservable.notifyObservers(this);\n            this._scene = null;\n            if (this._parentContainer) {\n                const index = this._parentContainer.textures.indexOf(this);\n                if (index > -1) {\n                    this._parentContainer.textures.splice(index, 1);\n                }\n                this._parentContainer = null;\n            }\n        }\n        // Callback\n        this.onDisposeObservable.notifyObservers(this);\n        this.onDisposeObservable.clear();\n        this.metadata = null;\n        super.dispose();\n    }\n    /**\n     * Serialize the texture into a JSON representation that can be parsed later on.\n     * @param allowEmptyName True to force serialization even if name is empty. Default: false\n     * @returns the JSON representation of the texture\n     */\n    serialize(allowEmptyName = false) {\n        if (!this.name && !allowEmptyName) {\n            return null;\n        }\n        const serializationObject = SerializationHelper.Serialize(this);\n        // Animations\n        SerializationHelper.AppendSerializedAnimations(this, serializationObject);\n        return serializationObject;\n    }\n    /**\n     * Helper function to be called back once a list of texture contains only ready textures.\n     * @param textures Define the list of textures to wait for\n     * @param callback Define the callback triggered once the entire list will be ready\n     */\n    static WhenAllReady(textures, callback) {\n        let numRemaining = textures.length;\n        if (numRemaining === 0) {\n            callback();\n            return;\n        }\n        for (let i = 0; i < textures.length; i++) {\n            const texture = textures[i];\n            if (texture.isReady()) {\n                if (--numRemaining === 0) {\n                    callback();\n                }\n            }\n            else {\n                const onLoadObservable = texture.onLoadObservable;\n                if (onLoadObservable) {\n                    onLoadObservable.addOnce(() => {\n                        if (--numRemaining === 0) {\n                            callback();\n                        }\n                    });\n                }\n                else {\n                    if (--numRemaining === 0) {\n                        callback();\n                    }\n                }\n            }\n        }\n    }\n    static _IsScene(sceneOrEngine) {\n        return sceneOrEngine.getClassName() === \"Scene\";\n    }\n}\n/**\n * Default anisotropic filtering level for the application.\n * It is set to 4 as a good tradeoff between perf and quality.\n */\nBaseTexture.DEFAULT_ANISOTROPIC_FILTERING_LEVEL = 4;\n__decorate([\n    serialize()\n], BaseTexture.prototype, \"uniqueId\", void 0);\n__decorate([\n    serialize()\n], BaseTexture.prototype, \"name\", void 0);\n__decorate([\n    serialize()\n], BaseTexture.prototype, \"metadata\", void 0);\n__decorate([\n    serialize(\"hasAlpha\")\n], BaseTexture.prototype, \"_hasAlpha\", void 0);\n__decorate([\n    serialize(\"getAlphaFromRGB\")\n], BaseTexture.prototype, \"_getAlphaFromRGB\", void 0);\n__decorate([\n    serialize()\n], BaseTexture.prototype, \"level\", void 0);\n__decorate([\n    serialize(\"coordinatesIndex\")\n], BaseTexture.prototype, \"_coordinatesIndex\", void 0);\n__decorate([\n    serialize()\n], BaseTexture.prototype, \"optimizeUVAllocation\", void 0);\n__decorate([\n    serialize(\"coordinatesMode\")\n], BaseTexture.prototype, \"_coordinatesMode\", void 0);\n__decorate([\n    serialize()\n], BaseTexture.prototype, \"wrapU\", null);\n__decorate([\n    serialize()\n], BaseTexture.prototype, \"wrapV\", null);\n__decorate([\n    serialize()\n], BaseTexture.prototype, \"wrapR\", void 0);\n__decorate([\n    serialize()\n], BaseTexture.prototype, \"anisotropicFilteringLevel\", void 0);\n__decorate([\n    serialize()\n], BaseTexture.prototype, \"isCube\", null);\n__decorate([\n    serialize()\n], BaseTexture.prototype, \"is3D\", null);\n__decorate([\n    serialize()\n], BaseTexture.prototype, \"is2DArray\", null);\n__decorate([\n    serialize()\n], BaseTexture.prototype, \"gammaSpace\", null);\n__decorate([\n    serialize()\n], BaseTexture.prototype, \"invertZ\", void 0);\n__decorate([\n    serialize()\n], BaseTexture.prototype, \"lodLevelInAlpha\", void 0);\n__decorate([\n    serialize()\n], BaseTexture.prototype, \"lodGenerationOffset\", null);\n__decorate([\n    serialize()\n], BaseTexture.prototype, \"lodGenerationScale\", null);\n__decorate([\n    serialize()\n], BaseTexture.prototype, \"linearSpecularLOD\", null);\n__decorate([\n    serializeAsTexture()\n], BaseTexture.prototype, \"irradianceTexture\", null);\n__decorate([\n    serialize()\n], BaseTexture.prototype, \"isRenderTarget\", void 0);\n//# sourceMappingURL=baseTexture.js.map","import { CubeMapToSphericalPolynomialTools } from \"../../Misc/HighDynamicRange/cubemapToSphericalPolynomial.js\";\nimport { BaseTexture } from \"./baseTexture.js\";\nBaseTexture.prototype.forceSphericalPolynomialsRecompute = function () {\n    if (this._texture) {\n        this._texture._sphericalPolynomial = null;\n        this._texture._sphericalPolynomialPromise = null;\n        this._texture._sphericalPolynomialComputed = false;\n    }\n};\nObject.defineProperty(BaseTexture.prototype, \"sphericalPolynomial\", {\n    get: function () {\n        if (this._texture) {\n            if (this._texture._sphericalPolynomial || this._texture._sphericalPolynomialComputed) {\n                return this._texture._sphericalPolynomial;\n            }\n            if (this._texture.isReady) {\n                if (!this._texture._sphericalPolynomialPromise) {\n                    this._texture._sphericalPolynomialPromise = CubeMapToSphericalPolynomialTools.ConvertCubeMapTextureToSphericalPolynomial(this);\n                    if (this._texture._sphericalPolynomialPromise === null) {\n                        this._texture._sphericalPolynomialComputed = true;\n                    }\n                    else {\n                        this._texture._sphericalPolynomialPromise.then((sphericalPolynomial) => {\n                            this._texture._sphericalPolynomial = sphericalPolynomial;\n                            this._texture._sphericalPolynomialComputed = true;\n                        });\n                    }\n                }\n                return null;\n            }\n        }\n        return null;\n    },\n    set: function (value) {\n        if (this._texture) {\n            this._texture._sphericalPolynomial = value;\n        }\n    },\n    enumerable: true,\n    configurable: true,\n});\n//# sourceMappingURL=baseTexture.polynomial.js.map","import { __decorate } from \"../../tslib.es6.js\";\nimport { serialize, serializeAsMatrix, SerializationHelper } from \"../../Misc/decorators.js\";\nimport { Tools } from \"../../Misc/tools.js\";\nimport { Matrix, Vector3 } from \"../../Maths/math.vector.js\";\nimport { BaseTexture } from \"../../Materials/Textures/baseTexture.js\";\nimport { Texture } from \"../../Materials/Textures/texture.js\";\n\nimport { GetClass, RegisterClass } from \"../../Misc/typeStore.js\";\nimport \"../../Engines/Extensions/engine.cubeTexture.js\";\nimport { Observable } from \"../../Misc/observable.js\";\n/**\n * Class for creating a cube texture\n */\nexport class CubeTexture extends BaseTexture {\n    /**\n     * Gets or sets the size of the bounding box associated with the cube texture\n     * When defined, the cubemap will switch to local mode\n     * @see https://community.arm.com/graphics/b/blog/posts/reflections-based-on-local-cubemaps-in-unity\n     * @example https://www.babylonjs-playground.com/#RNASML\n     */\n    set boundingBoxSize(value) {\n        if (this._boundingBoxSize && this._boundingBoxSize.equals(value)) {\n            return;\n        }\n        this._boundingBoxSize = value;\n        const scene = this.getScene();\n        if (scene) {\n            scene.markAllMaterialsAsDirty(1);\n        }\n    }\n    /**\n     * Returns the bounding box size\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/reflectionTexture#using-local-cubemap-mode\n     */\n    get boundingBoxSize() {\n        return this._boundingBoxSize;\n    }\n    /**\n     * Sets texture matrix rotation angle around Y axis in radians.\n     */\n    set rotationY(value) {\n        this._rotationY = value;\n        this.setReflectionTextureMatrix(Matrix.RotationY(this._rotationY));\n    }\n    /**\n     * Gets texture matrix rotation angle around Y axis radians.\n     */\n    get rotationY() {\n        return this._rotationY;\n    }\n    /**\n     * Are mip maps generated for this texture or not.\n     */\n    get noMipmap() {\n        return this._noMipmap;\n    }\n    /**\n     * Gets the forced extension (if any)\n     */\n    get forcedExtension() {\n        return this._forcedExtension;\n    }\n    /**\n     * Creates a cube texture from an array of image urls\n     * @param files defines an array of image urls\n     * @param scene defines the hosting scene\n     * @param noMipmap specifies if mip maps are not used\n     * @returns a cube texture\n     */\n    static CreateFromImages(files, scene, noMipmap) {\n        let rootUrlKey = \"\";\n        files.forEach((url) => (rootUrlKey += url));\n        return new CubeTexture(rootUrlKey, scene, null, noMipmap, files);\n    }\n    /**\n     * Creates and return a texture created from prefilterd data by tools like IBL Baker or Lys.\n     * @param url defines the url of the prefiltered texture\n     * @param scene defines the scene the texture is attached to\n     * @param forcedExtension defines the extension of the file if different from the url\n     * @param createPolynomials defines whether or not to create polynomial harmonics from the texture data if necessary\n     * @returns the prefiltered texture\n     */\n    static CreateFromPrefilteredData(url, scene, forcedExtension = null, createPolynomials = true) {\n        const oldValue = scene.useDelayedTextureLoading;\n        scene.useDelayedTextureLoading = false;\n        const result = new CubeTexture(url, scene, null, false, null, null, null, undefined, true, forcedExtension, createPolynomials);\n        scene.useDelayedTextureLoading = oldValue;\n        return result;\n    }\n    /**\n     * Creates a cube texture to use with reflection for instance. It can be based upon dds or six images as well\n     * as prefiltered data.\n     * @param rootUrl defines the url of the texture or the root name of the six images\n     * @param sceneOrEngine defines the scene or engine the texture is attached to\n     * @param extensions defines the suffixes add to the picture name in case six images are in use like _px.jpg...\n     * @param noMipmap defines if mipmaps should be created or not\n     * @param files defines the six files to load for the different faces in that order: px, py, pz, nx, ny, nz\n     * @param onLoad defines a callback triggered at the end of the file load if no errors occurred\n     * @param onError defines a callback triggered in case of error during load\n     * @param format defines the internal format to use for the texture once loaded\n     * @param prefiltered defines whether or not the texture is created from prefiltered data\n     * @param forcedExtension defines the extensions to use (force a special type of file to load) in case it is different from the file name\n     * @param createPolynomials defines whether or not to create polynomial harmonics from the texture data if necessary\n     * @param lodScale defines the scale applied to environment texture. This manages the range of LOD level used for IBL according to the roughness\n     * @param lodOffset defines the offset applied to environment texture. This manages first LOD level used for IBL according to the roughness\n     * @param loaderOptions options to be passed to the loader\n     * @param useSRGBBuffer Defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU) (default: false)\n     * @returns the cube texture\n     */\n    constructor(rootUrl, sceneOrEngine, extensions = null, noMipmap = false, files = null, onLoad = null, onError = null, format = 5, prefiltered = false, forcedExtension = null, createPolynomials = false, lodScale = 0.8, lodOffset = 0, loaderOptions, useSRGBBuffer) {\n        var _a;\n        super(sceneOrEngine);\n        this._lodScale = 0.8;\n        this._lodOffset = 0;\n        /**\n         * Observable triggered once the texture has been loaded.\n         */\n        this.onLoadObservable = new Observable();\n        /**\n         * Gets or sets the center of the bounding box associated with the cube texture.\n         * It must define where the camera used to render the texture was set\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/reflectionTexture#using-local-cubemap-mode\n         */\n        this.boundingBoxPosition = Vector3.Zero();\n        this._rotationY = 0;\n        /** @internal */\n        this._files = null;\n        this._forcedExtension = null;\n        this._extensions = null;\n        this.name = rootUrl;\n        this.url = rootUrl;\n        this._noMipmap = noMipmap;\n        this.hasAlpha = false;\n        this._format = format;\n        this.isCube = true;\n        this._textureMatrix = Matrix.Identity();\n        this._createPolynomials = createPolynomials;\n        this.coordinatesMode = Texture.CUBIC_MODE;\n        this._extensions = extensions;\n        this._files = files;\n        this._forcedExtension = forcedExtension;\n        this._loaderOptions = loaderOptions;\n        this._useSRGBBuffer = useSRGBBuffer;\n        this._lodScale = lodScale;\n        this._lodOffset = lodOffset;\n        if (!rootUrl && !files) {\n            return;\n        }\n        this.updateURL(rootUrl, forcedExtension, onLoad, prefiltered, onError, extensions, (_a = this.getScene()) === null || _a === void 0 ? void 0 : _a.useDelayedTextureLoading, files);\n    }\n    /**\n     * Get the current class name of the texture useful for serialization or dynamic coding.\n     * @returns \"CubeTexture\"\n     */\n    getClassName() {\n        return \"CubeTexture\";\n    }\n    /**\n     * Update the url (and optional buffer) of this texture if url was null during construction.\n     * @param url the url of the texture\n     * @param forcedExtension defines the extension to use\n     * @param onLoad callback called when the texture is loaded  (defaults to null)\n     * @param prefiltered Defines whether the updated texture is prefiltered or not\n     * @param onError callback called if there was an error during the loading process (defaults to null)\n     * @param extensions defines the suffixes add to the picture name in case six images are in use like _px.jpg...\n     * @param delayLoad defines if the texture should be loaded now (false by default)\n     * @param files defines the six files to load for the different faces in that order: px, py, pz, nx, ny, nz\n     */\n    updateURL(url, forcedExtension, onLoad = null, prefiltered = false, onError = null, extensions = null, delayLoad = false, files = null) {\n        if (!this.name || this.name.startsWith(\"data:\")) {\n            this.name = url;\n        }\n        this.url = url;\n        if (forcedExtension) {\n            this._forcedExtension = forcedExtension;\n        }\n        const lastDot = url.lastIndexOf(\".\");\n        const extension = forcedExtension ? forcedExtension : lastDot > -1 ? url.substring(lastDot).toLowerCase() : \"\";\n        const isDDS = extension.indexOf(\".dds\") === 0;\n        const isEnv = extension.indexOf(\".env\") === 0;\n        const isBasis = extension.indexOf(\".basis\") === 0;\n        if (isEnv) {\n            this.gammaSpace = false;\n            this._prefiltered = false;\n            this.anisotropicFilteringLevel = 1;\n        }\n        else {\n            this._prefiltered = prefiltered;\n            if (prefiltered) {\n                this.gammaSpace = false;\n                this.anisotropicFilteringLevel = 1;\n            }\n        }\n        if (files) {\n            this._files = files;\n        }\n        else {\n            if (!isBasis && !isEnv && !isDDS && !extensions) {\n                extensions = [\"_px.jpg\", \"_py.jpg\", \"_pz.jpg\", \"_nx.jpg\", \"_ny.jpg\", \"_nz.jpg\"];\n            }\n            this._files = this._files || [];\n            this._files.length = 0;\n            if (extensions) {\n                for (let index = 0; index < extensions.length; index++) {\n                    this._files.push(url + extensions[index]);\n                }\n                this._extensions = extensions;\n            }\n        }\n        if (delayLoad) {\n            this.delayLoadState = 4;\n            this._delayedOnLoad = onLoad;\n            this._delayedOnError = onError;\n        }\n        else {\n            this._loadTexture(onLoad, onError);\n        }\n    }\n    /**\n     * Delays loading of the cube texture\n     * @param forcedExtension defines the extension to use\n     */\n    delayLoad(forcedExtension) {\n        if (this.delayLoadState !== 4) {\n            return;\n        }\n        if (forcedExtension) {\n            this._forcedExtension = forcedExtension;\n        }\n        this.delayLoadState = 1;\n        this._loadTexture(this._delayedOnLoad, this._delayedOnError);\n    }\n    /**\n     * Returns the reflection texture matrix\n     * @returns the reflection texture matrix\n     */\n    getReflectionTextureMatrix() {\n        return this._textureMatrix;\n    }\n    /**\n     * Sets the reflection texture matrix\n     * @param value Reflection texture matrix\n     */\n    setReflectionTextureMatrix(value) {\n        var _a;\n        if (value.updateFlag === this._textureMatrix.updateFlag) {\n            return;\n        }\n        if (value.isIdentity() !== this._textureMatrix.isIdentity()) {\n            (_a = this.getScene()) === null || _a === void 0 ? void 0 : _a.markAllMaterialsAsDirty(1, (mat) => mat.getActiveTextures().indexOf(this) !== -1);\n        }\n        this._textureMatrix = value;\n    }\n    _loadTexture(onLoad = null, onError = null) {\n        var _a;\n        const scene = this.getScene();\n        const oldTexture = this._texture;\n        this._texture = this._getFromCache(this.url, this._noMipmap, undefined, undefined, this._useSRGBBuffer, this.isCube);\n        const onLoadProcessing = () => {\n            var _a;\n            this.onLoadObservable.notifyObservers(this);\n            if (oldTexture) {\n                oldTexture.dispose();\n                (_a = this.getScene()) === null || _a === void 0 ? void 0 : _a.markAllMaterialsAsDirty(1);\n            }\n            if (onLoad) {\n                onLoad();\n            }\n        };\n        const errorHandler = (message, exception) => {\n            this._loadingError = true;\n            this._errorObject = { message, exception };\n            if (onError) {\n                onError(message, exception);\n            }\n            Texture.OnTextureLoadErrorObservable.notifyObservers(this);\n        };\n        if (!this._texture) {\n            if (this._prefiltered) {\n                this._texture = this._getEngine().createPrefilteredCubeTexture(this.url, scene, this._lodScale, this._lodOffset, onLoad, errorHandler, this._format, this._forcedExtension, this._createPolynomials);\n            }\n            else {\n                this._texture = this._getEngine().createCubeTexture(this.url, scene, this._files, this._noMipmap, onLoad, errorHandler, this._format, this._forcedExtension, false, this._lodScale, this._lodOffset, null, this._loaderOptions, !!this._useSRGBBuffer);\n            }\n            (_a = this._texture) === null || _a === void 0 ? void 0 : _a.onLoadedObservable.add(() => this.onLoadObservable.notifyObservers(this));\n        }\n        else {\n            if (this._texture.isReady) {\n                Tools.SetImmediate(() => onLoadProcessing());\n            }\n            else {\n                this._texture.onLoadedObservable.add(() => onLoadProcessing());\n            }\n        }\n    }\n    /**\n     * Parses text to create a cube texture\n     * @param parsedTexture define the serialized text to read from\n     * @param scene defines the hosting scene\n     * @param rootUrl defines the root url of the cube texture\n     * @returns a cube texture\n     */\n    static Parse(parsedTexture, scene, rootUrl) {\n        const texture = SerializationHelper.Parse(() => {\n            let prefiltered = false;\n            if (parsedTexture.prefiltered) {\n                prefiltered = parsedTexture.prefiltered;\n            }\n            return new CubeTexture(rootUrl + parsedTexture.name, scene, parsedTexture.extensions, false, parsedTexture.files || null, null, null, undefined, prefiltered, parsedTexture.forcedExtension);\n        }, parsedTexture, scene);\n        // Local Cubemaps\n        if (parsedTexture.boundingBoxPosition) {\n            texture.boundingBoxPosition = Vector3.FromArray(parsedTexture.boundingBoxPosition);\n        }\n        if (parsedTexture.boundingBoxSize) {\n            texture.boundingBoxSize = Vector3.FromArray(parsedTexture.boundingBoxSize);\n        }\n        // Animations\n        if (parsedTexture.animations) {\n            for (let animationIndex = 0; animationIndex < parsedTexture.animations.length; animationIndex++) {\n                const parsedAnimation = parsedTexture.animations[animationIndex];\n                const internalClass = GetClass(\"BABYLON.Animation\");\n                if (internalClass) {\n                    texture.animations.push(internalClass.Parse(parsedAnimation));\n                }\n            }\n        }\n        return texture;\n    }\n    /**\n     * Makes a clone, or deep copy, of the cube texture\n     * @returns a new cube texture\n     */\n    clone() {\n        let uniqueId = 0;\n        const newCubeTexture = SerializationHelper.Clone(() => {\n            const cubeTexture = new CubeTexture(this.url, this.getScene() || this._getEngine(), this._extensions, this._noMipmap, this._files);\n            uniqueId = cubeTexture.uniqueId;\n            return cubeTexture;\n        }, this);\n        newCubeTexture.uniqueId = uniqueId;\n        return newCubeTexture;\n    }\n}\n__decorate([\n    serialize()\n], CubeTexture.prototype, \"url\", void 0);\n__decorate([\n    serialize(\"rotationY\")\n], CubeTexture.prototype, \"rotationY\", null);\n__decorate([\n    serialize(\"files\")\n], CubeTexture.prototype, \"_files\", void 0);\n__decorate([\n    serialize(\"forcedExtension\")\n], CubeTexture.prototype, \"_forcedExtension\", void 0);\n__decorate([\n    serialize(\"extensions\")\n], CubeTexture.prototype, \"_extensions\", void 0);\n__decorate([\n    serializeAsMatrix(\"textureMatrix\")\n], CubeTexture.prototype, \"_textureMatrix\", void 0);\nTexture._CubeTextureParser = CubeTexture.Parse;\n// Some exporters relies on Tools.Instantiate\nRegisterClass(\"BABYLON.CubeTexture\", CubeTexture);\n//# sourceMappingURL=cubeTexture.js.map","import { Logger } from \"../../Misc/logger.js\";\nimport { Texture } from \"../../Materials/Textures/texture.js\";\n\nimport \"../../Engines/Extensions/engine.dynamicTexture.js\";\n/**\n * A class extending Texture allowing drawing on a texture\n * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/dynamicTexture\n */\nexport class DynamicTexture extends Texture {\n    /**\n     * Creates a DynamicTexture\n     * @param name defines the name of the texture\n     * @param options provides 3 alternatives for width and height of texture, a canvas, object with width and height properties, number for both width and height\n     * @param scene defines the scene where you want the texture\n     * @param generateMipMaps defines the use of MinMaps or not (default is false)\n     * @param samplingMode defines the sampling mode to use (default is Texture.TRILINEAR_SAMPLINGMODE)\n     * @param format defines the texture format to use (default is Engine.TEXTUREFORMAT_RGBA)\n     * @param invertY defines if the texture needs to be inverted on the y axis during loading\n     */\n    constructor(name, options, scene = null, generateMipMaps = false, samplingMode = 3, format = 5, invertY) {\n        super(null, scene, !generateMipMaps, invertY, samplingMode, undefined, undefined, undefined, undefined, format);\n        this.name = name;\n        this.wrapU = Texture.CLAMP_ADDRESSMODE;\n        this.wrapV = Texture.CLAMP_ADDRESSMODE;\n        this._generateMipMaps = generateMipMaps;\n        const engine = this._getEngine();\n        if (!engine) {\n            return;\n        }\n        if (options.getContext) {\n            this._canvas = options;\n            this._texture = engine.createDynamicTexture(options.width, options.height, generateMipMaps, samplingMode);\n        }\n        else {\n            this._canvas = engine.createCanvas(1, 1);\n            if (options.width || options.width === 0) {\n                this._texture = engine.createDynamicTexture(options.width, options.height, generateMipMaps, samplingMode);\n            }\n            else {\n                this._texture = engine.createDynamicTexture(options, options, generateMipMaps, samplingMode);\n            }\n        }\n        const textureSize = this.getSize();\n        if (this._canvas.width !== textureSize.width) {\n            this._canvas.width = textureSize.width;\n        }\n        if (this._canvas.height !== textureSize.height) {\n            this._canvas.height = textureSize.height;\n        }\n        this._context = this._canvas.getContext(\"2d\");\n    }\n    /**\n     * Get the current class name of the texture useful for serialization or dynamic coding.\n     * @returns \"DynamicTexture\"\n     */\n    getClassName() {\n        return \"DynamicTexture\";\n    }\n    /**\n     * Gets the current state of canRescale\n     */\n    get canRescale() {\n        return true;\n    }\n    _recreate(textureSize) {\n        this._canvas.width = textureSize.width;\n        this._canvas.height = textureSize.height;\n        this.releaseInternalTexture();\n        this._texture = this._getEngine().createDynamicTexture(textureSize.width, textureSize.height, this._generateMipMaps, this.samplingMode);\n    }\n    /**\n     * Scales the texture\n     * @param ratio the scale factor to apply to both width and height\n     */\n    scale(ratio) {\n        const textureSize = this.getSize();\n        textureSize.width *= ratio;\n        textureSize.height *= ratio;\n        this._recreate(textureSize);\n    }\n    /**\n     * Resizes the texture\n     * @param width the new width\n     * @param height the new height\n     */\n    scaleTo(width, height) {\n        const textureSize = this.getSize();\n        textureSize.width = width;\n        textureSize.height = height;\n        this._recreate(textureSize);\n    }\n    /**\n     * Gets the context of the canvas used by the texture\n     * @returns the canvas context of the dynamic texture\n     */\n    getContext() {\n        return this._context;\n    }\n    /**\n     * Clears the texture\n     */\n    clear() {\n        const size = this.getSize();\n        this._context.fillRect(0, 0, size.width, size.height);\n    }\n    /**\n     * Updates the texture\n     * @param invertY defines the direction for the Y axis (default is true - y increases downwards)\n     * @param premulAlpha defines if alpha is stored as premultiplied (default is false)\n     * @param allowGPUOptimization true to allow some specific GPU optimizations (subject to engine feature \"allowGPUOptimizationsForGUI\" being true)\n     */\n    update(invertY, premulAlpha = false, allowGPUOptimization = false) {\n        this._getEngine().updateDynamicTexture(this._texture, this._canvas, invertY === undefined ? true : invertY, premulAlpha, this._format || undefined, undefined, allowGPUOptimization);\n    }\n    /**\n     * Draws text onto the texture\n     * @param text defines the text to be drawn\n     * @param x defines the placement of the text from the left\n     * @param y defines the placement of the text from the top when invertY is true and from the bottom when false\n     * @param font defines the font to be used with font-style, font-size, font-name\n     * @param color defines the color used for the text\n     * @param clearColor defines the color for the canvas, use null to not overwrite canvas\n     * @param invertY defines the direction for the Y axis (default is true - y increases downwards)\n     * @param update defines whether texture is immediately update (default is true)\n     */\n    drawText(text, x, y, font, color, clearColor, invertY, update = true) {\n        const size = this.getSize();\n        if (clearColor) {\n            this._context.fillStyle = clearColor;\n            this._context.fillRect(0, 0, size.width, size.height);\n        }\n        this._context.font = font;\n        if (x === null || x === undefined) {\n            const textSize = this._context.measureText(text);\n            x = (size.width - textSize.width) / 2;\n        }\n        if (y === null || y === undefined) {\n            const fontSize = parseInt(font.replace(/\\D/g, \"\"));\n            y = size.height / 2 + fontSize / 3.65;\n        }\n        this._context.fillStyle = color || \"\";\n        this._context.fillText(text, x, y);\n        if (update) {\n            this.update(invertY);\n        }\n    }\n    /**\n     * Clones the texture\n     * @returns the clone of the texture.\n     */\n    clone() {\n        const scene = this.getScene();\n        if (!scene) {\n            return this;\n        }\n        const textureSize = this.getSize();\n        const newTexture = new DynamicTexture(this.name, textureSize, scene, this._generateMipMaps);\n        // Base texture\n        newTexture.hasAlpha = this.hasAlpha;\n        newTexture.level = this.level;\n        // Dynamic Texture\n        newTexture.wrapU = this.wrapU;\n        newTexture.wrapV = this.wrapV;\n        return newTexture;\n    }\n    /**\n     * Serializes the dynamic texture.  The scene should be ready before the dynamic texture is serialized\n     * @returns a serialized dynamic texture object\n     */\n    serialize() {\n        const scene = this.getScene();\n        if (scene && !scene.isReady()) {\n            Logger.Warn(\"The scene must be ready before serializing the dynamic texture\");\n        }\n        const serializationObject = super.serialize();\n        if (DynamicTexture._IsCanvasElement(this._canvas)) {\n            serializationObject.base64String = this._canvas.toDataURL();\n        }\n        serializationObject.invertY = this._invertY;\n        serializationObject.samplingMode = this.samplingMode;\n        return serializationObject;\n    }\n    static _IsCanvasElement(canvas) {\n        return canvas.toDataURL !== undefined;\n    }\n    /** @internal */\n    _rebuild() {\n        this.update();\n    }\n}\n//# sourceMappingURL=dynamicTexture.js.map","import { PanoramaToCubeMapTools } from \"../../Misc/HighDynamicRange/panoramaToCubemap.js\";\nimport { BaseTexture } from \"./baseTexture.js\";\nimport { Texture } from \"./texture.js\";\nimport { Tools } from \"../../Misc/tools.js\";\nimport \"../../Engines/Extensions/engine.rawTexture.js\";\n\nimport { LoadImage } from \"../../Misc/fileTools.js\";\n/**\n * This represents a texture coming from an equirectangular image supported by the web browser canvas.\n */\nexport class EquiRectangularCubeTexture extends BaseTexture {\n    /**\n     * Instantiates an EquiRectangularCubeTexture from the following parameters.\n     * @param url The location of the image\n     * @param scene The scene the texture will be used in\n     * @param size The cubemap desired size (the more it increases the longer the generation will be)\n     * @param noMipmap Forces to not generate the mipmap if true\n     * @param gammaSpace Specifies if the texture will be used in gamma or linear space\n     * (the PBR material requires those textures in linear space, but the standard material would require them in Gamma space)\n     * @param onLoad  defines a callback called when texture is loaded\n     * @param onError  defines a callback called if there is an error\n     */\n    constructor(url, scene, size, noMipmap = false, gammaSpace = true, onLoad = null, onError = null) {\n        super(scene);\n        this._onLoad = null;\n        this._onError = null;\n        if (!url) {\n            throw new Error(\"Image url is not set\");\n        }\n        this._coordinatesMode = Texture.CUBIC_MODE;\n        this.name = url;\n        this.url = url;\n        this._size = size;\n        this._noMipmap = noMipmap;\n        this.gammaSpace = gammaSpace;\n        this._onLoad = onLoad;\n        this._onError = onError;\n        this.hasAlpha = false;\n        this.isCube = true;\n        this._texture = this._getFromCache(url, this._noMipmap, undefined, undefined, undefined, this.isCube);\n        if (!this._texture) {\n            if (!scene.useDelayedTextureLoading) {\n                this._loadImage(this._loadTexture.bind(this), this._onError);\n            }\n            else {\n                this.delayLoadState = 4;\n            }\n        }\n        else if (onLoad) {\n            if (this._texture.isReady) {\n                Tools.SetImmediate(() => onLoad());\n            }\n            else {\n                this._texture.onLoadedObservable.add(onLoad);\n            }\n        }\n    }\n    /**\n     * Load the image data, by putting the image on a canvas and extracting its buffer.\n     * @param loadTextureCallback\n     * @param onError\n     */\n    _loadImage(loadTextureCallback, onError) {\n        const canvas = document.createElement(\"canvas\");\n        LoadImage(this.url, (image) => {\n            this._width = image.width;\n            this._height = image.height;\n            canvas.width = this._width;\n            canvas.height = this._height;\n            const ctx = canvas.getContext(\"2d\");\n            ctx.drawImage(image, 0, 0);\n            const imageData = ctx.getImageData(0, 0, image.width, image.height);\n            this._buffer = imageData.data.buffer;\n            canvas.remove();\n            loadTextureCallback();\n        }, (_, e) => {\n            if (onError) {\n                onError(`${this.getClassName()} could not be loaded`, e);\n            }\n        }, null);\n    }\n    /**\n     * Convert the image buffer into a cubemap and create a CubeTexture.\n     */\n    _loadTexture() {\n        const scene = this.getScene();\n        const callback = () => {\n            const imageData = this._getFloat32ArrayFromArrayBuffer(this._buffer);\n            // Extract the raw linear data.\n            const data = PanoramaToCubeMapTools.ConvertPanoramaToCubemap(imageData, this._width, this._height, this._size);\n            const results = [];\n            // Push each faces.\n            for (let i = 0; i < 6; i++) {\n                const dataFace = data[EquiRectangularCubeTexture._FacesMapping[i]];\n                results.push(dataFace);\n            }\n            return results;\n        };\n        if (!scene) {\n            return;\n        }\n        this._texture = scene\n            .getEngine()\n            .createRawCubeTextureFromUrl(this.url, scene, this._size, 4, scene.getEngine().getCaps().textureFloat ? 1 : 7, this._noMipmap, callback, null, this._onLoad, this._onError);\n    }\n    /**\n     * Convert the ArrayBuffer into a Float32Array and drop the transparency channel.\n     * @param buffer The ArrayBuffer that should be converted.\n     * @returns The buffer as Float32Array.\n     */\n    _getFloat32ArrayFromArrayBuffer(buffer) {\n        const dataView = new DataView(buffer);\n        const floatImageData = new Float32Array((buffer.byteLength * 3) / 4);\n        let k = 0;\n        for (let i = 0; i < buffer.byteLength; i++) {\n            // We drop the transparency channel, because we do not need/want it\n            if ((i + 1) % 4 !== 0) {\n                floatImageData[k++] = dataView.getUint8(i) / 255;\n            }\n        }\n        return floatImageData;\n    }\n    /**\n     * Get the current class name of the texture useful for serialization or dynamic coding.\n     * @returns \"EquiRectangularCubeTexture\"\n     */\n    getClassName() {\n        return \"EquiRectangularCubeTexture\";\n    }\n    /**\n     * Create a clone of the current EquiRectangularCubeTexture and return it.\n     * @returns A clone of the current EquiRectangularCubeTexture.\n     */\n    clone() {\n        const scene = this.getScene();\n        if (!scene) {\n            return this;\n        }\n        const newTexture = new EquiRectangularCubeTexture(this.url, scene, this._size, this._noMipmap, this.gammaSpace);\n        // Base texture\n        newTexture.level = this.level;\n        newTexture.wrapU = this.wrapU;\n        newTexture.wrapV = this.wrapV;\n        newTexture.coordinatesIndex = this.coordinatesIndex;\n        newTexture.coordinatesMode = this.coordinatesMode;\n        return newTexture;\n    }\n}\n/** The six faces of the cube. */\nEquiRectangularCubeTexture._FacesMapping = [\"right\", \"left\", \"up\", \"down\", \"front\", \"back\"];\n//# sourceMappingURL=equiRectangularCubeTexture.js.map","\nimport { InternalTexture } from \"./internalTexture.js\";\n/**\n * Class used to store an external texture (like GPUExternalTexture in WebGPU)\n */\nexport class ExternalTexture {\n    /**\n     * Checks if a texture is an external or internal texture\n     * @param texture the external or internal texture\n     * @returns true if the texture is an external texture, else false\n     */\n    static IsExternalTexture(texture) {\n        return texture.underlyingResource !== undefined;\n    }\n    /**\n     * Get the class name of the texture.\n     * @returns \"ExternalTexture\"\n     */\n    getClassName() {\n        return \"ExternalTexture\";\n    }\n    /**\n     * Gets the underlying texture object\n     */\n    get underlyingResource() {\n        return this._video;\n    }\n    /**\n     * Constructs the texture\n     * @param video The video the texture should be wrapped around\n     */\n    constructor(video) {\n        /**\n         * Gets a boolean indicating if the texture uses mipmaps\n         */\n        this.useMipMaps = false;\n        /**\n         * The type of the underlying texture is implementation dependent, so return \"UNDEFINED\" for the type\n         */\n        this.type = 16;\n        this._video = video;\n        this.uniqueId = InternalTexture._Counter++;\n    }\n    /**\n     * Get if the texture is ready to be used (downloaded, converted, mip mapped...).\n     * @returns true if fully ready\n     */\n    isReady() {\n        return this._video.readyState >= this._video.HAVE_CURRENT_DATA;\n    }\n    /**\n     * Dispose the texture and release its associated resources.\n     */\n    dispose() { }\n}\n//# sourceMappingURL=externalTexture.js.map","import { Matrix, Vector3 } from \"../../Maths/math.vector.js\";\nimport { BaseTexture } from \"../../Materials/Textures/baseTexture.js\";\nimport { Texture } from \"../../Materials/Textures/texture.js\";\n\nimport { HDRTools } from \"../../Misc/HighDynamicRange/hdr.js\";\nimport { CubeMapToSphericalPolynomialTools } from \"../../Misc/HighDynamicRange/cubemapToSphericalPolynomial.js\";\nimport { RegisterClass } from \"../../Misc/typeStore.js\";\nimport { Observable } from \"../../Misc/observable.js\";\nimport { Tools } from \"../../Misc/tools.js\";\nimport { ToGammaSpace } from \"../../Maths/math.constants.js\";\nimport { HDRFiltering } from \"../../Materials/Textures/Filtering/hdrFiltering.js\";\nimport { ToHalfFloat } from \"../../Misc/textureTools.js\";\nimport \"../../Engines/Extensions/engine.rawTexture.js\";\nimport \"../../Materials/Textures/baseTexture.polynomial.js\";\n/**\n * This represents a texture coming from an HDR input.\n *\n * The only supported format is currently panorama picture stored in RGBE format.\n * Example of such files can be found on Poly Haven: https://polyhaven.com/hdris\n */\nexport class HDRCubeTexture extends BaseTexture {\n    /**\n     * Sets whether or not the texture is blocking during loading.\n     */\n    set isBlocking(value) {\n        this._isBlocking = value;\n    }\n    /**\n     * Gets whether or not the texture is blocking during loading.\n     */\n    get isBlocking() {\n        return this._isBlocking;\n    }\n    /**\n     * Sets texture matrix rotation angle around Y axis in radians.\n     */\n    set rotationY(value) {\n        this._rotationY = value;\n        this.setReflectionTextureMatrix(Matrix.RotationY(this._rotationY));\n    }\n    /**\n     * Gets texture matrix rotation angle around Y axis radians.\n     */\n    get rotationY() {\n        return this._rotationY;\n    }\n    /**\n     * Gets or sets the size of the bounding box associated with the cube texture\n     * When defined, the cubemap will switch to local mode\n     * @see https://community.arm.com/graphics/b/blog/posts/reflections-based-on-local-cubemaps-in-unity\n     * @example https://www.babylonjs-playground.com/#RNASML\n     */\n    set boundingBoxSize(value) {\n        if (this._boundingBoxSize && this._boundingBoxSize.equals(value)) {\n            return;\n        }\n        this._boundingBoxSize = value;\n        const scene = this.getScene();\n        if (scene) {\n            scene.markAllMaterialsAsDirty(1);\n        }\n    }\n    get boundingBoxSize() {\n        return this._boundingBoxSize;\n    }\n    /**\n     * Instantiates an HDRTexture from the following parameters.\n     *\n     * @param url The location of the HDR raw data (Panorama stored in RGBE format)\n     * @param sceneOrEngine The scene or engine the texture will be used in\n     * @param size The cubemap desired size (the more it increases the longer the generation will be)\n     * @param noMipmap Forces to not generate the mipmap if true\n     * @param generateHarmonics Specifies whether you want to extract the polynomial harmonics during the generation process\n     * @param gammaSpace Specifies if the texture will be use in gamma or linear space (the PBR material requires those texture in linear space, but the standard material would require them in Gamma space)\n     * @param prefilterOnLoad Prefilters HDR texture to allow use of this texture as a PBR reflection texture.\n     * @param onLoad\n     * @param onError\n     */\n    constructor(url, sceneOrEngine, size, noMipmap = false, generateHarmonics = true, gammaSpace = false, prefilterOnLoad = false, onLoad = null, onError = null) {\n        var _a;\n        super(sceneOrEngine);\n        this._generateHarmonics = true;\n        this._onError = null;\n        this._isBlocking = true;\n        this._rotationY = 0;\n        /**\n         * Gets or sets the center of the bounding box associated with the cube texture\n         * It must define where the camera used to render the texture was set\n         */\n        this.boundingBoxPosition = Vector3.Zero();\n        /**\n         * Observable triggered once the texture has been loaded.\n         */\n        this.onLoadObservable = new Observable();\n        if (!url) {\n            return;\n        }\n        this._coordinatesMode = Texture.CUBIC_MODE;\n        this.name = url;\n        this.url = url;\n        this.hasAlpha = false;\n        this.isCube = true;\n        this._textureMatrix = Matrix.Identity();\n        this._prefilterOnLoad = prefilterOnLoad;\n        this._onLoad = () => {\n            this.onLoadObservable.notifyObservers(this);\n            if (onLoad) {\n                onLoad();\n            }\n        };\n        this._onError = onError;\n        this.gammaSpace = gammaSpace;\n        this._noMipmap = noMipmap;\n        this._size = size;\n        this._generateHarmonics = generateHarmonics;\n        this._texture = this._getFromCache(url, this._noMipmap, undefined, undefined, undefined, this.isCube);\n        if (!this._texture) {\n            if (!((_a = this.getScene()) === null || _a === void 0 ? void 0 : _a.useDelayedTextureLoading)) {\n                this._loadTexture();\n            }\n            else {\n                this.delayLoadState = 4;\n            }\n        }\n        else {\n            if (this._texture.isReady) {\n                Tools.SetImmediate(() => this._onLoad());\n            }\n            else {\n                this._texture.onLoadedObservable.add(this._onLoad);\n            }\n        }\n    }\n    /**\n     * Get the current class name of the texture useful for serialization or dynamic coding.\n     * @returns \"HDRCubeTexture\"\n     */\n    getClassName() {\n        return \"HDRCubeTexture\";\n    }\n    /**\n     * Occurs when the file is raw .hdr file.\n     */\n    _loadTexture() {\n        const engine = this._getEngine();\n        const caps = engine.getCaps();\n        let textureType = 0;\n        if (caps.textureFloat && caps.textureFloatLinearFiltering) {\n            textureType = 1;\n        }\n        else if (caps.textureHalfFloat && caps.textureHalfFloatLinearFiltering) {\n            textureType = 2;\n        }\n        const callback = (buffer) => {\n            this.lodGenerationOffset = 0.0;\n            this.lodGenerationScale = 0.8;\n            // Extract the raw linear data.\n            const data = HDRTools.GetCubeMapTextureData(buffer, this._size);\n            // Generate harmonics if needed.\n            if (this._generateHarmonics) {\n                const sphericalPolynomial = CubeMapToSphericalPolynomialTools.ConvertCubeMapToSphericalPolynomial(data);\n                this.sphericalPolynomial = sphericalPolynomial;\n            }\n            const results = [];\n            let byteArray = null;\n            let shortArray = null;\n            // Push each faces.\n            for (let j = 0; j < 6; j++) {\n                // Create fallback array\n                if (textureType === 2) {\n                    shortArray = new Uint16Array(this._size * this._size * 3);\n                }\n                else if (textureType === 0) {\n                    // 3 channels of 1 bytes per pixel in bytes.\n                    byteArray = new Uint8Array(this._size * this._size * 3);\n                }\n                const dataFace = data[HDRCubeTexture._FacesMapping[j]];\n                // If special cases.\n                if (this.gammaSpace || shortArray || byteArray) {\n                    for (let i = 0; i < this._size * this._size; i++) {\n                        // Put in gamma space if requested.\n                        if (this.gammaSpace) {\n                            dataFace[i * 3 + 0] = Math.pow(dataFace[i * 3 + 0], ToGammaSpace);\n                            dataFace[i * 3 + 1] = Math.pow(dataFace[i * 3 + 1], ToGammaSpace);\n                            dataFace[i * 3 + 2] = Math.pow(dataFace[i * 3 + 2], ToGammaSpace);\n                        }\n                        // Convert to half float texture for fallback.\n                        if (shortArray) {\n                            shortArray[i * 3 + 0] = ToHalfFloat(dataFace[i * 3 + 0]);\n                            shortArray[i * 3 + 1] = ToHalfFloat(dataFace[i * 3 + 1]);\n                            shortArray[i * 3 + 2] = ToHalfFloat(dataFace[i * 3 + 2]);\n                        }\n                        // Convert to int texture for fallback.\n                        if (byteArray) {\n                            let r = Math.max(dataFace[i * 3 + 0] * 255, 0);\n                            let g = Math.max(dataFace[i * 3 + 1] * 255, 0);\n                            let b = Math.max(dataFace[i * 3 + 2] * 255, 0);\n                            // May use luminance instead if the result is not accurate.\n                            const max = Math.max(Math.max(r, g), b);\n                            if (max > 255) {\n                                const scale = 255 / max;\n                                r *= scale;\n                                g *= scale;\n                                b *= scale;\n                            }\n                            byteArray[i * 3 + 0] = r;\n                            byteArray[i * 3 + 1] = g;\n                            byteArray[i * 3 + 2] = b;\n                        }\n                    }\n                }\n                if (shortArray) {\n                    results.push(shortArray);\n                }\n                else if (byteArray) {\n                    results.push(byteArray);\n                }\n                else {\n                    results.push(dataFace);\n                }\n            }\n            return results;\n        };\n        if (engine._features.allowTexturePrefiltering && this._prefilterOnLoad) {\n            const previousOnLoad = this._onLoad;\n            const hdrFiltering = new HDRFiltering(engine);\n            this._onLoad = () => {\n                hdrFiltering.prefilter(this, previousOnLoad);\n            };\n        }\n        this._texture = engine.createRawCubeTextureFromUrl(this.url, this.getScene(), this._size, 4, textureType, this._noMipmap, callback, null, this._onLoad, this._onError);\n    }\n    clone() {\n        const newTexture = new HDRCubeTexture(this.url, this.getScene() || this._getEngine(), this._size, this._noMipmap, this._generateHarmonics, this.gammaSpace);\n        // Base texture\n        newTexture.level = this.level;\n        newTexture.wrapU = this.wrapU;\n        newTexture.wrapV = this.wrapV;\n        newTexture.coordinatesIndex = this.coordinatesIndex;\n        newTexture.coordinatesMode = this.coordinatesMode;\n        return newTexture;\n    }\n    // Methods\n    delayLoad() {\n        if (this.delayLoadState !== 4) {\n            return;\n        }\n        this.delayLoadState = 1;\n        this._texture = this._getFromCache(this.url, this._noMipmap);\n        if (!this._texture) {\n            this._loadTexture();\n        }\n    }\n    /**\n     * Get the texture reflection matrix used to rotate/transform the reflection.\n     * @returns the reflection matrix\n     */\n    getReflectionTextureMatrix() {\n        return this._textureMatrix;\n    }\n    /**\n     * Set the texture reflection matrix used to rotate/transform the reflection.\n     * @param value Define the reflection matrix to set\n     */\n    setReflectionTextureMatrix(value) {\n        var _a;\n        this._textureMatrix = value;\n        if (value.updateFlag === this._textureMatrix.updateFlag) {\n            return;\n        }\n        if (value.isIdentity() !== this._textureMatrix.isIdentity()) {\n            (_a = this.getScene()) === null || _a === void 0 ? void 0 : _a.markAllMaterialsAsDirty(1, (mat) => mat.getActiveTextures().indexOf(this) !== -1);\n        }\n    }\n    /**\n     * Dispose the texture and release its associated resources.\n     */\n    dispose() {\n        this.onLoadObservable.clear();\n        super.dispose();\n    }\n    /**\n     * Parses a JSON representation of an HDR Texture in order to create the texture\n     * @param parsedTexture Define the JSON representation\n     * @param scene Define the scene the texture should be created in\n     * @param rootUrl Define the root url in case we need to load relative dependencies\n     * @returns the newly created texture after parsing\n     */\n    static Parse(parsedTexture, scene, rootUrl) {\n        let texture = null;\n        if (parsedTexture.name && !parsedTexture.isRenderTarget) {\n            texture = new HDRCubeTexture(rootUrl + parsedTexture.name, scene, parsedTexture.size, parsedTexture.noMipmap, parsedTexture.generateHarmonics, parsedTexture.useInGammaSpace);\n            texture.name = parsedTexture.name;\n            texture.hasAlpha = parsedTexture.hasAlpha;\n            texture.level = parsedTexture.level;\n            texture.coordinatesMode = parsedTexture.coordinatesMode;\n            texture.isBlocking = parsedTexture.isBlocking;\n        }\n        if (texture) {\n            if (parsedTexture.boundingBoxPosition) {\n                texture.boundingBoxPosition = Vector3.FromArray(parsedTexture.boundingBoxPosition);\n            }\n            if (parsedTexture.boundingBoxSize) {\n                texture.boundingBoxSize = Vector3.FromArray(parsedTexture.boundingBoxSize);\n            }\n            if (parsedTexture.rotationY) {\n                texture.rotationY = parsedTexture.rotationY;\n            }\n        }\n        return texture;\n    }\n    serialize() {\n        if (!this.name) {\n            return null;\n        }\n        const serializationObject = {};\n        serializationObject.name = this.name;\n        serializationObject.hasAlpha = this.hasAlpha;\n        serializationObject.isCube = true;\n        serializationObject.level = this.level;\n        serializationObject.size = this._size;\n        serializationObject.coordinatesMode = this.coordinatesMode;\n        serializationObject.useInGammaSpace = this.gammaSpace;\n        serializationObject.generateHarmonics = this._generateHarmonics;\n        serializationObject.customType = \"BABYLON.HDRCubeTexture\";\n        serializationObject.noMipmap = this._noMipmap;\n        serializationObject.isBlocking = this._isBlocking;\n        serializationObject.rotationY = this._rotationY;\n        return serializationObject;\n    }\n}\nHDRCubeTexture._FacesMapping = [\"right\", \"left\", \"up\", \"down\", \"front\", \"back\"];\nRegisterClass(\"BABYLON.HDRCubeTexture\", HDRCubeTexture);\n//# sourceMappingURL=hdrCubeTexture.js.map","import { Matrix } from \"../../Maths/math.vector.js\";\nimport { BaseTexture } from \"../../Materials/Textures/baseTexture.js\";\n\nimport { RegisterClass } from \"../../Misc/typeStore.js\";\n// Ensures Raw texture are included\nimport \"../../Engines/Extensions/engine.rawTexture.js\";\n/**\n * This represents a color grading texture. This acts as a lookup table LUT, useful during post process\n * It can help converting any input color in a desired output one. This can then be used to create effects\n * from sepia, black and white to sixties or futuristic rendering...\n *\n * The only supported format is currently 3dl.\n * More information on LUT: https://en.wikipedia.org/wiki/3D_lookup_table\n */\nexport class ColorGradingTexture extends BaseTexture {\n    /**\n     * Instantiates a ColorGradingTexture from the following parameters.\n     *\n     * @param url The location of the color grading data (currently only supporting 3dl)\n     * @param sceneOrEngine The scene or engine the texture will be used in\n     * @param onLoad defines a callback triggered when the texture has been loaded\n     */\n    constructor(url, sceneOrEngine, onLoad = null) {\n        super(sceneOrEngine);\n        if (!url) {\n            return;\n        }\n        this._textureMatrix = Matrix.Identity();\n        this.name = url;\n        this.url = url;\n        this._onLoad = onLoad;\n        this._texture = this._getFromCache(url, true);\n        if (!this._texture) {\n            const scene = this.getScene();\n            if (scene) {\n                if (!scene.useDelayedTextureLoading) {\n                    this._loadTexture();\n                }\n                else {\n                    this.delayLoadState = 4;\n                }\n            }\n            else {\n                this._loadTexture();\n            }\n        }\n        else {\n            this._triggerOnLoad();\n        }\n    }\n    /**\n     * Fires the onload event from the constructor if requested.\n     */\n    _triggerOnLoad() {\n        if (this._onLoad) {\n            this._onLoad();\n        }\n    }\n    /**\n     * Returns the texture matrix used in most of the material.\n     * This is not used in color grading but keep for troubleshooting purpose (easily swap diffuse by colorgrading to look in).\n     */\n    getTextureMatrix() {\n        return this._textureMatrix;\n    }\n    /**\n     * Occurs when the file being loaded is a .3dl LUT file.\n     */\n    _load3dlTexture() {\n        const engine = this._getEngine();\n        let texture;\n        if (!engine._features.support3DTextures) {\n            texture = engine.createRawTexture(null, 1, 1, 5, false, false, 2, null, 0);\n        }\n        else {\n            texture = engine.createRawTexture3D(null, 1, 1, 1, 5, false, false, 2, null, 0);\n        }\n        this._texture = texture;\n        this._texture.isReady = false;\n        this.isCube = false;\n        this.is3D = engine._features.support3DTextures;\n        this.wrapU = 0;\n        this.wrapV = 0;\n        this.wrapR = 0;\n        this.anisotropicFilteringLevel = 1;\n        const callback = (text) => {\n            if (typeof text !== \"string\") {\n                return;\n            }\n            let data = null;\n            let tempData = null;\n            let line;\n            const lines = text.split(\"\\n\");\n            let size = 0, pixelIndexW = 0, pixelIndexH = 0, pixelIndexSlice = 0;\n            let maxColor = 0;\n            for (let i = 0; i < lines.length; i++) {\n                line = lines[i];\n                if (!ColorGradingTexture._NoneEmptyLineRegex.test(line)) {\n                    continue;\n                }\n                if (line.indexOf(\"#\") === 0) {\n                    continue;\n                }\n                const words = line.split(\" \");\n                if (size === 0) {\n                    // Number of space + one\n                    size = words.length;\n                    data = new Uint8Array(size * size * size * 4); // volume texture of side size and rgb 8\n                    tempData = new Float32Array(size * size * size * 4);\n                    continue;\n                }\n                if (size != 0) {\n                    const r = Math.max(parseInt(words[0]), 0);\n                    const g = Math.max(parseInt(words[1]), 0);\n                    const b = Math.max(parseInt(words[2]), 0);\n                    maxColor = Math.max(r, maxColor);\n                    maxColor = Math.max(g, maxColor);\n                    maxColor = Math.max(b, maxColor);\n                    const pixelStorageIndex = (pixelIndexW + pixelIndexSlice * size + pixelIndexH * size * size) * 4;\n                    if (tempData) {\n                        tempData[pixelStorageIndex + 0] = r;\n                        tempData[pixelStorageIndex + 1] = g;\n                        tempData[pixelStorageIndex + 2] = b;\n                    }\n                    // Keep for reference in case of back compat problems.\n                    // pixelIndexSlice++;\n                    // if (pixelIndexSlice % size == 0) {\n                    //     pixelIndexH++;\n                    //     pixelIndexSlice = 0;\n                    //     if (pixelIndexH % size == 0) {\n                    //         pixelIndexW++;\n                    //         pixelIndexH = 0;\n                    //     }\n                    // }\n                    pixelIndexH++;\n                    if (pixelIndexH % size == 0) {\n                        pixelIndexSlice++;\n                        pixelIndexH = 0;\n                        if (pixelIndexSlice % size == 0) {\n                            pixelIndexW++;\n                            pixelIndexSlice = 0;\n                        }\n                    }\n                }\n            }\n            if (tempData && data) {\n                for (let i = 0; i < tempData.length; i++) {\n                    if (i > 0 && (i + 1) % 4 === 0) {\n                        data[i] = 255;\n                    }\n                    else {\n                        const value = tempData[i];\n                        data[i] = (value / maxColor) * 255;\n                    }\n                }\n            }\n            if (texture.is3D) {\n                texture.updateSize(size, size, size);\n                engine.updateRawTexture3D(texture, data, 5, false);\n            }\n            else {\n                texture.updateSize(size * size, size);\n                engine.updateRawTexture(texture, data, 5, false);\n            }\n            texture.isReady = true;\n            this._triggerOnLoad();\n        };\n        const scene = this.getScene();\n        if (scene) {\n            scene._loadFile(this.url, callback);\n        }\n        else {\n            engine._loadFile(this.url, callback);\n        }\n        return this._texture;\n    }\n    /**\n     * Starts the loading process of the texture.\n     */\n    _loadTexture() {\n        if (this.url && this.url.toLocaleLowerCase().indexOf(\".3dl\") == this.url.length - 4) {\n            this._load3dlTexture();\n        }\n    }\n    /**\n     * Clones the color grading texture.\n     */\n    clone() {\n        const newTexture = new ColorGradingTexture(this.url, this.getScene() || this._getEngine());\n        // Base texture\n        newTexture.level = this.level;\n        return newTexture;\n    }\n    /**\n     * Called during delayed load for textures.\n     */\n    delayLoad() {\n        if (this.delayLoadState !== 4) {\n            return;\n        }\n        this.delayLoadState = 1;\n        this._texture = this._getFromCache(this.url, true);\n        if (!this._texture) {\n            this._loadTexture();\n        }\n    }\n    /**\n     * Parses a color grading texture serialized by Babylon.\n     * @param parsedTexture The texture information being parsedTexture\n     * @param scene The scene to load the texture in\n     * @returns A color grading texture\n     */\n    static Parse(parsedTexture, scene) {\n        let texture = null;\n        if (parsedTexture.name && !parsedTexture.isRenderTarget) {\n            texture = new ColorGradingTexture(parsedTexture.name, scene);\n            texture.name = parsedTexture.name;\n            texture.level = parsedTexture.level;\n        }\n        return texture;\n    }\n    /**\n     * Serializes the LUT texture to json format.\n     */\n    serialize() {\n        if (!this.name) {\n            return null;\n        }\n        const serializationObject = {};\n        serializationObject.name = this.name;\n        serializationObject.level = this.level;\n        serializationObject.customType = \"BABYLON.ColorGradingTexture\";\n        return serializationObject;\n    }\n}\n/**\n * Empty line regex stored for GC.\n */\nColorGradingTexture._NoneEmptyLineRegex = /\\S+/;\nRegisterClass(\"BABYLON.ColorGradingTexture\", ColorGradingTexture);\n//# sourceMappingURL=colorGradingTexture.js.map","import { BaseTexture } from \"../../Materials/Textures/baseTexture.js\";\n\nimport { Matrix } from \"../../Maths/math.vector.js\";\nimport { Observable } from \"../../Misc/observable.js\";\nimport \"../../Engines/Extensions/engine.dynamicTexture.js\";\nimport \"../../Engines/Extensions/engine.videoTexture.js\";\n/**\n * This represents the smallest workload to use an already existing element (Canvas or Video) as a texture.\n * To be as efficient as possible depending on your constraints nothing aside the first upload\n * is automatically managed.\n * It is a cheap VideoTexture or DynamicTexture if you prefer to keep full control of the elements\n * in your application.\n *\n * As the update is not automatic, you need to call them manually.\n */\nexport class HtmlElementTexture extends BaseTexture {\n    /**\n     * Instantiates a HtmlElementTexture from the following parameters.\n     *\n     * @param name Defines the name of the texture\n     * @param element Defines the video or canvas the texture is filled with\n     * @param options Defines the other none mandatory texture creation options\n     */\n    constructor(name, element, options) {\n        var _a, _b;\n        super(options.scene || options.engine);\n        /**\n         * Observable triggered once the texture has been loaded.\n         */\n        this.onLoadObservable = new Observable();\n        if (!element || (!options.engine && !options.scene)) {\n            return;\n        }\n        options = {\n            ...HtmlElementTexture._DefaultOptions,\n            ...options,\n        };\n        this._generateMipMaps = options.generateMipMaps;\n        this._samplingMode = options.samplingMode;\n        this._textureMatrix = Matrix.Identity();\n        this._format = options.format;\n        this.name = name;\n        this.element = element;\n        this._isVideo = !!element.getVideoPlaybackQuality;\n        this._externalTexture = this._isVideo ? (_b = (_a = this._engine) === null || _a === void 0 ? void 0 : _a.createExternalTexture(element)) !== null && _b !== void 0 ? _b : null : null;\n        this.anisotropicFilteringLevel = 1;\n        this._createInternalTexture();\n    }\n    _createInternalTexture() {\n        let width = 0;\n        let height = 0;\n        if (this._isVideo) {\n            width = this.element.videoWidth;\n            height = this.element.videoHeight;\n        }\n        else {\n            width = this.element.width;\n            height = this.element.height;\n        }\n        const engine = this._getEngine();\n        if (engine) {\n            this._texture = engine.createDynamicTexture(width, height, this._generateMipMaps, this._samplingMode);\n            this._texture.format = this._format;\n        }\n        this.update();\n    }\n    /**\n     * Returns the texture matrix used in most of the material.\n     */\n    getTextureMatrix() {\n        return this._textureMatrix;\n    }\n    /**\n     * Updates the content of the texture.\n     * @param invertY Defines whether the texture should be inverted on Y (false by default on video and true on canvas)\n     */\n    update(invertY = null) {\n        const engine = this._getEngine();\n        if (this._texture == null || engine == null) {\n            return;\n        }\n        const wasReady = this.isReady();\n        if (this._isVideo) {\n            const videoElement = this.element;\n            if (videoElement.readyState < videoElement.HAVE_CURRENT_DATA) {\n                return;\n            }\n            engine.updateVideoTexture(this._texture, this._externalTexture ? this._externalTexture : videoElement, invertY === null ? true : invertY);\n        }\n        else {\n            const canvasElement = this.element;\n            engine.updateDynamicTexture(this._texture, canvasElement, invertY === null ? true : invertY, false, this._format);\n        }\n        if (!wasReady && this.isReady()) {\n            this.onLoadObservable.notifyObservers(this);\n        }\n    }\n    /**\n     * Dispose the texture and release its associated resources.\n     */\n    dispose() {\n        this.onLoadObservable.clear();\n        super.dispose();\n    }\n}\nHtmlElementTexture._DefaultOptions = {\n    generateMipMaps: false,\n    samplingMode: 2,\n    format: 5,\n    engine: null,\n    scene: null,\n};\n//# sourceMappingURL=htmlElementTexture.js.map","import { GetTGAHeader, UploadContent } from \"../../../Misc/tga.js\";\nimport { Engine } from \"../../../Engines/engine.js\";\n/**\n * Implementation of the TGA Texture Loader.\n * @internal\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport class _TGATextureLoader {\n    constructor() {\n        /**\n         * Defines whether the loader supports cascade loading the different faces.\n         */\n        this.supportCascades = false;\n    }\n    /**\n     * This returns if the loader support the current file information.\n     * @param extension defines the file extension of the file being loaded\n     * @returns true if the loader can load the specified file\n     */\n    canLoad(extension) {\n        return extension.endsWith(\".tga\");\n    }\n    /**\n     * Uploads the cube texture data to the WebGL texture. It has already been bound.\n     */\n    loadCubeData() {\n        throw \".env not supported in Cube.\";\n    }\n    /**\n     * Uploads the 2D texture data to the WebGL texture. It has already been bound once in the callback.\n     * @param data contains the texture data\n     * @param texture defines the BabylonJS internal texture\n     * @param callback defines the method to call once ready to upload\n     */\n    loadData(data, texture, callback) {\n        const bytes = new Uint8Array(data.buffer, data.byteOffset, data.byteLength);\n        const header = GetTGAHeader(bytes);\n        callback(header.width, header.height, texture.generateMipMaps, false, () => {\n            UploadContent(texture, bytes);\n        });\n    }\n}\n// Register the loader.\nEngine._TextureLoaders.push(new _TGATextureLoader());\n//# sourceMappingURL=tgaTextureLoader.js.map","import { HDRTools } from \"../../../Misc/HighDynamicRange/hdr.js\";\nimport { Engine } from \"../../../Engines/engine.js\";\n\n/**\n * Implementation of the HDR Texture Loader.\n * @internal\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport class _HDRTextureLoader {\n    constructor() {\n        /**\n         * Defines whether the loader supports cascade loading the different faces.\n         */\n        this.supportCascades = false;\n    }\n    /**\n     * This returns if the loader support the current file information.\n     * @param extension defines the file extension of the file being loaded\n     * @returns true if the loader can load the specified file\n     */\n    canLoad(extension) {\n        return extension.endsWith(\".hdr\");\n    }\n    /**\n     * Uploads the cube texture data to the WebGL texture. It has already been bound.\n     */\n    loadCubeData() {\n        throw \".env not supported in Cube.\";\n    }\n    /**\n     * Uploads the 2D texture data to the WebGL texture. It has already been bound once in the callback.\n     * @param data contains the texture data\n     * @param texture defines the BabylonJS internal texture\n     * @param callback defines the method to call once ready to upload\n     */\n    loadData(data, texture, callback) {\n        const uint8array = new Uint8Array(data.buffer, data.byteOffset, data.byteLength);\n        const hdrInfo = HDRTools.RGBE_ReadHeader(uint8array);\n        const pixelsDataRGB32 = HDRTools.RGBE_ReadPixels(uint8array, hdrInfo);\n        const pixels = hdrInfo.width * hdrInfo.height;\n        const pixelsDataRGBA32 = new Float32Array(pixels * 4);\n        for (let i = 0; i < pixels; i += 1) {\n            pixelsDataRGBA32[i * 4] = pixelsDataRGB32[i * 3];\n            pixelsDataRGBA32[i * 4 + 1] = pixelsDataRGB32[i * 3 + 1];\n            pixelsDataRGBA32[i * 4 + 2] = pixelsDataRGB32[i * 3 + 2];\n            pixelsDataRGBA32[i * 4 + 3] = 1;\n        }\n        callback(hdrInfo.width, hdrInfo.height, texture.generateMipMaps, false, () => {\n            const engine = texture.getEngine();\n            texture.type = 1;\n            texture.format = 5;\n            texture._gammaSpace = false;\n            engine._uploadDataToTextureDirectly(texture, pixelsDataRGBA32);\n        });\n    }\n}\n// Register the loader.\nEngine._TextureLoaders.push(new _HDRTextureLoader());\n//# sourceMappingURL=hdrTextureLoader.js.map","import { Engine } from \"../../../Engines/engine.js\";\nimport { LoadTextureFromTranscodeResult, TranscodeAsync } from \"../../../Misc/basis.js\";\nimport { Tools } from \"../../../Misc/tools.js\";\n/**\n * Loader for .basis file format\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport class _BasisTextureLoader {\n    constructor() {\n        /**\n         * Defines whether the loader supports cascade loading the different faces.\n         */\n        this.supportCascades = false;\n    }\n    /**\n     * This returns if the loader support the current file information.\n     * @param extension defines the file extension of the file being loaded\n     * @returns true if the loader can load the specified file\n     */\n    canLoad(extension) {\n        return extension.endsWith(\".basis\");\n    }\n    /**\n     * Uploads the cube texture data to the WebGL texture. It has already been bound.\n     * @param data contains the texture data\n     * @param texture defines the BabylonJS internal texture\n     * @param createPolynomials will be true if polynomials have been requested\n     * @param onLoad defines the callback to trigger once the texture is ready\n     * @param onError defines the callback to trigger in case of error\n     */\n    loadCubeData(data, texture, createPolynomials, onLoad, onError) {\n        if (Array.isArray(data)) {\n            return;\n        }\n        const caps = texture.getEngine().getCaps();\n        const transcodeConfig = {\n            supportedCompressionFormats: {\n                etc1: caps.etc1 ? true : false,\n                s3tc: caps.s3tc ? true : false,\n                pvrtc: caps.pvrtc ? true : false,\n                etc2: caps.etc2 ? true : false,\n                astc: caps.astc ? true : false,\n                bc7: caps.bptc ? true : false,\n            },\n        };\n        TranscodeAsync(data, transcodeConfig)\n            .then((result) => {\n            const hasMipmap = result.fileInfo.images[0].levels.length > 1 && texture.generateMipMaps;\n            LoadTextureFromTranscodeResult(texture, result);\n            texture.getEngine()._setCubeMapTextureParams(texture, hasMipmap);\n            texture.isReady = true;\n            texture.onLoadedObservable.notifyObservers(texture);\n            texture.onLoadedObservable.clear();\n            if (onLoad) {\n                onLoad();\n            }\n        })\n            .catch((err) => {\n            const errorMessage = \"Failed to transcode Basis file, transcoding may not be supported on this device\";\n            Tools.Warn(errorMessage);\n            texture.isReady = true;\n            if (onError) {\n                onError(err);\n            }\n        });\n    }\n    /**\n     * Uploads the 2D texture data to the WebGL texture. It has already been bound once in the callback.\n     * @param data contains the texture data\n     * @param texture defines the BabylonJS internal texture\n     * @param callback defines the method to call once ready to upload\n     */\n    loadData(data, texture, callback) {\n        const caps = texture.getEngine().getCaps();\n        const transcodeConfig = {\n            supportedCompressionFormats: {\n                etc1: caps.etc1 ? true : false,\n                s3tc: caps.s3tc ? true : false,\n                pvrtc: caps.pvrtc ? true : false,\n                etc2: caps.etc2 ? true : false,\n                astc: caps.astc ? true : false,\n                bc7: caps.bptc ? true : false,\n            },\n        };\n        TranscodeAsync(data, transcodeConfig)\n            .then((result) => {\n            const rootImage = result.fileInfo.images[0].levels[0];\n            const hasMipmap = result.fileInfo.images[0].levels.length > 1 && texture.generateMipMaps;\n            callback(rootImage.width, rootImage.height, hasMipmap, result.format !== -1, () => {\n                LoadTextureFromTranscodeResult(texture, result);\n            });\n        })\n            .catch((err) => {\n            Tools.Warn(\"Failed to transcode Basis file, transcoding may not be supported on this device\");\n            Tools.Warn(`Failed to transcode Basis file: ${err}`);\n            callback(0, 0, false, false, () => { }, true);\n        });\n    }\n}\n// Register the loader.\nEngine._TextureLoaders.push(new _BasisTextureLoader());\n//# sourceMappingURL=basisTextureLoader.js.map","/**\n * This is a support class for frame Data on texture packer sets.\n */\nexport class TexturePackerFrame {\n    /**\n     * Initializes a texture package frame.\n     * @param id The numerical frame identifier\n     * @param scale Scalar Vector2 for UV frame\n     * @param offset Vector2 for the frame position in UV units.\n     * @returns TexturePackerFrame\n     */\n    constructor(id, scale, offset) {\n        this.id = id;\n        this.scale = scale;\n        this.offset = offset;\n    }\n}\n//# sourceMappingURL=frame.js.map","import { Engine } from \"../../../Engines/engine.js\";\nimport { VertexBuffer } from \"../../../Buffers/buffer.js\";\nimport { Texture } from \"../texture.js\";\nimport { DynamicTexture } from \"../dynamicTexture.js\";\nimport { Vector2 } from \"../../../Maths/math.vector.js\";\nimport { Color3, Color4 } from \"../../../Maths/math.color.js\";\nimport { TexturePackerFrame } from \"./frame.js\";\nimport { Logger } from \"../../../Misc/logger.js\";\nimport { Tools } from \"../../../Misc/tools.js\";\n/**\n * This is a support class that generates a series of packed texture sets.\n * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/materials_introduction\n */\nexport class TexturePacker {\n    /**\n     * Initializes a texture package series from an array of meshes or a single mesh.\n     * @param name The name of the package\n     * @param meshes The target meshes to compose the package from\n     * @param options The arguments that texture packer should follow while building.\n     * @param scene The scene which the textures are scoped to.\n     * @returns TexturePacker\n     */\n    constructor(name, meshes, options, scene) {\n        var _b, _c, _d, _e, _g, _h, _j, _k, _l, _m, _o, _p, _q;\n        this.name = name;\n        this.meshes = meshes;\n        this.scene = scene;\n        /**\n         * Run through the options and set what ever defaults are needed that where not declared.\n         */\n        this.options = options;\n        this.options.map = (_b = this.options.map) !== null && _b !== void 0 ? _b : [\n            \"ambientTexture\",\n            \"bumpTexture\",\n            \"diffuseTexture\",\n            \"emissiveTexture\",\n            \"lightmapTexture\",\n            \"opacityTexture\",\n            \"reflectionTexture\",\n            \"refractionTexture\",\n            \"specularTexture\",\n        ];\n        this.options.uvsIn = (_c = this.options.uvsIn) !== null && _c !== void 0 ? _c : VertexBuffer.UVKind;\n        this.options.uvsOut = (_d = this.options.uvsOut) !== null && _d !== void 0 ? _d : VertexBuffer.UVKind;\n        this.options.layout = (_e = this.options.layout) !== null && _e !== void 0 ? _e : TexturePacker.LAYOUT_STRIP;\n        if (this.options.layout === TexturePacker.LAYOUT_COLNUM) {\n            this.options.colnum = (_g = this.options.colnum) !== null && _g !== void 0 ? _g : 8;\n        }\n        this.options.updateInputMeshes = (_h = this.options.updateInputMeshes) !== null && _h !== void 0 ? _h : true;\n        this.options.disposeSources = (_j = this.options.disposeSources) !== null && _j !== void 0 ? _j : true;\n        this._expecting = 0;\n        this.options.fillBlanks = (_k = this.options.fillBlanks) !== null && _k !== void 0 ? _k : true;\n        if (this.options.fillBlanks === true) {\n            this.options.customFillColor = (_l = this.options.customFillColor) !== null && _l !== void 0 ? _l : \"black\";\n        }\n        this.options.frameSize = (_m = this.options.frameSize) !== null && _m !== void 0 ? _m : 256;\n        this.options.paddingRatio = (_o = this.options.paddingRatio) !== null && _o !== void 0 ? _o : 0.0115;\n        this._paddingValue = Math.ceil(this.options.frameSize * this.options.paddingRatio);\n        //Make it an even padding Number.\n        if (this._paddingValue % 2 !== 0) {\n            this._paddingValue++;\n        }\n        this.options.paddingMode = (_p = this.options.paddingMode) !== null && _p !== void 0 ? _p : TexturePacker.SUBUV_WRAP;\n        if (this.options.paddingMode === TexturePacker.SUBUV_COLOR) {\n            this.options.paddingColor = (_q = this.options.paddingColor) !== null && _q !== void 0 ? _q : new Color4(0, 0, 0, 1.0);\n        }\n        this.sets = {};\n        this.frames = [];\n        return this;\n    }\n    /**\n     * Starts the package process\n     * @param resolve The promises resolution function\n     * @returns TexturePacker\n     */\n    _createFrames(resolve) {\n        const dtSize = this._calculateSize();\n        const dtUnits = new Vector2(1, 1).divide(dtSize);\n        let doneCount = 0;\n        const expecting = this._expecting;\n        const meshLength = this.meshes.length;\n        const sKeys = Object.keys(this.sets);\n        for (let i = 0; i < sKeys.length; i++) {\n            const setName = sKeys[i];\n            const dt = new DynamicTexture(this.name + \".TexturePack.\" + setName + \"Set\", { width: dtSize.x, height: dtSize.y }, this.scene, true, //Generate Mips\n            Texture.TRILINEAR_SAMPLINGMODE, Engine.TEXTUREFORMAT_RGBA);\n            const dtx = dt.getContext();\n            dtx.fillStyle = \"rgba(0,0,0,0)\";\n            dtx.fillRect(0, 0, dtSize.x, dtSize.y);\n            dt.update(false);\n            this.sets[setName] = dt;\n        }\n        const baseSize = this.options.frameSize || 256;\n        const padding = this._paddingValue;\n        const tcs = baseSize + 2 * padding;\n        const done = () => {\n            this._calculateMeshUVFrames(baseSize, padding, dtSize, dtUnits, this.options.updateInputMeshes || false);\n        };\n        //Update the Textures\n        for (let i = 0; i < meshLength; i++) {\n            const m = this.meshes[i];\n            const mat = m.material;\n            //Check if the material has the texture\n            //Create a temporary canvas the same size as 1 frame\n            //Then apply the texture to the center and the 8 offsets\n            //Copy the Context and place in the correct frame on the DT\n            for (let j = 0; j < sKeys.length; j++) {\n                const tempTexture = new DynamicTexture(\"temp\", tcs, this.scene, true);\n                const tcx = tempTexture.getContext();\n                const offset = this._getFrameOffset(i);\n                const updateDt = () => {\n                    doneCount++;\n                    tempTexture.update(false);\n                    const iDat = tcx.getImageData(0, 0, tcs, tcs);\n                    //Update Set\n                    const dt = this.sets[setName];\n                    const dtx = dt.getContext();\n                    dtx.putImageData(iDat, dtSize.x * offset.x, dtSize.y * offset.y);\n                    tempTexture.dispose();\n                    dt.update(false);\n                    if (doneCount == expecting) {\n                        done();\n                        resolve();\n                        return;\n                    }\n                };\n                const setName = sKeys[j] || \"_blank\";\n                if (!mat || mat[setName] === null) {\n                    tcx.fillStyle = \"rgba(0,0,0,0)\";\n                    if (this.options.fillBlanks) {\n                        tcx.fillStyle = this.options.customFillColor;\n                    }\n                    tcx.fillRect(0, 0, tcs, tcs);\n                    updateDt();\n                }\n                else {\n                    const setTexture = mat[setName];\n                    const img = new Image();\n                    if (setTexture instanceof DynamicTexture) {\n                        img.src = setTexture.getContext().canvas.toDataURL(\"image/png\");\n                    }\n                    else {\n                        img.src = setTexture.url;\n                    }\n                    Tools.SetCorsBehavior(img.src, img);\n                    img.onload = () => {\n                        tcx.fillStyle = \"rgba(0,0,0,0)\";\n                        tcx.fillRect(0, 0, tcs, tcs);\n                        tempTexture.update(false);\n                        tcx.setTransform(1, 0, 0, -1, 0, 0);\n                        const cellOffsets = [0, 0, 1, 0, 1, 1, 0, 1, -1, 1, -1, 0, -1 - 1, 0, -1, 1, -1];\n                        switch (this.options.paddingMode) {\n                            //Wrap Mode\n                            case 0:\n                                for (let i = 0; i < 9; i++) {\n                                    tcx.drawImage(img, 0, 0, img.width, img.height, padding + baseSize * cellOffsets[i], padding + baseSize * cellOffsets[i + 1] - tcs, baseSize, baseSize);\n                                }\n                                break;\n                            //Extend Mode\n                            case 1:\n                                for (let i = 0; i < padding; i++) {\n                                    tcx.drawImage(img, 0, 0, img.width, img.height, i + baseSize * cellOffsets[0], padding - tcs, baseSize, baseSize);\n                                    tcx.drawImage(img, 0, 0, img.width, img.height, padding * 2 - i, padding - tcs, baseSize, baseSize);\n                                    tcx.drawImage(img, 0, 0, img.width, img.height, padding, i - tcs, baseSize, baseSize);\n                                    tcx.drawImage(img, 0, 0, img.width, img.height, padding, padding * 2 - i - tcs, baseSize, baseSize);\n                                }\n                                tcx.drawImage(img, 0, 0, img.width, img.height, padding + baseSize * cellOffsets[0], padding + baseSize * cellOffsets[1] - tcs, baseSize, baseSize);\n                                break;\n                            //Color Mode\n                            case 2:\n                                tcx.fillStyle = (this.options.paddingColor || Color3.Black()).toHexString();\n                                tcx.fillRect(0, 0, tcs, -tcs);\n                                tcx.clearRect(padding, padding, baseSize, baseSize);\n                                tcx.drawImage(img, 0, 0, img.width, img.height, padding + baseSize * cellOffsets[0], padding + baseSize * cellOffsets[1] - tcs, baseSize, baseSize);\n                                break;\n                        }\n                        tcx.setTransform(1, 0, 0, 1, 0, 0);\n                        updateDt();\n                    };\n                }\n            }\n        }\n    }\n    /**\n     * Calculates the Size of the Channel Sets\n     * @returns Vector2\n     */\n    _calculateSize() {\n        const meshLength = this.meshes.length || 0;\n        const baseSize = this.options.frameSize || 0;\n        const padding = this._paddingValue || 0;\n        switch (this.options.layout) {\n            case 0: {\n                //STRIP_LAYOUT\n                return new Vector2(baseSize * meshLength + 2 * padding * meshLength, baseSize + 2 * padding);\n            }\n            case 1: {\n                //POWER2\n                const sqrtCount = Math.max(2, Math.ceil(Math.sqrt(meshLength)));\n                const size = baseSize * sqrtCount + 2 * padding * sqrtCount;\n                return new Vector2(size, size);\n            }\n            case 2: {\n                //COLNUM\n                const cols = this.options.colnum || 1;\n                const rowCnt = Math.max(1, Math.ceil(meshLength / cols));\n                return new Vector2(baseSize * cols + 2 * padding * cols, baseSize * rowCnt + 2 * padding * rowCnt);\n            }\n        }\n        return Vector2.Zero();\n    }\n    /**\n     * Calculates the UV data for the frames.\n     * @param baseSize the base frameSize\n     * @param padding the base frame padding\n     * @param dtSize size of the Dynamic Texture for that channel\n     * @param dtUnits is 1/dtSize\n     * @param update flag to update the input meshes\n     */\n    _calculateMeshUVFrames(baseSize, padding, dtSize, dtUnits, update) {\n        const meshLength = this.meshes.length;\n        for (let i = 0; i < meshLength; i++) {\n            const m = this.meshes[i];\n            const scale = new Vector2(baseSize / dtSize.x, baseSize / dtSize.y);\n            const pOffset = dtUnits.clone().scale(padding);\n            const frameOffset = this._getFrameOffset(i);\n            const offset = frameOffset.add(pOffset);\n            const frame = new TexturePackerFrame(i, scale, offset);\n            this.frames.push(frame);\n            //Update Output UVs\n            if (update) {\n                this._updateMeshUV(m, i);\n                this._updateTextureReferences(m);\n            }\n        }\n    }\n    /**\n     * Calculates the frames Offset.\n     * @param index of the frame\n     * @returns Vector2\n     */\n    _getFrameOffset(index) {\n        const meshLength = this.meshes.length;\n        let uvStep, yStep, xStep;\n        switch (this.options.layout) {\n            case 0: {\n                //STRIP_LAYOUT\n                uvStep = 1 / meshLength;\n                return new Vector2(index * uvStep, 0);\n            }\n            case 1: {\n                //POWER2\n                const sqrtCount = Math.max(2, Math.ceil(Math.sqrt(meshLength)));\n                yStep = Math.floor(index / sqrtCount);\n                xStep = index - yStep * sqrtCount;\n                uvStep = 1 / sqrtCount;\n                return new Vector2(xStep * uvStep, yStep * uvStep);\n            }\n            case 2: {\n                //COLNUM\n                const cols = this.options.colnum || 1;\n                const rowCnt = Math.max(1, Math.ceil(meshLength / cols));\n                xStep = Math.floor(index / rowCnt);\n                yStep = index - xStep * rowCnt;\n                uvStep = new Vector2(1 / cols, 1 / rowCnt);\n                return new Vector2(xStep * uvStep.x, yStep * uvStep.y);\n            }\n        }\n        return Vector2.Zero();\n    }\n    /**\n     * Updates a Mesh to the frame data\n     * @param mesh that is the target\n     * @param frameID or the frame index\n     */\n    _updateMeshUV(mesh, frameID) {\n        const frame = this.frames[frameID];\n        const uvIn = mesh.getVerticesData(this.options.uvsIn || VertexBuffer.UVKind);\n        const uvOut = [];\n        let toCount = 0;\n        if (uvIn.length) {\n            toCount = uvIn.length || 0;\n        }\n        for (let i = 0; i < toCount; i += 2) {\n            uvOut.push(uvIn[i] * frame.scale.x + frame.offset.x, uvIn[i + 1] * frame.scale.y + frame.offset.y);\n        }\n        mesh.setVerticesData(this.options.uvsOut || VertexBuffer.UVKind, uvOut);\n    }\n    /**\n     * Updates a Meshes materials to use the texture packer channels\n     * @param m is the mesh to target\n     * @param force all channels on the packer to be set.\n     */\n    _updateTextureReferences(m, force = false) {\n        const mat = m.material;\n        const sKeys = Object.keys(this.sets);\n        const _dispose = (_t) => {\n            if (_t.dispose) {\n                _t.dispose();\n            }\n        };\n        for (let i = 0; i < sKeys.length; i++) {\n            const setName = sKeys[i];\n            if (!force) {\n                if (!mat) {\n                    return;\n                }\n                if (mat[setName] !== null) {\n                    _dispose(mat[setName]);\n                    mat[setName] = this.sets[setName];\n                }\n            }\n            else {\n                if (mat[setName] !== null) {\n                    _dispose(mat[setName]);\n                }\n                mat[setName] = this.sets[setName];\n            }\n        }\n    }\n    /**\n     * Public method to set a Mesh to a frame\n     * @param m that is the target\n     * @param frameID or the frame index\n     * @param updateMaterial trigger for if the Meshes attached Material be updated?\n     */\n    setMeshToFrame(m, frameID, updateMaterial = false) {\n        this._updateMeshUV(m, frameID);\n        if (updateMaterial) {\n            this._updateTextureReferences(m, true);\n        }\n    }\n    /**\n     * Starts the async promise to compile the texture packer.\n     * @returns Promise<void>\n     */\n    processAsync() {\n        return new Promise((resolve, reject) => {\n            try {\n                if (this.meshes.length === 0) {\n                    //Must be a JSON load!\n                    resolve();\n                    return;\n                }\n                let done = 0;\n                const doneCheck = (mat) => {\n                    done++;\n                    //Check Status of all Textures on all meshes, till they are ready.\n                    if (this.options.map) {\n                        for (let j = 0; j < this.options.map.length; j++) {\n                            const index = this.options.map[j];\n                            const t = mat[index];\n                            if (t !== null) {\n                                if (!this.sets[this.options.map[j]]) {\n                                    this.sets[this.options.map[j]] = true;\n                                }\n                                this._expecting++;\n                            }\n                        }\n                        if (done === this.meshes.length) {\n                            this._createFrames(resolve);\n                        }\n                    }\n                };\n                for (let i = 0; i < this.meshes.length; i++) {\n                    const mesh = this.meshes[i];\n                    const material = mesh.material;\n                    if (!material) {\n                        done++;\n                        if (done === this.meshes.length) {\n                            return this._createFrames(resolve);\n                        }\n                        continue;\n                    }\n                    material.forceCompilationAsync(mesh).then(() => {\n                        doneCheck(material);\n                    });\n                }\n            }\n            catch (e) {\n                return reject(e);\n            }\n        });\n    }\n    /**\n     * Disposes all textures associated with this packer\n     */\n    dispose() {\n        const sKeys = Object.keys(this.sets);\n        for (let i = 0; i < sKeys.length; i++) {\n            const channel = sKeys[i];\n            this.sets[channel].dispose();\n        }\n    }\n    /**\n     * Starts the download process for all the channels converting them to base64 data and embedding it all in a JSON file.\n     * @param imageType is the image type to use.\n     * @param quality of the image if downloading as jpeg, Ranges from >0 to 1.\n     */\n    download(imageType = \"png\", quality = 1) {\n        setTimeout(() => {\n            const pack = {\n                name: this.name,\n                sets: {},\n                options: {},\n                frames: [],\n            };\n            const sKeys = Object.keys(this.sets);\n            const oKeys = Object.keys(this.options);\n            try {\n                for (let i = 0; i < sKeys.length; i++) {\n                    const channel = sKeys[i];\n                    const dt = this.sets[channel];\n                    pack.sets[channel] = dt.getContext().canvas.toDataURL(\"image/\" + imageType, quality);\n                }\n                for (let i = 0; i < oKeys.length; i++) {\n                    const opt = oKeys[i];\n                    pack.options[opt] = this.options[opt];\n                }\n                for (let i = 0; i < this.frames.length; i++) {\n                    const _f = this.frames[i];\n                    pack.frames.push(_f.scale.x, _f.scale.y, _f.offset.x, _f.offset.y);\n                }\n            }\n            catch (err) {\n                Logger.Warn(\"Unable to download: \" + err);\n                return;\n            }\n            const data = \"data:text/json;charset=utf-8,\" + encodeURIComponent(JSON.stringify(pack, null, 4));\n            const _a = document.createElement(\"a\");\n            _a.setAttribute(\"href\", data);\n            _a.setAttribute(\"download\", this.name + \"_texurePackage.json\");\n            document.body.appendChild(_a);\n            _a.click();\n            _a.remove();\n        }, 0);\n    }\n    /**\n     * Public method to load a texturePacker JSON file.\n     * @param data of the JSON file in string format.\n     */\n    updateFromJSON(data) {\n        try {\n            const parsedData = JSON.parse(data);\n            this.name = parsedData.name;\n            const _options = Object.keys(parsedData.options);\n            for (let i = 0; i < _options.length; i++) {\n                this.options[_options[i]] = parsedData.options[_options[i]];\n            }\n            for (let i = 0; i < parsedData.frames.length; i += 4) {\n                const frame = new TexturePackerFrame(i / 4, new Vector2(parsedData.frames[i], parsedData.frames[i + 1]), new Vector2(parsedData.frames[i + 2], parsedData.frames[i + 3]));\n                this.frames.push(frame);\n            }\n            const channels = Object.keys(parsedData.sets);\n            for (let i = 0; i < channels.length; i++) {\n                const _t = new Texture(parsedData.sets[channels[i]], this.scene, false, false);\n                this.sets[channels[i]] = _t;\n            }\n        }\n        catch (err) {\n            Logger.Warn(\"Unable to update from JSON: \" + err);\n        }\n    }\n}\n/** Packer Layout Constant 0 */\nTexturePacker.LAYOUT_STRIP = 0;\n/** Packer Layout Constant 1 */\nTexturePacker.LAYOUT_POWER2 = 1;\n/** Packer Layout Constant 2 */\nTexturePacker.LAYOUT_COLNUM = 2;\n/** Packer Layout Constant 0 */\nTexturePacker.SUBUV_WRAP = 0;\n/** Packer Layout Constant 1 */\nTexturePacker.SUBUV_EXTEND = 1;\n/** Packer Layout Constant 2 */\nTexturePacker.SUBUV_COLOR = 2;\n//# sourceMappingURL=packer.js.map","import { EngineStore } from \"../../../Engines/engineStore.js\";\nimport { ProceduralTexture } from \"./proceduralTexture.js\";\nimport { RegisterClass } from \"../../../Misc/typeStore.js\";\nimport \"../../../Shaders/noise.fragment.js\";\n/**\n * Class used to generate noise procedural textures\n */\nexport class NoiseProceduralTexture extends ProceduralTexture {\n    /**\n     * Creates a new NoiseProceduralTexture\n     * @param name defines the name fo the texture\n     * @param size defines the size of the texture (default is 256)\n     * @param scene defines the hosting scene\n     * @param fallbackTexture defines the texture to use if the NoiseProceduralTexture can't be created\n     * @param generateMipMaps defines if mipmaps must be generated (true by default)\n     */\n    constructor(name, size = 256, scene = EngineStore.LastCreatedScene, fallbackTexture, generateMipMaps) {\n        super(name, size, \"noise\", scene, fallbackTexture, generateMipMaps);\n        /** Gets or sets the start time (default is 0) */\n        this.time = 0.0;\n        /** Gets or sets a value between 0 and 1 indicating the overall brightness of the texture (default is 0.2) */\n        this.brightness = 0.2;\n        /** Defines the number of octaves to process */\n        this.octaves = 3;\n        /** Defines the level of persistence (0.8 by default) */\n        this.persistence = 0.8;\n        /** Gets or sets animation speed factor (default is 1) */\n        this.animationSpeedFactor = 1;\n        this.autoClear = false;\n        this._updateShaderUniforms();\n    }\n    _updateShaderUniforms() {\n        const scene = this.getScene();\n        if (!scene) {\n            return;\n        }\n        this.time += scene.getAnimationRatio() * this.animationSpeedFactor * 0.01;\n        this.setFloat(\"brightness\", this.brightness);\n        this.setFloat(\"persistence\", this.persistence);\n        this.setFloat(\"timeScale\", this.time);\n    }\n    _getDefines() {\n        return \"#define OCTAVES \" + (this.octaves | 0);\n    }\n    /**\n     * Generate the current state of the procedural texture\n     * @param useCameraPostProcess\n     */\n    render(useCameraPostProcess) {\n        this._updateShaderUniforms();\n        super.render(useCameraPostProcess);\n    }\n    /**\n     * Serializes this noise procedural texture\n     * @returns a serialized noise procedural texture object\n     */\n    serialize() {\n        const serializationObject = {};\n        serializationObject.customType = \"BABYLON.NoiseProceduralTexture\";\n        serializationObject.brightness = this.brightness;\n        serializationObject.octaves = this.octaves;\n        serializationObject.persistence = this.persistence;\n        serializationObject.animationSpeedFactor = this.animationSpeedFactor;\n        serializationObject.size = this.getSize().width;\n        serializationObject.generateMipMaps = this._generateMipMaps;\n        serializationObject.time = this.time;\n        return serializationObject;\n    }\n    /**\n     * Clone the texture.\n     * @returns the cloned texture\n     */\n    clone() {\n        const textureSize = this.getSize();\n        const newTexture = new NoiseProceduralTexture(this.name, textureSize.width, this.getScene(), this._fallbackTexture ? this._fallbackTexture : undefined, this._generateMipMaps);\n        // Base texture\n        newTexture.hasAlpha = this.hasAlpha;\n        newTexture.level = this.level;\n        // RenderTarget Texture\n        newTexture.coordinatesMode = this.coordinatesMode;\n        // Noise Specifics\n        newTexture.brightness = this.brightness;\n        newTexture.octaves = this.octaves;\n        newTexture.persistence = this.persistence;\n        newTexture.animationSpeedFactor = this.animationSpeedFactor;\n        newTexture.time = this.time;\n        return newTexture;\n    }\n    /**\n     * Creates a NoiseProceduralTexture from parsed noise procedural texture data\n     * @param parsedTexture defines parsed texture data\n     * @param scene defines the current scene\n     * @returns a parsed NoiseProceduralTexture\n     */\n    static Parse(parsedTexture, scene) {\n        var _a;\n        const texture = new NoiseProceduralTexture(parsedTexture.name, parsedTexture.size, scene, undefined, parsedTexture.generateMipMaps);\n        texture.brightness = parsedTexture.brightness;\n        texture.octaves = parsedTexture.octaves;\n        texture.persistence = parsedTexture.persistence;\n        texture.animationSpeedFactor = parsedTexture.animationSpeedFactor;\n        texture.time = (_a = parsedTexture.time) !== null && _a !== void 0 ? _a : 0;\n        return texture;\n    }\n}\nRegisterClass(\"BABYLON.NoiseProceduralTexture\", NoiseProceduralTexture);\n//# sourceMappingURL=noiseProceduralTexture.js.map","import { Observable } from \"../../Misc/observable.js\";\nimport { TextureSampler } from \"./textureSampler.js\";\n/**\n * Defines the source of the internal texture\n */\nexport var InternalTextureSource;\n(function (InternalTextureSource) {\n    /**\n     * The source of the texture data is unknown\n     */\n    InternalTextureSource[InternalTextureSource[\"Unknown\"] = 0] = \"Unknown\";\n    /**\n     * Texture data comes from an URL\n     */\n    InternalTextureSource[InternalTextureSource[\"Url\"] = 1] = \"Url\";\n    /**\n     * Texture data is only used for temporary storage\n     */\n    InternalTextureSource[InternalTextureSource[\"Temp\"] = 2] = \"Temp\";\n    /**\n     * Texture data comes from raw data (ArrayBuffer)\n     */\n    InternalTextureSource[InternalTextureSource[\"Raw\"] = 3] = \"Raw\";\n    /**\n     * Texture content is dynamic (video or dynamic texture)\n     */\n    InternalTextureSource[InternalTextureSource[\"Dynamic\"] = 4] = \"Dynamic\";\n    /**\n     * Texture content is generated by rendering to it\n     */\n    InternalTextureSource[InternalTextureSource[\"RenderTarget\"] = 5] = \"RenderTarget\";\n    /**\n     * Texture content is part of a multi render target process\n     */\n    InternalTextureSource[InternalTextureSource[\"MultiRenderTarget\"] = 6] = \"MultiRenderTarget\";\n    /**\n     * Texture data comes from a cube data file\n     */\n    InternalTextureSource[InternalTextureSource[\"Cube\"] = 7] = \"Cube\";\n    /**\n     * Texture data comes from a raw cube data\n     */\n    InternalTextureSource[InternalTextureSource[\"CubeRaw\"] = 8] = \"CubeRaw\";\n    /**\n     * Texture data come from a prefiltered cube data file\n     */\n    InternalTextureSource[InternalTextureSource[\"CubePrefiltered\"] = 9] = \"CubePrefiltered\";\n    /**\n     * Texture content is raw 3D data\n     */\n    InternalTextureSource[InternalTextureSource[\"Raw3D\"] = 10] = \"Raw3D\";\n    /**\n     * Texture content is raw 2D array data\n     */\n    InternalTextureSource[InternalTextureSource[\"Raw2DArray\"] = 11] = \"Raw2DArray\";\n    /**\n     * Texture content is a depth/stencil texture\n     */\n    InternalTextureSource[InternalTextureSource[\"DepthStencil\"] = 12] = \"DepthStencil\";\n    /**\n     * Texture data comes from a raw cube data encoded with RGBD\n     */\n    InternalTextureSource[InternalTextureSource[\"CubeRawRGBD\"] = 13] = \"CubeRawRGBD\";\n    /**\n     * Texture content is a depth texture\n     */\n    InternalTextureSource[InternalTextureSource[\"Depth\"] = 14] = \"Depth\";\n})(InternalTextureSource || (InternalTextureSource = {}));\n/**\n * Class used to store data associated with WebGL texture data for the engine\n * This class should not be used directly\n */\nexport class InternalTexture extends TextureSampler {\n    /**\n     * Gets a boolean indicating if the texture uses mipmaps\n     * TODO implements useMipMaps as a separate setting from generateMipMaps\n     */\n    get useMipMaps() {\n        return this.generateMipMaps;\n    }\n    set useMipMaps(value) {\n        this.generateMipMaps = value;\n    }\n    /** Gets the unique id of the internal texture */\n    get uniqueId() {\n        return this._uniqueId;\n    }\n    /** @internal */\n    _setUniqueId(id) {\n        this._uniqueId = id;\n    }\n    /**\n     * Gets the Engine the texture belongs to.\n     * @returns The babylon engine\n     */\n    getEngine() {\n        return this._engine;\n    }\n    /**\n     * Gets the data source type of the texture\n     */\n    get source() {\n        return this._source;\n    }\n    /**\n     * Creates a new InternalTexture\n     * @param engine defines the engine to use\n     * @param source defines the type of data that will be used\n     * @param delayAllocation if the texture allocation should be delayed (default: false)\n     */\n    constructor(engine, source, delayAllocation = false) {\n        super();\n        /**\n         * Defines if the texture is ready\n         */\n        this.isReady = false;\n        /**\n         * Defines if the texture is a cube texture\n         */\n        this.isCube = false;\n        /**\n         * Defines if the texture contains 3D data\n         */\n        this.is3D = false;\n        /**\n         * Defines if the texture contains 2D array data\n         */\n        this.is2DArray = false;\n        /**\n         * Defines if the texture contains multiview data\n         */\n        this.isMultiview = false;\n        /**\n         * Gets the URL used to load this texture\n         */\n        this.url = \"\";\n        /**\n         * Gets a boolean indicating if the texture needs mipmaps generation\n         */\n        this.generateMipMaps = false;\n        /**\n         * Gets the number of samples used by the texture (WebGL2+ only)\n         */\n        this.samples = 0;\n        /**\n         * Gets the type of the texture (int, float...)\n         */\n        this.type = -1;\n        /**\n         * Gets the format of the texture (RGB, RGBA...)\n         */\n        this.format = -1;\n        /**\n         * Observable called when the texture is loaded\n         */\n        this.onLoadedObservable = new Observable();\n        /**\n         * Observable called when the texture load is raising an error\n         */\n        this.onErrorObservable = new Observable();\n        /**\n         * If this callback is defined it will be called instead of the default _rebuild function\n         */\n        this.onRebuildCallback = null;\n        /**\n         * Gets the width of the texture\n         */\n        this.width = 0;\n        /**\n         * Gets the height of the texture\n         */\n        this.height = 0;\n        /**\n         * Gets the depth of the texture\n         */\n        this.depth = 0;\n        /**\n         * Gets the initial width of the texture (It could be rescaled if the current system does not support non power of two textures)\n         */\n        this.baseWidth = 0;\n        /**\n         * Gets the initial height of the texture (It could be rescaled if the current system does not support non power of two textures)\n         */\n        this.baseHeight = 0;\n        /**\n         * Gets the initial depth of the texture (It could be rescaled if the current system does not support non power of two textures)\n         */\n        this.baseDepth = 0;\n        /**\n         * Gets a boolean indicating if the texture is inverted on Y axis\n         */\n        this.invertY = false;\n        // Private\n        /** @internal */\n        this._invertVScale = false;\n        /** @internal */\n        this._associatedChannel = -1;\n        /** @internal */\n        this._source = InternalTextureSource.Unknown;\n        /** @internal */\n        this._buffer = null;\n        /** @internal */\n        this._bufferView = null;\n        /** @internal */\n        this._bufferViewArray = null;\n        /** @internal */\n        this._bufferViewArrayArray = null;\n        /** @internal */\n        this._size = 0;\n        /** @internal */\n        this._extension = \"\";\n        /** @internal */\n        this._files = null;\n        /** @internal */\n        this._workingCanvas = null;\n        /** @internal */\n        this._workingContext = null;\n        /** @internal */\n        this._cachedCoordinatesMode = null;\n        /** @internal */\n        this._isDisabled = false;\n        /** @internal */\n        this._compression = null;\n        /** @internal */\n        this._sphericalPolynomial = null;\n        /** @internal */\n        this._sphericalPolynomialPromise = null;\n        /** @internal */\n        this._sphericalPolynomialComputed = false;\n        /** @internal */\n        this._lodGenerationScale = 0;\n        /** @internal */\n        this._lodGenerationOffset = 0;\n        /** @internal */\n        this._useSRGBBuffer = false;\n        // The following three fields helps sharing generated fixed LODs for texture filtering\n        // In environment not supporting the textureLOD extension like EDGE. They are for internal use only.\n        // They are at the level of the gl texture to benefit from the cache.\n        /** @internal */\n        this._lodTextureHigh = null;\n        /** @internal */\n        this._lodTextureMid = null;\n        /** @internal */\n        this._lodTextureLow = null;\n        /** @internal */\n        this._isRGBD = false;\n        /** @internal */\n        this._linearSpecularLOD = false;\n        /** @internal */\n        this._irradianceTexture = null;\n        /** @internal */\n        this._hardwareTexture = null;\n        /** @internal */\n        this._maxLodLevel = null;\n        /** @internal */\n        this._references = 1;\n        /** @internal */\n        this._gammaSpace = null;\n        this._engine = engine;\n        this._source = source;\n        this._uniqueId = InternalTexture._Counter++;\n        if (!delayAllocation) {\n            this._hardwareTexture = engine._createHardwareTexture();\n        }\n    }\n    /**\n     * Increments the number of references (ie. the number of Texture that point to it)\n     */\n    incrementReferences() {\n        this._references++;\n    }\n    /**\n     * Change the size of the texture (not the size of the content)\n     * @param width defines the new width\n     * @param height defines the new height\n     * @param depth defines the new depth (1 by default)\n     */\n    updateSize(width, height, depth = 1) {\n        this._engine.updateTextureDimensions(this, width, height, depth);\n        this.width = width;\n        this.height = height;\n        this.depth = depth;\n        this.baseWidth = width;\n        this.baseHeight = height;\n        this.baseDepth = depth;\n        this._size = width * height * depth;\n    }\n    /** @internal */\n    _rebuild() {\n        var _a;\n        this.isReady = false;\n        this._cachedCoordinatesMode = null;\n        this._cachedWrapU = null;\n        this._cachedWrapV = null;\n        this._cachedWrapR = null;\n        this._cachedAnisotropicFilteringLevel = null;\n        if (this.onRebuildCallback) {\n            const data = this.onRebuildCallback(this);\n            const swapAndSetIsReady = (proxyInternalTexture) => {\n                proxyInternalTexture._swapAndDie(this, false);\n                this.isReady = data.isReady;\n            };\n            if (data.isAsync) {\n                data.proxy.then(swapAndSetIsReady);\n            }\n            else {\n                swapAndSetIsReady(data.proxy);\n            }\n            return;\n        }\n        let proxy;\n        switch (this.source) {\n            case InternalTextureSource.Temp:\n                break;\n            case InternalTextureSource.Url:\n                proxy = this._engine.createTexture((_a = this._originalUrl) !== null && _a !== void 0 ? _a : this.url, !this.generateMipMaps, this.invertY, null, this.samplingMode, \n                // Do not use Proxy here as it could be fully synchronous\n                // and proxy would be undefined.\n                (temp) => {\n                    temp._swapAndDie(this, false);\n                    this.isReady = true;\n                }, null, this._buffer, undefined, this.format, this._extension, undefined, undefined, undefined, this._useSRGBBuffer);\n                return;\n            case InternalTextureSource.Raw:\n                proxy = this._engine.createRawTexture(this._bufferView, this.baseWidth, this.baseHeight, this.format, this.generateMipMaps, this.invertY, this.samplingMode, this._compression, this.type, undefined, this._useSRGBBuffer);\n                proxy._swapAndDie(this, false);\n                this.isReady = true;\n                break;\n            case InternalTextureSource.Raw3D:\n                proxy = this._engine.createRawTexture3D(this._bufferView, this.baseWidth, this.baseHeight, this.baseDepth, this.format, this.generateMipMaps, this.invertY, this.samplingMode, this._compression, this.type);\n                proxy._swapAndDie(this, false);\n                this.isReady = true;\n                break;\n            case InternalTextureSource.Raw2DArray:\n                proxy = this._engine.createRawTexture2DArray(this._bufferView, this.baseWidth, this.baseHeight, this.baseDepth, this.format, this.generateMipMaps, this.invertY, this.samplingMode, this._compression, this.type);\n                proxy._swapAndDie(this, false);\n                this.isReady = true;\n                break;\n            case InternalTextureSource.Dynamic:\n                proxy = this._engine.createDynamicTexture(this.baseWidth, this.baseHeight, this.generateMipMaps, this.samplingMode);\n                proxy._swapAndDie(this, false);\n                this._engine.updateDynamicTexture(this, this._engine.getRenderingCanvas(), this.invertY, undefined, undefined, true);\n                // The engine will make sure to update content so no need to flag it as isReady = true\n                break;\n            case InternalTextureSource.Cube:\n                proxy = this._engine.createCubeTexture(this.url, null, this._files, !this.generateMipMaps, () => {\n                    proxy._swapAndDie(this, false);\n                    this.isReady = true;\n                }, null, this.format, this._extension, false, 0, 0, null, undefined, this._useSRGBBuffer);\n                return;\n            case InternalTextureSource.CubeRaw:\n                proxy = this._engine.createRawCubeTexture(this._bufferViewArray, this.width, this.format, this.type, this.generateMipMaps, this.invertY, this.samplingMode, this._compression);\n                proxy._swapAndDie(this, false);\n                this.isReady = true;\n                break;\n            case InternalTextureSource.CubeRawRGBD:\n                // This case is being handeled by the environment texture tools and is not a part of the rebuild process.\n                // To use CubeRawRGBD use updateRGBDAsync on the cube texture.\n                return;\n            case InternalTextureSource.CubePrefiltered:\n                proxy = this._engine.createPrefilteredCubeTexture(this.url, null, this._lodGenerationScale, this._lodGenerationOffset, (proxy) => {\n                    if (proxy) {\n                        proxy._swapAndDie(this, false);\n                    }\n                    this.isReady = true;\n                }, null, this.format, this._extension);\n                proxy._sphericalPolynomial = this._sphericalPolynomial;\n                return;\n        }\n    }\n    /**\n     * @internal\n     */\n    _swapAndDie(target, swapAll = true) {\n        // TODO what about refcount on target?\n        var _a;\n        (_a = this._hardwareTexture) === null || _a === void 0 ? void 0 : _a.setUsage(target._source, this.generateMipMaps, this.isCube, this.width, this.height);\n        target._hardwareTexture = this._hardwareTexture;\n        if (swapAll) {\n            target._isRGBD = this._isRGBD;\n        }\n        if (this._lodTextureHigh) {\n            if (target._lodTextureHigh) {\n                target._lodTextureHigh.dispose();\n            }\n            target._lodTextureHigh = this._lodTextureHigh;\n        }\n        if (this._lodTextureMid) {\n            if (target._lodTextureMid) {\n                target._lodTextureMid.dispose();\n            }\n            target._lodTextureMid = this._lodTextureMid;\n        }\n        if (this._lodTextureLow) {\n            if (target._lodTextureLow) {\n                target._lodTextureLow.dispose();\n            }\n            target._lodTextureLow = this._lodTextureLow;\n        }\n        if (this._irradianceTexture) {\n            if (target._irradianceTexture) {\n                target._irradianceTexture.dispose();\n            }\n            target._irradianceTexture = this._irradianceTexture;\n        }\n        const cache = this._engine.getLoadedTexturesCache();\n        let index = cache.indexOf(this);\n        if (index !== -1) {\n            cache.splice(index, 1);\n        }\n        index = cache.indexOf(target);\n        if (index === -1) {\n            cache.push(target);\n        }\n    }\n    /**\n     * Dispose the current allocated resources\n     */\n    dispose() {\n        this._references--;\n        this.onLoadedObservable.clear();\n        this.onErrorObservable.clear();\n        if (this._references === 0) {\n            this._engine._releaseTexture(this);\n            this._hardwareTexture = null;\n        }\n    }\n}\n/** @internal */\nInternalTexture._Counter = 0;\n//# sourceMappingURL=internalTexture.js.map","export var SourceTextureFormat;\n(function (SourceTextureFormat) {\n    SourceTextureFormat[SourceTextureFormat[\"ETC1S\"] = 0] = \"ETC1S\";\n    SourceTextureFormat[SourceTextureFormat[\"UASTC4x4\"] = 1] = \"UASTC4x4\";\n})(SourceTextureFormat || (SourceTextureFormat = {}));\nexport var TranscodeTarget;\n(function (TranscodeTarget) {\n    TranscodeTarget[TranscodeTarget[\"ASTC_4X4_RGBA\"] = 0] = \"ASTC_4X4_RGBA\";\n    TranscodeTarget[TranscodeTarget[\"BC7_RGBA\"] = 1] = \"BC7_RGBA\";\n    TranscodeTarget[TranscodeTarget[\"BC3_RGBA\"] = 2] = \"BC3_RGBA\";\n    TranscodeTarget[TranscodeTarget[\"BC1_RGB\"] = 3] = \"BC1_RGB\";\n    TranscodeTarget[TranscodeTarget[\"PVRTC1_4_RGBA\"] = 4] = \"PVRTC1_4_RGBA\";\n    TranscodeTarget[TranscodeTarget[\"PVRTC1_4_RGB\"] = 5] = \"PVRTC1_4_RGB\";\n    TranscodeTarget[TranscodeTarget[\"ETC2_RGBA\"] = 6] = \"ETC2_RGBA\";\n    TranscodeTarget[TranscodeTarget[\"ETC1_RGB\"] = 7] = \"ETC1_RGB\";\n    TranscodeTarget[TranscodeTarget[\"RGBA32\"] = 8] = \"RGBA32\";\n    TranscodeTarget[TranscodeTarget[\"R8\"] = 9] = \"R8\";\n    TranscodeTarget[TranscodeTarget[\"RG8\"] = 10] = \"RG8\";\n})(TranscodeTarget || (TranscodeTarget = {}));\nexport var EngineFormat;\n(function (EngineFormat) {\n    EngineFormat[EngineFormat[\"COMPRESSED_RGBA_BPTC_UNORM_EXT\"] = 36492] = \"COMPRESSED_RGBA_BPTC_UNORM_EXT\";\n    EngineFormat[EngineFormat[\"COMPRESSED_RGBA_ASTC_4X4_KHR\"] = 37808] = \"COMPRESSED_RGBA_ASTC_4X4_KHR\";\n    EngineFormat[EngineFormat[\"COMPRESSED_RGB_S3TC_DXT1_EXT\"] = 33776] = \"COMPRESSED_RGB_S3TC_DXT1_EXT\";\n    EngineFormat[EngineFormat[\"COMPRESSED_RGBA_S3TC_DXT5_EXT\"] = 33779] = \"COMPRESSED_RGBA_S3TC_DXT5_EXT\";\n    EngineFormat[EngineFormat[\"COMPRESSED_RGBA_PVRTC_4BPPV1_IMG\"] = 35842] = \"COMPRESSED_RGBA_PVRTC_4BPPV1_IMG\";\n    EngineFormat[EngineFormat[\"COMPRESSED_RGB_PVRTC_4BPPV1_IMG\"] = 35840] = \"COMPRESSED_RGB_PVRTC_4BPPV1_IMG\";\n    EngineFormat[EngineFormat[\"COMPRESSED_RGBA8_ETC2_EAC\"] = 37496] = \"COMPRESSED_RGBA8_ETC2_EAC\";\n    EngineFormat[EngineFormat[\"COMPRESSED_RGB8_ETC2\"] = 37492] = \"COMPRESSED_RGB8_ETC2\";\n    EngineFormat[EngineFormat[\"COMPRESSED_RGB_ETC1_WEBGL\"] = 36196] = \"COMPRESSED_RGB_ETC1_WEBGL\";\n    EngineFormat[EngineFormat[\"RGBA8Format\"] = 32856] = \"RGBA8Format\";\n    EngineFormat[EngineFormat[\"R8Format\"] = 33321] = \"R8Format\";\n    EngineFormat[EngineFormat[\"RG8Format\"] = 33323] = \"RG8Format\";\n})(EngineFormat || (EngineFormat = {}));\n//# sourceMappingURL=ktx2decoderTypes.js.map","import { Matrix, Vector3, Vector2 } from \"../../Maths/math.vector.js\";\nimport { Texture } from \"../../Materials/Textures/texture.js\";\nimport { RenderTargetTexture } from \"../../Materials/Textures/renderTargetTexture.js\";\nimport { BlurPostProcess } from \"../../PostProcesses/blurPostProcess.js\";\n\nimport { Plane } from \"../../Maths/math.plane.js\";\n/**\n * Mirror texture can be used to simulate the view from a mirror in a scene.\n * It will dynamically be rendered every frame to adapt to the camera point of view.\n * You can then easily use it as a reflectionTexture on a flat surface.\n * In case the surface is not a plane, please consider relying on reflection probes.\n * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/reflectionTexture#mirrortexture\n */\nexport class MirrorTexture extends RenderTargetTexture {\n    /**\n     * Define the blur ratio used to blur the reflection if needed.\n     */\n    set blurRatio(value) {\n        if (this._blurRatio === value) {\n            return;\n        }\n        this._blurRatio = value;\n        this._preparePostProcesses();\n    }\n    get blurRatio() {\n        return this._blurRatio;\n    }\n    /**\n     * Define the adaptive blur kernel used to blur the reflection if needed.\n     * This will autocompute the closest best match for the `blurKernel`\n     */\n    set adaptiveBlurKernel(value) {\n        this._adaptiveBlurKernel = value;\n        this._autoComputeBlurKernel();\n    }\n    /**\n     * Define the blur kernel used to blur the reflection if needed.\n     * Please consider using `adaptiveBlurKernel` as it could find the closest best value for you.\n     */\n    set blurKernel(value) {\n        this.blurKernelX = value;\n        this.blurKernelY = value;\n    }\n    /**\n     * Define the blur kernel on the X Axis used to blur the reflection if needed.\n     * Please consider using `adaptiveBlurKernel` as it could find the closest best value for you.\n     */\n    set blurKernelX(value) {\n        if (this._blurKernelX === value) {\n            return;\n        }\n        this._blurKernelX = value;\n        this._preparePostProcesses();\n    }\n    get blurKernelX() {\n        return this._blurKernelX;\n    }\n    /**\n     * Define the blur kernel on the Y Axis used to blur the reflection if needed.\n     * Please consider using `adaptiveBlurKernel` as it could find the closest best value for you.\n     */\n    set blurKernelY(value) {\n        if (this._blurKernelY === value) {\n            return;\n        }\n        this._blurKernelY = value;\n        this._preparePostProcesses();\n    }\n    get blurKernelY() {\n        return this._blurKernelY;\n    }\n    _autoComputeBlurKernel() {\n        const engine = this.getScene().getEngine();\n        const dw = this.getRenderWidth() / engine.getRenderWidth();\n        const dh = this.getRenderHeight() / engine.getRenderHeight();\n        this.blurKernelX = this._adaptiveBlurKernel * dw;\n        this.blurKernelY = this._adaptiveBlurKernel * dh;\n    }\n    _onRatioRescale() {\n        if (this._sizeRatio) {\n            this.resize(this._initialSizeParameter);\n            if (!this._adaptiveBlurKernel) {\n                this._preparePostProcesses();\n            }\n        }\n        if (this._adaptiveBlurKernel) {\n            this._autoComputeBlurKernel();\n        }\n    }\n    _updateGammaSpace() {\n        const scene = this.getScene();\n        if (!scene) {\n            return;\n        }\n        this.gammaSpace = !scene.imageProcessingConfiguration.isEnabled || !scene.imageProcessingConfiguration.applyByPostProcess;\n    }\n    /**\n     * Instantiates a Mirror Texture.\n     * Mirror texture can be used to simulate the view from a mirror in a scene.\n     * It will dynamically be rendered every frame to adapt to the camera point of view.\n     * You can then easily use it as a reflectionTexture on a flat surface.\n     * In case the surface is not a plane, please consider relying on reflection probes.\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/reflectionTexture#mirrors\n     * @param name\n     * @param size\n     * @param scene\n     * @param generateMipMaps\n     * @param type\n     * @param samplingMode\n     * @param generateDepthBuffer\n     */\n    constructor(name, size, scene, generateMipMaps, type = 0, samplingMode = Texture.BILINEAR_SAMPLINGMODE, generateDepthBuffer = true) {\n        super(name, size, scene, generateMipMaps, true, type, false, samplingMode, generateDepthBuffer);\n        /**\n         * Define the reflection plane we want to use. The mirrorPlane is usually set to the constructed reflector.\n         * It is possible to directly set the mirrorPlane by directly using a Plane(a, b, c, d) where a, b and c give the plane normal vector (a, b, c) and d is a scalar displacement from the mirrorPlane to the origin. However in all but the very simplest of situations it is more straight forward to set it to the reflector as stated in the doc.\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/reflectionTexture#mirrors\n         */\n        this.mirrorPlane = new Plane(0, 1, 0, 1);\n        this._transformMatrix = Matrix.Zero();\n        this._mirrorMatrix = Matrix.Zero();\n        this._adaptiveBlurKernel = 0;\n        this._blurKernelX = 0;\n        this._blurKernelY = 0;\n        this._blurRatio = 1.0;\n        scene = this.getScene();\n        if (!scene) {\n            return this;\n        }\n        this.ignoreCameraViewport = true;\n        this._updateGammaSpace();\n        this._imageProcessingConfigChangeObserver = scene.imageProcessingConfiguration.onUpdateParameters.add(() => {\n            this._updateGammaSpace();\n        });\n        const engine = scene.getEngine();\n        if (engine.supportsUniformBuffers) {\n            this._sceneUBO = scene.createSceneUniformBuffer(`Scene for Mirror Texture (name \"${name}\")`);\n        }\n        this.onBeforeBindObservable.add(() => {\n            var _a;\n            (_a = engine._debugPushGroup) === null || _a === void 0 ? void 0 : _a.call(engine, `mirror generation for ${name}`, 1);\n        });\n        this.onAfterUnbindObservable.add(() => {\n            var _a;\n            (_a = engine._debugPopGroup) === null || _a === void 0 ? void 0 : _a.call(engine, 1);\n        });\n        let saveClipPlane;\n        this.onBeforeRenderObservable.add(() => {\n            if (this._sceneUBO) {\n                this._currentSceneUBO = scene.getSceneUniformBuffer();\n                scene.setSceneUniformBuffer(this._sceneUBO);\n                scene.getSceneUniformBuffer().unbindEffect();\n            }\n            Matrix.ReflectionToRef(this.mirrorPlane, this._mirrorMatrix);\n            this._mirrorMatrix.multiplyToRef(scene.getViewMatrix(), this._transformMatrix);\n            scene.setTransformMatrix(this._transformMatrix, scene.getProjectionMatrix());\n            saveClipPlane = scene.clipPlane;\n            scene.clipPlane = this.mirrorPlane;\n            scene._mirroredCameraPosition = Vector3.TransformCoordinates(scene.activeCamera.globalPosition, this._mirrorMatrix);\n        });\n        this.onAfterRenderObservable.add(() => {\n            if (this._sceneUBO) {\n                scene.setSceneUniformBuffer(this._currentSceneUBO);\n            }\n            scene.updateTransformMatrix();\n            scene._mirroredCameraPosition = null;\n            scene.clipPlane = saveClipPlane;\n        });\n    }\n    _preparePostProcesses() {\n        this.clearPostProcesses(true);\n        if (this._blurKernelX && this._blurKernelY) {\n            const engine = this.getScene().getEngine();\n            const textureType = engine.getCaps().textureFloatRender && engine.getCaps().textureFloatLinearFiltering ? 1 : 2;\n            this._blurX = new BlurPostProcess(\"horizontal blur\", new Vector2(1.0, 0), this._blurKernelX, this._blurRatio, null, Texture.BILINEAR_SAMPLINGMODE, engine, false, textureType);\n            this._blurX.autoClear = false;\n            if (this._blurRatio === 1 && this.samples < 2 && this._texture) {\n                this._blurX.inputTexture = this._renderTarget;\n            }\n            else {\n                this._blurX.alwaysForcePOT = true;\n            }\n            this._blurY = new BlurPostProcess(\"vertical blur\", new Vector2(0, 1.0), this._blurKernelY, this._blurRatio, null, Texture.BILINEAR_SAMPLINGMODE, engine, false, textureType);\n            this._blurY.autoClear = false;\n            this._blurY.alwaysForcePOT = this._blurRatio !== 1;\n            this.addPostProcess(this._blurX);\n            this.addPostProcess(this._blurY);\n        }\n        else {\n            if (this._blurY) {\n                this.removePostProcess(this._blurY);\n                this._blurY.dispose();\n                this._blurY = null;\n            }\n            if (this._blurX) {\n                this.removePostProcess(this._blurX);\n                this._blurX.dispose();\n                this._blurX = null;\n            }\n        }\n    }\n    /**\n     * Clone the mirror texture.\n     * @returns the cloned texture\n     */\n    clone() {\n        const scene = this.getScene();\n        if (!scene) {\n            return this;\n        }\n        const textureSize = this.getSize();\n        const newTexture = new MirrorTexture(this.name, textureSize.width, scene, this._renderTargetOptions.generateMipMaps, this._renderTargetOptions.type, this._renderTargetOptions.samplingMode, this._renderTargetOptions.generateDepthBuffer);\n        // Base texture\n        newTexture.hasAlpha = this.hasAlpha;\n        newTexture.level = this.level;\n        // Mirror Texture\n        newTexture.mirrorPlane = this.mirrorPlane.clone();\n        if (this.renderList) {\n            newTexture.renderList = this.renderList.slice(0);\n        }\n        return newTexture;\n    }\n    /**\n     * Serialize the texture to a JSON representation you could use in Parse later on\n     * @returns the serialized JSON representation\n     */\n    serialize() {\n        if (!this.name) {\n            return null;\n        }\n        const serializationObject = super.serialize();\n        serializationObject.mirrorPlane = this.mirrorPlane.asArray();\n        return serializationObject;\n    }\n    /**\n     * Dispose the texture and release its associated resources.\n     */\n    dispose() {\n        var _a;\n        super.dispose();\n        const scene = this.getScene();\n        if (scene) {\n            scene.imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingConfigChangeObserver);\n        }\n        (_a = this._sceneUBO) === null || _a === void 0 ? void 0 : _a.dispose();\n    }\n}\nTexture._CreateMirror = (name, renderTargetSize, scene, generateMipMaps) => {\n    return new MirrorTexture(name, renderTargetSize, scene, generateMipMaps);\n};\n//# sourceMappingURL=mirrorTexture.js.map","import { Texture } from \"../../Materials/Textures/texture.js\";\nimport { RenderTargetTexture } from \"../../Materials/Textures/renderTargetTexture.js\";\n\nimport \"../../Engines/Extensions/engine.multiRender.js\";\n/**\n * A multi render target, like a render target provides the ability to render to a texture.\n * Unlike the render target, it can render to several draw buffers in one draw.\n * This is specially interesting in deferred rendering or for any effects requiring more than\n * just one color from a single pass.\n */\nexport class MultiRenderTarget extends RenderTargetTexture {\n    /**\n     * Get if draw buffers are currently supported by the used hardware and browser.\n     */\n    get isSupported() {\n        var _a, _b;\n        return (_b = (_a = this._engine) === null || _a === void 0 ? void 0 : _a.getCaps().drawBuffersExtension) !== null && _b !== void 0 ? _b : false;\n    }\n    /**\n     * Get the list of textures generated by the multi render target.\n     */\n    get textures() {\n        return this._textures;\n    }\n    /**\n     * Gets the number of textures in this MRT. This number can be different from `_textures.length` in case a depth texture is generated.\n     */\n    get count() {\n        return this._count;\n    }\n    /**\n     * Get the depth texture generated by the multi render target if options.generateDepthTexture has been set\n     */\n    get depthTexture() {\n        return this._textures[this._textures.length - 1];\n    }\n    /**\n     * Set the wrapping mode on U of all the textures we are rendering to.\n     * Can be any of the Texture. (CLAMP_ADDRESSMODE, MIRROR_ADDRESSMODE or WRAP_ADDRESSMODE)\n     */\n    set wrapU(wrap) {\n        if (this._textures) {\n            for (let i = 0; i < this._textures.length; i++) {\n                this._textures[i].wrapU = wrap;\n            }\n        }\n    }\n    /**\n     * Set the wrapping mode on V of all the textures we are rendering to.\n     * Can be any of the Texture. (CLAMP_ADDRESSMODE, MIRROR_ADDRESSMODE or WRAP_ADDRESSMODE)\n     */\n    set wrapV(wrap) {\n        if (this._textures) {\n            for (let i = 0; i < this._textures.length; i++) {\n                this._textures[i].wrapV = wrap;\n            }\n        }\n    }\n    /**\n     * Instantiate a new multi render target texture.\n     * A multi render target, like a render target provides the ability to render to a texture.\n     * Unlike the render target, it can render to several draw buffers in one draw.\n     * This is specially interesting in deferred rendering or for any effects requiring more than\n     * just one color from a single pass.\n     * @param name Define the name of the texture\n     * @param size Define the size of the buffers to render to\n     * @param count Define the number of target we are rendering into\n     * @param scene Define the scene the texture belongs to\n     * @param options Define the options used to create the multi render target\n     * @param textureNames Define the names to set to the textures (if count > 0 - optional)\n     */\n    constructor(name, size, count, scene, options, textureNames) {\n        const generateMipMaps = options && options.generateMipMaps ? options.generateMipMaps : false;\n        const generateDepthTexture = options && options.generateDepthTexture ? options.generateDepthTexture : false;\n        const depthTextureFormat = options && options.depthTextureFormat ? options.depthTextureFormat : 15;\n        const doNotChangeAspectRatio = !options || options.doNotChangeAspectRatio === undefined ? true : options.doNotChangeAspectRatio;\n        const drawOnlyOnFirstAttachmentByDefault = options && options.drawOnlyOnFirstAttachmentByDefault ? options.drawOnlyOnFirstAttachmentByDefault : false;\n        super(name, size, scene, generateMipMaps, doNotChangeAspectRatio, undefined, undefined, undefined, undefined, undefined, undefined, undefined, true);\n        if (!this.isSupported) {\n            this.dispose();\n            return;\n        }\n        const types = [];\n        const samplingModes = [];\n        const useSRGBBuffers = [];\n        this._initTypes(count, types, samplingModes, useSRGBBuffers, options);\n        const generateDepthBuffer = !options || options.generateDepthBuffer === undefined ? true : options.generateDepthBuffer;\n        const generateStencilBuffer = !options || options.generateStencilBuffer === undefined ? false : options.generateStencilBuffer;\n        this._size = size;\n        this._multiRenderTargetOptions = {\n            samplingModes: samplingModes,\n            generateMipMaps: generateMipMaps,\n            generateDepthBuffer: generateDepthBuffer,\n            generateStencilBuffer: generateStencilBuffer,\n            generateDepthTexture: generateDepthTexture,\n            depthTextureFormat: depthTextureFormat,\n            types: types,\n            textureCount: count,\n            useSRGBBuffers: useSRGBBuffers,\n        };\n        this._count = count;\n        this._drawOnlyOnFirstAttachmentByDefault = drawOnlyOnFirstAttachmentByDefault;\n        if (count > 0) {\n            this._createInternalTextures();\n            this._createTextures(textureNames);\n        }\n    }\n    _initTypes(count, types, samplingModes, useSRGBBuffers, options) {\n        for (let i = 0; i < count; i++) {\n            if (options && options.types && options.types[i] !== undefined) {\n                types.push(options.types[i]);\n            }\n            else {\n                types.push(options && options.defaultType ? options.defaultType : 0);\n            }\n            if (options && options.samplingModes && options.samplingModes[i] !== undefined) {\n                samplingModes.push(options.samplingModes[i]);\n            }\n            else {\n                samplingModes.push(Texture.BILINEAR_SAMPLINGMODE);\n            }\n            if (options && options.useSRGBBuffers && options.useSRGBBuffers[i] !== undefined) {\n                useSRGBBuffers.push(options.useSRGBBuffers[i]);\n            }\n            else {\n                useSRGBBuffers.push(false);\n            }\n        }\n    }\n    /**\n     * @internal\n     */\n    _rebuild(forceFullRebuild = false, textureNames) {\n        if (this._count < 1) {\n            return;\n        }\n        this.releaseInternalTextures();\n        this._createInternalTextures();\n        if (forceFullRebuild) {\n            this._releaseTextures();\n            this._createTextures(textureNames);\n        }\n        const internalTextures = this._renderTarget.textures;\n        for (let i = 0; i < internalTextures.length; i++) {\n            const texture = this._textures[i];\n            texture._texture = internalTextures[i];\n        }\n        if (this.samples !== 1) {\n            this._renderTarget.setSamples(this.samples, !this._drawOnlyOnFirstAttachmentByDefault, true);\n        }\n    }\n    _createInternalTextures() {\n        this._renderTarget = this._getEngine().createMultipleRenderTarget(this._size, this._multiRenderTargetOptions, !this._drawOnlyOnFirstAttachmentByDefault);\n        this._texture = this._renderTarget.texture;\n    }\n    _releaseTextures() {\n        if (this._textures) {\n            for (let i = 0; i < this._textures.length; i++) {\n                this._textures[i]._texture = null; // internal textures are released by a call to releaseInternalTextures()\n                this._textures[i].dispose();\n            }\n        }\n    }\n    _createTextures(textureNames) {\n        const internalTextures = this._renderTarget.textures;\n        this._textures = [];\n        for (let i = 0; i < internalTextures.length; i++) {\n            const texture = new Texture(null, this.getScene());\n            if (textureNames === null || textureNames === void 0 ? void 0 : textureNames[i]) {\n                texture.name = textureNames[i];\n            }\n            texture._texture = internalTextures[i];\n            this._textures.push(texture);\n        }\n    }\n    /**\n     * Replaces an internal texture within the MRT. Useful to share textures between MultiRenderTarget.\n     * @param texture The new texture to set in the MRT\n     * @param index The index of the texture to replace\n     * @param disposePrevious Set to true if the previous internal texture should be disposed\n     */\n    setInternalTexture(texture, index, disposePrevious = true) {\n        if (!this.renderTarget) {\n            return;\n        }\n        if (index === 0) {\n            this._texture = texture;\n        }\n        this.renderTarget.setTexture(texture, index, disposePrevious);\n        if (!this.textures[index]) {\n            this.textures[index] = new Texture(null, this.getScene());\n        }\n        this.textures[index]._texture = texture;\n        this._count = this.renderTarget.textures ? this.renderTarget.textures.length : 0;\n        if (this._multiRenderTargetOptions.types) {\n            this._multiRenderTargetOptions.types[index] = texture.type;\n        }\n        if (this._multiRenderTargetOptions.samplingModes) {\n            this._multiRenderTargetOptions.samplingModes[index] = texture.samplingMode;\n        }\n        if (this._multiRenderTargetOptions.useSRGBBuffers) {\n            this._multiRenderTargetOptions.useSRGBBuffers[index] = texture._useSRGBBuffer;\n        }\n    }\n    /**\n     * Define the number of samples used if MSAA is enabled.\n     */\n    get samples() {\n        return this._samples;\n    }\n    set samples(value) {\n        if (this._renderTarget) {\n            this._samples = this._renderTarget.setSamples(value);\n        }\n        else {\n            // In case samples are set with 0 textures created, we must save the desired samples value\n            this._samples = value;\n        }\n    }\n    /**\n     * Resize all the textures in the multi render target.\n     * Be careful as it will recreate all the data in the new texture.\n     * @param size Define the new size\n     */\n    resize(size) {\n        this._size = size;\n        this._rebuild();\n    }\n    /**\n     * Changes the number of render targets in this MRT\n     * Be careful as it will recreate all the data in the new texture.\n     * @param count new texture count\n     * @param options Specifies texture types and sampling modes for new textures\n     * @param textureNames Specifies the names of the textures (optional)\n     */\n    updateCount(count, options, textureNames) {\n        this._multiRenderTargetOptions.textureCount = count;\n        this._count = count;\n        const types = [];\n        const samplingModes = [];\n        const useSRGBBuffers = [];\n        this._initTypes(count, types, samplingModes, useSRGBBuffers, options);\n        this._multiRenderTargetOptions.types = types;\n        this._multiRenderTargetOptions.samplingModes = samplingModes;\n        this._multiRenderTargetOptions.useSRGBBuffers = useSRGBBuffers;\n        this._rebuild(true, textureNames);\n    }\n    _unbindFrameBuffer(engine, faceIndex) {\n        if (this._renderTarget) {\n            engine.unBindMultiColorAttachmentFramebuffer(this._renderTarget, this.isCube, () => {\n                this.onAfterRenderObservable.notifyObservers(faceIndex);\n            });\n        }\n    }\n    /**\n     * Dispose the render targets and their associated resources\n     * @param doNotDisposeInternalTextures\n     */\n    dispose(doNotDisposeInternalTextures = false) {\n        this._releaseTextures();\n        if (!doNotDisposeInternalTextures) {\n            this.releaseInternalTextures();\n        }\n        else {\n            // Prevent internal texture dispose in super.dispose\n            this._texture = null;\n        }\n        super.dispose();\n    }\n    /**\n     * Release all the underlying texture used as draw buffers.\n     */\n    releaseInternalTextures() {\n        var _a, _b;\n        const internalTextures = (_a = this._renderTarget) === null || _a === void 0 ? void 0 : _a.textures;\n        if (!internalTextures) {\n            return;\n        }\n        for (let i = internalTextures.length - 1; i >= 0; i--) {\n            this._textures[i]._texture = null;\n        }\n        (_b = this._renderTarget) === null || _b === void 0 ? void 0 : _b.dispose();\n        this._renderTarget = null;\n    }\n}\n//# sourceMappingURL=multiRenderTarget.js.map","import { MultiRenderTarget } from \"./multiRenderTarget.js\";\nimport { ImageProcessingPostProcess } from \"../../PostProcesses/imageProcessingPostProcess.js\";\n/**\n * A multi render target designed to render the prepass.\n * Prepass is a scene component used to render information in multiple textures\n * alongside with the scene materials rendering.\n * Note : This is an internal class, and you should NOT need to instanciate this.\n * Only the `PrePassRenderer` should instanciate this class.\n * It is more likely that you need a regular `MultiRenderTarget`\n * @internal\n */\nexport class PrePassRenderTarget extends MultiRenderTarget {\n    constructor(name, renderTargetTexture, size, count, scene, options) {\n        super(name, size, count, scene, options);\n        /**\n         * @internal\n         */\n        this._beforeCompositionPostProcesses = [];\n        /**\n         * @internal\n         */\n        this._internalTextureDirty = false;\n        /**\n         * Is this render target enabled for prepass rendering\n         */\n        this.enabled = false;\n        /**\n         * Render target associated with this prePassRenderTarget\n         * If this is `null`, it means this prePassRenderTarget is associated with the scene\n         */\n        this.renderTargetTexture = null;\n        this.renderTargetTexture = renderTargetTexture;\n    }\n    /**\n     * Creates a composition effect for this RT\n     * @internal\n     */\n    _createCompositionEffect() {\n        this.imageProcessingPostProcess = new ImageProcessingPostProcess(\"prePassComposition\", 1, null, undefined, this._engine);\n        this.imageProcessingPostProcess._updateParameters();\n    }\n    /**\n     * Checks that the size of this RT is still adapted to the desired render size.\n     * @internal\n     */\n    _checkSize() {\n        const requiredWidth = this._engine.getRenderWidth(true);\n        const requiredHeight = this._engine.getRenderHeight(true);\n        const width = this.getRenderWidth();\n        const height = this.getRenderHeight();\n        if (width !== requiredWidth || height !== requiredHeight) {\n            this.resize({ width: requiredWidth, height: requiredHeight });\n            this._internalTextureDirty = true;\n        }\n    }\n    /**\n     * Changes the number of render targets in this MRT\n     * Be careful as it will recreate all the data in the new texture.\n     * @param count new texture count\n     * @param options Specifies texture types and sampling modes for new textures\n     * @param textureNames Specifies the names of the textures (optional)\n     */\n    updateCount(count, options, textureNames) {\n        super.updateCount(count, options, textureNames);\n        this._internalTextureDirty = true;\n    }\n    /**\n     * Resets the post processes chains applied to this RT.\n     * @internal\n     */\n    _resetPostProcessChain() {\n        this._beforeCompositionPostProcesses.length = 0;\n    }\n    /**\n     * Diposes this render target\n     */\n    dispose() {\n        const scene = this._scene;\n        super.dispose();\n        if (scene && scene.prePassRenderer) {\n            const index = scene.prePassRenderer.renderTargets.indexOf(this);\n            if (index !== -1) {\n                scene.prePassRenderer.renderTargets.splice(index, 1);\n            }\n        }\n        if (this.imageProcessingPostProcess) {\n            this.imageProcessingPostProcess.dispose();\n        }\n        if (this.renderTargetTexture) {\n            this.renderTargetTexture._prePassRenderTarget = null;\n        }\n        if (this._outputPostProcess) {\n            this._outputPostProcess.autoClear = true;\n            this._outputPostProcess.restoreDefaultInputTexture();\n        }\n    }\n}\n//# sourceMappingURL=prePassRenderTarget.js.map","import { SerializationHelper } from \"../../Misc/decorators.js\";\nimport { _UpdateRGBDAsync as UpdateRGBDAsyncEnvTools } from \"../../Misc/environmentTextureTools.js\";\nimport { InternalTextureSource } from \"./internalTexture.js\";\nimport { CubeTexture } from \"./cubeTexture.js\";\n\nimport \"../../Engines/Extensions/engine.rawTexture.js\";\n/**\n * Raw cube texture where the raw buffers are passed in\n */\nexport class RawCubeTexture extends CubeTexture {\n    /**\n     * Creates a cube texture where the raw buffers are passed in.\n     * @param scene defines the scene the texture is attached to\n     * @param data defines the array of data to use to create each face\n     * @param size defines the size of the textures\n     * @param format defines the format of the data\n     * @param type defines the type of the data (like Engine.TEXTURETYPE_UNSIGNED_INT)\n     * @param generateMipMaps  defines if the engine should generate the mip levels\n     * @param invertY defines if data must be stored with Y axis inverted\n     * @param samplingMode defines the required sampling mode (like Texture.NEAREST_SAMPLINGMODE)\n     * @param compression defines the compression used (null by default)\n     */\n    constructor(scene, data, size, format = 5, type = 0, generateMipMaps = false, invertY = false, samplingMode = 3, compression = null) {\n        super(\"\", scene);\n        this._texture = scene.getEngine().createRawCubeTexture(data, size, format, type, generateMipMaps, invertY, samplingMode, compression);\n    }\n    /**\n     * Updates the raw cube texture.\n     * @param data defines the data to store\n     * @param format defines the data format\n     * @param type defines the type fo the data (Engine.TEXTURETYPE_UNSIGNED_INT by default)\n     * @param invertY defines if data must be stored with Y axis inverted\n     * @param compression defines the compression used (null by default)\n     */\n    update(data, format, type, invertY, compression = null) {\n        this._texture.getEngine().updateRawCubeTexture(this._texture, data, format, type, invertY, compression);\n    }\n    /**\n     * Updates a raw cube texture with RGBD encoded data.\n     * @param data defines the array of data [mipmap][face] to use to create each face\n     * @param sphericalPolynomial defines the spherical polynomial for irradiance\n     * @param lodScale defines the scale applied to environment texture. This manages the range of LOD level used for IBL according to the roughness\n     * @param lodOffset defines the offset applied to environment texture. This manages first LOD level used for IBL according to the roughness\n     * @returns a promise that resolves when the operation is complete\n     */\n    updateRGBDAsync(data, sphericalPolynomial = null, lodScale = 0.8, lodOffset = 0) {\n        return UpdateRGBDAsyncEnvTools(this._texture, data, sphericalPolynomial, lodScale, lodOffset).then(() => { });\n    }\n    /**\n     * Clones the raw cube texture.\n     * @returns a new cube texture\n     */\n    clone() {\n        return SerializationHelper.Clone(() => {\n            const scene = this.getScene();\n            const internalTexture = this._texture;\n            const texture = new RawCubeTexture(scene, internalTexture._bufferViewArray, internalTexture.width, internalTexture.format, internalTexture.type, internalTexture.generateMipMaps, internalTexture.invertY, internalTexture.samplingMode, internalTexture._compression);\n            if (internalTexture.source === InternalTextureSource.CubeRawRGBD) {\n                texture.updateRGBDAsync(internalTexture._bufferViewArrayArray, internalTexture._sphericalPolynomial, internalTexture._lodGenerationScale, internalTexture._lodGenerationOffset);\n            }\n            return texture;\n        }, this);\n    }\n}\n//# sourceMappingURL=rawCubeTexture.js.map","import { Texture } from \"./texture.js\";\n\nimport \"../../Engines/Extensions/engine.rawTexture.js\";\n/**\n * Raw texture can help creating a texture directly from an array of data.\n * This can be super useful if you either get the data from an uncompressed source or\n * if you wish to create your texture pixel by pixel.\n */\nexport class RawTexture extends Texture {\n    /**\n     * Instantiates a new RawTexture.\n     * Raw texture can help creating a texture directly from an array of data.\n     * This can be super useful if you either get the data from an uncompressed source or\n     * if you wish to create your texture pixel by pixel.\n     * @param data define the array of data to use to create the texture (null to create an empty texture)\n     * @param width define the width of the texture\n     * @param height define the height of the texture\n     * @param format define the format of the data (RGB, RGBA... Engine.TEXTUREFORMAT_xxx)\n     * @param sceneOrEngine defines the scene or engine the texture will belong to\n     * @param generateMipMaps define whether mip maps should be generated or not\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\n     * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)\n     * @param creationFlags specific flags to use when creating the texture (1 for storage textures, for eg)\n     * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).\n     */\n    constructor(data, width, height, \n    /**\n     * Define the format of the data (RGB, RGBA... Engine.TEXTUREFORMAT_xxx)\n     */\n    format, sceneOrEngine, generateMipMaps = true, invertY = false, samplingMode = 3, type = 0, creationFlags, useSRGBBuffer) {\n        super(null, sceneOrEngine, !generateMipMaps, invertY, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, creationFlags);\n        this.format = format;\n        if (!this._engine) {\n            return;\n        }\n        if (!this._engine._caps.textureFloatLinearFiltering && type === 1) {\n            samplingMode = 1;\n        }\n        if (!this._engine._caps.textureHalfFloatLinearFiltering && type === 2) {\n            samplingMode = 1;\n        }\n        this._texture = this._engine.createRawTexture(data, width, height, format, generateMipMaps, invertY, samplingMode, null, type, creationFlags !== null && creationFlags !== void 0 ? creationFlags : 0, useSRGBBuffer !== null && useSRGBBuffer !== void 0 ? useSRGBBuffer : false);\n        this.wrapU = Texture.CLAMP_ADDRESSMODE;\n        this.wrapV = Texture.CLAMP_ADDRESSMODE;\n    }\n    /**\n     * Updates the texture underlying data.\n     * @param data Define the new data of the texture\n     */\n    update(data) {\n        this._getEngine().updateRawTexture(this._texture, data, this._texture.format, this._texture.invertY, null, this._texture.type, this._texture._useSRGBBuffer);\n    }\n    /**\n     * Creates a luminance texture from some data.\n     * @param data Define the texture data\n     * @param width Define the width of the texture\n     * @param height Define the height of the texture\n     * @param sceneOrEngine defines the scene or engine the texture will belong to\n     * @param generateMipMaps Define whether or not to create mip maps for the texture\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\n     * @returns the luminance texture\n     */\n    static CreateLuminanceTexture(data, width, height, sceneOrEngine, generateMipMaps = true, invertY = false, samplingMode = 3) {\n        return new RawTexture(data, width, height, 1, sceneOrEngine, generateMipMaps, invertY, samplingMode);\n    }\n    /**\n     * Creates a luminance alpha texture from some data.\n     * @param data Define the texture data\n     * @param width Define the width of the texture\n     * @param height Define the height of the texture\n     * @param sceneOrEngine defines the scene or engine the texture will belong to\n     * @param generateMipMaps Define whether or not to create mip maps for the texture\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\n     * @returns the luminance alpha texture\n     */\n    static CreateLuminanceAlphaTexture(data, width, height, sceneOrEngine, generateMipMaps = true, invertY = false, samplingMode = 3) {\n        return new RawTexture(data, width, height, 2, sceneOrEngine, generateMipMaps, invertY, samplingMode);\n    }\n    /**\n     * Creates an alpha texture from some data.\n     * @param data Define the texture data\n     * @param width Define the width of the texture\n     * @param height Define the height of the texture\n     * @param sceneOrEngine defines the scene or engine the texture will belong to\n     * @param generateMipMaps Define whether or not to create mip maps for the texture\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\n     * @returns the alpha texture\n     */\n    static CreateAlphaTexture(data, width, height, sceneOrEngine, generateMipMaps = true, invertY = false, samplingMode = 3) {\n        return new RawTexture(data, width, height, 0, sceneOrEngine, generateMipMaps, invertY, samplingMode);\n    }\n    /**\n     * Creates a RGB texture from some data.\n     * @param data Define the texture data\n     * @param width Define the width of the texture\n     * @param height Define the height of the texture\n     * @param sceneOrEngine defines the scene or engine the texture will belong to\n     * @param generateMipMaps Define whether or not to create mip maps for the texture\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\n     * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)\n     * @param creationFlags specific flags to use when creating the texture (1 for storage textures, for eg)\n     * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).\n     * @returns the RGB alpha texture\n     */\n    static CreateRGBTexture(data, width, height, sceneOrEngine, generateMipMaps = true, invertY = false, samplingMode = 3, type = 0, creationFlags = 0, useSRGBBuffer = false) {\n        return new RawTexture(data, width, height, 4, sceneOrEngine, generateMipMaps, invertY, samplingMode, type, creationFlags, useSRGBBuffer);\n    }\n    /**\n     * Creates a RGBA texture from some data.\n     * @param data Define the texture data\n     * @param width Define the width of the texture\n     * @param height Define the height of the texture\n     * @param sceneOrEngine defines the scene or engine the texture will belong to\n     * @param generateMipMaps Define whether or not to create mip maps for the texture\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\n     * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)\n     * @param creationFlags specific flags to use when creating the texture (1 for storage textures, for eg)\n     * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).\n     * @returns the RGBA texture\n     */\n    static CreateRGBATexture(data, width, height, sceneOrEngine, generateMipMaps = true, invertY = false, samplingMode = 3, type = 0, creationFlags = 0, useSRGBBuffer = false) {\n        return new RawTexture(data, width, height, 5, sceneOrEngine, generateMipMaps, invertY, samplingMode, type, creationFlags, useSRGBBuffer);\n    }\n    /**\n     * Creates a RGBA storage texture from some data.\n     * @param data Define the texture data\n     * @param width Define the width of the texture\n     * @param height Define the height of the texture\n     * @param sceneOrEngine defines the scene or engine the texture will belong to\n     * @param generateMipMaps Define whether or not to create mip maps for the texture\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\n     * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)\n     * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).\n     * @returns the RGBA texture\n     */\n    static CreateRGBAStorageTexture(data, width, height, sceneOrEngine, generateMipMaps = true, invertY = false, samplingMode = 3, type = 0, useSRGBBuffer = false) {\n        return new RawTexture(data, width, height, 5, sceneOrEngine, generateMipMaps, invertY, samplingMode, type, 1, useSRGBBuffer);\n    }\n    /**\n     * Creates a R texture from some data.\n     * @param data Define the texture data\n     * @param width Define the width of the texture\n     * @param height Define the height of the texture\n     * @param sceneOrEngine defines the scene or engine the texture will belong to\n     * @param generateMipMaps Define whether or not to create mip maps for the texture\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\n     * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)\n     * @returns the R texture\n     */\n    static CreateRTexture(data, width, height, sceneOrEngine, generateMipMaps = true, invertY = false, samplingMode = Texture.TRILINEAR_SAMPLINGMODE, type = 1) {\n        return new RawTexture(data, width, height, 6, sceneOrEngine, generateMipMaps, invertY, samplingMode, type);\n    }\n    /**\n     * Creates a R storage texture from some data.\n     * @param data Define the texture data\n     * @param width Define the width of the texture\n     * @param height Define the height of the texture\n     * @param sceneOrEngine defines the scene or engine the texture will belong to\n     * @param generateMipMaps Define whether or not to create mip maps for the texture\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\n     * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)\n     * @returns the R texture\n     */\n    static CreateRStorageTexture(data, width, height, sceneOrEngine, generateMipMaps = true, invertY = false, samplingMode = Texture.TRILINEAR_SAMPLINGMODE, type = 1) {\n        return new RawTexture(data, width, height, 6, sceneOrEngine, generateMipMaps, invertY, samplingMode, type, 1);\n    }\n}\n//# sourceMappingURL=rawTexture.js.map","import { Texture } from \"./texture.js\";\n\nimport \"../../Engines/Extensions/engine.rawTexture.js\";\n/**\n * Class used to store 2D array textures containing user data\n */\nexport class RawTexture2DArray extends Texture {\n    /**\n     * Gets the number of layers of the texture\n     */\n    get depth() {\n        return this._depth;\n    }\n    /**\n     * Create a new RawTexture2DArray\n     * @param data defines the data of the texture\n     * @param width defines the width of the texture\n     * @param height defines the height of the texture\n     * @param depth defines the number of layers of the texture\n     * @param format defines the texture format to use\n     * @param scene defines the hosting scene\n     * @param generateMipMaps defines a boolean indicating if mip levels should be generated (true by default)\n     * @param invertY defines if texture must be stored with Y axis inverted\n     * @param samplingMode defines the sampling mode to use (Texture.TRILINEAR_SAMPLINGMODE by default)\n     * @param textureType defines the texture Type (Engine.TEXTURETYPE_UNSIGNED_INT, Engine.TEXTURETYPE_FLOAT...)\n     */\n    constructor(data, width, height, depth, \n    /** Gets or sets the texture format to use */\n    format, scene, generateMipMaps = true, invertY = false, samplingMode = Texture.TRILINEAR_SAMPLINGMODE, textureType = 0) {\n        super(null, scene, !generateMipMaps, invertY);\n        this.format = format;\n        this._texture = scene.getEngine().createRawTexture2DArray(data, width, height, depth, format, generateMipMaps, invertY, samplingMode, null, textureType);\n        this._depth = depth;\n        this.is2DArray = true;\n    }\n    /**\n     * Update the texture with new data\n     * @param data defines the data to store in the texture\n     */\n    update(data) {\n        if (!this._texture) {\n            return;\n        }\n        this._getEngine().updateRawTexture2DArray(this._texture, data, this._texture.format, this._texture.invertY, null, this._texture.type);\n    }\n    /**\n     * Creates a RGBA texture from some data.\n     * @param data Define the texture data\n     * @param width Define the width of the texture\n     * @param height Define the height of the texture\n     * @param depth defines the number of layers of the texture\n     * @param scene defines the scene the texture will belong to\n     * @param generateMipMaps Define whether or not to create mip maps for the texture\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\n     * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)\n     * @returns the RGBA texture\n     */\n    static CreateRGBATexture(data, width, height, depth, scene, generateMipMaps = true, invertY = false, samplingMode = 3, type = 0) {\n        return new RawTexture2DArray(data, width, height, depth, 5, scene, generateMipMaps, invertY, samplingMode, type);\n    }\n}\n//# sourceMappingURL=rawTexture2DArray.js.map","import { Observable } from \"../../Misc/observable.js\";\nimport { Matrix, Vector3 } from \"../../Maths/math.vector.js\";\nimport { Texture } from \"../../Materials/Textures/texture.js\";\nimport { PostProcessManager } from \"../../PostProcesses/postProcessManager.js\";\nimport { RenderingManager } from \"../../Rendering/renderingManager.js\";\n\nimport \"../../Engines/Extensions/engine.renderTarget.js\";\nimport \"../../Engines/Extensions/engine.renderTargetCube.js\";\nimport { Engine } from \"../../Engines/engine.js\";\nimport { _ObserveArray } from \"../../Misc/arrayTools.js\";\nimport { DumpTools } from \"../../Misc/dumpTools.js\";\n/**\n * This Helps creating a texture that will be created from a camera in your scene.\n * It is basically a dynamic texture that could be used to create special effects for instance.\n * Actually, It is the base of lot of effects in the framework like post process, shadows, effect layers and rendering pipelines...\n */\nexport class RenderTargetTexture extends Texture {\n    /**\n     * Use this list to define the list of mesh you want to render.\n     */\n    get renderList() {\n        return this._renderList;\n    }\n    set renderList(value) {\n        if (this._unObserveRenderList) {\n            this._unObserveRenderList();\n            this._unObserveRenderList = null;\n        }\n        if (value) {\n            this._unObserveRenderList = _ObserveArray(value, this._renderListHasChanged);\n        }\n        this._renderList = value;\n    }\n    /**\n     * Post-processes for this render target\n     */\n    get postProcesses() {\n        return this._postProcesses;\n    }\n    get _prePassEnabled() {\n        return !!this._prePassRenderTarget && this._prePassRenderTarget.enabled;\n    }\n    /**\n     * Set a after unbind callback in the texture.\n     * This has been kept for backward compatibility and use of onAfterUnbindObservable is recommended.\n     */\n    set onAfterUnbind(callback) {\n        if (this._onAfterUnbindObserver) {\n            this.onAfterUnbindObservable.remove(this._onAfterUnbindObserver);\n        }\n        this._onAfterUnbindObserver = this.onAfterUnbindObservable.add(callback);\n    }\n    /**\n     * Set a before render callback in the texture.\n     * This has been kept for backward compatibility and use of onBeforeRenderObservable is recommended.\n     */\n    set onBeforeRender(callback) {\n        if (this._onBeforeRenderObserver) {\n            this.onBeforeRenderObservable.remove(this._onBeforeRenderObserver);\n        }\n        this._onBeforeRenderObserver = this.onBeforeRenderObservable.add(callback);\n    }\n    /**\n     * Set a after render callback in the texture.\n     * This has been kept for backward compatibility and use of onAfterRenderObservable is recommended.\n     */\n    set onAfterRender(callback) {\n        if (this._onAfterRenderObserver) {\n            this.onAfterRenderObservable.remove(this._onAfterRenderObserver);\n        }\n        this._onAfterRenderObserver = this.onAfterRenderObservable.add(callback);\n    }\n    /**\n     * Set a clear callback in the texture.\n     * This has been kept for backward compatibility and use of onClearObservable is recommended.\n     */\n    set onClear(callback) {\n        if (this._onClearObserver) {\n            this.onClearObservable.remove(this._onClearObserver);\n        }\n        this._onClearObserver = this.onClearObservable.add(callback);\n    }\n    /**\n     * Gets the render pass ids used by the render target texture. For a single render target the array length will be 1, for a cube texture it will be 6 and for\n     * a 2D texture array it will return an array of ids the size of the 2D texture array\n     */\n    get renderPassIds() {\n        return this._renderPassIds;\n    }\n    /**\n     * Gets the current value of the refreshId counter\n     */\n    get currentRefreshId() {\n        return this._currentRefreshId;\n    }\n    /**\n     * Sets a specific material to be used to render a mesh/a list of meshes in this render target texture\n     * @param mesh mesh or array of meshes\n     * @param material material or array of materials to use for this render pass. If undefined is passed, no specific material will be used but the regular material instead (mesh.material). It's possible to provide an array of materials to use a different material for each rendering in the case of a cube texture (6 rendering) and a 2D texture array (as many rendering as the length of the array)\n     */\n    setMaterialForRendering(mesh, material) {\n        let meshes;\n        if (!Array.isArray(mesh)) {\n            meshes = [mesh];\n        }\n        else {\n            meshes = mesh;\n        }\n        for (let j = 0; j < meshes.length; ++j) {\n            for (let i = 0; i < this._renderPassIds.length; ++i) {\n                meshes[j].setMaterialForRenderPass(this._renderPassIds[i], material !== undefined ? (Array.isArray(material) ? material[i] : material) : undefined);\n            }\n        }\n    }\n    /**\n     * Gets render target creation options that were used.\n     */\n    get renderTargetOptions() {\n        return this._renderTargetOptions;\n    }\n    /**\n     * Gets the render target wrapper associated with this render target\n     */\n    get renderTarget() {\n        return this._renderTarget;\n    }\n    _onRatioRescale() {\n        if (this._sizeRatio) {\n            this.resize(this._initialSizeParameter);\n        }\n    }\n    /**\n     * Gets or sets the size of the bounding box associated with the texture (when in cube mode)\n     * When defined, the cubemap will switch to local mode\n     * @see https://community.arm.com/graphics/b/blog/posts/reflections-based-on-local-cubemaps-in-unity\n     * @example https://www.babylonjs-playground.com/#RNASML\n     */\n    set boundingBoxSize(value) {\n        if (this._boundingBoxSize && this._boundingBoxSize.equals(value)) {\n            return;\n        }\n        this._boundingBoxSize = value;\n        const scene = this.getScene();\n        if (scene) {\n            scene.markAllMaterialsAsDirty(1);\n        }\n    }\n    get boundingBoxSize() {\n        return this._boundingBoxSize;\n    }\n    /**\n     * In case the RTT has been created with a depth texture, get the associated\n     * depth texture.\n     * Otherwise, return null.\n     */\n    get depthStencilTexture() {\n        var _a, _b;\n        return (_b = (_a = this._renderTarget) === null || _a === void 0 ? void 0 : _a._depthStencilTexture) !== null && _b !== void 0 ? _b : null;\n    }\n    /** @internal */\n    constructor(name, size, scene, generateMipMaps = false, doNotChangeAspectRatio = true, type = 0, isCube = false, samplingMode = Texture.TRILINEAR_SAMPLINGMODE, generateDepthBuffer = true, generateStencilBuffer = false, isMulti = false, format = 5, delayAllocation = false, samples, creationFlags, noColorAttachment = false, useSRGBBuffer = false) {\n        var _a, _b, _c, _d, _e, _f;\n        let colorAttachment = undefined;\n        if (typeof generateMipMaps === \"object\") {\n            const options = generateMipMaps;\n            generateMipMaps = !!options.generateMipMaps;\n            doNotChangeAspectRatio = (_a = options.doNotChangeAspectRatio) !== null && _a !== void 0 ? _a : true;\n            type = (_b = options.type) !== null && _b !== void 0 ? _b : 0;\n            isCube = !!options.isCube;\n            samplingMode = (_c = options.samplingMode) !== null && _c !== void 0 ? _c : Texture.TRILINEAR_SAMPLINGMODE;\n            generateDepthBuffer = (_d = options.generateDepthBuffer) !== null && _d !== void 0 ? _d : true;\n            generateStencilBuffer = !!options.generateStencilBuffer;\n            isMulti = !!options.isMulti;\n            format = (_e = options.format) !== null && _e !== void 0 ? _e : 5;\n            delayAllocation = !!options.delayAllocation;\n            samples = options.samples;\n            creationFlags = options.creationFlags;\n            noColorAttachment = !!options.noColorAttachment;\n            useSRGBBuffer = !!options.useSRGBBuffer;\n            colorAttachment = options.colorAttachment;\n        }\n        super(null, scene, !generateMipMaps, undefined, samplingMode, undefined, undefined, undefined, undefined, format);\n        this._unObserveRenderList = null;\n        this._renderListHasChanged = (_functionName, previousLength) => {\n            var _a;\n            const newLength = this._renderList ? this._renderList.length : 0;\n            if ((previousLength === 0 && newLength > 0) || newLength === 0) {\n                (_a = this.getScene()) === null || _a === void 0 ? void 0 : _a.meshes.forEach((mesh) => {\n                    mesh._markSubMeshesAsLightDirty();\n                });\n            }\n        };\n        /**\n         * Define if particles should be rendered in your texture.\n         */\n        this.renderParticles = true;\n        /**\n         * Define if sprites should be rendered in your texture.\n         */\n        this.renderSprites = false;\n        /**\n         * Force checking the layerMask property even if a custom list of meshes is provided (ie. if renderList is not undefined)\n         */\n        this.forceLayerMaskCheck = false;\n        /**\n         * Define if the camera viewport should be respected while rendering the texture or if the render should be done to the entire texture.\n         */\n        this.ignoreCameraViewport = false;\n        /**\n         * An event triggered when the texture is unbind.\n         */\n        this.onBeforeBindObservable = new Observable();\n        /**\n         * An event triggered when the texture is unbind.\n         */\n        this.onAfterUnbindObservable = new Observable();\n        /**\n         * An event triggered before rendering the texture\n         */\n        this.onBeforeRenderObservable = new Observable();\n        /**\n         * An event triggered after rendering the texture\n         */\n        this.onAfterRenderObservable = new Observable();\n        /**\n         * An event triggered after the texture clear\n         */\n        this.onClearObservable = new Observable();\n        /**\n         * An event triggered when the texture is resized.\n         */\n        this.onResizeObservable = new Observable();\n        /** @internal */\n        this._cleared = false;\n        /**\n         * Skip the initial clear of the rtt at the beginning of the frame render loop\n         */\n        this.skipInitialClear = false;\n        this._currentRefreshId = -1;\n        this._refreshRate = 1;\n        this._samples = 1;\n        this._canRescale = true;\n        this._renderTarget = null;\n        /**\n         * Gets or sets the center of the bounding box associated with the texture (when in cube mode)\n         * It must define where the camera used to render the texture is set\n         */\n        this.boundingBoxPosition = Vector3.Zero();\n        scene = this.getScene();\n        if (!scene) {\n            return;\n        }\n        const engine = this.getScene().getEngine();\n        this._coordinatesMode = Texture.PROJECTION_MODE;\n        this.renderList = new Array();\n        this.name = name;\n        this.isRenderTarget = true;\n        this._initialSizeParameter = size;\n        this._renderPassIds = [];\n        this._isCubeData = isCube;\n        this._processSizeParameter(size);\n        this.renderPassId = this._renderPassIds[0];\n        this._resizeObserver = engine.onResizeObservable.add(() => { });\n        this._generateMipMaps = generateMipMaps ? true : false;\n        this._doNotChangeAspectRatio = doNotChangeAspectRatio;\n        // Rendering groups\n        this._renderingManager = new RenderingManager(scene);\n        this._renderingManager._useSceneAutoClearSetup = true;\n        if (isMulti) {\n            return;\n        }\n        this._renderTargetOptions = {\n            generateMipMaps: generateMipMaps,\n            type: type,\n            format: (_f = this._format) !== null && _f !== void 0 ? _f : undefined,\n            samplingMode: this.samplingMode,\n            generateDepthBuffer: generateDepthBuffer,\n            generateStencilBuffer: generateStencilBuffer,\n            samples,\n            creationFlags,\n            noColorAttachment: noColorAttachment,\n            useSRGBBuffer,\n            colorAttachment: colorAttachment,\n        };\n        if (this.samplingMode === Texture.NEAREST_SAMPLINGMODE) {\n            this.wrapU = Texture.CLAMP_ADDRESSMODE;\n            this.wrapV = Texture.CLAMP_ADDRESSMODE;\n        }\n        if (!delayAllocation) {\n            if (isCube) {\n                this._renderTarget = scene.getEngine().createRenderTargetCubeTexture(this.getRenderSize(), this._renderTargetOptions);\n                this.coordinatesMode = Texture.INVCUBIC_MODE;\n                this._textureMatrix = Matrix.Identity();\n            }\n            else {\n                this._renderTarget = scene.getEngine().createRenderTargetTexture(this._size, this._renderTargetOptions);\n            }\n            this._texture = this._renderTarget.texture;\n            if (samples !== undefined) {\n                this.samples = samples;\n            }\n        }\n    }\n    /**\n     * Creates a depth stencil texture.\n     * This is only available in WebGL 2 or with the depth texture extension available.\n     * @param comparisonFunction Specifies the comparison function to set on the texture. If 0 or undefined, the texture is not in comparison mode (default: 0)\n     * @param bilinearFiltering Specifies whether or not bilinear filtering is enable on the texture (default: true)\n     * @param generateStencil Specifies whether or not a stencil should be allocated in the texture (default: false)\n     * @param samples sample count of the depth/stencil texture (default: 1)\n     * @param format format of the depth texture (default: 14)\n     */\n    createDepthStencilTexture(comparisonFunction = 0, bilinearFiltering = true, generateStencil = false, samples = 1, format = 14) {\n        var _a;\n        (_a = this._renderTarget) === null || _a === void 0 ? void 0 : _a.createDepthStencilTexture(comparisonFunction, bilinearFiltering, generateStencil, samples, format);\n    }\n    _releaseRenderPassId() {\n        if (this._scene) {\n            const engine = this._scene.getEngine();\n            for (let i = 0; i < this._renderPassIds.length; ++i) {\n                engine.releaseRenderPassId(this._renderPassIds[i]);\n            }\n        }\n        this._renderPassIds = [];\n    }\n    _createRenderPassId() {\n        this._releaseRenderPassId();\n        const engine = this._scene.getEngine(); // scene can't be null in a RenderTargetTexture, see constructor\n        const numPasses = this._isCubeData ? 6 : this.getRenderLayers() || 1;\n        for (let i = 0; i < numPasses; ++i) {\n            this._renderPassIds[i] = engine.createRenderPassId(`RenderTargetTexture - ${this.name}#${i}`);\n        }\n    }\n    _processSizeParameter(size) {\n        if (size.ratio) {\n            this._sizeRatio = size.ratio;\n            const engine = this._getEngine();\n            this._size = {\n                width: this._bestReflectionRenderTargetDimension(engine.getRenderWidth(), this._sizeRatio),\n                height: this._bestReflectionRenderTargetDimension(engine.getRenderHeight(), this._sizeRatio),\n            };\n        }\n        else {\n            this._size = size;\n        }\n        this._createRenderPassId();\n    }\n    /**\n     * Define the number of samples to use in case of MSAA.\n     * It defaults to one meaning no MSAA has been enabled.\n     */\n    get samples() {\n        var _a, _b;\n        return (_b = (_a = this._renderTarget) === null || _a === void 0 ? void 0 : _a.samples) !== null && _b !== void 0 ? _b : this._samples;\n    }\n    set samples(value) {\n        if (this._renderTarget) {\n            this._samples = this._renderTarget.setSamples(value);\n        }\n    }\n    /**\n     * Resets the refresh counter of the texture and start bak from scratch.\n     * Could be useful to regenerate the texture if it is setup to render only once.\n     */\n    resetRefreshCounter() {\n        this._currentRefreshId = -1;\n    }\n    /**\n     * Define the refresh rate of the texture or the rendering frequency.\n     * Use 0 to render just once, 1 to render on every frame, 2 to render every two frames and so on...\n     */\n    get refreshRate() {\n        return this._refreshRate;\n    }\n    set refreshRate(value) {\n        this._refreshRate = value;\n        this.resetRefreshCounter();\n    }\n    /**\n     * Adds a post process to the render target rendering passes.\n     * @param postProcess define the post process to add\n     */\n    addPostProcess(postProcess) {\n        if (!this._postProcessManager) {\n            const scene = this.getScene();\n            if (!scene) {\n                return;\n            }\n            this._postProcessManager = new PostProcessManager(scene);\n            this._postProcesses = new Array();\n        }\n        this._postProcesses.push(postProcess);\n        this._postProcesses[0].autoClear = false;\n    }\n    /**\n     * Clear all the post processes attached to the render target\n     * @param dispose define if the cleared post processes should also be disposed (false by default)\n     */\n    clearPostProcesses(dispose = false) {\n        if (!this._postProcesses) {\n            return;\n        }\n        if (dispose) {\n            for (const postProcess of this._postProcesses) {\n                postProcess.dispose();\n            }\n        }\n        this._postProcesses = [];\n    }\n    /**\n     * Remove one of the post process from the list of attached post processes to the texture\n     * @param postProcess define the post process to remove from the list\n     */\n    removePostProcess(postProcess) {\n        if (!this._postProcesses) {\n            return;\n        }\n        const index = this._postProcesses.indexOf(postProcess);\n        if (index === -1) {\n            return;\n        }\n        this._postProcesses.splice(index, 1);\n        if (this._postProcesses.length > 0) {\n            this._postProcesses[0].autoClear = false;\n        }\n    }\n    /** @internal */\n    _shouldRender() {\n        if (this._currentRefreshId === -1) {\n            // At least render once\n            this._currentRefreshId = 1;\n            return true;\n        }\n        if (this.refreshRate === this._currentRefreshId) {\n            this._currentRefreshId = 1;\n            return true;\n        }\n        this._currentRefreshId++;\n        return false;\n    }\n    /**\n     * Gets the actual render size of the texture.\n     * @returns the width of the render size\n     */\n    getRenderSize() {\n        return this.getRenderWidth();\n    }\n    /**\n     * Gets the actual render width of the texture.\n     * @returns the width of the render size\n     */\n    getRenderWidth() {\n        if (this._size.width) {\n            return this._size.width;\n        }\n        return this._size;\n    }\n    /**\n     * Gets the actual render height of the texture.\n     * @returns the height of the render size\n     */\n    getRenderHeight() {\n        if (this._size.width) {\n            return this._size.height;\n        }\n        return this._size;\n    }\n    /**\n     * Gets the actual number of layers of the texture.\n     * @returns the number of layers\n     */\n    getRenderLayers() {\n        const layers = this._size.layers;\n        if (layers) {\n            return layers;\n        }\n        return 0;\n    }\n    /**\n     * Don't allow this render target texture to rescale. Mainly used to prevent rescaling by the scene optimizer.\n     */\n    disableRescaling() {\n        this._canRescale = false;\n    }\n    /**\n     * Get if the texture can be rescaled or not.\n     */\n    get canRescale() {\n        return this._canRescale;\n    }\n    /**\n     * Resize the texture using a ratio.\n     * @param ratio the ratio to apply to the texture size in order to compute the new target size\n     */\n    scale(ratio) {\n        const newSize = Math.max(1, this.getRenderSize() * ratio);\n        this.resize(newSize);\n    }\n    /**\n     * Get the texture reflection matrix used to rotate/transform the reflection.\n     * @returns the reflection matrix\n     */\n    getReflectionTextureMatrix() {\n        if (this.isCube) {\n            return this._textureMatrix;\n        }\n        return super.getReflectionTextureMatrix();\n    }\n    /**\n     * Resize the texture to a new desired size.\n     * Be careful as it will recreate all the data in the new texture.\n     * @param size Define the new size. It can be:\n     *   - a number for squared texture,\n     *   - an object containing { width: number, height: number }\n     *   - or an object containing a ratio { ratio: number }\n     */\n    resize(size) {\n        var _a;\n        const wasCube = this.isCube;\n        (_a = this._renderTarget) === null || _a === void 0 ? void 0 : _a.dispose();\n        this._renderTarget = null;\n        const scene = this.getScene();\n        if (!scene) {\n            return;\n        }\n        this._processSizeParameter(size);\n        if (wasCube) {\n            this._renderTarget = scene.getEngine().createRenderTargetCubeTexture(this.getRenderSize(), this._renderTargetOptions);\n        }\n        else {\n            this._renderTarget = scene.getEngine().createRenderTargetTexture(this._size, this._renderTargetOptions);\n        }\n        this._texture = this._renderTarget.texture;\n        if (this._renderTargetOptions.samples !== undefined) {\n            this.samples = this._renderTargetOptions.samples;\n        }\n        if (this.onResizeObservable.hasObservers()) {\n            this.onResizeObservable.notifyObservers(this);\n        }\n    }\n    /**\n     * Renders all the objects from the render list into the texture.\n     * @param useCameraPostProcess Define if camera post processes should be used during the rendering\n     * @param dumpForDebug Define if the rendering result should be dumped (copied) for debugging purpose\n     */\n    render(useCameraPostProcess = false, dumpForDebug = false) {\n        this._render(useCameraPostProcess, dumpForDebug);\n    }\n    /**\n     * This function will check if the render target texture can be rendered (textures are loaded, shaders are compiled)\n     * @returns true if all required resources are ready\n     */\n    isReadyForRendering() {\n        return this._render(false, false, true);\n    }\n    _render(useCameraPostProcess = false, dumpForDebug = false, checkReadiness = false) {\n        var _a;\n        const scene = this.getScene();\n        if (!scene) {\n            return checkReadiness;\n        }\n        const engine = scene.getEngine();\n        if (this.useCameraPostProcesses !== undefined) {\n            useCameraPostProcess = this.useCameraPostProcesses;\n        }\n        if (this._waitingRenderList) {\n            this.renderList = [];\n            for (let index = 0; index < this._waitingRenderList.length; index++) {\n                const id = this._waitingRenderList[index];\n                const mesh = scene.getMeshById(id);\n                if (mesh) {\n                    this.renderList.push(mesh);\n                }\n            }\n            this._waitingRenderList = undefined;\n        }\n        // Is predicate defined?\n        if (this.renderListPredicate) {\n            if (this.renderList) {\n                this.renderList.length = 0; // Clear previous renderList\n            }\n            else {\n                this.renderList = [];\n            }\n            const scene = this.getScene();\n            if (!scene) {\n                return checkReadiness;\n            }\n            const sceneMeshes = scene.meshes;\n            for (let index = 0; index < sceneMeshes.length; index++) {\n                const mesh = sceneMeshes[index];\n                if (this.renderListPredicate(mesh)) {\n                    this.renderList.push(mesh);\n                }\n            }\n        }\n        const currentRenderPassId = engine.currentRenderPassId;\n        this.onBeforeBindObservable.notifyObservers(this);\n        // Set custom projection.\n        // Needs to be before binding to prevent changing the aspect ratio.\n        const camera = (_a = this.activeCamera) !== null && _a !== void 0 ? _a : scene.activeCamera;\n        const sceneCamera = scene.activeCamera;\n        if (camera) {\n            if (camera !== scene.activeCamera) {\n                scene.setTransformMatrix(camera.getViewMatrix(), camera.getProjectionMatrix(true));\n                scene.activeCamera = camera;\n            }\n            engine.setViewport(camera.viewport, this.getRenderWidth(), this.getRenderHeight());\n        }\n        this._defaultRenderListPrepared = false;\n        let returnValue = checkReadiness;\n        if (!checkReadiness) {\n            if (this.is2DArray) {\n                for (let layer = 0; layer < this.getRenderLayers(); layer++) {\n                    this._renderToTarget(0, useCameraPostProcess, dumpForDebug, layer, camera);\n                    scene.incrementRenderId();\n                    scene.resetCachedMaterial();\n                }\n            }\n            else if (this.isCube) {\n                for (let face = 0; face < 6; face++) {\n                    this._renderToTarget(face, useCameraPostProcess, dumpForDebug, undefined, camera);\n                    scene.incrementRenderId();\n                    scene.resetCachedMaterial();\n                }\n            }\n            else {\n                this._renderToTarget(0, useCameraPostProcess, dumpForDebug, undefined, camera);\n            }\n        }\n        else {\n            if (!scene.getViewMatrix()) {\n                // We probably didn't execute scene.render() yet, so make sure we have a view/projection matrix setup for the scene\n                scene.updateTransformMatrix();\n            }\n            const numLayers = this.is2DArray ? this.getRenderLayers() : this.isCube ? 6 : 1;\n            for (let layer = 0; layer < numLayers && returnValue; layer++) {\n                let currentRenderList = null;\n                const defaultRenderList = this.renderList ? this.renderList : scene.getActiveMeshes().data;\n                const defaultRenderListLength = this.renderList ? this.renderList.length : scene.getActiveMeshes().length;\n                engine.currentRenderPassId = this._renderPassIds[layer];\n                this.onBeforeRenderObservable.notifyObservers(layer);\n                if (this.getCustomRenderList) {\n                    currentRenderList = this.getCustomRenderList(layer, defaultRenderList, defaultRenderListLength);\n                }\n                if (!currentRenderList) {\n                    currentRenderList = defaultRenderList;\n                }\n                if (!this._doNotChangeAspectRatio) {\n                    scene.updateTransformMatrix(true);\n                }\n                for (let i = 0; i < currentRenderList.length && returnValue; ++i) {\n                    const mesh = currentRenderList[i];\n                    if (!mesh.isEnabled() || mesh.isBlocked || !mesh.isVisible || !mesh.subMeshes) {\n                        continue;\n                    }\n                    if (this.customIsReadyFunction) {\n                        if (!this.customIsReadyFunction(mesh, this.refreshRate, checkReadiness)) {\n                            returnValue = false;\n                            continue;\n                        }\n                    }\n                    else if (!mesh.isReady(true)) {\n                        returnValue = false;\n                        continue;\n                    }\n                }\n                this.onAfterRenderObservable.notifyObservers(layer);\n                if (this.is2DArray || this.isCube) {\n                    scene.incrementRenderId();\n                    scene.resetCachedMaterial();\n                }\n            }\n        }\n        this.onAfterUnbindObservable.notifyObservers(this);\n        engine.currentRenderPassId = currentRenderPassId;\n        if (sceneCamera) {\n            scene.activeCamera = sceneCamera;\n            // Do not avoid setting uniforms when multiple scenes are active as another camera may have overwrite these\n            if (scene.getEngine().scenes.length > 1 || (this.activeCamera && this.activeCamera !== scene.activeCamera)) {\n                scene.setTransformMatrix(scene.activeCamera.getViewMatrix(), scene.activeCamera.getProjectionMatrix(true));\n            }\n            engine.setViewport(scene.activeCamera.viewport);\n        }\n        scene.resetCachedMaterial();\n        return returnValue;\n    }\n    _bestReflectionRenderTargetDimension(renderDimension, scale) {\n        const minimum = 128;\n        const x = renderDimension * scale;\n        const curved = Engine.NearestPOT(x + (minimum * minimum) / (minimum + x));\n        // Ensure we don't exceed the render dimension (while staying POT)\n        return Math.min(Engine.FloorPOT(renderDimension), curved);\n    }\n    _prepareRenderingManager(currentRenderList, currentRenderListLength, camera, checkLayerMask) {\n        const scene = this.getScene();\n        if (!scene) {\n            return;\n        }\n        this._renderingManager.reset();\n        const sceneRenderId = scene.getRenderId();\n        for (let meshIndex = 0; meshIndex < currentRenderListLength; meshIndex++) {\n            const mesh = currentRenderList[meshIndex];\n            if (mesh && !mesh.isBlocked) {\n                if (this.customIsReadyFunction) {\n                    if (!this.customIsReadyFunction(mesh, this.refreshRate, false)) {\n                        this.resetRefreshCounter();\n                        continue;\n                    }\n                }\n                else if (!mesh.isReady(this.refreshRate === 0)) {\n                    this.resetRefreshCounter();\n                    continue;\n                }\n                if (!mesh._internalAbstractMeshDataInfo._currentLODIsUpToDate && scene.activeCamera) {\n                    mesh._internalAbstractMeshDataInfo._currentLOD = scene.customLODSelector\n                        ? scene.customLODSelector(mesh, this.activeCamera || scene.activeCamera)\n                        : mesh.getLOD(this.activeCamera || scene.activeCamera);\n                    mesh._internalAbstractMeshDataInfo._currentLODIsUpToDate = true;\n                }\n                if (!mesh._internalAbstractMeshDataInfo._currentLOD) {\n                    continue;\n                }\n                let meshToRender = mesh._internalAbstractMeshDataInfo._currentLOD;\n                meshToRender._preActivateForIntermediateRendering(sceneRenderId);\n                let isMasked;\n                if (checkLayerMask && camera) {\n                    isMasked = (mesh.layerMask & camera.layerMask) === 0;\n                }\n                else {\n                    isMasked = false;\n                }\n                if (mesh.isEnabled() && mesh.isVisible && mesh.subMeshes && !isMasked) {\n                    if (meshToRender !== mesh) {\n                        meshToRender._activate(sceneRenderId, true);\n                    }\n                    if (mesh._activate(sceneRenderId, true) && mesh.subMeshes.length) {\n                        if (!mesh.isAnInstance) {\n                            meshToRender._internalAbstractMeshDataInfo._onlyForInstancesIntermediate = false;\n                        }\n                        else {\n                            if (mesh._internalAbstractMeshDataInfo._actAsRegularMesh) {\n                                meshToRender = mesh;\n                            }\n                        }\n                        meshToRender._internalAbstractMeshDataInfo._isActiveIntermediate = true;\n                        for (let subIndex = 0; subIndex < meshToRender.subMeshes.length; subIndex++) {\n                            const subMesh = meshToRender.subMeshes[subIndex];\n                            this._renderingManager.dispatch(subMesh, meshToRender);\n                        }\n                    }\n                }\n            }\n        }\n        for (let particleIndex = 0; particleIndex < scene.particleSystems.length; particleIndex++) {\n            const particleSystem = scene.particleSystems[particleIndex];\n            const emitter = particleSystem.emitter;\n            if (!particleSystem.isStarted() || !emitter || !emitter.position || !emitter.isEnabled()) {\n                continue;\n            }\n            if (currentRenderList.indexOf(emitter) >= 0) {\n                this._renderingManager.dispatchParticles(particleSystem);\n            }\n        }\n    }\n    /**\n     * @internal\n     * @param faceIndex face index to bind to if this is a cubetexture\n     * @param layer defines the index of the texture to bind in the array\n     */\n    _bindFrameBuffer(faceIndex = 0, layer = 0) {\n        const scene = this.getScene();\n        if (!scene) {\n            return;\n        }\n        const engine = scene.getEngine();\n        if (this._renderTarget) {\n            engine.bindFramebuffer(this._renderTarget, this.isCube ? faceIndex : undefined, undefined, undefined, this.ignoreCameraViewport, 0, layer);\n        }\n    }\n    _unbindFrameBuffer(engine, faceIndex) {\n        if (!this._renderTarget) {\n            return;\n        }\n        engine.unBindFramebuffer(this._renderTarget, this.isCube, () => {\n            this.onAfterRenderObservable.notifyObservers(faceIndex);\n        });\n    }\n    /**\n     * @internal\n     */\n    _prepareFrame(scene, faceIndex, layer, useCameraPostProcess) {\n        if (this._postProcessManager) {\n            if (!this._prePassEnabled) {\n                this._postProcessManager._prepareFrame(this._texture, this._postProcesses);\n            }\n        }\n        else if (!useCameraPostProcess || !scene.postProcessManager._prepareFrame(this._texture)) {\n            this._bindFrameBuffer(faceIndex, layer);\n        }\n    }\n    _renderToTarget(faceIndex, useCameraPostProcess, dumpForDebug, layer = 0, camera = null) {\n        var _a, _b, _c, _d, _e, _f;\n        const scene = this.getScene();\n        if (!scene) {\n            return;\n        }\n        const engine = scene.getEngine();\n        (_a = engine._debugPushGroup) === null || _a === void 0 ? void 0 : _a.call(engine, `render to face #${faceIndex} layer #${layer}`, 1);\n        // Bind\n        this._prepareFrame(scene, faceIndex, layer, useCameraPostProcess);\n        if (this.is2DArray) {\n            engine.currentRenderPassId = this._renderPassIds[layer];\n            this.onBeforeRenderObservable.notifyObservers(layer);\n        }\n        else {\n            engine.currentRenderPassId = this._renderPassIds[faceIndex];\n            this.onBeforeRenderObservable.notifyObservers(faceIndex);\n        }\n        const fastPath = engine.snapshotRendering && engine.snapshotRenderingMode === 1;\n        if (!fastPath) {\n            // Get the list of meshes to render\n            let currentRenderList = null;\n            const defaultRenderList = this.renderList ? this.renderList : scene.getActiveMeshes().data;\n            const defaultRenderListLength = this.renderList ? this.renderList.length : scene.getActiveMeshes().length;\n            if (this.getCustomRenderList) {\n                currentRenderList = this.getCustomRenderList(this.is2DArray ? layer : faceIndex, defaultRenderList, defaultRenderListLength);\n            }\n            if (!currentRenderList) {\n                // No custom render list provided, we prepare the rendering for the default list, but check\n                // first if we did not already performed the preparation before so as to avoid re-doing it several times\n                if (!this._defaultRenderListPrepared) {\n                    this._prepareRenderingManager(defaultRenderList, defaultRenderListLength, camera, !this.renderList || this.forceLayerMaskCheck);\n                    this._defaultRenderListPrepared = true;\n                }\n                currentRenderList = defaultRenderList;\n            }\n            else {\n                // Prepare the rendering for the custom render list provided\n                this._prepareRenderingManager(currentRenderList, currentRenderList.length, camera, this.forceLayerMaskCheck);\n            }\n            // Before clear\n            for (const step of scene._beforeRenderTargetClearStage) {\n                step.action(this, faceIndex, layer);\n            }\n            // Clear\n            if (this.onClearObservable.hasObservers()) {\n                this.onClearObservable.notifyObservers(engine);\n            }\n            else {\n                if (!this.skipInitialClear) {\n                    engine.clear(this.clearColor || scene.clearColor, true, true, true);\n                }\n            }\n            if (!this._doNotChangeAspectRatio) {\n                scene.updateTransformMatrix(true);\n            }\n            // Before Camera Draw\n            for (const step of scene._beforeRenderTargetDrawStage) {\n                step.action(this, faceIndex, layer);\n            }\n            // Render\n            this._renderingManager.render(this.customRenderFunction, currentRenderList, this.renderParticles, this.renderSprites);\n            // After Camera Draw\n            for (const step of scene._afterRenderTargetDrawStage) {\n                step.action(this, faceIndex, layer);\n            }\n            const saveGenerateMipMaps = (_c = (_b = this._texture) === null || _b === void 0 ? void 0 : _b.generateMipMaps) !== null && _c !== void 0 ? _c : false;\n            if (this._texture) {\n                this._texture.generateMipMaps = false; // if left true, the mipmaps will be generated (if this._texture.generateMipMaps = true) when the first post process binds its own RTT: by doing so it will unbind the current RTT,\n                // which will trigger a mipmap generation. We don't want this because it's a wasted work, we will do an unbind of the current RTT at the end of the process (see unbindFrameBuffer) which will\n                // trigger the generation of the final mipmaps\n            }\n            if (this._postProcessManager) {\n                this._postProcessManager._finalizeFrame(false, (_d = this._renderTarget) !== null && _d !== void 0 ? _d : undefined, faceIndex, this._postProcesses, this.ignoreCameraViewport);\n            }\n            else if (useCameraPostProcess) {\n                scene.postProcessManager._finalizeFrame(false, (_e = this._renderTarget) !== null && _e !== void 0 ? _e : undefined, faceIndex);\n            }\n            for (const step of scene._afterRenderTargetPostProcessStage) {\n                step.action(this, faceIndex, layer);\n            }\n            if (this._texture) {\n                this._texture.generateMipMaps = saveGenerateMipMaps;\n            }\n            if (!this._doNotChangeAspectRatio) {\n                scene.updateTransformMatrix(true);\n            }\n            // Dump ?\n            if (dumpForDebug) {\n                DumpTools.DumpFramebuffer(this.getRenderWidth(), this.getRenderHeight(), engine);\n            }\n        }\n        else {\n            // Clear\n            if (this.onClearObservable.hasObservers()) {\n                this.onClearObservable.notifyObservers(engine);\n            }\n            else {\n                if (!this.skipInitialClear) {\n                    engine.clear(this.clearColor || scene.clearColor, true, true, true);\n                }\n            }\n        }\n        // Unbind\n        this._unbindFrameBuffer(engine, faceIndex);\n        if (this._texture && this.isCube && faceIndex === 5) {\n            engine.generateMipMapsForCubemap(this._texture);\n        }\n        (_f = engine._debugPopGroup) === null || _f === void 0 ? void 0 : _f.call(engine, 1);\n    }\n    /**\n     * Overrides the default sort function applied in the rendering group to prepare the meshes.\n     * This allowed control for front to back rendering or reversely depending of the special needs.\n     *\n     * @param renderingGroupId The rendering group id corresponding to its index\n     * @param opaqueSortCompareFn The opaque queue comparison function use to sort.\n     * @param alphaTestSortCompareFn The alpha test queue comparison function use to sort.\n     * @param transparentSortCompareFn The transparent queue comparison function use to sort.\n     */\n    setRenderingOrder(renderingGroupId, opaqueSortCompareFn = null, alphaTestSortCompareFn = null, transparentSortCompareFn = null) {\n        this._renderingManager.setRenderingOrder(renderingGroupId, opaqueSortCompareFn, alphaTestSortCompareFn, transparentSortCompareFn);\n    }\n    /**\n     * Specifies whether or not the stencil and depth buffer are cleared between two rendering groups.\n     *\n     * @param renderingGroupId The rendering group id corresponding to its index\n     * @param autoClearDepthStencil Automatically clears depth and stencil between groups if true.\n     */\n    setRenderingAutoClearDepthStencil(renderingGroupId, autoClearDepthStencil) {\n        this._renderingManager.setRenderingAutoClearDepthStencil(renderingGroupId, autoClearDepthStencil);\n        this._renderingManager._useSceneAutoClearSetup = false;\n    }\n    /**\n     * Clones the texture.\n     * @returns the cloned texture\n     */\n    clone() {\n        const textureSize = this.getSize();\n        const newTexture = new RenderTargetTexture(this.name, textureSize, this.getScene(), this._renderTargetOptions.generateMipMaps, this._doNotChangeAspectRatio, this._renderTargetOptions.type, this.isCube, this._renderTargetOptions.samplingMode, this._renderTargetOptions.generateDepthBuffer, this._renderTargetOptions.generateStencilBuffer, undefined, this._renderTargetOptions.format, undefined, this._renderTargetOptions.samples);\n        // Base texture\n        newTexture.hasAlpha = this.hasAlpha;\n        newTexture.level = this.level;\n        // RenderTarget Texture\n        newTexture.coordinatesMode = this.coordinatesMode;\n        if (this.renderList) {\n            newTexture.renderList = this.renderList.slice(0);\n        }\n        return newTexture;\n    }\n    /**\n     * Serialize the texture to a JSON representation we can easily use in the respective Parse function.\n     * @returns The JSON representation of the texture\n     */\n    serialize() {\n        if (!this.name) {\n            return null;\n        }\n        const serializationObject = super.serialize();\n        serializationObject.renderTargetSize = this.getRenderSize();\n        serializationObject.renderList = [];\n        if (this.renderList) {\n            for (let index = 0; index < this.renderList.length; index++) {\n                serializationObject.renderList.push(this.renderList[index].id);\n            }\n        }\n        return serializationObject;\n    }\n    /**\n     *  This will remove the attached framebuffer objects. The texture will not be able to be used as render target anymore\n     */\n    disposeFramebufferObjects() {\n        var _a;\n        (_a = this._renderTarget) === null || _a === void 0 ? void 0 : _a.dispose(true);\n    }\n    /**\n     * Release and destroy the underlying lower level texture aka internalTexture.\n     */\n    releaseInternalTexture() {\n        var _a;\n        (_a = this._renderTarget) === null || _a === void 0 ? void 0 : _a.releaseTextures();\n        this._texture = null;\n    }\n    /**\n     * Dispose the texture and release its associated resources.\n     */\n    dispose() {\n        var _a;\n        this.onResizeObservable.clear();\n        this.onClearObservable.clear();\n        this.onAfterRenderObservable.clear();\n        this.onAfterUnbindObservable.clear();\n        this.onBeforeBindObservable.clear();\n        this.onBeforeRenderObservable.clear();\n        if (this._postProcessManager) {\n            this._postProcessManager.dispose();\n            this._postProcessManager = null;\n        }\n        if (this._prePassRenderTarget) {\n            this._prePassRenderTarget.dispose();\n        }\n        this._releaseRenderPassId();\n        this.clearPostProcesses(true);\n        if (this._resizeObserver) {\n            this.getScene().getEngine().onResizeObservable.remove(this._resizeObserver);\n            this._resizeObserver = null;\n        }\n        this.renderList = null;\n        // Remove from custom render targets\n        const scene = this.getScene();\n        if (!scene) {\n            return;\n        }\n        let index = scene.customRenderTargets.indexOf(this);\n        if (index >= 0) {\n            scene.customRenderTargets.splice(index, 1);\n        }\n        for (const camera of scene.cameras) {\n            index = camera.customRenderTargets.indexOf(this);\n            if (index >= 0) {\n                camera.customRenderTargets.splice(index, 1);\n            }\n        }\n        (_a = this._renderTarget) === null || _a === void 0 ? void 0 : _a.dispose();\n        this._renderTarget = null;\n        this._texture = null;\n        super.dispose();\n    }\n    /** @internal */\n    _rebuild() {\n        if (this.refreshRate === RenderTargetTexture.REFRESHRATE_RENDER_ONCE) {\n            this.refreshRate = RenderTargetTexture.REFRESHRATE_RENDER_ONCE;\n        }\n        if (this._postProcessManager) {\n            this._postProcessManager._rebuild();\n        }\n    }\n    /**\n     * Clear the info related to rendering groups preventing retention point in material dispose.\n     */\n    freeRenderingGroups() {\n        if (this._renderingManager) {\n            this._renderingManager.freeRenderingGroups();\n        }\n    }\n    /**\n     * Gets the number of views the corresponding to the texture (eg. a MultiviewRenderTarget will have > 1)\n     * @returns the view count\n     */\n    getViewCount() {\n        return 1;\n    }\n}\n/**\n * The texture will only be rendered once which can be useful to improve performance if everything in your render is static for instance.\n */\nRenderTargetTexture.REFRESHRATE_RENDER_ONCE = 0;\n/**\n * The texture will only be rendered rendered every frame and is recommended for dynamic contents.\n */\nRenderTargetTexture.REFRESHRATE_RENDER_ONEVERYFRAME = 1;\n/**\n * The texture will be rendered every 2 frames which could be enough if your dynamic objects are not\n * the central point of your effect and can save a lot of performances.\n */\nRenderTargetTexture.REFRESHRATE_RENDER_ONEVERYTWOFRAMES = 2;\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nTexture._CreateRenderTargetTexture = (name, renderTargetSize, scene, generateMipMaps, creationFlags) => {\n    return new RenderTargetTexture(name, renderTargetSize, scene, generateMipMaps);\n};\n//# sourceMappingURL=renderTargetTexture.js.map","\n/**\n * Class used to store a texture sampler data\n */\nexport class TextureSampler {\n    /**\n     * | Value | Type               | Description |\n     * | ----- | ------------------ | ----------- |\n     * | 0     | CLAMP_ADDRESSMODE  |             |\n     * | 1     | WRAP_ADDRESSMODE   |             |\n     * | 2     | MIRROR_ADDRESSMODE |             |\n     */\n    get wrapU() {\n        return this._cachedWrapU;\n    }\n    set wrapU(value) {\n        this._cachedWrapU = value;\n    }\n    /**\n     * | Value | Type               | Description |\n     * | ----- | ------------------ | ----------- |\n     * | 0     | CLAMP_ADDRESSMODE  |             |\n     * | 1     | WRAP_ADDRESSMODE   |             |\n     * | 2     | MIRROR_ADDRESSMODE |             |\n     */\n    get wrapV() {\n        return this._cachedWrapV;\n    }\n    set wrapV(value) {\n        this._cachedWrapV = value;\n    }\n    /**\n     * | Value | Type               | Description |\n     * | ----- | ------------------ | ----------- |\n     * | 0     | CLAMP_ADDRESSMODE  |             |\n     * | 1     | WRAP_ADDRESSMODE   |             |\n     * | 2     | MIRROR_ADDRESSMODE |             |\n     */\n    get wrapR() {\n        return this._cachedWrapR;\n    }\n    set wrapR(value) {\n        this._cachedWrapR = value;\n    }\n    /**\n     * With compliant hardware and browser (supporting anisotropic filtering)\n     * this defines the level of anisotropic filtering in the texture.\n     * The higher the better but the slower.\n     */\n    get anisotropicFilteringLevel() {\n        return this._cachedAnisotropicFilteringLevel;\n    }\n    set anisotropicFilteringLevel(value) {\n        this._cachedAnisotropicFilteringLevel = value;\n    }\n    /**\n     * Gets or sets the comparison function (513, 514, etc). Set 0 to not use a comparison function\n     */\n    get comparisonFunction() {\n        return this._comparisonFunction;\n    }\n    set comparisonFunction(value) {\n        this._comparisonFunction = value;\n    }\n    /**\n     * Indicates to use the mip maps (if available on the texture).\n     * Thanks to this flag, you can instruct the sampler to not sample the mipmaps even if they exist (and if the sampling mode is set to a value that normally samples the mipmaps!)\n     */\n    get useMipMaps() {\n        return this._useMipMaps;\n    }\n    set useMipMaps(value) {\n        this._useMipMaps = value;\n    }\n    /**\n     * Creates a Sampler instance\n     */\n    constructor() {\n        /**\n         * Gets the sampling mode of the texture\n         */\n        this.samplingMode = -1;\n        this._useMipMaps = true;\n        /** @internal */\n        this._cachedWrapU = null;\n        /** @internal */\n        this._cachedWrapV = null;\n        /** @internal */\n        this._cachedWrapR = null;\n        /** @internal */\n        this._cachedAnisotropicFilteringLevel = null;\n        /** @internal */\n        this._comparisonFunction = 0;\n    }\n    /**\n     * Sets all the parameters of the sampler\n     * @param wrapU u address mode (default: TEXTURE_WRAP_ADDRESSMODE)\n     * @param wrapV v address mode (default: TEXTURE_WRAP_ADDRESSMODE)\n     * @param wrapR r address mode (default: TEXTURE_WRAP_ADDRESSMODE)\n     * @param anisotropicFilteringLevel anisotropic level (default: 1)\n     * @param samplingMode sampling mode (default: 2)\n     * @param comparisonFunction comparison function (default: 0 - no comparison function)\n     * @returns the current sampler instance\n     */\n    setParameters(wrapU = 1, wrapV = 1, wrapR = 1, anisotropicFilteringLevel = 1, samplingMode = 2, comparisonFunction = 0) {\n        this._cachedWrapU = wrapU;\n        this._cachedWrapV = wrapV;\n        this._cachedWrapR = wrapR;\n        this._cachedAnisotropicFilteringLevel = anisotropicFilteringLevel;\n        this.samplingMode = samplingMode;\n        this._comparisonFunction = comparisonFunction;\n        return this;\n    }\n    /**\n     * Compares this sampler with another one\n     * @param other sampler to compare with\n     * @returns true if the samplers have the same parametres, else false\n     */\n    compareSampler(other) {\n        return (this._cachedWrapU === other._cachedWrapU &&\n            this._cachedWrapV === other._cachedWrapV &&\n            this._cachedWrapR === other._cachedWrapR &&\n            this._cachedAnisotropicFilteringLevel === other._cachedAnisotropicFilteringLevel &&\n            this.samplingMode === other.samplingMode &&\n            this._comparisonFunction === other._comparisonFunction &&\n            this._useMipMaps === other._useMipMaps);\n    }\n}\n//# sourceMappingURL=textureSampler.js.map"],"names":["PBRBaseSimpleMaterial","doubleSided","this","_twoSidedLighting","value","backFaceCulling","_markAllSubMeshesAsTexturesDirty","constructor","name","scene","super","maxSimultaneousLights","disableLighting","invertNormalMapX","invertNormalMapY","emissiveColor","occlusionStrength","useLightmapAsShadowmap","_useAlphaFromAlbedoTexture","_useAmbientInGrayScale","getClassName","prototype","PBRMetallicRoughnessMaterial","_useRoughnessFromMetallicTextureAlpha","_useRoughnessFromMetallicTextureGreen","_useMetallnessFromMetallicTextureBlue","metallic","roughness","clone","getScene","id","clearCoat","copyTo","anisotropy","brdf","sheen","subSurface","serialize","serializationObject","customType","iridescence","static","source","rootUrl","material","parse","PBRSpecularGlossinessMaterial","useMicroSurfaceFromReflectivityMapAlpha","_useMicroSurfaceFromReflectivityMapAlpha","MaterialAnisotropicDefines","arguments","ANISOTROPIC","ANISOTROPIC_TEXTURE","ANISOTROPIC_TEXTUREDIRECTUV","MAINUV1","PBRAnisotropicConfiguration","_enable","_isEnabled","_internalMarkAllSubMeshesAsTexturesDirty","addToPluginList","isEnabled","intensity","direction","_texture","texture","_dirtyCallbacks","isReadyForSubMesh","defines","_areTexturesDirty","texturesEnabled","isReadyOrNotBlocking","prepareDefinesBeforeAttributes","mesh","isVerticesDataPresent","_needUVs","bindForSubMesh","uniformBuffer","isFrozen","_material","useUbo","isSync","updateFloat2","coordinatesIndex","level","updateFloat3","x","y","setTexture","hasTexture","getActiveTextures","activeTextures","push","getAnimatables","animatables","animations","length","dispose","forceDisposeTextures","addFallbacks","fallbacks","currentRank","addFallback","getSamplers","samplers","getUniforms","ubo","size","type","MaterialBRDFDefines","BRDF_V_HEIGHT_CORRELATED","MS_BRDF_ENERGY_CONSERVATION","SPHERICAL_HARMONICS","SPECULAR_GLOSSINESS_ENERGY_CONSERVATION","PBRBRDFConfiguration","_markAllSubMeshesAsMiscDirty","_internalMarkAllSubMeshesAsMiscDirty","_useEnergyConservation","DEFAULT_USE_ENERGY_CONSERVATION","useEnergyConservation","_useSmithVisibilityHeightCorrelated","DEFAULT_USE_SMITH_VISIBILITY_HEIGHT_CORRELATED","useSmithVisibilityHeightCorrelated","_useSphericalHarmonics","DEFAULT_USE_SPHERICAL_HARMONICS","useSphericalHarmonics","_useSpecularGlossinessInputEnergyConservation","DEFAULT_USE_SPECULAR_GLOSSINESS_INPUT_ENERGY_CONSERVATION","useSpecularGlossinessInputEnergyConservation","prepareDefines","onCreatedEffectParameters","effect","subMesh","PBRMaterialDefines","externalProperties","PBR","NUM_SAMPLES","REALTIME_FILTERING","MAINUV2","MAINUV3","MAINUV4","MAINUV5","MAINUV6","UV1","UV2","UV3","UV4","UV5","UV6","ALBEDO","GAMMAALBEDO","ALBEDODIRECTUV","VERTEXCOLOR","BAKED_VERTEX_ANIMATION_TEXTURE","AMBIENT","AMBIENTDIRECTUV","AMBIENTINGRAYSCALE","OPACITY","VERTEXALPHA","OPACITYDIRECTUV","OPACITYRGB","ALPHATEST","DEPTHPREPASS","ALPHABLEND","ALPHAFROMALBEDO","ALPHATESTVALUE","SPECULAROVERALPHA","RADIANCEOVERALPHA","ALPHAFRESNEL","LINEARALPHAFRESNEL","PREMULTIPLYALPHA","EMISSIVE","EMISSIVEDIRECTUV","GAMMAEMISSIVE","REFLECTIVITY","REFLECTIVITY_GAMMA","REFLECTIVITYDIRECTUV","SPECULARTERM","MICROSURFACEFROMREFLECTIVITYMAP","MICROSURFACEAUTOMATIC","LODBASEDMICROSFURACE","MICROSURFACEMAP","MICROSURFACEMAPDIRECTUV","METALLICWORKFLOW","ROUGHNESSSTOREINMETALMAPALPHA","ROUGHNESSSTOREINMETALMAPGREEN","METALLNESSSTOREINMETALMAPBLUE","AOSTOREINMETALMAPRED","METALLIC_REFLECTANCE","METALLIC_REFLECTANCE_GAMMA","METALLIC_REFLECTANCEDIRECTUV","METALLIC_REFLECTANCE_USE_ALPHA_ONLY","REFLECTANCE","REFLECTANCE_GAMMA","REFLECTANCEDIRECTUV","ENVIRONMENTBRDF","ENVIRONMENTBRDF_RGBD","NORMAL","TANGENT","BUMP","BUMPDIRECTUV","OBJECTSPACE_NORMALMAP","PARALLAX","PARALLAXOCCLUSION","NORMALXYSCALE","LIGHTMAP","LIGHTMAPDIRECTUV","USELIGHTMAPASSHADOWMAP","GAMMALIGHTMAP","RGBDLIGHTMAP","REFLECTION","REFLECTIONMAP_3D","REFLECTIONMAP_SPHERICAL","REFLECTIONMAP_PLANAR","REFLECTIONMAP_CUBIC","USE_LOCAL_REFLECTIONMAP_CUBIC","REFLECTIONMAP_PROJECTION","REFLECTIONMAP_SKYBOX","REFLECTIONMAP_EXPLICIT","REFLECTIONMAP_EQUIRECTANGULAR","REFLECTIONMAP_EQUIRECTANGULAR_FIXED","REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED","INVERTCUBICMAP","USESPHERICALFROMREFLECTIONMAP","USEIRRADIANCEMAP","USESPHERICALINVERTEX","REFLECTIONMAP_OPPOSITEZ","LODINREFLECTIONALPHA","GAMMAREFLECTION","RGBDREFLECTION","LINEARSPECULARREFLECTION","RADIANCEOCCLUSION","HORIZONOCCLUSION","INSTANCES","THIN_INSTANCES","INSTANCESCOLOR","PREPASS","PREPASS_IRRADIANCE","PREPASS_IRRADIANCE_INDEX","PREPASS_ALBEDO_SQRT","PREPASS_ALBEDO_SQRT_INDEX","PREPASS_DEPTH","PREPASS_DEPTH_INDEX","PREPASS_NORMAL","PREPASS_NORMAL_INDEX","PREPASS_POSITION","PREPASS_POSITION_INDEX","PREPASS_VELOCITY","PREPASS_VELOCITY_INDEX","PREPASS_REFLECTIVITY","PREPASS_REFLECTIVITY_INDEX","SCENE_MRT_COUNT","NUM_BONE_INFLUENCERS","BonesPerMesh","BONETEXTURE","BONES_VELOCITY_ENABLED","NONUNIFORMSCALING","MORPHTARGETS","MORPHTARGETS_NORMAL","MORPHTARGETS_TANGENT","MORPHTARGETS_UV","NUM_MORPH_INFLUENCERS","MORPHTARGETS_TEXTURE","IMAGEPROCESSING","VIGNETTE","VIGNETTEBLENDMODEMULTIPLY","VIGNETTEBLENDMODEOPAQUE","TONEMAPPING","TONEMAPPING_ACES","CONTRAST","COLORCURVES","COLORGRADING","COLORGRADING3D","SAMPLER3DGREENDEPTH","SAMPLER3DBGRMAP","DITHER","IMAGEPROCESSINGPOSTPROCESS","SKIPFINALCOLORCLAMP","EXPOSURE","MULTIVIEW","ORDER_INDEPENDENT_TRANSPARENCY","ORDER_INDEPENDENT_TRANSPARENCY_16BITS","USEPHYSICALLIGHTFALLOFF","USEGLTFLIGHTFALLOFF","TWOSIDEDLIGHTING","SHADOWFLOAT","CLIPPLANE","CLIPPLANE2","CLIPPLANE3","CLIPPLANE4","CLIPPLANE5","CLIPPLANE6","POINTSIZE","FOG","LOGARITHMICDEPTH","CAMERA_ORTHOGRAPHIC","CAMERA_PERSPECTIVE","FORCENORMALFORWARD","SPECULARAA","UNLIT","DEBUGMODE","rebuild","reset","PBRBaseMaterial","realTimeFiltering","_realTimeFiltering","b","markAsDirty","realTimeFilteringQuality","_realTimeFilteringQuality","n","canRenderToMRT","_attachImageProcessingConfiguration","configuration","_imageProcessingConfiguration","_imageProcessingObserver","onUpdateParameters","remove","imageProcessingConfiguration","add","_markAllSubMeshesAsImageProcessingDirty","_directIntensity","_emissiveIntensity","_environmentIntensity","_specularIntensity","_lightingInfos","_disableBumpMap","_albedoTexture","_ambientTexture","_ambientTextureStrength","_ambientTextureImpactOnAnalyticalLights","DEFAULT_AO_ON_ANALYTICAL_LIGHTS","_opacityTexture","_reflectionTexture","_emissiveTexture","_reflectivityTexture","_metallicTexture","_metallic","_roughness","_metallicF0Factor","_metallicReflectanceColor","_useOnlyMetallicFromMetallicReflectanceTexture","_metallicReflectanceTexture","_reflectanceTexture","_microSurfaceTexture","_bumpTexture","_lightmapTexture","_ambientColor","_albedoColor","_reflectivityColor","_reflectionColor","_emissiveColor","_microSurface","_useLightmapAsShadowmap","_useHorizonOcclusion","_useRadianceOcclusion","_useSpecularOverAlpha","_useAmbientOcclusionFromMetallicTextureRed","_useAutoMicroSurfaceFromReflectivityMap","_lightFalloff","LIGHTFALLOFF_PHYSICAL","_useRadianceOverAlpha","_useObjectSpaceNormalMap","_useParallax","_useParallaxOcclusion","_parallaxScaleBias","_disableLighting","_maxSimultaneousLights","_invertNormalMapX","_invertNormalMapY","_alphaCutOff","_forceAlphaTest","_useAlphaFresnel","_useLinearAlphaFresnel","_environmentBRDFTexture","_forceIrradianceInFragment","_forceNormalForward","_enableSpecularAntiAliasing","_renderTargets","_globalAmbientColor","_useLogarithmicDepth","_unlit","_debugMode","debugMode","_debugLimit","_debugFactor","_cacheHasRenderTargetTextures","detailMap","getRenderTargetTextures","isRenderTarget","_eventInfo","renderTargets","_callbackPluginEventFillRenderTargetTextures","prePassConfiguration","hasRenderTargetTextures","isPrePassCapable","disableDepthWrite","useLogarithmicDepth","getEngine","getCaps","fragmentDepthSupported","_disableAlphaBlending","_a","_transparencyMode","PBRMATERIAL_OPAQUE","PBRMATERIAL_ALPHATEST","disableAlphaBlending","needAlphaBlending","alpha","_shouldUseAlphaFromAlbedoTexture","needAlphaTesting","_hasAlphaChannel","hasAlpha","getAlphaTestTexture","useInstances","_uniformBufferLayoutBuilt","buildUniformLayout","_wasPreviouslyReady","_wasPreviouslyUsingInstances","materialDefines","_callbackPluginEventGeneric","defineNames","_isReadyForSubMesh","engine","_callbackPluginEventHasRenderTargetTextures","reflectionTexture","_getReflectionTexture","irradianceTexture","standardDerivatives","isReady","_callbackPluginEventIsReadyForSubMesh","_areImageProcessingDirty","createNormals","previousEffect","lightDisposed","_areLightsDisposed","_prepareEffect","onCompiled","onError","getRenderingMesh","hasThinInstances","forceWasNotReadyPreviously","_onEffectCreatedObservable","notifyObservers","allowShaderHotSwapping","markAsUnprocessed","resetCachedMaterial","setEffect","_materialContext","_renderId","getRenderId","performancePriority","checkReadyOnlyOnce","isMetallicWorkflow","useClipPlane","useThinInstances","_prepareDefines","isDirty","markAsProcessed","fallbackRank","attribs","i","shaderName","uniforms","uniformBuffers","attributes","uniformBuffersNames","customCode","undefined","uniformsNames","csnrOptions","customShaderNameResolve","join","toString","createEffect","indexParameters","maxSimultaneousMorphTargets","processFinalCode","processCodeAfterIncludes","multiTarget","_needNormals","oit","needAlphaBlendingForMesh","useOrderIndependentTransparency","textureLOD","gammaSpace","getAlphaFromRGB","isRGBD","lodLevelInAlpha","linearSpecularLOD","_features","needTypeSuffixInShaderConstants","coordinatesMode","isCube","useRightHandedSystem","invertZ","boundingBoxSize","maxVaryingVectors","identicalTextures","checkTransformsAreIdentical","LIGHTFALLOFF_STANDARD","LIGHTFALLOFF_GLTF","_areMiscDirty","alphaMode","pointsCloud","fogEnabled","_shouldTurnAlphaTestOn","wireframe","_callbackPluginEventPrepareDefinesBeforeAttributes","_callbackPluginEventPrepareDefines","forceCompilation","options","localOptions","clipPlane","onCompileObservable","_uniformBuffer","addUniform","world","_b","_c","_d","_activeEffect","getMeshUniformBuffer","bindToEffect","transferToEffect","_callbackPluginEventHardBindForSubMesh","toNormalMatrix","_normalMatrix","bindOnlyNormalMatrix","mustRebind","_forceRebindOnNextCall","_mustRebind","visibility","bindViewProjection","updateFloat4","updateMatrix","getReflectionTextureMatrix","cubeTexture","updateVector3","boundingBoxPosition","width","getSize","polynomials","sphericalPolynomial","preScaledHarmonics","l00","l1_1","l10","l11","l2_2","l2_1","l20","l21","l22","z","xx","zz","yy","xy","yz","zx","lodGenerationScale","lodGenerationOffset","_mirroredCameraPosition","updateFloat","pointSize","updateColor4","ior","_indexOfRefraction","outsideIOR","f0","Math","pow","scaleToRef","metallicF90","updateColor3","SS_REFRACTION","_linkRefractionWithTransparency","environmentIntensity","w","updateVector4","ambientColor","multiplyToRef","_lodTextureMid","_lodTextureLow","_lodTextureHigh","depthPeelingRenderer","bind","_callbackPluginEventBindForSubMesh","bindEyePosition","needToAlwaysBindUniformBuffers","_needToBindSceneUbo","lightsEnabled","applyFog","fogMode","receiveShadows","bindView","bakedVertexAnimationManager","_afterBind","update","results","environmentTexture","setPrePassRenderer","isScatteringEnabled","subSurfaceConfiguration","enableSubSurfaceForPrePass","enabled","forceDisposeEffect","_e","_f","_g","_h","_j","_k","_l","_m","environmentBRDFTexture","PBRMATERIAL_ALPHABLEND","PBRMATERIAL_ALPHATESTANDBLEND","MaterialClearCoatDefines","CLEARCOAT","CLEARCOAT_DEFAULTIOR","CLEARCOAT_TEXTURE","CLEARCOAT_TEXTURE_ROUGHNESS","CLEARCOAT_TEXTUREDIRECTUV","CLEARCOAT_TEXTURE_ROUGHNESSDIRECTUV","CLEARCOAT_BUMP","CLEARCOAT_BUMPDIRECTUV","CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE","CLEARCOAT_TEXTURE_ROUGHNESS_IDENTICAL","CLEARCOAT_REMAP_F0","CLEARCOAT_TINT","CLEARCOAT_TINT_TEXTURE","CLEARCOAT_TINT_TEXTUREDIRECTUV","CLEARCOAT_TINT_GAMMATEXTURE","PBRClearCoatConfiguration","_DefaultIndexOfRefraction","indexOfRefraction","_useRoughnessFromMainTexture","useRoughnessFromMainTexture","_textureRoughness","textureRoughness","_remapF0OnInterfaceChange","remapF0OnInterfaceChange","bumpTexture","_isTintEnabled","isTintEnabled","tintColor","tintColorAtDistance","tintThickness","_tintTexture","tintTexture","disableBumpMap","a","eta","r","g","max","MaterialIridescenceDefines","IRIDESCENCE","IRIDESCENCE_TEXTURE","IRIDESCENCE_TEXTUREDIRECTUV","IRIDESCENCE_THICKNESS_TEXTURE","IRIDESCENCE_THICKNESS_TEXTUREDIRECTUV","IRIDESCENCE_USE_THICKNESS_FROM_MAINTEXTURE","PBRIridescenceConfiguration","minimumThickness","_DefaultMinimumThickness","maximumThickness","_DefaultMaximumThickness","_thicknessTexture","thicknessTexture","PBRMaterial","refractionTexture","isRefractionEnabled","linkRefractionWithTransparency","invertRefractionY","usePhysicalLightFalloff","useGLTFLightFalloff","cameraColorCurvesEnabled","colorCurvesEnabled","cameraColorGradingEnabled","colorGradingEnabled","cameraToneMappingEnabled","toneMappingEnabled","cameraExposure","exposure","cameraContrast","contrast","cameraColorGradingTexture","colorGradingTexture","cameraColorCurves","colorCurves","directIntensity","emissiveIntensity","specularIntensity","ambientTextureStrength","ambientTextureImpactOnAnalyticalLights","metallicF0Factor","metallicReflectanceColor","useOnlyMetallicFromMetallicReflectanceTexture","albedoColor","reflectivityColor","reflectionColor","microSurface","useAlphaFromAlbedoTexture","forceAlphaTest","alphaCutOff","useSpecularOverAlpha","useRoughnessFromMetallicTextureAlpha","useRoughnessFromMetallicTextureGreen","useMetallnessFromMetallicTextureBlue","useAmbientOcclusionFromMetallicTextureRed","useAmbientInGrayScale","useAutoMicroSurfaceFromReflectivityMap","useRadianceOverAlpha","useObjectSpaceNormalMap","useParallax","useParallaxOcclusion","parallaxScaleBias","forceIrradianceInFragment","twoSidedLighting","useAlphaFresnel","useLinearAlphaFresnel","forceNormalForward","enableSpecularAntiAliasing","useHorizonOcclusion","useRadianceOcclusion","unlit","stencil","MaterialSheenDefines","SHEEN","SHEEN_TEXTURE","SHEEN_GAMMATEXTURE","SHEEN_TEXTURE_ROUGHNESS","SHEEN_TEXTUREDIRECTUV","SHEEN_TEXTURE_ROUGHNESSDIRECTUV","SHEEN_LINKWITHALBEDO","SHEEN_ROUGHNESS","SHEEN_ALBEDOSCALING","SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE","SHEEN_TEXTURE_ROUGHNESS_IDENTICAL","PBRSheenConfiguration","_linkSheenWithAlbedo","linkSheenWithAlbedo","color","_albedoScaling","albedoScaling","MaterialSubSurfaceDefines","SUBSURFACE","SS_REFRACTION_USE_INTENSITY_FROM_TEXTURE","SS_TRANSLUCENCY","SS_TRANSLUCENCY_USE_INTENSITY_FROM_TEXTURE","SS_SCATTERING","SS_THICKNESSANDMASK_TEXTURE","SS_THICKNESSANDMASK_TEXTUREDIRECTUV","SS_HAS_THICKNESS","SS_REFRACTIONINTENSITY_TEXTURE","SS_REFRACTIONINTENSITY_TEXTUREDIRECTUV","SS_TRANSLUCENCYINTENSITY_TEXTURE","SS_TRANSLUCENCYINTENSITY_TEXTUREDIRECTUV","SS_REFRACTIONMAP_3D","SS_REFRACTIONMAP_OPPOSITEZ","SS_LODINREFRACTIONALPHA","SS_GAMMAREFRACTION","SS_RGBDREFRACTION","SS_LINEARSPECULARREFRACTION","SS_LINKREFRACTIONTOTRANSPARENCY","SS_ALBEDOFORREFRACTIONTINT","SS_ALBEDOFORTRANSLUCENCYTINT","SS_USE_LOCAL_REFRACTIONMAP_CUBIC","SS_USE_THICKNESS_AS_DEPTH","SS_MASK_FROM_THICKNESS_TEXTURE","SS_USE_GLTF_TEXTURES","PBRSubSurfaceConfiguration","scatteringDiffusionProfile","_scene","ssDiffusionProfileColors","_scatteringDiffusionProfileIndex","c","addDiffusionProfile","volumeIndexOfRefraction","_volumeIndexOfRefraction","_isRefractionEnabled","_isTranslucencyEnabled","_isScatteringEnabled","_markScenePrePassDirty","_internalMarkScenePrePassDirty","isTranslucencyEnabled","refractionIntensity","translucencyIntensity","useAlbedoToTintRefraction","useAlbedoToTintTranslucency","_refractionTexture","_invertRefractionY","useThicknessAsDepth","diffusionDistance","_useMaskFromThicknessTexture","useMaskFromThicknessTexture","_refractionIntensityTexture","refractionIntensityTexture","_translucencyIntensityTexture","translucencyIntensityTexture","_useGltfStyleTextures","useGltfStyleTextures","registerForExtraEvents","_getRefractionTexture","refractionIntensityTextureIsThicknessTexture","translucencyIntensityTextureIsThicknessTexture","useOnlyThicknessTexture","hardBindForSubMesh","getWorldMatrix","decompose","thicknessScale","abs","lodBasedMicrosurface","depth","refractionIor","fillRenderTargetTextures","HDRFiltering","_lodGenerationOffset","_lodGenerationScale","quality","hdrScale","_engine","_createRenderTarget","textureType","textureHalfFloatRender","textureFloatRender","rtWrapper","createRenderTargetCubeTexture","format","createMipMaps","generateMipMaps","generateDepthBuffer","generateStencilBuffer","samplingMode","updateTextureWrappingMode","updateTextureSamplingMode","_prefilterInternal","mipmapsCount","_effectWrapper","outputTexture","_effectRenderer","setViewport","intTexture","getInternalTexture","applyEffectWrapper","directions","setFloat","setFloat2","face","setVector3","lod","bindFramebuffer","draw","restoreStates","restoreDefaultFramebuffer","_releaseTexture","_swapAndDie","_prefiltered","_createEffect","vertexShader","fragmentShader","samplerNames","uniformNames","useShaderStore","prefilter","onFinished","allowTexturePrefiltering","Promise","resolve","executeWhenCompiled","reject","supportCascades","canLoad","extension","endsWith","loadCubeData","imgs","createPolynomials","onLoad","info","loadMipmap","maxLevel","Array","isArray","index","data","height","isRGB","isLuminance","mipmapCount","_unpackFlipY","isCompressed","isFourCC","generateMipMapsForCubemap","_setCubeMapTextureParams","onLoadedObservable","clear","isDDS","loadData","callback","then","reason","e","mimeType","_invertVScale","invertY","ktx","numberOfMipmapLevels","uploadLevels","pixelWidth","pixelHeight","mappedFormat","mapSRGBToLinear","glInternalFormat","_useSRGBBuffer","_getUseSRGBBuffer","_gammaSpace","isInvalid","uploadAsync","error","message","MultiviewRenderTarget","samples","_samples","_renderTarget","createMultiviewRenderTargetTexture","getRenderWidth","getRenderHeight","isMultiview","_getEngine","maxSamples","_bindFrameBuffer","bindMultiviewFramebuffer","getViewCount","ProceduralTexture","fragment","fallbackTexture","autoClear","onGeneratedObservable","onBeforeGenerationObservable","nodeMaterialSource","_textures","_currentRefreshId","_frameId","_refreshRate","_vertexBuffers","_uniforms","_samplers","_floats","_ints","_floatsArrays","_colors3","_colors4","_vectors2","_vectors3","_matrices","_fallbackTextureUsed","_cachedDefines","_contentUpdateId","_rtWrapper","component","_getComponent","_addComponent","proceduralTextures","_fullEngine","_size","_textureType","_generateMipMaps","_drawWrapper","setFragment","_fallbackTexture","_createRtWrapper","vertices","_createIndexBuffer","createRenderTargetTexture","getEffect","_setEffect","getContent","_contentData","buffer","readPixels","indices","_indexBuffer","createIndexBuffer","_rebuild","vb","refreshRate","_getDefines","shaders","_fragment","fragmentElement","vertex","incrementReferences","resetRefreshCounter","_shouldRender","getRenderSize","resize","_checkUniform","uniformName","indexOf","setInt","setFloats","setColor3","setColor4","setVector2","setMatrix","render","useCameraPostProcess","enableEffect","setState","setArray","setFloat4","_debugPushGroup","call","viewPort","currentViewport","bindBuffers","clearColor","drawElementsType","unBindFramebuffer","_debugPopGroup","onGenerated","textureSize","newTexture","splice","vertexBuffer","_releaseBuffer","ProceduralTextureSceneComponent","register","_beforeClearStage","registerStep","_beforeClear","proceduralTexturesEnabled","proceduralIndex","proceduralTexture","BaseTexture","_hasAlpha","markAllMaterialsAsDirty","mat","_getAlphaFromRGB","_coordinatesIndex","_coordinatesMode","wrapU","_wrapU","wrapV","_wrapV","_isCube","is3D","is2DArray","gamma","_isRGBD","noMipmap","_linearSpecularLOD","_irradianceTexture","uid","_uid","onDispose","_onDisposeObserver","onDisposeObservable","isBlocking","loadingError","_loadingError","errorObject","_errorObject","sceneOrEngine","internalTexture","metadata","reservedDataStore","optimizeUVAllocation","wrapR","anisotropicFilteringLevel","DEFAULT_ANISOTROPIC_FILTERING_LEVEL","_forceSerialize","_parentContainer","_IsScene","uniqueId","getUniqueId","addTexture","getTextureMatrix","scale","ratio","canRescale","_getFromCache","url","sampling","useSRGBBuffer","correctedUseSRGBBuffer","texturesCache","getLoadedTexturesCache","texturesCacheEntry","textureFormat","faceIndex","flushRenderer","noDataConversion","Number","MAX_VALUE","maxWidth","maxHeight","round","min","_readTexturePixels","_readPixelsSync","_readTexturePixelsSync","stopAnimation","removePendingData","textures","onTextureRemovedObservable","allowEmptyName","numRemaining","onLoadObservable","addOnce","_sphericalPolynomial","_sphericalPolynomialPromise","_sphericalPolynomialComputed","Object","defineProperty","get","set","enumerable","configurable","CubeTexture","_boundingBoxSize","equals","rotationY","_rotationY","setReflectionTextureMatrix","_noMipmap","forcedExtension","_forcedExtension","files","rootUrlKey","forEach","oldValue","useDelayedTextureLoading","result","extensions","prefiltered","lodScale","lodOffset","loaderOptions","_lodScale","_lodOffset","_files","_extensions","_format","_textureMatrix","_createPolynomials","_loaderOptions","updateURL","delayLoad","startsWith","lastDot","lastIndexOf","substring","toLowerCase","isEnv","isBasis","delayLoadState","_delayedOnLoad","_delayedOnError","_loadTexture","updateFlag","isIdentity","oldTexture","onLoadProcessing","errorHandler","exception","createPrefilteredCubeTexture","createCubeTexture","parsedTexture","animationIndex","parsedAnimation","internalClass","Parse","newCubeTexture","DynamicTexture","getContext","_canvas","createDynamicTexture","createCanvas","_context","_recreate","releaseInternalTexture","scaleTo","fillRect","premulAlpha","allowGPUOptimization","updateDynamicTexture","drawText","text","font","fillStyle","textSize","measureText","fontSize","parseInt","replace","fillText","_IsCanvasElement","base64String","toDataURL","_invertY","canvas","EquiRectangularCubeTexture","_onLoad","_onError","Error","_loadImage","loadTextureCallback","document","createElement","image","_width","_height","ctx","drawImage","imageData","getImageData","_buffer","_","createRawCubeTextureFromUrl","textureFloat","_getFloat32ArrayFromArrayBuffer","dataFace","_FacesMapping","dataView","DataView","floatImageData","Float32Array","byteLength","k","getUint8","ExternalTexture","underlyingResource","_video","video","useMipMaps","readyState","HAVE_CURRENT_DATA","HDRCubeTexture","_isBlocking","generateHarmonics","prefilterOnLoad","_generateHarmonics","_prefilterOnLoad","caps","textureFloatLinearFiltering","textureHalfFloat","textureHalfFloatLinearFiltering","previousOnLoad","hdrFiltering","byteArray","shortArray","j","Uint16Array","Uint8Array","useInGammaSpace","ColorGradingTexture","_triggerOnLoad","_load3dlTexture","support3DTextures","createRawTexture3D","createRawTexture","line","tempData","lines","split","pixelIndexW","pixelIndexH","pixelIndexSlice","maxColor","_NoneEmptyLineRegex","test","words","pixelStorageIndex","updateSize","updateRawTexture3D","updateRawTexture","_loadFile","toLocaleLowerCase","HtmlElementTexture","element","_DefaultOptions","_samplingMode","_isVideo","getVideoPlaybackQuality","_externalTexture","createExternalTexture","_createInternalTexture","videoWidth","videoHeight","wasReady","videoElement","updateVideoTexture","canvasElement","bytes","byteOffset","header","uint8array","hdrInfo","pixelsDataRGB32","pixels","pixelsDataRGBA32","_uploadDataToTextureDirectly","transcodeConfig","supportedCompressionFormats","etc1","s3tc","pvrtc","etc2","astc","bc7","bptc","hasMipmap","fileInfo","images","levels","catch","err","rootImage","TexturePackerFrame","offset","TexturePacker","meshes","_o","_p","_q","map","uvsIn","uvsOut","layout","LAYOUT_STRIP","LAYOUT_COLNUM","colnum","updateInputMeshes","disposeSources","_expecting","fillBlanks","customFillColor","frameSize","paddingRatio","_paddingValue","ceil","paddingMode","SUBUV_WRAP","SUBUV_COLOR","paddingColor","sets","frames","_createFrames","dtSize","_calculateSize","dtUnits","divide","doneCount","expecting","meshLength","sKeys","keys","setName","dt","dtx","baseSize","padding","tcs","done","_calculateMeshUVFrames","tempTexture","tcx","_getFrameOffset","updateDt","iDat","putImageData","img","Image","src","onload","setTransform","cellOffsets","toHexString","clearRect","sqrtCount","sqrt","cols","rowCnt","m","pOffset","frame","_updateMeshUV","_updateTextureReferences","uvStep","yStep","xStep","floor","frameID","uvIn","getVerticesData","uvOut","toCount","setVerticesData","force","_dispose","_t","setMeshToFrame","updateMaterial","processAsync","doneCheck","forceCompilationAsync","channel","download","imageType","setTimeout","pack","oKeys","opt","encodeURIComponent","JSON","stringify","setAttribute","body","appendChild","click","updateFromJSON","parsedData","_options","channels","LAYOUT_POWER2","SUBUV_EXTEND","NoiseProceduralTexture","time","brightness","octaves","persistence","animationSpeedFactor","_updateShaderUniforms","getAnimationRatio","InternalTextureSource","InternalTexture","_uniqueId","_setUniqueId","_source","delayAllocation","onErrorObservable","onRebuildCallback","baseWidth","baseHeight","baseDepth","_associatedChannel","Unknown","_bufferView","_bufferViewArray","_bufferViewArrayArray","_extension","_workingCanvas","_workingContext","_cachedCoordinatesMode","_isDisabled","_compression","_hardwareTexture","_maxLodLevel","_references","_Counter","_createHardwareTexture","updateTextureDimensions","_cachedWrapU","_cachedWrapV","_cachedWrapR","_cachedAnisotropicFilteringLevel","swapAndSetIsReady","proxyInternalTexture","isAsync","proxy","Temp","Url","createTexture","_originalUrl","temp","Raw","Raw3D","Raw2DArray","createRawTexture2DArray","Dynamic","getRenderingCanvas","Cube","CubeRaw","createRawCubeTexture","CubeRawRGBD","CubePrefiltered","target","swapAll","setUsage","cache","SourceTextureFormat","TranscodeTarget","EngineFormat","MirrorTexture","blurRatio","_blurRatio","_preparePostProcesses","adaptiveBlurKernel","_adaptiveBlurKernel","_autoComputeBlurKernel","blurKernel","blurKernelX","blurKernelY","_blurKernelX","_blurKernelY","dw","dh","_onRatioRescale","_sizeRatio","_initialSizeParameter","_updateGammaSpace","applyByPostProcess","mirrorPlane","_transformMatrix","_mirrorMatrix","ignoreCameraViewport","_imageProcessingConfigChangeObserver","saveClipPlane","supportsUniformBuffers","_sceneUBO","createSceneUniformBuffer","onBeforeBindObservable","onAfterUnbindObservable","onBeforeRenderObservable","_currentSceneUBO","getSceneUniformBuffer","setSceneUniformBuffer","unbindEffect","getViewMatrix","setTransformMatrix","getProjectionMatrix","activeCamera","globalPosition","onAfterRenderObservable","updateTransformMatrix","clearPostProcesses","_blurX","inputTexture","alwaysForcePOT","_blurY","addPostProcess","removePostProcess","_renderTargetOptions","renderList","slice","asArray","renderTargetSize","MultiRenderTarget","isSupported","drawBuffersExtension","count","_count","depthTexture","wrap","textureNames","generateDepthTexture","depthTextureFormat","doNotChangeAspectRatio","drawOnlyOnFirstAttachmentByDefault","types","samplingModes","useSRGBBuffers","_initTypes","_multiRenderTargetOptions","textureCount","_drawOnlyOnFirstAttachmentByDefault","_createInternalTextures","_createTextures","defaultType","forceFullRebuild","releaseInternalTextures","_releaseTextures","internalTextures","setSamples","createMultipleRenderTarget","setInternalTexture","disposePrevious","renderTarget","updateCount","_unbindFrameBuffer","unBindMultiColorAttachmentFramebuffer","doNotDisposeInternalTextures","PrePassRenderTarget","renderTargetTexture","_beforeCompositionPostProcesses","_internalTextureDirty","_createCompositionEffect","imageProcessingPostProcess","_updateParameters","_checkSize","requiredWidth","requiredHeight","_resetPostProcessChain","prePassRenderer","_prePassRenderTarget","_outputPostProcess","restoreDefaultInputTexture","RawCubeTexture","compression","updateRawCubeTexture","updateRGBDAsync","RawTexture","creationFlags","_caps","RawTexture2DArray","_depth","updateRawTexture2DArray","RenderTargetTexture","_renderList","_unObserveRenderList","_renderListHasChanged","postProcesses","_postProcesses","_prePassEnabled","onAfterUnbind","_onAfterUnbindObserver","onBeforeRender","_onBeforeRenderObserver","onAfterRender","_onAfterRenderObserver","onClear","_onClearObserver","onClearObservable","renderPassIds","_renderPassIds","currentRefreshId","setMaterialForRendering","setMaterialForRenderPass","renderTargetOptions","depthStencilTexture","_depthStencilTexture","isMulti","noColorAttachment","colorAttachment","_functionName","previousLength","newLength","_markSubMeshesAsLightDirty","renderParticles","renderSprites","forceLayerMaskCheck","onResizeObservable","_cleared","skipInitialClear","_canRescale","_isCubeData","_processSizeParameter","renderPassId","_resizeObserver","_doNotChangeAspectRatio","_renderingManager","_useSceneAutoClearSetup","createDepthStencilTexture","comparisonFunction","bilinearFiltering","generateStencil","_releaseRenderPassId","releaseRenderPassId","_createRenderPassId","numPasses","getRenderLayers","createRenderPassId","_bestReflectionRenderTargetDimension","postProcess","_postProcessManager","layers","disableRescaling","newSize","wasCube","hasObservers","dumpForDebug","_render","isReadyForRendering","checkReadiness","useCameraPostProcesses","_waitingRenderList","getMeshById","renderListPredicate","sceneMeshes","currentRenderPassId","camera","sceneCamera","viewport","_defaultRenderListPrepared","returnValue","numLayers","layer","currentRenderList","defaultRenderList","getActiveMeshes","defaultRenderListLength","getCustomRenderList","isBlocked","isVisible","subMeshes","customIsReadyFunction","incrementRenderId","_renderToTarget","scenes","renderDimension","curved","_prepareRenderingManager","currentRenderListLength","checkLayerMask","sceneRenderId","meshIndex","_internalAbstractMeshDataInfo","_currentLODIsUpToDate","_currentLOD","customLODSelector","getLOD","isMasked","meshToRender","_preActivateForIntermediateRendering","layerMask","_activate","isAnInstance","_actAsRegularMesh","_onlyForInstancesIntermediate","_isActiveIntermediate","subIndex","dispatch","particleIndex","particleSystems","particleSystem","emitter","isStarted","position","dispatchParticles","_prepareFrame","postProcessManager","snapshotRendering","snapshotRenderingMode","step","_beforeRenderTargetClearStage","action","_beforeRenderTargetDrawStage","customRenderFunction","_afterRenderTargetDrawStage","saveGenerateMipMaps","_finalizeFrame","_afterRenderTargetPostProcessStage","setRenderingOrder","renderingGroupId","opaqueSortCompareFn","alphaTestSortCompareFn","transparentSortCompareFn","setRenderingAutoClearDepthStencil","autoClearDepthStencil","disposeFramebufferObjects","releaseTextures","customRenderTargets","cameras","REFRESHRATE_RENDER_ONCE","freeRenderingGroups","REFRESHRATE_RENDER_ONEVERYFRAME","REFRESHRATE_RENDER_ONEVERYTWOFRAMES","TextureSampler","_comparisonFunction","_useMipMaps","setParameters","compareSampler","other"],"sourceRoot":""}