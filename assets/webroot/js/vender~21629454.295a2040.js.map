{"version":3,"file":"js/vender~21629454.295a2040.js","mappings":"uLAMA,oCAAgD,SAAUA,GACtD,IAAKC,KAAKC,iBACN,OAAQ,EAEZ,MAAMC,EAAQF,KAAKC,iBAAiBE,QAAQJ,GAI5C,OAHe,IAAXG,GACAF,KAAKC,iBAAiBG,OAAOF,EAAO,GAEjCA,CACX,EACA,iCAA6C,SAAUG,GAC9CL,KAAKC,mBACND,KAAKC,iBAAmB,IAE5BD,KAAKC,iBAAiBK,KAAKD,EAC/B,EAKO,MAAME,EAUTC,YAEAC,EAAMC,EAAMC,EAAOC,GAAkB,EAAMC,GAAW,EAAOC,GAAc,GAevE,GAdAd,KAAKS,KAAOA,EACZT,KAAKe,YAAc,gBACnBf,KAAKgB,QAAU,WACfhB,KAAKiB,KAAO,WACZjB,KAAKkB,cAAe,EAEpBlB,KAAKmB,SAAW,WAIhBnB,KAAKoB,SAAW,KAEhBpB,KAAKqB,iBAAmB,KACxBrB,KAAKsB,OAASX,EACVA,EAAMY,YAAYC,uBAAwB,CAC1CxB,KAAKyB,WAAa,GAClB,IAAK,IAAIC,EAAI,EAAGA,EAAI,IAAKA,EACrB1B,KAAKyB,WAAWnB,KAAKK,EAAMgB,yBAAyB,qCAAqClB,aAAgBiB,KAEjH,CAEK1B,KAAKsB,OAAOrB,mBACbD,KAAKsB,OAAOrB,iBAAmB,IAAI2B,OAEvC5B,KAAKsB,OAAOrB,iBAAiBK,KAAKN,MAClC,IAAI6B,EAAc,EAClB,GAAIhB,EAAU,CACV,MAAMiB,EAAO9B,KAAKsB,OAAOC,YAAYQ,UACjCD,EAAKE,uBACLH,EAAc,EAETC,EAAKG,qBACVJ,EAAc,EAEtB,CACA7B,KAAKkC,qBAAuB,IAAI,IAAoBzB,EAAMC,EAAMC,EAAOC,GAAiB,EAAMiB,GAAa,GAC3G7B,KAAKkC,qBAAqBC,YAAcrB,EACxC,MAAMsB,EAAwBzB,EAAMY,YAAYa,sBA0ChD,IAAIC,EAzCJrC,KAAKkC,qBAAqBI,yBAAyBC,KAAKC,IAKpD,OAJIxC,KAAKyB,aACLd,EAAM8B,sBAAsBzC,KAAKyB,WAAWe,IAC5C7B,EAAM+B,wBAAwBC,gBAE1BH,GACJ,KAAK,EACDxC,KAAKiB,KAAK2B,eAAe,EAAG,EAAG,GAC/B,MACJ,KAAK,EACD5C,KAAKiB,KAAK2B,gBAAgB,EAAG,EAAG,GAChC,MACJ,KAAK,EACD5C,KAAKiB,KAAK2B,eAAe,EAAG5C,KAAKkB,aAAe,GAAK,EAAG,GACxD,MACJ,KAAK,EACDlB,KAAKiB,KAAK2B,eAAe,EAAG5C,KAAKkB,cAAgB,EAAI,EAAG,GACxD,MACJ,KAAK,EACDlB,KAAKiB,KAAK2B,eAAe,EAAG,EAAGjC,EAAMkC,sBAAwB,EAAI,GACjE,MACJ,KAAK,EACD7C,KAAKiB,KAAK2B,eAAe,EAAG,EAAGjC,EAAMkC,qBAAuB,GAAK,GAGrE7C,KAAK8C,eACL9C,KAAKmB,SAAS4B,SAAS/C,KAAK8C,cAAcE,uBAE9ChD,KAAKmB,SAAS8B,SAASjD,KAAKiB,KAAMjB,KAAKgB,SACvC,MAAMkC,EAAiBvC,EAAMkC,qBAAuB,mBAAuB,mBACrEM,EAAsBxC,EAAMkC,qBAAuB,sBAA0B,sBACnFK,EAAelD,KAAKmB,SAAUnB,KAAKgB,QAAS,SAAchB,KAAKe,aAC3DJ,EAAMyC,eACNpD,KAAKqD,kBAAoBF,EAAoBG,KAAKC,GAAK,EAAG,EAAGnB,EAAwBzB,EAAMyC,aAAaI,KAAO7C,EAAMyC,aAAaK,KAAMrB,EAAwBzB,EAAMyC,aAAaK,KAAO9C,EAAMyC,aAAaI,KAAMxD,KAAKsB,OAAOC,YAAYmC,iBAC3O/C,EAAMgD,mBAAmB3D,KAAKe,YAAaf,KAAKqD,mBAC5C1C,EAAMyC,aAAaQ,cAAgB5D,KAAKkC,qBAAqBkB,eAC7DpD,KAAKkC,qBAAqBkB,aAAezC,EAAMyC,aAAaS,WAAa,OAGjFlD,EAAMmD,oBAAsB9D,KAAKmB,QAAQ,IAG7CnB,KAAKkC,qBAAqB6B,uBAAuBxB,KAAI,KACjD,IAAIyB,EAAIC,EACRjE,KAAKkE,iBAAmBvD,EAAM+B,wBACsB,QAAnDuB,GAAMD,EAAKrD,EAAMY,aAAa4C,uBAAoC,IAAPF,GAAyBA,EAAGG,KAAKJ,EAAI,mCAAmCvD,IAAQ,GAC5I4B,EAA4BrC,KAAKsB,OAAO+C,6BAA6BC,mBACjExD,IACAH,EAAM0D,6BAA6BC,oBAAqB,EAC5D,IAEJtE,KAAKkC,qBAAqBqC,wBAAwBhC,KAAI,KAClD,IAAIyB,EAAIC,EACRtD,EAAM0D,6BAA6BC,mBAAqBjC,EACxD1B,EAAMmD,oBAAsB,KACxB9D,KAAKyB,YACLd,EAAM8B,sBAAsBzC,KAAKkE,kBAErCvD,EAAM6D,uBAAsB,GACuB,QAAlDP,GAAMD,EAAKrD,EAAMY,aAAakD,sBAAmC,IAAPR,GAAyBA,EAAGG,KAAKJ,EAAI,EAAE,GAE1G,CAEIU,cACA,OAAO1E,KAAKkC,qBAAqBwC,OACrC,CACIA,YAAQC,GACR3E,KAAKkC,qBAAqBwC,QAAUC,CACxC,CAEIC,kBACA,OAAO5E,KAAKkC,qBAAqB0C,WACrC,CACIA,gBAAYD,GACZ3E,KAAKkC,qBAAqB0C,YAAcD,CAC5C,CAKAE,WACI,OAAO7E,KAAKsB,MAChB,CAEIwD,kBACA,OAAO9E,KAAKkC,oBAChB,CAEI6C,iBACA,OAAO/E,KAAKkC,qBAAqB6C,UACrC,CAKAC,aAAaC,GACTjF,KAAK8C,cAAgBmC,CACzB,CAMAC,kCAAkCC,EAAkBC,GAChDpF,KAAKkC,qBAAqBgD,kCAAkCC,EAAkBC,EAClF,CAIAC,UACI,MAAMnF,EAAQF,KAAKsB,OAAOrB,iBAAiBE,QAAQH,MAKnD,IAJe,IAAXE,GAEAF,KAAKsB,OAAOrB,iBAAiBG,OAAOF,EAAO,GAE3CF,KAAKqB,iBAAkB,CACvB,MAAMnB,EAAQF,KAAKqB,iBAAiBpB,iBAAiBE,QAAQH,MACzDE,GAAS,GACTF,KAAKqB,iBAAiBpB,iBAAiBG,OAAOF,EAAO,GAEzDF,KAAKqB,iBAAmB,IAC5B,CAKA,GAJIrB,KAAKkC,uBACLlC,KAAKkC,qBAAqBmD,UAC1BrF,KAAKkC,qBAAuB,MAE5BlC,KAAKyB,WAAY,CACjB,IAAK,MAAM6D,KAAOtF,KAAKyB,WACnB6D,EAAID,UAERrF,KAAKyB,WAAa,EACtB,CACJ,CAMA8D,SAASC,GACL,IAAIC,EAAM,SAAWzF,KAAKS,KAO1B,OANI+E,IACAC,GAAO,eAAiBzF,KAAKmB,SAASoE,WAClCvF,KAAK8C,gBACL2C,GAAO,oBAAsBzF,KAAK8C,cAAcrC,OAGjDgF,CACX,CAKAC,eACI,MAAO,iBACX,CAKAC,YACI,MAAMC,EAAsB,eAA8B5F,KAAMA,KAAKkC,qBAAqByD,aAG1F,OAFAC,EAAoBC,mBAAoB,EACxCD,EAAoBxE,SAAWpB,KAAKoB,SAC7BwE,CACX,CAQAE,aAAaC,EAAuBpF,EAAOqF,GACvC,IAAIC,EAAkB,KACtB,GAAItF,EAAMV,iBACN,IAAK,IAAIC,EAAQ,EAAGA,EAAQS,EAAMV,iBAAiBiG,OAAQhG,IAAS,CAChE,MAAMiG,EAAKxF,EAAMV,iBAAiBC,GAClC,GAAIiG,EAAG1F,OAASsF,EAAsBtF,KAAM,CACxCwF,EAAkBE,EAClB,KACJ,CACJ,CAUJ,OARAF,EAAkB,YAA0B,IAAMA,GAAmB,IAAI1F,EAAgBwF,EAAsBtF,KAAMsF,EAAsBK,iBAAkBzF,EAAOoF,EAAsBM,mBAAmBN,EAAuBpF,EAAOqF,GAC3OC,EAAgBnB,YAAYwB,mBAAqBP,EAAsBhB,WACnEgB,EAAsBjD,eACtBmD,EAAgBjB,aAAarE,EAAM4F,YAAYR,EAAsBjD,gBAErEiD,EAAsB3E,WACtB6E,EAAgB7E,SAAW2E,EAAsB3E,UAE9C6E,CACX,GAEJ,QAAW,EACP,WACD1F,EAAgBiG,UAAW,qBAAiB,IAC/C,QAAW,EACP,WACDjG,EAAgBiG,UAAW,gBAAY,E,8KClR1C,MACMC,EAAS,wBAGf,EAAkD,EAAE,qBAAgE,uCAAI,EAExH,MCJM,EAA2C,kTCGjD,EAAkD,EAAE,qBAA2D,kCAAI,EAEnH,MCRiE,EAAsC,sMAQhG,EAA0C,EAAE,aAAO,iC,MCJpD,EAAmB,+GAOzB,EAAkD,EAAE,qBAA8D,qCAAI,EAEtH,MCXuD,EAAoC,yaAmB3F,EAA0C,EAAE,aAA4C,gCAAI,EAoB5F,OAAO,eAAe,EAA2B,EAAE,UAAW,yBAA0B,CACpF,IAAK,WACD,OAAO,KAAK,0BAA2B,CAC3C,EACA,IAAK,SAAU,GACX,KAAK,wBAA0B,EAE3B,GACA,KAAK,wBAEb,EACO,YAAY,EACnB,cAAc,IAElB,EAAkD,EAAE,UAAU,uBAAyB,WAInF,OAHK,KAAK,uBACN,KAAK,qBAAuB,IAAI,EAAoB,OAEjD,KAAK,oBAChB,EACA,OAAO,eAAa,iCAChB,IAAK,WACD,OAAO,KAAK,mBAAoB,CACpC,EACA,IAAK,SAAU,GACX,KAAK,iBAAmB,EAEpB,GACA,KAAK,WAAW,wBAExB,EACA,YAAY,EACZ,cAAc,IAMlB,MAAM,EAKF,YAAY,GAIR,KAAK,KAAO,EAAqE,EAAE,yBAInF,KAAK,WAAa,IAAI,EAAuB,GAAG,EAAG,EAAG,GAItDzG,KAAK,UAAY,IAAI,EAAuB,GAAG,GAAK,GAAK,IAIzDA,KAAK,eAAgB,EAIrB,KAAK,+BAAiC,IAAI,EAA2B,GAIrE,KAAK,8BAAgC,IAAI,EAA2B,GAIpE,KAAK,2BAA6B,IAAI,EAA2B,GAIjEA,KAAK,SAAU,EAIf,KAAK,WAAa,IAAI,EAA2B,EAAE,IACnD,KAAK,eAAiB,CAAC,EACvB,KAAK,iBAAmB,KACxB,KAAK,eAAiB,KACtB,KAAK,MAAQ,EACb,EAAM,cAAc,MACpB,KAAK,oBAAsB,IAAI,EAAiC,EAAE,KAAK,MAAM,iBAAa,OAAW,EAAW,4BAA6B,KAAK,MAAM,YAAY,UACpK,KAAK,oBAAoB,KAAK,qBAC9B,KAAK,mBAAqB,IAAI,EAAiC,EAAE,KAAK,MAAM,iBAAa,OAAW,EAAW,2BAA4B,KAAK,MAAM,YAAY,UAClK,KAAK,oBAAoB,KAAK,mBAClC,CACA,oBAAoB,GAChB,EAAI,WAAW,QAAS,GACxB,EAAI,WAAW,QAAS,IACxB,EAAI,WAAW,iBAAkB,IACjC,EAAI,WAAW,kBAAmB,IAClC,EAAI,QACR,CAIA,WACI,KAAK,MAAM,+BAA+B,aAAa,EAA8F,EAAE,kDAAmD,KAAM,KAAK,OACrN,KAAK,MAAM,oBAAoB,aAAa,EAAmF,EAAE,uCAAwC,KAAM,KAAK,gBACpL,KAAK,MAAM,sBAAsB,aAAa,EAAqF,EAAE,yCAA0C,KAAM,KAAK,kBAC1LA,KAAK,MAAM,8BAA8B,aAAa,EAA6F,EAAE,iDAAkD,KAAM,KAAK,OACtN,CACA,iBAAiB,EAAM,GACnB,GAAI,EAAK,yBAA0B,CAC/B,MAAM,EAAe,EAAQ,kBACzB,UACA,EAAa,YAAY,KAAO,EAAK,iBACrC,KAAK,WAAW,KAAK,EAAa,aAE1C,CACJ,CACA,eAAe,GACX,GAAI,EAAK,iBAAmB,KAAK,MAAM,uBAAwB,CAC3D,MAAM,EAAe,EAAK,kBAC1B,EAAY,oCACZ,KAAK,WAAW,mBACpB,CACJ,CACA,oBACI,GAAI,KAAK,aACL,OAEJA,KAAK,aAAe,IAAI,EAAmC,EAAE,cAAe,KAAK,MAAO,sBAAuB,CAC3G,WAAY,CAAC,EAA8C,EAAE,cAC7D,SAAU,CAAC,QAAS,iBAAkB,kBAAmB,SACzD,eAAgB,CAAC,yBAClB,GACH,KAAK,aAAa,gBAAiB,EACnC,KAAK,aAAa,kBAAoB,CAClC,QAAQ,GAEZ,KAAK,8BAAgC,IAAI,EAAmC,EAAE,sBAAuB,KAAK,MAAO,sBAAuB,CACpI,WAAY,CAAC,EAA8C,EAAE,cAC7D,SAAU,CAAC,QAAS,iBAAkB,kBAAmB,SACzD,eAAgB,CAAC,yBAClB,GACH,KAAK,8BAA8B,gBAAiB,EACpD,KAAK,8BAA8B,kBAAoB,CACnD,QAAQ,GAEZ,MAAM,EAAS,KAAK,MAAM,YACpB,GAAU,EAAG,EAAoC,IAAI,CAAE,KAAM,IACnE,KAAK,eAAe,EAA8C,EAAE,cAAgB,IAAI,EAAiC,EAAE,EAAQ,EAAQ,UAAW,EAA8C,EAAE,cAAc,GACpN,KAAK,qBACL,KAAK,eAAiB,EAAQ,QAC9B,KAAK,2BAA2B,gBAAgB,KACpD,CACA,qBACI,MAAM,EAAS,KAAK,MAAM,YAC1B,KAAK,aAAe,EAAO,kBAAkB,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACvH,CAKA,UACI,MAAM,EAAK,KAAK,eAAe,EAA8C,EAAE,cAC3E,GACA,EAAG,WAEP,KAAK,oBACT,CAIA,QACI,KAAK,WAAW,OACpB,CAKA,OAAO,GACH,IAAI,EAAI,EACR,GAA+B,IAA3B,KAAK,WAAW,SAAiB,KAAK,QACtC,OAGJ,GADA,KAAK,qBACA,KAAK,aAAa,UACnB,OAEJ,MAAM,EAAS,KAAK,MAAM,YAC1B,EAAO,eAAc,GACrB,MAAM,EAAa,KAAK,WAAW,WAC7B,EAAY,KAAK,UAAU,WAC3B,EAAkB,KAAK,MAAM,qBACnC,IAAK,IAAI,EAAmB,EAAG,EAAmB,KAAK,WAAW,OAAQ,IAAoB,CAC1F,MAAM,EAAc,KAAK,WAAW,KAAK,GACzC,GAAI,EAAY,OAAS,EACrB,SAEJ,KAAK,8BAA8B,GACnCA,KAAK,+BAA+B,gBAAgB,GACpD,MAAM,EAAM,EAAY,QAElB,EADM,EAAY,QACP,SAAS,GACpB,EAAS,EAAI,IAAI,EAAK,MAAM,KAC5B,EAAc,EAAgC,GAAG,QAAQ,EAAK,EAAG,EAAK,EAAG,EAAK,GAAG,SAAS,EAAoC,GAAG,YAAY,EAAO,EAAG,EAAO,EAAG,EAAO,IAAI,SAAS,EAAY,kBACjM,EAAwB,EAAO,sBACrC,GAAI,KAAK,cAAe,CACpB,MAAM,EAA0D,QAAvC,EAAK,EAAY,wBAAqC,IAAP,EAAgB,EAAK,KAAK,aAAa,kBAC/G,KAAK,aAAa,SAAS,GAC3B,EAAO,YAAY,KAAK,eAAgB,KAAK,aAAc,KAAK,aAAa,aAEzE,EACA,EAAO,gCAGP,EAAO,mCAEX,KAAK,mBAAmB,aAAa,EAAgB,OAAQ,uBAC7D,KAAK,mBAAmB,mBAAmB,QAAS,GACpD,KAAK,mBAAmB,aAAa,QAAS,GAC9C,KAAK,mBAAmB,aAAa,iBAAkB,GACvD,KAAK,mBAAmB,SAExB,EAAO,iBAAiB,EAAwC,EAAE,iBAAkB,EAAG,GAC3F,CACA,MAAM,EAAyC,QAArB,EAAK,EAAI,yBAA2B,IAAP,EAAgB,EAAK,KAAK,aAAa,kBAC9F,KAAK,aAAa,SAAS,GAC3B,EAAO,YAAY,KAAK,eAAgB,KAAK,aAAc,KAAK,aAAa,aAEzE,EACA,EAAO,4BAGP,EAAO,yBAEX,KAAK,oBAAoB,aAAa,EAAiB,OAAQ,uBAC/DA,KAAK,oBAAoB,mBAAmB,QAAS,GACrDA,KAAK,oBAAoB,aAAa,QAAS,GAC/C,KAAK,oBAAoB,aAAa,iBAAkB,GACxD,KAAK,oBAAoB,SAEzB,EAAO,iBAAiB,EAAwC,EAAE,iBAAkB,EAAG,IACvF,KAAK,8BAA8B,gBAAgB,EACvD,CACA,KAAK,aAAa,SAClB,EAAO,gCACP,EAAO,eAAc,EACzB,CACA,8BAA8B,GAC1B,IAAK,EAAY,kBAAmB,CAChC,MAAM,EAAS,KAAK,MAAM,YAC1B,EAAY,kBAAoB,IAAI,EAA6B,EAAE,GACnE,EAAY,iBAAmB,IAAI,EAA6B,EAAE,GAClE,EAAY,kBAAkB,UAAU,KAAK,aAAa,aAC1D,EAAY,iBAAiB,UAAU,KAAK,aAAa,YAC7D,CACJ,CAKA,2BAA2B,GACvB,MAAM,EAAS,KAAK,MAAM,iBACkB,IAAxC,KAAK,iCACL,KAAK,+BAAiC,EAAO,mBAAmB,oCAEpE,MAAM,EAAsB,EAAO,oBACnC,EAAO,oBAAsB,KAAK,+BAClCA,KAAK,oBACL,MAAM,EAAU,EAAK,UAAU,GAC/B,IAAK,KAAK,8BAA8B,QAAQ,OAAM,EAAW,KAAa,EAAK,gBAE/E,YADA,EAAO,oBAAsB,GAG5B,KAAK,mBACN,KAAK,iBAAmB,EAAO,kBAAkB,KAAK,iBAE1D,MAAM,EAAwB,EAAO,sBACrC0G,EAAO,eAAc,GACrB,EAAO,eAAc,GACrB,MAAM,EAAc,EAAK,kBAAkB,YACrC,EAAM,EAAY,QAElB,EADM,EAAY,QACP,SAAS,GACpB,EAAS,EAAI,IAAI,EAAK,MAAM,KAC5B,EAAc,EAAgC,GAAG,QAAQ,EAAK,EAAG,EAAK,EAAG,EAAK,GAAG,SAAS,EAAoC,GAAG,YAAY,EAAO,EAAG,EAAO,EAAG,EAAO,IAAI,SAAS,EAAY,kBACjM,EAAc,EAAQ,aAC5B,KAAK,8BAA8B,SAAS,GAC5C,EAAO,YAAY,KAAK,eAAgB,KAAK,iBAAkB,EAAY,QACvE,EACA,EAAO,4BAGP,EAAO,yBAEX1G,KAAK,MAAM,sBACXA,KAAK,oBAAoB,aAAa,EAAY,OAAQ,uBAC1DA,KAAK2G,oBAAoB,aAAa,QAAS,GAC/C3G,KAAK,oBAAoB,aAAa,iBAAkB,KAAK,MAAM,sBACnE,KAAK,oBAAoB,SACzB,EAAO,iBAAiB,EAAwC,EAAE,iBAAkB,EAAG,IACvF,KAAK,8BAA8B,SACnC,EAAO,gCACP,EAAO,eAAc,GACrB,EAAO,eAAc,GACrB,EAAO,oBAAsB,CACjC,CAIA,U,QACJ,IAAY,KAAK,iC,uiBC9VuC,KAAK,MAAM,YAAY,eAAe,KAAK,cACnC,KAAK,mBACE,KAAK,MAAM,YAAY,eAAe,KAAK,kBACnB,KAAK,iBAAmB,KAErE,EAIO,EAEnD,MACA,CAAE,EAAqC,EAAqB,KAE7C,EAAoB,EAAE,EAAqB,CAClC,EAAK,IAAM,IAEpB,IAAI,EAAoD,EAAoB,OACxE,EAAkD,EAAoB,OACtE,EAA8D,EAAoB,OAClF,EAA0E,EAAoB,OAC9F,EAA4D,EAAoB,OAChF,EAAkD,EAAoB,MAGtE,GAF0D,EAAoB,OACtB,EAAoB,MAC3B,EAAoB,QACrE,EAAqE,EAAoB,OAgBlH,MAAM,EAMF,wBAAwB,EAAM,GAC1BA,KAAK,UAAU,wBAAwB,EAAM,EACjD,CAWA,YAAY,EAAO,EAAO,EAAG,EAAS,KAAM,GAAsB,EAAO,EAAe,EAAkG,EAAE,uBAAwB,GAAoB,EAAO,GAE3O,KAAK,SAAU,EAEf,KAAK,kCAAmC,EAMxC,KAAK,uBAAwB,EAI7BA,KAAK,gBAAiB,EACtBA,KAAK,OAAS,EACdA,KAAK,qBAAuB,EAC5B,KAAK,mBAAqB,EAC1BA,KAAK,SAAoB,IAAT,EACZ,KAAK,SACL,KAAK,WAAa,IAAI,EAAgE,GAAG,EAAK,EAAK,EAAK,GAGxG,KAAK,WAAa,IAAI,EAAgE,GAAG,EAAK,EAAK,EAAK,GAE5G,EAAc,8BAA8B,KAAK,QACjD,MAAM,EAAS,EAAM,YACrB,KAAK,QAAU,EACX,IAAiB,EAAgG,EAAE,uBACtG,IAAT,GAAe,EAAO,MAAM,8BAC5B,EAAe,EAAgG,EAAE,sBAExG,IAAT,GAAe,EAAO,MAAM,kCAC5B,EAAe,EAAgG,EAAE,uBAIzH,MAAM,EAAS,KAAK,WAAa,EAAO,UAAU,8BAAgC,EAAI,EACtF,KAAK,UAAY,IAAI,EAAmG,EAAE,QAAmC,EAAO,gBAAiB,CAAE,MAAO,EAAO,iBAAkB,OAAQ,EAAO,mBAAqB,KAAK,QAAQ,GAAO,EAAM,GAAM,EAAO,OAAc,OAAW,OAAW,EAAW,GACjV,KAAK,UAAU,MAAQ,EAA6F,EAAE,kBACtH,KAAK,UAAU,MAAQ,EAA6F,EAAE,kBACtH,KAAK,UAAU,YAAc,EAC7B,KAAK,UAAU,iBAAkB,EACjC,KAAK,UAAU,WAAa,KAE5B,KAAK,UAAU,aAAe,KAAK,QACnC,KAAK,UAAU,sBAAuB,EACtC,KAAK,UAAU,wBAAyB,EAExC,KAAK,UAAU,kBAAkB,KAAK,IAClC,EAAO,MAAM,KAAK,YAAY,GAAM,GAAM,EAAK,IAEnD,KAAK,UAAU,uBAAuB,KAAI,KACtC,IAAI,EAC8B,QAAjC,EAAK0G,EAAO,uBAAoC,IAAP,GAAyB,EAAG,KAAK,EAAQ,iBAAkB,EAAE,IAE3G,KAAK,UAAU,wBAAwB,KAAI,KACvC,IAAI,EAC6B,QAAhC,EAAK,EAAO,sBAAmC,IAAP,GAAyB,EAAG,KAAK,EAAQ,EAAE,IAExF,KAAK,UAAU,sBAAwB,CAAC,EAAM,EAAa,KACvD,IAAK,GAA2B,IAAhB,IAAsB,EAAK,UACvC,IAAK,IAAI,EAAI,EAAG,EAAI,EAAK,UAAU,SAAU,EAAG,CAC5C,MAAM,EAAU,EAAK,UAAU,GACzB,EAAgB,EAAQ,mBACxB,EAAQ,EAAc,wBAAwB,EAAQ,MAAO,EAAQ,sBACrE,EAA6B,EAAO,UAAU,kBACN,OAAxC,EAAM,iBAAiB,EAAQ,WAAyD,IAAxC,EAAM,iBAAiB,EAAQ,MAAuB,EAAc,kBAC1H,IAAK,KAAK,QAAQ,EAAS,GACvB,OAAO,CAEf,CAEJ,OAAO,CAAI,EAGf,MAAM,EAAiB,IACnB,IAAI,EAAI,EACR,MAAM,EAAgB,EAAQ,mBACxB,EAAgB,EAAQ,mBACxB,EAAQ,KAAK,OACb,EAAS,EAAM,YACf,EAAW,EAAQ,cAEzB,GADA,EAAc,8BAA8B,uBAAwB,GAC/D,GAAY,EAAc,kBAAoB,EAAS,mBAA+C,IAA1B,EAAQ,eAAuB,EAAQ,YAAc,EAAM,cACxI,OAGJ,MAAM,EAAS,EAAc,6BAA+B,EAC5D,IAAI,EAA2E,QAAxD,EAAK,EAAc,uCAAoD,IAAP,EAAgB,EAAK,EAAS,gBACjH,IACA,EACwB,IAApB,EACM,EACA,GAEd,MAAM,EAA6C,IAApB,EAC/B,EAAO,SAAS,EAAS,gBAAiB,GAAG,EAAO,EAAwB,KAAK,gBAAkB,EAAS,cAAgB,EAAS,eAErI,MAAM,EAAQ,EAAc,wBAAwB,EAAQ,MAAO,EAAQ,sBAC3E,GAAI,EAAM,WACN,OAEJ,MAAM,EAA6B,EAAO,UAAU,kBACN,OAAxC,EAAM,iBAAiB,EAAQ,WAAyD,IAAxC,EAAM,iBAAiB,EAAQ,MAAuB,EAAc,kBACpH,EAAS,KAAK,SAAW,EAAM,aACrC,GAAI,KAAK,QAAQ,EAAS,IAA+B,EAAQ,CAC7D,EAAQ,UAAY,EAAM,cAC1B,MAAM,EAAkG,QAA7E,EAAK,EAAc,8BAA8B,8BAA2C,IAAP,OAAgB,EAAS,EAAG,EAAO,qBACnJ,IAAI,EAAc,EAAQ,mBACrB,GAAe,IAChB,EAAc,EAAkB,mBAEpC,MAAM,EAAgB,EAAO,OAAS,EAAkF,EAAE,oBAC1H,IAAK,EACD,OAEJ,MAAM,EAAS,EAAY,OAe3B,IAAI,EAAM,EAUV,GAxBA,EAAO,aAAa,GACf,GACD,EAAc,MAAM,EAAS,EAAQ,EAAS,UAE7C,EAQD,EAAkB,eAAe,EAAc,iBAAkB,EAAe,IAPhF,EAAO,UAAU,iBAAkB,EAAM,sBACzC,EAAO,UAAU,QAAS,EAAc,kBACpC,KAAK,oBACL,EAAO,UAAU,OAAQ,EAAM,kBAOnC,GACA,GAAQ,EAAO,uBAAyB,EAAO,gBAAkB,EAAI,EACrE,EAAO,EAAO,uBAAyB,EAAO,gBAAkB,EAAI,IAGpE,EAAO,EAAO,uBAAyB,EAAO,gBAAkB,EAAO,KAAO,EAAO,gBAAkB,EAAI,EAAO,KAClH,EAAO,EAAO,uBAAyB,EAAO,gBAAkB,EAAI,EAAO,MAE/E,EAAO,UAAU,cAAe,EAAM,EAAO,IACzC,GAEA,GAAI,EAAS,mBAAoB,CAC7B,MAAM,EAAe,EAAS,sBAC1B,IACA,EAAO,WAAW,iBAAkB,GACpC,EAAO,UAAU,gBAAiB,EAAa,oBAEvD,CAEA,GAAI,EAAc,UAAY,EAAc,0BAA4B,EAAc,SAAU,CAC5F,MAAM,EAAW,EAAc,SAC/B,GAAI,EAAS,0BAA2B,CACpC,MAAM,EAAc,EAAS,0BAA0B,GACvD,IAAK,EACD,OAEJ,EAAO,WAAW,cAAe,GACjC,EAAO,SAAS,mBAAoB,GAAO,EAAS,MAAM,OAAS,GACvE,MAEI,EAAO,YAAY,SAAU,EAAS,qBAAqB,GAEnE,EAEA,EAAG,EAAwF,IAAI,EAAQ,EAAU,GAEjH,EAA0G,EAAE,0BAA0B,EAAe,GACjJ,EAAc,oBAAsB,EAAc,mBAAmB,0BACrE,EAAc,mBAAmB,MAAM,EAE/C,CAEA,EAAc,kBAAkB,EAAe,EAAS,EAAQ,EAAS,SAAU,EAAO,GAA4B,CAAC,EAAY,IAAU,EAAO,UAAU,QAAS,IAC3K,GAEJ,KAAK,UAAU,qBAAuB,CAAC,EAAiB,EAAoB,EAAsB,KAC9F,IAAI,EACJ,GAAI,EAAmB,OACnB,IAAK,EAAQ,EAAG,EAAQ,EAAmB,OAAQ,IAC/C,EAAc,EAAmB,KAAK,IAG9C,IAAK,EAAQ,EAAG,EAAQ,EAAgB,OAAQ,IAC5C,EAAc,EAAgB,KAAK,IAEvC,IAAK,EAAQ,EAAG,EAAQ,EAAmB,OAAQ,IAC/C,EAAc,EAAmB,KAAK,IAE1C,GAAI,KAAK,iCACL,IAAK,EAAQ,EAAG,EAAQ,EAAqB,OAAQ,IACjD,EAAc,EAAqB,KAAK,SAI5C,IAAK,EAAQ,EAAG,EAAQ,EAAqB,OAAQ,IACjD,EAAqB,KAAK,GAAO,mBAAmB,8BAA8B,uBAAwB,CAElH,CAER,CAOA,QAAQ,EAAS,GACb,IAAI,EACJ,MAAM,EAAS,KAAE,mBACX,EAAO,EAAI,UACX,EAAQ,EAAK,WACb,EAAe,8GACrB,GAAI,EACA,OAAO,EAAkB,kBAAkB,EAAM,EAAS,GAE9D,MAAM,EAAW,EAAQ,cACzB,IAAK,GAAY,EAAS,kBACtB,OAAO,EAEX,MAAM,EAAU,GACV,EAAU,CAAC,EAAiF,EAAE,cAcpG,GAZI,GAAY,EAAS,oBAAsB,EAAS,wBACpD,EAAQ,KAAK,qBACT,EAAK,sBAAsB,EAA2E,EAAE,UACxG,EAAQ,KAAK,EAA2E,EAAE,QAC1F,EAAQ,KAAK,gBAEb,EAAK,sBAAsB,EAA4E,EAAE,WACzG,EAAQ,KAAK,EAA4E,EAAE,SAC3FE,EAAQtG,KAAK,iBAIjB,EAAK,UAAY,EAAK,yBAA0B,CAChD,EAAI,8BACJ,EAAQ,KAAK,EAAwF,EAAE,qBACnG,EAAK,mBAAqB,IAC1B,EAAQ,KAAK,EAA6F,EAAE,0BAC5G,EAAQ,KAAK,EAA6F,EAAE,2BAEhH,6DACA,EAAQ,KAAK,yBAA2B,EAAK,SAAW,EAAK,SAAS,MAAM,OAAS,EAAI,IACzF,MAAM,EAAW,EAAQ,mBAAmB,UACxC,aAA2C,EAAS,EAAS,4BAC7D,EAAQ,KAAK,sBAErB,MAEI,EAAQ,KAAK,kCAGjB,MAAM,EAAqB,EAAK,mBAChC,IAAI,EAAsB,EACtB,GACI,EAAmB,eAAiB,IACpC,EAAsB,EAAmB,eACzC,EAAQ,KAAK,wBACb,EAAQ,KAAK,iCAAmC,GACxD,4BACY,EAAQ,KAAK,gCAEjB,EAA4H,EAAE,4CAA4C,EAAS,EAAM,IAI7L,IACA,EAAQ,KAAK,qBACb,EAA2G,EAAE,2BAA2B,GACpI,EAAQ,mBAAmB,kBAC3B,EAAQ,KAAK,2BAIjB,KAAK,sBACL,EAAQ,KAAK,0BAGb,KAAK,oBACL,EAAQ,KAAK,+BAGb,KAAK,UACL,EAAQ,KAAK,mBAGjB,EAAG,EAAsG,IAAI,EAAU,EAAO,GAE9H,MAAM,EAAc,EAAQ,qBAAgB,GAAW,GACjD,EAAgB,EAAY,QAC5B,EAAO,EAAQ,KAAK,MAC1B,GAAI,IAAkB,EAAM,CACxB,MAAM,EAAW,CACb,QACA,SACA,mBACA,iBACA,OACA,gBACA,cACA,wBACA,yBACA,8BAEJ,EAAG,EAA+F,IAAI,GACtG,EAAY,UAAU,EAAO,aAAa,QAAS,EAAS,EAAU,CAAC,iBAAkB,eAAgB,eAAgB,OAAM,OAAW,OAAW,EAAW,CAC5J,4BAA6B,IAC7B,EACR,CACA,OAAO,EAAY,OAAO,SAC9B,CAKA,cACI,OAAO,KAAK,S,+MC5XoC,EAKQ,EAAc,8BAAiC,IAC7D,MAAM,EAAG,EAAkE,GAAG,8BAA8B,CAIpG,EAE1D,MACM,CAAE,EAAqC,EAAqB,KAG7C,IAAI,EAAkD,EAAoB,OACtE,EAAuD,EAAoB,OAC3E,EAAoD,EAAoB,OACjG,WACyB,EAAsD,EAAoB,OAC1E,EAA4D,EAAoB,OAChF,EAAkD,EAAoB,MAGtE,GAFyD,EAAoB,OAChF,SACsD,EAAoB,OACvE,EAA0D,EAAoB,OAavG,EAAyG,EAAE,UAAU,sBAAwB,WAKzI,OAJI,KAAK,iBACL,KAAK,eAAe,UACpB,KAAK,eAAiB,MAEnB,IACX,EACA,EAAwG,EAAE,UAAU,qBAAuB,SAAU,EAAU,IAAM,GAAgC,EAAO,GAGxM,OAFA,KAAK,wBACL,KAAK,eAAiB,IAAI,EAAc,KAAM,EAAS,GAA+B,EAAM,GACrF,IACX,EACA,OAAO,eAAe,EAAmF,EAAE,UAAW,gBAAiB,CACnI,IAAK,WACM,OAAO,KAAK,cACvB,EACA,YAAY,EACZ,cAAc,IAElB,EAAkG,EAAE,UAAU,qBAAuB,SAAU,EAAU,IAAM,GAAgC,GAG3L,OAFA,KAAK,wBACL,KAAK,eAAiB,IAAI,EAAkB,KAAM,EAAS,GACpD,IACX,EAEA,EAA2G,EAAE,UAAU,qBAAuB,SAAU,EAAU,IAAM,GAAgC,GAEpM,OADA,EAAwG,EAAE,UAAU,qBAAqB,MAAM,KAAM,WAC9I,IACX,EAIA,MAAM,EACF,cACIN,KAAK,MAAQ,IAAI,MACjB,KAAK,oBAAsB,CAC/B,EAKJ,MAAM,EAEE,qBACA,OAAO,KAAK,eAChB,CAEI,mBACA,OAAO,KAAK,aAChB,CAEI,mBACA,OAAO,KAAK,aAChB,CAII,iBACA,OAAO,KAAK,WAChB,CACI,eAAW,GACX,KAAK,YAAc,CACvB,CACA,kBAAkB,GACd,IAAK,EAAM,sBAAuB,CAC9B,MAAM,EAAS,IAAI,EAAgF,EAAE,aAAc,EAAO,OAAQ,CAC9H,WAAY,CAAC,WAAY,UACzB,SAAU,CAAC,QAAS,iBAAkB,QAAS,QAAS,iBACzD,GACH,EAAO,mBAAoB,EAC3B,EAAO,iBAAkB,EACzB,EAAO,sBAAwB,EAAM,YAAY,SACjD,EAAM,sBAAwB,CAClC,CACA,OAAO,EAAM,qBACjB,CAUA,YAAY,EAAQ,EAAU,IAAE,aAC5B,IAAI,EAIJ,KAAK,gCAAkC,IAIvC,KAAK,+BAAiC,GACtC,KAAK,gBAAkB,IAAI,MAC3BA,KAAK,cAAgB,IAAI,MACzB,KAAK,cAAgB,IAAI,MACzB,KAAK,SAAW,CAAC,EACjBA,KAAK,qBAAuB,CAAC,EAC7B,KAAK,gCAAiC,EAEtC,KAAK,WAAY,EAIjB,KAAK,gBAAkB,IAAI,EAAmE,EAAE,IAChGA,KAAK,QAAU,EACf,KAAK,+BAAiC,EACtC,KAAK,SAAW,QAAyC,EAAU,KACnE,KAAK,SAAW,EACZ,KAAK,QAAQ,WAAU,uBACvB,KAAK,aAAe,IAAI,EAA2E,EAAE,EAAO,cAEhH,KAAK,qBACD,IACgG,QAA3F,EAAK,aAAyC,EAAS,EAAQ,8BAA2C,IAAP,GAAgB,EACpH,KAAK,+BAGL,KAAK,uBAGb,KAAK,qBAAuB,KAAK,QAAQ,oBAAoB,KAAI,KAC7D,KAAK,UAAU,IAEnB,KAAK,qBAAuB,KAAK,QAAQ,oBAAoB,KAAI,KAC7D,KAAK,SAAS,GAEtB,CACA,qBACQ,KAAK,cAGT,KAAK,YAAc,EAAc,WAAW,KAAK,QAAQ,YAC7D,CAEA,WACI,IAAI,EAAS,KAAK,aAAwB,cACtC,GACA,EAAO,WAEX,EAAS,KAAK,SAAS,EAA+E,EAAE,YACpG,GACA,EAAO,WAEX,MACM,EADQ,KAAK,QAAQ,WACN,YACrB,KAAK,IAAM,EAAO,kBAAkB,KAAK,cAC7C,CAIA,UACI,IAAI,EACJ,KAAK,QAAQ,oBAAoB,OAAO,KAAK,sBAC7C,KAAK,QAAQ,oBAAoB,OAAO,KAAK,sBAC7C,IAAI,EAAS,KAAK,SAAS,EAAiF,EAAE,cAC1G,IACA,EAAO,UACP,KAAK,SAAS,EAAiF,EAAE,cAAgB,MAErH,EAAS,KAAK,SAAS,EAA+E,EAAE,YACpG,IACA,EAAO,UACP,KAAK,SAAS,EAA+E,EAAE,YAAc,MAE7G,KAAK,KACL,KAAK,QAAQ,WAAW,YAAY,eAAe,KAAK,KAE5D,KAAK,YAAY,UACY,QAA5B,EAAK,KAAK,oBAAiC,IAAP,GAAyB,EAAG,SACrE,CACA,2BAA2B,EAAI,EAAI,EAAI,EAAI,GACvC,OAAK,IAAO,GAAM,IAAO,GAAQ,IAAO,GAAM,IAAO,EAC1C,EAEN,IAAO,GAAM,IAAO,GAAQ,IAAO,GAAM,IAAO,EAC1C,EAEN,IAAO,GAAM,IAAO,GAAQ,IAAO,GAAM,IAAO,EAC1C,GAEH,CACZ,CACA,uCAAuC,EAAI,EAAI,EAAI,EAAI,GACnD,MAAM,EAAM,MACZ,OAAK,EAAG,kBAAkB,EAAI,IAAQ,EAAG,kBAAkB,EAAI,IAAU,EAAG,kBAAkB,EAAI,IAAQ,EAAG,kBAAkB,EAAI,GACxH,EAEN,EAAG,kBAAkB,EAAI,IAAQ,EAAG,kBAAkB,EAAI,IAAU,EAAG,kBAAkB,EAAI,IAAQ,EAAG,kBAAkB,EAAI,GACxH,EAEN,EAAG,kBAAkB,EAAI,IAAQ,EAAG,kBAAkB,EAAI,IAAU,EAAG,kBAAkB,EAAI,IAAQ,EAAG,kBAAkB,EAAI,GACxH,GAEH,CACZ,CAUA,WAAW,EAAW,EAAM,EAAa,EAAI,GACzC,IAAI,EACJ,QAAa,IAAT,EACA,GAAmB,MAElB,CAED,EADmB,EAAsE,EAAE,IAAI,EAAY,GAAY,EAAY,IACnG,KAAK,QACzC,CACI,GACA,KAAK,WAAW,EAAI,EAAI,KAAK,gBAAgB,OAAS,EAE9D,CASA,WAAW,EAAI,EAAI,GAEf,KAAK,gBAAgB,KAAK,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAE/F,KAAK,cAAc,KAAK,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAE3G,KAAK,cAAc,KAAK,EAAQ,EAAS,EAAG,EAAS,EAAG,EAAQ,EAAS,EAAG,EAAS,EACzF,CAQA,oBAAoB,EAAY,EAAe,EAAS,GACpD,MAAM,EAAgB,CAAC,EAAY,EAAc,KACzC,GAAc,GACd,EAAa,KAAK,GAEtB,IAAK,IAAI,EAAI,EAAG,EAAI,EAAW,SAAU,EACrC,EAAa,KAAK,EAAW,GAAG,GACpC,EAEJ,IAAI,EAAY,EACZ,EAAW,GAAG,QAAU,EAAW,GAAG,QAAU,EAAW,GAAG,QAAU,EAAW,GAAG,OACtF,EAAY,EAEP,EAAW,GAAG,QAAU,EAAW,GAAG,QAAU,EAAW,GAAG,QAAU,EAAW,GAAG,SAC3F,EAAY,GAEhB,IAAK,IAAI,EAAI,EAAG,EAAI,IAAK6G,EACjB,IAAM,EACN,EAAW,GAAG,MAAK,CAAC,EAAG,IAAO,EAAE,GAAK,EAAE,IAAM,EAAI,EAAE,GAAK,EAAE,GAAK,EAAI,IAGnE,EAAW,GAAG,MAAK,CAAC,EAAG,IAAO,EAAE,GAAK,EAAE,IAAM,EAAI,EAAE,GAAK,EAAE,GAAK,EAAI,IAG3E,MAAM,EAAmB,GAAI,EAAoB,GACjD,EAAc,EAAW,GAAY,GAAmB,GACxD,MAAM,EAAgB,EAAiB,OACvC,IAAK,IAAI,EAAI,EAAY,EAAG,GAAK,EAAY,IAAK,EAC9C,EAAc,EAAW,EAAI,GAAI,EAAmB,IAAM,EAAY,EAAI,EAAmB,EAAQ,GAAkB,EAAI,GAAK,KAAQ,GAE5I,MAAM,EAAiB,EAAkB,OAGzC,EAAQ,KAAK,EAAmB,EAAQ,EAAgB,IAAa,EAAiB,GAAI,EAAkB,IAC5G,EAAQ,KAAK,EAAmB,EAAQ,GAAkB,EAAY,GAAK,IAAM,EAAkB,EAAiB,GAAI,EAAiB,EAAgB,IACzJ,MAAM,EAAe,GAAiB,EAChC,EAAa,EAAe,EAAgB,EAC5C,EAAc,EAAe,EAAiB,EAC9C,EAAiB,EAAe,EAAgB,EAAI,EAAiB,EACrE,EAAU,EAAe,EAAI,EACnC,IAAI,EAAU,EAAgB,EAAiB,EAC3C,EAVY,EAWZ,EAVa,EAWjB,MAAM,EAAe,EAAe,EAAmB,EACjD,EAAgB,EAAe,EAAU,EAC/C,IAAI,EAAS,EACb,KAAO,KAAY,GAAG,CAQlB,IAAI,EAPA,EACA,EAAQ,KAAK,EAAa,GAAY,EAAc,IAGpD,EAAQ,KAAK,EAAc,GAAa,EAAa,IAEzD,GAAU,EAEN,GAAU,GAAe,EAAY,GACrC,EAAU,IAAe,GACzB,GAAU,GAGV,EAAU,IAAgB,GAE9B,EAAQ,KAAK,EACjB,CACA,EAAQ,EAAgB,GAAK,EAAQ,EAAQ,OAAS,GACtD,EAAQ,EAAgB,GAAK,EAAQ,EAAQ,OAAS,GACtD,EAAQ,EAAgB,GAAK,EAAQ,EAAQ,OAAS,GACtD,EAAQ,OAAS,EAAQ,OAAS,CACtC,CACA,+BACI,IAAI,EAAI,EAAI,EAAI,EAAI,EAAI,EAAI,EAAI,EAAI,EAAI,EACxC,MAAM,EAAY,KAAK,QAAQ,gBAAgB,EAAiF,EAAE,cAClI,IAAI,EAAU,KAAK,QAAQ,aAC3B,IAAK,IAAY,EACb,OAEC,MAAM,QAAQ,KACf,EAAU,MAAM,KAAK,IAKzB,MAAM,EAAkH,QAA3F,EAA8B,QAAxB,EAAK,KAAK,gBAA6B,IAAP,OAAgB,EAAS,EAAG,2BAAwC,IAAP,GAAgB,EAC1I,EAAiB,EAAsB,KAAK,OAAO,KAAK,IAA+F,QAA1F,EAA8B,QAAxB,EAAK,KAAK,gBAA6B,IAAP,OAAgB,EAAS,EAAG,0BAAuC,IAAP,EAAgB,EAAK,MAAQ,KAAK,IAAI,KAAkG,QAA1F,EAA8B,QAAxB,EAAK,KAAK,gBAA6B,IAAP,OAAgB,EAAS,EAAG,0BAAuC,IAAP,EAAgB,EAAK,KACpU,EAAqB,GACrB,EAAkB,GACxB,GAAI,EAAqB,CACrB,MAAM,EAAc,CAAC,EACrB,IAAK,IAAI,EAAK,EAAG,EAAK,EAAU,OAAQ,GAAM,EAAG,CAC7C,MAAM,EAAK,EAAU,EAAK,GAAI,EAAK,EAAU,EAAK,GAAI,EAAK,EAAU,EAAK,GACpE,EAAM,EAAG,QAAQ,GAAkB,IAAM,EAAG,QAAQ,GAAkB,IAAM,EAAG,QAAQ,GAC7F,QAAyB,IAArB,EAAY,GACZ,EAAmB,KAAK,EAAY,QAEnC,CACD,MAAM,EAAM,EAAK,EACjB,EAAY,GAAO,EACnB,EAAmB,KAAK,GACxB,EAAgB,KAAK,EACzB,CACJ,CACJ,MAEI,IAAK,IAAI,EAAK,EAAG,EAAK,EAAU,OAAQ,GAAM,EAAG,CAC7C,MAAM,EAAK,EAAU,EAAK,GAAI,EAAK,EAAU,EAAK,GAAI,EAAK,EAAU,EAAK,GAC1E,IAAI,GAAQ,EACZ,IAAK,IAAI,EAAK,EAAG,EAAK,IAAO,EAAO,GAAM,EAAG,CACzC,MAAM,EAAK,EAAU,EAAK,GAAI,EAAK,EAAU,EAAK,GAAI,EAAK,EAAU,EAAK,GAC1E,GAAI,KAAK,IAAI,EAAK,GAAM,GAAkB,KAAK,IAAI,EAAK,GAAM,GAAkB,KAAK,IAAI,EAAK,GAAM,EAAgB,CAChH,EAAmB,KAAK,EAAK,GAC7B,GAAQ,EACR,KACJ,CACJ,CACK,IACD,EAAmB,KAAK,EAAK,GAC7B,EAAgB,KAAK,EAAK,GAElC,CAEJ,GAA6B,QAAxB,EAAK,KAAK,gBAA6B,IAAP,OAAgB,EAAS,EAAG,kBAAmB,CAqBhF,MAAM,EAAgH,QAA5F,EAA8B,QAAxB,EAAK,KAAK,gBAA6B,IAAP,OAAgB,EAAS,EAAG,4BAAyC,IAAP,EAAgB,EAAK,KAC7I,EAAgB,GACtB,IAAK,IAAI,EAAQ,EAAG,EAAQ,EAAQ,OAAQ,GAAS,EAAG,CAEpD,IAAI,EACJ,IAAK,IAAI,EAAI,EAAG,EAAI,IAAK,EAAG,CAExB,MAAM,EAAU,EAAmB,EAAQ,EAAQ,IAC7C,EAAU,EAAmB,EAAQ,GAAU,EAAI,GAAK,IACxD,EAAU,EAAmB,EAAQ,GAAU,EAAI,GAAK,IAC9D,GAAI,IAAY,EACZ,SAEJ,MAAM,EAAM,EAAoB,EAAV,EAAc,GAAI,EAAM,EAAoB,EAAV,EAAc,GAAI,EAAM,EAAoB,EAAV,EAAc,GAClG,EAAM,EAAoB,EAAV,EAAc,GAAI,EAAM,EAAoB,EAAV,EAAc,GAAI,EAAM,EAAoB,EAAV,EAAc,GAClG,EAAO,KAAK,MAAM,EAAM,IAAQ,EAAM,IAAQ,EAAM,IAAQ,EAAM,IAAQ,EAAM,IAAQ,EAAM,IACpG,IAAK,IAAI,EAAI,EAAG,EAAI,EAAgB,OAAS,EAAG,IAAK,CAEjD,MAAM,EAAS,EAAgB,GAC/B,GAAI,IAAW,GAAW,IAAW,GAAW,IAAW,EACvD,SAEJ,MAAM,EAAI,EAAmB,EAAT,EAAa,GAAI,EAAI,EAAmB,EAAT,EAAa,GAAI,EAAI,EAAmB,EAAT,EAAa,GACzF,EAAM,KAAK,MAAM,EAAI,IAAQ,EAAI,IAAQ,EAAI,IAAQ,EAAI,IAAQ,EAAI,IAAQ,EAAI,IACjF,EAAM,KAAK,MAAM,EAAI,IAAQ,EAAI,IAAQ,EAAI,IAAQ,EAAI,IAAQ,EAAI,IAAQ,EAAI,IACnF,KAAK,IAAI,EAAM,EAAM,GAAQ,IAExB,IACD,EAAuB,CACnB,MAAO,EACP,YAAa,CAAC,GAAI,GAAI,KAE1C,WAEA,6BAEI,CACJ,CACJ,CAEA,IAAK,IAAI,EAAI,EAAG,EAAI,EAAc,SAAU,EAAG,CAC3C,MAAM,EAAW,EAAc,GAC/B,KAAK,oBAAoB,EAAS,YAAa,EAAS,MAAO,EAAS,EAC5E,CACA,EAAc,OAAS,CAC3B,CAIA,MAAM,EAAQ,CAAC,EACf,IAAK,IAAI,EAAQ,EAAG,EAAQ,EAAO,aAC/B,IAAI,EACJ,IAAK,IAAI,EAAI,EAAG,EAAI,IAAK,EAAG,CACxB,IAAI,EAAU,EAAmB,EAAQ,EAAQ,IAC7C,EAAU,EAAmB,EAAQ,GAAU,EAAI,GAAK,IAC5D,MAAM,EAAU,EAAmB,EAAQ,GAAU,EAAI,GAAK,IAC9D,GAAI,IAAY,IAAa,IAAY,GAAW,IAAY,KAAsC,QAAxB,EAAK,KAAK,gBAA6B,IAAP,OAAgB,EAAS,EAAG,4BACtI,SAWJ,GATA,EAA+F,GAAG,QAAQ,GAAG,eAAe,EAAoB,EAAV,EAAc,GAAI,EAAoB,EAAV,EAAc,GAAI,EAAoB,EAAV,EAAc,IAC5M,EAA+F,GAAG,QAAQ,GAAG,eAAe,EAAoB,EAAV,EAAc,GAAI,EAAoB,EAAV,EAAc,GAAI,EAAoB,EAAV,EAAc,IAC5M,EAA+F,GAAG,QAAQ,GAAG,eAAe,EAAoB,EAAV,EAAc,GAAI,EAAoB,EAAV,EAAc,GAAI,EAAoB,EAAV,EAAc,IACvM,IACD,EAA8F,GAAG,QAAQ,GAAG,cAAc,EAAgF,GAAG,QAAQ,GAAI,EAAgF,GAAG,QAAQ,IACpT,EAA8F,GAAG,QAAQ,GAAG,cAAc,EAAgF,GAAG,QAAQ,GAAI,EAAgF,GAAG,QAAQ,IACpT,EAAa,EAAwE,EAAE,MAAM,EAAgF,GAAG,QAAQ,GAAI,EAAgF,GAAG,QAAQ,IACvR,EAAW,aAEf,KACA,UACI,EAAU,EACV,EAAU,CACd,CACA,MAAM,EAAM,EAAU,IAAM,EACtB,EAAK,EAAM,GACjB,GAAI,GACA,IAAK,EAAG,KAAM,CACZ,QAA2B,EAAM,UACjC,eACM,KAAK,WAAC,aAA+B,GAAI,EAAQ,mCAAsC,OAAS,GAEpG,EAAG,MAAO,CACd,OAGA,EAAM,GAAO,CAAE,OAAQ,EAAY,MAAM,EAAO,MAAO,EAAO,EAEtE,CACJ,CACA,IAAK,MAAM,KAAO,EAAO,CACrB,MAAM,EAAK,EAAM,GACjB,IAAK,EAAG,KAAM,CAEV,MAAM,EAAU,EAAmB,EAAQ,EAAG,MAAQ,EAAG,IACnD,EAAU,EAAmB,EAAQ,EAAG,OAAU,EAAG,EAAI,GAAK,IACpE,EAA+F,GAAG,QAAQ,GAAG,eAAe,EAAoB,EAAV,EAAc,GAAI,EAAoB,EAAV,EAAc,GAAI,EAAoB,EAAV,EAAc,IAC5M,EAA+F,GAAG,QAAQ,GAAG,eAAe,EAAoB,EAAV,EAAc,GAAI,EAAoB,EAAV,EAAc,GAAI,EAAoB,EAAV,EAAc,IAC5M,KAAK,WAAW,EAAgF,GAAG,QAAQ,GAAI,EAAgF,GAAG,QAAQ,GAAI,KAAK,gBAAgB,OAAS,EAChP,CACJ,CAIA,MAAM,EAAS,KAAK,QAAQ,WAAW,YACvC,KAAK,SAAS,EAAiF,EAAE,cAAgB,IAAI,EAAoE,EAAE,EAAQ,KAAK,gBAAiB,EAAiF,EAAE,cAAc,GAC1T,KAAK,SAAS,EAAe,cAAoB,IAAI,EAAoE,EAAE,EAAQ,KAAK,cAAe,EAA+E,EAAE,YAAY,GAAO,EAAO,GAClQ,KAAK,qBAAqB,EAAqB,EAAE,cAAgB,KAAK,SAAS,EAAiF,EAAE,cAClK,KAAK,qBAAqB,EAAmB,EAAE,YAAc,KAAK,SAAS,EAA+E,EAAE,YAC5J,KAAK,IAAM,EAAO,kBAAK,oBACvB,KAAK,cAAgB,KAAK,cAAc,MAC5C,CAKA,sBACI,MAAM,EAAY,KAAK,QAAQ,gBAAgB,EAAiF,EAAE,cAC5H,EAAU,KAAK,QAAQ,aAC7B,IAAK,IAAY,EACb,OAGJ,MAAM,EAAc,IAAI,MAClB,EAAc,IAAI,MACxB,IAAI,EACA,EAEJ,IAAK,EAAQ,EAAG,EAAQC,EAAQ,OAAQ,GAAS,EAAG,CAChD,EAAkB,IAAI,EACtB,MAAM,EAAU,EAAQ,GAClB,EAAU,EAAQ,EAAQ,GAC1B,EAAU,EAAQ,EAAQ,GAChC,EAAgB,GAAK,IAAI,EAAkE,EAAE,EAAoB,EAAV,GAAc,EAAoB,EAAV,EAAc,GAAI,EAAoB,EAAV,EAAc,IACzK,EAAgB,GAAK,IAAI,EAAkE,EAAE,EAAoB,EAAV,GAAc,EAAoB,EAAV,EAAc,GAAI,EAAoB,EAAV,EAAc,IACzK,EAAgB,GAAK,IAAI,EAAkE,EAAE,EAAoB,EAAV,GAAc,EAAoB,EAAV,EAAc,GAAI,EAAoB,EAAV,EAAc,IACzK,MAAM,EAAa,EAAwE,EAAE,MAAM,EAAgB,GAAG,SAAS,EAAgB,IAAK,EAAgB,GAAG,SAAS,EAAgB,KAChM,EAAW,YACX,EAAY,KAAK,GACjB,EAAY,KAAK,EACrB,CAEA,IAAK,EAAQ,EAAG,EAAQ,EAAY,OAAQ,IAAS,CACjD,EAAkB,EAAY,GAC9B,IAAK,IAAI,EAAa,EAAQ,EAAG,EAAa,EAAY,OAAQ,IAAc,CAC5E,MAAM,EAAuB,EAAY,GACzC,GAA4C,IAAxC,EAAgB,oBAEhB,MAEJ,GAAiD,IAA7C,EAAqB,oBAErB,SAEJ,MAAM,EAAU,EAAqB,EAAb,GAClB,EAAU,EAAqB,EAAb,EAAiB,GACnC,EAAU,EAAqB,EAAb,EAAiB,GACzC,IAAK,IAAI,EAAY,EAAG,EAAY,EAAG,IAAa,CAChD,IAAI,EAAiB,EACrB,QAAyC,IAArC,EAAgB,MAAM,GAA1B,CAGA,OAAQ,GACJ,KAAK,EAEG,EADA,KAAK,+BACY,KAAK,uCAAuC,EAAgB,GAAI,EAAgB,GAAI,EAAqB,GAAI,EAAqB,GAAI,EAAqB,IAG3J,KAAK,2BAA2B,EAAgB,EAAR,GAAY,EAAgB,EAAR,EAAY,GAAI,EAAS,EAAS,GAEnH,MACJ,KAAK,EAEG,EADA,KAAK,+BACY,KAAK,uCAAuC,EAAgB,GAAI,EAAgB,GAAI,EAAqB,GAAI,EAAqB,GAAI,EAAqB,IAG3J,KAAK,2BAA2B,EAAgB,EAAR,EAAY,GAAI,EAAgB,EAAR,EAAY,GAAI,EAAS,EAAS,GAEvH,MACJ,KAAK,EAEG,EADA,KAAK,+BACY,KAAK,uCAAuC,EAAgB,GAAI,EAAgB,GAAI,EAAqB,GAAI,EAAqB,GAAI,EAAqB,IAGtL,2CAA6B,EAA7B,GAAiC,OAInC,IAAwB,IAApB,IAGJ,EAAgB,MAAM,GAAa,EACnC,EAAqB,MAAM,GAAkB,EAC7C,EAAgB,sBAChB,EAAqB,sBACuB,IAAxC,EAAgB,qBAChB,KAnCJ,CAqCJ,CACJ,CACJ,CAEA,IAAK,EAAQ,EAAG,EAAQ,EAAY,OAAQ,IAAS,CAEjD,MAAM,EAAU,EAAY,GAC5B9G,KAAK,WAAW,EAAO,EAAQ,MAAM,GAAI,EAAa,EAAQ,GAAI,EAAQ,IAC1E,KAAK,WAAW,EAAO,EAAQ,MAAM,GAAI,EAAa,EAAQ,GAAI,EAAQ,IAC1E,KAAK,WAAW,EAAO,EAAQ,MAAM,GAAI,EAAa,EAAQ,GAAI,EAAQ,GAC9E,CAEA,MAAM,EAAS,KAAK,QAAQ,WAAW,YACvC,KAAK,SAAS,EAAiF,EAAE,cAAgB,IAAI,EAAoE,EAAE,EAAQ,KAAK,gBAAiB,EAAiF,EAAE,cAAc,GAC1T,KAAK,SAAS,EAA+E,EAAE,YAAc,IAAI,EAAoE,EAAE,EAAQ,KAAK,cAAe,EAA+E,EAAE,YAAY,GAAO,EAAO,GAC9T,KAAK,qBAAqB,EAAiF,EAAE,cAAgB,KAAK,SAAS,EAAiF,EAAE,cAC9N,KAAK,qBAAqB,EAA+E,EAAE,YAAc,KAAK,SAAS,EAA+E,EAAE,YACxN,KAAK,IAAM,EAAO,kBAAkB,KAAK,eACzC,KAAK,cAAgB,KAAK,cAAc,MAC5C,CAKA,UACI,OAAO,KAAK,YAAY,QAAQ,KAAK,QAAU,KAAK,QAAQ,cAAgB,KAAK,gBAAgB,OAAS,GAAM,KAAK,QAAQ,iBACjI,CAIA,SACI,MAAM,EAAQ,KAAK,QAAQ,WACrB,EAAqB,KAAK,YAAY,kBAI5C,GAHI,KAAK,cACL,KAAK,YAAY,gBAAgB,KAAK,eAErC,KAAK,YAAc,EAAM,aAE1B,YADA,KAAK,YAAY,gBAAgB,GAGrC,MAAM,EAAe,KAAK,QAAQ,cAAgB,KAAK,gBAAgB,OAAS,EAC1E,EAA0B,GAAgB,KAAK,QAAQ,iBAC7D,IAAI,EAAgB,EACpB,GAAI,EAKA,GAJA,KAAK,qBAA6B,OAAI,KAAK,QAAQ,gBAAgB,UACnEA,KAAK,qBAA6B,OAAI,KAAK,QAAQ,gBAAgB,UACnE,KAAK,qBAA6B,OAAI,KAAK,QAAQ,gBAAgB,UACnE,KAAK,qBAA6B,OAAI,KAAK,QAAQ,gBAAgB,UAC/D,EAAc,CACd,MAAM,EAAkB,KAAK,QAAQ,qBAErC,GADA,EAAgB,KAAK,gBAAgB,QAChC,EAAgB,cAIjB,YAHK,KAAK,QAAQ,WAAW,qBACzB,KAAK,gBAAgB,SAI7B,IAAK,EAAgB,SAAU,CAC3B,IAAI,EAAS,EACb,IAAK,IAAI,EAAI,EAAG,EAAI,IAAiB,EACjC,KAAK,gBAAgB,KAAK,GAAG,YAAY,EAAgB,cAAe,GACxE,GAAU,GAEd,EAAgB,gBAAgB,eAAe,EAAgB,cAAe,EAAG,EACrF,CACJ,MAEI,EAAgB,KAAK,QAAQ,kBAGrC,MAAM,EAAS,EAAM,YACrB,KAAK,YAAY,WACiB,IAA9B,KAAK,QAAQ,WAAW,EACxB,EAAO,aAAa,GAGpB,EAAO,aAAa,GAGxB,EAAO,YAAY,EAA0B,KAAK,qBAAuB,KAAK,SAAU,KAAK,IAAK,KAAK,YAAY,aACnH,EAAM,sBACN,KAAK,YAAY,UAAU,QAAS,KAAK,QAAQ,YAC7C,EAAM,aAAa,OAAS,EAAkF,EAAE,oBAChH,KAAK,YAAY,SAAS,QAAS,KAAK,QAAQ,WAAa,KAAK,iCAGlE,KAAK,YAAY,SAAS,QAAS,KAAK,QAAQ,WAAa,KAAK,gCAEtE,KAAK,YAAY,SAAS,cAAe,EAAO,eAAe,EAAM,eACrE,KAAK,YAAY,KAAK,KAAK,QAAQ,kBAEnC,EAAO,iBAAiB,EAAqF,EAAE,iBAAkB,EAAG,KAAK,cAAe,GACxJ,KAAK,YAAY,SACb,GACA,EAAO,2BAEN,KAAK,QAAQ,WAAW,qBACzB,KAAK,gBAAgB,QAEzB,KAAK,YAAM,kBACf,EAKJ,MAAM,UAA0B,EAO5B,YAAY,EAAQ,EAAU,IAAM,GAAgC,GAChE,MAAM,EAAQ,EAAS,GAA+B,GACtD,KAAK,qB,uaC9tB4C,KAAK,SAAS,EAA+E,EAAE,YAAc,IAAI,EAAoE,EAAE,EAAQ,KAAK,cAAe,EAA+E,EAAE,YAAY,GAAO,EAAO,GAC3T,KAAK,IAAM,EAAO,kBAAkB,KAAK,e,4CAEtC,EAIN,EAEV,MACF,CAAE,EAAqC,EAAqB,KAEuC,EAAoB,EAAE,EAAqB,CACpK,EAAK,IAAM,IAEb,IAAI,EAAqD,EAAoB,OACzE,EAAkD,EAAoB,OACtE,EAA8D,EAAoB,OAClF,EAAwE,EAAoB,OAC5F,EAA4D,EAAoB,OAChF,EAAoD,EAAoB,OACxE,EAAiD,EAAoB,OACrE,EAAsD,EAAoB,OAG1E,GAF6D,EAAoB,OACtB,EAAoB,OACnB,EAAoB,QAChF,EAAsE,EAAoB,OAenH,MAAM,EAAW,CACb,QACA,SACA,iBACA,gBACA,OACA,gBACA,yBACA,iBACA,aACA,qBACA,eACA,oBACA,cACA,WACA,aACA,sBACA,aACA,wBACA,yBACA,8BAEJ,EAAG,EAAgG,IAAI,GAIvG,MAAM,EAMF,qBAAqB,GACjBA,KAAK,oBAAqB,EAC1B,KAAK,iBAAmB,EACpB,KAAK,qBAEL,KAAK,mBAAmB,kBAAkB,QAC1C,KAAK,mBAAmB,kBAAkB,KAAI,SAItD,CAMA,yBACI,KAAK,oBAAqB,EAC1B,KAAK,sBACT,CAKA,eACI,KAAK,iBAAkB,EACvB,KAAK,qBAAsB,EAC3B,KAAK,iBAAkB,EACvB,KAAK,aAAe,EACxB,CAMA,kBAAkB,EAAoB,GAC9B,IAAuB,EAAuB,uBAC9C,KAAK,eAAiB,EACtB,KAAK,iBAAkB,GAElB,IAAuB,EAAuB,uBACnD,KAAK,eAAiB,EACtB,KAAK,iBAAkB,GAElB,IAAuB,EAAuB,2BACnD,KAAK,mBAAqB,EAC1B,KAAK,qBAAsB,GAEtB,IAAuB,EAAuB,mBACnD,KAAK,YAAc,EAEd,IAAuB,EAAuB,sBACnD,KAAK,aAAe,EAE5B,CAMA,gBAAgB,GACZ,KAAK,aAAe,CACxB,CAMA,qBAAqB,GACjB,KAAK,mBAAmB,mBAAmB,EAAiB,GAAG,EACnE,CAII,iBACA,OAAO,KAAK,mBAAmB,UACnC,CAII,eAAW,GACX,KAAK,mBAAmB,WAAa,CACzC,CAKI,kBACA,OAAO,KAAK,mBAAmB,WACnC,CAMA,gBAAgB,GACZ,OAAQ,GACJ,KAAK,EAAuB,sBACxB,OAAO,KAAK,eAChB,KAAK,EAAuB,sBACxB,OAAO,KAAK,eAChB,KAAK,EAAuB,0BACxB,OAAO,KAAK,mBAChB,QACI,OAAQ,EAEpB,CAII,qBACA,OAAO,KAAK,eAChB,CAII,mBAAe,GACf,KAAK,gBAAkB,EAElB,KAAK,qBACN,KAAK,UACL,KAAK,uBAEb,CAII,qBACA,OAAO,KAAK,eAChB,CAII,mBAAe,GACf,KAAK,gBAAkB,EAClB,IACD,KAAK,gCAAkC,CAAC,GAEvC,KAAK,qBACN,KAAK,UACL,KAAK,wBAET,KAAK,OAAO,2BAA6B,CAC7C,CAII,yBACA,OAAOA,KAAK,mBAChB,CAQI,uBAAmB,GACnB,KAAK,oBAAsB,EACtB,KAAK,qBACN,KAAK,UACL,KAAK,uBAEb,CAII,YACA,OAAO,KAAK,MAChB,CAKI,YACA,OAAO,KAAK,MAChB,CAOA,YAAY,EAAO,EAAQ,EAAG,EAAc,IAMxCA,KAAK,gCAAkC,CAAC,EAMxC,KAAK,qCAAuC,CAAC,EAK7C,KAAK,kCAAoC,GAEzC,KAAK,yBAA0B,EAC/B,KAAK,gBAAkB,KACvB,KAAK,iBAAkB,EACvB,KAAK,iBAAkB,EACvB,KAAK,qBAAsB,EAC3B,KAAK,gBAAY,EACjB,KAAK,gBAAkB,EACvB,KAAK,oBAAsB,EAC3B,KAAK,aAAe,EACpB,KAAK,cAAgB,EACrB,KAAK,oBAAqB,EAC1B,KAAK,qBAAuB,IAAI,EAAgE,GAChG,KAAK,OAAS,EACd,KAAK,OAAS,EACd,KAAK,QAAU,EAAM,YAAY,uBACjC,KAAK,aAAe,EACpB,EAAuB,8BAA8B,KAAK,QAE1D,KAAK,sBACT,CAOA,QAAQ,EAAS,GACb,MAAM,EAAW,EAAQ,cACzB,GAAI,GAAY,EAAS,kBACrB,OAAO,EAEX,MAAM,EAAU,GACV,EAAU,CAAC,EAAiF,EAAE,aAAc,EAA+E,EAAE,YAC7L,EAAO,EAAQ,UAErB,GAAI,EAAU,CACV,IAAI,GAAS,EAWb,GAVI,EAAS,oBAAsB,EAAS,wBACxC,EAAQ,KAAK,qBACb,EAAQ,KAAK,uBAAuB,EAAS,sBAAsB,iBAAmB,KACtF,GAAS,GAET,EAAS,aAAe,EAAkG,EAAE,qBAC5H,EAAQ,KAAK,gBACb,EAAQ,KAAK,kBAAkB,EAAS,YAAY,iBAAmB,KACvE,GAAS,GAET,KAAK,oBAAqB,CAC1B,IAAI,GAAmB,EAES,iCAA5B,EAAS,gBAEiC,OAAtC,EAAS,2BACT,EAAQ,KAAK,sBACb,EAAQ,KAAK,0BAA0B,EAAS,yBAAyB,iBAAmB,KAC5F,EAAQ,KAAK,4BACb,GAAS,EACT,GAAmB,GAEG,OAAtB,EAAS,WACT4G,EAAQtG,KAAK,oBACb,EAAQ,KAAK,4BACb,GAAmB,GAEI,OAAvB,EAAS,YACT,EAAQ,KAAK,qBACb,EAAQ,KAAK,4BACb,GAAmB,GAEnB,IAC6B,OAAzB,EAAS,cACT,EAAQ,KAAK,yBACb,EAAQ,KAAK,oBAAoB,EAAS,YAAY,iBAAmB,KACrE,EAAS,YAAY,YACrB,EAAQ,KAAK,uBAEjB,GAAS,GAEc,OAAvB,EAAS,WACT,EAAQ,KAAK,yBAIY,kCAA5B,EAAS,gBAE6B,OAAvC,EAAS,2BACTsG,EAAQtG,KAAK,qCACb,EAAQ,KAAK,0BAA0B,EAAS,0BAA0B,iBAAmB,KAC7F,GAAS,EACL,EAAS,0BAA0B,YACnC,EAAQ,KAAK,qCAIc,OAA3B,EAAS,eACT,EAAQ,KAAK,6BAGO,OAAxB,EAAS,YACT,EAAQ,KAAK,wBAGgB,gBAA5B,EAAS,gBAEmB,OAA7B,EAAS,kBACT,EAAQ,KAAK,sBACb,EAAQ,KAAK,0BAA0B,EAAS,gBAAgB,iBAAmB,KACnF,EAAQ,KAAK,4BACb,GAAS,EACT,GAAmB,GAEG,OAAtB,EAAS,WACT,EAAQ,KAAK,oBACb,EAAQ,KAAK,4BACb,GAAmB,GAEI,OAAvB,EAAS,YACT,EAAQ,KAAK,qBACb,EAAQ,KAAK,4BACb,GAAmB,GAEnB,GAC+B,OAA3B,EAAS,gBACT,EAAQ,KAAK,yBACb,EAAQ,KAAK,oBAAoB,EAAS,cAAc,iBAAmB,KACvE,EAAS,cAAc,YACvB,EAAQ,KAAK,uBAEjB,GAAS,GAEgB,OAAzByG,EAAS,aACTH,EAAQtG,KAAK,yBAKoB,OAAjC,EAAS,qBACT,EAAQ,KAAK,qCACb,EAAQ,KAAK,0BAA0B,EAAS,oBAAoB,iBAAmB,KACnF,EAAS,oBAAoB,YAC7B,EAAQ,KAAK,oCAEjB,GAAS,GAE2B,OAA/B,EAAS,mBACd,EAAQ,KAAK,6BAER,OAAL,EAAK,cACL,EAAQ,KAAK,yBAIY,qBAA5B,EAAS,iBAEmB,OAA7B,EAAS,kBACT,EAAQ,KAAK,+BACb,EAAQ,KAAK,0BAA0B,EAAS,gBAAgB,iBAAmB,KAC/E,EAAS,gBAAgB,YACzB,EAAQ,KAAK,oCAEjB,GAAS,GAEkB,OAA3B,EAAS,eACT,EAAQ,KAAK,6BAGzB,CACI,IACA,EAAQ,KAAK,mBACT,EAAK,sBAAsB,EAA2E,EAAE,UACxG,EAAQ,KAAK,EAA2E,EAAE,QAC1F,EAAQ,KAAK,gBAEb,EAAK,sBAAsB,EAA4E,EAAE,WACzG,EAAQ,KAAK,EAA4E,EAAE,SAC3F,EAAQ,KAAK,gBAGzB,CAEI,KAAK,qBACL,EAAQ,KAAK,oBACA,IAAT,KAAK,cACL,EAAQ,KAAC,yCACT,EAAQ,KAAK,2BAEA,IAAb,KAAK,eACL,EAAQ,KAAK,wBAA0B,KAAK,cAC5C,EAAQ,KAAK,4BAIjB,KAAK,kBACL,EAAQ,KAAK,oBACb,EAAQ,KAAK,0BAA4B,KAAK,iBAE9C,KAAK,kBACL,EAAQ,KAAK,oBACb,EAAQ,KAAK,0BAA4B,KAAK,iBACgB,IAA1D,KAAK,kCAAkC,QAAQ,IAC/CsG,EAAQtG,KAAK,mCAGjB,KAAK,sBACL,EAAQ,KAAK,wBACb,EAAI,6DAGJ,EAAK,UAAY,EAAK,0BACtB,EAAQ,KAAK,EAAwF,EAAE,qBACvG,EAAQA,KAAK,EAAwF,EAAE,qBACvG,yBACI,EAAQ,KAAK,EAA6F,EAAE,0BAC5G,EAAQA,KAAK,EAA6F,EAAE,2BAEhH,EAAQ,KAAK,gCAAkC,EAAK,oBACpD,EAAQ,KAAK,yBAA2B,EAAK,SAAW,EAAK,SAAS,MAAM,OAAS,EAAI,KAGzF,EAAQ,KAAK,kCAGjB,MAAM,EAAqB,EAAK,mBAChC,QACI,GACI,EAAmB,eAAiB,IACpC,EAAsB,EAAmB,eACzC,EAAQ,KAAK,wBACb,EAAQ,KAAK,iCAAmC,GAC5C,EAAmB,0BACnB,EAAQ,KAAK,gCAEjB,EAA4H,EAAE,4CAA4C,EAAS,EAAM,IAI7L,IACA,EAAQ,KAAK,qBACb,EAA2G,EAAE,2BAA2B,EAAS,KAAK,iBAClJ,EAAQ,mBAAmB,kBAC3B,EAAQ,KAAK,2BAIjB,KAAK,mBACL,EAAQ,KAAK,+BAAiC,KAAK,aAAa,QAGhE,EAAQ,KAAK,+BAAiC,KAAK,mBAAmB,SAAS,SAEnF,EAAG,EAAuG,IAAI,EAAU,KAAK,OAAQ,GAErI,MAAM,EAAS,KAAK,OAAO,YACrB,EAAc,EAAQ,qBAAgB,GAAW,GACjD,EAAgB,EAAY,QAC5B,EAAO,EAAQ,KAAK,MAc1B,OAbI,IAAkB,GAClB,EAAY,UAAU,EAAO,aAAa,WAAY,CAClD,WAAY,EACZ,cAAe,EACf,SAAU,CAAC,iBAAkB,cAAe,sBAAuB,gBAAiB,gBACpF,QAAS,EACT,WAAY,KACZ,UAAW,KACX,QAAS,KACT,oBAAqB,CAAC,SACtB,gBAAiB,CAAE,aAAc,KAAK,mBAAmB,SAAS,OAAS,EAAG,4BAA6B,IAC5G,GAAS,GAET,EAAY,OAAO,SAC9B,CAKA,aACI,OAAO,KAAK,kBAChB,CAII,cACA,OAAO,KAAK,mBAAmB,OACnC,CAII,YAAQ,GACR,KAAK,mBAAmB,QAAU,CACtC,CAIA,UACI,GAAI,KAAK,gBAAiB,CACP,KAAK,OAAO,YACpB,mBAAmB,OAAO,KAAK,iBACtC,KAAK,gBAAkB,IAC3B,CACA,KAAK,aAAa,SACtB,CACA,6BACI,MAAM,EAAe,GACrB,IAAI,EAAQ,EAiBZ,OAhBA,EAAa,KAAK,gBAAiB,kBAC/B,KAAK,kBACL,KAAK,eAAiB,EACtB,IACA,EAAa,KAAK,qBAElB,KAAK,kBACL,KAAK,eAAiB,EACtB,IACA,EAAa,KAAK,qBAElB,KAAK,sBACL,KAAK,mBAAY,EACjB,IACA,EAAa,KAAK,yBAEf,CAAC,EAAO,EACnB,CACA,uBACI,MAAM,EAAS,KAAK,OAAO,aACpB,EAAO,GAAgB,KAAK,6BACnC,IAAI,EAAO,EAQX,GAPI,EAAO,MAAM,cAAgB,EAAO,MAAM,4BAC1C,EAAO,EAEF,EAAO,MAAM,kBAAoB,EAAO,MAAM,kCACnD,EAAO,GAEX,KAAK,mBAAqB,IAAI,EAA+F,EAAE,UAAW,CAAE,MAAO,EAAO,iBAAmB,KAAK,OAAQ,OAAQ,EAAO,kBAAoB,KAAK,QAAU,EAAO,KAAK,OAAQ,CAAE,iBAAiB,EAAO,sBAAsB,EAAM,YAAa,EAAM,mBAAoB,KAAK,cAAgB,EAAa,OAAO,yBACjY,KAAK,YACN,OAEJ,KAAK,mBAAmB,MAAQ,EAA6F,EAAE,kBAC/H,KAAK,mBAAc,QAAoC,EAAE,kBACzD,KAAK,mBAAmB,YAAc,EACtC,KAAK,mBAAmB,iBAAkB,EAC1C,KAAK,mBAAmB,WAAa,KAErC,KAAK,mBAAmB,kBAAkB,KAAK,IAC3C,EAAO,MAAM,IAAI,EAAgE,GAAG,EAAK,EAAK,EAAK,IAAM,GAAM,GAAM,EAAK,IAE9H,KAAK,gBAAkB,EAAO,mBAAmB,KAAI,KAC7C,KAAK,oBACL,KAAK,mBAAmB,OAAO,CAAE,MAAO,EAAO,iBAAmB,KAAK,OAAQ,OAAQ,EAAO,kBAAoB,KAAK,QAC3H,IAGJ,MAAM,EAAiB,IACnB,MAAM,EAAgB,EAAQ,mBACxB,EAAgB,EAAQ,mBACxB,EAAQ,KAAK,OACb,EAAS,EAAM,YACf,EAAW,EAAQ,cACzB,IAAK,EACD,OAIJ,GAFA,EAAc,8BAA8B,uBAAwB,EAEhE,KAAK,kBAAoB,KAAK,gCAAgC,EAAc,YAC5E,KAAK,gCAAgC,EAAc,UAAY,CAC3D,MAAO,EAA0E,GAAG,WACpF,eAAgB,EAAM,sBAEtB,aACA,MAAM,EAAuB,EAAc,SAAS,qBAAqB,GACzE,KAAK,qCAAqC,EAAc,UAAY,KAAK,iCAAiC,EAAsB,IAAI,aAAa,EAAqB,QAC1K,CAGJ,MAAM,EAAQ,EAAc,wBAAwB,EAAQ,MAAO,EAAQ,sBAC3E,GAAI,EAAM,WACN,OAEJ,MAAM,EAA6B,EAAO,UAAU,kBAA4D,OAAxC,EAAM,iBAAiB,EAAQ,MAAiB,EAAc,kBAChI,EAAQ,EAAc,iBAC5B,GAAI,KAAK,QAAQ,EAAS,GAAwB,CAC9C,MAAM,EAAc,EAAQ,kBAC5B,IAAK,EACD,OAEJ,MAAM,EAAS,EAAY,OAa3B,IAAI,EAZJ,EAAO,aAAa,GACf,GACD,EAAc,MAAM,EAAS,EAAQ,EAAS,UAE7C,KAAK,SAKN,EAAuG,EAAE,uBAAuB,EAAQ,KAAK,OAAO,yBACpJ,KAAK,OAAO,qBALZ,EAAO,UAAU,iBAAkB,EAAM,sBACzC,EAAO,UAAU,OAAQ,EAAM,kBAOnC,MAAM,EAAsB,EAAc,qBAC1C,GAAK,EAAoB,WAAa,EAAS,iBAAqE,OAAlD,EAAc,gCAW5E,EAAkB,EAAoB,oBAXiF,CACvH,MAAM,EAAkB,EAAc,6BACtC,EAAkB,EAAc,gCACR,OAApB,IACA,EAAkB,EAAS,iBAE3B,EAAkB,IAClB,EAAkB,IAAoB,EAA6F,EAAE,yBAA2B,EAAoG,EAAE,gCAAkC,EAA6F,EAAE,yBAE/Y,CAMA,GAFA,EAAS,SAAS,EAAa,GAE3B,EAAS,mBAAoB,CAC7B,MAAM,EAAe,EAAS,sBAC1B,IACA,EAAO,WAAW,iBAAkB,GACpC,EAAO,UAAU,gBAAiB,EAAa,oBAEvD,CAEI,EAAS,aAAe,EAAM,YAAY,UAAU,qBAAuB,EAAkG,EAAE,qBAC/K,EAAO,UAAU,aAAc,EAAS,YAAY,iBAAkB,EAAM,EAAS,YAAY,MAAO,EAAS,mBACjH,EAAO,UAAU,aAAc,EAAS,YAAY,oBACpD,EAAO,WAAW,cAAe,EAAS,aAC1C,EAAO,UAAU,sBAAuB,EAAS,kBAAoB,EAAM,EAAK,EAAS,kBAAoB,EAAM,IAGnH,KAAK,sBAE2B,iCAA5B,EAAS,gBAEiC,OAAtC,EAAS,2BACT,EAAO,WAAW,sBAAuB,EAAS,0BAClD,EAAO,UAAU,qBAAsB,EAAS,yBAAyB,qBAEnD,OAAtB,EAAS,UACT,EAAO,SAAS,WAAY,EAAS,UAEd,OAAvB,EAAS,WACT,EAAO,SAAS,aAAc,EAAM,EAAS,WAEpB,OAAzB,EAAS,cACT0G,EAAO,WAAW,gBAAiB,EAAS,aAC5C,EAAO,UAAU,eAAgB,EAAS,YAAY,qBAE/B,OAAvB,EAAS,WACT,EAAO,UAAU,cAAe,EAAS,YAGZ,kCAA5B,EAAS,gBAE6B,OAAvC,EAAS,2BACT,EAAO,WAAW,sBAAuB,EAAS,2BAClD,EAAO,UAAU,qBAAsBD,EAAS,0BAA0B,qBAG3C,OAA3BA,EAAS,gBACT,EAAS,cAAc,mBAAmB,KAAK,sBAC/C,EAAO,UAAU,oBAAqB,KAAK,uBAGvB,OAAxB,EAAS,YACT,EAAO,SAAS,aAAc,EAAS,aAGV,gBAA5B,EAAS,gBAEmB,OAA7B,EAAS,kBACT,EAAO,WAAW,sBAAuB,EAAS,iBAClD,EAAO,UAAU,qBAAsB,EAAS,gBAAgB,qBAE1C,OAAtB,EAAS,UACT,EAAO,SAAS,WAAY,EAAS,UAEd,OAAvB,EAAS,WACT,EAAO,SAAS,aAAc,EAAM,EAAS,WAEtB,OAAvB,EAAS,WAA4C,OAAtB,EAAS,UAAkD,OAA7B,EAAS,iBAEvC,OAA3B,EAAS,gBACT,EAAO,WAAW,gBAAiB,EAAS,eAC5C,EAAO,UAAU,eAAgB,EAAS,cAAc,qBAE/B,OAAzB,EAAS,aACT,EAAO,UAAU,cAAe,EAAS,eAKR,OAAjC,EAAS,qBACT,EAAO,WAAW,sBAAuB,EAAS,qBAClD,EAAO,UAAU,qBAAsB,EAAS,oBAAoB,qBAEhC,OAA/B,EAAS,mBACd,EAAO,UAAU,oBAAqB,EAAS,mBAErB,OAA1B,EAAS,cACT,EAAO,SAAS,aAAc,EAAS,gBAId,qBAA5B,EAAS,iBAEmB,OAA7B,EAAS,kBACT,EAAO,WAAW,sBAAuB,EAAS,iBAClD,EAAO,UAAU,qBAAsB,EAAS,gBAAgB,qBAErC,OAA3B,EAAS,eACT,EAAO,UAAU,oBAAqB,EAAS,kBAK3D,EAAG,EAAyF,IAAI,EAAQ,EAAU,KAAK,QAEnH,EAAc,UAAY,EAAc,0BAA4B,EAAc,WAClF,EAAO,YAAY,SAAU,EAAc,SAAS,qBAAqB,IACrE,KAAK,iBACL,EAAO,YAAY,iBAAkB,KAAK,qCAAqC,EAAc,YAIrG,EAA0G,EAAE,0BAA0B,EAAe,GACjJ,EAAc,oBAAsB,EAAc,mBAAmB,0BACrE,EAAc,mBAAmB,MAAM,GAGvC,KAAK,kBACL,EAAO,UAAU,gBAAiB,KAAK,gCAAgC,EAAc,UAAU,OAC/F,EAAO,UAAU,yBAA0B,KAAK,gCAAgC,EAAc,UAAU,iBAExG,GAA8B,EAAc,kBAC5C,EAAO,UAAU,QAAS,GAG9B,EAAc,kBAAkB,EAAe,EAAS,EAAQ,EAAS,SAAU,EAAO,GAA4B,CAAC,EAAY,KAC1H,GACD,EAAO,UAAU,QAAS,EAC9B,GAER,CAEI,KAAK,kBACL/G,KAAK,gCAAgC,EAAc,UAAU,MAAQ,EAAM,QAC3E,KAAK,gCAAgC,EAAc,UAAU,eAAiB,KAAK,OAAO,qBAAqB,QAC3G,EAAc,UACd,KAAK,iCAAiC,EAAc,SAAS,qBAAqB,GAAgB,KAAK,qCAAqC,EAAc,WAElK,EAEJ,KAAK,mBAAmB,sBAAwB,CAAC,EAAM,EAAa,KAChE,IAAK,GAA2B,IAAhB,IAAsB,EAAK,UACvC,IAAK,IAAI,EAAI,EAAG,EAAI,EAAK,UAAU,SAAU,EAAG,CAC5C,MAAM,EAAU,EAAK,UAAU,GACzB,EAAW,EAAQ,cACnB,EAAgB,EAAQ,mBAC9B,IAAK,EACD,SAEJ,MAAM,EAAQ,EAAc,wBAAwB,EAAQ,MAAO,EAAQ,sBACrE,EAA6B,EAAO,UAAU,kBAA4D,OAAxC,EAAM,iBAAiB,EAAQ,MAAiB,EAAc,kBACtI,IAAK,KAAK,QAAQ,EAAS,GACvB,OAAO,CAEf,CAEJ,OAAO,CAAI,EAEf,KAAK,mBAAmB,qBAAuB,CAAC,EAAiB,EAAoB,EAAsB,KACvG,IAAI,EACJ,GAAI,KAAK,mBAAoB,CACzB,IAAK,KAAK,iBAAiB,QACvB,OAEJ,KAAK,OAAO,YAAY,gBAAgB,KAAK,aACjD,CACA,GAAI,EAAmB,OAAQ,CAE3B,IADA,EAAO,eAAc,GAChB,EAAQ,EAAG,EAAQ,EAAmB,OAAQ,IAC/C,EAAc,EAAmB,KAAK,IAE1C,EAAO,eAAc,EACzB,CACA,IAAK,EAAQ,EAAG,EAAQ,EAAgB,OAAQ,IAC5C,EAAc,EAAgB,KAAK,IAGvC,IADA,EAAO,eAAc,GAChB,EAAQ,EAAG,EAAQ,EAAmB,OAAQ,IAC/C,EAAc,EAAmB,KAAK,IAE1C,GAAI,KAAK,wBACL,IAAK,EAAQ,EAAG,EAAQ,EAAqB,OAAQ,IACjD,EAAc,EAAqB,KAAK,IAGhD,EAAO,eAAc,EAAK,CAElC,CAEA,iCAAiC,EAAQ,GACrC,IAAK,IAAI,EAAI,EAAG0B,EAAI,EAAO,OAAQ,IAC/B,EAAO,GAAK,EAAO,GAEvB,OAAO,CACX,EAMJ,EAAuB,mBAAqB,E,kDCn3B5C,EAAsB,wBAKtB,EAAuB,0BAA4B,EAInD,EAAuB,8BAAiC,IACpD,MAAM,EAAG,EAAkE,GAAG,uCAAuC,CAIlH,EAED,MACA,CAAE,EAAqC,EAAqB,KAG7C,IAAI,EAAyC,EAAoB,OAC7D,EAAkD,EAAoB,OAC/F,WAKA,OAAO,eAAe,EAA8D,EAAE,UAAW,yBAA0B,CACvH,IAAK,WACD,OAAO,KAAK,uBAChB,EACA,IAAK,SAAU,GACP,GAAS,EAAM,cACR,KAAK,wBAA0B,EAE9C,EACA,YAAY,EACZ,cAAc,IAElB,EAA2F,EAAE,UAAU,6BAA+B,SAAU,EAAQ,EAAG,EAAc,IACrK,OAAI,KAAK,0BAGT,KAAK,wBAA0B,IAAI,EAAsF,EAAE,KAAM,EAAO,GACnI,KAAK,wBAAwB,cAC9B,KAAK,wBAA0B,OAJxB,KAAK,uBAOpB,EACA,EAA0D,qDACjD,KAAK,0BAGV,KAAK,wBAAwB,UAC7B,KAAK,wBAA0B,KACnC,EAKA,MAAM,EAKF,YAAY,GAIR,KAAK,KAAO,EAA2G,EAAE,4BACjI,YACI,CAIA,WACI,KAAK,MAAM,0BAA0B,aAAa,EAA+H,EAAE,gDAAiD,KAAM,KAAK,qBACnP,C,2ICjFgC,EAAoH,EAAE,8BAAiC,I,uDAGnH,IACxE,WACQ,EAAM,cAAc,GACxB,CAIG,EAED,MACA,CAAE,EAAqC,EAAsC,KAMzD,EAAoB,OAA9C,IAEI,EAAgB,EAAoB,OAEpC,EAAQ,EAAoB,OAE5B,EAAiB,EAAoB,OAMzC,EAA+C,EAAE,UAAU,oBAAsB,SAAU,EAAQ,GAAsB,EAAO,GAAmB,EAAO,EAAe,GAErK,KADA,EAAS,GAAU,KAAK,cAEpB,KAAM,+CAKH,GAHF,KAAK,iBACN,KAAK,eAAiB,CAAC,IAEf,KAAK,eAAe,EAAO,IAAK,CACxC,MAAM,IAAqB,KAAK,YAAY,UAAU,mBACtD,IAAI,EAAc,EAKd,GAJA,KAAK,YAAY,UAAU,wBAA4B,GAAqB,EAGvE,EACS,EAGA,EANA,EAQlB,KAAK,eAAe,EAAO,IAAM,IAAI,EAAiC,EAAE,KAAM,EAAa,EAAQ,EAAqB,EAC5H,CACA,OAAO,KAAK,eAAe,EAAO,GACtC,EACA,EAAgD,EAAE,UAAQ,kCACtD,EAAS,GAAU,KAAK,eACR,KAAK,gBAAmB,KAAK,eAAe,EAAO,KAGnE,KAAK,eAAe,EAAO,IAAI,SACnC,EAKA,MAAM,EAKF,YAAY,GAIR,KAAK,KAAO,EAA+D,EAAE,mBAC7E,KAAK,MAAQ,CACjB,CAIA,WACI,KAAK,MAAM,0BAA0B,aAAa,EAAmF,EAAE,uCAAwC,KAAM,KAAK,sBAC1L,KAAK,MAAM,sCAAsC,aAAa,EAA+F,EAAE,mDAAoD,KAAM,KAAK,iCAClO,CAKA,UAEA,CAIA,UACI,IAAK,MAAM,KAAO,KAAK,MAAM,eACzB,KAAK,MAAM,eAAe,GAAK,SAEvC,CACA,qBAAqB,GACjB,GAAI,KAAK,MAAM,eACX,IAAK,MAAM,KAAO,KAAK,MAAM,eAAzC,C,obCtGQ,EAAM,cAAc,GACxB,EAI4C,IAAI,EAAoB,EAAoB,OAErB,EAAa,EAAoB,OAEjB,EAAa,EAAoB,MAEhE,EAAc,EAAoB,OAE7C,EAAiB,EAAoB,OAE9E,EAAsB,EAAoB,OAE1C,EAAS,EAAoB,OAE7B,EAAqB,EAAoB,OAEpB,EAAoB,OAErB,EAAoB,OAEhB,EAAoB,OAiBhD,MAAM,EACF,cAII1B,KAAK,SAAU,EAIf,KAAK,KAAO,eAIZ,KAAK,iBAAmB,CAAC,EAC7B,EAOJ,MAAM,EAIE,gBACA,OAAO,KAAK,UAChB,CACI,cAAU,GACN,KAAK,aAAe,IAGxB,KAAK,WAAa,EAClB,KAAK,uBACT,CAII,sBACA,OAAO,KAAK,gBAChB,CACI,oBAAgB,GACZ,KAAK,mBAAqB,IAG9B,KAAK,iBAAmB,EACxB,KAAK,uBACT,CAKA,gBAAgB,IACyC,IAAjD,KAAK,gBAAgB,QAAQ,EAAK,WAClC,KAAK,gBAAgB,KAAK,EAAK,SAEvC,CAKA,mBAAmB,GACf,MAAM,EAAQ,KAAK,gBAAgB,QAAQ,EAAK,WACjC,IAAX,GACA,8BAAgB,EAExB,CAOA,YAAY,EAAO,EAAY,GAiB3B,GAhBAA,KAAK,cAAgB,GACrB,KAAK,sBAAwB,EAC7B,KAAK,mBAAqB,CAAC,EAAC,GAAO,EAAC,GAAM,GAAO,EAAC,GAAM,GAAM,IAC9DA,KAAK,aAAe,GACpB,KAAK,oBAAsB,IAAI,EAA2B,EAAE,IAC5D,KAAK,mBAAqB,IAAI,EAA2B,EAAE,IAC3D,KAAK,gBAAkB,GACvB,KAAK,YAAc,CACf,IAAI,EAAuB,GAAG,EAAqB,mBAAoB,EAAqB,mBAAoB,EAAG,GACnH,IAAI,EAAuB,IAAI,EAAqB,WAAY,EAAqB,WAAY,EAAG,GACpG,IAAI,EAAuB,GAAG,EAAG,EAAG,EAAG,IAE3C,KAAK,OAAS,EACd,KAAK,QAAU,EAAM,YACrB,KAAK,WAAa,EAEb,EAAM,wBAAX,CAIA,IAAK,IAAI,EAAI,EAAG,EAAI,KAAK,mBAAmB,SAAU,EAClD,KAAK,aAAa,GAAK,KAAK,QAAQ,mBAAmB,KAAK,mBAAmB,IAEnF,KAAK,eAAiB,GACtBA,KAAK,iBAAkB,EACvBA,KAAK,4BAA8B,IAAI,EACvC,KAAK,kBACL,KAAK,gBARL,MAFI,EAAwB,EAAE,KAAK,uFAWvC,CACA,uBAEI,GADAA,KAAK,wBACD,KAAK,iBACL,IAAK,IAAI,EAAI,EAAG,EAAI,KAAK,WAAa,IAAK,EAClC,KAAK,eAAe,KACrB,KAAK,eAAe,GAAK,KAAK,QAAQ,mBAAmB,gCAAgC,KAIzG,CACA,wBACI,IAAK,IAAI,EAAI,EAAG,EAAI,KAAK,eAAe,SAAU,EAC9C,KAAK,QAAQ,oBAAoB,KAAK,eAAe,IAEzD,KAAK,eAAiB,EAC1B,CACA,kBACI,MAAM,EAAO,CACT,MAAO,KAAK,QAAQ,iBACpB,OAAQ,KAAK,QAAQ,mBAGzB,KAAK,WAAa,CAAC,IAAI,EAAyC,EAAE,qBAAsB,EAAM,EAAG,KAAK,QAAS,IAAI,EAAyC,EAAE,qBAAsB,EAAM,EAAG,KAAK,SAClM,KAAK,WAAa,CACd,IAAI,EAAyC,EAAE,qBAAsB,EAAM,EAAG,KAAK,OAAQ,CAAE,qBAAqB,IAClH,IAAI,EAAwB,uBAAsB,EAAM,EAAG,kCAAiB,KAEhF,KAAK,cAAgB,IAAI,EAAyC,EAAE,mBAAoB,EAAM,EAAG,KAAK,OAAQ,CAAE,qBAAqB,IACrI,KAAK,UAAY,IAAI,EAA6C,EAAE,qBAAsB,EAAM,KAAK,QAAQ,GAG7G,MAAM,EAAe,CACjB,CACI,OAAQ,EACR,aAAc,EACd,KAAM,KAAK,QAAQ,UAAU,4BAA8B,EAAI,GAEnE,CACI,OAAQ,EACR,aAAc,EACd,KAAM,IAGd,IAAK,IAAI,EAAI,EAAG,EAAI,EAAG0B,IAAK,CACxB,MAAM,EAAe,KAAK,QAAQ,uBAAuB,EAAM,EAAa,IAAI,GAC1E,EAAoB,KAAK,QAAQ,uBAAuB,EAAM,EAAa,IAAI,GAC/E,EAAmB,KAAK,QAAQ,uBAAuB,EAAM,EAAa,IAAI,GACpF1B,KAAK,WAAW0B,GAAG,mBAAmB,EAAc,GACpD1B,KAAK,WAAW,GAAG,mBAAmB,EAAmB,GACzD,KAAK,WAAW,GAAG,mBAAmB,EAAkB,GACxD,KAAK,WAAW,GAAG,mBAAmB,EAAmB,GACzD,KAAK,WAAW,GAAG,mBAAmB,EAAkB,GACxD,KAAK,cAAc,KAAK,IAAI,EAA6B,EAAE,GAAe,IAAI,EAA6B,EAAE,GAAoB,IAAI,EAA6B,EAAE,GACxK,CACJ,CAUA,mBACI,IAAK,IAAI,EAAI,EAAG,EAAI,KAAK,cAAc,OAAQ,IACjC,IAAN,GAIJ,KAAK,cAAc,GAAG,UAE1B,IAAK,IAAI,EAAI,EAAG,EAAI,EAAG,IACnB,KAAK,WAAW,GAAG,SAAQ,GAC3BA,KAAK,WAAW,GAAG,SAAQ,GAC3BA,KAAK,cAAc,SAAQ,GAE/B,KAAK,UAAU,UACf,KAAK,cAAgB,GACrB,KAAK,WAAa,GAClB,KAAK,WAAa,EACtB,CACA,kBAKI,OAJI,KAAK,WAAW,GAAG,UAAU,QAAU,KAAK,QAAQ,kBAAoB,KAAK,WAAW,GAAG,UAAU,SAAW,KAAK,QAAQ,oBAC7H,KAAK,mBACL,KAAK,mBAEF,KAAK,0BAChB,CACA,2BACI,IAAI,EACJ,MAAM,EAAkB,KAAK,OAAO,gBACpC,IAAK,EACD,OAAO,EAGX,MAAM,EAAe,EAAgB,SAAS,GACxC,GAAgE,QAA7C,EAAK,EAAgB,UAAU,gBAA6B,IAAP,OAAgB,EAAS,EAAG,QAAU,EAAgB,UAAU,SAAS,GAAc,qBAAuB,KAC5L,QAAK,IAGD,KAAK,oBAAsB,IAC3B,KAAK,kBAAoB,EACzB,KAAK,cAAc,mBAAmB,KAAK,kBAAmB,GAC1D,KAAK,cAAc,IACnB,KAAK,cAAc,GAAG,UAE1B,KAAK,cAAc,GAAI,QAAc,KAAK,mBAC1C,EAAgB,UAAU,aAAa,YAAY,KAAK,WAAW,GAAG,gBAEnE,EACX,CACA,iBACI,KAAK,wBAA0B,IAAI,EAAkC,EAAE,CACnE,eAAgB,eAChB,gBAAgB,EAChB,OAAQ,KAAK,QACb,aAAc,CAAC,cACf,aAAc,KAElB,KAAK,gCAAkC,IAAI,EAAkC,EAAE,CAC3E,eAAgB,eAChB,gBAAgB,EAChB,OAAQ,KAAK,QACb,aAAc,CAAC,cACf,aAAc,KAElB,KAAK,oBAAsB,IAAI,EAAkC,EAAE,CAC/D,eAAgB,WAChB,gBAAgB,EAChB,OAAQ,KAAK,QACb,aAAc,CAAC,cAAe,cAC9B,aAAc,KAElB,KAAK,gBAAkB,IAAI,EAAmC,EAAE,KAAK,QACzE,CAKA,mBAAmB,GACf,EAAgB,uBAAuB,KAAK,4BAChD,CAKA,KAAK,GACD,EAAO,WAAW,kBAAmB,KAAK,cAA2C,EAA7B,KAAK,wBAC7D,EAAO,WAAW,uBAAwB,KAAK,cAA2C,EAA7B,KAAK,sBAA4B,GAClG,CACA,iBAAiB,GACb,IAAI,EACA,KAAK,mBACL,EAAqB,CAAC,GAE1B,IAAK,IAAI,EAAI,EAAG,EAAI,EAAqB,OAAQ,IAAK,CAClD,MAAM,EAAW,EAAqB,KAAK,GAAG,cAC9C,IAAI,GAA4B,EAC5B,GAAc,EAClB,MAAM,EAAU,EAAqB,KAAK,GAC1C,IAAI,EACA,GAAY,EAYhB,GAXI,KAAK,mBACL,EAAc,EAAQ,kBACtB,GAAa,GAEb,IACA,EAA4B,EAAS,uBACrC,EAAc,EAAS,gBACvB,EAAS,wBAAyB,EAClC,EAAS,iBAAkB,GAE/B,EAAQ,QAAO,GACX,IAEA,EAAc,EAAQ,kBAClB,EAAY,iBAAiB,CAC7B,IAAI,EAAqB,EAAmB,EAAY,gBAAgB,UACnE,IACD,EAAqB,EAAmB,EAAY,gBAAgB,UAAY,KAAK,QAAQ,yBAEjG,EAAQ,kBAAkB,gBAAkB,CAChD,CAEA,IACA,EAAS,uBAAyB,EAClC,EAAS,gBAAkB,EAEnC,CACJ,CACA,cAAc,GACV,IAAI,GACkD,QAAtC,EAAK,KAAK,OAAO,uBAAoC,IAAP,OAAgB,EAAS,EAAG,gBAAgB,KAAK,YAE3G,KAAK,QAAQ,gBAAgB,KAAK,UAAU,cAG5C,KAAK,QAAQ,4BAEjB,KAAK,QAAQ,aAAa,GAC1B,KAAK,QAAQ,cACb,KAAK,QAAQ,aAAa,KAAK,oBAAoB,cACnD,KAAK,oBAAoB,OAAO,WAAW,cAAe,KAAK,cAAwB,EAAV,EAAc,IAC3F,KAAK,oBAAoB,OAAO,WAAW,aAAc,KAAK,cAAc,IAC5E,KAAK,gBAAgB,OAAO,KAAK,oBACrC,CAMA,OAAO,GAGH,GAFA,KAAK,oBAAoB,OAAS,EAClC,KAAK,mBAAmB,OAAS,IAC5B,KAAK,wBAAwB,OAAO,WACpC,KAAK,gCAAgC,OAAO,WAC5C,KAAK,oBAAoB,OAAO,WAChC,KAAK,mBACN,OAAO,KAAK,mBAEhB,IAAK,IAAI0B,EAAI,EAAG,EAAI,EAAqB,OAAQ,IAAK,CAClD,MAAM,EAAU,EAAqB,KAAK,GACpC,EAAW,EAAQ,eACrB,GACC,EAAS,WAAa,EAAqD,EAAE,qBAAuB,EAAS,WAAa,EAAkD,EAAE,kBAAoB,EAAS,WAAa,EAAuD,EAAE,wBACpN,IAA9D,KAAK,gBAAgB,QAAQ,EAAQ,UAAU,UAI/C,KAAK,mBAAmB,KAAK,GAH7B,KAAK,oBAAoB,KAAK,EAKtC,CACA,IAAK,KAAK,oBAAoB,OAM1B,OALA,KAAK,QAAQ,gBAAgB,KAAK,WAAW,GAAG,cAChD,KAAK,QAAQ,gBAAgB,KAAK,aAAa,IAC/C,KAAK,QAAQ,MAAM,KAAK,YAAY,IAAI,GAAM,GAAO,GACrD,KAAK,QAAQ,kBAAkB,KAAK,WAAW,GAAG,cAClD,KAAK,cAAc,GACZ,KAAK,mBAEhB,MAAM,EAAsB,KAAK,QAAQ,oBACzC1B,KAAK,OAAO,gBAAgB,UAAW,EACnC,KAAK,mBACL,KAAK,QAAQ,oBAAsB,KAAK,eAAe,IAG3DA,KAAKiH,QAAQ,gBAAgB,KAAK,WAAW,GAAG,cAChDjH,KAAK,QAAQ,gBAAgB,KAAK,aAAa,IAC/C,KAAK,QAAQ,MAAM,KAAK,YAAY,IAAI,GAAM,GAAO,GACrD,KAAK,QAAQ,kBAAkB,KAAK,WAAW,GAAG,cAClD,KAAK,QAAQ,gBAAgB,KAAK,WAAW,GAAG,cAChD,KAAK,QAAQ,gBAAgB,KAAK,aAAa,IAC/C,KAAK,QAAQ,MAAM,KAAK,YAAY,IAAI,GAAM,GAAO,GACrD,KAAK,QAAQ,kBAAkB,KAAK,WAAW,GAAG,cAClD,KAAK,QAAQ,gBAAgB,KAAK,WAAW,GAAG,cAChD,KAAK,QAAQ,gBAAgB,KAAK,aAAa,IAC/C,KAAK,QAAQ,MAAM,KAAK,YAAY,IAAI,GAAM,GAAO,GACrD,KAAK,QAAQ,kBAAkB,KAAK,WAAW,GAAG,cAClD,KAAK,QAAQ,gBAAgB,KAAK,WAAW,GAAG,cAChD,KAAK,QAAQ,gBAAgB,KAAK,aAAa,IAC/C,KAAK,QAAQ,MAAM,KAAK,YAAY,IAAI,GAAM,GAAO,GACrD,KAAK,QAAQ,kBAAkB,KAAK,WAAW,GAAG,cAElD,KAAK,QAAQ,gBAAgB,KAAK,WAAW,GAAG,cAChD,KAAK,QAAQ,gBAAgB,KAAK,aAAa,IAC/C,KAAK,QAAQ,aAAa,IAC1B,KAAK,QAAQ,iBAAiB,GAC9B,KAAK,QAAQ,kBAAkB,WAAY,EAC3C,KAAK,QAAQ,kBAAkB,WAAY,EAC3C,KAAK,QAAQ,cACb,KAAK,sBAAwB,EAE7B,KAAK,iBAAiB,KAAK,qBAC3B,KAAK,QAAQ,kBAAkB,KAAK,WAAW,GAAG,cAClD,KAAK,OAAO,sBAEZ,IAAI,EAAS,EACT,EAAU,EACd,IAAK,IAAI,EAAI,EAAG,EAAI,KAAK,WAAY,IAAK,CACtC,EAAS0B,EAAI,EACb,EAAU,EAAI,EACd1B,KAAK,sBAAwB,EACzB,KAAK,mBACL,KAAK,QAAQ,oBAAsB,KAAK,eAAe,EAAI,IAG/DA,KAAK,QAAQ,gBAAgB,KAAK,WAAW,GAAS,cACtDA,KAAKiH,QAAQ,gBAAgB,KAAK,aAAa,IAC/C,KAAK,QAAQ,MAAM,KAAK,YAAY,IAAI,GAAM,GAAO,GACrD,KAAK,QAAQ,kBAAkB,KAAK,WAAW,GAAS,cACxD,KAAK,QAAQ,gBAAgB,KAAK,WAAW,GAAS,cACtD,KAAK,QAAQ,gBAAgB,KAAK,aAAa,IAC/C,KAAK,QAAQ,MAAM,KAAK,YAAY,IAAI,GAAM,GAAO,GACrD,KAAK,QAAQ,kBAAkB,KAAK,WAAW,GAAS,cACxD,KAAK,QAAQ,gBAAgB,KAAK,WAAW,GAAS,cACtD,KAAK,QAAQ,gBAAgB,KAAK,aAAa,IAC/C,KAAK,QAAQ,aAAa,IAC1B,KAAK,QAAQ,iBAAiB,GAC9B,KAAK,QAAQ,kBAAkB,WAAY,EAC3C,KAAK,QAAQ,cAEb,KAAK,iBAAiB,KAAK,qBAC3B,KAAK,QAAQ,kBAAkB,KAAK,WAAW,GAAS,cACxD,KAAK,OAAO,sBAEZ,KAAK,QAAQ,gBAAgB,KAAK,cAAc,cAChD,KAAK,QAAQ,gBAAgB,KAAK,aAAa,IAC/C,KAAK,QAAQ,iBAAiB,GAC9B,KAAK,QAAQ,aAAa,IAC1B,KAAK,QAAQ,cACb,MAAM,EAAqC,IAAZ,GAAkB,KAAK,iBAAkD,KAAK,gCAApC,KAAK,wBAC9E,KAAK,QAAQ,aAAa,EAAtC,c,2FCxcgD,KAAK,QAAQ,kBAAkB,KAAK,cAAc,aAC3B,CAO/D,OANiE,KAAK,QAAQ,oBAAsB,EAEpG,KAAK,cAAc,GACnB,KAAK,OAAO,gBAAgB,UAAW,EACvC,KAAK,QAAQ,kBAAkB,WAAQ,EACvC,KAAK,QAAQ,kBAAkB,WAAY,EACpC,KAAK,kBAChB,CAIA,UACI,KAAK,mBACLjH,KAAK,wBAAwB,UAC7B,KAAK,oBAAoB,UACzB,KAAK,gBAAgB,UACrB,KAAK,uBACT,EAEJ,EAAqB,oBAAsB,MAC3C,EAAqB,WAAa,EAClC,EAAqB,WAAa,EAOlC,OAAO,eAAe,EAA2B,EAAE,UAAW,uBAAwB,CAClF,IAAK,WACD,IAAK,KAAK,sBAAuB,CAC7B,IAAI,EAAY,KAAK,cAAc,EAAsE,EAAE,2BACtG,IACD,EAAY,IAAI,EAA2B,MAC3C,KAAK,cAAc,GAE3B,CACO,OAAO,KAAK,qBACvB,EACA,IAAK,SAAU,GACX,KAAK,sBAAwB,CACjC,EACA,YAAY,EACZ,cAAc,IAElB,OAAO,eAAe,EAA2B,EAAE,UAAW,kCAAmC,CAC7F,IAAK,WACD,OAAO,KAAK,gCAChB,EACA,IAAK,SAAU,GACX,IAAI,EACA,KAAK,mCAAqC,IAG9C,KAAK,iCAAmC,EACxC,KAAK,wBAAwB,IACG,QAA/B,EAAK,KAAK,uBAAoC,IAAP,GAAyB,EAAG,cACxE,EACA,YAAY,EACZ,cAAc,IAKlB,MAAM,E,oGCnEiF,WAAa,CAKhB,UAAY,CAI5F,UACI,IAAI,EACuC,QAA1C,EAAK,KAAK,MAAM,4BAAyC,IAAP,GAAyB,EAAG,UACxE,KAAK,MAAM,qBAAuB,IAC7C,EAIgB,EAAoB,OAAxC,IAEI,EAAyB,EAAoB,OAI7C,GAFuC,EAAoB,OAErC,EAAoB,QAE1C,EAAW,EAAoB,OAcnC,MAAM,EAMF,SAAS,GACL,OAAO,KAAK,gBAAgB,EAChC,CAII,cACA,OAAO,KAAK,UAAU,OAC1B,CACI,YAAQ,GACR,KAAK,UAAU,QAAU,CAC7B,CAMA,kBACI,OAAO,KAAK,cAChB,CAMA,iBAAiB,GACT,EACA,KAAK,eAAiB,GAGtB,KAAK,eAAiB,KAAK,UAC3B,KAAK,QAAQ,oBAAsB,KAAK,eAAe,aAE/D,CAKI,yBACA,OAAO,KAAK,iBAAmB,KAAK,SACxC,CACA,qCACI,GAAK,KAAK,iCAUF,KAAK,iBACL,KAAK,gBAAgB,yBAEzB,KAAK,gBAAkB,KACvB,KAAK,OAAO,oCAd4B,CAExC,GADA,KAAK,gBAAkB,KAAK,OAAO,gCAC9B,KAAK,gBAGN,YADA,KAAK,kCAAmC,GAG5C,KAAK,gBAAgB,qBAAqB,KAC9C,CAQJ,CAII,cACA,OAAO,KAAK,QAChB,CAKA,YAAY,GAIRA,KAAK,oBAAsB,GAM3B,KAAK,kBAAoB,GAIzBA,KAAK,SAAW,EAChBA,KAAK,YAAc,GACnB,KAAK,WAAa,GAClBA,KAAK,UAAY,GACjBA,KAAK,gBAAkB,GACvB,KAAK,UAAW,EAIhB,KAAK,sBAAwB,GAI7B,KAAK,kCAAmC,EAIxC,KAAK,cAAgB,GACrB,KAAK,YAAc,IAAI,EAAuB,GAAG,EAAG,EAAG,EAAG,GAC1D,KAAK,UAAW,EAChB,KAAK,8BAA+B,EAMpC,KAAK,uBAAwB,EAC7B,KAAK,OAAS,EACd,KAAK,QAAU,EAAM,YACrB,EAAgB,8BAA8B,KAAK,QACnD,KAAK,UAAY,KAAK,oBAAoB,iBAAkB,MAC5D,KAAK,eAAiB,KAAK,SAC/B,CASA,oBAAoB,EAAM,GACtB,MAAM,EAAK,IAAI,EAA6C,EAAE,EAAM,EAAqB,CAAE,MAAO,KAAK,QAAQ,iBAAkB,OAAQ,KAAK,QAAQ,mBAAqB,EAAG,KAAK,OAAQ,CACvL,iBAAiB,EACjB,sBAAuB,KAAK,QAAQ,gBACpC,YAAa,EACb,MAAO,GACP,oCAAoC,IAGxC,OADA,KAAK,cAAc,KAAK,GACjB,CACX,CAII,kBACA,OAAO,KAAK,OAAO,YAAY,UAAU,oBAC7C,CAMA,yBAAyB,EAAQ,GAC7B,MAAM,EAAW,EAAQ,cACnB,EAAmB,GAAY,EAAS,iBACxC,EAAW,IAA0D,IAA9C,KAAK,kBAAkB,QAAQ,GACxD,KAAK,SAAW,KAAK,eAAe,UAChC,EAAO,cAAgB,IAAqB,EAC5C,KAAK,QAAQ,gBAAgB,KAAK,0BAG9B,KAAK,QAAQ,qBACb,KAAK,QAAQ,gBAAgB,KAAK,qBAGlC,KAAK,QAAQ,0BAEb,KAAK,iBAAmB,KAAK,qBAAuB,GACpD,KAAK,gBAAgB,WAAW,KAAK,EAAQ,qBAI7D,CACA,2BACI,MAAM,EAAoB,GACpB,EAAc,EAAC,GACf,EAAgB,EAAC,GACvB,IAAK,IAAI,EAAI,EAAG,EAAI,KAAK,SAAU,IAC/B,EAAkB,MAAK,GACnB,EAAI,IACJ,EAAY,MAAK,GACjB,EAAc,MAAK,IAG3B,KAAK,wBAA0B,KAAK,QAAQ,mBAAmB,GAC/D,KAAK,kBAAoB,KAAK,QAAQ,mBAAmB,GACzD,KAAK,oBAAsB,KAAK,QAAQ,mBAAmB,EAC/D,CACA,eACI,IAAK,IAAI,EAAI,EAAG,EAAI,EAAgB,gBAAgB,OAAQ,IACxD,KAAK,gBAAgB,EAAgB,gBAAgB,GAAG,OAAS,EAErE,KAAK,gBAAgB,GAAK,EAC1B,KAAK,WAAa,CAAC,GACnB,KAAK,YAAc,CAAC,EAAgB,gBAAgB,GAAG,QACvD,KAAK,UAAY,CAAC,EAAgB,gBAAE,SACpC,KAAK,SAAW,CACpB,CACA,8BAEI,GADA,KAAK,qCACD,KAAK,gBAAiB,CACtB,KAAK,gBAAgB,eACrB,MAAM,EAAoB,GAC1B,IAAK,IAAI0B,EAAI,EAAGA,EAAI,KAAK,WAAW,OAAQ,IACxC,EAAkB,MAAK,GAE3B,KAAK,gBAAgB,qBAAqB,KAAK,UAAU,sBACzD,MAAM,EAAU,CACZ,CACI,gBAAiB,EACjB,uBAAwB,EAAsE,EAAE,oBAEpG,CACI,gBAAiB,EACjB,uBAAwB,EAAuE,EAAE,qBAErG,CACI,gBAAiB,EACjB,uBAAwB,EAAyE,EAAE,uBAEvG,CACI,gBAAiB,EACjB,uBAAwB,EAA6E,EAAE,2BAE3G,CACI,gBAAiB,EACjB,uBAAwB,EAAyE,EAAE,wBAI3G,IAAK,IAAI,EAAI,EAAG,EAAI,EAAQ,OAAQ,IAAK,CACrC,MAAM,EAAQ,KAAK,WAAW,QAAQ,EAAQ,GAAG,kBAClC,IAAX,IACA,KAAK,gBAAgB,kBAAkB,EAAQ,GAAG,uBAAwB,GAC1E,EAAkB,IAAS,EAEnC,CACA,KAAK,gBAAgB,gBAAgB,KAAK,QAAQ,mBAAmB,GACzE,CACJ,CAIA,qBACQ,KAAK,SAAW,KAAK,eAAe,SAAW,KAAK,sBAChD,KAAK,QAAQ,qBACb,KAAK,QAAQ,gBAAgB,KAAK,qBAGlC,KAAK,QAAQ,0BAGzB,CAKA,YAAY,EAAQ,EAAW,GAEvB,KAAK,UACL,KAAK,UAEJ,KAAK,UAAa,KAAK,eAAe,UAGvC,KAAK,kBACL,KAAK,gBAAgB,WAAa,IAEtC,KAAK,wBAAwB,KAAK,eAAgB,GACtD,CACA,cAAc,EAAqB,EAAW,GACtC,EAAoB,oBACpB,EAAoB,oBAAoB,cAAc,KAAK,OAAQ,EAAW,EAAO,EAAoB,oBAAoB,wBAExH,KAAK,gCAAgC,OAC1C1B,KAAK,OAAO,mBAAmB,gBAG/B,KAAK,QAAQ,2BAErB,CAQA,gBAAgB,GACZ,MAAM,EAAU,KAAK,gCAAgC,GACrD,QAAK,IAGL,EAAQ,aAAe,EAAG,cACnB,EACX,CACA,qBAAqB,EAAqB,GACtC,IAAI,EACJ,MAAM,EAAU,KAAK,gCAAgC,GAC/C,EAAgB,EAAU,EAAQ,aAAe,EAAoB,oBAAsB,EAAoB,oBAAoB,aAAe,KAExJ,IAAI,EAAmB,KAAK,eAAe,gCACvCA,KAAK,+BACL,EAAmB,EAAiB,OAAO,CAAC,KAAK,eAAe,8BAGhE,EAAiB,SACjB,KAAK,OAAO,mBAAmB,cAA0D,QAA3C,EAAK,KAAK,eAAe,oBAAiC,IAAP,OAAgB,EAAS,EAAG,QAAS,GACtI,KAAK,OAAO,mBAAmB,aAAa,EAAkB,GAAe,EAAO,GAE5F,CAIA,WAAW,EAAW,GACd,KAAK,UAAY,KAAK,eAAe,UACrC,KAAK,cAAc,KAAK,eAAgB,EAAW,GACnD,KAAK,qBAAqB,KAAK,eAAgB,GAEvD,CAKA,SACQ,KAAK,UAAY,KAAK,eAAe,UACrC,KAAK,iBAAiB,KAAK,gBAE3B,KAAK,QAAQ,gBAAgB,KAAK,mBAClC,KAAK,QAAQ,MAAM,KAAK,aAAa,GAAM,GAAO,GAElD,KAAK,QAAQ,gBAAgB,KAAK,qBAE1C,CAEA,iBAAiB,GACb,GAAI,KAAK,UAAY,KAAK,eAAe,QAAS,CAC9C,KAAK,eAAe,aACpB,MAAM,EAAkB,KAAK,eAAe,aACxC,GACA,KAAK,QAAQ,gBAAgB,EAErC,CACJ,CACA,YAAY,GACR,KAAK,SAAW,CACpB,CACA,wBAAwB,EAAqB,GACzC,EAAoB,QAAU,EACzB,GACD,KAAK,uBAAuB,EAEpC,CAQA,uBAAuB,GAEnB,IAAK,IAAI,EAAI,EAAG,EAAI,KAAK,sBAAsB,OAAQ,IACnD,GAAI,KAAK,sBAAsB,GAAG,OAAS,EAAI,KAC3C,OAAO,KAAK,sBAAsB,GAI1C,OADA,KAAK,sBAAsB,KAAK,GACzB,CACX,CACA,UACI,MAAM,EAAmB,KAAK,SAC9B,IAAK,IAAI,EAAI,EAAG,EAAI,KAAK,sBAAsB,OAAQ,IAC/C,KAAK,sBAAsB,GAAG,SAC9B,KAAK,gBAAgB,KAAK,sBAAsB,GAAG,kBAG3D,IAAK,IAAI,EAAI,EAAG,EAAI,KAAK,cAAc,OAAQ,IAAK,CAC5C,KAAK,WAAa,GAAoB,KAAK,cAAc,GAAG,QAAU,KAAK,UAC3E,KAAK,cAAc,GAAG,YAAY,KAAK,SAAU,CAAE,MAAO,KAAK,aAAe,KAAK,UAAU,OAAO,wBAExG,KAAK,cAAc,GAAG,yBACtB,IAAK,IAAI,EAAI,EAAG,EAAI,KAAK,sBAAsB,OAAQ,IAC/C,KAAK,sBAAsB,GAAG,WAIzB,KAAK,sBAAsB,GAAG,aAAe,KAAK,sBAAsB,GAAG,mBAC5E,KAAK,sBAAsB,GAAG,oBAE9B,KAAK,sBAAsB,GAAG,aAC9B,KAAK,cAAc,GAAG,gCAAgC,KAAK,KAAK,sBAAsB,GAAG,aAIzG,CACA,KAAK,2BACL,KAAK,aAAY,GACjB,KAAK,6BACT,CACA,WACI,KAAK,aAAY,GACjB,IAAK,IAAI,EAAI,EAAG,EAAI,KAAK,cAAc,OAAQ,IAC3C,KAAK,wBAAwB,KAAK,cAAc,IAAI,GAExD,KAAK,eACL,IAAK,IAAI,EAAI,EAAG,EAAI,KAAK,sBAAsB,OAAQ,IACnD,KAAK,sBAAsB,GAAG,SAAU,CAEhD,CACA,wBAAwB,EAAqB,GACzC,GAAI,EACA,OAAO,EAAO,eAEb,GAAI,EAAoB,oBAAqB,CAC9C,GAAI,EAAoB,oBAAoB,uBAAwB,CAChE,MAAM,EAAS,EAAoB,oBAAoB,aAAe,EAAoB,oBAAoB,aAAe,KAAK,OAAO,aACzI,OAAO,EAAS,EAAO,eAAiB,EAC5C,CACK,OAAI,EAAoB,oBAAoB,cACtC,EAAoB,oBAAoB,cAGxC,EAEf,CAEI,OAAO,KAAK,OAAO,aAAe,KAAK,OAAO,aAAa,eAAiB,EAEpF,CACA,wBAAwB,EAAqB,GAEzC,MAAM,EAAkB,GAAU,KAAK,OAAO,iBAAmB,KAAK,OAAO,cAAc,QAAwD,IAA9C,KAAK,OAAO,cAAc,QAAQ,GACvIA,KAAK,gCAAkC,KAAK,wBAAwB,EAAqB,GACzF,KAAK,gCAAkC,KAAK,gCAAgC,QAAQ,GACnE,MAAN,IAEX,KAAK,OAAO,WAAY,EACxB,MAAM,EAA2B,KAAK,oBAAoB,KAAK,iCAC/D,KAAK,8BAAgC,IAA6B,KAAK,uBAAyB,KAAK,0BAA4B,EACjI,MAAM,EAAgB,KAAK,qBAAqB,KAAK,iCAC/C,EAAiB,EAAoB,iCAAmC,EAAoB,gCAAgC,GAClI,IAAI,EAAU,KAEd,KAAK,OAAO,6BAA6B,mBAAqB,KAAK,8BAAgC,EAE/F,KAAK,+BAAiC,EAAoB,4BAC1D,EAAoB,2BAGpB,EACA,EAAU,EAEL,KAAK,6BACV,EAAU,EAAoB,2BAEzB,IACL,EAAU,GAEd,KAAK,iBAAiB,GACtB,KAAK,qBAAqB,EAAqB,EACnD,CACA,qBAAqB,EAAqB,GAClC,IACA,EAAY,WAAY,EACxB,EAAY,aAAe,EAAoB,cAE/C,EAAoB,qBAAuB,IACvC,EAAoB,oBACpB,KAAK,uBAAuB,GAEhC,EAAoB,mBAAqB,GAEzC,EAAoB,wBACpB,KAAK,8BACL,EAAoB,uBAAwB,EAEpD,CAIA,uBAAuB,GACf,EAAoB,qBACpB,EAAoB,mBAAmB,WAAY,EACnD,EAAoB,mBAAmB,6BACvC,EAAoB,mBAAqB,KAEjD,CACA,wBACI,IAAK,IAAI,EAAI,EAAG,EAAI,KAAK,sBAAsB,OAAQ,IACnD,GAAI,KAAK,sBAAsB,GAAG,SAAW,KAAK,sBAAsB,GAAG,qBACvE,OAAO,EAGf,OAAO,CACX,CACA,oBAAoB,GAChB,IAAI,EACJ,IAAI,GAAsB,EAC1B,GAAI,EACA,IAAK,IAAI,EAAI,EAAG,EAAI,EAAc,OAAQ,IACtC,GAAyF,gCAAxD,QAA3B,EAAK,EAAc,UAAuB,IAAP,OAAgB,EAAS,EAAG,gBAAkD,CACnH,GAAsB,EACtB,KACJ,CAGR,OAAO,CACX,CAMA,qBAAqB,GACjB,IAAK,IAAI,EAAU,EAAG,EAAU,EAAc,OAAQ,IAClD,GAA+B,OAA3B,EAAc,GACd,OAAO,EAAc,GAG7B,OAAO,IACX,CAIA,cACI,KAAK,UAAW,CACpB,CAKA,gBAAgB,GAEZ,KAAK,OAAO,4BAA6B,EACzC,IAAK,IAAI,EAAI,EAAG,EAAI,EAAM,OAAQ,IAAK,CACnC,MAAM,EAAO,EAAM,IACiB,IAAhC,KAAK,gBAAgB,KACrB,KAAK,gBAAgB,GAAQ,KAAK,WAAW,OAC7C,KAAK,WAAW,KAAK,GACrBA,KAAK,YAAY,KAAK,EAAgB,gBAAgB,GAAM,QAC5D,KAAK,UAAU,KAAK,EAAgB,gBAAgB,GAAM,MAC1D,KAAK,YAEI,IAAT,IACA,KAAK,OAAO,4BAA6B,EAEjD,CACJ,CACA,UACI,KAAK,WACL,IAcI,EAdA,GAAgB,EACpB,KAAK,OAAO,6BAA6B,oBAAqB,EAC1D,KAAK,OAAO,uBAAyB,KAAK,OAAO,kCACjD,KAAK,OAAO,sBAAsB,mBAAmB,MACrD,GAAgB,GAEpB,IAAK,IAAI,EAAI,EAAG,EAAI,KAAK,OAAO,UAAUkG,OAAQ,IAC1C,KAAK,OAAO,UAAU,GAAGgB,mBAAmBlH,QAC5C,GAAgB,GAGpB,GACA,KAAK,wBAAwB,KAAK,WAAW,GAGjD,IAAK,IAAI,EAAI,EAAG,EAAI,KAAK,cAAc,OAAQ,IAAK,CAChD,GAAI,KAAK,cAAc,GAAG,oBACtB,EAAgB,KAAK,wBAAwB,KAAK,cAAc,QAE/D,CACD,MAAM,EAAS,KAAK,OAAO,aAC3B,IAAK,EACD,SAEJ,EAAgB,EAAO,cAC3B,CACA,GAAK,IAGL,EAAgB,EAAc,QAAQ,GACrB,MAAN,IAEP,GAAe,CACf,IAAK,IAAI,EAAI,EAAG,EAAI,EAAc,OAAQ,IAClC,EAAc,GAAG,mBAAmB,QACpC,KAAK,wBAAwB,KAAK,cAAc,IAAI,GACpD,GAAgB,GAGpB,KAAK,oBAAoB,KACzB,KAAK,OAAO,6BAA6B,oBAAqB,EAEtE,CACJ,CACA,KAAK,kCACL,KAAK,UAAW,EACZ,GACF,cAEN,CACA,kCACI,MAAM,EAAY,KAAK,OAAO,UAC9B,IAAK,IAAI,EAAI,EAAG,EAAI,EAAU,OAAQ,IAClC,EAAU,GAAG,YAAY,EAAkD,EAAE,iBAErF,CAIA,UACI,IAAK,IAAI,EAAI,KAAK,cAAc,OAAS,EAAG,GAAK,EAAG,IAChD,KAAK,cAAc,GAAG,UAE1B,IAAK,IAAI,EAAI,EAAG,EAAI,KAAK,sBAAsB,OAAQ,IAC/C,KAAK,sBAAsB,GAAG,SAC9B,KAAK,sBAAsB,GAAG,SAG1C,EAKJ,EAAgB,8BAAiC,IAC7C,MAAM,EAAG,EAA0B,GAAG,gCAAgC,EAE1E,EAAgB,gBAAkB,CAC9B,CACI,KAAM,EACN,OAAQ,EACR,KAAM,sBAEV,CACI,KAAM,EACN,OAAQ,EACR,KAAM,oBAEV,CACI,KAAM,EACN,OAAQ,EACR,KAAM,oB,CCxqB8B,KAAM,EACqB,OAAQ,EAChB,KAAM,wBAEjE,CACI,KAAM,EACN,OAAQ,EACR,KAAM,iBAEV,CACI,KAAM,EACN,OAAQ,EACR,KAAM,iBAEV,CACI,KAAM,EACd,SACQ,KAAM,kBAEV,CACI,KAAM,EACN,OAAQ,EACR,KAAM,mBASd,OAAO,eAAe,EAA2B,EAAE,UAAW,kBAAmB,CAC7E,IAAK,WACD,OAAO,KAAK,gBAChB,EACA,IAAK,SAAU,GACP,GAAS,EAAM,cACf,KAAK,iBAAmB,EAEhC,EACA,YAAY,EACZ,cAAc,IAElB,EAAiD,EAAE,UAAU,sBAAwB,WACjF,OAAI,KAAK,mBAGT,KAAK,iBAAW,YACX,KAAK,iBAAiB,cACvB,KAAK,iBAAmB,KACxB,EAAyB,EAAE,MAAM,qJAL1B,KAAK,gBAQpB,EACA,EAAkD,EAAE,UAAG,kCAC9C,KAAK,mBAGV,KAAK,iBAAiB,UACtB,KAAK,iBAAmB,KAC5B,EAKA,MAAM,EAKF,YAAY,GAIR,KAAK,KAAO,EAAiE,EAAE,qBAC/E,KAAK,MAAQ,CACjB,CAIA,WACI,KAAK,MAAM,uBAAuB,aAAa,EAA0E,EAAE,8BAA+B,KAAM,KAAK,mBACrK,KAAK,MAAM,sBAAsB,aAAa,EAAyE,EAAE,6BAA8B,KAAM,KAAK,kBAClK,KAAK,MAAM,6BAA6B,aAAa,EAAgF,EAAE,oCAAqC,KAAM,KAAK,yBACvL,KAAK,MAAM,4BAA4B,aAAa,EAAyE,EAAE,6BAA8B,KAAM,KAAK,wBACxK,KAAK,MAAM,kBAAkB,aAAa,EAAqE,EAAE,yBAA0B,KAAM,KAAK,mBACtJ,KAAK,MAAM,8BAA8B,aAAa,EAAiF,EAAE,qCAAsC,KAAM,KAAK,+BAC1L,KAAK,MAAM,0BAA0B,aAAa,EAA6E,EAAE,iCAAkC,KAAM,KAAK,2BAC9K,KAAK,MAAM,yBAAyB,aAAa,EAA4E,EAAE,gCAAiC,KAAM,KAAK,yBAC/K,CACA,wBAAwB,EAAc,EAAW,GACzCA,KAAKW,MAAMwG,kBAAoB,EAAa,oBAC5C,KAAK,MAAM,gBAAgB,iBAAiB,EAAa,sBACzD,KAAK,MAAM,gBAAgB,iBAAY,EAAW,EAAW,GAErE,CACA,uBAAuB,EAAc,EAAW,GACxCnH,KAAKW,MAAMwG,kBAAoB,EAAa,mBAC5C,KAAK,MAAM,gBAAgB,WAAW,EAAW,EAEzD,CACA,8BAA8B,GACtB,KAAK,MAAM,kBAAoB,EAAa,oBACvC,EAAa,uBACd,EAAa,qBAAuB,KAAK,MAAM,gBAAgB,oBAAoB,EAAa,KAAO,cAAe,IAE1H,KAAK,MAAM,gBAAgB,iBAAiB,EAAa,sBACzD,KAAK,MAAM,gBAAgB,SAEnC,CACA,kBAAkB,GACV,KAAK,MAAM,kBACX,KAAK,MAAM,gBAAgB,iBAAiB,MAC5C,KAAK,MAAM,gBAAgB,YAAY,GAE/C,CACA,mBACQ,KAAK,MAAM,iBACX,KAAK,MAAM,gBAAgB,YAEnC,CACA,oBACQ,KAAK,MAAM,kBACX,KAAK,MAAM,gBAAgB,iBAAiB,MAC5C,KAAK,MAAM,gBAAgB,SAEnC,CACA,0BAA0B,EAAM,EAAS,EAAO,GAC5C,IAAK,EACD,OAGJ,MAAM,EAAQ,EAAK,WACf,EAAM,iBACN,EAAM,gBAAgB,yBAAyB,EAAQ,EAE/D,CACA,yBAAyB,GACrB,MAAM,EAAQ,EAAK,WACf,EAAM,iBACN,EAAM,gBAAgB,oB,CC1IwE,UAEhD,KAAK,MAAM,yBAE7D,KAAK,MAAM,uBACf,CAIA,UACI,KAAK,MAAM,wBACf,EAEJ,EAAgB,8BAAiC,IAE7C,IAAI,EAAY,EAAM,cAAc,EAAiE,EAAE,sBAClG,IACD,EAAY,IAAI,EAA8B,GAC9C,EAAM,cAAc,GACxB,EAIJ,IAAI,EAAkC,EAAoB,OAY1D,MAAM,EAIE,mBACA,OAAO,KAAK,aAChB,CAII,mBACA,OAAO,KAAK,aAChB,CAII,oBACA,OAAO,KAAK,cAChB,CAKA,YAAY,GACR,KAAK,cAAgB,GACrB,KAAK,eAAiB,GACtB,KAAK,cAAgB,GAIrB,KAAK,SAAU,EAIfnH,KAAK,sBAAuB,EAI5B,KAAK,KAAO,EAA4D,EAAE,gBAO1E,KAAK,yBAA2B,GAKhC,KAAK,cAAgB,EAIrB,KAAK,iBAAmB,CACpB,EACA,EACA,EACA,GAGJ,KAAK,oBAAoB,IAAI,EAAuB,GAAG,EAAG,EAAG,IAC7D,KAAK,OAAS,EACd,EAAwB,8BAA8B,KAAK,OAC/D,CAOA,oBAAoB,GAChB,GAAI,KAAK,aAAa,QAAU,EAG5B,OADA,EAAyB,EAAE,MAAM,iEAC1B,EAGX,IAAK,IAAI0B,EAAI,EAAG,EAAI,KAAK,cAAc,OAAS,EAAG,IAC/C,GAAI,KAAK,cAAkB,EAAJ,KAAW,EAAM,GAAK,KAAK,cAAkB,EAAJ,EAAQ,KAAO,EAAM,GAAK,KAAK,cAAkB,EAAJ,EAAQ,KAAO,EAAM,EAC9H,OAAO,EAOf,OAJA,KAAK,cAAc,KAAK,EAAM,EAAG,EAAM,EAAG,EAAM,GAChD,KAAK,cAAc,KAAK,KAAK,IAAI,KAAK,IAAI,EAAM,EAAG,EAAM,GAAI,EAAM,IACnE1B,KAAK,eAAe,KAAK,KAAK,8BAA8B,IAC5D,KAAK,yBAAyB,KAAK,GAC5B,KAAK,cAAc,OAAS,CACvC,CAKA,oBAGI,OAFA,KAAK,YAAc,IAAI,EAAqE,EAAE,uBAAwB,KAAK,OAAQ,EAAG,UAAM,EAAW,KAAK,OAAO,aACnK,KAAK,YAAY,WAAY,EACtB,KAAK,WAChB,CAKA,4BACI,KAAK,cAAgB,GACrB,KAAK,cAAgB,GACrB,KAAK,eAAiB,GACtB,KAAK,yBAA2B,EACpC,CAIA,UACI,KAAK,4BACD,KAAK,aACL,KAAK,YAAY,SAEzB,CAaA,8BAAM,GACF,MACM,EAAwB,KAAK,IAAI,EAA/C,W,0CADoB,K,GChKhB,8BAA8B,EAAG,GAE7B,MAAM,EAAI,EAAI,GADd,EAAI,EAAI,IACe,EAAI,EAAI,KAAK,KAAK,EAAI,EAAI,EAAI,IAC/C,EAAI,KAAK,IAAI,GAAI,EAAM,GAEvB,EAAI,EADA,EAAIoH,EAAI,EACA,EAElB,OADU,EAAI,KAAK,IAAI,GAAK,EAAI,IACrB,CACf,EAKJ,EAAwB,8BAAiC,IACrD,MAAM,EAAG,EAA0B,GAAG,2BAA2B,EAIjD,EAAoB,OAQG,EAAE,UAAU,EAA4D,EAAE,iBAAiB,CAAC,EAAY,KAE/I,QAA4C,IAAxC,EAAW,0BAAkF,OAAxC,EAAW,2BAChE,EAAM,6BACF,EAAM,yBACN,IAAK,IAAI,EAAQ,EAAG,EAAQ,EAAW,yBAAyB,OAAQ,EAAQ,EAAO,IAAS,CAC5F,MAAM,EAAQ,EAAW,yBAAyB,GAClD,EAAM,wBAAwB,oBAAoB,IAAI,EAAuB,GAAG,EAAM,EAAG,EAAM,EAAG,EAAM,GAC5G,CAER,IAEJ,OAAO,eAAe,EAA2B,EAAE,UAAW,0BAA2B,CACrF,IAAK,WACD,OAAO,KAAK,wBAChB,EACA,IAAK,SAAU,GACP,GACI,KAAK,0BACL,KAAK,yBAA2B,EAGrC,EACP,YAAY,EACZ,cAAc,IAElB,EAAsD,EAAE,UAAU,2BAA6B,WAC3F,GAAI,KAAK,yBACL,OAAO,KAAK,yBAEhB,MAAM,EAAkB,KAAK,wBAC7B,OAAI,GACApH,KAAK,yBAA2B,IAAI,EAAwB,MAC5D,EAAgB,uBAAuB,KAAK,0BACrC,KAAK,0BAET,IACX,EACA,EAAuD,EAAE,UAAU,4BAA8B,WACxF,KAAK,2BAGV,KAAK,yBAAyB,UAC9B,KAAK,yBAA2B,KACpC,EAKA,MAAM,EAKF,YAAY,GAIR,KAAK,KAAO,EAAiE,EAAE,qBAC/E,KAAK,MAAQ,CACjB,CAIA,WAAa,CAKb,UAAU,GACN,IAAK,KAAK,MAAM,wBACZ,OAEJ,MAAM,EAA2B,KAAK,MAAM,wBAAwB,yBACpE,EAAoB,yBAA2B,GAC/C,IAAK,IAAI,EAAI,EAAG,EAAI,EAAyB,OAAQ,IACjD,EAAoB,yBAAyB,KAAK,CAC9C,EAAG,EAAyB,GAAG,EAC/B,EAAG,EAAyB,GAAG,EAC/B,EAAG,EAAyB,GAAG,GAG3C,CAIA,mBAEA,CAIA,sBAES,KAAK,MAAM,iB,wHC9HqB,E,oCAIiB,IAAI,EAAY,EAAM,cAAc,EAA4D,EAAE,iBACvF,IACzB,EAAY,IAAI,EAAyB,GAC3C,EAAM,cAAc,GAC6D,EAI/H,IAAI,EAAS,EAAoB,OAE7B,EAAO,EAAoB,OAE3B,EAAwB,EAAoB,OAE5C,EAAiB,EAAoB,OAMrC,GAJmB,EAAoB,OAEtB,EAAoB,OAEX,EAAoB,QAgBlD,EAA8C,EAAE,UAAU,mBAAqB,WAI3E,OAHK,KAAK,mBACNA,KAAK,iBAAmB,IAAI,EAAgB,OAEzC,KAAK,gBAChB,EACA,OAAO,eAAe,EAAyB,GAAG,UAAW,gBAAiB,CAC1E,IAAK,WACD,OAAO,KAAK,cAChB,EACA,IAAK,SAAU,GACA,GAEP,KAAK,WAAW,qBAEpB,KAAK,eAAiB,CAC1B,EACA,YAAY,EACZ,cAAc,IAElB,OAAO,eAAa,gCAChB,IAAK,WACD,OAAO,KAAK,cAChB,EACA,IAAK,SAAU,GACP,GAEA,KAAK,WAAW,qBAEpBA,KAAK,eAAiB,CAC1B,EACA,YAAY,EACZ,cAAc,IAMlB,MAAM,EAKF,YAAY,GAIR,KAAK,KAAO,EAAiE,EAAE,qBAI/E,KAAK,QAAU,EAIf,KAAK,aAAe,EACpB,KAAK,MAAQ,EACb,KAAK,QAAU,EAAM,YACrB,KAAK,MAAM,cAAc,MACzB,KAAK,sBAAwB,GAC7B,IAAK,IAAI,EAAI,EAAG,EAAI,IAAK,EACrB,KAAK,sBAAsB,GAAK,KAAK,QAAQ,mBAAmB,qBAAqB,KAE7F,CAIA,WACI,KAAK,MAAM,0BAA0B,aAAa,EAA6E,EAAE,iCAAkC,KAAM,KAAK,sBAC9K,KAAK,MAAM,yBAAyB,aAAa,EAA4E,EAAE,gCAAiC,KAAM,KAAK,oBAC/K,CAKA,UAEA,CAIA,UACI,IAAK,IAAI,EAAI,EAAG,EAAI,KAAK,sBAAsB,SAAU,EACrD,KAAK,QAAQ,oBAAoB,KAAK,sBAAsB,GAEpE,CAQA,OAAO,EAAS,EAAO,GAAa,EAAO,GACvC,EAAe,QAAmD,EAAe,KAAK,sBAAsB,GAC5G,MAAM,EAAQ,KAAK,MACb,EAAS,EAAM,YACf,EAA6B,EAAO,UAAU,kBACN,OAAxC,EAAM,iBAAiB,EAAQ,WAAyD,IAAxC,EAAM,iBAAiB,EAAQ,MAAuB,EAAQ,mBAAmB,kBACvI,IAAK,KAAK,QAAQ,EAAS,EAA4B,GACnD,OAEJ,oBACM,EAAkB,EAAU,8BAA8B,kBAAoB,EAAY,KAC1F,EAAgB,EAAQ,mBACxB,EAAgB,GAAoC,EACpD,EAAW,EAAQ,cACzB,IAAK,IAAa,EAAM,aACpB,OAEJ,MAAM,EAAc,EAAQ,gBAAgB,GACtC,EAAS,EAAiD,EAAE,UAAU,GAuB5E,GAtBA,EAAO,aAAa,GAEhB,EAAS,qBACb,yCAAmB,KAAK,IAAI,EAAM,aAAa,KAAO,GAAO,KAAK,MAElE,EAAO,SAAS,SAAU,EAAa,EAAI,EAAc,cACzD,EAAO,UAAU,QAAS,EAAa,EAAc,aAAe,EAAc,aAAc,EAAa,EAAc,aAAe,EAAS,OACnJ,EAAO,UAAU,iBAAkB,EAAM,sBACzC,EAAO,UAAU,QAAS,EAAc,kBAEpC,EAAc,UAAY,EAAc,0BAA4B,EAAc,UAClF,EAAO,YAAY,SAAU,EAAc,SAAS,qBAAqB,IAEzE,EAAc,oBAAsB,EAAc,mBAAmB,0BACrE,EAAc,mBAAmB,MAAM,GAG3C,EAA6D,EAAE,0BAA0B,EAAe,GACnG,GACD,EAAc,MAAM,EAAS,EAAQ,EAAS,UAG9C,GAAY,EAAS,mBAAoB,CACzC,MAAM,EAAO,wBACT,IACA,EAAO,WAAW,iBAAkB,GACpC,EAAO,UAAU,gBAAiB,EAAa,oBAEvD,EAEA,EAAG,EAA2C,IAAI,EAAQ,EAAU,GACpE,EAAO,YAAY,KAAK,SACxB,EAAO,iBAAiB,KAAK,cAC7B,EAAc,kBAAkB,EAAG,eAA2B,EAAO,GAA4B,CAAC,EAAY,KAC1G,EAAO,UAAU,cAErB,EAAO,WAAW,GAClB,EAAO,gBAAgB,EAC3B,CASA,QAAI,OACA,EAAe,QAAmD,EAAe,KAAK,sBAAsB,GAC5G,MAAM,EAAU,GACV,EAAU,CAAC,mBAAwD,EAAE,YACrE,EAAO,EAAI,UACX,EAAW,EAAQ,cACzB,IAAK,EACD,OAAO,EAEX,MAAM,EAAQ,EAAK,WAEf,EAAS,qBACT,EAAQ,KAAK,qBACT,EAAK,sBAAsB,EAAgC,EAAE,UAC7D,EAAQ,KAAK,EAAgC,EAAE,QAC/C,EAAQ,KAAK,gBAEb,EAAK,sBAAsB,EAAiC,EAAE,WAC9D,EAAQ,KAAK,EAAiC,EAAE,SAChD,EAAQ,KAAK,iBAIjB,EAAS,qBACT,EAAQ,KAAK,6BAGjB,EAAG,EAAyD,IAAI,EAAU,EAAO,GAE7E,EAAK,UAAY,EAAK,0BACtB,EAAQ,KAAK,EAA6C,EAAE,qBAC5D,EAAQM,KAAK,EAA6C,EAAE,qBAC5D,yBACI,EAAQ,KAAK,EAAkD,EAAE,0BACjE,EAAQA,KAAK,EAAkD,EAAE,2BAErE,EAAQ,KAAK,gCAAkC,EAAK,oBACpD,EAAQ,KAAK,yBAA2B,EAAK,SAAW,EAAK,SAAS,MAAM,OAAS,EAAI,KAGzF,EAAQ,KAAK,kCAGjB,MAAM,EAAqB,EAAK,mBAChC,IAAI,EAAsB,EACtB,GACI,EAAmB,eAAiB,IACpC,EAAsB,EAAmB,eACzC,EAAQ,KAAK,wBACb,EAAQ,KAAK,iCAAmC,GAC5C,EAAmB,0BACnB,EAAQ,KAAK,gCAEjB,EAA+E,EAAE,4CAA4C,EAAS,EAAM,IAIhJ,IACA,EAAQ,KAAK,qBACb,EAA8D,EAAE,2BAA2B,GACvF,EAAQ,mBAAmB,kBAC3B,EAAQ,KAAK,2BAIrB,MAAM,EAAc,EAAQ,gBAAgB,GAAc,GACpD,EAAgB,EAAY,QAC5B,EAAO,EAAQ,KAAK,MAC1B,GAAI,IAAkB,EAAM,CACxB,MAAM,EAAW,CACb,QACA,SACA,iBACA,gBACA,SACA,QACA,2BACA,wBACA,yBACA,8BAEJ,EAAG,EAAkD,IAAI,GACzD,EAAY,UAAU,KAAK,MAAM,YAAY,aAAa,UAAW,EAAS,EAAU,CAAC,iBAAkB,gBAAiB,OAAM,OAAW,OAAW,EAAW,CAC/J,4BAA6B,IAC7B,EACR,CACA,OAAO,EAAY,OAAO,SAC9B,CACA,qBAAqB,EAAM,EAAS,GAGhC,GADA,KAAK,iBAAmB,KAAK,QAAQ,gBACjC,EAAK,cAAe,CACpB,MAAM,EAAW,EAAQ,cACrB,GAAY,EAAS,yBAAyB,KAC9C,KAAK,QAAQ,oBAGb,KAAK,QAAQ,eAAc,GAC3B,KAAK,QAAQ,eAAc,GAC3B,KAAK,QAAQ,kBAAiB,GAC9B,KAAK,QAAQ,wBAAwB,MACrC,KAAK,QAAQ,mBAAmB,KAChC,KAAK,QAAQ,eAAe,EAAgB,mBAC5C,KAAK,QAAQ,4BAA4B,EAAgB,mBACzD,KAAK,QAAQ,qBAAqB,sBAAuB,EACzD,KAAK,OAAO,EAAS,GAAmC,EAAM,KAAK,sBAAsB,IACzF,KAAK,QAAQ,eAAc,GAC3B,KAAK,QAAQ,mBAAmB,MAGpC,KAAK,QAAQ,eAAc,GAC3B,KAAK,OAAO,EAAS,GAAO,EAAO,KAAK,sBAAsB,IAC9D,KAAK,QAAQ,cAAc,KAAK,kBAC5B,GAAY,EAAS,yBAAyB,KAC9C,KAAK,QAAQ,qBAAqB,sBAAuB,EACzD,KAAK,QAAQ,sB,sOC1TiD,KAAK,QAAQ,cAAc,KAAK,kBAC5C,KAAK,QAAQ,WAAW,WAAa,CAC/F,CAEI,EAAK,eAAiB,KAAK,mBAC3B,KAAK,QAAQ,eAAc,GACpB,KAAK,QAAQ,eAAc,GAClC,KAAK,OAAO,EAAS,GAAO,EAAO,KAAK,sBAAsB,IAC9D,KAAK,QAAQ,eAAc,GAEnC,EAKJ,EAAgB,kBAAoB,EAGf,EAAoB,OAElB,EAAoB,OAEhB,EAAoB,OAJ/C,IAMI,EAAa,EAAoB,OASrC,MAAM,EAEE,mBACA,OAAO,KAAK,aAChB,CACI,iBAAa,GACT,IAAS,KAAK,gBAGlB,KAAK,cAAgB,EACrB,KAAK,sBAAsB,gBAAgB,MAC/C,CAEI,oBACA,OAAQ,KAAK,WACjB,CAEI,kBACA,OAAO,KAAK,YAChB,CACI,gBAAY,GACR,KAAK,eAAiB,GAAQ,KAAK,iBAGvC,KAAK,aAAe,EACpBN,KAAK,kBAAmB,EAC5B,CACA,eACI,IAAI,EACJ,SAAwC,QAA7B,EAAK,KAAK,qBAAkC,IAAP,OAAgB,EAAS,EAAG,SAChF,CAII,kBACA,OAAO,IACX,CAIA,eACI,MAAO,sBACX,CAKA,YAAY,GAER,KAAK,SAAW,EAChB,KAAK,cAAgB,GAErB,KAAK,sBAAwB,IAAI,EAA2B,GAE5D,KAAK,uBAAyB,IAC9B,KAAK,cAAe,EACpB,KAAK,OAAS,EACd,KAAK,QAAU,EAAM,YACrBA,KAAK,kBAAmB,EACxB,KAAK,oBAAsB,KAC3B,KAAK,wBAA0B,IACnC,CACA,iBACI,MAAM,EAAe,CAAC,OAAQ,aAAc,iBAAkB,QACxD,EAAiB,CAAC,WAAY,UAC9B,EAAU,GAChB,KAAK,kBAAmB,EACpB,KAAK,cACL,EAAe,KAAK,YACpB,EAAQ,KAAK,oCAEb,KAAK,OAAO,sBACZ,EAAQ,KAAK,8BAEjB,KAAK,oBAAsB,IAAI,EAAkC,EAAE,CAC/D,OAAQ,KAAK,QACb,gBAAgB,EAChB,aAAc,8BACd,eAAgB,8BAChB,iBACA,eACA,aAAc,GACd,YAEJ,EAAa,KAAK,iBAClB,KAAK,wBAA0B,IAAI,EAAkC,EAAE,CACnE,OAAQ,KAAK,QACb,gBAAgB,EAChB,aAAc,kCACd,eAAgB,kCAChB,eAAgB,CAAC,WAAY,UAC7B,eACA,aAAc,IAEtB,CAKA,UAII,GAHIA,KAAK,kBACL,KAAK,kBAEJ,KAAK,sBAAwB,KAAK,wBACnC,OAAO,EAEX,MAAM,EAAc,KAAK,oBAAoB,aAAa,OACpD,EAAkB,KAAK,wBAAwB,aAAa,OAClE,OAAO,EAAY,WAAa,EAAgB,SACpD,CAIA,qBACI,MAAM,EAAe,KAAK,aAC1B,IAAK,KAAK,qBAAwC,IAAjB,EAC7B,OAEJ,MAAM,EAAmB,KAAK,oBAAoB,aAC5C,EAAc,EAAiB,OACrC,KAAK,QAAQ,aAAa,GAC1B,KAAK,QAAQ,YAAY,KAAK,cAAe,KAAK,YAAa,GAC/D,EAAY,UAAU,OAAQ,KAAK,OAAO,iBAC1C,EAAY,UAAU,aAAc,KAAK,OAAO,uBAChD,EAAY,UAAU,OAAQ,KAAK,cAAe,KAAK,eACvD,EAAY,SAAS,iBAAkB,KAAK,cAAgB,GACxD,KAAK,cACL,KAAK,QAAQ,eAAe,EAAG,EAAG,EAAG,GAGrC,KAAK,QAAQ,iBAAiB,EAAG,EAAG,EAE5C,CAIA,yBACI,MAAM,EAAe,KAAK,aAC1B,IAAK,KAAK,yBAA4C,IAAjB,EACjC,OAEJ,MAAM,EAAuB,KAAK,wBAAwB,aACpD,EAAkB,EAAqB,OAC7C,KAAK,QAAQ,aAAa,GAC1B,KAAK,QAAQ,eAAc,GAC3B,KAAK,QAAQ,aAAa,GAC1B,KAAK,QAAQ,YAAY,KAAK,cAAe,KAAK,YAAa,GAC/D,EAAgB,UAAU,OAAQ,KAAK,OAAO,iBAC9C,EAAgB,UAAU,aAAc,KAAhD,8B,kHCrL6E,KAAK,cACtE,KAAK,QAAQ,eAAe,EAAG,EAAG,EAAG,GAG9B,KAAK,QAAQ,iBAAiB,EAAG,EAAG,GAE/C,KAAK,QAAQ,eAAc,GAC3B,KAAK,QAAQ,aAAa,EAC9B,CAIA,uBAEA,CAIA,UACI,IAAI,EAAI,EAC4B,QAAnC,EAAK,KAAK,2BAAwC,IAAP,GAAyB,EAAG,UAChC,QAAvC,EAAK,KAAK,+BAA4C,IAAP,GAAyB,EAAG,SAChF,EASJ,MAAM,UAA2C,EAEzC,qBACA,OAAO,KAAK,eAChB,CAIA,eACI,MAAO,oCACX,CAMI,wCACA,OAAO,KAAK,kCAChB,CACI,sCAAkC,GAC9B,KAAK,qCAAuC,IAGhD,KAAK,mCAAqC,EACtC,GACA,KAAK,gBAAgB,UAAY,KAAK,WACtC,KAAK,gBAAgB,gCAAgC,OAAO,KAAK,+BACjE,KAAK,8BAAgC,OAGrC,KAAK,gBAAgB,WAAa,EAClC,KAAK,8BAAgC,KAAK,gBAAgB,gCAAgC,KAAI,KAC1F,KAAK,QAAQ,aAAa,EAAE,KAGxC,CAII,oBACA,OAAO,KAAK,gBAAgB,aAChC,CAII,kBACA,OAAO,KAAK,gBAAgB,WAChC,CAMA,YAAY,EAAO,GACf,MAAM,GACN,KAAK,oCAAqC,EAC1C,KAAK,gBAAkB,EACvBA,KAAKqH,gBAAkB,EAAG,OAAO,KAAK,GACtC,KAAK,WAAa,EAAG,UACrB,KAAK,8BAAgC,KACrC,KAAK,iBAAmB,KAAK,gBAAgB,gBAC7C,KAAK,gBAAgB,iBAAkB,EACvC,KAAK,gBAAgB,OAAS,IAAM,EACpC,KAAK,cAAgB,EAAG,QAAU,EAAG,SAAW,EAChDrH,KAAK,mCAAoC,CAC7C,CAKA,UACI,OAAO,MAAM,WAAa,KAAK,gBAAgB,S,iECnGG,uBAClD,KAAK,iBACF,CAIP,UACI,MAAM,UACN,KAAK,gBAAgB,gCAAgC,OAAO,KAAK,+BACjE,KAAK,8BAAgC,KACrCA,KAAK,gBAAgB,OAAS,KAAK,gBACnC,KAAK,gBAAgB,UAAY,KAAK,WACtC,KAAK,gBAAgB,gBAAkB,KAAK,gBAChD,EAIJ,ICeI,EDfA,EAAc,EAAoB,OAElC,EAAc,EAAoB,OAElC,EAAmB,EAAoB,OAQ3C,MAAM,EACE,wBACA,OAAO,KAAK,kBAChB,CACI,sBAAkB,GAClB,GAAI,KAAK,qBAAuB,IAGhCA,KAAK,mBAAqB,EACM,OAA5B,KAAK,oBAA6B,CAClC,MAAM,EAAQ,KAAK,mBAAmB,GAChC,EAAQ,KAAK,mBAAQ,GAC3B,KAAK,mBAAqB,GAC1B,IAAK,IAAI,EAAI,EAAG,EAA8B,EAA1B,KAAK,qBAA0B,EAC/C,KAAK,mBAAmB,GAAS,EAAJ,EAAQ,EAAQ,CAErD,CACJ,CACI,mBACA,OAAO,KAAK,GAChB,CACI,uBACA,OAAO,KAAK,OAChB,CACI,cACA,OAAO,KAAK,QAChB,CACI,kBACA,OAAO,KAAK,eAChB,CACA,YAAY,EAAM,EAAO,EAAO,EAAQ,EAAkB,EAAkB,EAAc,EAAG,EAAgB,EAAG,EAAkB,EAAG,EAAoB,EAAG,GAAkB,EAAO,EAAS,KAAM,GAAsB,EAAM,EAAU,GACtOA,KAAK,YAAa,EAClBA,KAAK,gBAAkB,EACvBA,KAAK,eAAiB,EACtB,KAAK,mBAAqB,EAC1B,KAAK,kBAAoB,IACzBA,KAAK,eAAiB,GACtBA,KAAK,aAAe,IACpB,KAAK,oBAAsB,IAAI,EAA2B,GAC1D,KAAK,MAAQ,EACb,KAAK,OAAS,EACd,KAAK,QAAU,EACf,KAAK,QAAU,EAAM,YACrB,KAAK,OAAS,EACd,KAAK,QAAU,EACf,KAAK,kBAAoB,EACzB,KAAK,kBAAoB,EACzB,KAAK,aAAe,EACpB,KAAK,eAAiB,EACtB,KAAK,iBAAmB,EACxB,KAAK,mBAAqB,EAC1B,KAAK,iBAAmB,EACxB,KAAK,qBAAuB,EAC5BA,KAAK,SAAW,EAChB,KAAK,yBAA2B,EAChC,KAAK,WAAkC,IAArB,GAA+C,IAArB,EAC5C,KAAK,IAAM,KACX,KAAK,SAAW,KAChB,KAAK,QAAU,KACf,KAAK,gBAAkB,KACvB,KAAK,mBAAqB,IAC9B,CACA,aAGI,GAFA,KAAK,UACLA,KAAK,sBACD,KAAK,YAAc,KAAK,SAAU,CAClC,MAAO,EAAQ,EAAgB,GAAqB,KAAK,yBAAyB,KAAK,SAAU,KAAK,iBAAkB,KAAK,mBAAoB,KAAK,gBAAiB,KAAK,MAAO,KAAK,kBACxL,KAAK,QAAU,EACf,KAAK,gBAAkB,EACvB,KAAK,mBAAqB,CAC9B,CACJ,CACA,yBACQ,KAAK,YAAc,0BACnB,KAAK,yBAA2B,EAChC,KAAK,OAAO,mBAAmB,aAAa,KAAK,mBAAoB,KAAK,SAAS,GACnF,KAAK,QAAQ,kBAAkB,KAAK,SAE5C,CACA,sBACI,KAAK,IAAM,KAAK,QAAQ,0BAA0B,CAAE,MAAO,KAAK,OAAQ,OAAQ,KAAK,SAAW,CAC5F,iBAAiB,EACjB,KAAM,KAAK,aACX,OAAQ,KAAK,eACb,aAAc,EACd,oBAAqB,KAAK,qBAC1B,uBAAuB,EACvB,QAAS,KAAK,WAElB,MAAM,EAAgB,KAAK,IAAI,QAC/B,EAAc,sBACd,KAAK,SAAW,IAAI,EAAJ,oBAChB,KAAK,SAAS,KAAO,MAAQ,KAAK,MAClC,KAAK,SAAS,SAAW,EACzB,KAAK,SAAS,MAAQ,EAA6B,EAAE,kBACrD,KAAK,SAAS,MAAQ,EAAgD,EAAE,kBACxE,KAAK,SAAS,0BAA4B,CAC9C,CACA,yBAAyB,EAAmB,EAAa,EAAe,EAAiB,EAAW,GAAkB,GAClH,MAAM,EAAS,KAAK,OAAO,YACrB,EAAa,IAAI,EAAyB,GAAG,KAAK,MAAM,KAAK,kBAAoB,GAAkB,KAAK,MAAM,KAAK,kBAAoB,IACvI,EAAwC,IAAhB,GAAqB,EAAO,UAAU,6BAC/C,IAAhB,GAAqB,EAAO,UAAU,gCACrC,EAAS,KAAK,QAAQ,0BAA0B,CAAE,MAAO,EAAW,EAAG,OAAQ,EAAW,GAAK,CACjG,iBAAiB,EACjB,KAAM,EACN,OAAQ,EACR,aAAc,EAAuB,EAAI,EACzC,qBAAqB,EACrB,uBAAuB,EACvB,QAAS,KAAK,WAEZ,EAAgB,EAAO,QAC7B,EAAc,sBACd,MAAM,EAAU,IAAI,EAA8B,EAAE,KAAM,KAAK,QAM/D,GALA,EAAQ,KAAO,aAAe,EAC9B,EAAQ,SAAW,EACnB,EAAQ,MAAQ,EAAgD,EAAE,kBAClE,EAAQ,MAAQ,EAAgD,EAAE,kBAClE,EAAQ,0BAA4B,EAChC,EAAiB,CACjB,MAAM,EAAyB,IAAI,EAA6B,EAAE,iBAAkB,6BAA8B,CAAC,aAAc,WAAY,KAAM,EAAG,KAAM,EAAG,GAAQ,EAAM,KAAM,OAAa,OAAW,OAAW,EAAW,GACjO,EAAuB,QAAU,KAAK,SACtC,EAAuB,+BAAgC,EACvD,EAAuB,kBAAI,SACA,IAAnB,KAAK,yBACL,EAAO,WAAW,iBAAkB,GAGpC,EAAO,aAAa,iBAAkB,EAAuB,aAAa,SAE9E,EAAO,OAAO,aAAc,KAAK,gBACjC,EAAO,UAAU,UAAW,EAAI,KAAK,kBAAmB,GACxD,KAAK,0BAA0B,IAEnC,EAAuB,wBAAwB,KAAI,KAC/C,EAAuB,UAAU,SAAS,IACtC,EAAG,QAAQ,MAAQ,EAAgD,EAAE,kBACrE,EAAG,QAAQ,MAAQ,EAAgD,EAAE,iBAAiB,GACxF,IAEN,KAAK,wBAAwB,GAC7B,MAAM,EAAyB,IAAI,EAA6B,EAAE,iBAAkB,6BAA8B,CAAC,aAAc,WAAY,KAAM,EAAG,KAAM,EAAG,GAAQ,EAAM,KAAM,OAAa,OAAW,OAAW,EAAW,GACjO,EAAuB,QAAU,KAAK,SACtC,EAAuB,kBAAkB,KAAK,IAC1C,EAAO,OAAO,aAAc,KAAK,gBACjC,EAAO,UAAU,UAAW,EAAG,EAAI,KAAK,mBACxC,KAAK,0BAA0B,IAEnC,EAAuB,wBAAwB,KAAI,KAC/C,EAAuB,UAAU,SAAS,IACtC,EAAG,QAAQ,MAAQ,EAAgD,EAAE,kBACrE,EAAG,QAAQ,MAAQ,EAAgD,EAAE,iBAAiB,GACxF,IAEN,KAAK,wBAAwB,GAC7B,EAAuB,WAAY,EACnC,EAAuB,WAAI,EAC3B,MAAM,EAAW,GACjB,IAAK,IAAI,EAAI,EAAG,EAA8B,EAA1B,KAAK,qBAA0B,EAC/C,EAAS,GAAS,EAAJ,EAAQ,EAAyB,EAEnD,MAAO,CAAC,EAAQ,EAAS,EAC7B,CACK,CACD,MAAM,EAAW,CAAC,gBAAiB,UAAW,4BAA6B,kBACrE,EAAyB,IAAI,EAA6B,EAAE,iBAAkB,8BAA+B,EAAU,KAAM,EAAG,KAAM,EAAG,GAAQ,EAAM,KAAM,OAAa,OAAW,OAAW,EAAW,GACjN,EAAuB,QAAU,KAAK,SACtC,EAAuB,+BAAgC,EACvD,EAAuB,kBAAkB,KAAK,IACJ,IAAlC,KAAK,yBACL,EAAO,WAAW,iBAAkB,GAGpC,EAAO,aAAa,iBAAD,wBAEvB,EAAO,OAAO,gBAAiB,KAAK,mBACpC,EAAO,UAAU,UAAW,EAAI,KAAK,kBAAmB,GACxD,EAAO,SAAS,4BAA6B,KAAK,iCAClD,EAAO,SAAS,iBAAkB,KAAK,sBACvC,KAAK,0BAA0B,IAEnC,EAAuB,wBAAwB,KAAI,KAC/C,EAAuB,UAAU,SAAS,IACtCsH,EAAG,QAAQ,MAAQ,EAAgD,EAAE,kBACrE,EAAG,QAAQ,MAAQ,EAAgD,EAAE,iBAAiB,GACxF,IAEN,KAAK,wBAAwB,GAC7B,MAAM,EAAyB,IAAI,EAA6B,EAAE,iBAAkB,8BAA+B,EAAU,KAAM,EAAG,KAAM,EAAG,GAAQ,EAAM,KAAM,OAAa,OAAW,OAAW,EAAW,GACjN,EAAuB,QAAU,KAAK,SACtC,EAAuB,kBAAkB,KAAK,IAC1C,EAAO,OAAO,gBAAiB,KAAK,mBACpC,EAAO,UAAU,UAAW,EAAG,EAAI,KAAK,mBACxC,EAAO,SAAS,4BAA6B,KAAK,iCAClD,EAAO,SAAS,iBAAkB,KAAK,sBACvC,KAAK,0BAA0B,IAEnC,EAAuB,wBAAwB,KAAI,KAC/C,EAAuB,UAAU,SAAS,IACtC,EAAG,QAAQ,MAAQ,EAAgD,EAAE,kBACrE,EAAG,QAAQ,MAAQ,EAAgD,EAAE,iBAAiB,GACxF,IAEN,KAAK,wBAAwB,GAC7B,EAAuB,WAAY,EACnC,EAAuB,WAAY,EACnC,MAAM,EAAW,GACjB,IAAK,IAAI,EAAI,EAAG,EAA8B,EAA1B,KAAK,qBAA0B,EAC/C,EAAS,GAAS,EAAJ,EAAQ,EAAyB,EAEnD,MAAO,CAAC,EAAQ,EAAS,EAC7B,CACJ,CACA,wBAAwB,GACf,EAAG,eAGR,EAAG,qBAAqB,KAAI,KAExB,EAAG,0BAA4B,EAAG,yBAA2B,GAAK,CAAC,IAEvE,EAAG,kBAAkB,KAAI,KAErB,EAAG,0BAA4B,EAAG,yBAA2B,GAAK,CAAC,IAE3E,CACA,gC,gLCnQ2D,CACW,qBACZ,OAAQ,KAAK,aAAe,EAAK,KAAK,cAC/B,CACI,UACjE,IAAI,EAAI,EAAI,EAAI,EACZ,KAAK,oBAAoB,gBACzB,KAAK,oBAAoB,gBAAgB,MAEzB,QAAnB,EAAK,KAAK,WAAwB,IAAP,GAAyB,EAAG,UACxD,KAAK,IAAM,KACc,QAAxB,EAAK,KAAK,gBAA6B,IAAP,GAAyB,EAAG,UAC7D,KAAK,SAAW,KACQ,QAAvB,EAAK,KAAK,eAA4B,IAAP,GAAyB,EAAG,UAC5D,KAAK,QAAU,KACiB,QAA/B,EAAK,KAAK,uBAAoC,IAAP,GAAyB,EAAG,UACpE,KAAK,gBAAkB,KACnB,KAAK,qBACL,KAAK,mBAAmB,GAAG,UAC3B,KAAK,mBAAmB,GAAG,WAExB,KAAK,mBAAqB,IACrC,GAcJ,SAAW,GACP,EAAoB,EAAkC,aAAI,GAAK,eAC/D,EAAoB,EAAyC,oBAAI,GAAK,sBACtE,EAAoB,EAAsC,iBAAI,GAAK,mBACnE,EAAoB,EAA6C,wBAAI,GAAK,0BAC1E,EAAoB,EAAoC,eAAI,GAAK,iBACjE,EAAoB,EAA6B,QAAI,GAAK,UAC1D,EAAoB,EAAsC,iBAAI,GAAK,kBACtE,CARD,CAQG,IAAwB,EAAsB,CAAC,IAIlD,MAAM,EAIE,yBACA,OAAO,KAAK,mBAChB,CAII,6BACA,OAAO,KAAK,uBAChB,CACI,2BAAuB,GACnB,KAAK,0BAA4B,IAGrCtH,KAAK,wBAA0B,EAC/B,KAAK,qBAAsB,EAC/B,CAII,mBACA,OAAOA,KAAK,aAChB,CACI,iBAAa,GACTA,KAAK,gBAAkB,IAG3BA,KAAKuH,qBAAsB,EAC3BvH,KAAK,cAAgB,EACzB,CAII,YACA,OAAOA,KAAK,MAChB,CACI,UAAM,GACFA,KAAK,SAAW,IAGpBA,KAAK,OAAS,EACdA,KAAKuH,qBAAsB,EAC/B,CAKI,qBACA,OAAOvH,KAAK,eAChB,CACI,mBAAe,GACXA,KAAK,kBAAoB,IAG7BA,KAAK,qBAAsB,EAC3BA,KAAK,gBAAkB,EAC3B,CAII,sBACA,OAAOA,KAAK,gBAChB,CACI,oBAAgB,GACZA,KAAK,mBAAqB,IAG9BA,KAAK,iBAAmB,EACxBA,KAAK,qBAAsB,EAC/B,CAKI,2BACA,OAAO,KAAK,qBAChB,CACI,yBAAqB,GACjB,KAAK,wBAA0B,IAGnCA,KAAK,sBAAwB,EAC7B,KAAK,qBAAsB,EAC/B,CAII,0BACA,OAAO,KAAK,oBAChB,CACI,wBAAoB,GAChB,KAAK,uBAAyB,IAGlCA,KAAK,qBAAuB,EAC5B,KAAK,qBACT,CAII,6BACA,OAAO,KAAK,uBAChB,CACI,2BAAuB,GACnB,KAAK,0BAA4B,IAGrCA,KAAK,wBAA0B,EAC/B,KAAK,qBACT,CAII,6BACA,OAAO,KAAK,uBAChB,CACI,2BAAuB,GACnB,KAAK,0BAA4B,IAGrCA,KAAK,wBAA0B,EAC/B,KAAK,qBACT,CAII,0BACA,OAAOA,KAAK,oBAChB,CACI,wBAAoB,GAChBA,KAAK,uBAAyB,IAGlCA,KAAK,qBAAuB,EAC5BA,KAAK,qBACT,CAII,0BACA,OAAOA,KAAK,oBAChB,CACI,wBAAoB,GAChBA,KAAK,uBAAyB,IAGlCA,KAAK,qBAAuB,EAC5BA,KAAK,qBAAsB,EAC/B,CAKI,+BACA,OAAO,KAAK,yBAChB,CACI,6BAAyB,GACrB,KAAK,4BAA8B,IAGvCA,KAAK,0BAA4B,EACjC,KAAK,qBAAsB,EAC/B,CAII,8BACA,OAAO,KAAK,wBAChB,CACI,4BAAwB,GACpB,KAAK,2BAA6B,IAGtCA,KAAK,yBAA2B,EAChC,KAAK,qBACT,CAII,iCACA,OAAOA,KAAK,2BAChB,CACI,+BAA2B,GACvBA,KAAK,8BAAgC,IAGzCA,KAAK,4BAA8B,EACnCA,KAAK,qBACT,CAII,wBACA,OAAO,KAAK,kBAChB,CACI,sBAAkB,GACd,KAAK,qBAAuB,IAGhC,KAAK,mBAAqB,EAC1B,KAAK,qBAAsB,EAC/B,CAKI,kBACA,OAAO,KAAK,YAChB,CACI,gBAAY,GACR,KAAK,eAAiB,IAG1B,KAAK,aAAe,EACpB,KAAK,qBAAsB,EAC3BA,KAAK,sBAAsB,gBAAgB,MAC/C,CAKI,mBACA,OAAO,KAAK,aAChB,CACI,iBAAa,GACT,KAAK,gBAAkB,IAG3B,KAAK,cAAgB,EACrBA,KAAK,qBAAsB,EAC/B,CAKI,uBACA,OAAO,KAAK,iBAChB,CACI,qBAAiB,GACb,KAAK,oBAAsB,IAG/B,KAAK,kBAAoB,EACzBA,KAAK,qBAAsB,EAC/B,CAKI,qBACA,OAAOA,KAAK,eAChB,CACI,mBAAe,GACX,KAAK,kBAAoB,IAG7B,KAAK,gBAAkB,EACvB,KAAK,qBAAsB,EAC/B,CAKI,cACA,OAAO,KAAK,QAChB,CACI,YAAQ,GACJ,KAAK,WAAa,IAGtBA,KAAK,SAAW,EAChB,KAAK,qBAAsB,EAC/B,CAII,aACA,OAAO,KAAK,OAChB,CAMA,YAAY,EAAO,GACf,KAAK,yBAA0B,EAI/BA,KAAK,WAAa,IAAI,EAAuB,GAAG,KAAO,MAAQ,MAI/DA,KAAK,QAAU,EAIfA,KAAK,mBAAqB,GAI1BA,KAAK,aAAe,EAIpBA,KAAK,cAAgB,IAIrBA,KAAK,iBAAmB,EAIxBA,KAAK,SAAW,IAAI,EAAQ,QAAQ,GAAG,YACvCA,KAAK,cAAgB,EAAW,oBAChCA,KAAK,QAAS,EACdA,KAAK,kBAAmB,EACxBA,KAAK,sBAAwB,EAC7BA,KAAK,qBAAuB,EAC5B,KAAK,wBAA0B,EAC/B,KAAK,wBAA0B,IAC/B,KAAK,qBAAuB,GAC5B,KAAK,sBAAuB,EAC5BA,KAAK,0BAA4B,EACjCA,KAAK,yBAA2B,EAChC,KAAK,4BAA8B,EACnC,KAAK,oBAAqB,EAE1BA,KAAK,sBAAwB,IAAI,EAA2B,GAC5D,KAAK,cAAe,EACpB,KAAK,cAAgB,KACrB,KAAK,kBAAoB,KACzB,KAAK,gBAAkB,KACvB,KAAK,SAAW,EAChB,KAAK,OAAS,EACd,KAAK,QAAU,EAAM,YACrB,KAAK,QAAU,QAAuC,EAAS,EAAM,aACrE,KAAK,qBAAsB,EAC3B,KAAK,gBAAkB,KACvB,KAAK,qBAAuB,IAAI,EAAwB,GACxD,KAAK,iBAAmB,IAAI,EAAuB,GAAG,IAAK,IAAK,IAAK,GACrE,KAAK,qBAAuB,IAAI,EAAuB,GAAG,EAAG,EAAG,EAAG,GACnE,KAAK,mBAAqB,KAC1B,KAAK,qBAAuB,KAC5B,KAAK,uBAAyB,KAC9BA,KAAK,mBAAqB,IAC9B,CAEA,cACI,IAAI,EAAI,EAAI,EACZ,KAAK,UACL,KAAK,qBAAsB,EAC3B,MAAM,EAA2C,QAA7B,EAAK,KAAK,qBAAkC,IAAP,EAAgB,EAAK,KAAK,QAAQ,iBACrF,EAAqC,OAAvB,KAAK,cAAyB,KAAK,MAAO,KAAK,cAAgB,KAAK,QAAQ,kBAAqB,KAAK,QAAQ,kBAAoB,KAAK,QAAQ,kBAGnK,GAFA,KAAK,mBAAqB,IAAI,EAAuB,QAAS,KAAK,OAAQ,EAAY,EAAa,EAAY,EAAa,EAAG,EAAG,EAAG,GAAG,EAAO,KAAK,SAAS,EAAM,KAAK,UACzK,KAAK,wBAAwB,KAAK,oBAC9B,KAAK,uBAAwB,CAC7B,MAAM,EAA+C,QAA/B,EAAK,KAAK,uBAAoC,IAAP,EAAgB,EAAK,KAAK,QAAQ,iBACzF,EAAyC,OAAzB,KAAK,gBACrB,KAAK,MAAO,KAAK,gBAAkB,KAAK,QAAQ,kBAAqB,KAAK,QAAQ,kBAClF,KAAK,QAAQ,kBACnB,KAAK,qBAAuB,IAAI,EAAuB,UAAW,KAAK,OAAQ,EAAc,EAAe,EAAG,EAAG,EAAG,EAAG,EAAG,GAAG,EAAM,KAAK,SAAS,EAAM,KAAK,UAC7J,KAAK,wBAAwB,KAAK,qBACtC,CACA,MAAM,EAAmD,QAAjC,EAAK,KAAK,yBAAsC,IAAP,EAAgB,EAAK,KAAK,QAAQ,iBAC7F,EAA6C,OAA3B,KAAK,kBACvB,KAAK,MAAO,KAAK,kBAAoB,KAAK,QAAQ,kBAAqB,KAAK,QAAQ,kBACpF,KAAK,QAAQ,kBACd,KAAK,qBACN,KAAK,uBAAyB,IAAI,EAAuB,YAAa,KAAK,OAAQ,EAAgB,EAAiB,EAAgB,EAAiB,EAAG,EAAG,EAAG,GAAG,EAAM,KAAK,SAAS,EAAO,KAAK,UACjM,KAAK,wBAAwB,KAAK,yBAEtC,KAAK,mCACT,CACA,mBAAmB,EAAe,MACT,OAAjB,GAAyB,IAAiB,KAAK,oBAC/C,KAAK,0BAEY,OAAjB,GAAyB,IAAiB,KAAK,wBAC/C,KAAK,6BAEb,CACA,0BACS,KAAK,qBAGV,KAAK,mBAAmB,eAAiB,KAAK,oBAC9C,KAAK,mBAAmB,kBAAoB,KAAK,uBACjD,KAAK,mBAAmB,kBAAoB,KAAK,uBACjD,KAAK,mBAAmB,eAAiB,KAAK,oBAClD,CACA,8BACS,KAAK,yBAGV,KAAK,uBAAuB,eAAiB,KAAK,wBAClDA,KAAK,uBAAuB,kBAAoB,KAAK,2BACzD,CACA,wBAAwB,GAChB,IAAiB,KAAK,uBACtB,EAAa,WAAa,IAAiB,KAAK,mBAAqB,KAAK,gBAAkB,KAAK,oBACjG,EAAa,gBAAK,IAAU,KAAK,mBAAqB,KAAK,qBAAuB,KAAK,0BAE3F,KAAK,mBAAmB,GACxB,EAAa,YACjB,CACA,oCACI,IAAI,EACJ,MAAM,EAAS,KAAK,OAAO,YACrB,EAAe,CACjB,aACA,mBACA,sBACA,YACA,WACA,YACA,UACA,qBACA,eACA,iBAEE,EAAe,CAAC,gBAChB,EAAU,GAEhB,GADA,KAAK,SAAQ,IACR,KAAK,QACN,OAEJ,MAAM,EAAU,KAAK,mBAAmB,WAAa,KAAK,mBAAmB,YAAc,KAAK,mBAAmB,QAC7G,EAAY,IAAI,EAAyB,GAAG,EAAI,EAAQ,UAAU,MAAO,EAAI,EAAQ,UAAU,QAIrG,GAHI,KAAK,OAAO,sBACZ,EAAQ,KAAK,8BAEY,OAAzBA,KAAK,gBAA0B,EACgB,QAA/B,EAAK,KAAK,uBAAoC,IAAP,EAAgB,EAAK,KAAK,OAAO,sBAEpF,EAAa,KAAK,qBAClB,EAAQ,KAAK,sCAErB,CACI,KAAK,sBACL,EAAa,KAAK,kBAClB,EAAQ,KAAK,0CAGb,EAAa,KAAK,gBAElB,KAAK,eACL,EAAa,KAAK,mBAClB,EAAQ,KAAK,oCAEb,KAAK,oBACL,EAAa,KAAK,aAClB,EAAa,KAAK,kBAClB,EAAQ,KAAK,4CAGb,EAAa,KAAK,oBAClB,EAAa,KAAK,qBAElB,KAAK,SACL,EAAQ,KAAK,gCACT,KAAK,gBAAkB,EAAoB,QAC3C,EAAQ,KAAK,2CAER,KAAK,gBAAkB,EAAoB,iBAChD,EAAQ,KAAK,kDAGb,EAAQ,KAAK,wCACb,EAAa,KAAK,gBACd,KAAK,gBAAkB,EAAoB,cAAgB,KAAK,gBAAkB,EAAoB,qBACtG,EAAQ,KAAK,wCAIzB,KAAK,mBAAqB,IAAI,EAA6B,EAAE,iBAAkB,uBAAwB,EAAc,EAAc,EAAG,KAAM,EAAG,GAAQ,EAAO,KAAM,OAAG,OAAW,GAAW,OAAM,GACnM,KAAK,mBAAmB,aAAa,EAAQ,KAAK,OAClD,KAAK,mBAAmB,QAAU,KAAK,SACvC,KAAK,mBAAmB,kBAAkB,KAAK,IAC3C,IAAI,EAAI,EAAI,EAAI,EAAI,EAAI,EAAI,EAAI,EAAI,EAAI,EAAI,EAAI,EAAI,EAAI,EAAI,EAAI,EAAI,EAAI,EAAI,EAAI,EAAI,EAAI,EAAI,EAyD5F,GAxDA,KAAK,qBAAqB,SAAS,KAAK,OAAO,uBAC/C,KAAK,qBAAqB,SACtB,EAAO,UACP,EAAO,kBAAkB,wBAAyB,KAAK,mBAAmB,aAAa,SAEtF,KAAK,mBAAmB,YAOzB,EAAO,WAAW,eAAgB,KAAK,mBAAmB,aACtD,EAAO,UACP,EAAO,kBAAkB,sBAA0I,QAAlH,EAAoD,QAA9C,EAAK,KAAK,mBAAmB,mBAAgC,IAAP,OAAgB,EAAS,EAAG,4BAAyC,IAAP,EAAgB,EAAK,QARpM,EAAO,WAAW,eAAgB,KAAK,mBAAmB,SACtD,EAAO,UACP,EAAO,kBAAkB,sBAAsI,QAA9G,EAAgD,QAA1C,EAAK,KAAK,mBAAmB,eAA4B,IAAP,OAAgB,EAAS,EAAG,4BAAyC,IAAP,EAAgB,EAAK,OAShM,KAAK,qBACA,KAAK,qBAAqB,YAO3B,EAAO,WAAW,iBAAkB,KAAK,qBAAqB,aAC1D,EAAO,UACP,EAAO,kBAAkB,wBAA8I,QAApH,EAAsD,QAAhD,EAAK,KAAK,qBAAqB,mBAAgC,IAAP,OAAgB,EAAS,EAAG,4BAAyC,IAAP,EAAgB,EAAK,QARxM,EAAO,WAAW,iBAAkB,KAAK,qBAAqB,SAC1D,EAAO,UACP,EAAO,kBAAkB,wBAA0I,QAAhH,EAAkD,QAA5C,EAAK,KAAK,qBAAqB,eAA4B,IAAP,OAAgB,EAAS,EAAG,4BAAyC,IAAP,EAAgB,EAAK,OAWxM,EAAO,UAAU,eAAgB,KAAK,YAEtC,KAAK,oBACL,EAAO,SAAS,YAAa,KAAK,kBAClC,EAAO,aAAa,iBAAkB,KAAK,iBACvC,EAAO,UACP,EAAO,kBAAkB,wBAAyD,QAA/B,EAAK,KAAK,uBAAoC,IAAP,EAAgB,EAAK,QAI9G,KAAK,uBAAuB,YAO7B,EAAO,WAAW,mBAAoB,KAAK,uBAAuB,aAC9D,EAAO,UACP,EAAO,kBAAkB,0BAAkJ,QAAtH,EAAwD,QAAlD,EAAK,KAAK,uBAAuB,mBAAgC,IAAP,OAAgB,EAAS,EAAG,4BAAyC,IAAP,EAAgB,EAAK,QAR5M,EAAO,WAAW,mBAAoB,KAAK,uBAAuB,SAC9D,EAAO,UACP,EAAO,kBAAkB,0BAA8I,QAAlH,EAAoD,QAA9C,EAAK,KAAK,uBAAuB,eAA4B,IAAP,OAAgB,EAAS,EAAG,4BAAyC,IAAP,EAAgB,EAAK,OAS5M,EAAO,SAAS,mBAAoB,KAAK,mBAEhB,OAAzB,KAAK,gBAA0B,CAC/B,MAAM,EAAyC,QAA/B,EAAK,KAAK,uBAAoC,IAAP,EAAgB,EAAK,KAAK,OAAO,mBACpF,IACA,EAAO,WAAW,oBAAqB,GACnC,EAAO,UACP,EAAO,kBAAkB,2BAAmH,QAAtF,EAAK,aAAuC,EAAS,EAAO,4BAAyC,IAAP,EAAgB,EAAK,MAGrL,CAWA,GAVA,EAAO,UAAU,aAAc,KAAK,OAAO,iBAC3C,EAAO,UAAU,sBAAuB,KAAK,sBAC7C,EAAO,UAAU,mBAAoB,KAAK,OAAO,uBACjD,EAAO,WAAW,YAAa,GAC/B,EAAO,SAAS,UAAW,KAAK,SAChC,EAAO,SAAS,qBAAsB,KAAK,oBAC3C,EAAO,SAAS,eAAgB,KAAK,cACrC,EAAO,SAAS,gBAAiB,KAAK,eACtC,EAAO,WAAW,WAAY,KAAK,UACnC,EAAO,SAAS,YAAa,KAAK,QAAQ,MACtC,KAAK,OAAQ,CACb,IAAI,EAAU,KACd,OAAQ,KAAK,eACT,KAAK,EAAoB,aACrB,EAAU,KAAK,mBAAmB,QAClC,MACJ,KAAK,EAAoB,oBACrB,EAAU,KAAK,mBAAmB,WAAa,KAAK,mBAAmB,YAAc,KAAK,mBAAmB,QAC7G,MACJ,KAAK,EAAoB,iBACrB,EAAwG,QAA7F,EAA4C,QAAtC,EAAK,KAAK,8BAA2C,IAAP,OAAgB,EAAS,EAAG,eAA4B,IAAP,EAAgB,EAAK,KACrI,MACJ,KAAK,EAAoB,wBACrB,GAAkD,QAAtCwH,EAAK,KAAK,8BAA2C,IAAP,OAAgB,EAAS,EAAG,YAAgH,QAAjG,EAA4C,QAAtC,EAAK,KAAK,8BAA2C,IAAP,OAAgB,EAAS,EAAG,mBAAgC,IAAP,EAAgB,EAAK,KAAqG,QAA7F,EAA4C,QAAtC,EAAK,KAAK,8BAA2C,IAAP,OAAgB,EAAS,EAAG,eAA4B,IAAP,EAAgB,EAAK,KACrW,MACJ,KAAK,EAAoB,eACjB,KAAK,uBACL,EAAU,KAAK,qBAAqB,SAI5C,KAAK,gBAAkB,EAAoB,UAC3C,EAAO,WAAW,eAAgB,GAC9B,EAAO,UACP,EAAO,kBAAkB,sBAAiH,QAAzF,EAAK,aAAyC,EAAS,EAAQ,4BAAyC,IAAP,EAAgB,EAAK,MAGnL,IAER,CAEA,gBACI,IAAI,EAAI,EAAI,GAC2B,QAAlC,EAAK,KAAK,0BAAuC,IAAP,OAAgB,EAAS,EAAG,gBACvE,KAAK,QAAQ,gBAAgB,KAAK,mBAAmB,cACrD,KAAK,QAAQ,MAAM,KAAK,kBAAkB,GAAM,GAAM,GACtDxH,KAAKiH,QAAQ,kBAAkB,KAAK,mBAAmB,gBAElB,QAApC,EAAK,KAAK,4BAAyC,IAAP,OAAgB,EAAS,EAAG,gBACzEjH,KAAKiH,QAAQ,gBAAgB,KAAK,qBAAqBQ,cACvD,KAAK,QAAQ,MAAM,KAAK,sBAAsB,GAAM,GAAM,GAC1D,KAAK,QAAQ,kBAAkB,KAAK,qBAAqB,gBAElB,QAAtC,EAAK,KAAK,8BAA2C,IAAP,OAAgB,EAAS,EAAG,gBAC3E,KAAK,QAAQ,gBAAgB,KAAK,uBAAuB,cAEzDzH,KAAKiH,QAAQ,MAAM,KAAK,sBAAsB,GAAM,GAAO,GAC3D,KAAK,QAAQ,kBAAkB,KAAK,uBAAuB,cAEnE,CAEA,QAAQS,GACJ,IAAI,EAAI,EAAI,EAAI,EAAI,EAAI,EACxB,GAAI1H,KAAK,sBAAwB,EAAY,UACzC,OAEJ,MAAM,EAAsB,KAAK,QAAQ,qBACzC,KAAK,QAAQ,UAAS,OAAO,OAAW,OAAW,GAAW,GAC9D,KAAK,QAAQ,gBAAe,GAC5B,KAAK,QAAQ,eAAc,GAC3B,KAAK,QAAQ,aAAa,IAEa,QAAlC,EAAK,KAAK,0BAAuC,IAAP,OAAgB,EAAS,EAAG,gBACvE,KAAK,QAAQ,gBAAgB,KAAK,mBAAmB,cACrD,EAAY,qBACZ,KAAK,QAAQ,2BACb,KAAK,QAAQ,kBAAkB,KAAK,mBAAmB,gBAGlB,QAApC,EAAK,KAAK,4BAAyC,IAAP,OAAgB,EAAS,EAAG,gBACzE,KAAK,QAAQ,gBAAgB,KAAK,qBAAqB,cACvD,EAAY,uBACZ,KAAK,QAAQ,2BACbA,KAAK,QAAQ,kBAAkB,KAAK,qBAAqB,gBAGlB,QAAtC,EAAK,KAAK,8BAA2C,IAAP,OAAgB,EAAS,EAAG,gBAC3EA,KAAK,QAAQ,gBAAgB,KAAK,uBAAuB,cACzD,EAAY,yBACZ,KAAK,QAAQ,2BACb,KAAK,QAAQ,kBAAkB,KAAK,uBAAuB,eAG5B,QAAlC,EAAK,KAAK,0BAAuC,IAAP,GAAyB,EAAG,yBAClC,QAApC,EAAK,KAAK,4BAAyC,IAAP,GAAyB,EAAG,yBAClC,QAAtC,EAAK,KAAK,8BAAnB,IAAuD,GAAvD,2B,GCprBmE,KAAK,QAAQ,gBAAgB,EAE1B,CAKlE,QAAQ,GAAoB,GACjB,IAAI,EAAI,EAAI,EAAI,EAClB,IACkC,QAAlC,EAAK,KAAK,0BAAuC,IAAP,GAAyB,EAAG,UACvE,KAAK,mBAAqB,KACW,QAApC,EAAK,KAAK,4BAAyC,IAAP,GAAyB,EAAG,UACzE,KAAK,qBAAuB,KACW,QAAtC,EAAK,KAAK,8BAA2C,IAAP,GAAyB,EAAG,UAC3E,KAAK,uBAAyB,MAE9B,KAAK,oBAAsB,KAAK,SAChC,KAAK,QAAQ,kBAAkB,KAAK,oBAEL,QAAlC,EAAK,KAAK,0BAAuC,IAAP,GAAyB,EAAG,UACvE,KAAK,mBAAqB,KAC1B,KAAK,qBAAsB,CAC/B,EAYJ,MAAM,UAA4C,EAI9C,eACI,MAAO,qCACX,CAII,oBACA,OAAO,KAAK,cAChB,CAOA,YAAY,EAAO,EAAS,GACxB,MAAM,GACN,KAAK,cAAgB,EACrBA,KAAK2H,sBAAwB,KAC7B,KAAK,eAAiB,CAAC,EACvB,KAAK,WAAW,EACpB,CAKA,WAAW,GACP,IAAK,MAAM,KAAQ,EAAS,CACxB,IAAI,EACA,GAAY,EAChB,OAAQ,GACJ,IAAK,WACD,EAAS,EACT,MACJ,IAAK,SACD,GAAY,EAGpB,KAAK,eAAe,GAAQ,IAAI,EAAyB,EAAE,KAAK,QAAS,EAAQ,GAAO,GAAM,GAAM,EAAO,EAAQ,EACvH,CACJ,CACA,iBACI,MAAM,iBAGN,KAAK,sBAAwB,IAAI,EAAkC,EAAE,CACjE,OAAQ,KAAK,QACb,gBAAgB,EAChB,aAAc,gCACd,eAAgB,gCAChB,eANmB,CAAC,WAAY,SAAU,SAO1C,aARiB,CAAC,OAAQ,aAAc,QASxC,aAAc,IAEtB,CAKA,UACI,IAAI,EAAI,EAIR,OAHK,KAAK,eAAuB,SAC7B,KAAK,eAAuB,OAAI,IAAI,EAAyB,EAAE,KAAK,QAAS,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,UAAU,GAAO,EAAO,IAE5H,MAAM,WAAoH,QAArG,EAA2C,QAArC,EAAK,KAAK,6BAA0C,IAAP,OAAgB,EAAS,EAAG,OAAO,iBAA8B,IAAP,GAAgB,CAC7J,CAKI,mBACA,OAAO,KAAK,aAChB,CAKA,gBAAgB,GACZ,KAAK,cAAgB,CACzB,CAIA,uBACI,MAAM,EAAe,KAAK,aAC1B,IAAK,KAAK,uBAA0C,IAAjB,EAC/B,OAEJ,MAAM,EAAqB,KAAK,sBAAsB,aAChD,EAAgB,EAAmB,OACzC,KAAK,QAAQ,aAAa,G,uMChIoD,EAAc,UAAU,OAAQ,KAAK,cAAe,KAAK,eAE5H,KAAK,cACZ,KAAK,QAAQ,eAAe,EAAG,EAAG,EAAG,GAGrC,KAAK,QAAQ,iBAAiB,EAAG,EAAG,EAE5C,CAIA,UACI,IAAI,EACJ,MAAM,UACgC,QAArC,EAAK,KAAK,6BAA0C,IAAP,GAAyB,EAAG,UAC1E,IAAK,MAAM,KAAQ,KAAK,eACpB,KAAK,eAAe,GAAM,UAE9B3H,KAAK,eAAiB,CAAC,CAC3B,EAIJ,IAAI,EAAuB,EAAoB,OAK/C,MAAM,E,qZC9ByC,OAAO,KAAK,sBAAsB,KAAK,EAAQ,KAAK,gBAC7B,CAC2B,UACR,KAAK,gBAAgB,UACP,KAAK,sBAAsB,SACzC,EAImB,EAAoB,OAEpB,EAAoB,OAErB,EAAoB,OAEzG,EAAsB,MAED,EAAoB,OAElB,EAAoB,OAEtB,EAAoB,OAErB,EAAoB,OAE9D,SAuCA,SAAS,EAAuB,GAC5B,QAAS,EAAI,cACjB,CAxBA,OAAO,eAAe,EAA2B,EAAE,UAAW,gBAAiB,CACpE,IAAK,WACR,OAAO,KAAK,cAChB,EACA,IAAK,SAAU,GACX,KAAK,eAAiB,CAC1B,EACA,YAAY,EACZ,cAAc,IAElB,EAAoB,2CAChB,OAAIA,KAAK,iBAGT,KAAK,eAAiB,IAAI,EAAc,OAF7B,KAAK,cAIpB,EACA,EAAgD,EAAE,UAAU,qBAAU,WAClE,IAAI,EAC2B,QAA9B,EAAK,KAAK,sBAAmC,IAAP,GAAyB,EAAG,UACnE,KAAK,eAAiB,IAC1B,EAOA,MAAM,EAKF,YAAY,GAIR,KAAK,KAAO,EAA+D,EAAE,mBAC7E,KAAK,MAAQ,CACjB,CAIA,WACIA,KAAKW,MAAM,sCAAsC,aAAa,EAA+F,EAAE,mDAAoD,KAAM,KAAK,kCAC9N,KAAK,MAAM,sBAAsB,aAAa,EAA+E,EAAE,mCAAoC,KAAM,KAAK,iBAClL,CACA,iCAAiC,GAC7B,IAAI,EACgC,QAAnC,EAAK,KAAK,MAAM,qBAAkC,IAAP,GAAyB,EAAG,mBAC5E,CACO,iBAAiB,GACpB,IAAI,EACgC,QAAnC,EAAK,KAAK,MAAM,qBAAkC,IAAP,GAAyB,EAAG,QAAQ,EACpF,CAKA,UACQ,KAAK,MAAM,iBAEX,KAAK,MAAM,uBAEX,KAAK,MAAM,sBAEnB,CAIA,UACI,KAAK,MAAM,sBACf,EAMJ,MAAM,EAEF,qCAAqC,GACjC,IAAI,EAAY,EAAM,cAAc,EAA+D,EAAE,oBAChG,IACD,EAAY,IAAI,EAA4B,GAC5C,EAAM,cAAc,GAE5B,CAKA,YAAY,GACR,KAAK,OAAS,EACd,KAAK,QAAU,EAAM,YACrB,KAAK,wBAA0B,KAC/B,KAAK,cAAgB,GACrB,KAAK,gBAAkB,GACvB,KAAK,SAAW,IAAI,IACpB,EAAc,8BAA8B,KAAK,QACjD,KAAK,wBAA0B,KAAK,QAAQ,mBAAmB,KAAI,KAC/D,KAAK,aAAa,GAE1B,CAKA,WACI,KAAK,wBACL,KAAK,aACT,CAMA,kCAAkC,GAC9B,MAAM,EAAQ,KAAK,wBAAwB,GAC3C,OAAkB,IAAX,EAAe,KAAK,cAAc,GAAS,IACtD,CAUA,kBAAkB,EAAI,EAAwB,EAAgB,GAC1D,MAAM,EAAS,IAAI,EAAmC,KAAK,OAAQ,GACnE,EAAO,sBAAsB,IAAI,KAAK,iCAAiC,KAAK,OACvE,IACD,EAAiB,IAAI,EAA6B,KAAK,OAAQ,GAC/D,KAAK,gBAAgB,KAAK,IAEzB,EAAe,sBAAsB,gBACtC,EAAe,sBAAsB,IAAI,KAAK,+BAA+B,KAAK,YAEvD,IAA3B,IACA,EAAe,uBAAyB,GAE5C,MAAM,EAAe,CAAE,SAAQ,kBAI/B,OAHA,KAAK,cAAc,KAAK,GACxBX,KAAK,wBACLA,KAAK,mCACE,CACX,CAUA,mBAAmB,EAAS,EAAc,EAAwB,EAAgB,GAC9E,MAAM,EAAS,IAAI,EAAoC,KAAK,OAAQ,EAAS,GAC7E,EAAO,sBAAsB,IAAI,KAAK,iCAAiC,KAAK,OACvE,IACD,EAAiB,IAAI,EAA6B,KAAK,OAAQ,GAC/D,KAAK,gBAAgB,KAAK,IAEzB,EAAe,sBAAsB,gBACtC,EAAe,sBAAsB,IAAI,KAAK,+BAA+B,KAAK,YAEvD,IAA3B,IACA,EAAe,uBAAyB,GAE5C,MAAM,EAAe,CAAE,SAAQ,kBAI/B,OAHAA,KAAK4H,cAAc,KAAK,GACxB,KAAK,wBACL,KAAK,mCACE,CACX,CAOA,mBAAmB,EAAc,GAA6B,GAC1D,MAAM,EAAQ,KAAK,cAAc,QAAQ,GACzC,OAAe,IAAX,IAGJ,EAAa,OAAO,UACpB,KAAK,cAAc,OAAO,EAAO,GAC7B,GAA8B,KAAK,+BACnC,KAAK,cAGL5H,KAAK,oCAEF,EACX,CACA,wBACI,KAAK,cAAc,MAAK,CAAC,EAAG,IACjB,EAAE,OAAO,SAAW,EAAE,OAAO,UAAY,EAAI,EAAE,OAAO,SAAW,EAAE,OAAO,SAAW,EAAI,GAExG,CACA,+BACI,MAAM,EAAU,CAAC,EACjB,IAAK,IAAI,EAAI,EAAG,EAAI,KAAK,cAAc,SAAU,EAAG,CAChD,MAAM,EAAiB,KAAK,cAAc,GAAG,eAC7C,EAAQ,KAAK,gBAAgB,QAAQ,KAAmB,CAC5D,CACA,IAAI,GAAU,EACd,MAAM,EAAU,GAChB,IAAK,IAAI,EAAI,EAAG,EAAI,KAAK,gBAAgB,SAAU,EAC1C,EAAQ,GAKT,EAAQ,KAAK,KAAK,gBAAgB,KAJlC,KAAK,gBAAgB,GAAG,UACxB,GAAU,GAUlB,OAJI,IACA,KAAK,gBAAgB,OAAS,EAC9B,KAAK,gBAAgB,QAAQ,IAE1B,CACX,CACA,wBAAwB,GACpB,IAAK,IAAI,EAAI,EAAG,EAAI,KAAK,cAAc,SAAU,EAAG,CAChD,MAAM,EAAM,KAAK,cAAc,GAAG,OAClC,GAAI,EAAuB,IAAQ,EAAI,iBAAmB,EACtD,OAAO,CAEf,CACA,OAAQ,CACZ,CACA,cACI,IAAK,IAAI,EAAI,EAAG,EAAI,KAAK,gBAAgB,SAAU,EAC/C,KAAK,gBAAgB,GAAG,UAE5B,MAAM,EAAU,IAAI,IACpB,IAAK,IAAI,EAAI,EAAG,EAAI,KAAK,gBAAgB,SAAU,EAAG,CAClD,MAAM,EAAiB,KAAK,gBAAgB,GAE5C,GADA,EAAe,cACX,EAAe,QAAU,EAAe,mBAAoB,CAC5D,IAAI,EAAO,EAAQ,IAAI,EAAe,QACjC,IACD,EAAO,CAAC,GAAI,CAAC,GACb,EAAQ,IAAI,EAAe,OAAQ,IAEvC,EAAK,GAAG,KAAK,GACb,EAAe,OAAO,kBAAkB,EAAe,mBAAoB,EAC/E,CACJ,CACA,IAAI,EAAW,EAAQ,OACvB,IAAK,IAAI,EAAM,EAAS,QAAqB,IAAb,EAAI,KAAe,EAAM,EAAS,OAAQ,CACtE,MAAM,EAAS,EAAI,MACb,EAAO,EAAQ,IAAI,GACnB,EAAmB,EAAO,uBAChC,IAAK,EACD,SAEJ,MAAO,EAAiB,GAAqB,EAC7C,EAAiB,wBAAwB,KAAI,KACzC,IAAI,EACC,EAAiB,aAAa,qBAC/B,EAAiB,aAAa,0BAA0B,GAAG,EAAM,KAAK,QAAQ,gBAAiB,EAAgB,GAAG,SAEtH,IAAK,MAAM,KAAkB,EAAiB,CAC1C,MAAM,EAA+D,QAAhD,EAAK,EAAe,8BAA2C,IAAP,OAAgB,EAAS,EAAG,aACnG,EAAmB,aAAiD,EAAS,EAAY,QAC/F,GAAI,GAAe,EAAkB,CACjC,MAAM,EAAM,EAAiB,MAAQ,IAAM,EAAiB,OAC5D,IAAI,EAAmB,EAAkB,GACpC,IACD,EAAmB,EAAkB,GAAO,IAAI,EAA+B,KAAK,QAAS,EAAiB,MAAO,EAAiB,SAE1I,EAAiB,eAAe,YAAY,EAChD,CACJ,IAER,CAEA,EAAW,KAAK,SAAS,OACzB,IAAK,IAAI,EAAM,EAAS,QAAqB,IAAb,EAAI,KAAe,EAAM,EAAS,OAAQ,CACtE,MAAM,EAAS,EAAI,MAEb,EADO,KAAK,SAAS,IAAI,GACA,GACzB,EAAQ,EAAQ,IAAI,GAC1B,GAAK,EAMD,IAAK,MAAM,KAAO,EACT,EAAM,GAAG,IACV,EAAkB,GAAK,eAP/B,IAAK,MAAM,KAAO,EACd,EAAkB,GAAK,SAUnC,CACA,KAAK,SAAS,QACd,KAAK,SAAW,EAChB,KAAK,kCACT,CACA,mCACI,MAAM,EAAgB,IAAI,IAC1B,IAAK,IAAI,EAAI,EAAG,EAAI,KAAK,cAAc,SAAU,EAAG,CAChD,MAAM,EAAkB,KAAK,cAAc,GAC3C,IAAI,EAAU,EAAc,IAAI,EAAgB,qBAChC,IAAZ,IACA,EAAU,GAEd,EAAc,IAAI,EAAgB,eAAgB,KAAK,IAAI,EAAS,EAAgB,OAAO,cAC/F,CACA,EAAc,SAAQ,CAAC,EAAc,KAC7B,EAAe,qBACf,EAAe,mBAAmB,aAAe,EACrD,GAER,CACA,iCACI,IAAK,MAAM,KAAmB,KAAK,cAC/B,EAAgB,OAAO,YAAc,EAAgB,eAAe,WAE5E,CAEA,oBACI,IAAK,MAAM,KAAY,KAAK,gBACxB,GAAI,EAAS,mBAET,YADA,KAAK,aAIjB,CAEA,QAAQ,GACJ,IAAI,EACJ,IAAK,IAAI0B,EAAI,EAAGA,EAAI1B,KAAK,gBAAgB,SAAU,EAC1C,GAAa,KAAK,gBAAgB,GAAG,SAAW,GACjD,KAAK,gBAAgB,GAAG,gBAGhC,MAAM,EAAW,KAAK,SAAS,OAC/B,IAAK,IAAI,EAAM,EAAS,QAAqB,IAAb,EAAI,KAAe,EAAM,EAAS,OAAQ,CACtE,MAAM,EAAS,EAAI,MACb,EAAO,KAAK,SAAS,IAAI,GAC/B,GAAI,GAAa,IAAW,EACxB,SAEJ,MAAM,EAAmB,EAAO,uBAChC,IAAK,EACD,SAEJ,MAAM,EAA2D,QAAxC,EAAK,EAAiB,oBAAiC,IAAP,OAAgB,EAAS,EAAG,oBACrG,GAAI,EAAiB,CACjB,MAAO,EAAiB,GAAqB,EAC7C,IAAK,MAAM,KAAkB,EACzB,EAAe,gBAAkB,EAErC,IAAK,MAAM,KAAO,EACd,EAAkB,GAAK,KAAK,EAEpC,CACJ,CACA,IAAK,IAAI,EAAI,EAAG,EAAI,KAAK,cAAc,SAAU,EAAG,CAChD,MAAM,EAAkB,KAAK,cAAc,GACtC,GAAa,EAAgB,eAAe,SAAW,GACxD,EAAgB,eAAhC,iBCzZ2C,CACG,CAI1C,U,qECLI,KAAK,wBAA0B,KACU,IAAK,IAAI,EAAI,EAAG,EAAI,KAAK,cAAc,SAAU,EACnD,KAAK,cAAc,GAAG,OAAO,UAE1B,IAAK,IAAI,EAAI,EAAG,EAAI,KAAK,gBAAgB,SAAU,EACzC,KAAK,gBAAgB,GAAG,UAEhC,KAAK,SAAS,SAAS,IACL,MAAM,EAAoB,EAAK,GACpD,IAAK,MAAM,KAAO,EACA,EAAkB,GAAK,SAChC,IAEd,KAAK,cAAgB,GACnB,KAAK,gBAAkB,GACnB,KAAK,SAAS,OACnB,ECGtC,EAED,I,mCCrBwE,cAItE,KAAK,SAAU,EAIf,KAAK,KAAO,aAIZ,KAAK,iBAAmB,CAAC,EAC7B,EAIG,EAED,MACA,CAAE,EAAqC,EAAqB,KAE7C,EAAoB,EAAE,EAAqB,CACzC,EAAK,IAAM,IAEb,IAAI,EAAmD,EAAoB,MACvE,EAAqD,EAAoB,OAUlG,MAAM,EAKE,wBAAoB,GAEhB,KAAK,qBADL,GAI4B,EAAe,mBAE/C,KAAK,cAAgB,KAAK,mBAC9B,CAKI,2BAAuB,GAEnB,KAAK,wBADL,GAIwB,qBAE5BA,KAAK,iBAAmB,KAAK,sBACjC,CAKI,6BAAyB,GAErB,KAAK,0BADL,GAIiC,EAAe,8BAEpD,KAAK,mBAAqB,KAAK,wBACnC,CASA,YAAY,EAAO,EAAO,EAAsB,KAAM,EAAyB,KAAM,EAA2B,MAC5G,KAAK,MAAQ,EACb,KAAK,iBAAmB,IAAI,EAAmE,EAAE,KACjG,KAAK,sBAAwB,IAAI,EAAmE,EAAE,KACtG,KAAK,oBAAsB,IAAI,EAAmE,EAAE,KACpG,KAAK,oBAAsB,IAAI,EAAmE,EAAE,KACpG,KAAK,iBAAmB,IAAI,EAAmE,EAAE,KACjG,KAAK,gBAAkB,IAAI,EAAmE,EAAE,KAEhG,KAAK,QAAS,EAEd,KAAK,gBAAkB,IAAI,EAA8E,EAAE,IAC3G,KAAK,OAAS,EACd,KAAK,oBAAsB,EAC3B,KAAK,uBAAyB,EAC9B,KAAK,yBAA2B,CACpC,CASA,OAAO,EAAsB,EAAe,EAAiB,GACzD,GAAI,EAEA,YADA,EAAqB,KAAK,iBAAkB,KAAK,oBAAqB,KAAK,sBAAuB,KAAK,qBAG3G,MAAM,EAAS,KAAK,OAAO,YAEa,IAApCA,KAAK,oBAAoB,SACzB0G,EAAO,eAAc,GACrB,KAAK,iBAAiB,KAAK,qBAC3B,EAAO,eAAc,IAGY,IAAjC,KAAK,iBAAiB,QACtB,KAAK,cAAc,KAAK,kBAGY,IAApC,KAAK,oBAAoB,QACzB,KAAK,iBAAiB,KAAK,qBAE/B,MAAM,EAAe,EAAO,mBAc5B,GAbA,EAAO,kBAAiB,GAEpB,GACA1G,KAAK,iBAGL,GACA,KAAK,iBAAiB,GAEtB,KAAK,8BACL,KAAK,+BAGiC,IAAtC,KAAK,sBAAsB,QAAgB,KAAK,OAAO,gCAAiC,CAExF,GADA,EAAO,iBAAiB,GACpB,KAAK,OAAO,gCAAiC,CAC7C,MAAM,EAAiB,KAAK,OAAO,qBAAqB,OAAO,KAAK,uBAChE,EAAe,QAEf,KAAK,mBAAmB,EAEhC,MAEI,KAAK,mBAAmB,KAAK,uBAEjC,EAAO,aAAa,EACxB,CAIA,GAFA,EAAO,kBAAiB,GAEpB,KAAK,gBAAgB,OAAQ,CAC7B,IAAK,IAAI,EAAqB,EAAG,EAAqB,KAAK,gBAAgB,OAAQ,IAC/E,KAAK,gBAAgB,KAAK,GAAoB,SAElD,EAAO,aAAa,EACxB,CAEA,EAAO,iBAAiB,EAC5B,CAKA,oBAAoB,GAChB,OAAO,EAAe,cAAc,EAAW,KAAK,qBAAsB,KAAK,OAAO,cAAc,EACxG,CAKA,uBAAuB,GACnB,OAAO,EAAe,cAAc,EAAW,KAAK,wBAAyB,KAAK,OAAO,cAAc,EAC3G,CAKA,yBAAyB,GACrB,OAAO,EAAe,cAAc,EAAW,KAAK,0BAA2B,KAAK,OAAO,cAAc,EAC7G,CAQA,qBAAqB,EAAW,EAAe,EAAQ,GACnD,IACI,EADA,EAAW,EAEf,MAAM,EAAiB,EAAS,EAAO,eAAiB,EAAe,YACvE,GAAI,EACA,KAAO,EAAW,EAAU,OAAQ,IAChC,EAAU,EAAU,KAAK,GACzB,EAAQ,YAAc,EAAQ,UAAU,WACxC,EAAQ,kBAAoB,EAA2E,EAAE,SAAS,EAAQ,kBAAkB,eAAe,YAAa,GAGhL,MAAM,EAAc,EAAU,SAAW,EAAU,KAAK,OAAS,EAAU,KAAO,EAAU,KAAK,MAAM,EAAG,EAAU,QAChH,GACA,EAAY,KAAK,GAErB,MAAM,EAAQ,EAAY,GAAG,UAAU,WACvC,IAAK,EAAW,EAAG,EAAW,EAAY,OAAQ,IAE9C,GADA,EAAU,EAAY,IAClB,EAAM,oCAAuC,EAAQ,YAAY,EAAM,gBAA3E,CAGA,GAAI,EAAa,CACb,MAAM,EAAW,EAAQ,cACzB,GAAI,GAAY,EAAS,iBAAkB,CACvC,MAAM,EAAS,EAAS,WAAW,YACnC,EAAO,eAAc,GACrB,EAAO,aAAa,GACpB,EAAQ,QAAO,GACf,EAAO,eAAc,EACzB,CACJ,CACA,EAAQ,OAAO,EAXf,CAaR,CAUA,qCAAqC,EAAG,GAEpC,OAAI,EAAE,YAAc,EAAE,YACX,EAEP,EAAE,YAAc,EAAE,aACV,EAGL,EAAe,uBAAuB,EAAG,EACpD,CAUA,8BAA8B,EAAG,GAE7B,OAAI,EAAE,kBAAoB,EAAE,kBACjB,EAEP,EAAE,kBAAoB,EAAE,mBAChB,EAEL,CACX,CAUA,8BAA8B,EAAG,GAE7B,OAAI,EAAE,kBAAoB,EAAE,mBAChB,EAER,EAAE,kBAAoB,EAAE,kBACjB,EAEJ,CACX,CASA,0BAA0B,EAAG,GACzB,MAAM,EAAQ,EAAE,UACV,EAAQ,EAAE,UAChB,OAAI,EAAM,UAAY,EAAM,SACjB,EAAM,SAAS,SAAW,EAAM,SAAS,SAE7C,EAAM,SAAW,EAAM,QAClC,CAIA,UACI,KAAK,iBAAiB,QACtB,KAAK,sBAAsB,QAC3B,KAAK,oBAAoB,QACzB,KAAK,oBAAoB,QACzB,KAAK,iBAAiB,QACtB,KAAK,iBACL,KAAK,gBAAgB,QACrB,KAAK,QAAS,CAClB,CAIA,iBACI,KAAK,gBAAgB,OACzB,CACA,UACI,KAAK,iBAAiB,UACtB,KAAK,sBAAsB,UAC3B,KAAK,oBAAoB,UACzB,KAAK,oBAAoB,UACzB,KAAK,iBAAiB,UACtB,KAAK,gBAAgB,UACrB,KAAK,gBAAgB,SACzB,CAOA,SAAS,EAAS,EAAM,QAEP,IAATiF,IACA,EAAO,EAAQ,gBAEF,IAAb,IACA,EAAW,EAAQ,eAEnB,UAGA,EAAS,yBAAyB,GAElC,KAAK,sBAAsB,KAAK,GAE3B,EAAS,oBAEV,EAAS,kBACT,KAAK,oBAAoB,KAAK,GAElC,KAAK,oBAAoB,KAAK,KAG1B,EAAS,kBACT,KAAK,oBAAoB,KAAK,GAElC,KAAK,iBAAiB,KAAK,IAE/B,EAAK,gBAAkB,KACnB,EAAK,gBAAkB,EAAK,eAAe,WAC3C,KAAK,gBAAgB,gBAAgB,EAAK,gBAE9CjF,KAAK,QAAS,EAClB,CACA,gBAAgB,GACZ,KAAK,gBAAgB,KAAK,GAC1B,KAAK,QAAS,CAClB,CACA,kBAAkB,GACd,KAAK,iBAAiB,KAAK,GAC3BA,KAAK,QAAS,CAClB,CACA,iBAAiB,GACb,GAAqC,IAAjC,KAAK,iBAAiB,OACtB,OAGJ,MAAM,EAAe,KAAK,OAAO,aACjC,KAAK,OAAO,qCAAqC,gBAAgB,KAAK,QACtE,IAAK,IAAI,EAAgB,EAAG,EAAgB,KAAK,iBAAiB,OAAQ,IAAiB,CACvF,MAAM,EAAW,8BACjB,GAAZ,KAAiB,GAAgB,EAAjC,uB,gRCtYiE,OAGzD,MAAM,EAAe,KAAK,OAAO,aAC1B,KAAK,OAAO,mCAAmC,gBAAgB,KAAK,QAC3E,IAAK,IAAI,EAAK,EAAG,EAAK,KAAK,gBAAgB,OAAQ,IAAM,CACrD,MAAM,EAAgB,KAAK,gBAAgB,KAAK,GAC2B,KAAtE,GAAgB,EAAa,UAAY,EAAc,YACxD,EAAc,QAEtB,CACO,KAAK,OAAO,kCAAkC,gBAAgB,KAAK,OAC9E,EAEJ,EAAe,YAAc,EAAuE,EAAE,MAG/F,EAED,MACA,CAAE,EAAqC,EAAqB,KAE7C,EAAoB,EAAE,EAAqB,CACzC,EAAK,IAAM,IAGb,IAAI,EAAkD,EAAoB,OAK/F,MAAM,GAON,MAAM,EAOE,iCACA,OAAO,KAAK,2BAChB,CACI,+BAA2B,GAC3B,GAAI,IAAU,KAAK,8BAGnBA,KAAK,4BAA8B,GAE9B,KAAK,6BAA6B,CACnC,IAAK,MAAM,KAAQ,KAAK,OAAO,OAC3B,GAAI,EAAK,UACL,IAAK,MAAM,KAAW,EAAK,UACvB,EAAQ,gBAAiB,EAIrC,IAAK,MAAM,KAAiB,KAAK,OAAO,eACpC,EAAc,gBAAiB,EAEnC,IAAK,MAAM,KAAkB,KAAK,OAAO,gBACrC,EAAe,gBAAiB,CAExC,CACJ,CAKA,YAAY,GAIR,KAAK,yBAA0B,EAC/B,KAAK,iBAAmB,IAAI,MAC5B,KAAK,uBAAyB,CAAC,EAC/B,KAAK,2BAA6B,CAAC,EACnC,KAAK,8BAAgC,CAAC,EACtC,KAAK,gCAAkC,CAAC,EACxC,KAAK,oBAAsB,IAAI,EAC/B,KAAK,6BAA8B,EACnC,KAAK,OAAS,EACd,IAAK,IAAI,EAAI,EAAiB,oBAAqB,EAAI,EAAiB,oBAAqB,IACzF,KAAK,uBAAuB,GAAK,CAAE,WAAW,EAAM,OAAO,EAAM,SAAS,EAElF,CAIA,kBAAkB,GACd,MAAM,EAAmB,GAAM,EAE/B,OADA,KAAK,uBAAuB,GACrB,KAAK,iBAAiB,EACjC,CACA,yBAAyB,GAAQ,EAAM,GAAU,GACzC,KAAK,oCAGT,KAAK,OAAO,YAAY,MAAM,MAAM,EAAO,EAAO,GAClD,KAAK,mCAAoC,EAC7C,CAKA,OAAO,EAAsB,EAAc,EAAiB,GAExD,MAAM,EAAO,KAAK,oBAIlB,GAHA,EAAK,MAAQ,KAAK,OAClB,EAAK,OAAS,KAAK,OAAO,aAEtB,KAAK,OAAO,gBAAkB,EAC9B,IAAK,IAAI,EAAQ,EAAG,EAAQ,KAAK,OAAO,eAAe,OAAQ,IAAS,CACpE,MAAM,EAAU,KAAK,OAAO,eAAe,GAC3C,KAAK,gBAAgB,EACzB,CAGJ,IAAK,IAAI,EAAQ,EAAiB,oBAAqB,EAAQ,EAAiB,oBAAqB,IAAS,CAC1G,KAAK,kCAAoC,IAAU,EAAiB,oBACpE,MAAM,EAAiB,KAAK,iBAAiB,GAC7C,IAAK,GAAkB,EAAe,OAClC,SAEJ,MAAM,EAAqB,KAAK,IAAI,EAAG,GAKvC,GAJA,EAAK,iBAAmB,EAExB,KAAK,OAAO,iCAAiC,gBAAgB,EAAM,GAE/D,EAAiB,UAAW,CAC5B,MAAM,EAAY,KAAK,wBAA0B,KAAK,OAAO,8BAA8B,GAAS,KAAK,uBAAuB,GAC5H,GAAa,EAAU,WACvB,KAAK,yBAAyB,EAAU,MAAO,EAAU,QAEjE,CAEA,IAAK,MAAM,KAAQ,KAAK,OAAO,+BAC3B,EAAK,OAAO,GAEhB,EAAe,OAAO,EAAsB,EAAe,EAAiB,GAC5E,IAAK,MAAM,KAAQ,KAAK,OAAO,8BAC3B,EAAK,OAAO,GAGhB,KAAK,OAAO,gCAAgC,gBAAgB,EAAM,EACtE,CACJ,CAKA,QACI,IAAI,KAAK,2BAGT,IAAK,IAAI,EAAQ,EAAiB,oBAAqB,EAAQ,EAAiB,oBAAqB,IAAS,CAC1G,MAAM,EAAiB,KAAK,iBAAiB,GACzC,GACA,EAAe,SAEvB,CACJ,CAKA,eACI,IAAI,KAAK,2BAGT,IAAK,IAAI,EAAQ,EAAiB,oBAAqB,EAAQ,EAAiB,oBAAqB,IAAS,CAC1G,MAAM6H,EAAiB,KAAK,iBAAiB,GACzC,GACA,EAAe,gBAEvB,CACJ,CAKA,UACI,KAAK,sBACL,KAAK,iBAAiB,OAAS,EAC/B7H,KAAK,oBAAsB,IAC/B,CAIA,sBACI,IAAK,IAAI,EAAQ,EAAiB,oBAAqB,EAAQ,EAAiB,oBAAqB,IAAS,CAC1G,MAAM,EAAiB,KAAK,iBAAiB,GACzC,GACA,EAAe,SAEvB,CACJ,CACA,uBAAuB,QAC6B,IAA5C,KAAK,iBAAiB,KACtB,KAAK,iBAAiB,GAAoB,IAAI,EAAsE,EAAE,EAAkB,KAAK,OAAQ,KAAK,2BAA2B,GAAmB,KAAK,8BAA8B,GAAmB,KAAK,gCAAgC,IAE3S,CAKA,gBAAgB,GACRA,KAAK8H,4BAA8B,EAAc,iBAGrD,EAAc,gBAAiB,EAC/B9H,KAAK+H,kBAAkB,EAAc,kBAAkB,gBAAgB,GAC3E,CAKA,kBAAkB,GACV,KAAK,4BAA8B,EAAe,iBAGtD,EAAe,gBAAiB,EAChC,KAAK,kBAAkB,EAAe,kBAAkB,kBAAkB,GAC9E,CAOA,SAAS,EAAS,EAAM,QACP,IAAT,IACA,EAAO,EAAQ,WAEf,KAAK,4BAA8B,EAAQ,iBAG/C,EAAQ,gBAAiB,EACzB,KAAK,kBAAkB,EAAK,kBAAkB,SAAS,EAAS,EAAM,GAC1E,CAUA,kBAAkB,EAAkB,EAAsB,KAAM,EAAyB,KAAM,EAA2B,MAItH,GAHA,KAAK,2BAA2B,GAAoB,EACpD,KAAK,8BAA8B,GAAoB,EACvD,KAAK,gCAAgC,GAAoB,EACrD,KAAK,iBAAiB,GAAmB,CACzC,MAAM,EAAQ,KAAK,iBAAiB,GACpC,EAAM,oBAAsB,KAAK,2BAA2B,GAC5D,EAAM,uBAAyB,KAAK,8BAA8B,GAClE,EAAM,yBAA2B,KAAK,gCAAgC,EAC1E,CACJ,CASA,kCAAkC,EAAkB,EAAuB,GAAQ,EAAM,GAAU,GAC/F,KAAK,uBAAuB,GAAoB,CAC5C,UAAW,E,mBClRnB,8BAA8B,GAC1B,OAAO,KAAK,uBAAuB,EACvC,EAKJ,EAAiB,oBAAsB,EAIvC,EAAiB,oBAAsB,EAIvC,EAAiB,WAAY,CAGtB,EAED,M,2BCpBN,MAAM,EACF,cAII,KAAK,SAAU,EAIf/H,KAAK,KAAO,0BAIZA,KAAK,iBAAmB,CAAC,EAAG,EAAG,EACnC,EAIG,EAED,M,2BCpBN,MAAM,EACF,cAII,KAAK,SAAU,EAIfA,KAAK,KAAO,yBAIZA,KAAK,iBAAmB,CAAC,EAAG,EAAG,EACnC,EAIG,EAED,M,iECnB8E,KAAK,KAAO,QAItC,KAAK,iBAAmB,CAAC,EAAG,EAClC,EAItC,EAER,MACA,CAAE,EAAqC,EAAqB,KAE7C,EAAoB,EAAE,EAAqB,CACzC,EAAK,IAAM,IAEb,IAAI,EAAyC,EAAoB,OAC7D,EAAmD,EAAoB,OACvE,EAAwD,EAAoB,OAC5E,EAA0D,EAAoB,MAC9E,EAAuD,EAAoB,OAC3E,EAA2D,EAAoB,OAC/E,EAAqD,EAAoB,OACzE,EAAoD,EAAoB,OAYjG,MAAM,EAMF,gBAAgB,GACZ,GAAI,KAAK,cACL,OAAO,KAAK,cAEX,CACD,IAAI,EAOJ,OALI,EADA,KAAK,cAAc,eAAc,0CACrB,KAAK,cAAc,cAAc,KAAK,cAAc,cAAc,OAAS,GAG3E,KAAK,cAAc,aAE/B,GAA0B,GAAa,EAAU,YAC1C,EAAU,UAEd,CACX,CACJ,CAKA,gBAAgB,GACZ,KAAK,cAAgB,CACzB,CAKA,uBAMI,OALK,KAAK,oBACN,KAAK,kBAAoB,IAAI,EAAiF,EAAE,qBAAsB,IAAI,EAAkE,EAAE,EAAG,EAAG,GAAI,KAAK,mBAC7N,KAAK,kBAAkB,UAAY,EACnC,KAAK,kBAAkB,YAAc,EAAqE,GAAG,QAE1G,KAAK,iBAChB,CAIW,iCACP,OAAiD,MAA7C,EAAqB,qBACd,EAAqB,oCAAoC,EAAyF,EAAE,kBAExJ,EAAqB,oBAChC,CAMA,2CAA2C,GAKvC,OAJA,EAAqB,qBAAuB,IAAI,EAAqB,GACrE,EAAqB,qBAAqB,cAAc,oBAAoB,SAAQ,KAChF,EAAqB,qBAAuB,IAAI,IAE7C,EAAqB,oBAChC,CAIW,0CAQP,OAP0D,MAAtD,EAAqB,gCACrB,EAAqB,8BAAgC,IAAI,EAAqB,EAAyF,EAAE,kBACzK,EAAqB,8BAA8B,kBAAkB,0BAA2B,EAChG,EAAqB,8BAA8B,cAAc,oBAAoB,SAAQ,KACzF,EAAqB,8BAAgC,IAAI,KAG1D,EAAqB,6BAChC,CAMA,YAEA,EAAe,GAAe,GAC1B,KAAK,cAAgB,EACrBA,KAAK,iBAAmB,CAAC,EACzB,KAAK,mBAAqB,CAAC,EAC3BA,KAAK,kBAAoB,KACzBA,KAAK,cAAgB,KAIrB,KAAK,uBAAwB,EAI7B,KAAK,cAAe,EAIpB,KAAK,4BAA6B,EAIlC,KAAK,kBAAmB,EAIxB,KAAK,gBAAiB,EAItB,KAAK,uBAAyB,IAAI,EAAmE,GAErG,KAAK,kBAAoB,IAAI,EAAoD,EAAE,EAAc,YAAa,CAAE,SAAS,IACzH,KAAK,kBAAkB,qBAAuB,EAAc,qBAC5D,KAAK,kBAAkB,6BAA8B,EAErD,KAAK,kBAAkB,sBAAuB,EAE9C,KAAK,kBAAkB,gBACnB,IACA,KAAK,yBAA2B,EAAc,uBAAuB,KAAK,IACtE,IAAK,KAAK,kBAAkB,aACxB,OAEJ,IAAK,KAAK,eACN,OAEJ,IAAK,KAAK,kBACF,EAAe,OAAS,EAA2F,GAAG,aACtH,EAAe,OAAS,EAAyF,GAAG,WACpH,EAAe,OAAS,EAA2F,GAAG,aACtH,EAAe,OAAS,EAAgG,GAAG,iBAC3H,OAGR,KAAK,kBAAkB,SAAW,EAAc,SAChD,KAAK,kBAAkB,SAAW,EAAc,SAChD,MAAM,EAAe,EAAe,MACpC,GAAI,EAAc,kBAAkB,EAAa,WAE7C,YADA,KAAK,iBAAiB,EAAa,YAAa,GAGpD,MAAM,EAA2B,IAC7B,IAAI,EAAY,KAChB,GAAI,EAAe,2BAEX,EADA,EAAe,2BAA2B,WAAW,YAAc,EACvD,EAAe,2BAGf,IAAI,EAA2E,OAG9F,GAAI,IAAU,KAAK,mBAAqB,EAAe,oBACxD,EAAY,EAAe,wBAE1B,CACD,IAAI,EAAuB,KAOvB,KAAK,gBACL,EAAuB,EAAM,cAC7B,EAAM,cAAgB,KAAK,cAC3B,EAAe,IAAM,MAEzB,EAAY,EAAe,IAAM,EAAM,YAAY,EAAe,KAAC,8BAC/D,IACA,EAAM,cAAgB,EAE9B,CACA,OAAO,CAAS,EAEd,EAAmB,EAAwB,KAAK,mBAOtD,IANK,EAAe,KAAO,IACvB,EAAe,IAAM,EAAiB,KAG1C,KAAK,kBAAkB,uBAAuB,gBAAgB,GAE1D,KAAK,4BAA8B,EAAe,MAAQ,EAA2F,GAAG,YAOxJ,OANK,EAAe,yBAChB,KAAK,kBAAkB,oBAAoB,gBAAgB,IAAI,EAAyE,GAAG,EAAe,KAAM,EAAe,MAAO,GAAmB,EAAe,WAExN,EAAe,OAAS,EAAyF,GAAG,WAAa,KAAK,iBAAiB,EAAa,aACpK,KAAK,iBAAiB,EAAa,YAAa,IAIxD,GAAI,KAAK,kBAAkB,0BAA4B,KAAK,sBAEpD,GAAoB,EAAiB,MAChC,EAAe,yBAChB,KAAK,kBAAkB,oBAAoB,gBAAgB,IAAI,EAAyE,GAAG,EAAe,KAAM,EAAe,MAAO,GAAmB,EAAe,MAE5N,EAAe,yBAA0B,OAG5C,CACD,MAAM,EAAoB,EAAwB,GAC5C,EAAe,EAAe,MAEhC,GAAqB,IAEa,IAA9B,EAAiB,UAAkB,EAAkB,WACjD,KAAK,2BAA6B,KAAK,0BAA0B,EAAkB,aAEnFA,KAAKgI,iBAAiBC,EAAgBC,EAAmBC,GACzDF,EAAeG,yBAA0B,GAEpC,EAAe,OAAS,EAA2F,GAAG,YAC3H,KAAK,iBAAiB,EAAM,cAEvB,EAAe,OAAS,EAA2F,GAAG,aAAe,EAAe,OAAS,EAAyF,GAAG,YAC1P,KAAK,mBAAmB,EAAa,aAErC,KAAK,uBAAuB,gBAAgB,EAAa,kBAClD,KAAK,mBAAmB,EAAa,YAEhD,KAAK,iBAAiB,EAAgB,EAAmB,KAGvD,KAAK,iBAAiB,EAAa,aAAe,EAAiB,SAAW,EAAkB,UAA2C,IAA/B,EAAkB,WAEpI,KAAK,iBAAiB,EAAgB,EAAkB,GAEnD,EAAe,0BAChB,EAAe,wBAA0B,EAAiB,SAAW,KAGnE,KAAK,iBAAiB,EAAa,YAAc,EAAiB,UAAY,EAAkB,WAGlG,KAAK,2BAA6B,KAAK,0BAA0B,EAAkB,aACnF,KAAK,iBAAiB,EAAgB,EAAmB,GACzD,EAAe,yBAA0B,IAGrC,EAAe,OAAS,EAA2F,GAAG,aAAe,EAAe,OAAS,EAAyF,GAAG,WACrP,KAAK,mBAAmB,EAAa,aAErC,KAAK,uBAAuB,gBAAgB,EAAa,kBAClD,KAAK,mBAAmB,EAAa,YAGpD,KAAK,iBAAiB,EAAgB,EAAkB,KAG5D,EAAe,OAAS,EAAyF,GAAG,WAAa,KAAK,iBAAiB,EAAa,aACpK,KAAK,iBAAiB,EAAa,YAAa,GAG5D,KAGA,KAAK,0BACL,EAAc,uBAAuB,wBAAwB,KAAK,2BAI1E,KAAK,kBAAkB,WAAY,EACnC,KAAK,qBAAuB,KAAK,cAAc,8BAA8B,KAAK,IAE1E,KAAK,cAAgB,GAAU,KAAK,mBACpC,KAAK,QACT,IAEJ,KAAK,sBAAwB,KAAK,cAAc,oBAAoB,KAAI,KACpE,KAAK,SAAS,IAElB,KAAK,eACT,CACA,iBAAiB,EAAgB,EAAU,GAClC,EAAe,0BAChB,KAAK,kBAAkB,oBAAoB,gBAAgB,IAAI,EAAyE,GAAG,EAAe,KAAM,EAAe,MAAO,GAAW,EAAe,MAChN,KAAK,mBAAmB,EAAa,YAAa,EAE1D,CAIA,SAEI,GADApI,KAAK,gBACDA,KAAK,kBAAkB,aAAc,CAErC,MAAM,EAAW,KAAK,kBAAkB,aAAa,WAC/C,EAAS,KAAK,kBAAkB,aACtC,EAAO,OAAS,KAAK,kBACjB,EAAO,aACP,EAAO,WAAW,OAAS,KAAK,mBAEhC,EAAO,cACP,EAAO,YAAY,OAAS,KAAK,mBAErC,KAAK,kBAAkB,QAAO,GAE9B,EAAO,OAAS,EACZ,EAAO,aACP,EAAO,WAAW,OAAS,GAE3B,EAAO,cACP,EAAO,YAAY,OAAS,EAEpC,C,6JC1VI,KAAK,uBACsD,KAAK,cAAc,oBAAoB,OAAO,KAAK,uBAE9G,KAAK,0BACL,KAAK,cAAc,uBAAuB,OAAO,KAAK,0BAE1D,KAAK,kBAAkB,SAC3B,CACA,gBACI,KAAK,kBAAkB,uBAAyB,KAAK,kBACrD,KAAK,kBAAkB,aAAe,KAAK,iBACnD,EAGA,EAAqB,qBAAuB,K,sDCZvB,IAAI,EAAuD,EAAoB,OACpB,EAAoB,OAIpG,MAAM,EAAO,2BACP,EAAS,0lB,+BCPkD,MAC3D,CAAE,EAAqC,EAAqB,KAMlE,MAAM,EAAO,uBACP,EAAS,g/DAJiE,EAAoB,OCFP,EAAE,qBAAqB,GAAQ,CAKrH,EAED,MACA,CAAE,EAAqC,EAAqB,KAMlE,MAAM,EAAO,kCACP,EAAS,yyBAJiE,EAAoB,OA2BP,EAAE,qBAAqB,GAAQ,C,kBCtC5H,MAAM,EAAO,mBACP,EAAS,62BAJiE,EAAoB,OAsCP,EAAE,qBAAqB,GAAQ,C,kBCpCnF,MAAM,EAAO,cAChD,EAAS,27D,SCC8E,EAAE,qBAAqB,GAAQ,CAK5H,EAEa,MACP,CAAE,EAAR,O,2xECA6F,EAAE,qBAAqB,GAAQ,CAK5H,EAEa,MACP,CAAE,EAAqC,EAA7C,K,wDCpBM,EAAS,ypD,6BCGR,EAED,MACA,CAAE,EAAqC,EAAqB,KAMlE,MAAM,EAAO,4BACP,EAAS,09EAJiE,EAAoB,OCLP,EAAE,qBAAqB,GAAQ,C,kBCHjE,MAAM,EAAO,aAClE,EAAS,kX,4CCFT,CAAE,EAAqC,EAAqB,KAMlE,MAAM,EAAO,wBACP,EAAS,4KAJiE,EAAoB,O,6BCH9F,MAC2D,CAAE,EAAqC,EAAqB,KAM7H,MAAM,EAAO,oBACP,EAAS,ylBAJiE,EAAoB,OCEP,EAAE,qBAAqB,GAAQ,C,kBCLjE,MAAM,EAAO,+BAClE,EAAS,6V,SCAgH,EAAE,qBAAqB,GAAQ,CAK9J,EAEa,MACP,CAAE,EAAqC,EAA7C,K,kXCTwJ,EAAE,qBAAqB,GAAQ,CAKhL,EAED,MACA,CAAE,EAAqC,EAAqB,K,gcAGqB,EAAoB,OCEd,EAAE,qBAAqB,GAAQ,CAKrH,EAED,MACA,CAAE,EAAqC,EAAqB,KAM3D,MAAM,EAAO,6BACd,EAAS,8fAJiE,EAAoB,OCRP,EAAE,qBAAqB,GAAQ,CAKrH,EAED,MACA,CAAE,EAAqC,EAAqB,KAMlE,MAAM,EAAO,8BACP,EAAS,seAJiE,EAAoB,O,mCC5B9F,CAAE,EAAqC,EAAqB,KAG7C,IAAI,EAAuD,EAAoB,OACpB,EAAoB,OACrB,EAAoB,MAKnG,MAAM,EAAO,wBACP,EAAS,0gCCaf,EAA6F,EAAE,qBAAqB,GAAQ,CAKrH,EAED,MACA,CAAE,EAAqC,EAAqB,KAMlE,MAAM,EAAO,eACP,EAAS,2EAJiE,EAAoB,OAUP,EAAE,qBAAqB,GAAQ,C,kBC5CjE,MAAM,EAAO,mBAClE,EAAS,2F,SAI8E,EAAE,qBAAqB,GAAQ,C,kBCH5H,MAAM,EAAO,YACP,EAAS,sUAJiE,EAAoB,OAiBP,EAAE,qBAAqB,GAAQ,CAK9G,E,sCCtBR,EAAS,yI,SAS8E,EAAE,qBAAqB,GAAQ,CAKrH,EAEP,MACM,CAAE,EAAqC,EAAqB,K,4vBCX2B,EAAE,qBAAqB,GAAQ,CAK5H,EAEa,MACP,CAAE,EAAqC,EAA7C,K,yFCX6F,EAAE,qBAAqB,GAAQ,CAKrH,E,gBCRP,MAAM,EAAO,uBACoD,EAAS,mD,SAKmB,EAAE,qBAAqB,GAAQ,C,kBCH5H,MAAM,EAAO,kBACP,EAAS,iOAJiE,EAAoB,OAaP,EAAE,qBAAqB,GAAQ,CAKrH,EAED,MACA,CAAE,EAAqC,EAAqB,KAG7C,IAAI,EAAuD,EAAoB,OACpB,EAAoB,OAIpG,MAAM,EAAO,yBACP,EAAS,kCAGf,EAA6F,EAAE,qBAAqB,GAAQ,CAKrH,EAED,MACA,CAAE,EAAqC,EAAqB,KAMlE,MAAM,EAAO,4BACP,EAAS,mDAJiE,EAAoB,OAOP,EAAE,qBAAqB,GAAQ,CAKrH,EAED,KACA,CAAE,EAAqC,EAAqB,KAMlE,MAAM,EAAO,qBACP,EAAS,0/BAJiE,EAAoB,OA6CP,EAAE,qBAAqB,GAAQ,CAKrH,EAED,MACA,CAAE,EAAqC,EAAqB,KAMlE,MAAM,EAAO,wBACP,EAAS,6/GAJiE,EAAoB,OC1FP,EAAE,qBAAqB,GAAQ,CAKrH,EAED,M,s7JC3BuF,EAAE,qBAAqB,GAAQ,C,kBCL5H,MAAM,EAAO,+BACP,EAAS,iGAJiE,EAAoB,OASpG,uBAAiCS,GAAQgG,C,kBCPzC,MAAMhG,EAAO,6BACPgG,EAAS,kqB,SCH8E,EAAE,qBAAqB,GAAQ,CAKrH,EAED,MACA,CAAE,EAAqC,EAAqB,KAMlE,MAAM,EAAO,2BACb,8/HAJgF,EAAoB,OCRP,EAAE,qBAAqB,GAAQ,CAKrH,E,gBCRP,MAAM,EAAO,qBACoD,EAAS,gsB,SAqBmB,EAAE,qBAAqB,GAAQ,CAKrH,EAED,KACA,CAAE,EAAqC,EAAqB,KAMlE,MAAM,EAAO,uBACP,EAAS,0pBAJiE,EAAoB,O,2BC9B7F,EAED,MACA,CAAE,EAAqC,EAAqB,KAMlE,MAAM,EAAO,kBACP,EAAS,2hBAJiE,EAAoB,OAuBP,EAAE,qBAAqB,GAAQ,CAK5H,EAEa,MACP,CAAE,EAAqC,EAA7C,K,iYC5B6F,EAAE,qBAAqB,GAAQ,CAK5H,EAEa,MACP,CAAE,EAAqC,EAA7C,K,odCR6F,EAAE,qBAAqB,GAAQ,CAKrH,EAED,M,2FClBkJ,EAAE,qBAAqB,GAAQ,CAKhL,EAED,MACA,CAAE,EAAqC,EAAqB,KAMlE,MAAM,EAAO,mBACb,wDAJgF,EAAoB,OAMA,EAAE,qBAAqB,GAAQ,C,kBCdnI,MAAM,EAAO,gBACP,EAAS,+qcAJ4H,EAAoB,O,6BCDzJ,MAC2D,CAAE,EAAqC,EAAqB,KAM7H,MAAM,EAAO,2BACP,EAAS,wwEAJiE,EAAoB,OCEP,EAAE,qBAAqB,GAAQ,CAKrH,EAED,MACA,CAAE,EAAqC,EAAqB,KAMlE,MAAM,EAAO,sBACP,EAAS,koEAJiE,EAAoB,O,6BChBnC,MAC3D,CAAE,EAAqC,EAAqB,KAMlE,MAAM,EAAO,6BACP,EAAS,22BAJiE,EAAoB,OCMP,EAAE,qBAAqB,GAAQ,C,kBCR5H,MAAM,EAAO,wBACP,EAAS,ouBAJiE,EAAoB,OAqCP,EAAE,qBAAqB,GAAQ,CAKrH,EAED,MACA,CAAE,EAAqC,EAAqB,KAMlE,MAAM,EAAO,0BACP,EAAS,utFAJiE,EAAoB,OChDP,EAAE,qBAAqB,GAAQ,CAKrH,EAED,MACA,CAAE,EAAqC,EAAqB,KAMlE,MAAM,EAAO,sBACP,EAAS,4GAJiE,EAAoB,OAUP,EAAE,qBAAqB,GAAQ,CAKrH,EAED,MACA,CAAE,EAAqC,EAAqB,KAMlE,MAAM,EAAO,mBACP,EAAS,wGAJiE,EAAoB,OASP,EAAE,qBAAqB,GAAQ,CAKrH,EAED,MACA,CAAE,EAAqC,EAAqB,KAMlE,MAAM,EAAO,iBACP,EAAS,mJAJiE,EAAoB,OAUP,EAAE,qBAAqB,GAAQ,C,kBC7DjE,MAAM,EAAO,2BAClE,EAAS,uD,SAK8E,EAAE,qBAAqB,GAAQ,CAKrH,EAED,KACA,CAAE,EAAqC,EAAqB,KAMlE,MAAM,EAAO,qBACP,EAAS,+LAJiE,EAAoB,OAkBP,EAAE,qBAAqB,GAAQ,CAKrH,EAED,MACA,CAAE,EAAqC,EAAqB,KAMlE,MAAM,EAAO,qBACP,EAAS,ugCAJiE,EAAoB,OAmCP,EAAE,qBAAqB,GAAQ,CAKrH,EAED,MACA,CAAE,EAAqC,EAAqB,KAMlE,MAAM,EAAO,gCACP,EAAS,2RAJiE,EAAoB,OC1FP,EAAE,qBAAqB,GAAQ,CAKrH,EAED,MACA,CAAE,EAAqC,EAAqB,KAMlE,MAAM,EAAO,2BACP,EAAS,sFAJiE,EAAoB,OAWP,EAAE,qBAAqB,GAAQ,CAKrH,EAED,MACA,CAAE,EAAqC,EAAqB,KAMlE,MAAM,EAAO,sCACP,EAAS,kpBAJiE,EAAoB,OAsBP,EAAE,qBAAqB,GAAQ,CAKrH,EAED,KACA,CAAE,EAAqC,EAAqB,KAMlE,MAAM,EAAO,yBACP,EAAS,oHAJiE,EAAoB,OASP,EAAE,qBAAqB,GAAQ,CAKrH,EAED,MACA,CAAE,EAAqC,EAAqB,KAMlE,MAAM,EAAO,iBACP,EAAS,oVAJiE,EAAoB,OAgBP,EAAE,qBAAqB,GAAQ,CAKrH,EAED,MACA,CAAE,EAAqC,EAAqB,KAMlE,MAAM,EAAO,cACP,EAAS,glCAJiE,EAAoB,OA2CP,EAAE,qBAAqB,GAAQ,CAKrH,EAED,MACA,CAAE,EAAqC,EAAqB,KAMlE,MAAM,EAAO,mBACP,EAAS,6XAJiE,EAAoB,O,2BCtK7F,EAED,MACA,CAAE,EAAqC,EAAqB,KAMlE,MAAM,EAAO,mBACP,EAAS,s5RAJiE,EAAoB,OCwEP,EAAE,qBAAqB,GAAQ,CAKrH,EAED,MACA,CAAE,EAAqC,EAAqB,KAMlE,MAAM,EAAO,wB,8+CAHb,SC5FwJ,EAAE,qBAAqB,GAAQ,CAKhL,EAED,MACA,CAAE,EAAqC,EAAqB,KAMlE,MAAM,EAAO,uBACP,EAAS,82BAJiE,EAAoB,OAwCP,EAAE,qBAAqB,GAAQ,CAKrH,EAED,MACA,CAAE,EAAqC,EAAqB,KAMlE,MAAM,EAAO,2BACP,EAAS,u0BAJiE,EAAoB,OC5DP,EAAE,qBAAqB,GAAQ,CAKrH,EAED,MACA,CAAE,EAAqC,EAAqB,KAMlE,8BACM,EAAS,isCAJiE,EAAoB,OCVP,EAAE,qBAAqB,GAAQ,CAKrH,EAED,MACO,CAAE,EAAqC,EAAqB,K,mnRCRoB,EAAE,qBAAqB,GAAQ,CAK9G,E,iDCTR,EAAS,gX,SAkB8E,EAAE,qBAAqB,GAAQ,C,iBCf5H,MAAM,EAAO,gCACP,EAAS,k0BAJiE,EAAoB,OC6BP,EAAE,qBAAqB,GAAQ,C,kBC1B5H,MAAM,EAAO,6BACP,EAAS,umHAJiE,EAAoB,OCG0B,EAAE,qBAAqB,GAAQ,CAKtJ,EAED,MACO,CAAE,EAAqC,EAAqB,K,y3BCJtB,2BCLP,EAEtC,MACA,CAAE,EAAU,EAAqB,KAMhC,MAAM,EAAO,uBACd,EAAS,22BAJiE,EAAoB,O,2BCN7F,EAED,MACA,CAAE,EAAqC,EAAqB,KAMlE,MAAM,EAAO,0BACP,EAAS,wTAJiE,EAAoB,OAiBA,EAAE,qBAAqB,GAAQ,C,iBCrBnI,MAAM,EAAO,sBACP,EAAS,45DAJ4H,EAAoB,OC4ClE,EAAE,qBAAqB,GAAQ,CAKrH,EAED,MACA,CAAE,EAAqC,EAAqB,KAMlE,MAAM,EAAO,uBACP,EAAS,mSAJiE,EAAoB,OAgBP,EAAE,qBAAqB,GAAQ,CAKrH,E,gBC7EP,MAAM,EAAO,sBACoD,EAAS,mY,SAYmB,EAAE,qBAAqB,GAAQ,CAK9G,E,kDClBR,EAAS,sX,oCCAR,EAED,KACA,CAAE,EAAqC,EAAqB,KAM3D,MAAM,EAAO,sBACd,EAAS,uwBAJiE,EAAoB,O,6BCN9F,MAC2D,CAAE,EAAqC,EAAqB,KAM7H,MAAM,EAAO,uBACP,EAAS,8hBAJiE,EAAoB,O,2BCJ7F,EAED,MACA,CAAE,EAAqC,EAAqB,KAMlE,MAAM,EAAO,qB,mqOAHb,EAAyB,OCNoE,EAAE,qBAAqB,GAAQ,CAKvE,EAEG,MACM,CAAE,EAAqC,EAAqB,KAMxE,MAAM,EAAO,uBACZ,EAAS,svHAJuE,EAAoB,OCN1D,EAAE,qBAAqB,GAAQ,C,iBCJpE,MAAM,EAAO,gBAC/D,EAAS,+gK,SCS8E,EAAE,qBAAqB,GAAQ,C,6CCXtH,EAAS,09U,SC+N8E,EAAE,qBAAqB,GAAQ,CAKrH,EAED,MACA,CAAE,EAAqC,EAAqB,KAMlE,MAAM,EAAO,WACP,EAAS,owMAJiE,EAAoB,OCpNsC,EAAE,qBAAqB,GAAQ,CAKzG,EAEb,MACN,CAAE,EAAqC,EAAqB,KAMzG,MAAM,sCACA,EAAS,qoFAJ+G,EAAoB,OAmErD,EAAE,qBAAqB,GAAQ,CAKrH,EAED,MACA,CAAE,EAAqC,EAAqB,KAMlE,MAAM,EAAO,6BACP,EAAS,2hLAJiE,EAAoB,OCtGP,EAAE,qBAAqB,GAAQ,CAKrH,EAED,MACA,CAAE,EAAqC,EAAqB,KAMlE,MAAM,EAAO,kCACP,EAAS,+gDAJiE,EAAoB,O,6BCpB9F,MAC2D,CAAE,EAAqC,EAAqB,KAM7H,MAAM,EAAO,yBACP,EAAS,89IAJiE,EAAoB,OCSP,EAAE,qBAAqB,GAAQ,CAKrH,EAED,MACA,CAAE,EAAqC,EAAqB,KAGtC,IAAI,EAAuD,EAAoB,OAC3G,S,6bCbA,EAA6F,EAAE,qBAAqB,GAAQ,CAK9G,E,+BChB8E,EAAoB,OAIhH,MACM,EAAS,ydCFf,EAAkD,EAAE,qBAA6D,oCAAI,EAErH,M,slJCiEA,EAAkD,EAAE,qBAAwD,+BAAI,CAKzG,EAED,MACA,CAAE,EAAqC,EAAqB,KAMlE,MAAM,EAAO,qBACP,EAAS,miFAJiE,EAAoB,O","sources":["webpack:///../../../node_modules/@babylonjs/core/Probes/reflectionProbe.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/boundingBoxRendererFragmentDeclaration.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/boundingBoxRendererUboDeclaration.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/boundingBoxRenderer.fragment.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/boundingBoxRendererVertexDeclaration.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/boundingBoxRenderer.vertex.js","webpack:///../../../node_modules/@babylonjs/core/Rendering/boundingBoxRenderer.js","webpack:///../../../node_modules/@babylonjs/core/Rendering/depthRenderer.js","webpack:///../../../node_modules/@babylonjs/core/Rendering/edgesRenderer.js","webpack:///../../../node_modules/@babylonjs/core/Rendering/geometryBufferRenderer.js","webpack:///../../../node_modules/@babylonjs/core/Rendering/geometryBufferRendererSceneComponent.js","webpack:///../../../node_modules/@babylonjs/core/Rendering/depthRendererSceneComponent.js","webpack:///../../../node_modules/@babylonjs/core/Rendering/depthPeelingRenderer.js","webpack:///../../../node_modules/@babylonjs/core/Rendering/depthPeelingSceneComponent.js","webpack:///../../../node_modules/@babylonjs/core/Rendering/prePassRenderer.js","webpack:///../../../node_modules/@babylonjs/core/Rendering/prePassRendererSceneComponent.js","webpack:///../../../node_modules/@babylonjs/core/Rendering/subSurfaceConfiguration.js","webpack:///../../../node_modules/@babylonjs/core/Rendering/subSurfaceSceneComponent.js","webpack:///../../../node_modules/@babylonjs/core/Rendering/outlineRenderer.js","webpack:///../../../node_modules/@babylonjs/core/Rendering/fluidRenderer/fluidRenderingObject.js","webpack:///../../../node_modules/@babylonjs/core/Rendering/fluidRenderer/fluidRenderingObjectParticleSystem.js","webpack:///../../../node_modules/@babylonjs/core/Rendering/fluidRenderer/fluidRenderingTextures.js","webpack:///../../../node_modules/@babylonjs/core/Rendering/fluidRenderer/fluidRenderingTargetRenderer.js","webpack:///../../../node_modules/@babylonjs/core/Rendering/fluidRenderer/fluidRenderingObjectCustomParticles.js","webpack:///../../../node_modules/@babylonjs/core/Rendering/fluidRenderer/fluidRenderingDepthTextureCopy.js","webpack:///../../../node_modules/@babylonjs/core/Rendering/fluidRenderer/fluidRenderer.js","webpack:///../../../node_modules/@babylonjs/core/Rendering/fluidRenderer/index.js","webpack:///../../../node_modules/@babylonjs/core/Rendering/index.js","webpack:///../../../node_modules/@babylonjs/core/Rendering/motionBlurConfiguration.js","webpack:///../../../node_modules/@babylonjs/core/Rendering/renderingGroup.js","webpack:///../../../node_modules/@babylonjs/core/Rendering/renderingManager.js","webpack:///../../../node_modules/@babylonjs/core/Rendering/screenSpaceReflections2Configuration.js","webpack:///../../../node_modules/@babylonjs/core/Rendering/screenSpaceReflectionsConfiguration.js","webpack:///../../../node_modules/@babylonjs/core/Rendering/ssao2Configuration.js","webpack:///../../../node_modules/@babylonjs/core/Rendering/utilityLayerRenderer.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/backgroundUboDeclaration.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/bakedVertexAnimation.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/bakedVertexAnimationDeclaration.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/bonesVertex.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/bumpFragment.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/bumpFragmentFunctions.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/bumpVertex.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/clipPlaneFragmentDeclaration.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/clipPlaneFragmentDeclaration2.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/clipPlaneVertexDeclaration.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/diffusionProfile.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/fibonacci.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/fogFragment.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/fogFragmentDeclaration.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/fogVertexDeclaration.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/fresnelFunction.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/geometryUboDeclaration.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/harmonicsFunctions.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/hdrFilteringFunctions.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/helperFunctions.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/imageProcessingDeclaration.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/imageProcessingFunctions.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/importanceSampling.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/instancesDeclaration.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/instancesVertex.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/kernelBlurFragment2.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/kernelBlurVaryingDeclaration.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/kernelBlurVertex.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/lightFragment.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/lightUboDeclaration.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/mainUVVaryingDeclaration.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/meshUboDeclaration.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/morphTargetsVertex.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/morphTargetsVertexDeclaration.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/packingFunctions.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBRDFFunctions.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockAlbedoOpacity.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockAlphaFresnel.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockAmbientOcclusion.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockAnisotropic.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockClearcoat.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockFinalUnlitComponents.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockIridescence.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockReflectance.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockReflectance0.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockReflection.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockReflectivity.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockSheen.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockSubSurface.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrDebug.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrFragmentDeclaration.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrFragmentSamplersDeclaration.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrHelperFunctions.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrUboDeclaration.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/samplerVertexDeclaration.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/samplerVertexImplementation.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/sceneUboDeclaration.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/screenSpaceRayTrace.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/shadowMapFragment.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/shadowMapUboDeclaration.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/meshVertexDeclaration.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/shadowMapVertexDeclaration.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/shadowMapVertexMetric.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/shadowMapVertexNormalBias.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/shadowsFragmentFunctions.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/shadowsVertex.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/subSurfaceScatteringFunctions.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/uvAttributeDeclaration.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/vertexColorMixing.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/anaglyph.fragment.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/background.vertex.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/chromaticAberration.fragment.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/circleOfConfusion.fragment.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/copyTextureToTexture.fragment.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/defaultFragmentDeclaration.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/default.fragment.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/default.vertex.js","webpack:///../../../node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/bonesVertex.js","webpack:///../../../node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/clipPlaneFragmentDeclaration.js","webpack:///../../../node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/morphTargetsVertex.js","webpack:///../../../node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/morphTargetsVertexDeclaration.js","webpack:///../../../node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/morphTargetsVertexGlobal.js","webpack:///../../../node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/morphTargetsVertexGlobalDeclaration.js","webpack:///../../../node_modules/@babylonjs/core/ShadersWGSL/gpuUpdateParticles.compute.js"],"sourcesContent":["import { __decorate } from \"../tslib.es6.js\";\nimport { serializeAsMeshReference, serializeAsVector3, SerializationHelper } from \"../Misc/decorators.js\";\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture.js\";\nimport { Matrix, Vector3 } from \"../Maths/math.vector.js\";\nimport { AbstractScene } from \"../abstractScene.js\";\n\nAbstractScene.prototype.removeReflectionProbe = function (toRemove) {\n    if (!this.reflectionProbes) {\n        return -1;\n    }\n    const index = this.reflectionProbes.indexOf(toRemove);\n    if (index !== -1) {\n        this.reflectionProbes.splice(index, 1);\n    }\n    return index;\n};\nAbstractScene.prototype.addReflectionProbe = function (newReflectionProbe) {\n    if (!this.reflectionProbes) {\n        this.reflectionProbes = [];\n    }\n    this.reflectionProbes.push(newReflectionProbe);\n};\n/**\n * Class used to generate realtime reflection / refraction cube textures\n * @see https://doc.babylonjs.com/features/featuresDeepDive/environment/reflectionProbes\n */\nexport class ReflectionProbe {\n    /**\n     * Creates a new reflection probe\n     * @param name defines the name of the probe\n     * @param size defines the texture resolution (for each face)\n     * @param scene defines the hosting scene\n     * @param generateMipMaps defines if mip maps should be generated automatically (true by default)\n     * @param useFloat defines if HDR data (float data) should be used to store colors (false by default)\n     * @param linearSpace defines if the probe should be generated in linear space or not (false by default)\n     */\n    constructor(\n    /** defines the name of the probe */\n    name, size, scene, generateMipMaps = true, useFloat = false, linearSpace = false) {\n        this.name = name;\n        this._viewMatrix = Matrix.Identity();\n        this._target = Vector3.Zero();\n        this._add = Vector3.Zero();\n        this._invertYAxis = false;\n        /** Gets or sets probe position (center of the cube map) */\n        this.position = Vector3.Zero();\n        /**\n         * Gets or sets an object used to store user defined information for the reflection probe.\n         */\n        this.metadata = null;\n        /** @internal */\n        this._parentContainer = null;\n        this._scene = scene;\n        if (scene.getEngine().supportsUniformBuffers) {\n            this._sceneUBOs = [];\n            for (let i = 0; i < 6; ++i) {\n                this._sceneUBOs.push(scene.createSceneUniformBuffer(`Scene for Reflection Probe (name \"${name}\") face #${i}`));\n            }\n        }\n        // Create the scene field if not exist.\n        if (!this._scene.reflectionProbes) {\n            this._scene.reflectionProbes = new Array();\n        }\n        this._scene.reflectionProbes.push(this);\n        let textureType = 0;\n        if (useFloat) {\n            const caps = this._scene.getEngine().getCaps();\n            if (caps.textureHalfFloatRender) {\n                textureType = 2;\n            }\n            else if (caps.textureFloatRender) {\n                textureType = 1;\n            }\n        }\n        this._renderTargetTexture = new RenderTargetTexture(name, size, scene, generateMipMaps, true, textureType, true);\n        this._renderTargetTexture.gammaSpace = !linearSpace;\n        const useReverseDepthBuffer = scene.getEngine().useReverseDepthBuffer;\n        this._renderTargetTexture.onBeforeRenderObservable.add((faceIndex) => {\n            if (this._sceneUBOs) {\n                scene.setSceneUniformBuffer(this._sceneUBOs[faceIndex]);\n                scene.getSceneUniformBuffer().unbindEffect();\n            }\n            switch (faceIndex) {\n                case 0:\n                    this._add.copyFromFloats(1, 0, 0);\n                    break;\n                case 1:\n                    this._add.copyFromFloats(-1, 0, 0);\n                    break;\n                case 2:\n                    this._add.copyFromFloats(0, this._invertYAxis ? 1 : -1, 0);\n                    break;\n                case 3:\n                    this._add.copyFromFloats(0, this._invertYAxis ? -1 : 1, 0);\n                    break;\n                case 4:\n                    this._add.copyFromFloats(0, 0, scene.useRightHandedSystem ? -1 : 1);\n                    break;\n                case 5:\n                    this._add.copyFromFloats(0, 0, scene.useRightHandedSystem ? 1 : -1);\n                    break;\n            }\n            if (this._attachedMesh) {\n                this.position.copyFrom(this._attachedMesh.getAbsolutePosition());\n            }\n            this.position.addToRef(this._add, this._target);\n            const lookAtFunction = scene.useRightHandedSystem ? Matrix.LookAtRHToRef : Matrix.LookAtLHToRef;\n            const perspectiveFunction = scene.useRightHandedSystem ? Matrix.PerspectiveFovRH : Matrix.PerspectiveFovLH;\n            lookAtFunction(this.position, this._target, Vector3.Up(), this._viewMatrix);\n            if (scene.activeCamera) {\n                this._projectionMatrix = perspectiveFunction(Math.PI / 2, 1, useReverseDepthBuffer ? scene.activeCamera.maxZ : scene.activeCamera.minZ, useReverseDepthBuffer ? scene.activeCamera.minZ : scene.activeCamera.maxZ, this._scene.getEngine().isNDCHalfZRange);\n                scene.setTransformMatrix(this._viewMatrix, this._projectionMatrix);\n                if (scene.activeCamera.isRigCamera && !this._renderTargetTexture.activeCamera) {\n                    this._renderTargetTexture.activeCamera = scene.activeCamera.rigParent || null;\n                }\n            }\n            scene._forcedViewPosition = this.position;\n        });\n        let currentApplyByPostProcess;\n        this._renderTargetTexture.onBeforeBindObservable.add(() => {\n            var _a, _b;\n            this._currentSceneUBO = scene.getSceneUniformBuffer();\n            (_b = (_a = scene.getEngine())._debugPushGroup) === null || _b === void 0 ? void 0 : _b.call(_a, `reflection probe generation for ${name}`, 1);\n            currentApplyByPostProcess = this._scene.imageProcessingConfiguration.applyByPostProcess;\n            if (linearSpace) {\n                scene.imageProcessingConfiguration.applyByPostProcess = true;\n            }\n        });\n        this._renderTargetTexture.onAfterUnbindObservable.add(() => {\n            var _a, _b;\n            scene.imageProcessingConfiguration.applyByPostProcess = currentApplyByPostProcess;\n            scene._forcedViewPosition = null;\n            if (this._sceneUBOs) {\n                scene.setSceneUniformBuffer(this._currentSceneUBO);\n            }\n            scene.updateTransformMatrix(true);\n            (_b = (_a = scene.getEngine())._debugPopGroup) === null || _b === void 0 ? void 0 : _b.call(_a, 1);\n        });\n    }\n    /** Gets or sets the number of samples to use for multi-sampling (0 by default). Required WebGL2 */\n    get samples() {\n        return this._renderTargetTexture.samples;\n    }\n    set samples(value) {\n        this._renderTargetTexture.samples = value;\n    }\n    /** Gets or sets the refresh rate to use (on every frame by default) */\n    get refreshRate() {\n        return this._renderTargetTexture.refreshRate;\n    }\n    set refreshRate(value) {\n        this._renderTargetTexture.refreshRate = value;\n    }\n    /**\n     * Gets the hosting scene\n     * @returns a Scene\n     */\n    getScene() {\n        return this._scene;\n    }\n    /** Gets the internal CubeTexture used to render to */\n    get cubeTexture() {\n        return this._renderTargetTexture;\n    }\n    /** Gets the list of meshes to render */\n    get renderList() {\n        return this._renderTargetTexture.renderList;\n    }\n    /**\n     * Attach the probe to a specific mesh (Rendering will be done from attached mesh's position)\n     * @param mesh defines the mesh to attach to\n     */\n    attachToMesh(mesh) {\n        this._attachedMesh = mesh;\n    }\n    /**\n     * Specifies whether or not the stencil and depth buffer are cleared between two rendering groups\n     * @param renderingGroupId The rendering group id corresponding to its index\n     * @param autoClearDepthStencil Automatically clears depth and stencil between groups if true.\n     */\n    setRenderingAutoClearDepthStencil(renderingGroupId, autoClearDepthStencil) {\n        this._renderTargetTexture.setRenderingAutoClearDepthStencil(renderingGroupId, autoClearDepthStencil);\n    }\n    /**\n     * Clean all associated resources\n     */\n    dispose() {\n        const index = this._scene.reflectionProbes.indexOf(this);\n        if (index !== -1) {\n            // Remove from the scene if found\n            this._scene.reflectionProbes.splice(index, 1);\n        }\n        if (this._parentContainer) {\n            const index = this._parentContainer.reflectionProbes.indexOf(this);\n            if (index > -1) {\n                this._parentContainer.reflectionProbes.splice(index, 1);\n            }\n            this._parentContainer = null;\n        }\n        if (this._renderTargetTexture) {\n            this._renderTargetTexture.dispose();\n            this._renderTargetTexture = null;\n        }\n        if (this._sceneUBOs) {\n            for (const ubo of this._sceneUBOs) {\n                ubo.dispose();\n            }\n            this._sceneUBOs = [];\n        }\n    }\n    /**\n     * Converts the reflection probe information to a readable string for debug purpose.\n     * @param fullDetails Supports for multiple levels of logging within scene loading\n     * @returns the human readable reflection probe info\n     */\n    toString(fullDetails) {\n        let ret = \"Name: \" + this.name;\n        if (fullDetails) {\n            ret += \", position: \" + this.position.toString();\n            if (this._attachedMesh) {\n                ret += \", attached mesh: \" + this._attachedMesh.name;\n            }\n        }\n        return ret;\n    }\n    /**\n     * Get the class name of the refection probe.\n     * @returns \"ReflectionProbe\"\n     */\n    getClassName() {\n        return \"ReflectionProbe\";\n    }\n    /**\n     * Serialize the reflection probe to a JSON representation we can easily use in the respective Parse function.\n     * @returns The JSON representation of the texture\n     */\n    serialize() {\n        const serializationObject = SerializationHelper.Serialize(this, this._renderTargetTexture.serialize());\n        serializationObject.isReflectionProbe = true;\n        serializationObject.metadata = this.metadata;\n        return serializationObject;\n    }\n    /**\n     * Parse the JSON representation of a reflection probe in order to recreate the reflection probe in the given scene.\n     * @param parsedReflectionProbe Define the JSON representation of the reflection probe\n     * @param scene Define the scene the parsed reflection probe should be instantiated in\n     * @param rootUrl Define the root url of the parsing sequence in the case of relative dependencies\n     * @returns The parsed reflection probe if successful\n     */\n    static Parse(parsedReflectionProbe, scene, rootUrl) {\n        let reflectionProbe = null;\n        if (scene.reflectionProbes) {\n            for (let index = 0; index < scene.reflectionProbes.length; index++) {\n                const rp = scene.reflectionProbes[index];\n                if (rp.name === parsedReflectionProbe.name) {\n                    reflectionProbe = rp;\n                    break;\n                }\n            }\n        }\n        reflectionProbe = SerializationHelper.Parse(() => reflectionProbe || new ReflectionProbe(parsedReflectionProbe.name, parsedReflectionProbe.renderTargetSize, scene, parsedReflectionProbe._generateMipMaps), parsedReflectionProbe, scene, rootUrl);\n        reflectionProbe.cubeTexture._waitingRenderList = parsedReflectionProbe.renderList;\n        if (parsedReflectionProbe._attachedMesh) {\n            reflectionProbe.attachToMesh(scene.getMeshById(parsedReflectionProbe._attachedMesh));\n        }\n        if (parsedReflectionProbe.metadata) {\n            reflectionProbe.metadata = parsedReflectionProbe.metadata;\n        }\n        return reflectionProbe;\n    }\n}\n__decorate([\n    serializeAsMeshReference()\n], ReflectionProbe.prototype, \"_attachedMesh\", void 0);\n__decorate([\n    serializeAsVector3()\n], ReflectionProbe.prototype, \"position\", void 0);\n//# sourceMappingURL=reflectionProbe.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nconst name = \"boundingBoxRendererFragmentDeclaration\";\nconst shader = `uniform vec4 color;\r`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const boundingBoxRendererFragmentDeclaration = { name, shader };\n//# sourceMappingURL=boundingBoxRendererFragmentDeclaration.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nconst name = \"boundingBoxRendererUboDeclaration\";\nconst shader = `#ifdef WEBGL2\nuniform vec4 color;\runiform mat4 world;\runiform mat4 viewProjection;\r#ifdef MULTIVIEW\nuniform mat4 viewProjectionR;\r#endif\n#else\nlayout(std140,column_major) uniform;\runiform BoundingBoxRenderer {\rvec4 color;\rmat4 world;\rmat4 viewProjection;\rmat4 viewProjectionR;\r};\r#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const boundingBoxRendererUboDeclaration = { name, shader };\n//# sourceMappingURL=boundingBoxRendererUboDeclaration.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nimport \"./ShadersInclude/boundingBoxRendererFragmentDeclaration.js\";\nimport \"./ShadersInclude/boundingBoxRendererUboDeclaration.js\";\nconst name = \"boundingBoxRendererPixelShader\";\nconst shader = `#include<__decl__boundingBoxRendererFragment>\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) {\r#define CUSTOM_FRAGMENT_MAIN_BEGIN\ngl_FragColor=color;\r#define CUSTOM_FRAGMENT_MAIN_END\n}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const boundingBoxRendererPixelShader = { name, shader };\n//# sourceMappingURL=boundingBoxRenderer.fragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nconst name = \"boundingBoxRendererVertexDeclaration\";\nconst shader = `uniform mat4 world;\runiform mat4 viewProjection;\r#ifdef MULTIVIEW\nuniform mat4 viewProjectionR;\r#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const boundingBoxRendererVertexDeclaration = { name, shader };\n//# sourceMappingURL=boundingBoxRendererVertexDeclaration.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nimport \"./ShadersInclude/boundingBoxRendererVertexDeclaration.js\";\nimport \"./ShadersInclude/boundingBoxRendererUboDeclaration.js\";\nconst name = \"boundingBoxRendererVertexShader\";\nconst shader = `attribute vec3 position;\r#include<__decl__boundingBoxRendererVertex>\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void) {\r#define CUSTOM_VERTEX_MAIN_BEGIN\nvec4 worldPos=world*vec4(position,1.0);\r#ifdef MULTIVIEW\nif (gl_ViewID_OVR==0u) {\rgl_Position=viewProjection*worldPos;\r} else {\rgl_Position=viewProjectionR*worldPos;\r}\r#else\ngl_Position=viewProjection*worldPos;\r#endif\n#define CUSTOM_VERTEX_MAIN_END\n}\r`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const boundingBoxRendererVertexShader = { name, shader };\n//# sourceMappingURL=boundingBoxRenderer.vertex.js.map","import { Scene } from \"../scene.js\";\nimport { VertexBuffer } from \"../Buffers/buffer.js\";\nimport { AbstractMesh } from \"../Meshes/abstractMesh.js\";\nimport { Matrix } from \"../Maths/math.vector.js\";\nimport { SmartArray } from \"../Misc/smartArray.js\";\nimport { SceneComponentConstants } from \"../sceneComponent.js\";\nimport { Material } from \"../Materials/material.js\";\nimport { ShaderMaterial } from \"../Materials/shaderMaterial.js\";\nimport { Color3 } from \"../Maths/math.color.js\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { DrawWrapper } from \"../Materials/drawWrapper.js\";\nimport { UniformBuffer } from \"../Materials/uniformBuffer.js\";\nimport { CreateBoxVertexData } from \"../Meshes/Builders/boxBuilder.js\";\nimport \"../Shaders/boundingBoxRenderer.fragment.js\";\nimport \"../Shaders/boundingBoxRenderer.vertex.js\";\nObject.defineProperty(Scene.prototype, \"forceShowBoundingBoxes\", {\n    get: function () {\n        return this._forceShowBoundingBoxes || false;\n    },\n    set: function (value) {\n        this._forceShowBoundingBoxes = value;\n        // Lazyly creates a BB renderer if needed.\n        if (value) {\n            this.getBoundingBoxRenderer();\n        }\n    },\n    enumerable: true,\n    configurable: true,\n});\nScene.prototype.getBoundingBoxRenderer = function () {\n    if (!this._boundingBoxRenderer) {\n        this._boundingBoxRenderer = new BoundingBoxRenderer(this);\n    }\n    return this._boundingBoxRenderer;\n};\nObject.defineProperty(AbstractMesh.prototype, \"showBoundingBox\", {\n    get: function () {\n        return this._showBoundingBox || false;\n    },\n    set: function (value) {\n        this._showBoundingBox = value;\n        // Lazyly creates a BB renderer if needed.\n        if (value) {\n            this.getScene().getBoundingBoxRenderer();\n        }\n    },\n    enumerable: true,\n    configurable: true,\n});\n/**\n * Component responsible of rendering the bounding box of the meshes in a scene.\n * This is usually used through the mesh.showBoundingBox or the scene.forceShowBoundingBoxes properties\n */\nexport class BoundingBoxRenderer {\n    /**\n     * Instantiates a new bounding box renderer in a scene.\n     * @param scene the scene the  renderer renders in\n     */\n    constructor(scene) {\n        /**\n         * The component name helpful to identify the component in the list of scene components.\n         */\n        this.name = SceneComponentConstants.NAME_BOUNDINGBOXRENDERER;\n        /**\n         * Color of the bounding box lines placed in front of an object\n         */\n        this.frontColor = new Color3(1, 1, 1);\n        /**\n         * Color of the bounding box lines placed behind an object\n         */\n        this.backColor = new Color3(0.1, 0.1, 0.1);\n        /**\n         * Defines if the renderer should show the back lines or not\n         */\n        this.showBackLines = true;\n        /**\n         * Observable raised before rendering a bounding box\n         */\n        this.onBeforeBoxRenderingObservable = new Observable();\n        /**\n         * Observable raised after rendering a bounding box\n         */\n        this.onAfterBoxRenderingObservable = new Observable();\n        /**\n         * Observable raised after resources are created\n         */\n        this.onResourcesReadyObservable = new Observable();\n        /**\n         * When false, no bounding boxes will be rendered\n         */\n        this.enabled = true;\n        /**\n         * @internal\n         */\n        this.renderList = new SmartArray(32);\n        this._vertexBuffers = {};\n        this._fillIndexBuffer = null;\n        this._fillIndexData = null;\n        this.scene = scene;\n        scene._addComponent(this);\n        this._uniformBufferFront = new UniformBuffer(this.scene.getEngine(), undefined, undefined, \"BoundingBoxRendererFront\", !this.scene.getEngine().isWebGPU);\n        this._buildUniformLayout(this._uniformBufferFront);\n        this._uniformBufferBack = new UniformBuffer(this.scene.getEngine(), undefined, undefined, \"BoundingBoxRendererBack\", !this.scene.getEngine().isWebGPU);\n        this._buildUniformLayout(this._uniformBufferBack);\n    }\n    _buildUniformLayout(ubo) {\n        ubo.addUniform(\"color\", 4);\n        ubo.addUniform(\"world\", 16);\n        ubo.addUniform(\"viewProjection\", 16);\n        ubo.addUniform(\"viewProjectionR\", 16);\n        ubo.create();\n    }\n    /**\n     * Registers the component in a given scene\n     */\n    register() {\n        this.scene._beforeEvaluateActiveMeshStage.registerStep(SceneComponentConstants.STEP_BEFOREEVALUATEACTIVEMESH_BOUNDINGBOXRENDERER, this, this.reset);\n        this.scene._preActiveMeshStage.registerStep(SceneComponentConstants.STEP_PREACTIVEMESH_BOUNDINGBOXRENDERER, this, this._preActiveMesh);\n        this.scene._evaluateSubMeshStage.registerStep(SceneComponentConstants.STEP_EVALUATESUBMESH_BOUNDINGBOXRENDERER, this, this._evaluateSubMesh);\n        this.scene._afterRenderingGroupDrawStage.registerStep(SceneComponentConstants.STEP_AFTERRENDERINGGROUPDRAW_BOUNDINGBOXRENDERER, this, this.render);\n    }\n    _evaluateSubMesh(mesh, subMesh) {\n        if (mesh.showSubMeshesBoundingBox) {\n            const boundingInfo = subMesh.getBoundingInfo();\n            if (boundingInfo !== null && boundingInfo !== undefined) {\n                boundingInfo.boundingBox._tag = mesh.renderingGroupId;\n                this.renderList.push(boundingInfo.boundingBox);\n            }\n        }\n    }\n    _preActiveMesh(mesh) {\n        if (mesh.showBoundingBox || this.scene.forceShowBoundingBoxes) {\n            const boundingInfo = mesh.getBoundingInfo();\n            boundingInfo.boundingBox._tag = mesh.renderingGroupId;\n            this.renderList.push(boundingInfo.boundingBox);\n        }\n    }\n    _prepareResources() {\n        if (this._colorShader) {\n            return;\n        }\n        this._colorShader = new ShaderMaterial(\"colorShader\", this.scene, \"boundingBoxRenderer\", {\n            attributes: [VertexBuffer.PositionKind],\n            uniforms: [\"world\", \"viewProjection\", \"viewProjectionR\", \"color\"],\n            uniformBuffers: [\"BoundingBoxRenderer\"],\n        }, false);\n        this._colorShader.doNotSerialize = true;\n        this._colorShader.reservedDataStore = {\n            hidden: true,\n        };\n        this._colorShaderForOcclusionQuery = new ShaderMaterial(\"colorShaderOccQuery\", this.scene, \"boundingBoxRenderer\", {\n            attributes: [VertexBuffer.PositionKind],\n            uniforms: [\"world\", \"viewProjection\", \"viewProjectionR\", \"color\"],\n            uniformBuffers: [\"BoundingBoxRenderer\"],\n        }, true);\n        this._colorShaderForOcclusionQuery.doNotSerialize = true;\n        this._colorShaderForOcclusionQuery.reservedDataStore = {\n            hidden: true,\n        };\n        const engine = this.scene.getEngine();\n        const boxdata = CreateBoxVertexData({ size: 1.0 });\n        this._vertexBuffers[VertexBuffer.PositionKind] = new VertexBuffer(engine, boxdata.positions, VertexBuffer.PositionKind, false);\n        this._createIndexBuffer();\n        this._fillIndexData = boxdata.indices;\n        this.onResourcesReadyObservable.notifyObservers(this);\n    }\n    _createIndexBuffer() {\n        const engine = this.scene.getEngine();\n        this._indexBuffer = engine.createIndexBuffer([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 7, 1, 6, 2, 5, 3, 4]);\n    }\n    /**\n     * Rebuilds the elements related to this component in case of\n     * context lost for instance.\n     */\n    rebuild() {\n        const vb = this._vertexBuffers[VertexBuffer.PositionKind];\n        if (vb) {\n            vb._rebuild();\n        }\n        this._createIndexBuffer();\n    }\n    /**\n     * @internal\n     */\n    reset() {\n        this.renderList.reset();\n    }\n    /**\n     * Render the bounding boxes of a specific rendering group\n     * @param renderingGroupId defines the rendering group to render\n     */\n    render(renderingGroupId) {\n        var _a, _b;\n        if (this.renderList.length === 0 || !this.enabled) {\n            return;\n        }\n        this._prepareResources();\n        if (!this._colorShader.isReady()) {\n            return;\n        }\n        const engine = this.scene.getEngine();\n        engine.setDepthWrite(false);\n        const frontColor = this.frontColor.toColor4();\n        const backColor = this.backColor.toColor4();\n        const transformMatrix = this.scene.getTransformMatrix();\n        for (let boundingBoxIndex = 0; boundingBoxIndex < this.renderList.length; boundingBoxIndex++) {\n            const boundingBox = this.renderList.data[boundingBoxIndex];\n            if (boundingBox._tag !== renderingGroupId) {\n                continue;\n            }\n            this._createWrappersForBoundingBox(boundingBox);\n            this.onBeforeBoxRenderingObservable.notifyObservers(boundingBox);\n            const min = boundingBox.minimum;\n            const max = boundingBox.maximum;\n            const diff = max.subtract(min);\n            const median = min.add(diff.scale(0.5));\n            const worldMatrix = Matrix.Scaling(diff.x, diff.y, diff.z).multiply(Matrix.Translation(median.x, median.y, median.z)).multiply(boundingBox.getWorldMatrix());\n            const useReverseDepthBuffer = engine.useReverseDepthBuffer;\n            if (this.showBackLines) {\n                const drawWrapperBack = (_a = boundingBox._drawWrapperBack) !== null && _a !== void 0 ? _a : this._colorShader._getDrawWrapper();\n                this._colorShader._preBind(drawWrapperBack);\n                engine.bindBuffers(this._vertexBuffers, this._indexBuffer, this._colorShader.getEffect());\n                // Back\n                if (useReverseDepthBuffer) {\n                    engine.setDepthFunctionToLessOrEqual();\n                }\n                else {\n                    engine.setDepthFunctionToGreaterOrEqual();\n                }\n                this._uniformBufferBack.bindToEffect(drawWrapperBack.effect, \"BoundingBoxRenderer\");\n                this._uniformBufferBack.updateDirectColor4(\"color\", backColor);\n                this._uniformBufferBack.updateMatrix(\"world\", worldMatrix);\n                this._uniformBufferBack.updateMatrix(\"viewProjection\", transformMatrix);\n                this._uniformBufferBack.update();\n                // Draw order\n                engine.drawElementsType(Material.LineListDrawMode, 0, 24);\n            }\n            const drawWrapperFront = (_b = boundingBox._drawWrapperFront) !== null && _b !== void 0 ? _b : this._colorShader._getDrawWrapper();\n            this._colorShader._preBind(drawWrapperFront);\n            engine.bindBuffers(this._vertexBuffers, this._indexBuffer, this._colorShader.getEffect());\n            // Front\n            if (useReverseDepthBuffer) {\n                engine.setDepthFunctionToGreater();\n            }\n            else {\n                engine.setDepthFunctionToLess();\n            }\n            this._uniformBufferFront.bindToEffect(drawWrapperFront.effect, \"BoundingBoxRenderer\");\n            this._uniformBufferFront.updateDirectColor4(\"color\", frontColor);\n            this._uniformBufferFront.updateMatrix(\"world\", worldMatrix);\n            this._uniformBufferFront.updateMatrix(\"viewProjection\", transformMatrix);\n            this._uniformBufferFront.update();\n            // Draw order\n            engine.drawElementsType(Material.LineListDrawMode, 0, 24);\n            this.onAfterBoxRenderingObservable.notifyObservers(boundingBox);\n        }\n        this._colorShader.unbind();\n        engine.setDepthFunctionToLessOrEqual();\n        engine.setDepthWrite(true);\n    }\n    _createWrappersForBoundingBox(boundingBox) {\n        if (!boundingBox._drawWrapperFront) {\n            const engine = this.scene.getEngine();\n            boundingBox._drawWrapperFront = new DrawWrapper(engine);\n            boundingBox._drawWrapperBack = new DrawWrapper(engine);\n            boundingBox._drawWrapperFront.setEffect(this._colorShader.getEffect());\n            boundingBox._drawWrapperBack.setEffect(this._colorShader.getEffect());\n        }\n    }\n    /**\n     * In case of occlusion queries, we can render the occlusion bounding box through this method\n     * @param mesh Define the mesh to render the occlusion bounding box for\n     */\n    renderOcclusionBoundingBox(mesh) {\n        const engine = this.scene.getEngine();\n        if (this._renderPassIdForOcclusionQuery === undefined) {\n            this._renderPassIdForOcclusionQuery = engine.createRenderPassId(`Render pass for occlusion query`);\n        }\n        const currentRenderPassId = engine.currentRenderPassId;\n        engine.currentRenderPassId = this._renderPassIdForOcclusionQuery;\n        this._prepareResources();\n        const subMesh = mesh.subMeshes[0];\n        if (!this._colorShaderForOcclusionQuery.isReady(mesh, undefined, subMesh) || !mesh.hasBoundingInfo) {\n            engine.currentRenderPassId = currentRenderPassId;\n            return;\n        }\n        if (!this._fillIndexBuffer) {\n            this._fillIndexBuffer = engine.createIndexBuffer(this._fillIndexData);\n        }\n        const useReverseDepthBuffer = engine.useReverseDepthBuffer;\n        engine.setDepthWrite(false);\n        engine.setColorWrite(false);\n        const boundingBox = mesh.getBoundingInfo().boundingBox;\n        const min = boundingBox.minimum;\n        const max = boundingBox.maximum;\n        const diff = max.subtract(min);\n        const median = min.add(diff.scale(0.5));\n        const worldMatrix = Matrix.Scaling(diff.x, diff.y, diff.z).multiply(Matrix.Translation(median.x, median.y, median.z)).multiply(boundingBox.getWorldMatrix());\n        const drawWrapper = subMesh._drawWrapper;\n        this._colorShaderForOcclusionQuery._preBind(drawWrapper);\n        engine.bindBuffers(this._vertexBuffers, this._fillIndexBuffer, drawWrapper.effect);\n        if (useReverseDepthBuffer) {\n            engine.setDepthFunctionToGreater();\n        }\n        else {\n            engine.setDepthFunctionToLess();\n        }\n        this.scene.resetCachedMaterial();\n        this._uniformBufferFront.bindToEffect(drawWrapper.effect, \"BoundingBoxRenderer\");\n        this._uniformBufferFront.updateMatrix(\"world\", worldMatrix);\n        this._uniformBufferFront.updateMatrix(\"viewProjection\", this.scene.getTransformMatrix());\n        this._uniformBufferFront.update();\n        engine.drawElementsType(Material.TriangleFillMode, 0, 36);\n        this._colorShaderForOcclusionQuery.unbind();\n        engine.setDepthFunctionToLessOrEqual();\n        engine.setDepthWrite(true);\n        engine.setColorWrite(true);\n        engine.currentRenderPassId = currentRenderPassId;\n    }\n    /**\n     * Dispose and release the resources attached to this renderer.\n     */\n    dispose() {\n        if (this._renderPassIdForOcclusionQuery !== undefined) {\n            this.scene.getEngine().releaseRenderPassId(this._renderPassIdForOcclusionQuery);\n            this._renderPassIdForOcclusionQuery = undefined;\n        }\n        if (!this._colorShader) {\n            return;\n        }\n        this.onBeforeBoxRenderingObservable.clear();\n        this.onAfterBoxRenderingObservable.clear();\n        this.onResourcesReadyObservable.clear();\n        this.renderList.dispose();\n        this._colorShader.dispose();\n        this._colorShaderForOcclusionQuery.dispose();\n        this._uniformBufferFront.dispose();\n        this._uniformBufferBack.dispose();\n        const buffer = this._vertexBuffers[VertexBuffer.PositionKind];\n        if (buffer) {\n            buffer.dispose();\n            this._vertexBuffers[VertexBuffer.PositionKind] = null;\n        }\n        this.scene.getEngine()._releaseBuffer(this._indexBuffer);\n        if (this._fillIndexBuffer) {\n            this.scene.getEngine()._releaseBuffer(this._fillIndexBuffer);\n            this._fillIndexBuffer = null;\n        }\n    }\n}\n//# sourceMappingURL=boundingBoxRenderer.js.map","import { Color4 } from \"../Maths/math.color.js\";\nimport { VertexBuffer } from \"../Buffers/buffer.js\";\nimport { Texture } from \"../Materials/Textures/texture.js\";\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture.js\";\nimport { MaterialHelper } from \"../Materials/materialHelper.js\";\nimport { Camera } from \"../Cameras/camera.js\";\n\nimport \"../Shaders/depth.fragment.js\";\nimport \"../Shaders/depth.vertex.js\";\nimport { _WarnImport } from \"../Misc/devTools.js\";\nimport { addClipPlaneUniforms, bindClipPlane, prepareDefinesForClipPlanes } from \"../Materials/clipPlaneMaterialHelper.js\";\n/**\n * This represents a depth renderer in Babylon.\n * A depth renderer will render to it's depth map every frame which can be displayed or used in post processing\n */\nexport class DepthRenderer {\n    /**\n     * Sets a specific material to be used to render a mesh/a list of meshes by the depth renderer\n     * @param mesh mesh or array of meshes\n     * @param material material to use by the depth render when rendering the mesh(es). If undefined is passed, the specific material created by the depth renderer will be used.\n     */\n    setMaterialForRendering(mesh, material) {\n        this._depthMap.setMaterialForRendering(mesh, material);\n    }\n    /**\n     * Instantiates a depth renderer\n     * @param scene The scene the renderer belongs to\n     * @param type The texture type of the depth map (default: Engine.TEXTURETYPE_FLOAT)\n     * @param camera The camera to be used to render the depth map (default: scene's active camera)\n     * @param storeNonLinearDepth Defines whether the depth is stored linearly like in Babylon Shadows or directly like glFragCoord.z\n     * @param samplingMode The sampling mode to be used with the render target (Linear, Nearest...) (default: TRILINEAR_SAMPLINGMODE)\n     * @param storeCameraSpaceZ Defines whether the depth stored is the Z coordinate in camera space. If true, storeNonLinearDepth has no effect. (Default: false)\n     * @param name Name of the render target (default: DepthRenderer)\n     */\n    constructor(scene, type = 1, camera = null, storeNonLinearDepth = false, samplingMode = Texture.TRILINEAR_SAMPLINGMODE, storeCameraSpaceZ = false, name) {\n        /** Enable or disable the depth renderer. When disabled, the depth texture is not updated */\n        this.enabled = true;\n        /** Force writing the transparent objects into the depth map */\n        this.forceDepthWriteTransparentMeshes = false;\n        /**\n         * Specifies that the depth renderer will only be used within\n         * the camera it is created for.\n         * This can help forcing its rendering during the camera processing.\n         */\n        this.useOnlyInActiveCamera = false;\n        /** If true, reverse the culling of materials before writing to the depth texture.\n         * So, basically, when \"true\", back facing instead of front facing faces are rasterized into the texture\n         */\n        this.reverseCulling = false;\n        this._scene = scene;\n        this._storeNonLinearDepth = storeNonLinearDepth;\n        this._storeCameraSpaceZ = storeCameraSpaceZ;\n        this.isPacked = type === 0;\n        if (this.isPacked) {\n            this.clearColor = new Color4(1.0, 1.0, 1.0, 1.0);\n        }\n        else {\n            this.clearColor = new Color4(1.0, 0.0, 0.0, 1.0);\n        }\n        DepthRenderer._SceneComponentInitialization(this._scene);\n        const engine = scene.getEngine();\n        this._camera = camera;\n        if (samplingMode !== Texture.NEAREST_SAMPLINGMODE) {\n            if (type === 1 && !engine._caps.textureFloatLinearFiltering) {\n                samplingMode = Texture.NEAREST_SAMPLINGMODE;\n            }\n            if (type === 2 && !engine._caps.textureHalfFloatLinearFiltering) {\n                samplingMode = Texture.NEAREST_SAMPLINGMODE;\n            }\n        }\n        // Render target\n        const format = this.isPacked || !engine._features.supportExtendedTextureFormats ? 5 : 6;\n        this._depthMap = new RenderTargetTexture(name !== null && name !== void 0 ? name : \"DepthRenderer\", { width: engine.getRenderWidth(), height: engine.getRenderHeight() }, this._scene, false, true, type, false, samplingMode, undefined, undefined, undefined, format);\n        this._depthMap.wrapU = Texture.CLAMP_ADDRESSMODE;\n        this._depthMap.wrapV = Texture.CLAMP_ADDRESSMODE;\n        this._depthMap.refreshRate = 1;\n        this._depthMap.renderParticles = false;\n        this._depthMap.renderList = null;\n        // Camera to get depth map from to support multiple concurrent cameras\n        this._depthMap.activeCamera = this._camera;\n        this._depthMap.ignoreCameraViewport = true;\n        this._depthMap.useCameraPostProcesses = false;\n        // set default depth value to 1.0 (far away)\n        this._depthMap.onClearObservable.add((engine) => {\n            engine.clear(this.clearColor, true, true, true);\n        });\n        this._depthMap.onBeforeBindObservable.add(() => {\n            var _a;\n            (_a = engine._debugPushGroup) === null || _a === void 0 ? void 0 : _a.call(engine, \"depth renderer\", 1);\n        });\n        this._depthMap.onAfterUnbindObservable.add(() => {\n            var _a;\n            (_a = engine._debugPopGroup) === null || _a === void 0 ? void 0 : _a.call(engine, 1);\n        });\n        this._depthMap.customIsReadyFunction = (mesh, refreshRate, preWarm) => {\n            if ((preWarm || refreshRate === 0) && mesh.subMeshes) {\n                for (let i = 0; i < mesh.subMeshes.length; ++i) {\n                    const subMesh = mesh.subMeshes[i];\n                    const renderingMesh = subMesh.getRenderingMesh();\n                    const batch = renderingMesh._getInstancesRenderList(subMesh._id, !!subMesh.getReplacementMesh());\n                    const hardwareInstancedRendering = engine.getCaps().instancedArrays &&\n                        ((batch.visibleInstances[subMesh._id] !== null && batch.visibleInstances[subMesh._id] !== undefined) || renderingMesh.hasThinInstances);\n                    if (!this.isReady(subMesh, hardwareInstancedRendering)) {\n                        return false;\n                    }\n                }\n            }\n            return true;\n        };\n        // Custom render function\n        const renderSubMesh = (subMesh) => {\n            var _a, _b;\n            const renderingMesh = subMesh.getRenderingMesh();\n            const effectiveMesh = subMesh.getEffectiveMesh();\n            const scene = this._scene;\n            const engine = scene.getEngine();\n            const material = subMesh.getMaterial();\n            effectiveMesh._internalAbstractMeshDataInfo._isActiveIntermediate = false;\n            if (!material || effectiveMesh.infiniteDistance || material.disableDepthWrite || subMesh.verticesCount === 0 || subMesh._renderId === scene.getRenderId()) {\n                return;\n            }\n            // Culling\n            const detNeg = effectiveMesh._getWorldMatrixDeterminant() < 0;\n            let sideOrientation = (_a = renderingMesh.overrideMaterialSideOrientation) !== null && _a !== void 0 ? _a : material.sideOrientation;\n            if (detNeg) {\n                sideOrientation =\n                    sideOrientation === 0\n                        ? 1\n                        : 0;\n            }\n            const reverseSideOrientation = sideOrientation === 0;\n            engine.setState(material.backFaceCulling, 0, false, reverseSideOrientation, this.reverseCulling ? !material.cullBackFaces : material.cullBackFaces);\n            // Managing instances\n            const batch = renderingMesh._getInstancesRenderList(subMesh._id, !!subMesh.getReplacementMesh());\n            if (batch.mustReturn) {\n                return;\n            }\n            const hardwareInstancedRendering = engine.getCaps().instancedArrays &&\n                ((batch.visibleInstances[subMesh._id] !== null && batch.visibleInstances[subMesh._id] !== undefined) || renderingMesh.hasThinInstances);\n            const camera = this._camera || scene.activeCamera;\n            if (this.isReady(subMesh, hardwareInstancedRendering) && camera) {\n                subMesh._renderId = scene.getRenderId();\n                const renderingMaterial = (_b = effectiveMesh._internalAbstractMeshDataInfo._materialForRenderPass) === null || _b === void 0 ? void 0 : _b[engine.currentRenderPassId];\n                let drawWrapper = subMesh._getDrawWrapper();\n                if (!drawWrapper && renderingMaterial) {\n                    drawWrapper = renderingMaterial._getDrawWrapper();\n                }\n                const cameraIsOrtho = camera.mode === Camera.ORTHOGRAPHIC_CAMERA;\n                if (!drawWrapper) {\n                    return;\n                }\n                const effect = drawWrapper.effect;\n                engine.enableEffect(drawWrapper);\n                if (!hardwareInstancedRendering) {\n                    renderingMesh._bind(subMesh, effect, material.fillMode);\n                }\n                if (!renderingMaterial) {\n                    effect.setMatrix(\"viewProjection\", scene.getTransformMatrix());\n                    effect.setMatrix(\"world\", effectiveMesh.getWorldMatrix());\n                    if (this._storeCameraSpaceZ) {\n                        effect.setMatrix(\"view\", scene.getViewMatrix());\n                    }\n                }\n                else {\n                    renderingMaterial.bindForSubMesh(effectiveMesh.getWorldMatrix(), effectiveMesh, subMesh);\n                }\n                let minZ, maxZ;\n                if (cameraIsOrtho) {\n                    minZ = !engine.useReverseDepthBuffer && engine.isNDCHalfZRange ? 0 : 1;\n                    maxZ = engine.useReverseDepthBuffer && engine.isNDCHalfZRange ? 0 : 1;\n                }\n                else {\n                    minZ = engine.useReverseDepthBuffer && engine.isNDCHalfZRange ? camera.minZ : engine.isNDCHalfZRange ? 0 : camera.minZ;\n                    maxZ = engine.useReverseDepthBuffer && engine.isNDCHalfZRange ? 0 : camera.maxZ;\n                }\n                effect.setFloat2(\"depthValues\", minZ, minZ + maxZ);\n                if (!renderingMaterial) {\n                    // Alpha test\n                    if (material.needAlphaTesting()) {\n                        const alphaTexture = material.getAlphaTestTexture();\n                        if (alphaTexture) {\n                            effect.setTexture(\"diffuseSampler\", alphaTexture);\n                            effect.setMatrix(\"diffuseMatrix\", alphaTexture.getTextureMatrix());\n                        }\n                    }\n                    // Bones\n                    if (renderingMesh.useBones && renderingMesh.computeBonesUsingShaders && renderingMesh.skeleton) {\n                        const skeleton = renderingMesh.skeleton;\n                        if (skeleton.isUsingTextureForMatrices) {\n                            const boneTexture = skeleton.getTransformMatrixTexture(renderingMesh);\n                            if (!boneTexture) {\n                                return;\n                            }\n                            effect.setTexture(\"boneSampler\", boneTexture);\n                            effect.setFloat(\"boneTextureWidth\", 4.0 * (skeleton.bones.length + 1));\n                        }\n                        else {\n                            effect.setMatrices(\"mBones\", skeleton.getTransformMatrices(renderingMesh));\n                        }\n                    }\n                    // Clip planes\n                    bindClipPlane(effect, material, scene);\n                    // Morph targets\n                    MaterialHelper.BindMorphTargetParameters(renderingMesh, effect);\n                    if (renderingMesh.morphTargetManager && renderingMesh.morphTargetManager.isUsingTextureForTargets) {\n                        renderingMesh.morphTargetManager._bind(effect);\n                    }\n                }\n                // Draw\n                renderingMesh._processRendering(effectiveMesh, subMesh, effect, material.fillMode, batch, hardwareInstancedRendering, (isInstance, world) => effect.setMatrix(\"world\", world));\n            }\n        };\n        this._depthMap.customRenderFunction = (opaqueSubMeshes, alphaTestSubMeshes, transparentSubMeshes, depthOnlySubMeshes) => {\n            let index;\n            if (depthOnlySubMeshes.length) {\n                for (index = 0; index < depthOnlySubMeshes.length; index++) {\n                    renderSubMesh(depthOnlySubMeshes.data[index]);\n                }\n            }\n            for (index = 0; index < opaqueSubMeshes.length; index++) {\n                renderSubMesh(opaqueSubMeshes.data[index]);\n            }\n            for (index = 0; index < alphaTestSubMeshes.length; index++) {\n                renderSubMesh(alphaTestSubMeshes.data[index]);\n            }\n            if (this.forceDepthWriteTransparentMeshes) {\n                for (index = 0; index < transparentSubMeshes.length; index++) {\n                    renderSubMesh(transparentSubMeshes.data[index]);\n                }\n            }\n            else {\n                for (index = 0; index < transparentSubMeshes.length; index++) {\n                    transparentSubMeshes.data[index].getEffectiveMesh()._internalAbstractMeshDataInfo._isActiveIntermediate = false;\n                }\n            }\n        };\n    }\n    /**\n     * Creates the depth rendering effect and checks if the effect is ready.\n     * @param subMesh The submesh to be used to render the depth map of\n     * @param useInstances If multiple world instances should be used\n     * @returns if the depth renderer is ready to render the depth map\n     */\n    isReady(subMesh, useInstances) {\n        var _a;\n        const engine = this._scene.getEngine();\n        const mesh = subMesh.getMesh();\n        const scene = mesh.getScene();\n        const renderingMaterial = (_a = mesh._internalAbstractMeshDataInfo._materialForRenderPass) === null || _a === void 0 ? void 0 : _a[engine.currentRenderPassId];\n        if (renderingMaterial) {\n            return renderingMaterial.isReadyForSubMesh(mesh, subMesh, useInstances);\n        }\n        const material = subMesh.getMaterial();\n        if (!material || material.disableDepthWrite) {\n            return false;\n        }\n        const defines = [];\n        const attribs = [VertexBuffer.PositionKind];\n        // Alpha test\n        if (material && material.needAlphaTesting() && material.getAlphaTestTexture()) {\n            defines.push(\"#define ALPHATEST\");\n            if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {\n                attribs.push(VertexBuffer.UVKind);\n                defines.push(\"#define UV1\");\n            }\n            if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind)) {\n                attribs.push(VertexBuffer.UV2Kind);\n                defines.push(\"#define UV2\");\n            }\n        }\n        // Bones\n        if (mesh.useBones && mesh.computeBonesUsingShaders) {\n            attribs.push(VertexBuffer.MatricesIndicesKind);\n            attribs.push(VertexBuffer.MatricesWeightsKind);\n            if (mesh.numBoneInfluencers > 4) {\n                attribs.push(VertexBuffer.MatricesIndicesExtraKind);\n                attribs.push(VertexBuffer.MatricesWeightsExtraKind);\n            }\n            defines.push(\"#define NUM_BONE_INFLUENCERS \" + mesh.numBoneInfluencers);\n            defines.push(\"#define BonesPerMesh \" + (mesh.skeleton ? mesh.skeleton.bones.length + 1 : 0));\n            const skeleton = subMesh.getRenderingMesh().skeleton;\n            if (skeleton === null || skeleton === void 0 ? void 0 : skeleton.isUsingTextureForMatrices) {\n                defines.push(\"#define BONETEXTURE\");\n            }\n        }\n        else {\n            defines.push(\"#define NUM_BONE_INFLUENCERS 0\");\n        }\n        // Morph targets\n        const morphTargetManager = mesh.morphTargetManager;\n        let numMorphInfluencers = 0;\n        if (morphTargetManager) {\n            if (morphTargetManager.numInfluencers > 0) {\n                numMorphInfluencers = morphTargetManager.numInfluencers;\n                defines.push(\"#define MORPHTARGETS\");\n                defines.push(\"#define NUM_MORPH_INFLUENCERS \" + numMorphInfluencers);\n                if (morphTargetManager.isUsingTextureForTargets) {\n                    defines.push(\"#define MORPHTARGETS_TEXTURE\");\n                }\n                MaterialHelper.PrepareAttributesForMorphTargetsInfluencers(attribs, mesh, numMorphInfluencers);\n            }\n        }\n        // Instances\n        if (useInstances) {\n            defines.push(\"#define INSTANCES\");\n            MaterialHelper.PushAttributesForInstances(attribs);\n            if (subMesh.getRenderingMesh().hasThinInstances) {\n                defines.push(\"#define THIN_INSTANCES\");\n            }\n        }\n        // None linear depth\n        if (this._storeNonLinearDepth) {\n            defines.push(\"#define NONLINEARDEPTH\");\n        }\n        // Store camera space Z coordinate instead of NDC Z\n        if (this._storeCameraSpaceZ) {\n            defines.push(\"#define STORE_CAMERASPACE_Z\");\n        }\n        // Float Mode\n        if (this.isPacked) {\n            defines.push(\"#define PACKED\");\n        }\n        // Clip planes\n        prepareDefinesForClipPlanes(material, scene, defines);\n        // Get correct effect\n        const drawWrapper = subMesh._getDrawWrapper(undefined, true);\n        const cachedDefines = drawWrapper.defines;\n        const join = defines.join(\"\\n\");\n        if (cachedDefines !== join) {\n            const uniforms = [\n                \"world\",\n                \"mBones\",\n                \"boneTextureWidth\",\n                \"viewProjection\",\n                \"view\",\n                \"diffuseMatrix\",\n                \"depthValues\",\n                \"morphTargetInfluences\",\n                \"morphTargetTextureInfo\",\n                \"morphTargetTextureIndices\",\n            ];\n            addClipPlaneUniforms(uniforms);\n            drawWrapper.setEffect(engine.createEffect(\"depth\", attribs, uniforms, [\"diffuseSampler\", \"morphTargets\", \"boneSampler\"], join, undefined, undefined, undefined, {\n                maxSimultaneousMorphTargets: numMorphInfluencers,\n            }), join);\n        }\n        return drawWrapper.effect.isReady();\n    }\n    /**\n     * Gets the texture which the depth map will be written to.\n     * @returns The depth map texture\n     */\n    getDepthMap() {\n        return this._depthMap;\n    }\n    /**\n     * Disposes of the depth renderer.\n     */\n    dispose() {\n        const keysToDelete = [];\n        for (const key in this._scene._depthRenderer) {\n            const depthRenderer = this._scene._depthRenderer[key];\n            if (depthRenderer === this) {\n                keysToDelete.push(key);\n            }\n        }\n        if (keysToDelete.length > 0) {\n            this._depthMap.dispose();\n            for (const key of keysToDelete) {\n                delete this._scene._depthRenderer[key];\n            }\n        }\n    }\n}\n/**\n * @internal\n */\nDepthRenderer._SceneComponentInitialization = (_) => {\n    throw _WarnImport(\"DepthRendererSceneComponent\");\n};\n//# sourceMappingURL=depthRenderer.js.map","import { VertexBuffer } from \"../Buffers/buffer.js\";\nimport { AbstractMesh } from \"../Meshes/abstractMesh.js\";\nimport { LinesMesh, InstancedLinesMesh } from \"../Meshes/linesMesh.js\";\nimport { Vector3, TmpVectors } from \"../Maths/math.vector.js\";\nimport { Material } from \"../Materials/material.js\";\nimport { ShaderMaterial } from \"../Materials/shaderMaterial.js\";\nimport { Camera } from \"../Cameras/camera.js\";\n\nimport \"../Shaders/line.fragment.js\";\nimport \"../Shaders/line.vertex.js\";\nimport { SmartArray } from \"../Misc/smartArray.js\";\nimport { DrawWrapper } from \"../Materials/drawWrapper.js\";\nAbstractMesh.prototype.disableEdgesRendering = function () {\n    if (this._edgesRenderer) {\n        this._edgesRenderer.dispose();\n        this._edgesRenderer = null;\n    }\n    return this;\n};\nAbstractMesh.prototype.enableEdgesRendering = function (epsilon = 0.95, checkVerticesInsteadOfIndices = false, options) {\n    this.disableEdgesRendering();\n    this._edgesRenderer = new EdgesRenderer(this, epsilon, checkVerticesInsteadOfIndices, true, options);\n    return this;\n};\nObject.defineProperty(AbstractMesh.prototype, \"edgesRenderer\", {\n    get: function () {\n        return this._edgesRenderer;\n    },\n    enumerable: true,\n    configurable: true,\n});\nLinesMesh.prototype.enableEdgesRendering = function (epsilon = 0.95, checkVerticesInsteadOfIndices = false) {\n    this.disableEdgesRendering();\n    this._edgesRenderer = new LineEdgesRenderer(this, epsilon, checkVerticesInsteadOfIndices);\n    return this;\n};\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nInstancedLinesMesh.prototype.enableEdgesRendering = function (epsilon = 0.95, checkVerticesInsteadOfIndices = false) {\n    LinesMesh.prototype.enableEdgesRendering.apply(this, arguments);\n    return this;\n};\n/**\n * FaceAdjacencies Helper class to generate edges\n */\nclass FaceAdjacencies {\n    constructor() {\n        this.edges = new Array();\n        this.edgesConnectedCount = 0;\n    }\n}\n/**\n * This class is used to generate edges of the mesh that could then easily be rendered in a scene.\n */\nexport class EdgesRenderer {\n    /** Gets the vertices generated by the edge renderer */\n    get linesPositions() {\n        return this._linesPositions;\n    }\n    /** Gets the normals generated by the edge renderer */\n    get linesNormals() {\n        return this._linesNormals;\n    }\n    /** Gets the indices generated by the edge renderer */\n    get linesIndices() {\n        return this._linesIndices;\n    }\n    /**\n     * Gets or sets the shader used to draw the lines\n     */\n    get lineShader() {\n        return this._lineShader;\n    }\n    set lineShader(shader) {\n        this._lineShader = shader;\n    }\n    static _GetShader(scene) {\n        if (!scene._edgeRenderLineShader) {\n            const shader = new ShaderMaterial(\"lineShader\", scene, \"line\", {\n                attributes: [\"position\", \"normal\"],\n                uniforms: [\"world\", \"viewProjection\", \"color\", \"width\", \"aspectRatio\"],\n            }, false);\n            shader.disableDepthWrite = true;\n            shader.backFaceCulling = false;\n            shader.checkReadyOnEveryCall = scene.getEngine().isWebGPU;\n            scene._edgeRenderLineShader = shader;\n        }\n        return scene._edgeRenderLineShader;\n    }\n    /**\n     * Creates an instance of the EdgesRenderer. It is primarily use to display edges of a mesh.\n     * Beware when you use this class with complex objects as the adjacencies computation can be really long\n     * @param  source Mesh used to create edges\n     * @param  epsilon sum of angles in adjacency to check for edge\n     * @param  checkVerticesInsteadOfIndices bases the edges detection on vertices vs indices. Note that this parameter is not used if options.useAlternateEdgeFinder = true\n     * @param  generateEdgesLines - should generate Lines or only prepare resources.\n     * @param  options The options to apply when generating the edges\n     */\n    constructor(source, epsilon = 0.95, checkVerticesInsteadOfIndices = false, generateEdgesLines = true, options) {\n        var _a;\n        /**\n         * Define the size of the edges with an orthographic camera\n         */\n        this.edgesWidthScalerForOrthographic = 1000.0;\n        /**\n         * Define the size of the edges with a perspective camera\n         */\n        this.edgesWidthScalerForPerspective = 50.0;\n        this._linesPositions = new Array();\n        this._linesNormals = new Array();\n        this._linesIndices = new Array();\n        this._buffers = {};\n        this._buffersForInstances = {};\n        this._checkVerticesInsteadOfIndices = false;\n        /** Gets or sets a boolean indicating if the edgesRenderer is active */\n        this.isEnabled = true;\n        /**\n         * List of instances to render in case the source mesh has instances\n         */\n        this.customInstances = new SmartArray(32);\n        this._source = source;\n        this._checkVerticesInsteadOfIndices = checkVerticesInsteadOfIndices;\n        this._options = options !== null && options !== void 0 ? options : null;\n        this._epsilon = epsilon;\n        if (this._source.getScene().getEngine().isWebGPU) {\n            this._drawWrapper = new DrawWrapper(source.getEngine());\n        }\n        this._prepareRessources();\n        if (generateEdgesLines) {\n            if ((_a = options === null || options === void 0 ? void 0 : options.useAlternateEdgeFinder) !== null && _a !== void 0 ? _a : true) {\n                this._generateEdgesLinesAlternate();\n            }\n            else {\n                this._generateEdgesLines();\n            }\n        }\n        this._meshRebuildObserver = this._source.onRebuildObservable.add(() => {\n            this._rebuild();\n        });\n        this._meshDisposeObserver = this._source.onDisposeObservable.add(() => {\n            this.dispose();\n        });\n    }\n    _prepareRessources() {\n        if (this._lineShader) {\n            return;\n        }\n        this._lineShader = EdgesRenderer._GetShader(this._source.getScene());\n    }\n    /** @internal */\n    _rebuild() {\n        let buffer = this._buffers[VertexBuffer.PositionKind];\n        if (buffer) {\n            buffer._rebuild();\n        }\n        buffer = this._buffers[VertexBuffer.NormalKind];\n        if (buffer) {\n            buffer._rebuild();\n        }\n        const scene = this._source.getScene();\n        const engine = scene.getEngine();\n        this._ib = engine.createIndexBuffer(this._linesIndices);\n    }\n    /**\n     * Releases the required resources for the edges renderer\n     */\n    dispose() {\n        var _a;\n        this._source.onRebuildObservable.remove(this._meshRebuildObserver);\n        this._source.onDisposeObservable.remove(this._meshDisposeObserver);\n        let buffer = this._buffers[VertexBuffer.PositionKind];\n        if (buffer) {\n            buffer.dispose();\n            this._buffers[VertexBuffer.PositionKind] = null;\n        }\n        buffer = this._buffers[VertexBuffer.NormalKind];\n        if (buffer) {\n            buffer.dispose();\n            this._buffers[VertexBuffer.NormalKind] = null;\n        }\n        if (this._ib) {\n            this._source.getScene().getEngine()._releaseBuffer(this._ib);\n        }\n        this._lineShader.dispose();\n        (_a = this._drawWrapper) === null || _a === void 0 ? void 0 : _a.dispose();\n    }\n    _processEdgeForAdjacencies(pa, pb, p0, p1, p2) {\n        if ((pa === p0 && pb === p1) || (pa === p1 && pb === p0)) {\n            return 0;\n        }\n        if ((pa === p1 && pb === p2) || (pa === p2 && pb === p1)) {\n            return 1;\n        }\n        if ((pa === p2 && pb === p0) || (pa === p0 && pb === p2)) {\n            return 2;\n        }\n        return -1;\n    }\n    _processEdgeForAdjacenciesWithVertices(pa, pb, p0, p1, p2) {\n        const eps = 1e-10;\n        if ((pa.equalsWithEpsilon(p0, eps) && pb.equalsWithEpsilon(p1, eps)) || (pa.equalsWithEpsilon(p1, eps) && pb.equalsWithEpsilon(p0, eps))) {\n            return 0;\n        }\n        if ((pa.equalsWithEpsilon(p1, eps) && pb.equalsWithEpsilon(p2, eps)) || (pa.equalsWithEpsilon(p2, eps) && pb.equalsWithEpsilon(p1, eps))) {\n            return 1;\n        }\n        if ((pa.equalsWithEpsilon(p2, eps) && pb.equalsWithEpsilon(p0, eps)) || (pa.equalsWithEpsilon(p0, eps) && pb.equalsWithEpsilon(p2, eps))) {\n            return 2;\n        }\n        return -1;\n    }\n    /**\n     * Checks if the pair of p0 and p1 is en edge\n     * @param faceIndex\n     * @param edge\n     * @param faceNormals\n     * @param  p0\n     * @param  p1\n     * @private\n     */\n    _checkEdge(faceIndex, edge, faceNormals, p0, p1) {\n        let needToCreateLine;\n        if (edge === undefined) {\n            needToCreateLine = true;\n        }\n        else {\n            const dotProduct = Vector3.Dot(faceNormals[faceIndex], faceNormals[edge]);\n            needToCreateLine = dotProduct < this._epsilon;\n        }\n        if (needToCreateLine) {\n            this.createLine(p0, p1, this._linesPositions.length / 3);\n        }\n    }\n    /**\n     * push line into the position, normal and index buffer\n     * @param p0\n     * @param p1\n     * @param offset\n     * @protected\n     */\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    createLine(p0, p1, offset) {\n        // Positions\n        this._linesPositions.push(p0.x, p0.y, p0.z, p0.x, p0.y, p0.z, p1.x, p1.y, p1.z, p1.x, p1.y, p1.z);\n        // Normals\n        this._linesNormals.push(p1.x, p1.y, p1.z, -1, p1.x, p1.y, p1.z, 1, p0.x, p0.y, p0.z, -1, p0.x, p0.y, p0.z, 1);\n        // Indices\n        this._linesIndices.push(offset, offset + 1, offset + 2, offset, offset + 2, offset + 3);\n    }\n    /**\n     * See https://playground.babylonjs.com/#R3JR6V#1 for a visual display of the algorithm\n     * @param edgePoints\n     * @param indexTriangle\n     * @param indices\n     * @param remapVertexIndices\n     */\n    _tessellateTriangle(edgePoints, indexTriangle, indices, remapVertexIndices) {\n        const makePointList = (edgePoints, pointIndices, firstIndex) => {\n            if (firstIndex >= 0) {\n                pointIndices.push(firstIndex);\n            }\n            for (let i = 0; i < edgePoints.length; ++i) {\n                pointIndices.push(edgePoints[i][0]);\n            }\n        };\n        let startEdge = 0;\n        if (edgePoints[1].length >= edgePoints[0].length && edgePoints[1].length >= edgePoints[2].length) {\n            startEdge = 1;\n        }\n        else if (edgePoints[2].length >= edgePoints[0].length && edgePoints[2].length >= edgePoints[1].length) {\n            startEdge = 2;\n        }\n        for (let e = 0; e < 3; ++e) {\n            if (e === startEdge) {\n                edgePoints[e].sort((a, b) => (a[1] < b[1] ? -1 : a[1] > b[1] ? 1 : 0));\n            }\n            else {\n                edgePoints[e].sort((a, b) => (a[1] > b[1] ? -1 : a[1] < b[1] ? 1 : 0));\n            }\n        }\n        const mainPointIndices = [], otherPointIndices = [];\n        makePointList(edgePoints[startEdge], mainPointIndices, -1);\n        const numMainPoints = mainPointIndices.length;\n        for (let i = startEdge + 2; i >= startEdge + 1; --i) {\n            makePointList(edgePoints[i % 3], otherPointIndices, i !== startEdge + 2 ? remapVertexIndices[indices[indexTriangle + ((i + 1) % 3)]] : -1);\n        }\n        const numOtherPoints = otherPointIndices.length;\n        const idxMain = 0;\n        const idxOther = 0;\n        indices.push(remapVertexIndices[indices[indexTriangle + startEdge]], mainPointIndices[0], otherPointIndices[0]);\n        indices.push(remapVertexIndices[indices[indexTriangle + ((startEdge + 1) % 3)]], otherPointIndices[numOtherPoints - 1], mainPointIndices[numMainPoints - 1]);\n        const bucketIsMain = numMainPoints <= numOtherPoints;\n        const bucketStep = bucketIsMain ? numMainPoints : numOtherPoints;\n        const bucketLimit = bucketIsMain ? numOtherPoints : numMainPoints;\n        const bucketIdxLimit = bucketIsMain ? numMainPoints - 1 : numOtherPoints - 1;\n        const winding = bucketIsMain ? 0 : 1;\n        let numTris = numMainPoints + numOtherPoints - 2;\n        let bucketIdx = bucketIsMain ? idxMain : idxOther;\n        let nbucketIdx = bucketIsMain ? idxOther : idxMain;\n        const bucketPoints = bucketIsMain ? mainPointIndices : otherPointIndices;\n        const nbucketPoints = bucketIsMain ? otherPointIndices : mainPointIndices;\n        let bucket = 0;\n        while (numTris-- > 0) {\n            if (winding) {\n                indices.push(bucketPoints[bucketIdx], nbucketPoints[nbucketIdx]);\n            }\n            else {\n                indices.push(nbucketPoints[nbucketIdx], bucketPoints[bucketIdx]);\n            }\n            bucket += bucketStep;\n            let lastIdx;\n            if (bucket >= bucketLimit && bucketIdx < bucketIdxLimit) {\n                lastIdx = bucketPoints[++bucketIdx];\n                bucket -= bucketLimit;\n            }\n            else {\n                lastIdx = nbucketPoints[++nbucketIdx];\n            }\n            indices.push(lastIdx);\n        }\n        indices[indexTriangle + 0] = indices[indices.length - 3];\n        indices[indexTriangle + 1] = indices[indices.length - 2];\n        indices[indexTriangle + 2] = indices[indices.length - 1];\n        indices.length = indices.length - 3;\n    }\n    _generateEdgesLinesAlternate() {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;\n        const positions = this._source.getVerticesData(VertexBuffer.PositionKind);\n        let indices = this._source.getIndices();\n        if (!indices || !positions) {\n            return;\n        }\n        if (!Array.isArray(indices)) {\n            indices = Array.from(indices);\n        }\n        /**\n         * Find all vertices that are at the same location (with an epsilon) and remapp them on the same vertex\n         */\n        const useFastVertexMerger = (_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.useFastVertexMerger) !== null && _b !== void 0 ? _b : true;\n        const epsVertexMerge = useFastVertexMerger ? Math.round(-Math.log((_d = (_c = this._options) === null || _c === void 0 ? void 0 : _c.epsilonVertexMerge) !== null && _d !== void 0 ? _d : 1e-6) / Math.log(10)) : (_f = (_e = this._options) === null || _e === void 0 ? void 0 : _e.epsilonVertexMerge) !== null && _f !== void 0 ? _f : 1e-6;\n        const remapVertexIndices = [];\n        const uniquePositions = []; // list of unique index of vertices - needed for tessellation\n        if (useFastVertexMerger) {\n            const mapVertices = {};\n            for (let v1 = 0; v1 < positions.length; v1 += 3) {\n                const x1 = positions[v1 + 0], y1 = positions[v1 + 1], z1 = positions[v1 + 2];\n                const key = x1.toFixed(epsVertexMerge) + \"|\" + y1.toFixed(epsVertexMerge) + \"|\" + z1.toFixed(epsVertexMerge);\n                if (mapVertices[key] !== undefined) {\n                    remapVertexIndices.push(mapVertices[key]);\n                }\n                else {\n                    const idx = v1 / 3;\n                    mapVertices[key] = idx;\n                    remapVertexIndices.push(idx);\n                    uniquePositions.push(idx);\n                }\n            }\n        }\n        else {\n            for (let v1 = 0; v1 < positions.length; v1 += 3) {\n                const x1 = positions[v1 + 0], y1 = positions[v1 + 1], z1 = positions[v1 + 2];\n                let found = false;\n                for (let v2 = 0; v2 < v1 && !found; v2 += 3) {\n                    const x2 = positions[v2 + 0], y2 = positions[v2 + 1], z2 = positions[v2 + 2];\n                    if (Math.abs(x1 - x2) < epsVertexMerge && Math.abs(y1 - y2) < epsVertexMerge && Math.abs(z1 - z2) < epsVertexMerge) {\n                        remapVertexIndices.push(v2 / 3);\n                        found = true;\n                        break;\n                    }\n                }\n                if (!found) {\n                    remapVertexIndices.push(v1 / 3);\n                    uniquePositions.push(v1 / 3);\n                }\n            }\n        }\n        if ((_g = this._options) === null || _g === void 0 ? void 0 : _g.applyTessellation) {\n            /**\n             * Tessellate triangles if necessary:\n             *\n             *               A\n             *               +\n             *               |\\\n             *               | \\\n             *               |  \\\n             *             E +   \\\n             *              /|    \\\n             *             / |     \\\n             *            /  |      \\\n             *           +---+-------+ B\n             *           D   C\n             *\n             * For the edges to be rendered correctly, the ABC triangle has to be split into ABE and BCE, else AC is considered to be an edge, whereas only AE should be.\n             *\n             * The tessellation process looks for the vertices like E that are in-between two other vertices making of an edge and create new triangles as necessary\n             */\n            // First step: collect the triangles to tessellate\n            const epsVertexAligned = (_j = (_h = this._options) === null || _h === void 0 ? void 0 : _h.epsilonVertexAligned) !== null && _j !== void 0 ? _j : 1e-6;\n            const mustTesselate = []; // liste of triangles that must be tessellated\n            for (let index = 0; index < indices.length; index += 3) {\n                // loop over all triangles\n                let triangleToTessellate;\n                for (let i = 0; i < 3; ++i) {\n                    // loop over the 3 edges of the triangle\n                    const p0Index = remapVertexIndices[indices[index + i]];\n                    const p1Index = remapVertexIndices[indices[index + ((i + 1) % 3)]];\n                    const p2Index = remapVertexIndices[indices[index + ((i + 2) % 3)]];\n                    if (p0Index === p1Index) {\n                        continue;\n                    } // degenerated triangle - don't process\n                    const p0x = positions[p0Index * 3 + 0], p0y = positions[p0Index * 3 + 1], p0z = positions[p0Index * 3 + 2];\n                    const p1x = positions[p1Index * 3 + 0], p1y = positions[p1Index * 3 + 1], p1z = positions[p1Index * 3 + 2];\n                    const p0p1 = Math.sqrt((p1x - p0x) * (p1x - p0x) + (p1y - p0y) * (p1y - p0y) + (p1z - p0z) * (p1z - p0z));\n                    for (let v = 0; v < uniquePositions.length - 1; v++) {\n                        // loop over all (unique) vertices and look for the ones that would be in-between p0 and p1\n                        const vIndex = uniquePositions[v];\n                        if (vIndex === p0Index || vIndex === p1Index || vIndex === p2Index) {\n                            continue;\n                        } // don't handle the vertex if it is a vertex of the current triangle\n                        const x = positions[vIndex * 3 + 0], y = positions[vIndex * 3 + 1], z = positions[vIndex * 3 + 2];\n                        const p0p = Math.sqrt((x - p0x) * (x - p0x) + (y - p0y) * (y - p0y) + (z - p0z) * (z - p0z));\n                        const pp1 = Math.sqrt((x - p1x) * (x - p1x) + (y - p1y) * (y - p1y) + (z - p1z) * (z - p1z));\n                        if (Math.abs(p0p + pp1 - p0p1) < epsVertexAligned) {\n                            // vertices are aligned and p in-between p0 and p1 if distance(p0, p) + distance (p, p1) ~ distance(p0, p1)\n                            if (!triangleToTessellate) {\n                                triangleToTessellate = {\n                                    index: index,\n                                    edgesPoints: [[], [], []],\n                                };\n                                mustTesselate.push(triangleToTessellate);\n                            }\n                            triangleToTessellate.edgesPoints[i].push([vIndex, p0p]);\n                        }\n                    }\n                }\n            }\n            // Second step: tesselate the triangles\n            for (let t = 0; t < mustTesselate.length; ++t) {\n                const triangle = mustTesselate[t];\n                this._tessellateTriangle(triangle.edgesPoints, triangle.index, indices, remapVertexIndices);\n            }\n            mustTesselate.length = 0;\n        }\n        /**\n         * Collect the edges to render\n         */\n        const edges = {};\n        for (let index = 0; index < indices.length; index += 3) {\n            let faceNormal;\n            for (let i = 0; i < 3; ++i) {\n                let p0Index = remapVertexIndices[indices[index + i]];\n                let p1Index = remapVertexIndices[indices[index + ((i + 1) % 3)]];\n                const p2Index = remapVertexIndices[indices[index + ((i + 2) % 3)]];\n                if (p0Index === p1Index || ((p0Index === p2Index || p1Index === p2Index) && ((_k = this._options) === null || _k === void 0 ? void 0 : _k.removeDegeneratedTriangles))) {\n                    continue;\n                }\n                TmpVectors.Vector3[0].copyFromFloats(positions[p0Index * 3 + 0], positions[p0Index * 3 + 1], positions[p0Index * 3 + 2]);\n                TmpVectors.Vector3[1].copyFromFloats(positions[p1Index * 3 + 0], positions[p1Index * 3 + 1], positions[p1Index * 3 + 2]);\n                TmpVectors.Vector3[2].copyFromFloats(positions[p2Index * 3 + 0], positions[p2Index * 3 + 1], positions[p2Index * 3 + 2]);\n                if (!faceNormal) {\n                    TmpVectors.Vector3[1].subtractToRef(TmpVectors.Vector3[0], TmpVectors.Vector3[3]);\n                    TmpVectors.Vector3[2].subtractToRef(TmpVectors.Vector3[1], TmpVectors.Vector3[4]);\n                    faceNormal = Vector3.Cross(TmpVectors.Vector3[3], TmpVectors.Vector3[4]);\n                    faceNormal.normalize();\n                }\n                if (p0Index > p1Index) {\n                    const tmp = p0Index;\n                    p0Index = p1Index;\n                    p1Index = tmp;\n                }\n                const key = p0Index + \"_\" + p1Index;\n                const ei = edges[key];\n                if (ei) {\n                    if (!ei.done) {\n                        const dotProduct = Vector3.Dot(faceNormal, ei.normal);\n                        if (dotProduct < this._epsilon) {\n                            this.createLine(TmpVectors.Vector3[0], TmpVectors.Vector3[1], this._linesPositions.length / 3);\n                        }\n                        ei.done = true;\n                    }\n                }\n                else {\n                    edges[key] = { normal: faceNormal, done: false, index: index, i: i };\n                }\n            }\n        }\n        for (const key in edges) {\n            const ei = edges[key];\n            if (!ei.done) {\n                // Orphaned edge - we must display it\n                const p0Index = remapVertexIndices[indices[ei.index + ei.i]];\n                const p1Index = remapVertexIndices[indices[ei.index + ((ei.i + 1) % 3)]];\n                TmpVectors.Vector3[0].copyFromFloats(positions[p0Index * 3 + 0], positions[p0Index * 3 + 1], positions[p0Index * 3 + 2]);\n                TmpVectors.Vector3[1].copyFromFloats(positions[p1Index * 3 + 0], positions[p1Index * 3 + 1], positions[p1Index * 3 + 2]);\n                this.createLine(TmpVectors.Vector3[0], TmpVectors.Vector3[1], this._linesPositions.length / 3);\n            }\n        }\n        /**\n         * Merge into a single mesh\n         */\n        const engine = this._source.getScene().getEngine();\n        this._buffers[VertexBuffer.PositionKind] = new VertexBuffer(engine, this._linesPositions, VertexBuffer.PositionKind, false);\n        this._buffers[VertexBuffer.NormalKind] = new VertexBuffer(engine, this._linesNormals, VertexBuffer.NormalKind, false, false, 4);\n        this._buffersForInstances[VertexBuffer.PositionKind] = this._buffers[VertexBuffer.PositionKind];\n        this._buffersForInstances[VertexBuffer.NormalKind] = this._buffers[VertexBuffer.NormalKind];\n        this._ib = engine.createIndexBuffer(this._linesIndices);\n        this._indicesCount = this._linesIndices.length;\n    }\n    /**\n     * Generates lines edges from adjacencjes\n     * @private\n     */\n    _generateEdgesLines() {\n        const positions = this._source.getVerticesData(VertexBuffer.PositionKind);\n        const indices = this._source.getIndices();\n        if (!indices || !positions) {\n            return;\n        }\n        // First let's find adjacencies\n        const adjacencies = new Array();\n        const faceNormals = new Array();\n        let index;\n        let faceAdjacencies;\n        // Prepare faces\n        for (index = 0; index < indices.length; index += 3) {\n            faceAdjacencies = new FaceAdjacencies();\n            const p0Index = indices[index];\n            const p1Index = indices[index + 1];\n            const p2Index = indices[index + 2];\n            faceAdjacencies.p0 = new Vector3(positions[p0Index * 3], positions[p0Index * 3 + 1], positions[p0Index * 3 + 2]);\n            faceAdjacencies.p1 = new Vector3(positions[p1Index * 3], positions[p1Index * 3 + 1], positions[p1Index * 3 + 2]);\n            faceAdjacencies.p2 = new Vector3(positions[p2Index * 3], positions[p2Index * 3 + 1], positions[p2Index * 3 + 2]);\n            const faceNormal = Vector3.Cross(faceAdjacencies.p1.subtract(faceAdjacencies.p0), faceAdjacencies.p2.subtract(faceAdjacencies.p1));\n            faceNormal.normalize();\n            faceNormals.push(faceNormal);\n            adjacencies.push(faceAdjacencies);\n        }\n        // Scan\n        for (index = 0; index < adjacencies.length; index++) {\n            faceAdjacencies = adjacencies[index];\n            for (let otherIndex = index + 1; otherIndex < adjacencies.length; otherIndex++) {\n                const otherFaceAdjacencies = adjacencies[otherIndex];\n                if (faceAdjacencies.edgesConnectedCount === 3) {\n                    // Full\n                    break;\n                }\n                if (otherFaceAdjacencies.edgesConnectedCount === 3) {\n                    // Full\n                    continue;\n                }\n                const otherP0 = indices[otherIndex * 3];\n                const otherP1 = indices[otherIndex * 3 + 1];\n                const otherP2 = indices[otherIndex * 3 + 2];\n                for (let edgeIndex = 0; edgeIndex < 3; edgeIndex++) {\n                    let otherEdgeIndex = 0;\n                    if (faceAdjacencies.edges[edgeIndex] !== undefined) {\n                        continue;\n                    }\n                    switch (edgeIndex) {\n                        case 0:\n                            if (this._checkVerticesInsteadOfIndices) {\n                                otherEdgeIndex = this._processEdgeForAdjacenciesWithVertices(faceAdjacencies.p0, faceAdjacencies.p1, otherFaceAdjacencies.p0, otherFaceAdjacencies.p1, otherFaceAdjacencies.p2);\n                            }\n                            else {\n                                otherEdgeIndex = this._processEdgeForAdjacencies(indices[index * 3], indices[index * 3 + 1], otherP0, otherP1, otherP2);\n                            }\n                            break;\n                        case 1:\n                            if (this._checkVerticesInsteadOfIndices) {\n                                otherEdgeIndex = this._processEdgeForAdjacenciesWithVertices(faceAdjacencies.p1, faceAdjacencies.p2, otherFaceAdjacencies.p0, otherFaceAdjacencies.p1, otherFaceAdjacencies.p2);\n                            }\n                            else {\n                                otherEdgeIndex = this._processEdgeForAdjacencies(indices[index * 3 + 1], indices[index * 3 + 2], otherP0, otherP1, otherP2);\n                            }\n                            break;\n                        case 2:\n                            if (this._checkVerticesInsteadOfIndices) {\n                                otherEdgeIndex = this._processEdgeForAdjacenciesWithVertices(faceAdjacencies.p2, faceAdjacencies.p0, otherFaceAdjacencies.p0, otherFaceAdjacencies.p1, otherFaceAdjacencies.p2);\n                            }\n                            else {\n                                otherEdgeIndex = this._processEdgeForAdjacencies(indices[index * 3 + 2], indices[index * 3], otherP0, otherP1, otherP2);\n                            }\n                            break;\n                    }\n                    if (otherEdgeIndex === -1) {\n                        continue;\n                    }\n                    faceAdjacencies.edges[edgeIndex] = otherIndex;\n                    otherFaceAdjacencies.edges[otherEdgeIndex] = index;\n                    faceAdjacencies.edgesConnectedCount++;\n                    otherFaceAdjacencies.edgesConnectedCount++;\n                    if (faceAdjacencies.edgesConnectedCount === 3) {\n                        break;\n                    }\n                }\n            }\n        }\n        // Create lines\n        for (index = 0; index < adjacencies.length; index++) {\n            // We need a line when a face has no adjacency on a specific edge or if all the adjacencies has an angle greater than epsilon\n            const current = adjacencies[index];\n            this._checkEdge(index, current.edges[0], faceNormals, current.p0, current.p1);\n            this._checkEdge(index, current.edges[1], faceNormals, current.p1, current.p2);\n            this._checkEdge(index, current.edges[2], faceNormals, current.p2, current.p0);\n        }\n        // Merge into a single mesh\n        const engine = this._source.getScene().getEngine();\n        this._buffers[VertexBuffer.PositionKind] = new VertexBuffer(engine, this._linesPositions, VertexBuffer.PositionKind, false);\n        this._buffers[VertexBuffer.NormalKind] = new VertexBuffer(engine, this._linesNormals, VertexBuffer.NormalKind, false, false, 4);\n        this._buffersForInstances[VertexBuffer.PositionKind] = this._buffers[VertexBuffer.PositionKind];\n        this._buffersForInstances[VertexBuffer.NormalKind] = this._buffers[VertexBuffer.NormalKind];\n        this._ib = engine.createIndexBuffer(this._linesIndices);\n        this._indicesCount = this._linesIndices.length;\n    }\n    /**\n     * Checks whether or not the edges renderer is ready to render.\n     * @returns true if ready, otherwise false.\n     */\n    isReady() {\n        return this._lineShader.isReady(this._source, (this._source.hasInstances && this.customInstances.length > 0) || this._source.hasThinInstances);\n    }\n    /**\n     * Renders the edges of the attached mesh,\n     */\n    render() {\n        const scene = this._source.getScene();\n        const currentDrawWrapper = this._lineShader._getDrawWrapper();\n        if (this._drawWrapper) {\n            this._lineShader._setDrawWrapper(this._drawWrapper);\n        }\n        if (!this.isReady() || !scene.activeCamera) {\n            this._lineShader._setDrawWrapper(currentDrawWrapper);\n            return;\n        }\n        const hasInstances = this._source.hasInstances && this.customInstances.length > 0;\n        const useBuffersWithInstances = hasInstances || this._source.hasThinInstances;\n        let instanceCount = 0;\n        if (useBuffersWithInstances) {\n            this._buffersForInstances[\"world0\"] = this._source.getVertexBuffer(\"world0\");\n            this._buffersForInstances[\"world1\"] = this._source.getVertexBuffer(\"world1\");\n            this._buffersForInstances[\"world2\"] = this._source.getVertexBuffer(\"world2\");\n            this._buffersForInstances[\"world3\"] = this._source.getVertexBuffer(\"world3\");\n            if (hasInstances) {\n                const instanceStorage = this._source._instanceDataStorage;\n                instanceCount = this.customInstances.length;\n                if (!instanceStorage.instancesData) {\n                    if (!this._source.getScene()._activeMeshesFrozen) {\n                        this.customInstances.reset();\n                    }\n                    return;\n                }\n                if (!instanceStorage.isFrozen) {\n                    let offset = 0;\n                    for (let i = 0; i < instanceCount; ++i) {\n                        this.customInstances.data[i].copyToArray(instanceStorage.instancesData, offset);\n                        offset += 16;\n                    }\n                    instanceStorage.instancesBuffer.updateDirectly(instanceStorage.instancesData, 0, instanceCount);\n                }\n            }\n            else {\n                instanceCount = this._source.thinInstanceCount;\n            }\n        }\n        const engine = scene.getEngine();\n        this._lineShader._preBind();\n        if (this._source.edgesColor.a !== 1) {\n            engine.setAlphaMode(2);\n        }\n        else {\n            engine.setAlphaMode(0);\n        }\n        // VBOs\n        engine.bindBuffers(useBuffersWithInstances ? this._buffersForInstances : this._buffers, this._ib, this._lineShader.getEffect());\n        scene.resetCachedMaterial();\n        this._lineShader.setColor4(\"color\", this._source.edgesColor);\n        if (scene.activeCamera.mode === Camera.ORTHOGRAPHIC_CAMERA) {\n            this._lineShader.setFloat(\"width\", this._source.edgesWidth / this.edgesWidthScalerForOrthographic);\n        }\n        else {\n            this._lineShader.setFloat(\"width\", this._source.edgesWidth / this.edgesWidthScalerForPerspective);\n        }\n        this._lineShader.setFloat(\"aspectRatio\", engine.getAspectRatio(scene.activeCamera));\n        this._lineShader.bind(this._source.getWorldMatrix());\n        // Draw order\n        engine.drawElementsType(Material.TriangleFillMode, 0, this._indicesCount, instanceCount);\n        this._lineShader.unbind();\n        if (useBuffersWithInstances) {\n            engine.unbindInstanceAttributes();\n        }\n        if (!this._source.getScene()._activeMeshesFrozen) {\n            this.customInstances.reset();\n        }\n        this._lineShader._setDrawWrapper(currentDrawWrapper);\n    }\n}\n/**\n * LineEdgesRenderer for LineMeshes to remove unnecessary triangulation\n */\nexport class LineEdgesRenderer extends EdgesRenderer {\n    /**\n     * This constructor turns off auto generating edges line in Edges Renderer to make it here.\n     * @param  source LineMesh used to generate edges\n     * @param  epsilon not important (specified angle for edge detection)\n     * @param  checkVerticesInsteadOfIndices not important for LineMesh\n     */\n    constructor(source, epsilon = 0.95, checkVerticesInsteadOfIndices = false) {\n        super(source, epsilon, checkVerticesInsteadOfIndices, false);\n        this._generateEdgesLines();\n    }\n    /**\n     * Generate edges for each line in LinesMesh. Every Line should be rendered as edge.\n     */\n    _generateEdgesLines() {\n        const positions = this._source.getVerticesData(VertexBuffer.PositionKind);\n        const indices = this._source.getIndices();\n        if (!indices || !positions) {\n            return;\n        }\n        const p0 = TmpVectors.Vector3[0];\n        const p1 = TmpVectors.Vector3[1];\n        const len = indices.length - 1;\n        for (let i = 0, offset = 0; i < len; i += 2, offset += 4) {\n            Vector3.FromArrayToRef(positions, 3 * indices[i], p0);\n            Vector3.FromArrayToRef(positions, 3 * indices[i + 1], p1);\n            this.createLine(p0, p1, offset);\n        }\n        // Merge into a single mesh\n        const engine = this._source.getScene().getEngine();\n        this._buffers[VertexBuffer.PositionKind] = new VertexBuffer(engine, this._linesPositions, VertexBuffer.PositionKind, false);\n        this._buffers[VertexBuffer.NormalKind] = new VertexBuffer(engine, this._linesNormals, VertexBuffer.NormalKind, false, false, 4);\n        this._ib = engine.createIndexBuffer(this._linesIndices);\n        this._indicesCount = this._linesIndices.length;\n    }\n}\n//# sourceMappingURL=edgesRenderer.js.map","import { Matrix } from \"../Maths/math.vector.js\";\nimport { VertexBuffer } from \"../Buffers/buffer.js\";\n\nimport { Texture } from \"../Materials/Textures/texture.js\";\nimport { MultiRenderTarget } from \"../Materials/Textures/multiRenderTarget.js\";\nimport { MaterialHelper } from \"../Materials/materialHelper.js\";\nimport { Color3, Color4 } from \"../Maths/math.color.js\";\nimport { _WarnImport } from \"../Misc/devTools.js\";\nimport { Material } from \"../Materials/material.js\";\nimport \"../Shaders/geometry.fragment.js\";\nimport \"../Shaders/geometry.vertex.js\";\nimport { MaterialFlags } from \"../Materials/materialFlags.js\";\nimport { addClipPlaneUniforms, bindClipPlane, prepareDefinesForClipPlanes } from \"../Materials/clipPlaneMaterialHelper.js\";\n/** list the uniforms used by the geometry renderer */\nconst uniforms = [\n    \"world\",\n    \"mBones\",\n    \"viewProjection\",\n    \"diffuseMatrix\",\n    \"view\",\n    \"previousWorld\",\n    \"previousViewProjection\",\n    \"mPreviousBones\",\n    \"bumpMatrix\",\n    \"reflectivityMatrix\",\n    \"albedoMatrix\",\n    \"reflectivityColor\",\n    \"albedoColor\",\n    \"metallic\",\n    \"glossiness\",\n    \"vTangentSpaceParams\",\n    \"vBumpInfos\",\n    \"morphTargetInfluences\",\n    \"morphTargetTextureInfo\",\n    \"morphTargetTextureIndices\",\n];\naddClipPlaneUniforms(uniforms);\n/**\n * This renderer is helpful to fill one of the render target with a geometry buffer.\n */\nexport class GeometryBufferRenderer {\n    /**\n     * @internal\n     * Sets up internal structures to share outputs with PrePassRenderer\n     * This method should only be called by the PrePassRenderer itself\n     */\n    _linkPrePassRenderer(prePassRenderer) {\n        this._linkedWithPrePass = true;\n        this._prePassRenderer = prePassRenderer;\n        if (this._multiRenderTarget) {\n            // prevents clearing of the RT since it's done by prepass\n            this._multiRenderTarget.onClearObservable.clear();\n            this._multiRenderTarget.onClearObservable.add(() => {\n                // pass\n            });\n        }\n    }\n    /**\n     * @internal\n     * Separates internal structures from PrePassRenderer so the geometry buffer can now operate by itself.\n     * This method should only be called by the PrePassRenderer itself\n     */\n    _unlinkPrePassRenderer() {\n        this._linkedWithPrePass = false;\n        this._createRenderTargets();\n    }\n    /**\n     * @internal\n     * Resets the geometry buffer layout\n     */\n    _resetLayout() {\n        this._enablePosition = false;\n        this._enableReflectivity = false;\n        this._enableVelocity = false;\n        this._attachments = [];\n    }\n    /**\n     * @internal\n     * Replaces a texture in the geometry buffer renderer\n     * Useful when linking textures of the prepass renderer\n     */\n    _forceTextureType(geometryBufferType, index) {\n        if (geometryBufferType === GeometryBufferRenderer.POSITION_TEXTURE_TYPE) {\n            this._positionIndex = index;\n            this._enablePosition = true;\n        }\n        else if (geometryBufferType === GeometryBufferRenderer.VELOCITY_TEXTURE_TYPE) {\n            this._velocityIndex = index;\n            this._enableVelocity = true;\n        }\n        else if (geometryBufferType === GeometryBufferRenderer.REFLECTIVITY_TEXTURE_TYPE) {\n            this._reflectivityIndex = index;\n            this._enableReflectivity = true;\n        }\n        else if (geometryBufferType === GeometryBufferRenderer.DEPTH_TEXTURE_TYPE) {\n            this._depthIndex = index;\n        }\n        else if (geometryBufferType === GeometryBufferRenderer.NORMAL_TEXTURE_TYPE) {\n            this._normalIndex = index;\n        }\n    }\n    /**\n     * @internal\n     * Sets texture attachments\n     * Useful when linking textures of the prepass renderer\n     */\n    _setAttachments(attachments) {\n        this._attachments = attachments;\n    }\n    /**\n     * @internal\n     * Replaces the first texture which is hard coded as a depth texture in the geometry buffer\n     * Useful when linking textures of the prepass renderer\n     */\n    _linkInternalTexture(internalTexture) {\n        this._multiRenderTarget.setInternalTexture(internalTexture, 0, false);\n    }\n    /**\n     * Gets the render list (meshes to be rendered) used in the G buffer.\n     */\n    get renderList() {\n        return this._multiRenderTarget.renderList;\n    }\n    /**\n     * Set the render list (meshes to be rendered) used in the G buffer.\n     */\n    set renderList(meshes) {\n        this._multiRenderTarget.renderList = meshes;\n    }\n    /**\n     * Gets whether or not G buffer are supported by the running hardware.\n     * This requires draw buffer supports\n     */\n    get isSupported() {\n        return this._multiRenderTarget.isSupported;\n    }\n    /**\n     * Returns the index of the given texture type in the G-Buffer textures array\n     * @param textureType The texture type constant. For example GeometryBufferRenderer.POSITION_TEXTURE_INDEX\n     * @returns the index of the given texture type in the G-Buffer textures array\n     */\n    getTextureIndex(textureType) {\n        switch (textureType) {\n            case GeometryBufferRenderer.POSITION_TEXTURE_TYPE:\n                return this._positionIndex;\n            case GeometryBufferRenderer.VELOCITY_TEXTURE_TYPE:\n                return this._velocityIndex;\n            case GeometryBufferRenderer.REFLECTIVITY_TEXTURE_TYPE:\n                return this._reflectivityIndex;\n            default:\n                return -1;\n        }\n    }\n    /**\n     * Gets a boolean indicating if objects positions are enabled for the G buffer.\n     */\n    get enablePosition() {\n        return this._enablePosition;\n    }\n    /**\n     * Sets whether or not objects positions are enabled for the G buffer.\n     */\n    set enablePosition(enable) {\n        this._enablePosition = enable;\n        // PrePass handles index and texture links\n        if (!this._linkedWithPrePass) {\n            this.dispose();\n            this._createRenderTargets();\n        }\n    }\n    /**\n     * Gets a boolean indicating if objects velocities are enabled for the G buffer.\n     */\n    get enableVelocity() {\n        return this._enableVelocity;\n    }\n    /**\n     * Sets whether or not objects velocities are enabled for the G buffer.\n     */\n    set enableVelocity(enable) {\n        this._enableVelocity = enable;\n        if (!enable) {\n            this._previousTransformationMatrices = {};\n        }\n        if (!this._linkedWithPrePass) {\n            this.dispose();\n            this._createRenderTargets();\n        }\n        this._scene.needsPreviousWorldMatrices = enable;\n    }\n    /**\n     * Gets a boolean indicating if objects reflectivity are enabled in the G buffer.\n     */\n    get enableReflectivity() {\n        return this._enableReflectivity;\n    }\n    /**\n     * Sets whether or not objects reflectivity are enabled for the G buffer.\n     * For Metallic-Roughness workflow with ORM texture, we assume that ORM texture is defined according to the default layout:\n     * pbr.useRoughnessFromMetallicTextureAlpha = false;\n     * pbr.useRoughnessFromMetallicTextureGreen = true;\n     * pbr.useMetallnessFromMetallicTextureBlue = true;\n     */\n    set enableReflectivity(enable) {\n        this._enableReflectivity = enable;\n        if (!this._linkedWithPrePass) {\n            this.dispose();\n            this._createRenderTargets();\n        }\n    }\n    /**\n     * Gets the scene associated with the buffer.\n     */\n    get scene() {\n        return this._scene;\n    }\n    /**\n     * Gets the ratio used by the buffer during its creation.\n     * How big is the buffer related to the main canvas.\n     */\n    get ratio() {\n        return this._ratio;\n    }\n    /**\n     * Creates a new G Buffer for the scene\n     * @param scene The scene the buffer belongs to\n     * @param ratio How big is the buffer related to the main canvas (default: 1)\n     * @param depthFormat Format of the depth texture (default: 15)\n     */\n    constructor(scene, ratio = 1, depthFormat = 15) {\n        /**\n         * Dictionary used to store the previous transformation matrices of each rendered mesh\n         * in order to compute objects velocities when enableVelocity is set to \"true\"\n         * @internal\n         */\n        this._previousTransformationMatrices = {};\n        /**\n         * Dictionary used to store the previous bones transformation matrices of each rendered mesh\n         * in order to compute objects velocities when enableVelocity is set to \"true\"\n         * @internal\n         */\n        this._previousBonesTransformationMatrices = {};\n        /**\n         * Array used to store the ignored skinned meshes while computing velocity map (typically used by the motion blur post-process).\n         * Avoids computing bones velocities and computes only mesh's velocity itself (position, rotation, scaling).\n         */\n        this.excludedSkinnedMeshesFromVelocity = [];\n        /** Gets or sets a boolean indicating if transparent meshes should be rendered */\n        this.renderTransparentMeshes = true;\n        this._resizeObserver = null;\n        this._enablePosition = false;\n        this._enableVelocity = false;\n        this._enableReflectivity = false;\n        this._positionIndex = -1;\n        this._velocityIndex = -1;\n        this._reflectivityIndex = -1;\n        this._depthIndex = -1;\n        this._normalIndex = -1;\n        this._linkedWithPrePass = false;\n        this._specularColorLinear = new Color3();\n        this._scene = scene;\n        this._ratio = ratio;\n        this._useUbo = scene.getEngine().supportsUniformBuffers;\n        this._depthFormat = depthFormat;\n        GeometryBufferRenderer._SceneComponentInitialization(this._scene);\n        // Render target\n        this._createRenderTargets();\n    }\n    /**\n     * Checks whether everything is ready to render a submesh to the G buffer.\n     * @param subMesh the submesh to check readiness for\n     * @param useInstances is the mesh drawn using instance or not\n     * @returns true if ready otherwise false\n     */\n    isReady(subMesh, useInstances) {\n        const material = subMesh.getMaterial();\n        if (material && material.disableDepthWrite) {\n            return false;\n        }\n        const defines = [];\n        const attribs = [VertexBuffer.PositionKind, VertexBuffer.NormalKind];\n        const mesh = subMesh.getMesh();\n        // Alpha test\n        if (material) {\n            let needUv = false;\n            if (material.needAlphaTesting() && material.getAlphaTestTexture()) {\n                defines.push(\"#define ALPHATEST\");\n                defines.push(`#define ALPHATEST_UV${material.getAlphaTestTexture().coordinatesIndex + 1}`);\n                needUv = true;\n            }\n            if (material.bumpTexture && MaterialFlags.BumpTextureEnabled) {\n                defines.push(\"#define BUMP\");\n                defines.push(`#define BUMP_UV${material.bumpTexture.coordinatesIndex + 1}`);\n                needUv = true;\n            }\n            if (this._enableReflectivity) {\n                let metallicWorkflow = false;\n                // for PBR materials: cf. https://doc.babylonjs.com/features/featuresDeepDive/materials/using/masterPBR\n                if (material.getClassName() === \"PBRMetallicRoughnessMaterial\") {\n                    // if it is a PBR material in MetallicRoughness Mode:\n                    if (material.metallicRoughnessTexture !== null) {\n                        defines.push(\"#define ORMTEXTURE\");\n                        defines.push(`#define REFLECTIVITY_UV${material.metallicRoughnessTexture.coordinatesIndex + 1}`);\n                        defines.push(\"#define METALLICWORKFLOW\");\n                        needUv = true;\n                        metallicWorkflow = true;\n                    }\n                    if (material.metallic !== null) {\n                        defines.push(\"#define METALLIC\");\n                        defines.push(\"#define METALLICWORKFLOW\");\n                        metallicWorkflow = true;\n                    }\n                    if (material.roughness !== null) {\n                        defines.push(\"#define ROUGHNESS\");\n                        defines.push(\"#define METALLICWORKFLOW\");\n                        metallicWorkflow = true;\n                    }\n                    if (metallicWorkflow) {\n                        if (material.baseTexture !== null) {\n                            defines.push(\"#define ALBEDOTEXTURE\");\n                            defines.push(`#define ALBEDO_UV${material.baseTexture.coordinatesIndex + 1}`);\n                            if (material.baseTexture.gammaSpace) {\n                                defines.push(\"#define GAMMAALBEDO\");\n                            }\n                            needUv = true;\n                        }\n                        if (material.baseColor !== null) {\n                            defines.push(\"#define ALBEDOCOLOR\");\n                        }\n                    }\n                }\n                else if (material.getClassName() === \"PBRSpecularGlossinessMaterial\") {\n                    // if it is a PBR material in Specular/Glossiness Mode:\n                    if (material.specularGlossinessTexture !== null) {\n                        defines.push(\"#define SPECULARGLOSSINESSTEXTURE\");\n                        defines.push(`#define REFLECTIVITY_UV${material.specularGlossinessTexture.coordinatesIndex + 1}`);\n                        needUv = true;\n                        if (material.specularGlossinessTexture.gammaSpace) {\n                            defines.push(\"#define GAMMAREFLECTIVITYTEXTURE\");\n                        }\n                    }\n                    else {\n                        if (material.specularColor !== null) {\n                            defines.push(\"#define REFLECTIVITYCOLOR\");\n                        }\n                    }\n                    if (material.glossiness !== null) {\n                        defines.push(\"#define GLOSSINESSS\");\n                    }\n                }\n                else if (material.getClassName() === \"PBRMaterial\") {\n                    // if it is the bigger PBRMaterial\n                    if (material.metallicTexture !== null) {\n                        defines.push(\"#define ORMTEXTURE\");\n                        defines.push(`#define REFLECTIVITY_UV${material.metallicTexture.coordinatesIndex + 1}`);\n                        defines.push(\"#define METALLICWORKFLOW\");\n                        needUv = true;\n                        metallicWorkflow = true;\n                    }\n                    if (material.metallic !== null) {\n                        defines.push(\"#define METALLIC\");\n                        defines.push(\"#define METALLICWORKFLOW\");\n                        metallicWorkflow = true;\n                    }\n                    if (material.roughness !== null) {\n                        defines.push(\"#define ROUGHNESS\");\n                        defines.push(\"#define METALLICWORKFLOW\");\n                        metallicWorkflow = true;\n                    }\n                    if (metallicWorkflow) {\n                        if (material.albedoTexture !== null) {\n                            defines.push(\"#define ALBEDOTEXTURE\");\n                            defines.push(`#define ALBEDO_UV${material.albedoTexture.coordinatesIndex + 1}`);\n                            if (material.albedoTexture.gammaSpace) {\n                                defines.push(\"#define GAMMAALBEDO\");\n                            }\n                            needUv = true;\n                        }\n                        if (material.albedoColor !== null) {\n                            defines.push(\"#define ALBEDOCOLOR\");\n                        }\n                    }\n                    else {\n                        // SpecularGlossiness Model\n                        if (material.reflectivityTexture !== null) {\n                            defines.push(\"#define SPECULARGLOSSINESSTEXTURE\");\n                            defines.push(`#define REFLECTIVITY_UV${material.reflectivityTexture.coordinatesIndex + 1}`);\n                            if (material.reflectivityTexture.gammaSpace) {\n                                defines.push(\"#define GAMMAREFLECTIVITYTEXTURE\");\n                            }\n                            needUv = true;\n                        }\n                        else if (material.reflectivityColor !== null) {\n                            defines.push(\"#define REFLECTIVITYCOLOR\");\n                        }\n                        if (material.microSurface !== null) {\n                            defines.push(\"#define GLOSSINESSS\");\n                        }\n                    }\n                }\n                else if (material.getClassName() === \"StandardMaterial\") {\n                    // if StandardMaterial:\n                    if (material.specularTexture !== null) {\n                        defines.push(\"#define REFLECTIVITYTEXTURE\");\n                        defines.push(`#define REFLECTIVITY_UV${material.specularTexture.coordinatesIndex + 1}`);\n                        if (material.specularTexture.gammaSpace) {\n                            defines.push(\"#define GAMMAREFLECTIVITYTEXTURE\");\n                        }\n                        needUv = true;\n                    }\n                    if (material.specularColor !== null) {\n                        defines.push(\"#define REFLECTIVITYCOLOR\");\n                    }\n                }\n            }\n            if (needUv) {\n                defines.push(\"#define NEED_UV\");\n                if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {\n                    attribs.push(VertexBuffer.UVKind);\n                    defines.push(\"#define UV1\");\n                }\n                if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind)) {\n                    attribs.push(VertexBuffer.UV2Kind);\n                    defines.push(\"#define UV2\");\n                }\n            }\n        }\n        // PrePass\n        if (this._linkedWithPrePass) {\n            defines.push(\"#define PREPASS\");\n            if (this._depthIndex !== -1) {\n                defines.push(\"#define DEPTH_INDEX \" + this._depthIndex);\n                defines.push(\"#define PREPASS_DEPTH\");\n            }\n            if (this._normalIndex !== -1) {\n                defines.push(\"#define NORMAL_INDEX \" + this._normalIndex);\n                defines.push(\"#define PREPASS_NORMAL\");\n            }\n        }\n        // Buffers\n        if (this._enablePosition) {\n            defines.push(\"#define POSITION\");\n            defines.push(\"#define POSITION_INDEX \" + this._positionIndex);\n        }\n        if (this._enableVelocity) {\n            defines.push(\"#define VELOCITY\");\n            defines.push(\"#define VELOCITY_INDEX \" + this._velocityIndex);\n            if (this.excludedSkinnedMeshesFromVelocity.indexOf(mesh) === -1) {\n                defines.push(\"#define BONES_VELOCITY_ENABLED\");\n            }\n        }\n        if (this._enableReflectivity) {\n            defines.push(\"#define REFLECTIVITY\");\n            defines.push(\"#define REFLECTIVITY_INDEX \" + this._reflectivityIndex);\n        }\n        // Bones\n        if (mesh.useBones && mesh.computeBonesUsingShaders) {\n            attribs.push(VertexBuffer.MatricesIndicesKind);\n            attribs.push(VertexBuffer.MatricesWeightsKind);\n            if (mesh.numBoneInfluencers > 4) {\n                attribs.push(VertexBuffer.MatricesIndicesExtraKind);\n                attribs.push(VertexBuffer.MatricesWeightsExtraKind);\n            }\n            defines.push(\"#define NUM_BONE_INFLUENCERS \" + mesh.numBoneInfluencers);\n            defines.push(\"#define BonesPerMesh \" + (mesh.skeleton ? mesh.skeleton.bones.length + 1 : 0));\n        }\n        else {\n            defines.push(\"#define NUM_BONE_INFLUENCERS 0\");\n        }\n        // Morph targets\n        const morphTargetManager = mesh.morphTargetManager;\n        let numMorphInfluencers = 0;\n        if (morphTargetManager) {\n            if (morphTargetManager.numInfluencers > 0) {\n                numMorphInfluencers = morphTargetManager.numInfluencers;\n                defines.push(\"#define MORPHTARGETS\");\n                defines.push(\"#define NUM_MORPH_INFLUENCERS \" + numMorphInfluencers);\n                if (morphTargetManager.isUsingTextureForTargets) {\n                    defines.push(\"#define MORPHTARGETS_TEXTURE\");\n                }\n                MaterialHelper.PrepareAttributesForMorphTargetsInfluencers(attribs, mesh, numMorphInfluencers);\n            }\n        }\n        // Instances\n        if (useInstances) {\n            defines.push(\"#define INSTANCES\");\n            MaterialHelper.PushAttributesForInstances(attribs, this._enableVelocity);\n            if (subMesh.getRenderingMesh().hasThinInstances) {\n                defines.push(\"#define THIN_INSTANCES\");\n            }\n        }\n        // Setup textures count\n        if (this._linkedWithPrePass) {\n            defines.push(\"#define RENDER_TARGET_COUNT \" + this._attachments.length);\n        }\n        else {\n            defines.push(\"#define RENDER_TARGET_COUNT \" + this._multiRenderTarget.textures.length);\n        }\n        prepareDefinesForClipPlanes(material, this._scene, defines);\n        // Get correct effect\n        const engine = this._scene.getEngine();\n        const drawWrapper = subMesh._getDrawWrapper(undefined, true);\n        const cachedDefines = drawWrapper.defines;\n        const join = defines.join(\"\\n\");\n        if (cachedDefines !== join) {\n            drawWrapper.setEffect(engine.createEffect(\"geometry\", {\n                attributes: attribs,\n                uniformsNames: uniforms,\n                samplers: [\"diffuseSampler\", \"bumpSampler\", \"reflectivitySampler\", \"albedoSampler\", \"morphTargets\"],\n                defines: join,\n                onCompiled: null,\n                fallbacks: null,\n                onError: null,\n                uniformBuffersNames: [\"Scene\"],\n                indexParameters: { buffersCount: this._multiRenderTarget.textures.length - 1, maxSimultaneousMorphTargets: numMorphInfluencers },\n            }, engine), join);\n        }\n        return drawWrapper.effect.isReady();\n    }\n    /**\n     * Gets the current underlying G Buffer.\n     * @returns the buffer\n     */\n    getGBuffer() {\n        return this._multiRenderTarget;\n    }\n    /**\n     * Gets the number of samples used to render the buffer (anti aliasing).\n     */\n    get samples() {\n        return this._multiRenderTarget.samples;\n    }\n    /**\n     * Sets the number of samples used to render the buffer (anti aliasing).\n     */\n    set samples(value) {\n        this._multiRenderTarget.samples = value;\n    }\n    /**\n     * Disposes the renderer and frees up associated resources.\n     */\n    dispose() {\n        if (this._resizeObserver) {\n            const engine = this._scene.getEngine();\n            engine.onResizeObservable.remove(this._resizeObserver);\n            this._resizeObserver = null;\n        }\n        this.getGBuffer().dispose();\n    }\n    _assignRenderTargetIndices() {\n        const textureNames = [];\n        let count = 2;\n        textureNames.push(\"gBuffer_Depth\", \"gBuffer_Normal\");\n        if (this._enablePosition) {\n            this._positionIndex = count;\n            count++;\n            textureNames.push(\"gBuffer_Position\");\n        }\n        if (this._enableVelocity) {\n            this._velocityIndex = count;\n            count++;\n            textureNames.push(\"gBuffer_Velocity\");\n        }\n        if (this._enableReflectivity) {\n            this._reflectivityIndex = count;\n            count++;\n            textureNames.push(\"gBuffer_Reflectivity\");\n        }\n        return [count, textureNames];\n    }\n    _createRenderTargets() {\n        const engine = this._scene.getEngine();\n        const [count, textureNames] = this._assignRenderTargetIndices();\n        let type = 0;\n        if (engine._caps.textureFloat && engine._caps.textureFloatLinearFiltering) {\n            type = 1;\n        }\n        else if (engine._caps.textureHalfFloat && engine._caps.textureHalfFloatLinearFiltering) {\n            type = 2;\n        }\n        this._multiRenderTarget = new MultiRenderTarget(\"gBuffer\", { width: engine.getRenderWidth() * this._ratio, height: engine.getRenderHeight() * this._ratio }, count, this._scene, { generateMipMaps: false, generateDepthTexture: true, defaultType: type, depthTextureFormat: this._depthFormat }, textureNames.concat(\"gBuffer_DepthBuffer\"));\n        if (!this.isSupported) {\n            return;\n        }\n        this._multiRenderTarget.wrapU = Texture.CLAMP_ADDRESSMODE;\n        this._multiRenderTarget.wrapV = Texture.CLAMP_ADDRESSMODE;\n        this._multiRenderTarget.refreshRate = 1;\n        this._multiRenderTarget.renderParticles = false;\n        this._multiRenderTarget.renderList = null;\n        // set default depth value to 1.0 (far away)\n        this._multiRenderTarget.onClearObservable.add((engine) => {\n            engine.clear(new Color4(0.0, 0.0, 0.0, 0.0), true, true, true);\n        });\n        this._resizeObserver = engine.onResizeObservable.add(() => {\n            if (this._multiRenderTarget) {\n                this._multiRenderTarget.resize({ width: engine.getRenderWidth() * this._ratio, height: engine.getRenderHeight() * this._ratio });\n            }\n        });\n        // Custom render function\n        const renderSubMesh = (subMesh) => {\n            const renderingMesh = subMesh.getRenderingMesh();\n            const effectiveMesh = subMesh.getEffectiveMesh();\n            const scene = this._scene;\n            const engine = scene.getEngine();\n            const material = subMesh.getMaterial();\n            if (!material) {\n                return;\n            }\n            effectiveMesh._internalAbstractMeshDataInfo._isActiveIntermediate = false;\n            // Velocity\n            if (this._enableVelocity && !this._previousTransformationMatrices[effectiveMesh.uniqueId]) {\n                this._previousTransformationMatrices[effectiveMesh.uniqueId] = {\n                    world: Matrix.Identity(),\n                    viewProjection: scene.getTransformMatrix(),\n                };\n                if (renderingMesh.skeleton) {\n                    const bonesTransformations = renderingMesh.skeleton.getTransformMatrices(renderingMesh);\n                    this._previousBonesTransformationMatrices[renderingMesh.uniqueId] = this._copyBonesTransformationMatrices(bonesTransformations, new Float32Array(bonesTransformations.length));\n                }\n            }\n            // Managing instances\n            const batch = renderingMesh._getInstancesRenderList(subMesh._id, !!subMesh.getReplacementMesh());\n            if (batch.mustReturn) {\n                return;\n            }\n            const hardwareInstancedRendering = engine.getCaps().instancedArrays && (batch.visibleInstances[subMesh._id] !== null || renderingMesh.hasThinInstances);\n            const world = effectiveMesh.getWorldMatrix();\n            if (this.isReady(subMesh, hardwareInstancedRendering)) {\n                const drawWrapper = subMesh._getDrawWrapper();\n                if (!drawWrapper) {\n                    return;\n                }\n                const effect = drawWrapper.effect;\n                engine.enableEffect(drawWrapper);\n                if (!hardwareInstancedRendering) {\n                    renderingMesh._bind(subMesh, effect, material.fillMode);\n                }\n                if (!this._useUbo) {\n                    effect.setMatrix(\"viewProjection\", scene.getTransformMatrix());\n                    effect.setMatrix(\"view\", scene.getViewMatrix());\n                }\n                else {\n                    MaterialHelper.BindSceneUniformBuffer(effect, this._scene.getSceneUniformBuffer());\n                    this._scene.finalizeSceneUbo();\n                }\n                let sideOrientation;\n                const instanceDataStorage = renderingMesh._instanceDataStorage;\n                if (!instanceDataStorage.isFrozen && (material.backFaceCulling || renderingMesh.overrideMaterialSideOrientation !== null)) {\n                    const mainDeterminant = effectiveMesh._getWorldMatrixDeterminant();\n                    sideOrientation = renderingMesh.overrideMaterialSideOrientation;\n                    if (sideOrientation === null) {\n                        sideOrientation = material.sideOrientation;\n                    }\n                    if (mainDeterminant < 0) {\n                        sideOrientation = sideOrientation === Material.ClockWiseSideOrientation ? Material.CounterClockWiseSideOrientation : Material.ClockWiseSideOrientation;\n                    }\n                }\n                else {\n                    sideOrientation = instanceDataStorage.sideOrientation;\n                }\n                material._preBind(drawWrapper, sideOrientation);\n                // Alpha test\n                if (material.needAlphaTesting()) {\n                    const alphaTexture = material.getAlphaTestTexture();\n                    if (alphaTexture) {\n                        effect.setTexture(\"diffuseSampler\", alphaTexture);\n                        effect.setMatrix(\"diffuseMatrix\", alphaTexture.getTextureMatrix());\n                    }\n                }\n                // Bump\n                if (material.bumpTexture && scene.getEngine().getCaps().standardDerivatives && MaterialFlags.BumpTextureEnabled) {\n                    effect.setFloat3(\"vBumpInfos\", material.bumpTexture.coordinatesIndex, 1.0 / material.bumpTexture.level, material.parallaxScaleBias);\n                    effect.setMatrix(\"bumpMatrix\", material.bumpTexture.getTextureMatrix());\n                    effect.setTexture(\"bumpSampler\", material.bumpTexture);\n                    effect.setFloat2(\"vTangentSpaceParams\", material.invertNormalMapX ? -1.0 : 1.0, material.invertNormalMapY ? -1.0 : 1.0);\n                }\n                // Reflectivity\n                if (this._enableReflectivity) {\n                    // for PBR materials: cf. https://doc.babylonjs.com/features/featuresDeepDive/materials/using/masterPBR\n                    if (material.getClassName() === \"PBRMetallicRoughnessMaterial\") {\n                        // if it is a PBR material in MetallicRoughness Mode:\n                        if (material.metallicRoughnessTexture !== null) {\n                            effect.setTexture(\"reflectivitySampler\", material.metallicRoughnessTexture);\n                            effect.setMatrix(\"reflectivityMatrix\", material.metallicRoughnessTexture.getTextureMatrix());\n                        }\n                        if (material.metallic !== null) {\n                            effect.setFloat(\"metallic\", material.metallic);\n                        }\n                        if (material.roughness !== null) {\n                            effect.setFloat(\"glossiness\", 1.0 - material.roughness);\n                        }\n                        if (material.baseTexture !== null) {\n                            effect.setTexture(\"albedoSampler\", material.baseTexture);\n                            effect.setMatrix(\"albedoMatrix\", material.baseTexture.getTextureMatrix());\n                        }\n                        if (material.baseColor !== null) {\n                            effect.setColor3(\"albedoColor\", material.baseColor);\n                        }\n                    }\n                    else if (material.getClassName() === \"PBRSpecularGlossinessMaterial\") {\n                        // if it is a PBR material in Specular/Glossiness Mode:\n                        if (material.specularGlossinessTexture !== null) {\n                            effect.setTexture(\"reflectivitySampler\", material.specularGlossinessTexture);\n                            effect.setMatrix(\"reflectivityMatrix\", material.specularGlossinessTexture.getTextureMatrix());\n                        }\n                        else {\n                            if (material.specularColor !== null) {\n                                material.specularColor.toLinearSpaceToRef(this._specularColorLinear);\n                                effect.setColor3(\"reflectivityColor\", this._specularColorLinear);\n                            }\n                        }\n                        if (material.glossiness !== null) {\n                            effect.setFloat(\"glossiness\", material.glossiness);\n                        }\n                    }\n                    else if (material.getClassName() === \"PBRMaterial\") {\n                        // if it is the bigger PBRMaterial\n                        if (material.metallicTexture !== null) {\n                            effect.setTexture(\"reflectivitySampler\", material.metallicTexture);\n                            effect.setMatrix(\"reflectivityMatrix\", material.metallicTexture.getTextureMatrix());\n                        }\n                        if (material.metallic !== null) {\n                            effect.setFloat(\"metallic\", material.metallic);\n                        }\n                        if (material.roughness !== null) {\n                            effect.setFloat(\"glossiness\", 1.0 - material.roughness);\n                        }\n                        if (material.roughness !== null || material.metallic !== null || material.metallicTexture !== null) {\n                            // MetallicRoughness Model\n                            if (material.albedoTexture !== null) {\n                                effect.setTexture(\"albedoSampler\", material.albedoTexture);\n                                effect.setMatrix(\"albedoMatrix\", material.albedoTexture.getTextureMatrix());\n                            }\n                            if (material.albedoColor !== null) {\n                                effect.setColor3(\"albedoColor\", material.albedoColor);\n                            }\n                        }\n                        else {\n                            // SpecularGlossiness Model\n                            if (material.reflectivityTexture !== null) {\n                                effect.setTexture(\"reflectivitySampler\", material.reflectivityTexture);\n                                effect.setMatrix(\"reflectivityMatrix\", material.reflectivityTexture.getTextureMatrix());\n                            }\n                            else if (material.reflectivityColor !== null) {\n                                effect.setColor3(\"reflectivityColor\", material.reflectivityColor);\n                            }\n                            if (material.microSurface !== null) {\n                                effect.setFloat(\"glossiness\", material.microSurface);\n                            }\n                        }\n                    }\n                    else if (material.getClassName() === \"StandardMaterial\") {\n                        // if StandardMaterial:\n                        if (material.specularTexture !== null) {\n                            effect.setTexture(\"reflectivitySampler\", material.specularTexture);\n                            effect.setMatrix(\"reflectivityMatrix\", material.specularTexture.getTextureMatrix());\n                        }\n                        if (material.specularColor !== null) {\n                            effect.setColor3(\"reflectivityColor\", material.specularColor);\n                        }\n                    }\n                }\n                // Clip plane\n                bindClipPlane(effect, material, this._scene);\n                // Bones\n                if (renderingMesh.useBones && renderingMesh.computeBonesUsingShaders && renderingMesh.skeleton) {\n                    effect.setMatrices(\"mBones\", renderingMesh.skeleton.getTransformMatrices(renderingMesh));\n                    if (this._enableVelocity) {\n                        effect.setMatrices(\"mPreviousBones\", this._previousBonesTransformationMatrices[renderingMesh.uniqueId]);\n                    }\n                }\n                // Morph targets\n                MaterialHelper.BindMorphTargetParameters(renderingMesh, effect);\n                if (renderingMesh.morphTargetManager && renderingMesh.morphTargetManager.isUsingTextureForTargets) {\n                    renderingMesh.morphTargetManager._bind(effect);\n                }\n                // Velocity\n                if (this._enableVelocity) {\n                    effect.setMatrix(\"previousWorld\", this._previousTransformationMatrices[effectiveMesh.uniqueId].world);\n                    effect.setMatrix(\"previousViewProjection\", this._previousTransformationMatrices[effectiveMesh.uniqueId].viewProjection);\n                }\n                if (hardwareInstancedRendering && renderingMesh.hasThinInstances) {\n                    effect.setMatrix(\"world\", world);\n                }\n                // Draw\n                renderingMesh._processRendering(effectiveMesh, subMesh, effect, material.fillMode, batch, hardwareInstancedRendering, (isInstance, w) => {\n                    if (!isInstance) {\n                        effect.setMatrix(\"world\", w);\n                    }\n                });\n            }\n            // Velocity\n            if (this._enableVelocity) {\n                this._previousTransformationMatrices[effectiveMesh.uniqueId].world = world.clone();\n                this._previousTransformationMatrices[effectiveMesh.uniqueId].viewProjection = this._scene.getTransformMatrix().clone();\n                if (renderingMesh.skeleton) {\n                    this._copyBonesTransformationMatrices(renderingMesh.skeleton.getTransformMatrices(renderingMesh), this._previousBonesTransformationMatrices[effectiveMesh.uniqueId]);\n                }\n            }\n        };\n        this._multiRenderTarget.customIsReadyFunction = (mesh, refreshRate, preWarm) => {\n            if ((preWarm || refreshRate === 0) && mesh.subMeshes) {\n                for (let i = 0; i < mesh.subMeshes.length; ++i) {\n                    const subMesh = mesh.subMeshes[i];\n                    const material = subMesh.getMaterial();\n                    const renderingMesh = subMesh.getRenderingMesh();\n                    if (!material) {\n                        continue;\n                    }\n                    const batch = renderingMesh._getInstancesRenderList(subMesh._id, !!subMesh.getReplacementMesh());\n                    const hardwareInstancedRendering = engine.getCaps().instancedArrays && (batch.visibleInstances[subMesh._id] !== null || renderingMesh.hasThinInstances);\n                    if (!this.isReady(subMesh, hardwareInstancedRendering)) {\n                        return false;\n                    }\n                }\n            }\n            return true;\n        };\n        this._multiRenderTarget.customRenderFunction = (opaqueSubMeshes, alphaTestSubMeshes, transparentSubMeshes, depthOnlySubMeshes) => {\n            let index;\n            if (this._linkedWithPrePass) {\n                if (!this._prePassRenderer.enabled) {\n                    return;\n                }\n                this._scene.getEngine().bindAttachments(this._attachments);\n            }\n            if (depthOnlySubMeshes.length) {\n                engine.setColorWrite(false);\n                for (index = 0; index < depthOnlySubMeshes.length; index++) {\n                    renderSubMesh(depthOnlySubMeshes.data[index]);\n                }\n                engine.setColorWrite(true);\n            }\n            for (index = 0; index < opaqueSubMeshes.length; index++) {\n                renderSubMesh(opaqueSubMeshes.data[index]);\n            }\n            engine.setDepthWrite(false);\n            for (index = 0; index < alphaTestSubMeshes.length; index++) {\n                renderSubMesh(alphaTestSubMeshes.data[index]);\n            }\n            if (this.renderTransparentMeshes) {\n                for (index = 0; index < transparentSubMeshes.length; index++) {\n                    renderSubMesh(transparentSubMeshes.data[index]);\n                }\n            }\n            engine.setDepthWrite(true);\n        };\n    }\n    // Copies the bones transformation matrices into the target array and returns the target's reference\n    _copyBonesTransformationMatrices(source, target) {\n        for (let i = 0; i < source.length; i++) {\n            target[i] = source[i];\n        }\n        return target;\n    }\n}\n/**\n * Constant used to retrieve the depth texture index in the G-Buffer textures array\n * using getIndex(GeometryBufferRenderer.DEPTH_TEXTURE_INDEX)\n */\nGeometryBufferRenderer.DEPTH_TEXTURE_TYPE = 0;\n/**\n * Constant used to retrieve the normal texture index in the G-Buffer textures array\n * using getIndex(GeometryBufferRenderer.NORMAL_TEXTURE_INDEX)\n */\nGeometryBufferRenderer.NORMAL_TEXTURE_TYPE = 1;\n/**\n * Constant used to retrieve the position texture index in the G-Buffer textures array\n * using getIndex(GeometryBufferRenderer.POSITION_TEXTURE_INDEX)\n */\nGeometryBufferRenderer.POSITION_TEXTURE_TYPE = 2;\n/**\n * Constant used to retrieve the velocity texture index in the G-Buffer textures array\n * using getIndex(GeometryBufferRenderer.VELOCITY_TEXTURE_INDEX)\n */\nGeometryBufferRenderer.VELOCITY_TEXTURE_TYPE = 3;\n/**\n * Constant used to retrieve the reflectivity texture index in the G-Buffer textures array\n * using the getIndex(GeometryBufferRenderer.REFLECTIVITY_TEXTURE_TYPE)\n */\nGeometryBufferRenderer.REFLECTIVITY_TEXTURE_TYPE = 4;\n/**\n * @internal\n */\nGeometryBufferRenderer._SceneComponentInitialization = (_) => {\n    throw _WarnImport(\"GeometryBufferRendererSceneComponent\");\n};\n//# sourceMappingURL=geometryBufferRenderer.js.map","import { Scene } from \"../scene.js\";\nimport { SceneComponentConstants } from \"../sceneComponent.js\";\nimport { GeometryBufferRenderer } from \"./geometryBufferRenderer.js\";\n\nObject.defineProperty(Scene.prototype, \"geometryBufferRenderer\", {\n    get: function () {\n        return this._geometryBufferRenderer;\n    },\n    set: function (value) {\n        if (value && value.isSupported) {\n            this._geometryBufferRenderer = value;\n        }\n    },\n    enumerable: true,\n    configurable: true,\n});\nScene.prototype.enableGeometryBufferRenderer = function (ratio = 1, depthFormat = 15) {\n    if (this._geometryBufferRenderer) {\n        return this._geometryBufferRenderer;\n    }\n    this._geometryBufferRenderer = new GeometryBufferRenderer(this, ratio, depthFormat);\n    if (!this._geometryBufferRenderer.isSupported) {\n        this._geometryBufferRenderer = null;\n    }\n    return this._geometryBufferRenderer;\n};\nScene.prototype.disableGeometryBufferRenderer = function () {\n    if (!this._geometryBufferRenderer) {\n        return;\n    }\n    this._geometryBufferRenderer.dispose();\n    this._geometryBufferRenderer = null;\n};\n/**\n * Defines the Geometry Buffer scene component responsible to manage a G-Buffer useful\n * in several rendering techniques.\n */\nexport class GeometryBufferRendererSceneComponent {\n    /**\n     * Creates a new instance of the component for the given scene\n     * @param scene Defines the scene to register the component in\n     */\n    constructor(scene) {\n        /**\n         * The component name helpful to identify the component in the list of scene components.\n         */\n        this.name = SceneComponentConstants.NAME_GEOMETRYBUFFERRENDERER;\n        this.scene = scene;\n    }\n    /**\n     * Registers the component in a given scene\n     */\n    register() {\n        this.scene._gatherRenderTargetsStage.registerStep(SceneComponentConstants.STEP_GATHERRENDERTARGETS_GEOMETRYBUFFERRENDERER, this, this._gatherRenderTargets);\n    }\n    /**\n     * Rebuilds the elements related to this component in case of\n     * context lost for instance.\n     */\n    rebuild() {\n        // Nothing to do for this component\n    }\n    /**\n     * Disposes the component and the associated resources\n     */\n    dispose() {\n        // Nothing to do for this component\n    }\n    _gatherRenderTargets(renderTargets) {\n        if (this.scene._geometryBufferRenderer) {\n            renderTargets.push(this.scene._geometryBufferRenderer.getGBuffer());\n        }\n    }\n}\nGeometryBufferRenderer._SceneComponentInitialization = (scene) => {\n    // Register the G Buffer component to the scene.\n    let component = scene._getComponent(SceneComponentConstants.NAME_GEOMETRYBUFFERRENDERER);\n    if (!component) {\n        component = new GeometryBufferRendererSceneComponent(scene);\n        scene._addComponent(component);\n    }\n};\n//# sourceMappingURL=geometryBufferRendererSceneComponent.js.map","import { Scene } from \"../scene.js\";\nimport { DepthRenderer } from \"./depthRenderer.js\";\n\nimport { SceneComponentConstants } from \"../sceneComponent.js\";\nScene.prototype.enableDepthRenderer = function (camera, storeNonLinearDepth = false, force32bitsFloat = false, samplingMode = 3) {\n    camera = camera || this.activeCamera;\n    if (!camera) {\n        throw \"No camera available to enable depth renderer\";\n    }\n    if (!this._depthRenderer) {\n        this._depthRenderer = {};\n    }\n    if (!this._depthRenderer[camera.id]) {\n        const supportFullfloat = !!this.getEngine().getCaps().textureFloatRender;\n        let textureType = 0;\n        if (this.getEngine().getCaps().textureHalfFloatRender && (!force32bitsFloat || !supportFullfloat)) {\n            textureType = 2;\n        }\n        else if (supportFullfloat) {\n            textureType = 1;\n        }\n        else {\n            textureType = 0;\n        }\n        this._depthRenderer[camera.id] = new DepthRenderer(this, textureType, camera, storeNonLinearDepth, samplingMode);\n    }\n    return this._depthRenderer[camera.id];\n};\nScene.prototype.disableDepthRenderer = function (camera) {\n    camera = camera || this.activeCamera;\n    if (!camera || !this._depthRenderer || !this._depthRenderer[camera.id]) {\n        return;\n    }\n    this._depthRenderer[camera.id].dispose();\n};\n/**\n * Defines the Depth Renderer scene component responsible to manage a depth buffer useful\n * in several rendering techniques.\n */\nexport class DepthRendererSceneComponent {\n    /**\n     * Creates a new instance of the component for the given scene\n     * @param scene Defines the scene to register the component in\n     */\n    constructor(scene) {\n        /**\n         * The component name helpful to identify the component in the list of scene components.\n         */\n        this.name = SceneComponentConstants.NAME_DEPTHRENDERER;\n        this.scene = scene;\n    }\n    /**\n     * Registers the component in a given scene\n     */\n    register() {\n        this.scene._gatherRenderTargetsStage.registerStep(SceneComponentConstants.STEP_GATHERRENDERTARGETS_DEPTHRENDERER, this, this._gatherRenderTargets);\n        this.scene._gatherActiveCameraRenderTargetsStage.registerStep(SceneComponentConstants.STEP_GATHERACTIVECAMERARENDERTARGETS_DEPTHRENDERER, this, this._gatherActiveCameraRenderTargets);\n    }\n    /**\n     * Rebuilds the elements related to this component in case of\n     * context lost for instance.\n     */\n    rebuild() {\n        // Nothing to do for this component\n    }\n    /**\n     * Disposes the component and the associated resources\n     */\n    dispose() {\n        for (const key in this.scene._depthRenderer) {\n            this.scene._depthRenderer[key].dispose();\n        }\n    }\n    _gatherRenderTargets(renderTargets) {\n        if (this.scene._depthRenderer) {\n            for (const key in this.scene._depthRenderer) {\n                const depthRenderer = this.scene._depthRenderer[key];\n                if (depthRenderer.enabled && !depthRenderer.useOnlyInActiveCamera) {\n                    renderTargets.push(depthRenderer.getDepthMap());\n                }\n            }\n        }\n    }\n    _gatherActiveCameraRenderTargets(renderTargets) {\n        if (this.scene._depthRenderer) {\n            for (const key in this.scene._depthRenderer) {\n                const depthRenderer = this.scene._depthRenderer[key];\n                if (depthRenderer.enabled && depthRenderer.useOnlyInActiveCamera && this.scene.activeCamera.id === key) {\n                    renderTargets.push(depthRenderer.getDepthMap());\n                }\n            }\n        }\n    }\n}\nDepthRenderer._SceneComponentInitialization = (scene) => {\n    // Register the G Buffer component to the scene.\n    let component = scene._getComponent(SceneComponentConstants.NAME_DEPTHRENDERER);\n    if (!component) {\n        component = new DepthRendererSceneComponent(scene);\n        scene._addComponent(component);\n    }\n};\n//# sourceMappingURL=depthRendererSceneComponent.js.map","/**\n * Implementation based on https://medium.com/@shrekshao_71662/dual-depth-peeling-implementation-in-webgl-11baa061ba4b\n */\n\nimport { MultiRenderTarget } from \"../Materials/Textures/multiRenderTarget.js\";\nimport { Color4 } from \"../Maths/math.color.js\";\nimport { SmartArray } from \"../Misc/smartArray.js\";\nimport { ThinTexture } from \"../Materials/Textures/thinTexture.js\";\nimport { EffectRenderer, EffectWrapper } from \"../Materials/effectRenderer.js\";\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture.js\";\nimport { Logger } from \"../Misc/logger.js\";\nimport { Material } from \"../Materials/material.js\";\nimport \"../Shaders/postprocess.vertex.js\";\nimport \"../Shaders/oitFinal.fragment.js\";\nimport \"../Shaders/oitBackBlend.fragment.js\";\nclass DepthPeelingEffectConfiguration {\n    constructor() {\n        /**\n         * Is this effect enabled\n         */\n        this.enabled = true;\n        /**\n         * Name of the configuration\n         */\n        this.name = \"depthPeeling\";\n        /**\n         * Textures that should be present in the MRT for this effect to work\n         */\n        this.texturesRequired = [4];\n    }\n}\n/**\n * The depth peeling renderer that performs\n * Order independant transparency (OIT).\n * This should not be instanciated directly, as it is part of a scene component\n */\nexport class DepthPeelingRenderer {\n    /**\n     * Number of depth peeling passes. As we are using dual depth peeling, each pass two levels of transparency are processed.\n     */\n    get passCount() {\n        return this._passCount;\n    }\n    set passCount(count) {\n        if (this._passCount === count) {\n            return;\n        }\n        this._passCount = count;\n        this._createRenderPassIds();\n    }\n    /**\n     * Instructs the renderer to use render passes. It is an optimization that makes the rendering faster for some engines (like WebGPU) but that consumes more memory, so it is disabled by default.\n     */\n    get useRenderPasses() {\n        return this._useRenderPasses;\n    }\n    set useRenderPasses(usePasses) {\n        if (this._useRenderPasses === usePasses) {\n            return;\n        }\n        this._useRenderPasses = usePasses;\n        this._createRenderPassIds();\n    }\n    /**\n     * Add a mesh in the exclusion list to prevent it to be handled by the depth peeling renderer\n     * @param mesh The mesh to exclude from the depth peeling renderer\n     */\n    addExcludedMesh(mesh) {\n        if (this._excludedMeshes.indexOf(mesh.uniqueId) === -1) {\n            this._excludedMeshes.push(mesh.uniqueId);\n        }\n    }\n    /**\n     * Remove a mesh from the exclusion list of the depth peeling renderer\n     * @param mesh The mesh to remove\n     */\n    removeExcludedMesh(mesh) {\n        const index = this._excludedMeshes.indexOf(mesh.uniqueId);\n        if (index !== -1) {\n            this._excludedMeshes.splice(index, 1);\n        }\n    }\n    /**\n     * Instanciates the depth peeling renderer\n     * @param scene Scene to attach to\n     * @param passCount Number of depth layers to peel\n     * @returns The depth peeling renderer\n     */\n    constructor(scene, passCount = 5) {\n        this._thinTextures = [];\n        this._currentPingPongState = 0;\n        this._layoutCacheFormat = [[true], [true, true], [true, true, true]];\n        this._layoutCache = [];\n        this._candidateSubMeshes = new SmartArray(10);\n        this._excludedSubMeshes = new SmartArray(10);\n        this._excludedMeshes = [];\n        this._colorCache = [\n            new Color4(DepthPeelingRenderer._DEPTH_CLEAR_VALUE, DepthPeelingRenderer._DEPTH_CLEAR_VALUE, 0, 0),\n            new Color4(-DepthPeelingRenderer._MIN_DEPTH, DepthPeelingRenderer._MAX_DEPTH, 0, 0),\n            new Color4(0, 0, 0, 0),\n        ];\n        this._scene = scene;\n        this._engine = scene.getEngine();\n        this._passCount = passCount;\n        //  We need a depth texture for opaque\n        if (!scene.enablePrePassRenderer()) {\n            Logger.Warn(\"Depth peeling for order independant transparency could not enable PrePass, aborting.\");\n            return;\n        }\n        for (let i = 0; i < this._layoutCacheFormat.length; ++i) {\n            this._layoutCache[i] = this._engine.buildTextureLayout(this._layoutCacheFormat[i]);\n        }\n        this._renderPassIds = [];\n        this.useRenderPasses = false;\n        this._prePassEffectConfiguration = new DepthPeelingEffectConfiguration();\n        this._createTextures();\n        this._createEffects();\n    }\n    _createRenderPassIds() {\n        this._releaseRenderPassIds();\n        if (this._useRenderPasses) {\n            for (let i = 0; i < this._passCount + 1; ++i) {\n                if (!this._renderPassIds[i]) {\n                    this._renderPassIds[i] = this._engine.createRenderPassId(`DepthPeelingRenderer - pass #${i}`);\n                }\n            }\n        }\n    }\n    _releaseRenderPassIds() {\n        for (let i = 0; i < this._renderPassIds.length; ++i) {\n            this._engine.releaseRenderPassId(this._renderPassIds[i]);\n        }\n        this._renderPassIds = [];\n    }\n    _createTextures() {\n        const size = {\n            width: this._engine.getRenderWidth(),\n            height: this._engine.getRenderHeight(),\n        };\n        // 2 for ping pong\n        this._depthMrts = [new MultiRenderTarget(\"depthPeelingDepth0\", size, 3, this._scene), new MultiRenderTarget(\"depthPeelingDepth1\", size, 3, this._scene)];\n        this._colorMrts = [\n            new MultiRenderTarget(\"depthPeelingColor0\", size, 2, this._scene, { generateDepthBuffer: false }),\n            new MultiRenderTarget(\"depthPeelingColor1\", size, 2, this._scene, { generateDepthBuffer: false }),\n        ];\n        this._blendBackMrt = new MultiRenderTarget(\"depthPeelingBack\", size, 1, this._scene, { generateDepthBuffer: false });\n        this._outputRT = new RenderTargetTexture(\"depthPeelingOutput\", size, this._scene, false);\n        // 0 is a depth texture\n        // 1 is a color texture\n        const optionsArray = [\n            {\n                format: 7,\n                samplingMode: 1,\n                type: this._engine.getCaps().textureFloatLinearFiltering ? 1 : 2,\n            },\n            {\n                format: 5,\n                samplingMode: 1,\n                type: 2, // For MSAA we need FLOAT\n            },\n        ];\n        for (let i = 0; i < 2; i++) {\n            const depthTexture = this._engine._createInternalTexture(size, optionsArray[0], false);\n            const frontColorTexture = this._engine._createInternalTexture(size, optionsArray[1], false);\n            const backColorTexture = this._engine._createInternalTexture(size, optionsArray[1], false);\n            this._depthMrts[i].setInternalTexture(depthTexture, 0);\n            this._depthMrts[i].setInternalTexture(frontColorTexture, 1);\n            this._depthMrts[i].setInternalTexture(backColorTexture, 2);\n            this._colorMrts[i].setInternalTexture(frontColorTexture, 0);\n            this._colorMrts[i].setInternalTexture(backColorTexture, 1);\n            this._thinTextures.push(new ThinTexture(depthTexture), new ThinTexture(frontColorTexture), new ThinTexture(backColorTexture));\n        }\n    }\n    // TODO : explore again MSAA with depth peeling when\n    // we are able to fetch individual samples in a multisampled renderbuffer\n    // public set samples(value: number) {\n    //     for (let i = 0; i < 2; i++) {\n    //         this._depthMrts[i].samples = value;\n    //         this._colorMrts[i].samples = value;\n    //     }\n    //     this._scene.prePassRenderer!.samples = value;\n    // }\n    _disposeTextures() {\n        for (let i = 0; i < this._thinTextures.length; i++) {\n            if (i === 6) {\n                // Do not dispose the shared texture with the prepass\n                continue;\n            }\n            this._thinTextures[i].dispose();\n        }\n        for (let i = 0; i < 2; i++) {\n            this._depthMrts[i].dispose(true);\n            this._colorMrts[i].dispose(true);\n            this._blendBackMrt.dispose(true);\n        }\n        this._outputRT.dispose();\n        this._thinTextures = [];\n        this._colorMrts = [];\n        this._depthMrts = [];\n    }\n    _updateTextures() {\n        if (this._depthMrts[0].getSize().width !== this._engine.getRenderWidth() || this._depthMrts[0].getSize().height !== this._engine.getRenderHeight()) {\n            this._disposeTextures();\n            this._createTextures();\n        }\n        return this._updateTextureReferences();\n    }\n    _updateTextureReferences() {\n        var _a;\n        const prePassRenderer = this._scene.prePassRenderer;\n        if (!prePassRenderer) {\n            return false;\n        }\n        // Retrieve opaque color texture\n        const textureIndex = prePassRenderer.getIndex(4);\n        const prePassTexture = ((_a = prePassRenderer.defaultRT.textures) === null || _a === void 0 ? void 0 : _a.length) ? prePassRenderer.defaultRT.textures[textureIndex].getInternalTexture() : null;\n        if (!prePassTexture) {\n            return false;\n        }\n        if (this._blendBackTexture !== prePassTexture) {\n            this._blendBackTexture = prePassTexture;\n            this._blendBackMrt.setInternalTexture(this._blendBackTexture, 0);\n            if (this._thinTextures[6]) {\n                this._thinTextures[6].dispose();\n            }\n            this._thinTextures[6] = new ThinTexture(this._blendBackTexture);\n            prePassRenderer.defaultRT.renderTarget._shareDepth(this._depthMrts[0].renderTarget);\n        }\n        return true;\n    }\n    _createEffects() {\n        this._blendBackEffectWrapper = new EffectWrapper({\n            fragmentShader: \"oitBackBlend\",\n            useShaderStore: true,\n            engine: this._engine,\n            samplerNames: [\"uBackColor\"],\n            uniformNames: [],\n        });\n        this._blendBackEffectWrapperPingPong = new EffectWrapper({\n            fragmentShader: \"oitBackBlend\",\n            useShaderStore: true,\n            engine: this._engine,\n            samplerNames: [\"uBackColor\"],\n            uniformNames: [],\n        });\n        this._finalEffectWrapper = new EffectWrapper({\n            fragmentShader: \"oitFinal\",\n            useShaderStore: true,\n            engine: this._engine,\n            samplerNames: [\"uFrontColor\", \"uBackColor\"],\n            uniformNames: [],\n        });\n        this._effectRenderer = new EffectRenderer(this._engine);\n    }\n    /**\n     * Links to the prepass renderer\n     * @param prePassRenderer The scene PrePassRenderer\n     */\n    setPrePassRenderer(prePassRenderer) {\n        prePassRenderer.addEffectConfiguration(this._prePassEffectConfiguration);\n    }\n    /**\n     * Binds depth peeling textures on an effect\n     * @param effect The effect to bind textures on\n     */\n    bind(effect) {\n        effect.setTexture(\"oitDepthSampler\", this._thinTextures[this._currentPingPongState * 3]);\n        effect.setTexture(\"oitFrontColorSampler\", this._thinTextures[this._currentPingPongState * 3 + 1]);\n    }\n    _renderSubMeshes(transparentSubMeshes) {\n        let mapMaterialContext;\n        if (this._useRenderPasses) {\n            mapMaterialContext = {};\n        }\n        for (let j = 0; j < transparentSubMeshes.length; j++) {\n            const material = transparentSubMeshes.data[j].getMaterial();\n            let previousShaderHotSwapping = true;\n            let previousBFC = false;\n            const subMesh = transparentSubMeshes.data[j];\n            let drawWrapper;\n            let firstDraw = false;\n            if (this._useRenderPasses) {\n                drawWrapper = subMesh._getDrawWrapper();\n                firstDraw = !drawWrapper;\n            }\n            if (material) {\n                previousShaderHotSwapping = material.allowShaderHotSwapping;\n                previousBFC = material.backFaceCulling;\n                material.allowShaderHotSwapping = false;\n                material.backFaceCulling = false;\n            }\n            subMesh.render(false);\n            if (firstDraw) {\n                // first time we draw this submesh: we replace the material context\n                drawWrapper = subMesh._getDrawWrapper(); // we are sure it is now non empty as we just rendered the submesh\n                if (drawWrapper.materialContext) {\n                    let newMaterialContext = mapMaterialContext[drawWrapper.materialContext.uniqueId];\n                    if (!newMaterialContext) {\n                        newMaterialContext = mapMaterialContext[drawWrapper.materialContext.uniqueId] = this._engine.createMaterialContext();\n                    }\n                    subMesh._getDrawWrapper().materialContext = newMaterialContext;\n                }\n            }\n            if (material) {\n                material.allowShaderHotSwapping = previousShaderHotSwapping;\n                material.backFaceCulling = previousBFC;\n            }\n        }\n    }\n    _finalCompose(writeId) {\n        var _a;\n        const output = (_a = this._scene.prePassRenderer) === null || _a === void 0 ? void 0 : _a.setCustomOutput(this._outputRT);\n        if (output) {\n            this._engine.bindFramebuffer(this._outputRT.renderTarget);\n        }\n        else {\n            this._engine.restoreDefaultFramebuffer();\n        }\n        this._engine.setAlphaMode(0);\n        this._engine.applyStates();\n        this._engine.enableEffect(this._finalEffectWrapper._drawWrapper);\n        this._finalEffectWrapper.effect.setTexture(\"uFrontColor\", this._thinTextures[writeId * 3 + 1]);\n        this._finalEffectWrapper.effect.setTexture(\"uBackColor\", this._thinTextures[6]);\n        this._effectRenderer.render(this._finalEffectWrapper);\n    }\n    /**\n     * Renders transparent submeshes with depth peeling\n     * @param transparentSubMeshes List of transparent meshes to render\n     * @returns The array of submeshes that could not be handled by this renderer\n     */\n    render(transparentSubMeshes) {\n        this._candidateSubMeshes.length = 0;\n        this._excludedSubMeshes.length = 0;\n        if (!this._blendBackEffectWrapper.effect.isReady() ||\n            !this._blendBackEffectWrapperPingPong.effect.isReady() ||\n            !this._finalEffectWrapper.effect.isReady() ||\n            !this._updateTextures()) {\n            return this._excludedSubMeshes;\n        }\n        for (let i = 0; i < transparentSubMeshes.length; i++) {\n            const subMesh = transparentSubMeshes.data[i];\n            const material = subMesh.getMaterial();\n            if (material &&\n                (material.fillMode === Material.TriangleFanDrawMode || material.fillMode === Material.TriangleFillMode || material.fillMode === Material.TriangleStripDrawMode) &&\n                this._excludedMeshes.indexOf(subMesh.getMesh().uniqueId) === -1) {\n                this._candidateSubMeshes.push(subMesh);\n            }\n            else {\n                this._excludedSubMeshes.push(subMesh);\n            }\n        }\n        if (!this._candidateSubMeshes.length) {\n            this._engine.bindFramebuffer(this._colorMrts[1].renderTarget);\n            this._engine.bindAttachments(this._layoutCache[1]);\n            this._engine.clear(this._colorCache[2], true, false, false);\n            this._engine.unBindFramebuffer(this._colorMrts[1].renderTarget);\n            this._finalCompose(1);\n            return this._excludedSubMeshes;\n        }\n        const currentRenderPassId = this._engine.currentRenderPassId;\n        this._scene.prePassRenderer._enabled = false;\n        if (this._useRenderPasses) {\n            this._engine.currentRenderPassId = this._renderPassIds[0];\n        }\n        // Clears\n        this._engine.bindFramebuffer(this._depthMrts[0].renderTarget);\n        this._engine.bindAttachments(this._layoutCache[0]);\n        this._engine.clear(this._colorCache[0], true, false, false);\n        this._engine.unBindFramebuffer(this._depthMrts[0].renderTarget);\n        this._engine.bindFramebuffer(this._depthMrts[1].renderTarget);\n        this._engine.bindAttachments(this._layoutCache[0]);\n        this._engine.clear(this._colorCache[1], true, false, false);\n        this._engine.unBindFramebuffer(this._depthMrts[1].renderTarget);\n        this._engine.bindFramebuffer(this._colorMrts[0].renderTarget);\n        this._engine.bindAttachments(this._layoutCache[1]);\n        this._engine.clear(this._colorCache[2], true, false, false);\n        this._engine.unBindFramebuffer(this._colorMrts[0].renderTarget);\n        this._engine.bindFramebuffer(this._colorMrts[1].renderTarget);\n        this._engine.bindAttachments(this._layoutCache[1]);\n        this._engine.clear(this._colorCache[2], true, false, false);\n        this._engine.unBindFramebuffer(this._colorMrts[1].renderTarget);\n        // Draw depth for first pass\n        this._engine.bindFramebuffer(this._depthMrts[0].renderTarget);\n        this._engine.bindAttachments(this._layoutCache[0]);\n        this._engine.setAlphaMode(11); // in WebGPU, when using MIN or MAX equation, the src / dst color factors should not use SRC_ALPHA and the src / dst alpha factors must be 1 else WebGPU will throw a validation error\n        this._engine.setAlphaEquation(3);\n        this._engine.depthCullingState.depthMask = false;\n        this._engine.depthCullingState.depthTest = true;\n        this._engine.applyStates();\n        this._currentPingPongState = 1;\n        // Render\n        this._renderSubMeshes(this._candidateSubMeshes);\n        this._engine.unBindFramebuffer(this._depthMrts[0].renderTarget);\n        this._scene.resetCachedMaterial();\n        // depth peeling ping-pong\n        let readId = 0;\n        let writeId = 0;\n        for (let i = 0; i < this._passCount; i++) {\n            readId = i % 2;\n            writeId = 1 - readId;\n            this._currentPingPongState = readId;\n            if (this._useRenderPasses) {\n                this._engine.currentRenderPassId = this._renderPassIds[i + 1];\n            }\n            // Clears\n            this._engine.bindFramebuffer(this._depthMrts[writeId].renderTarget);\n            this._engine.bindAttachments(this._layoutCache[0]);\n            this._engine.clear(this._colorCache[0], true, false, false);\n            this._engine.unBindFramebuffer(this._depthMrts[writeId].renderTarget);\n            this._engine.bindFramebuffer(this._colorMrts[writeId].renderTarget);\n            this._engine.bindAttachments(this._layoutCache[1]);\n            this._engine.clear(this._colorCache[2], true, false, false);\n            this._engine.unBindFramebuffer(this._colorMrts[writeId].renderTarget);\n            this._engine.bindFramebuffer(this._depthMrts[writeId].renderTarget);\n            this._engine.bindAttachments(this._layoutCache[2]);\n            this._engine.setAlphaMode(11); // the value does not matter (as MAX operation does not use them) but the src and dst color factors should not use SRC_ALPHA else WebGPU will throw a validation error\n            this._engine.setAlphaEquation(3);\n            this._engine.depthCullingState.depthTest = false;\n            this._engine.applyStates();\n            // Render\n            this._renderSubMeshes(this._candidateSubMeshes);\n            this._engine.unBindFramebuffer(this._depthMrts[writeId].renderTarget);\n            this._scene.resetCachedMaterial();\n            // Back color\n            this._engine.bindFramebuffer(this._blendBackMrt.renderTarget);\n            this._engine.bindAttachments(this._layoutCache[0]);\n            this._engine.setAlphaEquation(0);\n            this._engine.setAlphaMode(17);\n            this._engine.applyStates();\n            const blendBackEffectWrapper = writeId === 0 || !this._useRenderPasses ? this._blendBackEffectWrapper : this._blendBackEffectWrapperPingPong;\n            this._engine.enableEffect(blendBackEffectWrapper._drawWrapper);\n            blendBackEffectWrapper.effect.setTexture(\"uBackColor\", this._thinTextures[writeId * 3 + 2]);\n            this._effectRenderer.render(blendBackEffectWrapper);\n            this._engine.unBindFramebuffer(this._blendBackMrt.renderTarget);\n        }\n        this._engine.currentRenderPassId = currentRenderPassId;\n        // Final composition on default FB\n        this._finalCompose(writeId);\n        this._scene.prePassRenderer._enabled = true;\n        this._engine.depthCullingState.depthMask = true;\n        this._engine.depthCullingState.depthTest = true;\n        return this._excludedSubMeshes;\n    }\n    /**\n     * Disposes the depth peeling renderer and associated ressources\n     */\n    dispose() {\n        this._disposeTextures();\n        this._blendBackEffectWrapper.dispose();\n        this._finalEffectWrapper.dispose();\n        this._effectRenderer.dispose();\n        this._releaseRenderPassIds();\n    }\n}\nDepthPeelingRenderer._DEPTH_CLEAR_VALUE = -99999.0;\nDepthPeelingRenderer._MIN_DEPTH = 0;\nDepthPeelingRenderer._MAX_DEPTH = 1;\n//# sourceMappingURL=depthPeelingRenderer.js.map","\nimport { Scene } from \"../scene.js\";\nimport { SceneComponentConstants } from \"../sceneComponent.js\";\nimport { DepthPeelingRenderer } from \"./depthPeelingRenderer.js\";\nObject.defineProperty(Scene.prototype, \"depthPeelingRenderer\", {\n    get: function () {\n        if (!this._depthPeelingRenderer) {\n            let component = this._getComponent(SceneComponentConstants.NAME_DEPTHPEELINGRENDERER);\n            if (!component) {\n                component = new DepthPeelingSceneComponent(this);\n                this._addComponent(component);\n            }\n        }\n        return this._depthPeelingRenderer;\n    },\n    set: function (value) {\n        this._depthPeelingRenderer = value;\n    },\n    enumerable: true,\n    configurable: true,\n});\nObject.defineProperty(Scene.prototype, \"useOrderIndependentTransparency\", {\n    get: function () {\n        return this._useOrderIndependentTransparency;\n    },\n    set: function (value) {\n        var _a;\n        if (this._useOrderIndependentTransparency === value) {\n            return;\n        }\n        this._useOrderIndependentTransparency = value;\n        this.markAllMaterialsAsDirty(63);\n        (_a = this.prePassRenderer) === null || _a === void 0 ? void 0 : _a.markAsDirty();\n    },\n    enumerable: true,\n    configurable: true,\n});\n/**\n * Scene component to render order independent transparency with depth peeling\n */\nexport class DepthPeelingSceneComponent {\n    /**\n     * Creates a new instance of the component for the given scene\n     * @param scene Defines the scene to register the component in\n     */\n    constructor(scene) {\n        /**\n         * The component name helpful to identify the component in the list of scene components.\n         */\n        this.name = SceneComponentConstants.NAME_DEPTHPEELINGRENDERER;\n        this.scene = scene;\n        scene.depthPeelingRenderer = new DepthPeelingRenderer(scene);\n    }\n    /**\n     * Registers the component in a given scene\n     */\n    register() { }\n    /**\n     * Rebuilds the elements related to this component in case of\n     * context lost for instance.\n     */\n    rebuild() { }\n    /**\n     * Disposes the component and the associated resources.\n     */\n    dispose() {\n        var _a;\n        (_a = this.scene.depthPeelingRenderer) === null || _a === void 0 ? void 0 : _a.dispose();\n        this.scene.depthPeelingRenderer = null;\n    }\n}\n//# sourceMappingURL=depthPeelingSceneComponent.js.map","import { PrePassRenderTarget } from \"../Materials/Textures/prePassRenderTarget.js\";\n\nimport { _WarnImport } from \"../Misc/devTools.js\";\nimport { Color4 } from \"../Maths/math.color.js\";\nimport { Material } from \"../Materials/material.js\";\nimport { GeometryBufferRenderer } from \"../Rendering/geometryBufferRenderer.js\";\n/**\n * Renders a pre pass of the scene\n * This means every mesh in the scene will be rendered to a render target texture\n * And then this texture will be composited to the rendering canvas with post processes\n * It is necessary for effects like subsurface scattering or deferred shading\n */\nexport class PrePassRenderer {\n    /**\n     * Returns the index of a texture in the multi render target texture array.\n     * @param type Texture type\n     * @returns The index\n     */\n    getIndex(type) {\n        return this._textureIndices[type];\n    }\n    /**\n     * How many samples are used for MSAA of the scene render target\n     */\n    get samples() {\n        return this.defaultRT.samples;\n    }\n    set samples(n) {\n        this.defaultRT.samples = n;\n    }\n    /**\n     * @returns the prepass render target for the rendering pass.\n     * If we are currently rendering a render target, it returns the PrePassRenderTarget\n     * associated with that render target. Otherwise, it returns the scene default PrePassRenderTarget\n     */\n    getRenderTarget() {\n        return this._currentTarget;\n    }\n    /**\n     * @internal\n     * Managed by the scene component\n     * @param prePassRenderTarget\n     */\n    _setRenderTarget(prePassRenderTarget) {\n        if (prePassRenderTarget) {\n            this._currentTarget = prePassRenderTarget;\n        }\n        else {\n            this._currentTarget = this.defaultRT;\n            this._engine.currentRenderPassId = this._currentTarget.renderPassId;\n        }\n    }\n    /**\n     * Returns true if the currently rendered prePassRenderTarget is the one\n     * associated with the scene.\n     */\n    get currentRTisSceneRT() {\n        return this._currentTarget === this.defaultRT;\n    }\n    _refreshGeometryBufferRendererLink() {\n        if (!this.doNotUseGeometryRendererFallback) {\n            this._geometryBuffer = this._scene.enableGeometryBufferRenderer();\n            if (!this._geometryBuffer) {\n                // Not supported\n                this.doNotUseGeometryRendererFallback = true;\n                return;\n            }\n            this._geometryBuffer._linkPrePassRenderer(this);\n        }\n        else {\n            if (this._geometryBuffer) {\n                this._geometryBuffer._unlinkPrePassRenderer();\n            }\n            this._geometryBuffer = null;\n            this._scene.disableGeometryBufferRenderer();\n        }\n    }\n    /**\n     * Indicates if the prepass is enabled\n     */\n    get enabled() {\n        return this._enabled;\n    }\n    /**\n     * Instantiates a prepass renderer\n     * @param scene The scene\n     */\n    constructor(scene) {\n        /**\n         * To save performance, we can excluded skinned meshes from the prepass\n         */\n        this.excludedSkinnedMesh = [];\n        /**\n         * Force material to be excluded from the prepass\n         * Can be useful when `useGeometryBufferFallback` is set to `true`\n         * and you don't want a material to show in the effect.\n         */\n        this.excludedMaterials = [];\n        /**\n         * Number of textures in the multi render target texture where the scene is directly rendered\n         */\n        this.mrtCount = 0;\n        this._mrtFormats = [];\n        this._mrtLayout = [];\n        this._mrtNames = [];\n        this._textureIndices = [];\n        this._isDirty = true;\n        /**\n         * Configuration for prepass effects\n         */\n        this._effectConfigurations = [];\n        /**\n         * Prevents the PrePassRenderer from using the GeometryBufferRenderer as a fallback\n         */\n        this.doNotUseGeometryRendererFallback = true;\n        /**\n         * All the render targets generated by prepass\n         */\n        this.renderTargets = [];\n        this._clearColor = new Color4(0, 0, 0, 0);\n        this._enabled = false;\n        this._needsCompositionForThisPass = false;\n        /**\n         * Set to true to disable gamma transform in PrePass.\n         * Can be useful in case you already proceed to gamma transform on a material level\n         * and your post processes don't need to be in linear color space.\n         */\n        this.disableGammaTransform = false;\n        this._scene = scene;\n        this._engine = scene.getEngine();\n        PrePassRenderer._SceneComponentInitialization(this._scene);\n        this.defaultRT = this._createRenderTarget(\"sceneprePassRT\", null);\n        this._currentTarget = this.defaultRT;\n    }\n    /**\n     * Creates a new PrePassRenderTarget\n     * This should be the only way to instantiate a `PrePassRenderTarget`\n     * @param name Name of the `PrePassRenderTarget`\n     * @param renderTargetTexture RenderTarget the `PrePassRenderTarget` will be attached to.\n     * Can be `null` if the created `PrePassRenderTarget` is attached to the scene (default framebuffer).\n     * @internal\n     */\n    _createRenderTarget(name, renderTargetTexture) {\n        const rt = new PrePassRenderTarget(name, renderTargetTexture, { width: this._engine.getRenderWidth(), height: this._engine.getRenderHeight() }, 0, this._scene, {\n            generateMipMaps: false,\n            generateStencilBuffer: this._engine.isStencilEnable,\n            defaultType: 0,\n            types: [],\n            drawOnlyOnFirstAttachmentByDefault: true,\n        });\n        this.renderTargets.push(rt);\n        return rt;\n    }\n    /**\n     * Indicates if rendering a prepass is supported\n     */\n    get isSupported() {\n        return this._scene.getEngine().getCaps().drawBuffersExtension;\n    }\n    /**\n     * Sets the proper output textures to draw in the engine.\n     * @param effect The effect that is drawn. It can be or not be compatible with drawing to several output textures.\n     * @param subMesh Submesh on which the effect is applied\n     */\n    bindAttachmentsForEffect(effect, subMesh) {\n        const material = subMesh.getMaterial();\n        const isPrePassCapable = material && material.isPrePassCapable;\n        const excluded = material && this.excludedMaterials.indexOf(material) !== -1;\n        if (this.enabled && this._currentTarget.enabled) {\n            if (effect._multiTarget && isPrePassCapable && !excluded) {\n                this._engine.bindAttachments(this._multiRenderAttachments);\n            }\n            else {\n                if (this._engine._currentRenderTarget) {\n                    this._engine.bindAttachments(this._defaultAttachments);\n                }\n                else {\n                    this._engine.restoreSingleAttachment();\n                }\n                if (this._geometryBuffer && this.currentRTisSceneRT && !excluded) {\n                    this._geometryBuffer.renderList.push(subMesh.getRenderingMesh());\n                }\n            }\n        }\n    }\n    _reinitializeAttachments() {\n        const multiRenderLayout = [];\n        const clearLayout = [false];\n        const defaultLayout = [true];\n        for (let i = 0; i < this.mrtCount; i++) {\n            multiRenderLayout.push(true);\n            if (i > 0) {\n                clearLayout.push(true);\n                defaultLayout.push(false);\n            }\n        }\n        this._multiRenderAttachments = this._engine.buildTextureLayout(multiRenderLayout);\n        this._clearAttachments = this._engine.buildTextureLayout(clearLayout);\n        this._defaultAttachments = this._engine.buildTextureLayout(defaultLayout);\n    }\n    _resetLayout() {\n        for (let i = 0; i < PrePassRenderer._TextureFormats.length; i++) {\n            this._textureIndices[PrePassRenderer._TextureFormats[i].type] = -1;\n        }\n        this._textureIndices[4] = 0;\n        this._mrtLayout = [4];\n        this._mrtFormats = [PrePassRenderer._TextureFormats[4].format];\n        this._mrtNames = [PrePassRenderer._TextureFormats[4].name];\n        this.mrtCount = 1;\n    }\n    _updateGeometryBufferLayout() {\n        this._refreshGeometryBufferRendererLink();\n        if (this._geometryBuffer) {\n            this._geometryBuffer._resetLayout();\n            const texturesActivated = [];\n            for (let i = 0; i < this._mrtLayout.length; i++) {\n                texturesActivated.push(false);\n            }\n            this._geometryBuffer._linkInternalTexture(this.defaultRT.getInternalTexture());\n            const matches = [\n                {\n                    prePassConstant: 5,\n                    geometryBufferConstant: GeometryBufferRenderer.DEPTH_TEXTURE_TYPE,\n                },\n                {\n                    prePassConstant: 6,\n                    geometryBufferConstant: GeometryBufferRenderer.NORMAL_TEXTURE_TYPE,\n                },\n                {\n                    prePassConstant: 1,\n                    geometryBufferConstant: GeometryBufferRenderer.POSITION_TEXTURE_TYPE,\n                },\n                {\n                    prePassConstant: 3,\n                    geometryBufferConstant: GeometryBufferRenderer.REFLECTIVITY_TEXTURE_TYPE,\n                },\n                {\n                    prePassConstant: 2,\n                    geometryBufferConstant: GeometryBufferRenderer.VELOCITY_TEXTURE_TYPE,\n                },\n            ];\n            // replace textures in the geometryBuffer RT\n            for (let i = 0; i < matches.length; i++) {\n                const index = this._mrtLayout.indexOf(matches[i].prePassConstant);\n                if (index !== -1) {\n                    this._geometryBuffer._forceTextureType(matches[i].geometryBufferConstant, index);\n                    texturesActivated[index] = true;\n                }\n            }\n            this._geometryBuffer._setAttachments(this._engine.buildTextureLayout(texturesActivated));\n        }\n    }\n    /**\n     * Restores attachments for single texture draw.\n     */\n    restoreAttachments() {\n        if (this.enabled && this._currentTarget.enabled && this._defaultAttachments) {\n            if (this._engine._currentRenderTarget) {\n                this._engine.bindAttachments(this._defaultAttachments);\n            }\n            else {\n                this._engine.restoreSingleAttachment();\n            }\n        }\n    }\n    /**\n     * @internal\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _beforeDraw(camera, faceIndex, layer) {\n        // const previousEnabled = this._enabled && this._currentTarget.enabled;\n        if (this._isDirty) {\n            this._update();\n        }\n        if (!this._enabled || !this._currentTarget.enabled) {\n            return;\n        }\n        if (this._geometryBuffer) {\n            this._geometryBuffer.renderList = [];\n        }\n        this._setupOutputForThisPass(this._currentTarget, camera);\n    }\n    _prepareFrame(prePassRenderTarget, faceIndex, layer) {\n        if (prePassRenderTarget.renderTargetTexture) {\n            prePassRenderTarget.renderTargetTexture._prepareFrame(this._scene, faceIndex, layer, prePassRenderTarget.renderTargetTexture.useCameraPostProcesses);\n        }\n        else if (this._postProcessesSourceForThisPass.length) {\n            this._scene.postProcessManager._prepareFrame();\n        }\n        else {\n            this._engine.restoreDefaultFramebuffer();\n        }\n    }\n    /**\n     * Sets an intermediary texture between prepass and postprocesses. This texture\n     * will be used as input for post processes\n     * @param rt\n     * @returns true if there are postprocesses that will use this texture,\n     * false if there is no postprocesses - and the function has no effect\n     */\n    setCustomOutput(rt) {\n        const firstPP = this._postProcessesSourceForThisPass[0];\n        if (!firstPP) {\n            return false;\n        }\n        firstPP.inputTexture = rt.renderTarget;\n        return true;\n    }\n    _renderPostProcesses(prePassRenderTarget, faceIndex) {\n        var _a;\n        const firstPP = this._postProcessesSourceForThisPass[0];\n        const outputTexture = firstPP ? firstPP.inputTexture : prePassRenderTarget.renderTargetTexture ? prePassRenderTarget.renderTargetTexture.renderTarget : null;\n        // Build post process chain for this prepass post draw\n        let postProcessChain = this._currentTarget._beforeCompositionPostProcesses;\n        if (this._needsCompositionForThisPass) {\n            postProcessChain = postProcessChain.concat([this._currentTarget.imageProcessingPostProcess]);\n        }\n        // Activates and renders the chain\n        if (postProcessChain.length) {\n            this._scene.postProcessManager._prepareFrame((_a = this._currentTarget.renderTarget) === null || _a === void 0 ? void 0 : _a.texture, postProcessChain);\n            this._scene.postProcessManager.directRender(postProcessChain, outputTexture, false, faceIndex);\n        }\n    }\n    /**\n     * @internal\n     */\n    _afterDraw(faceIndex, layer) {\n        if (this._enabled && this._currentTarget.enabled) {\n            this._prepareFrame(this._currentTarget, faceIndex, layer);\n            this._renderPostProcesses(this._currentTarget, faceIndex);\n        }\n    }\n    /**\n     * Clears the current prepass render target (in the sense of settings pixels to the scene clear color value)\n     * @internal\n     */\n    _clear() {\n        if (this._enabled && this._currentTarget.enabled) {\n            this._bindFrameBuffer(this._currentTarget);\n            // Clearing other attachment with 0 on all other attachments\n            this._engine.bindAttachments(this._clearAttachments);\n            this._engine.clear(this._clearColor, true, false, false);\n            // Regular clear color with the scene clear color of the 1st attachment\n            this._engine.bindAttachments(this._defaultAttachments);\n        }\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _bindFrameBuffer(prePassRenderTarget) {\n        if (this._enabled && this._currentTarget.enabled) {\n            this._currentTarget._checkSize();\n            const internalTexture = this._currentTarget.renderTarget;\n            if (internalTexture) {\n                this._engine.bindFramebuffer(internalTexture);\n            }\n        }\n    }\n    _setEnabled(enabled) {\n        this._enabled = enabled;\n    }\n    _setRenderTargetEnabled(prePassRenderTarget, enabled) {\n        prePassRenderTarget.enabled = enabled;\n        if (!enabled) {\n            this._unlinkInternalTexture(prePassRenderTarget);\n        }\n    }\n    /**\n     * Adds an effect configuration to the prepass render target.\n     * If an effect has already been added, it won't add it twice and will return the configuration\n     * already present.\n     * @param cfg the effect configuration\n     * @returns the effect configuration now used by the prepass\n     */\n    addEffectConfiguration(cfg) {\n        // Do not add twice\n        for (let i = 0; i < this._effectConfigurations.length; i++) {\n            if (this._effectConfigurations[i].name === cfg.name) {\n                return this._effectConfigurations[i];\n            }\n        }\n        this._effectConfigurations.push(cfg);\n        return cfg;\n    }\n    _enable() {\n        const previousMrtCount = this.mrtCount;\n        for (let i = 0; i < this._effectConfigurations.length; i++) {\n            if (this._effectConfigurations[i].enabled) {\n                this._enableTextures(this._effectConfigurations[i].texturesRequired);\n            }\n        }\n        for (let i = 0; i < this.renderTargets.length; i++) {\n            if (this.mrtCount !== previousMrtCount || this.renderTargets[i].count !== this.mrtCount) {\n                this.renderTargets[i].updateCount(this.mrtCount, { types: this._mrtFormats }, this._mrtNames.concat(\"prePass_DepthBuffer\"));\n            }\n            this.renderTargets[i]._resetPostProcessChain();\n            for (let j = 0; j < this._effectConfigurations.length; j++) {\n                if (this._effectConfigurations[j].enabled) {\n                    // TODO : subsurface scattering has 1 scene-wide effect configuration\n                    // solution : do not stock postProcess on effectConfiguration, but in the prepassRenderTarget (hashmap configuration => postProcess)\n                    // And call createPostProcess whenever the post process does not exist in the RT\n                    if (!this._effectConfigurations[j].postProcess && this._effectConfigurations[j].createPostProcess) {\n                        this._effectConfigurations[j].createPostProcess();\n                    }\n                    if (this._effectConfigurations[j].postProcess) {\n                        this.renderTargets[i]._beforeCompositionPostProcesses.push(this._effectConfigurations[j].postProcess);\n                    }\n                }\n            }\n        }\n        this._reinitializeAttachments();\n        this._setEnabled(true);\n        this._updateGeometryBufferLayout();\n    }\n    _disable() {\n        this._setEnabled(false);\n        for (let i = 0; i < this.renderTargets.length; i++) {\n            this._setRenderTargetEnabled(this.renderTargets[i], false);\n        }\n        this._resetLayout();\n        for (let i = 0; i < this._effectConfigurations.length; i++) {\n            this._effectConfigurations[i].enabled = false;\n        }\n    }\n    _getPostProcessesSource(prePassRenderTarget, camera) {\n        if (camera) {\n            return camera._postProcesses;\n        }\n        else if (prePassRenderTarget.renderTargetTexture) {\n            if (prePassRenderTarget.renderTargetTexture.useCameraPostProcesses) {\n                const camera = prePassRenderTarget.renderTargetTexture.activeCamera ? prePassRenderTarget.renderTargetTexture.activeCamera : this._scene.activeCamera;\n                return camera ? camera._postProcesses : [];\n            }\n            else if (prePassRenderTarget.renderTargetTexture.postProcesses) {\n                return prePassRenderTarget.renderTargetTexture.postProcesses;\n            }\n            else {\n                return [];\n            }\n        }\n        else {\n            return this._scene.activeCamera ? this._scene.activeCamera._postProcesses : [];\n        }\n    }\n    _setupOutputForThisPass(prePassRenderTarget, camera) {\n        // Order is : draw ===> prePassRenderTarget._postProcesses ==> ipp ==> camera._postProcesses\n        const secondaryCamera = camera && this._scene.activeCameras && !!this._scene.activeCameras.length && this._scene.activeCameras.indexOf(camera) !== 0;\n        this._postProcessesSourceForThisPass = this._getPostProcessesSource(prePassRenderTarget, camera);\n        this._postProcessesSourceForThisPass = this._postProcessesSourceForThisPass.filter((pp) => {\n            return pp != null;\n        });\n        this._scene.autoClear = true;\n        const cameraHasImageProcessing = this._hasImageProcessing(this._postProcessesSourceForThisPass);\n        this._needsCompositionForThisPass = !cameraHasImageProcessing && !this.disableGammaTransform && this._needsImageProcessing() && !secondaryCamera;\n        const firstCameraPP = this._getFirstPostProcess(this._postProcessesSourceForThisPass);\n        const firstPrePassPP = prePassRenderTarget._beforeCompositionPostProcesses && prePassRenderTarget._beforeCompositionPostProcesses[0];\n        let firstPP = null;\n        // Setting the scene-wide post process configuration\n        this._scene.imageProcessingConfiguration.applyByPostProcess = this._needsCompositionForThisPass || cameraHasImageProcessing;\n        // Create composition effect if needed\n        if (this._needsCompositionForThisPass && !prePassRenderTarget.imageProcessingPostProcess) {\n            prePassRenderTarget._createCompositionEffect();\n        }\n        // Setting the prePassRenderTarget as input texture of the first PP\n        if (firstPrePassPP) {\n            firstPP = firstPrePassPP;\n        }\n        else if (this._needsCompositionForThisPass) {\n            firstPP = prePassRenderTarget.imageProcessingPostProcess;\n        }\n        else if (firstCameraPP) {\n            firstPP = firstCameraPP;\n        }\n        this._bindFrameBuffer(prePassRenderTarget);\n        this._linkInternalTexture(prePassRenderTarget, firstPP);\n    }\n    _linkInternalTexture(prePassRenderTarget, postProcess) {\n        if (postProcess) {\n            postProcess.autoClear = false;\n            postProcess.inputTexture = prePassRenderTarget.renderTarget;\n        }\n        if (prePassRenderTarget._outputPostProcess !== postProcess) {\n            if (prePassRenderTarget._outputPostProcess) {\n                this._unlinkInternalTexture(prePassRenderTarget);\n            }\n            prePassRenderTarget._outputPostProcess = postProcess;\n        }\n        if (prePassRenderTarget._internalTextureDirty) {\n            this._updateGeometryBufferLayout();\n            prePassRenderTarget._internalTextureDirty = false;\n        }\n    }\n    /**\n     * @internal\n     */\n    _unlinkInternalTexture(prePassRenderTarget) {\n        if (prePassRenderTarget._outputPostProcess) {\n            prePassRenderTarget._outputPostProcess.autoClear = true;\n            prePassRenderTarget._outputPostProcess.restoreDefaultInputTexture();\n            prePassRenderTarget._outputPostProcess = null;\n        }\n    }\n    _needsImageProcessing() {\n        for (let i = 0; i < this._effectConfigurations.length; i++) {\n            if (this._effectConfigurations[i].enabled && this._effectConfigurations[i].needsImageProcessing) {\n                return true;\n            }\n        }\n        return false;\n    }\n    _hasImageProcessing(postProcesses) {\n        var _a;\n        let isIPPAlreadyPresent = false;\n        if (postProcesses) {\n            for (let i = 0; i < postProcesses.length; i++) {\n                if (((_a = postProcesses[i]) === null || _a === void 0 ? void 0 : _a.getClassName()) === \"ImageProcessingPostProcess\") {\n                    isIPPAlreadyPresent = true;\n                    break;\n                }\n            }\n        }\n        return isIPPAlreadyPresent;\n    }\n    /**\n     * Internal, gets the first post proces.\n     * @param postProcesses\n     * @returns the first post process to be run on this camera.\n     */\n    _getFirstPostProcess(postProcesses) {\n        for (let ppIndex = 0; ppIndex < postProcesses.length; ppIndex++) {\n            if (postProcesses[ppIndex] !== null) {\n                return postProcesses[ppIndex];\n            }\n        }\n        return null;\n    }\n    /**\n     * Marks the prepass renderer as dirty, triggering a check if the prepass is necessary for the next rendering.\n     */\n    markAsDirty() {\n        this._isDirty = true;\n    }\n    /**\n     * Enables a texture on the MultiRenderTarget for prepass\n     * @param types\n     */\n    _enableTextures(types) {\n        // For velocity : enable storage of previous matrices for instances\n        this._scene.needsPreviousWorldMatrices = false;\n        for (let i = 0; i < types.length; i++) {\n            const type = types[i];\n            if (this._textureIndices[type] === -1) {\n                this._textureIndices[type] = this._mrtLayout.length;\n                this._mrtLayout.push(type);\n                this._mrtFormats.push(PrePassRenderer._TextureFormats[type].format);\n                this._mrtNames.push(PrePassRenderer._TextureFormats[type].name);\n                this.mrtCount++;\n            }\n            if (type === 2) {\n                this._scene.needsPreviousWorldMatrices = true;\n            }\n        }\n    }\n    _update() {\n        this._disable();\n        let enablePrePass = false;\n        this._scene.imageProcessingConfiguration.applyByPostProcess = false;\n        if (this._scene._depthPeelingRenderer && this._scene.useOrderIndependentTransparency) {\n            this._scene._depthPeelingRenderer.setPrePassRenderer(this);\n            enablePrePass = true;\n        }\n        for (let i = 0; i < this._scene.materials.length; i++) {\n            if (this._scene.materials[i].setPrePassRenderer(this)) {\n                enablePrePass = true;\n            }\n        }\n        if (enablePrePass) {\n            this._setRenderTargetEnabled(this.defaultRT, true);\n        }\n        let postProcesses;\n        for (let i = 0; i < this.renderTargets.length; i++) {\n            if (this.renderTargets[i].renderTargetTexture) {\n                postProcesses = this._getPostProcessesSource(this.renderTargets[i]);\n            }\n            else {\n                const camera = this._scene.activeCamera;\n                if (!camera) {\n                    continue;\n                }\n                postProcesses = camera._postProcesses;\n            }\n            if (!postProcesses) {\n                continue;\n            }\n            postProcesses = postProcesses.filter((pp) => {\n                return pp != null;\n            });\n            if (postProcesses) {\n                for (let j = 0; j < postProcesses.length; j++) {\n                    if (postProcesses[j].setPrePassRenderer(this)) {\n                        this._setRenderTargetEnabled(this.renderTargets[i], true);\n                        enablePrePass = true;\n                    }\n                }\n                if (this._hasImageProcessing(postProcesses)) {\n                    this._scene.imageProcessingConfiguration.applyByPostProcess = true;\n                }\n            }\n        }\n        this._markAllMaterialsAsPrePassDirty();\n        this._isDirty = false;\n        if (enablePrePass) {\n            this._enable();\n        }\n    }\n    _markAllMaterialsAsPrePassDirty() {\n        const materials = this._scene.materials;\n        for (let i = 0; i < materials.length; i++) {\n            materials[i].markAsDirty(Material.PrePassDirtyFlag);\n        }\n    }\n    /**\n     * Disposes the prepass renderer.\n     */\n    dispose() {\n        for (let i = this.renderTargets.length - 1; i >= 0; i--) {\n            this.renderTargets[i].dispose();\n        }\n        for (let i = 0; i < this._effectConfigurations.length; i++) {\n            if (this._effectConfigurations[i].dispose) {\n                this._effectConfigurations[i].dispose();\n            }\n        }\n    }\n}\n/**\n * @internal\n */\nPrePassRenderer._SceneComponentInitialization = (_) => {\n    throw _WarnImport(\"PrePassRendererSceneComponent\");\n};\nPrePassRenderer._TextureFormats = [\n    {\n        type: 0,\n        format: 2,\n        name: \"prePass_Irradiance\",\n    },\n    {\n        type: 1,\n        format: 2,\n        name: \"prePass_Position\",\n    },\n    {\n        type: 2,\n        format: 0,\n        name: \"prePass_Velocity\",\n    },\n    {\n        type: 3,\n        format: 0,\n        name: \"prePass_Reflectivity\",\n    },\n    {\n        type: 4,\n        format: 2,\n        name: \"prePass_Color\",\n    },\n    {\n        type: 5,\n        format: 2,\n        name: \"prePass_Depth\",\n    },\n    {\n        type: 6,\n        format: 2,\n        name: \"prePass_Normal\",\n    },\n    {\n        type: 7,\n        format: 0,\n        name: \"prePass_Albedo\",\n    },\n];\n//# sourceMappingURL=prePassRenderer.js.map","import { Scene } from \"../scene.js\";\nimport { SceneComponentConstants } from \"../sceneComponent.js\";\nimport { PrePassRenderer } from \"./prePassRenderer.js\";\nimport { Logger } from \"../Misc/logger.js\";\nObject.defineProperty(Scene.prototype, \"prePassRenderer\", {\n    get: function () {\n        return this._prePassRenderer;\n    },\n    set: function (value) {\n        if (value && value.isSupported) {\n            this._prePassRenderer = value;\n        }\n    },\n    enumerable: true,\n    configurable: true,\n});\nScene.prototype.enablePrePassRenderer = function () {\n    if (this._prePassRenderer) {\n        return this._prePassRenderer;\n    }\n    this._prePassRenderer = new PrePassRenderer(this);\n    if (!this._prePassRenderer.isSupported) {\n        this._prePassRenderer = null;\n        Logger.Error(\"PrePassRenderer needs WebGL 2 support.\\n\" + \"Maybe you tried to use the following features that need the PrePassRenderer :\\n\" + \" + Subsurface Scattering\");\n    }\n    return this._prePassRenderer;\n};\nScene.prototype.disablePrePassRenderer = function () {\n    if (!this._prePassRenderer) {\n        return;\n    }\n    this._prePassRenderer.dispose();\n    this._prePassRenderer = null;\n};\n/**\n * Defines the Geometry Buffer scene component responsible to manage a G-Buffer useful\n * in several rendering techniques.\n */\nexport class PrePassRendererSceneComponent {\n    /**\n     * Creates a new instance of the component for the given scene\n     * @param scene Defines the scene to register the component in\n     */\n    constructor(scene) {\n        /**\n         * The component name helpful to identify the component in the list of scene components.\n         */\n        this.name = SceneComponentConstants.NAME_PREPASSRENDERER;\n        this.scene = scene;\n    }\n    /**\n     * Registers the component in a given scene\n     */\n    register() {\n        this.scene._beforeCameraDrawStage.registerStep(SceneComponentConstants.STEP_BEFORECAMERADRAW_PREPASS, this, this._beforeCameraDraw);\n        this.scene._afterCameraDrawStage.registerStep(SceneComponentConstants.STEP_AFTERCAMERADRAW_PREPASS, this, this._afterCameraDraw);\n        this.scene._beforeRenderTargetDrawStage.registerStep(SceneComponentConstants.STEP_BEFORERENDERTARGETDRAW_PREPASS, this, this._beforeRenderTargetDraw);\n        this.scene._afterRenderTargetDrawStage.registerStep(SceneComponentConstants.STEP_AFTERCAMERADRAW_PREPASS, this, this._afterRenderTargetDraw);\n        this.scene._beforeClearStage.registerStep(SceneComponentConstants.STEP_BEFORECLEAR_PREPASS, this, this._beforeClearStage);\n        this.scene._beforeRenderTargetClearStage.registerStep(SceneComponentConstants.STEP_BEFORERENDERTARGETCLEAR_PREPASS, this, this._beforeRenderTargetClearStage);\n        this.scene._beforeRenderingMeshStage.registerStep(SceneComponentConstants.STEP_BEFORERENDERINGMESH_PREPASS, this, this._beforeRenderingMeshStage);\n        this.scene._afterRenderingMeshStage.registerStep(SceneComponentConstants.STEP_AFTERRENDERINGMESH_PREPASS, this, this._afterRenderingMeshStage);\n    }\n    _beforeRenderTargetDraw(renderTarget, faceIndex, layer) {\n        if (this.scene.prePassRenderer && !renderTarget.noPrePassRenderer) {\n            this.scene.prePassRenderer._setRenderTarget(renderTarget._prePassRenderTarget);\n            this.scene.prePassRenderer._beforeDraw(undefined, faceIndex, layer);\n        }\n    }\n    _afterRenderTargetDraw(renderTarget, faceIndex, layer) {\n        if (this.scene.prePassRenderer && !renderTarget.noPrePassRenderer) {\n            this.scene.prePassRenderer._afterDraw(faceIndex, layer);\n        }\n    }\n    _beforeRenderTargetClearStage(renderTarget) {\n        if (this.scene.prePassRenderer && !renderTarget.noPrePassRenderer) {\n            if (!renderTarget._prePassRenderTarget) {\n                renderTarget._prePassRenderTarget = this.scene.prePassRenderer._createRenderTarget(renderTarget.name + \"_prePassRTT\", renderTarget);\n            }\n            this.scene.prePassRenderer._setRenderTarget(renderTarget._prePassRenderTarget);\n            this.scene.prePassRenderer._clear();\n        }\n    }\n    _beforeCameraDraw(camera) {\n        if (this.scene.prePassRenderer) {\n            this.scene.prePassRenderer._setRenderTarget(null);\n            this.scene.prePassRenderer._beforeDraw(camera);\n        }\n    }\n    _afterCameraDraw() {\n        if (this.scene.prePassRenderer) {\n            this.scene.prePassRenderer._afterDraw();\n        }\n    }\n    _beforeClearStage() {\n        if (this.scene.prePassRenderer) {\n            this.scene.prePassRenderer._setRenderTarget(null);\n            this.scene.prePassRenderer._clear();\n        }\n    }\n    _beforeRenderingMeshStage(mesh, subMesh, batch, effect) {\n        if (!effect) {\n            return;\n        }\n        // Render to MRT\n        const scene = mesh.getScene();\n        if (scene.prePassRenderer) {\n            scene.prePassRenderer.bindAttachmentsForEffect(effect, subMesh);\n        }\n    }\n    _afterRenderingMeshStage(mesh) {\n        const scene = mesh.getScene();\n        if (scene.prePassRenderer) {\n            scene.prePassRenderer.restoreAttachments();\n        }\n    }\n    /**\n     * Rebuilds the elements related to this component in case of\n     * context lost for instance.\n     */\n    rebuild() {\n        // Release textures first\n        this.scene.disablePrePassRenderer();\n        // Re-enable\n        this.scene.enablePrePassRenderer();\n    }\n    /**\n     * Disposes the component and the associated resources\n     */\n    dispose() {\n        this.scene.disablePrePassRenderer();\n    }\n}\nPrePassRenderer._SceneComponentInitialization = (scene) => {\n    // Register the G Buffer component to the scene.\n    let component = scene._getComponent(SceneComponentConstants.NAME_PREPASSRENDERER);\n    if (!component) {\n        component = new PrePassRendererSceneComponent(scene);\n        scene._addComponent(component);\n    }\n};\n//# sourceMappingURL=prePassRendererSceneComponent.js.map","import { Logger } from \"../Misc/logger.js\";\nimport { Color3 } from \"../Maths/math.color.js\";\nimport { SubSurfaceScatteringPostProcess } from \"../PostProcesses/subSurfaceScatteringPostProcess.js\";\nimport { SceneComponentConstants } from \"../sceneComponent.js\";\nimport { _WarnImport } from \"../Misc/devTools.js\";\n\n/**\n * Contains all parameters needed for the prepass to perform\n * screen space subsurface scattering\n */\nexport class SubSurfaceConfiguration {\n    /**\n     * Diffusion profile color for subsurface scattering\n     */\n    get ssDiffusionS() {\n        return this._ssDiffusionS;\n    }\n    /**\n     * Diffusion profile max color channel value for subsurface scattering\n     */\n    get ssDiffusionD() {\n        return this._ssDiffusionD;\n    }\n    /**\n     * Diffusion profile filter radius for subsurface scattering\n     */\n    get ssFilterRadii() {\n        return this._ssFilterRadii;\n    }\n    /**\n     * Builds a subsurface configuration object\n     * @param scene The scene\n     */\n    constructor(scene) {\n        this._ssDiffusionS = [];\n        this._ssFilterRadii = [];\n        this._ssDiffusionD = [];\n        /**\n         * Is subsurface enabled\n         */\n        this.enabled = false;\n        /**\n         * Does the output of this prepass need to go through imageprocessing\n         */\n        this.needsImageProcessing = true;\n        /**\n         * Name of the configuration\n         */\n        this.name = SceneComponentConstants.NAME_SUBSURFACE;\n        /**\n         * Diffusion profile colors for subsurface scattering\n         * You can add one diffusion color using `addDiffusionProfile` on `scene.prePassRenderer`\n         * See ...\n         * Note that you can only store up to 5 of them\n         */\n        this.ssDiffusionProfileColors = [];\n        /**\n         * Defines the ratio real world => scene units.\n         * Used for subsurface scattering\n         */\n        this.metersPerUnit = 1;\n        /**\n         * Textures that should be present in the MRT for this effect to work\n         */\n        this.texturesRequired = [\n            5,\n            7,\n            4,\n            0,\n        ];\n        // Adding default diffusion profile\n        this.addDiffusionProfile(new Color3(1, 1, 1));\n        this._scene = scene;\n        SubSurfaceConfiguration._SceneComponentInitialization(this._scene);\n    }\n    /**\n     * Adds a new diffusion profile.\n     * Useful for more realistic subsurface scattering on diverse materials.\n     * @param color The color of the diffusion profile. Should be the average color of the material.\n     * @returns The index of the diffusion profile for the material subsurface configuration\n     */\n    addDiffusionProfile(color) {\n        if (this.ssDiffusionD.length >= 5) {\n            // We only suppport 5 diffusion profiles\n            Logger.Error(\"You already reached the maximum number of diffusion profiles.\");\n            return 0; // default profile\n        }\n        // Do not add doubles\n        for (let i = 0; i < this._ssDiffusionS.length / 3; i++) {\n            if (this._ssDiffusionS[i * 3] === color.r && this._ssDiffusionS[i * 3 + 1] === color.g && this._ssDiffusionS[i * 3 + 2] === color.b) {\n                return i;\n            }\n        }\n        this._ssDiffusionS.push(color.r, color.b, color.g);\n        this._ssDiffusionD.push(Math.max(Math.max(color.r, color.b), color.g));\n        this._ssFilterRadii.push(this.getDiffusionProfileParameters(color));\n        this.ssDiffusionProfileColors.push(color);\n        return this._ssDiffusionD.length - 1;\n    }\n    /**\n     * Creates the sss post process\n     * @returns The created post process\n     */\n    createPostProcess() {\n        this.postProcess = new SubSurfaceScatteringPostProcess(\"subSurfaceScattering\", this._scene, 1, null, undefined, this._scene.getEngine());\n        this.postProcess.autoClear = false;\n        return this.postProcess;\n    }\n    /**\n     * Deletes all diffusion profiles.\n     * Note that in order to render subsurface scattering, you should have at least 1 diffusion profile.\n     */\n    clearAllDiffusionProfiles() {\n        this._ssDiffusionD = [];\n        this._ssDiffusionS = [];\n        this._ssFilterRadii = [];\n        this.ssDiffusionProfileColors = [];\n    }\n    /**\n     * Disposes this object\n     */\n    dispose() {\n        this.clearAllDiffusionProfiles();\n        if (this.postProcess) {\n            this.postProcess.dispose();\n        }\n    }\n    /**\n     * @internal\n     * https://zero-radiance.github.io/post/sampling-diffusion/\n     *\n     * Importance sample the normalized diffuse reflectance profile for the computed value of 's'.\n     * ------------------------------------------------------------------------------------\n     * R[r, phi, s]   = s * (Exp[-r * s] + Exp[-r * s / 3]) / (8 * Pi * r)\n     * PDF[r, phi, s] = r * R[r, phi, s]\n     * CDF[r, s]      = 1 - 1/4 * Exp[-r * s] - 3/4 * Exp[-r * s / 3]\n     * ------------------------------------------------------------------------------------\n     * We importance sample the color channel with the widest scattering distance.\n     */\n    getDiffusionProfileParameters(color) {\n        const cdf = 0.997;\n        const maxScatteringDistance = Math.max(color.r, color.g, color.b);\n        return this._sampleBurleyDiffusionProfile(cdf, maxScatteringDistance);\n    }\n    /**\n     * Performs sampling of a Normalized Burley diffusion profile in polar coordinates.\n     * 'u' is the random number (the value of the CDF): [0, 1).\n     * rcp(s) = 1 / ShapeParam = ScatteringDistance.\n     * Returns the sampled radial distance, s.t. (u = 0 -> r = 0) and (u = 1 -> r = Inf).\n     * @param u\n     * @param rcpS\n     */\n    _sampleBurleyDiffusionProfile(u, rcpS) {\n        u = 1 - u; // Convert CDF to CCDF\n        const g = 1 + 4 * u * (2 * u + Math.sqrt(1 + 4 * u * u));\n        const n = Math.pow(g, -1.0 / 3.0); // g^(-1/3)\n        const p = g * n * n; // g^(+1/3)\n        const c = 1 + p + n; // 1 + g^(+1/3) + g^(-1/3)\n        const x = 3 * Math.log(c / (4 * u));\n        return x * rcpS;\n    }\n}\n/**\n * @internal\n */\nSubSurfaceConfiguration._SceneComponentInitialization = (_) => {\n    throw _WarnImport(\"SubSurfaceSceneComponent\");\n};\n//# sourceMappingURL=subSurfaceConfiguration.js.map","import { Scene } from \"../scene.js\";\nimport { SceneComponentConstants } from \"../sceneComponent.js\";\nimport { SubSurfaceConfiguration } from \"./subSurfaceConfiguration.js\";\nimport { AbstractScene } from \"../abstractScene.js\";\nimport { Color3 } from \"../Maths/math.color.js\";\n// Adds the parser to the scene parsers.\nAbstractScene.AddParser(SceneComponentConstants.NAME_SUBSURFACE, (parsedData, scene) => {\n    // Diffusion profiles\n    if (parsedData.ssDiffusionProfileColors !== undefined && parsedData.ssDiffusionProfileColors !== null) {\n        scene.enableSubSurfaceForPrePass();\n        if (scene.subSurfaceConfiguration) {\n            for (let index = 0, cache = parsedData.ssDiffusionProfileColors.length; index < cache; index++) {\n                const color = parsedData.ssDiffusionProfileColors[index];\n                scene.subSurfaceConfiguration.addDiffusionProfile(new Color3(color.r, color.g, color.b));\n            }\n        }\n    }\n});\nObject.defineProperty(Scene.prototype, \"subSurfaceConfiguration\", {\n    get: function () {\n        return this._subSurfaceConfiguration;\n    },\n    set: function (value) {\n        if (value) {\n            if (this.enablePrePassRenderer()) {\n                this._subSurfaceConfiguration = value;\n            }\n        }\n    },\n    enumerable: true,\n    configurable: true,\n});\nScene.prototype.enableSubSurfaceForPrePass = function () {\n    if (this._subSurfaceConfiguration) {\n        return this._subSurfaceConfiguration;\n    }\n    const prePassRenderer = this.enablePrePassRenderer();\n    if (prePassRenderer) {\n        this._subSurfaceConfiguration = new SubSurfaceConfiguration(this);\n        prePassRenderer.addEffectConfiguration(this._subSurfaceConfiguration);\n        return this._subSurfaceConfiguration;\n    }\n    return null;\n};\nScene.prototype.disableSubSurfaceForPrePass = function () {\n    if (!this._subSurfaceConfiguration) {\n        return;\n    }\n    this._subSurfaceConfiguration.dispose();\n    this._subSurfaceConfiguration = null;\n};\n/**\n * Defines the Geometry Buffer scene component responsible to manage a G-Buffer useful\n * in several rendering techniques.\n */\nexport class SubSurfaceSceneComponent {\n    /**\n     * Creates a new instance of the component for the given scene\n     * @param scene Defines the scene to register the component in\n     */\n    constructor(scene) {\n        /**\n         * The component name helpful to identify the component in the list of scene components.\n         */\n        this.name = SceneComponentConstants.NAME_PREPASSRENDERER;\n        this.scene = scene;\n    }\n    /**\n     * Registers the component in a given scene\n     */\n    register() { }\n    /**\n     * Serializes the component data to the specified json object\n     * @param serializationObject The object to serialize to\n     */\n    serialize(serializationObject) {\n        if (!this.scene.subSurfaceConfiguration) {\n            return;\n        }\n        const ssDiffusionProfileColors = this.scene.subSurfaceConfiguration.ssDiffusionProfileColors;\n        serializationObject.ssDiffusionProfileColors = [];\n        for (let i = 0; i < ssDiffusionProfileColors.length; i++) {\n            serializationObject.ssDiffusionProfileColors.push({\n                r: ssDiffusionProfileColors[i].r,\n                g: ssDiffusionProfileColors[i].g,\n                b: ssDiffusionProfileColors[i].b,\n            });\n        }\n    }\n    /**\n     * Adds all the elements from the container to the scene\n     */\n    addFromContainer() {\n        // Nothing to do\n    }\n    /**\n     * Removes all the elements in the container from the scene\n     */\n    removeFromContainer() {\n        // Make sure nothing will be serialized\n        if (!this.scene.prePassRenderer) {\n            return;\n        }\n        if (this.scene.subSurfaceConfiguration) {\n            this.scene.subSurfaceConfiguration.clearAllDiffusionProfiles();\n        }\n    }\n    /**\n     * Rebuilds the elements related to this component in case of\n     * context lost for instance.\n     */\n    rebuild() {\n        // Nothing to do for this component\n    }\n    /**\n     * Disposes the component and the associated resources\n     */\n    dispose() {\n        // Nothing to do for this component\n    }\n}\nSubSurfaceConfiguration._SceneComponentInitialization = (scene) => {\n    // Register the G Buffer component to the scene.\n    let component = scene._getComponent(SceneComponentConstants.NAME_SUBSURFACE);\n    if (!component) {\n        component = new SubSurfaceSceneComponent(scene);\n        scene._addComponent(component);\n    }\n};\n//# sourceMappingURL=subSurfaceSceneComponent.js.map","import { VertexBuffer } from \"../Buffers/buffer.js\";\nimport { Mesh } from \"../Meshes/mesh.js\";\nimport { Scene } from \"../scene.js\";\n\nimport { SceneComponentConstants } from \"../sceneComponent.js\";\nimport { DrawWrapper } from \"../Materials/drawWrapper.js\";\nimport { MaterialHelper } from \"../Materials/materialHelper.js\";\nimport \"../Shaders/outline.fragment.js\";\nimport \"../Shaders/outline.vertex.js\";\nimport { addClipPlaneUniforms, bindClipPlane, prepareDefinesForClipPlanes } from \"../Materials/clipPlaneMaterialHelper.js\";\n/**\n * Gets the outline renderer associated with the scene\n * @returns a OutlineRenderer\n */\nScene.prototype.getOutlineRenderer = function () {\n    if (!this._outlineRenderer) {\n        this._outlineRenderer = new OutlineRenderer(this);\n    }\n    return this._outlineRenderer;\n};\nObject.defineProperty(Mesh.prototype, \"renderOutline\", {\n    get: function () {\n        return this._renderOutline;\n    },\n    set: function (value) {\n        if (value) {\n            // Lazy Load the component.\n            this.getScene().getOutlineRenderer();\n        }\n        this._renderOutline = value;\n    },\n    enumerable: true,\n    configurable: true,\n});\nObject.defineProperty(Mesh.prototype, \"renderOverlay\", {\n    get: function () {\n        return this._renderOverlay;\n    },\n    set: function (value) {\n        if (value) {\n            // Lazy Load the component.\n            this.getScene().getOutlineRenderer();\n        }\n        this._renderOverlay = value;\n    },\n    enumerable: true,\n    configurable: true,\n});\n/**\n * This class is responsible to draw the outline/overlay of meshes.\n * It should not be used directly but through the available method on mesh.\n */\nexport class OutlineRenderer {\n    /**\n     * Instantiates a new outline renderer. (There could be only one per scene).\n     * @param scene Defines the scene it belongs to\n     */\n    constructor(scene) {\n        /**\n         * The name of the component. Each component must have a unique name.\n         */\n        this.name = SceneComponentConstants.NAME_OUTLINERENDERER;\n        /**\n         * Defines a zOffset default Factor to prevent zFighting between the overlay and the mesh.\n         */\n        this.zOffset = 1;\n        /**\n         * Defines a zOffset default Unit to prevent zFighting between the overlay and the mesh.\n         */\n        this.zOffsetUnits = 4; // 4 to account for projection a bit by default\n        this.scene = scene;\n        this._engine = scene.getEngine();\n        this.scene._addComponent(this);\n        this._passIdForDrawWrapper = [];\n        for (let i = 0; i < 4; ++i) {\n            this._passIdForDrawWrapper[i] = this._engine.createRenderPassId(`Outline Renderer (${i})`);\n        }\n    }\n    /**\n     * Register the component to one instance of a scene.\n     */\n    register() {\n        this.scene._beforeRenderingMeshStage.registerStep(SceneComponentConstants.STEP_BEFORERENDERINGMESH_OUTLINE, this, this._beforeRenderingMesh);\n        this.scene._afterRenderingMeshStage.registerStep(SceneComponentConstants.STEP_AFTERRENDERINGMESH_OUTLINE, this, this._afterRenderingMesh);\n    }\n    /**\n     * Rebuilds the elements related to this component in case of\n     * context lost for instance.\n     */\n    rebuild() {\n        // Nothing to do here.\n    }\n    /**\n     * Disposes the component and the associated resources.\n     */\n    dispose() {\n        for (let i = 0; i < this._passIdForDrawWrapper.length; ++i) {\n            this._engine.releaseRenderPassId(this._passIdForDrawWrapper[i]);\n        }\n    }\n    /**\n     * Renders the outline in the canvas.\n     * @param subMesh Defines the sumesh to render\n     * @param batch Defines the batch of meshes in case of instances\n     * @param useOverlay Defines if the rendering is for the overlay or the outline\n     * @param renderPassId Render pass id to use to render the mesh\n     */\n    render(subMesh, batch, useOverlay = false, renderPassId) {\n        renderPassId = renderPassId !== null && renderPassId !== void 0 ? renderPassId : this._passIdForDrawWrapper[0];\n        const scene = this.scene;\n        const engine = scene.getEngine();\n        const hardwareInstancedRendering = engine.getCaps().instancedArrays &&\n            ((batch.visibleInstances[subMesh._id] !== null && batch.visibleInstances[subMesh._id] !== undefined) || subMesh.getRenderingMesh().hasThinInstances);\n        if (!this.isReady(subMesh, hardwareInstancedRendering, renderPassId)) {\n            return;\n        }\n        const ownerMesh = subMesh.getMesh();\n        const replacementMesh = ownerMesh._internalAbstractMeshDataInfo._actAsRegularMesh ? ownerMesh : null;\n        const renderingMesh = subMesh.getRenderingMesh();\n        const effectiveMesh = replacementMesh ? replacementMesh : renderingMesh;\n        const material = subMesh.getMaterial();\n        if (!material || !scene.activeCamera) {\n            return;\n        }\n        const drawWrapper = subMesh._getDrawWrapper(renderPassId);\n        const effect = DrawWrapper.GetEffect(drawWrapper);\n        engine.enableEffect(drawWrapper);\n        // Logarithmic depth\n        if (material.useLogarithmicDepth) {\n            effect.setFloat(\"logarithmicDepthConstant\", 2.0 / (Math.log(scene.activeCamera.maxZ + 1.0) / Math.LN2));\n        }\n        effect.setFloat(\"offset\", useOverlay ? 0 : renderingMesh.outlineWidth);\n        effect.setColor4(\"color\", useOverlay ? renderingMesh.overlayColor : renderingMesh.outlineColor, useOverlay ? renderingMesh.overlayAlpha : material.alpha);\n        effect.setMatrix(\"viewProjection\", scene.getTransformMatrix());\n        effect.setMatrix(\"world\", effectiveMesh.getWorldMatrix());\n        // Bones\n        if (renderingMesh.useBones && renderingMesh.computeBonesUsingShaders && renderingMesh.skeleton) {\n            effect.setMatrices(\"mBones\", renderingMesh.skeleton.getTransformMatrices(renderingMesh));\n        }\n        if (renderingMesh.morphTargetManager && renderingMesh.morphTargetManager.isUsingTextureForTargets) {\n            renderingMesh.morphTargetManager._bind(effect);\n        }\n        // Morph targets\n        MaterialHelper.BindMorphTargetParameters(renderingMesh, effect);\n        if (!hardwareInstancedRendering) {\n            renderingMesh._bind(subMesh, effect, material.fillMode);\n        }\n        // Alpha test\n        if (material && material.needAlphaTesting()) {\n            const alphaTexture = material.getAlphaTestTexture();\n            if (alphaTexture) {\n                effect.setTexture(\"diffuseSampler\", alphaTexture);\n                effect.setMatrix(\"diffuseMatrix\", alphaTexture.getTextureMatrix());\n            }\n        }\n        // Clip plane\n        bindClipPlane(effect, material, scene);\n        engine.setZOffset(-this.zOffset);\n        engine.setZOffsetUnits(-this.zOffsetUnits);\n        renderingMesh._processRendering(effectiveMesh, subMesh, effect, material.fillMode, batch, hardwareInstancedRendering, (isInstance, world) => {\n            effect.setMatrix(\"world\", world);\n        });\n        engine.setZOffset(0);\n        engine.setZOffsetUnits(0);\n    }\n    /**\n     * Returns whether or not the outline renderer is ready for a given submesh.\n     * All the dependencies e.g. submeshes, texture, effect... mus be ready\n     * @param subMesh Defines the submesh to check readiness for\n     * @param useInstances Defines whether wee are trying to render instances or not\n     * @param renderPassId Render pass id to use to render the mesh\n     * @returns true if ready otherwise false\n     */\n    isReady(subMesh, useInstances, renderPassId) {\n        renderPassId = renderPassId !== null && renderPassId !== void 0 ? renderPassId : this._passIdForDrawWrapper[0];\n        const defines = [];\n        const attribs = [VertexBuffer.PositionKind, VertexBuffer.NormalKind];\n        const mesh = subMesh.getMesh();\n        const material = subMesh.getMaterial();\n        if (!material) {\n            return false;\n        }\n        const scene = mesh.getScene();\n        // Alpha test\n        if (material.needAlphaTesting()) {\n            defines.push(\"#define ALPHATEST\");\n            if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {\n                attribs.push(VertexBuffer.UVKind);\n                defines.push(\"#define UV1\");\n            }\n            if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind)) {\n                attribs.push(VertexBuffer.UV2Kind);\n                defines.push(\"#define UV2\");\n            }\n        }\n        //Logarithmic depth\n        if (material.useLogarithmicDepth) {\n            defines.push(\"#define LOGARITHMICDEPTH\");\n        }\n        // Clip planes\n        prepareDefinesForClipPlanes(material, scene, defines);\n        // Bones\n        if (mesh.useBones && mesh.computeBonesUsingShaders) {\n            attribs.push(VertexBuffer.MatricesIndicesKind);\n            attribs.push(VertexBuffer.MatricesWeightsKind);\n            if (mesh.numBoneInfluencers > 4) {\n                attribs.push(VertexBuffer.MatricesIndicesExtraKind);\n                attribs.push(VertexBuffer.MatricesWeightsExtraKind);\n            }\n            defines.push(\"#define NUM_BONE_INFLUENCERS \" + mesh.numBoneInfluencers);\n            defines.push(\"#define BonesPerMesh \" + (mesh.skeleton ? mesh.skeleton.bones.length + 1 : 0));\n        }\n        else {\n            defines.push(\"#define NUM_BONE_INFLUENCERS 0\");\n        }\n        // Morph targets\n        const morphTargetManager = mesh.morphTargetManager;\n        let numMorphInfluencers = 0;\n        if (morphTargetManager) {\n            if (morphTargetManager.numInfluencers > 0) {\n                numMorphInfluencers = morphTargetManager.numInfluencers;\n                defines.push(\"#define MORPHTARGETS\");\n                defines.push(\"#define NUM_MORPH_INFLUENCERS \" + numMorphInfluencers);\n                if (morphTargetManager.isUsingTextureForTargets) {\n                    defines.push(\"#define MORPHTARGETS_TEXTURE\");\n                }\n                MaterialHelper.PrepareAttributesForMorphTargetsInfluencers(attribs, mesh, numMorphInfluencers);\n            }\n        }\n        // Instances\n        if (useInstances) {\n            defines.push(\"#define INSTANCES\");\n            MaterialHelper.PushAttributesForInstances(attribs);\n            if (subMesh.getRenderingMesh().hasThinInstances) {\n                defines.push(\"#define THIN_INSTANCES\");\n            }\n        }\n        // Get correct effect\n        const drawWrapper = subMesh._getDrawWrapper(renderPassId, true);\n        const cachedDefines = drawWrapper.defines;\n        const join = defines.join(\"\\n\");\n        if (cachedDefines !== join) {\n            const uniforms = [\n                \"world\",\n                \"mBones\",\n                \"viewProjection\",\n                \"diffuseMatrix\",\n                \"offset\",\n                \"color\",\n                \"logarithmicDepthConstant\",\n                \"morphTargetInfluences\",\n                \"morphTargetTextureInfo\",\n                \"morphTargetTextureIndices\",\n            ];\n            addClipPlaneUniforms(uniforms);\n            drawWrapper.setEffect(this.scene.getEngine().createEffect(\"outline\", attribs, uniforms, [\"diffuseSampler\", \"morphTargets\"], join, undefined, undefined, undefined, {\n                maxSimultaneousMorphTargets: numMorphInfluencers,\n            }), join);\n        }\n        return drawWrapper.effect.isReady();\n    }\n    _beforeRenderingMesh(mesh, subMesh, batch) {\n        // Outline - step 1\n        this._savedDepthWrite = this._engine.getDepthWrite();\n        if (mesh.renderOutline) {\n            const material = subMesh.getMaterial();\n            if (material && material.needAlphaBlendingForMesh(mesh)) {\n                this._engine.cacheStencilState();\n                // Draw only to stencil buffer for the original mesh\n                // The resulting stencil buffer will be used so the outline is not visible inside the mesh when the mesh is transparent\n                this._engine.setDepthWrite(false);\n                this._engine.setColorWrite(false);\n                this._engine.setStencilBuffer(true);\n                this._engine.setStencilOperationPass(7681);\n                this._engine.setStencilFunction(519);\n                this._engine.setStencilMask(OutlineRenderer._StencilReference);\n                this._engine.setStencilFunctionReference(OutlineRenderer._StencilReference);\n                this._engine.stencilStateComposer.useStencilGlobalOnly = true;\n                this.render(subMesh, batch, /* This sets offset to 0 */ true, this._passIdForDrawWrapper[1]);\n                this._engine.setColorWrite(true);\n                this._engine.setStencilFunction(517);\n            }\n            // Draw the outline using the above stencil if needed to avoid drawing within the mesh\n            this._engine.setDepthWrite(false);\n            this.render(subMesh, batch, false, this._passIdForDrawWrapper[0]);\n            this._engine.setDepthWrite(this._savedDepthWrite);\n            if (material && material.needAlphaBlendingForMesh(mesh)) {\n                this._engine.stencilStateComposer.useStencilGlobalOnly = false;\n                this._engine.restoreStencilState();\n            }\n        }\n    }\n    _afterRenderingMesh(mesh, subMesh, batch) {\n        // Overlay\n        if (mesh.renderOverlay) {\n            const currentMode = this._engine.getAlphaMode();\n            const alphaBlendState = this._engine.alphaState.alphaBlend;\n            this._engine.setAlphaMode(2);\n            this.render(subMesh, batch, true, this._passIdForDrawWrapper[3]);\n            this._engine.setAlphaMode(currentMode);\n            this._engine.setDepthWrite(this._savedDepthWrite);\n            this._engine.alphaState.alphaBlend = alphaBlendState;\n        }\n        // Outline - step 2\n        if (mesh.renderOutline && this._savedDepthWrite) {\n            this._engine.setDepthWrite(true);\n            this._engine.setColorWrite(false);\n            this.render(subMesh, batch, false, this._passIdForDrawWrapper[2]);\n            this._engine.setColorWrite(true);\n        }\n    }\n}\n/**\n * Stencil value used to avoid outline being seen within the mesh when the mesh is transparent\n */\nOutlineRenderer._StencilReference = 0x04;\n//# sourceMappingURL=outlineRenderer.js.map","\nimport { EffectWrapper } from \"../../Materials/effectRenderer.js\";\nimport { Observable } from \"../../Misc/observable.js\";\n/**\n * Defines the base object used for fluid rendering.\n * It is based on a list of vertices (particles)\n */\nexport class FluidRenderingObject {\n    /** Gets or sets the size of the particle */\n    get particleSize() {\n        return this._particleSize;\n    }\n    set particleSize(size) {\n        if (size === this._particleSize) {\n            return;\n        }\n        this._particleSize = size;\n        this.onParticleSizeChanged.notifyObservers(this);\n    }\n    /** Indicates if the object uses instancing or not */\n    get useInstancing() {\n        return !this.indexBuffer;\n    }\n    /** Indicates if velocity of particles should be used when rendering the object. The vertex buffer set must contain a \"velocity\" buffer for this to work! */\n    get useVelocity() {\n        return this._useVelocity;\n    }\n    set useVelocity(use) {\n        if (this._useVelocity === use || !this._hasVelocity()) {\n            return;\n        }\n        this._useVelocity = use;\n        this._effectsAreDirty = true;\n    }\n    _hasVelocity() {\n        var _a;\n        return !!((_a = this.vertexBuffers) === null || _a === void 0 ? void 0 : _a.velocity);\n    }\n    /**\n     * Gets the index buffer (or null if the object is using instancing)\n     */\n    get indexBuffer() {\n        return null;\n    }\n    /**\n     * Gets the name of the class\n     */\n    getClassName() {\n        return \"FluidRenderingObject\";\n    }\n    /**\n     * Instantiates a fluid rendering object\n     * @param scene The scene the object is part of\n     */\n    constructor(scene) {\n        /** Defines the priority of the object. Objects will be rendered in ascending order of priority */\n        this.priority = 0;\n        this._particleSize = 0.1;\n        /** Observable triggered when the size of the particle is changed */\n        this.onParticleSizeChanged = new Observable();\n        /** Defines the alpha value of a particle */\n        this.particleThicknessAlpha = 0.05;\n        this._useVelocity = false;\n        this._scene = scene;\n        this._engine = scene.getEngine();\n        this._effectsAreDirty = true;\n        this._depthEffectWrapper = null;\n        this._thicknessEffectWrapper = null;\n    }\n    _createEffects() {\n        const uniformNames = [\"view\", \"projection\", \"particleRadius\", \"size\"];\n        const attributeNames = [\"position\", \"offset\"];\n        const defines = [];\n        this._effectsAreDirty = false;\n        if (this.useVelocity) {\n            attributeNames.push(\"velocity\");\n            defines.push(\"#define FLUIDRENDERING_VELOCITY\");\n        }\n        if (this._scene.useRightHandedSystem) {\n            defines.push(\"#define FLUIDRENDERING_RHS\");\n        }\n        this._depthEffectWrapper = new EffectWrapper({\n            engine: this._engine,\n            useShaderStore: true,\n            vertexShader: \"fluidRenderingParticleDepth\",\n            fragmentShader: \"fluidRenderingParticleDepth\",\n            attributeNames,\n            uniformNames,\n            samplerNames: [],\n            defines,\n        });\n        uniformNames.push(\"particleAlpha\");\n        this._thicknessEffectWrapper = new EffectWrapper({\n            engine: this._engine,\n            useShaderStore: true,\n            vertexShader: \"fluidRenderingParticleThickness\",\n            fragmentShader: \"fluidRenderingParticleThickness\",\n            attributeNames: [\"position\", \"offset\"],\n            uniformNames,\n            samplerNames: [],\n        });\n    }\n    /**\n     * Indicates if the object is ready to be rendered\n     * @returns True if everything is ready for the object to be rendered, otherwise false\n     */\n    isReady() {\n        if (this._effectsAreDirty) {\n            this._createEffects();\n        }\n        if (!this._depthEffectWrapper || !this._thicknessEffectWrapper) {\n            return false;\n        }\n        const depthEffect = this._depthEffectWrapper._drawWrapper.effect;\n        const thicknessEffect = this._thicknessEffectWrapper._drawWrapper.effect;\n        return depthEffect.isReady() && thicknessEffect.isReady();\n    }\n    /**\n     * Render the depth texture for this object\n     */\n    renderDepthTexture() {\n        const numParticles = this.numParticles;\n        if (!this._depthEffectWrapper || numParticles === 0) {\n            return;\n        }\n        const depthDrawWrapper = this._depthEffectWrapper._drawWrapper;\n        const depthEffect = depthDrawWrapper.effect;\n        this._engine.enableEffect(depthDrawWrapper);\n        this._engine.bindBuffers(this.vertexBuffers, this.indexBuffer, depthEffect);\n        depthEffect.setMatrix(\"view\", this._scene.getViewMatrix());\n        depthEffect.setMatrix(\"projection\", this._scene.getProjectionMatrix());\n        depthEffect.setFloat2(\"size\", this._particleSize, this._particleSize);\n        depthEffect.setFloat(\"particleRadius\", this._particleSize / 2);\n        if (this.useInstancing) {\n            this._engine.drawArraysType(7, 0, 4, numParticles);\n        }\n        else {\n            this._engine.drawElementsType(0, 0, numParticles);\n        }\n    }\n    /**\n     * Render the thickness texture for this object\n     */\n    renderThicknessTexture() {\n        const numParticles = this.numParticles;\n        if (!this._thicknessEffectWrapper || numParticles === 0) {\n            return;\n        }\n        const thicknessDrawWrapper = this._thicknessEffectWrapper._drawWrapper;\n        const thicknessEffect = thicknessDrawWrapper.effect;\n        this._engine.setAlphaMode(6);\n        this._engine.setDepthWrite(false);\n        this._engine.enableEffect(thicknessDrawWrapper);\n        this._engine.bindBuffers(this.vertexBuffers, this.indexBuffer, thicknessEffect);\n        thicknessEffect.setMatrix(\"view\", this._scene.getViewMatrix());\n        thicknessEffect.setMatrix(\"projection\", this._scene.getProjectionMatrix());\n        thicknessEffect.setFloat(\"particleAlpha\", this.particleThicknessAlpha);\n        thicknessEffect.setFloat2(\"size\", this._particleSize, this._particleSize);\n        if (this.useInstancing) {\n            this._engine.drawArraysType(7, 0, 4, numParticles);\n        }\n        else {\n            this._engine.drawElementsType(0, 0, numParticles);\n        }\n        this._engine.setDepthWrite(true);\n        this._engine.setAlphaMode(0);\n    }\n    /**\n     * Render the diffuse texture for this object\n     */\n    renderDiffuseTexture() {\n        // do nothing by default\n    }\n    /**\n     * Releases the ressources used by the class\n     */\n    dispose() {\n        var _a, _b;\n        (_a = this._depthEffectWrapper) === null || _a === void 0 ? void 0 : _a.dispose();\n        (_b = this._thicknessEffectWrapper) === null || _b === void 0 ? void 0 : _b.dispose();\n    }\n}\n//# sourceMappingURL=fluidRenderingObject.js.map","\nimport { FluidRenderingObject } from \"./fluidRenderingObject.js\";\n/**\n * Defines a rendering object based on a particle system\n */\nexport class FluidRenderingObjectParticleSystem extends FluidRenderingObject {\n    /** Gets the particle system */\n    get particleSystem() {\n        return this._particleSystem;\n    }\n    /**\n     * Gets the name of the class\n     */\n    getClassName() {\n        return \"FluidRenderingObjectParticleSystem\";\n    }\n    /**\n     * Gets or sets a boolean indicating that the diffuse texture should be generated based on the regular rendering of the particle system (default: true).\n     * Sometimes, generating the diffuse texture this way may be sub-optimal. In that case, you can disable this property, in which case the particle system will be\n     * rendered using a ALPHA_COMBINE mode instead of the one used by the particle system.\n     */\n    get useTrueRenderingForDiffuseTexture() {\n        return this._useTrueRenderingForDiffuseTexture;\n    }\n    set useTrueRenderingForDiffuseTexture(use) {\n        if (this._useTrueRenderingForDiffuseTexture === use) {\n            return;\n        }\n        this._useTrueRenderingForDiffuseTexture = use;\n        if (use) {\n            this._particleSystem.blendMode = this._blendMode;\n            this._particleSystem.onBeforeDrawParticlesObservable.remove(this._onBeforeDrawParticleObserver);\n            this._onBeforeDrawParticleObserver = null;\n        }\n        else {\n            this._particleSystem.blendMode = -1;\n            this._onBeforeDrawParticleObserver = this._particleSystem.onBeforeDrawParticlesObservable.add(() => {\n                this._engine.setAlphaMode(2);\n            });\n        }\n    }\n    /**\n     * Gets the vertex buffers\n     */\n    get vertexBuffers() {\n        return this._particleSystem.vertexBuffers;\n    }\n    /**\n     * Gets the index buffer (or null if the object is using instancing)\n     */\n    get indexBuffer() {\n        return this._particleSystem.indexBuffer;\n    }\n    /**\n     * Creates a new instance of the class\n     * @param scene The scene the particle system is part of\n     * @param ps The particle system\n     */\n    constructor(scene, ps) {\n        super(scene);\n        this._useTrueRenderingForDiffuseTexture = true;\n        this._particleSystem = ps;\n        this._originalRender = ps.render.bind(ps);\n        this._blendMode = ps.blendMode;\n        this._onBeforeDrawParticleObserver = null;\n        this._updateInAnimate = this._particleSystem.updateInAnimate;\n        this._particleSystem.updateInAnimate = true;\n        this._particleSystem.render = () => 0;\n        this.particleSize = (ps.minSize + ps.maxSize) / 2;\n        this.useTrueRenderingForDiffuseTexture = false;\n    }\n    /**\n     * Indicates if the object is ready to be rendered\n     * @returns True if everything is ready for the object to be rendered, otherwise false\n     */\n    isReady() {\n        return super.isReady() && this._particleSystem.isReady();\n    }\n    /**\n     * Gets the number of particles in this particle system\n     * @returns The number of particles\n     */\n    get numParticles() {\n        return this._particleSystem.getActiveCount();\n    }\n    /**\n     * Render the diffuse texture for this object\n     */\n    renderDiffuseTexture() {\n        this._originalRender();\n    }\n    /**\n     * Releases the ressources used by the class\n     */\n    dispose() {\n        super.dispose();\n        this._particleSystem.onBeforeDrawParticlesObservable.remove(this._onBeforeDrawParticleObserver);\n        this._onBeforeDrawParticleObserver = null;\n        this._particleSystem.render = this._originalRender;\n        this._particleSystem.blendMode = this._blendMode;\n        this._particleSystem.updateInAnimate = this._updateInAnimate;\n    }\n}\n//# sourceMappingURL=fluidRenderingObjectParticleSystem.js.map","\nimport { Texture } from \"../../Materials/Textures/texture.js\";\nimport { Vector2 } from \"../../Maths/math.vector.js\";\nimport { PostProcess } from \"../../PostProcesses/postProcess.js\";\nimport { Observable } from \"../../Misc/observable.js\";\n/** @internal */\nexport class FluidRenderingTextures {\n    get blurNumIterations() {\n        return this._blurNumIterations;\n    }\n    set blurNumIterations(numIterations) {\n        if (this._blurNumIterations === numIterations) {\n            return;\n        }\n        this._blurNumIterations = numIterations;\n        if (this._blurPostProcesses !== null) {\n            const blurX = this._blurPostProcesses[0];\n            const blurY = this._blurPostProcesses[1];\n            this._blurPostProcesses = [];\n            for (let i = 0; i < this._blurNumIterations * 2; ++i) {\n                this._blurPostProcesses[i] = i & 1 ? blurY : blurX;\n            }\n        }\n    }\n    get renderTarget() {\n        return this._rt;\n    }\n    get renderTargetBlur() {\n        return this._rtBlur;\n    }\n    get texture() {\n        return this._texture;\n    }\n    get textureBlur() {\n        return this._textureBlurred;\n    }\n    constructor(name, scene, width, height, blurTextureSizeX, blurTextureSizeY, textureType = 1, textureFormat = 6, blurTextureType = 1, blurTextureFormat = 6, useStandardBlur = false, camera = null, generateDepthBuffer = true, samples = 1) {\n        this.enableBlur = true;\n        this.blurSizeDivisor = 1;\n        this.blurFilterSize = 7;\n        this._blurNumIterations = 3;\n        this.blurMaxFilterSize = 100;\n        this.blurDepthScale = 10;\n        this.particleSize = 0.02;\n        this.onDisposeObservable = new Observable();\n        this._name = name;\n        this._scene = scene;\n        this._camera = camera;\n        this._engine = scene.getEngine();\n        this._width = width;\n        this._height = height;\n        this._blurTextureSizeX = blurTextureSizeX;\n        this._blurTextureSizeY = blurTextureSizeY;\n        this._textureType = textureType;\n        this._textureFormat = textureFormat;\n        this._blurTextureType = blurTextureType;\n        this._blurTextureFormat = blurTextureFormat;\n        this._useStandardBlur = useStandardBlur;\n        this._generateDepthBuffer = generateDepthBuffer;\n        this._samples = samples;\n        this._postProcessRunningIndex = 0;\n        this.enableBlur = blurTextureSizeX !== 0 && blurTextureSizeY !== 0;\n        this._rt = null;\n        this._texture = null;\n        this._rtBlur = null;\n        this._textureBlurred = null;\n        this._blurPostProcesses = null;\n    }\n    initialize() {\n        this.dispose();\n        this._createRenderTarget();\n        if (this.enableBlur && this._texture) {\n            const [rtBlur, textureBlurred, blurPostProcesses] = this._createBlurPostProcesses(this._texture, this._blurTextureType, this._blurTextureFormat, this.blurSizeDivisor, this._name, this._useStandardBlur);\n            this._rtBlur = rtBlur;\n            this._textureBlurred = textureBlurred;\n            this._blurPostProcesses = blurPostProcesses;\n        }\n    }\n    applyBlurPostProcesses() {\n        if (this.enableBlur && this._blurPostProcesses) {\n            this._postProcessRunningIndex = 0;\n            this._scene.postProcessManager.directRender(this._blurPostProcesses, this._rtBlur, true);\n            this._engine.unBindFramebuffer(this._rtBlur);\n        }\n    }\n    _createRenderTarget() {\n        this._rt = this._engine.createRenderTargetTexture({ width: this._width, height: this._height }, {\n            generateMipMaps: false,\n            type: this._textureType,\n            format: this._textureFormat,\n            samplingMode: 1,\n            generateDepthBuffer: this._generateDepthBuffer,\n            generateStencilBuffer: false,\n            samples: this._samples,\n        });\n        const renderTexture = this._rt.texture;\n        renderTexture.incrementReferences();\n        this._texture = new Texture(null, this._scene);\n        this._texture.name = \"rtt\" + this._name;\n        this._texture._texture = renderTexture;\n        this._texture.wrapU = Texture.CLAMP_ADDRESSMODE;\n        this._texture.wrapV = Texture.CLAMP_ADDRESSMODE;\n        this._texture.anisotropicFilteringLevel = 1;\n    }\n    _createBlurPostProcesses(textureBlurSource, textureType, textureFormat, blurSizeDivisor, debugName, useStandardBlur = false) {\n        const engine = this._scene.getEngine();\n        const targetSize = new Vector2(Math.floor(this._blurTextureSizeX / blurSizeDivisor), Math.floor(this._blurTextureSizeY / blurSizeDivisor));\n        const useBilinearFiltering = (textureType === 1 && engine.getCaps().textureFloatLinearFiltering) ||\n            (textureType === 2 && engine.getCaps().textureHalfFloatLinearFiltering);\n        const rtBlur = this._engine.createRenderTargetTexture({ width: targetSize.x, height: targetSize.y }, {\n            generateMipMaps: false,\n            type: textureType,\n            format: textureFormat,\n            samplingMode: useBilinearFiltering ? 2 : 1,\n            generateDepthBuffer: false,\n            generateStencilBuffer: false,\n            samples: this._samples,\n        });\n        const renderTexture = rtBlur.texture;\n        renderTexture.incrementReferences();\n        const texture = new Texture(null, this._scene);\n        texture.name = \"rttBlurred\" + debugName;\n        texture._texture = renderTexture;\n        texture.wrapU = Texture.CLAMP_ADDRESSMODE;\n        texture.wrapV = Texture.CLAMP_ADDRESSMODE;\n        texture.anisotropicFilteringLevel = 1;\n        if (useStandardBlur) {\n            const kernelBlurXPostprocess = new PostProcess(\"BilateralBlurX\", \"fluidRenderingStandardBlur\", [\"filterSize\", \"blurDir\"], null, 1, null, 1, engine, true, null, textureType, undefined, undefined, undefined, textureFormat);\n            kernelBlurXPostprocess.samples = this._samples;\n            kernelBlurXPostprocess.externalTextureSamplerBinding = true;\n            kernelBlurXPostprocess.onApplyObservable.add((effect) => {\n                if (this._postProcessRunningIndex === 0) {\n                    effect.setTexture(\"textureSampler\", textureBlurSource);\n                }\n                else {\n                    effect._bindTexture(\"textureSampler\", kernelBlurXPostprocess.inputTexture.texture);\n                }\n                effect.setInt(\"filterSize\", this.blurFilterSize);\n                effect.setFloat2(\"blurDir\", 1 / this._blurTextureSizeX, 0);\n                this._postProcessRunningIndex++;\n            });\n            kernelBlurXPostprocess.onSizeChangedObservable.add(() => {\n                kernelBlurXPostprocess._textures.forEach((rt) => {\n                    rt.texture.wrapU = Texture.CLAMP_ADDRESSMODE;\n                    rt.texture.wrapV = Texture.CLAMP_ADDRESSMODE;\n                });\n            });\n            this._fixReusablePostProcess(kernelBlurXPostprocess);\n            const kernelBlurYPostprocess = new PostProcess(\"BilateralBlurY\", \"fluidRenderingStandardBlur\", [\"filterSize\", \"blurDir\"], null, 1, null, 1, engine, true, null, textureType, undefined, undefined, undefined, textureFormat);\n            kernelBlurYPostprocess.samples = this._samples;\n            kernelBlurYPostprocess.onApplyObservable.add((effect) => {\n                effect.setInt(\"filterSize\", this.blurFilterSize);\n                effect.setFloat2(\"blurDir\", 0, 1 / this._blurTextureSizeY);\n                this._postProcessRunningIndex++;\n            });\n            kernelBlurYPostprocess.onSizeChangedObservable.add(() => {\n                kernelBlurYPostprocess._textures.forEach((rt) => {\n                    rt.texture.wrapU = Texture.CLAMP_ADDRESSMODE;\n                    rt.texture.wrapV = Texture.CLAMP_ADDRESSMODE;\n                });\n            });\n            this._fixReusablePostProcess(kernelBlurYPostprocess);\n            kernelBlurXPostprocess.autoClear = false;\n            kernelBlurYPostprocess.autoClear = false;\n            const blurList = [];\n            for (let i = 0; i < this._blurNumIterations * 2; ++i) {\n                blurList[i] = i & 1 ? kernelBlurYPostprocess : kernelBlurXPostprocess;\n            }\n            return [rtBlur, texture, blurList];\n        }\n        else {\n            const uniforms = [\"maxFilterSize\", \"blurDir\", \"projectedParticleConstant\", \"depthThreshold\"];\n            const kernelBlurXPostprocess = new PostProcess(\"BilateralBlurX\", \"fluidRenderingBilateralBlur\", uniforms, null, 1, null, 1, engine, true, null, textureType, undefined, undefined, undefined, textureFormat);\n            kernelBlurXPostprocess.samples = this._samples;\n            kernelBlurXPostprocess.externalTextureSamplerBinding = true;\n            kernelBlurXPostprocess.onApplyObservable.add((effect) => {\n                if (this._postProcessRunningIndex === 0) {\n                    effect.setTexture(\"textureSampler\", textureBlurSource);\n                }\n                else {\n                    effect._bindTexture(\"textureSampler\", kernelBlurXPostprocess.inputTexture.texture);\n                }\n                effect.setInt(\"maxFilterSize\", this.blurMaxFilterSize);\n                effect.setFloat2(\"blurDir\", 1 / this._blurTextureSizeX, 0);\n                effect.setFloat(\"projectedParticleConstant\", this._getProjectedParticleConstant());\n                effect.setFloat(\"depthThreshold\", this._getDepthThreshold());\n                this._postProcessRunningIndex++;\n            });\n            kernelBlurXPostprocess.onSizeChangedObservable.add(() => {\n                kernelBlurXPostprocess._textures.forEach((rt) => {\n                    rt.texture.wrapU = Texture.CLAMP_ADDRESSMODE;\n                    rt.texture.wrapV = Texture.CLAMP_ADDRESSMODE;\n                });\n            });\n            this._fixReusablePostProcess(kernelBlurXPostprocess);\n            const kernelBlurYPostprocess = new PostProcess(\"BilateralBlurY\", \"fluidRenderingBilateralBlur\", uniforms, null, 1, null, 1, engine, true, null, textureType, undefined, undefined, undefined, textureFormat);\n            kernelBlurYPostprocess.samples = this._samples;\n            kernelBlurYPostprocess.onApplyObservable.add((effect) => {\n                effect.setInt(\"maxFilterSize\", this.blurMaxFilterSize);\n                effect.setFloat2(\"blurDir\", 0, 1 / this._blurTextureSizeY);\n                effect.setFloat(\"projectedParticleConstant\", this._getProjectedParticleConstant());\n                effect.setFloat(\"depthThreshold\", this._getDepthThreshold());\n                this._postProcessRunningIndex++;\n            });\n            kernelBlurYPostprocess.onSizeChangedObservable.add(() => {\n                kernelBlurYPostprocess._textures.forEach((rt) => {\n                    rt.texture.wrapU = Texture.CLAMP_ADDRESSMODE;\n                    rt.texture.wrapV = Texture.CLAMP_ADDRESSMODE;\n                });\n            });\n            this._fixReusablePostProcess(kernelBlurYPostprocess);\n            kernelBlurXPostprocess.autoClear = false;\n            kernelBlurYPostprocess.autoClear = false;\n            const blurList = [];\n            for (let i = 0; i < this._blurNumIterations * 2; ++i) {\n                blurList[i] = i & 1 ? kernelBlurYPostprocess : kernelBlurXPostprocess;\n            }\n            return [rtBlur, texture, blurList];\n        }\n    }\n    _fixReusablePostProcess(pp) {\n        if (!pp.isReusable()) {\n            return;\n        }\n        pp.onActivateObservable.add(() => {\n            // undo what calling activate() does which will make sure we will retrieve the right texture when getting the input for the post process\n            pp._currentRenderTextureInd = (pp._currentRenderTextureInd + 1) % 2;\n        });\n        pp.onApplyObservable.add(() => {\n            // now we can advance to the next texture\n            pp._currentRenderTextureInd = (pp._currentRenderTextureInd + 1) % 2;\n        });\n    }\n    _getProjectedParticleConstant() {\n        var _a, _b;\n        return (this.blurFilterSize * this.particleSize * 0.05 * (this._height / 2)) / Math.tan(((_b = (_a = this._camera) === null || _a === void 0 ? void 0 : _a.fov) !== null && _b !== void 0 ? _b : (45 * Math.PI) / 180) / 2);\n    }\n    _getDepthThreshold() {\n        return (this.particleSize / 2) * this.blurDepthScale;\n    }\n    dispose() {\n        var _a, _b, _c, _d;\n        if (this.onDisposeObservable.hasObservers()) {\n            this.onDisposeObservable.notifyObservers(this);\n        }\n        (_a = this._rt) === null || _a === void 0 ? void 0 : _a.dispose();\n        this._rt = null;\n        (_b = this._texture) === null || _b === void 0 ? void 0 : _b.dispose();\n        this._texture = null;\n        (_c = this._rtBlur) === null || _c === void 0 ? void 0 : _c.dispose();\n        this._rtBlur = null;\n        (_d = this._textureBlurred) === null || _d === void 0 ? void 0 : _d.dispose();\n        this._textureBlurred = null;\n        if (this._blurPostProcesses) {\n            this._blurPostProcesses[0].dispose();\n            this._blurPostProcesses[1].dispose();\n        }\n        this._blurPostProcesses = null;\n    }\n}\n//# sourceMappingURL=fluidRenderingTextures.js.map","\nimport { Color3, Color4 } from \"../../Maths/math.color.js\";\nimport { Matrix, Vector2, Vector3 } from \"../../Maths/math.vector.js\";\nimport { Observable } from \"../../Misc/observable.js\";\nimport { PostProcess } from \"../../PostProcesses/postProcess.js\";\nimport { FluidRenderingTextures } from \"./fluidRenderingTextures.js\";\n/**\n * Textures that can be displayed as a debugging tool\n */\nexport var FluidRenderingDebug;\n(function (FluidRenderingDebug) {\n    FluidRenderingDebug[FluidRenderingDebug[\"DepthTexture\"] = 0] = \"DepthTexture\";\n    FluidRenderingDebug[FluidRenderingDebug[\"DepthBlurredTexture\"] = 1] = \"DepthBlurredTexture\";\n    FluidRenderingDebug[FluidRenderingDebug[\"ThicknessTexture\"] = 2] = \"ThicknessTexture\";\n    FluidRenderingDebug[FluidRenderingDebug[\"ThicknessBlurredTexture\"] = 3] = \"ThicknessBlurredTexture\";\n    FluidRenderingDebug[FluidRenderingDebug[\"DiffuseTexture\"] = 4] = \"DiffuseTexture\";\n    FluidRenderingDebug[FluidRenderingDebug[\"Normals\"] = 5] = \"Normals\";\n    FluidRenderingDebug[FluidRenderingDebug[\"DiffuseRendering\"] = 6] = \"DiffuseRendering\";\n})(FluidRenderingDebug || (FluidRenderingDebug = {}));\n/**\n * Class used to render an object as a fluid thanks to different render target textures (depth, thickness, diffuse)\n */\nexport class FluidRenderingTargetRenderer {\n    /**\n     * Returns true if the class needs to be reinitialized (because of changes in parameterization)\n     */\n    get needInitialization() {\n        return this._needInitialization;\n    }\n    /**\n     * Gets or sets a boolean indicating that the diffuse texture should be generated and used for the rendering\n     */\n    get generateDiffuseTexture() {\n        return this._generateDiffuseTexture;\n    }\n    set generateDiffuseTexture(generate) {\n        if (this._generateDiffuseTexture === generate) {\n            return;\n        }\n        this._generateDiffuseTexture = generate;\n        this._needInitialization = true;\n    }\n    /**\n     * Gets or sets the feature (texture) to be debugged. Not used if debug is false\n     */\n    get debugFeature() {\n        return this._debugFeature;\n    }\n    set debugFeature(feature) {\n        if (this._debugFeature === feature) {\n            return;\n        }\n        this._needInitialization = true;\n        this._debugFeature = feature;\n    }\n    /**\n     * Gets or sets a boolean indicating if we should display a specific texture (given by debugFeature) for debugging purpose\n     */\n    get debug() {\n        return this._debug;\n    }\n    set debug(debug) {\n        if (this._debug === debug) {\n            return;\n        }\n        this._debug = debug;\n        this._needInitialization = true;\n    }\n    /**\n     * Gets or sets the environment map used for the reflection part of the shading\n     * If null, no map will be used. If undefined, the scene.environmentMap will be used (if defined)\n     */\n    get environmentMap() {\n        return this._environmentMap;\n    }\n    set environmentMap(map) {\n        if (this._environmentMap === map) {\n            return;\n        }\n        this._needInitialization = true;\n        this._environmentMap = map;\n    }\n    /**\n     * Gets or sets a boolean indicating that the depth texture should be blurred\n     */\n    get enableBlurDepth() {\n        return this._enableBlurDepth;\n    }\n    set enableBlurDepth(enable) {\n        if (this._enableBlurDepth === enable) {\n            return;\n        }\n        this._enableBlurDepth = enable;\n        this._needInitialization = true;\n    }\n    /**\n     * Gets or sets the depth size divisor (positive number, generally between 1 and 4), which is used as a divisor when creating the texture used for blurring the depth\n     * For eg. if blurDepthSizeDivisor=2, the texture used to blur the depth will be half the size of the depth texture\n     */\n    get blurDepthSizeDivisor() {\n        return this._blurDepthSizeDivisor;\n    }\n    set blurDepthSizeDivisor(scale) {\n        if (this._blurDepthSizeDivisor === scale) {\n            return;\n        }\n        this._blurDepthSizeDivisor = scale;\n        this._needInitialization = true;\n    }\n    /**\n     * Size of the kernel used to filter the depth blur texture (positive number, generally between 1 and 20 - higher values will require more processing power from the GPU)\n     */\n    get blurDepthFilterSize() {\n        return this._blurDepthFilterSize;\n    }\n    set blurDepthFilterSize(filterSize) {\n        if (this._blurDepthFilterSize === filterSize) {\n            return;\n        }\n        this._blurDepthFilterSize = filterSize;\n        this._setBlurParameters();\n    }\n    /**\n     * Number of blurring iterations used to generate the depth blur texture (positive number, generally between 1 and 10 - higher values will require more processing power from the GPU)\n     */\n    get blurDepthNumIterations() {\n        return this._blurDepthNumIterations;\n    }\n    set blurDepthNumIterations(numIterations) {\n        if (this._blurDepthNumIterations === numIterations) {\n            return;\n        }\n        this._blurDepthNumIterations = numIterations;\n        this._setBlurParameters();\n    }\n    /**\n     * Maximum size of the kernel used to blur the depth texture (positive number, generally between 1 and 200 - higher values will require more processing power from the GPU when the particles are larger on screen)\n     */\n    get blurDepthMaxFilterSize() {\n        return this._blurDepthMaxFilterSize;\n    }\n    set blurDepthMaxFilterSize(maxFilterSize) {\n        if (this._blurDepthMaxFilterSize === maxFilterSize) {\n            return;\n        }\n        this._blurDepthMaxFilterSize = maxFilterSize;\n        this._setBlurParameters();\n    }\n    /**\n     * Depth weight in the calculation when applying the bilateral blur to generate the depth blur texture (positive number, generally between 0 and 100)\n     */\n    get blurDepthDepthScale() {\n        return this._blurDepthDepthScale;\n    }\n    set blurDepthDepthScale(scale) {\n        if (this._blurDepthDepthScale === scale) {\n            return;\n        }\n        this._blurDepthDepthScale = scale;\n        this._setBlurParameters();\n    }\n    /**\n     * Gets or sets a boolean indicating that the thickness texture should be blurred\n     */\n    get enableBlurThickness() {\n        return this._enableBlurThickness;\n    }\n    set enableBlurThickness(enable) {\n        if (this._enableBlurThickness === enable) {\n            return;\n        }\n        this._enableBlurThickness = enable;\n        this._needInitialization = true;\n    }\n    /**\n     * Gets or sets the thickness size divisor (positive number, generally between 1 and 4), which is used as a divisor when creating the texture used for blurring the thickness\n     * For eg. if blurThicknessSizeDivisor=2, the texture used to blur the thickness will be half the size of the thickness texture\n     */\n    get blurThicknessSizeDivisor() {\n        return this._blurThicknessSizeDivisor;\n    }\n    set blurThicknessSizeDivisor(scale) {\n        if (this._blurThicknessSizeDivisor === scale) {\n            return;\n        }\n        this._blurThicknessSizeDivisor = scale;\n        this._needInitialization = true;\n    }\n    /**\n     * Size of the kernel used to filter the thickness blur texture (positive number, generally between 1 and 20 - higher values will require more processing power from the GPU)\n     */\n    get blurThicknessFilterSize() {\n        return this._blurThicknessFilterSize;\n    }\n    set blurThicknessFilterSize(filterSize) {\n        if (this._blurThicknessFilterSize === filterSize) {\n            return;\n        }\n        this._blurThicknessFilterSize = filterSize;\n        this._setBlurParameters();\n    }\n    /**\n     * Number of blurring iterations used to generate the thickness blur texture (positive number, generally between 1 and 10 - higher values will require more processing power from the GPU)\n     */\n    get blurThicknessNumIterations() {\n        return this._blurThicknessNumIterations;\n    }\n    set blurThicknessNumIterations(numIterations) {\n        if (this._blurThicknessNumIterations === numIterations) {\n            return;\n        }\n        this._blurThicknessNumIterations = numIterations;\n        this._setBlurParameters();\n    }\n    /**\n     * Gets or sets a boolean indicating that a fixed thickness should be used instead of generating a thickness texture\n     */\n    get useFixedThickness() {\n        return this._useFixedThickness;\n    }\n    set useFixedThickness(use) {\n        if (this._useFixedThickness === use) {\n            return;\n        }\n        this._useFixedThickness = use;\n        this._needInitialization = true;\n    }\n    /**\n     * Gets or sets a boolean indicating that the velocity should be used when rendering the particles as a fluid.\n     * Note: the vertex buffers must contain a \"velocity\" buffer for this to work!\n     */\n    get useVelocity() {\n        return this._useVelocity;\n    }\n    set useVelocity(use) {\n        if (this._useVelocity === use) {\n            return;\n        }\n        this._useVelocity = use;\n        this._needInitialization = true;\n        this._onUseVelocityChanged.notifyObservers(this);\n    }\n    /**\n     * Defines the size of the depth texture.\n     * If null, the texture will have the size of the screen\n     */\n    get depthMapSize() {\n        return this._depthMapSize;\n    }\n    set depthMapSize(size) {\n        if (this._depthMapSize === size) {\n            return;\n        }\n        this._depthMapSize = size;\n        this._needInitialization = true;\n    }\n    /**\n     * Defines the size of the thickness texture.\n     * If null, the texture will have the size of the screen\n     */\n    get thicknessMapSize() {\n        return this._thicknessMapSize;\n    }\n    set thicknessMapSize(size) {\n        if (this._thicknessMapSize === size) {\n            return;\n        }\n        this._thicknessMapSize = size;\n        this._needInitialization = true;\n    }\n    /**\n     * Defines the size of the diffuse texture.\n     * If null, the texture will have the size of the screen\n     */\n    get diffuseMapSize() {\n        return this._diffuseMapSize;\n    }\n    set diffuseMapSize(size) {\n        if (this._diffuseMapSize === size) {\n            return;\n        }\n        this._diffuseMapSize = size;\n        this._needInitialization = true;\n    }\n    /**\n     * Gets or sets the number of samples used by MSAA\n     * Note: changing this value in WebGL does not work because depth/stencil textures can't be created with MSAA (see https://github.com/BabylonJS/Babylon.js/issues/12444)\n     */\n    get samples() {\n        return this._samples;\n    }\n    set samples(samples) {\n        if (this._samples === samples) {\n            return;\n        }\n        this._samples = samples;\n        this._needInitialization = true;\n    }\n    /**\n     * Gets the camera used for the rendering\n     */\n    get camera() {\n        return this._camera;\n    }\n    /**\n     * Creates an instance of the class\n     * @param scene Scene used to render the fluid object into\n     * @param camera Camera used to render the fluid object. If not provided, use the active camera of the scene instead\n     */\n    constructor(scene, camera) {\n        this._generateDiffuseTexture = false;\n        /**\n         * Fluid color. Not used if generateDiffuseTexture is true\n         */\n        this.fluidColor = new Color3(0.085, 0.6375, 0.765);\n        /**\n         * Density of the fluid (positive number). The higher the value, the more opaque the fluid.\n         */\n        this.density = 2;\n        /**\n         * Strength of the refraction (positive number, but generally between 0 and 0.3).\n         */\n        this.refractionStrength = 0.1;\n        /**\n         * Strength of the fresnel effect (value between 0 and 1). Lower the value if you want to soften the specular effect\n         */\n        this.fresnelClamp = 1.0;\n        /**\n         * Strength of the specular power (positive number). Increase the value to make the specular effect more concentrated\n         */\n        this.specularPower = 250;\n        /**\n         * Minimum thickness of the particles (positive number). If useFixedThickness is true, minimumThickness is the thickness used\n         */\n        this.minimumThickness = 0;\n        /**\n         * Direction of the light. The fluid is assumed to be lit by a directional light\n         */\n        this.dirLight = new Vector3(-2, -1, 1).normalize();\n        this._debugFeature = FluidRenderingDebug.DepthBlurredTexture;\n        this._debug = false;\n        this._enableBlurDepth = true;\n        this._blurDepthSizeDivisor = 1;\n        this._blurDepthFilterSize = 7;\n        this._blurDepthNumIterations = 3;\n        this._blurDepthMaxFilterSize = 100;\n        this._blurDepthDepthScale = 10;\n        this._enableBlurThickness = true;\n        this._blurThicknessSizeDivisor = 1;\n        this._blurThicknessFilterSize = 5;\n        this._blurThicknessNumIterations = 1;\n        this._useFixedThickness = false;\n        /** @internal */\n        this._onUseVelocityChanged = new Observable();\n        this._useVelocity = false;\n        this._depthMapSize = null;\n        this._thicknessMapSize = null;\n        this._diffuseMapSize = null;\n        this._samples = 1;\n        this._scene = scene;\n        this._engine = scene.getEngine();\n        this._camera = camera !== null && camera !== void 0 ? camera : scene.activeCamera;\n        this._needInitialization = true;\n        this._bgDepthTexture = null;\n        this._invProjectionMatrix = new Matrix();\n        this._depthClearColor = new Color4(1e6, 1e6, 1e6, 1);\n        this._thicknessClearColor = new Color4(0, 0, 0, 1);\n        this._depthRenderTarget = null;\n        this._diffuseRenderTarget = null;\n        this._thicknessRenderTarget = null;\n        this._renderPostProcess = null;\n    }\n    /** @internal */\n    _initialize() {\n        var _a, _b, _c;\n        this.dispose();\n        this._needInitialization = false;\n        const depthWidth = (_a = this._depthMapSize) !== null && _a !== void 0 ? _a : this._engine.getRenderWidth();\n        const depthHeight = this._depthMapSize !== null ? Math.round((this._depthMapSize * this._engine.getRenderHeight()) / this._engine.getRenderWidth()) : this._engine.getRenderHeight();\n        this._depthRenderTarget = new FluidRenderingTextures(\"Depth\", this._scene, depthWidth, depthHeight, depthWidth, depthHeight, 1, 7, 1, 7, false, this._camera, true, this._samples);\n        this._initializeRenderTarget(this._depthRenderTarget);\n        if (this.generateDiffuseTexture) {\n            const diffuseWidth = (_b = this._diffuseMapSize) !== null && _b !== void 0 ? _b : this._engine.getRenderWidth();\n            const diffuseHeight = this._diffuseMapSize !== null\n                ? Math.round((this._diffuseMapSize * this._engine.getRenderHeight()) / this._engine.getRenderWidth())\n                : this._engine.getRenderHeight();\n            this._diffuseRenderTarget = new FluidRenderingTextures(\"Diffuse\", this._scene, diffuseWidth, diffuseHeight, 0, 0, 0, 5, 0, 5, true, this._camera, true, this._samples);\n            this._initializeRenderTarget(this._diffuseRenderTarget);\n        }\n        const thicknessWidth = (_c = this._thicknessMapSize) !== null && _c !== void 0 ? _c : this._engine.getRenderWidth();\n        const thicknessHeight = this._thicknessMapSize !== null\n            ? Math.round((this._thicknessMapSize * this._engine.getRenderHeight()) / this._engine.getRenderWidth())\n            : this._engine.getRenderHeight();\n        if (!this._useFixedThickness) {\n            this._thicknessRenderTarget = new FluidRenderingTextures(\"Thickness\", this._scene, thicknessWidth, thicknessHeight, thicknessWidth, thicknessHeight, 2, 6, 2, 6, true, this._camera, false, this._samples);\n            this._initializeRenderTarget(this._thicknessRenderTarget);\n        }\n        this._createLiquidRenderingPostProcess();\n    }\n    _setBlurParameters(renderTarget = null) {\n        if (renderTarget === null || renderTarget === this._depthRenderTarget) {\n            this._setBlurDepthParameters();\n        }\n        if (renderTarget === null || renderTarget === this._thicknessRenderTarget) {\n            this._setBlurThicknessParameters();\n        }\n    }\n    _setBlurDepthParameters() {\n        if (!this._depthRenderTarget) {\n            return;\n        }\n        this._depthRenderTarget.blurFilterSize = this.blurDepthFilterSize;\n        this._depthRenderTarget.blurMaxFilterSize = this.blurDepthMaxFilterSize;\n        this._depthRenderTarget.blurNumIterations = this.blurDepthNumIterations;\n        this._depthRenderTarget.blurDepthScale = this.blurDepthDepthScale;\n    }\n    _setBlurThicknessParameters() {\n        if (!this._thicknessRenderTarget) {\n            return;\n        }\n        this._thicknessRenderTarget.blurFilterSize = this.blurThicknessFilterSize;\n        this._thicknessRenderTarget.blurNumIterations = this.blurThicknessNumIterations;\n    }\n    _initializeRenderTarget(renderTarget) {\n        if (renderTarget !== this._diffuseRenderTarget) {\n            renderTarget.enableBlur = renderTarget === this._depthRenderTarget ? this.enableBlurDepth : this.enableBlurThickness;\n            renderTarget.blurSizeDivisor = renderTarget === this._depthRenderTarget ? this.blurDepthSizeDivisor : this.blurThicknessSizeDivisor;\n        }\n        this._setBlurParameters(renderTarget);\n        renderTarget.initialize();\n    }\n    _createLiquidRenderingPostProcess() {\n        var _a;\n        const engine = this._scene.getEngine();\n        const uniformNames = [\n            \"viewMatrix\",\n            \"projectionMatrix\",\n            \"invProjectionMatrix\",\n            \"texelSize\",\n            \"dirLight\",\n            \"cameraFar\",\n            \"density\",\n            \"refractionStrength\",\n            \"fresnelClamp\",\n            \"specularPower\",\n        ];\n        const samplerNames = [\"depthSampler\"];\n        const defines = [];\n        this.dispose(true);\n        if (!this._camera) {\n            return;\n        }\n        const texture = this._depthRenderTarget.enableBlur ? this._depthRenderTarget.textureBlur : this._depthRenderTarget.texture;\n        const texelSize = new Vector2(1 / texture.getSize().width, 1 / texture.getSize().height);\n        if (this._scene.useRightHandedSystem) {\n            defines.push(\"#define FLUIDRENDERING_RHS\");\n        }\n        if (this._environmentMap !== null) {\n            const envMap = (_a = this._environmentMap) !== null && _a !== void 0 ? _a : this._scene.environmentTexture;\n            if (envMap) {\n                samplerNames.push(\"reflectionSampler\");\n                defines.push(\"#define FLUIDRENDERING_ENVIRONMENT\");\n            }\n        }\n        if (this._diffuseRenderTarget) {\n            samplerNames.push(\"diffuseSampler\");\n            defines.push(\"#define FLUIDRENDERING_DIFFUSETEXTURE\");\n        }\n        else {\n            uniformNames.push(\"diffuseColor\");\n        }\n        if (this._useVelocity) {\n            samplerNames.push(\"velocitySampler\");\n            defines.push(\"#define FLUIDRENDERING_VELOCITY\");\n        }\n        if (this._useFixedThickness) {\n            uniformNames.push(\"thickness\");\n            samplerNames.push(\"bgDepthSampler\");\n            defines.push(\"#define FLUIDRENDERING_FIXED_THICKNESS\");\n        }\n        else {\n            uniformNames.push(\"minimumThickness\");\n            samplerNames.push(\"thicknessSampler\");\n        }\n        if (this._debug) {\n            defines.push(\"#define FLUIDRENDERING_DEBUG\");\n            if (this._debugFeature === FluidRenderingDebug.Normals) {\n                defines.push(\"#define FLUIDRENDERING_DEBUG_SHOWNORMAL\");\n            }\n            else if (this._debugFeature === FluidRenderingDebug.DiffuseRendering) {\n                defines.push(\"#define FLUIDRENDERING_DEBUG_DIFFUSERENDERING\");\n            }\n            else {\n                defines.push(\"#define FLUIDRENDERING_DEBUG_TEXTURE\");\n                samplerNames.push(\"debugSampler\");\n                if (this._debugFeature === FluidRenderingDebug.DepthTexture || this._debugFeature === FluidRenderingDebug.DepthBlurredTexture) {\n                    defines.push(\"#define FLUIDRENDERING_DEBUG_DEPTH\");\n                }\n            }\n        }\n        this._renderPostProcess = new PostProcess(\"FluidRendering\", \"fluidRenderingRender\", uniformNames, samplerNames, 1, null, 2, engine, false, null, 0, undefined, undefined, true, undefined);\n        this._renderPostProcess.updateEffect(defines.join(\"\\n\"));\n        this._renderPostProcess.samples = this._samples;\n        this._renderPostProcess.onApplyObservable.add((effect) => {\n            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y;\n            this._invProjectionMatrix.copyFrom(this._scene.getProjectionMatrix());\n            this._invProjectionMatrix.invert();\n            if (engine.isWebGPU) {\n                effect.setTextureSampler(\"textureSamplerSampler\", this._renderPostProcess.inputTexture.texture);\n            }\n            if (!this._depthRenderTarget.enableBlur) {\n                effect.setTexture(\"depthSampler\", this._depthRenderTarget.texture);\n                if (engine.isWebGPU) {\n                    effect.setTextureSampler(\"depthSamplerSampler\", (_b = (_a = this._depthRenderTarget.texture) === null || _a === void 0 ? void 0 : _a.getInternalTexture()) !== null && _b !== void 0 ? _b : null);\n                }\n            }\n            else {\n                effect.setTexture(\"depthSampler\", this._depthRenderTarget.textureBlur);\n                if (engine.isWebGPU) {\n                    effect.setTextureSampler(\"depthSamplerSampler\", (_d = (_c = this._depthRenderTarget.textureBlur) === null || _c === void 0 ? void 0 : _c.getInternalTexture()) !== null && _d !== void 0 ? _d : null);\n                }\n            }\n            if (this._diffuseRenderTarget) {\n                if (!this._diffuseRenderTarget.enableBlur) {\n                    effect.setTexture(\"diffuseSampler\", this._diffuseRenderTarget.texture);\n                    if (engine.isWebGPU) {\n                        effect.setTextureSampler(\"diffuseSamplerSampler\", (_f = (_e = this._diffuseRenderTarget.texture) === null || _e === void 0 ? void 0 : _e.getInternalTexture()) !== null && _f !== void 0 ? _f : null);\n                    }\n                }\n                else {\n                    effect.setTexture(\"diffuseSampler\", this._diffuseRenderTarget.textureBlur);\n                    if (engine.isWebGPU) {\n                        effect.setTextureSampler(\"diffuseSamplerSampler\", (_h = (_g = this._diffuseRenderTarget.textureBlur) === null || _g === void 0 ? void 0 : _g.getInternalTexture()) !== null && _h !== void 0 ? _h : null);\n                    }\n                }\n            }\n            else {\n                effect.setColor3(\"diffuseColor\", this.fluidColor);\n            }\n            if (this._useFixedThickness) {\n                effect.setFloat(\"thickness\", this.minimumThickness);\n                effect._bindTexture(\"bgDepthSampler\", this._bgDepthTexture);\n                if (engine.isWebGPU) {\n                    effect.setTextureSampler(\"bgDepthSamplerSampler\", (_j = this._bgDepthTexture) !== null && _j !== void 0 ? _j : null);\n                }\n            }\n            else {\n                if (!this._thicknessRenderTarget.enableBlur) {\n                    effect.setTexture(\"thicknessSampler\", this._thicknessRenderTarget.texture);\n                    if (engine.isWebGPU) {\n                        effect.setTextureSampler(\"thicknessSamplerSampler\", (_l = (_k = this._thicknessRenderTarget.texture) === null || _k === void 0 ? void 0 : _k.getInternalTexture()) !== null && _l !== void 0 ? _l : null);\n                    }\n                }\n                else {\n                    effect.setTexture(\"thicknessSampler\", this._thicknessRenderTarget.textureBlur);\n                    if (engine.isWebGPU) {\n                        effect.setTextureSampler(\"thicknessSamplerSampler\", (_o = (_m = this._thicknessRenderTarget.textureBlur) === null || _m === void 0 ? void 0 : _m.getInternalTexture()) !== null && _o !== void 0 ? _o : null);\n                    }\n                }\n                effect.setFloat(\"minimumThickness\", this.minimumThickness);\n            }\n            if (this._environmentMap !== null) {\n                const envMap = (_p = this._environmentMap) !== null && _p !== void 0 ? _p : this._scene.environmentTexture;\n                if (envMap) {\n                    effect.setTexture(\"reflectionSampler\", envMap);\n                    if (engine.isWebGPU) {\n                        effect.setTextureSampler(\"reflectionSamplerSampler\", (_q = envMap === null || envMap === void 0 ? void 0 : envMap.getInternalTexture()) !== null && _q !== void 0 ? _q : null);\n                    }\n                }\n            }\n            effect.setMatrix(\"viewMatrix\", this._scene.getViewMatrix());\n            effect.setMatrix(\"invProjectionMatrix\", this._invProjectionMatrix);\n            effect.setMatrix(\"projectionMatrix\", this._scene.getProjectionMatrix());\n            effect.setVector2(\"texelSize\", texelSize);\n            effect.setFloat(\"density\", this.density);\n            effect.setFloat(\"refractionStrength\", this.refractionStrength);\n            effect.setFloat(\"fresnelClamp\", this.fresnelClamp);\n            effect.setFloat(\"specularPower\", this.specularPower);\n            effect.setVector3(\"dirLight\", this.dirLight);\n            effect.setFloat(\"cameraFar\", this._camera.maxZ);\n            if (this._debug) {\n                let texture = null;\n                switch (this._debugFeature) {\n                    case FluidRenderingDebug.DepthTexture:\n                        texture = this._depthRenderTarget.texture;\n                        break;\n                    case FluidRenderingDebug.DepthBlurredTexture:\n                        texture = this._depthRenderTarget.enableBlur ? this._depthRenderTarget.textureBlur : this._depthRenderTarget.texture;\n                        break;\n                    case FluidRenderingDebug.ThicknessTexture:\n                        texture = (_s = (_r = this._thicknessRenderTarget) === null || _r === void 0 ? void 0 : _r.texture) !== null && _s !== void 0 ? _s : null;\n                        break;\n                    case FluidRenderingDebug.ThicknessBlurredTexture:\n                        texture = ((_t = this._thicknessRenderTarget) === null || _t === void 0 ? void 0 : _t.enableBlur) ? (_v = (_u = this._thicknessRenderTarget) === null || _u === void 0 ? void 0 : _u.textureBlur) !== null && _v !== void 0 ? _v : null : (_x = (_w = this._thicknessRenderTarget) === null || _w === void 0 ? void 0 : _w.texture) !== null && _x !== void 0 ? _x : null;\n                        break;\n                    case FluidRenderingDebug.DiffuseTexture:\n                        if (this._diffuseRenderTarget) {\n                            texture = this._diffuseRenderTarget.texture;\n                        }\n                        break;\n                }\n                if (this._debugFeature !== FluidRenderingDebug.Normals) {\n                    effect.setTexture(\"debugSampler\", texture);\n                    if (engine.isWebGPU) {\n                        effect.setTextureSampler(\"debugSamplerSampler\", (_y = texture === null || texture === void 0 ? void 0 : texture.getInternalTexture()) !== null && _y !== void 0 ? _y : null);\n                    }\n                }\n            }\n        });\n    }\n    /** @internal */\n    _clearTargets() {\n        var _a, _b, _c;\n        if ((_a = this._depthRenderTarget) === null || _a === void 0 ? void 0 : _a.renderTarget) {\n            this._engine.bindFramebuffer(this._depthRenderTarget.renderTarget);\n            this._engine.clear(this._depthClearColor, true, true, false);\n            this._engine.unBindFramebuffer(this._depthRenderTarget.renderTarget);\n        }\n        if ((_b = this._diffuseRenderTarget) === null || _b === void 0 ? void 0 : _b.renderTarget) {\n            this._engine.bindFramebuffer(this._diffuseRenderTarget.renderTarget);\n            this._engine.clear(this._thicknessClearColor, true, true, false);\n            this._engine.unBindFramebuffer(this._diffuseRenderTarget.renderTarget);\n        }\n        if ((_c = this._thicknessRenderTarget) === null || _c === void 0 ? void 0 : _c.renderTarget) {\n            this._engine.bindFramebuffer(this._thicknessRenderTarget.renderTarget);\n            // we don't clear the depth buffer because it is the depth buffer that is coming from the scene and that we reuse in the thickness rendering pass\n            this._engine.clear(this._thicknessClearColor, true, false, false);\n            this._engine.unBindFramebuffer(this._thicknessRenderTarget.renderTarget);\n        }\n    }\n    /** @internal */\n    _render(fluidObject) {\n        var _a, _b, _c, _d, _e, _f;\n        if (this._needInitialization || !fluidObject.isReady()) {\n            return;\n        }\n        const currentRenderTarget = this._engine._currentRenderTarget;\n        this._engine.setState(false, undefined, undefined, undefined, true);\n        this._engine.setDepthBuffer(true);\n        this._engine.setDepthWrite(true);\n        this._engine.setAlphaMode(0);\n        // Render the particles in the depth texture\n        if ((_a = this._depthRenderTarget) === null || _a === void 0 ? void 0 : _a.renderTarget) {\n            this._engine.bindFramebuffer(this._depthRenderTarget.renderTarget);\n            fluidObject.renderDepthTexture();\n            this._engine.unbindInstanceAttributes();\n            this._engine.unBindFramebuffer(this._depthRenderTarget.renderTarget);\n        }\n        // Render the particles in the diffuse texture\n        if ((_b = this._diffuseRenderTarget) === null || _b === void 0 ? void 0 : _b.renderTarget) {\n            this._engine.bindFramebuffer(this._diffuseRenderTarget.renderTarget);\n            fluidObject.renderDiffuseTexture();\n            this._engine.unbindInstanceAttributes();\n            this._engine.unBindFramebuffer(this._diffuseRenderTarget.renderTarget);\n        }\n        // Render the particles in the thickness texture\n        if ((_c = this._thicknessRenderTarget) === null || _c === void 0 ? void 0 : _c.renderTarget) {\n            this._engine.bindFramebuffer(this._thicknessRenderTarget.renderTarget);\n            fluidObject.renderThicknessTexture();\n            this._engine.unbindInstanceAttributes();\n            this._engine.unBindFramebuffer(this._thicknessRenderTarget.renderTarget);\n        }\n        // Run the blur post processes\n        (_d = this._depthRenderTarget) === null || _d === void 0 ? void 0 : _d.applyBlurPostProcesses();\n        (_e = this._diffuseRenderTarget) === null || _e === void 0 ? void 0 : _e.applyBlurPostProcesses();\n        (_f = this._thicknessRenderTarget) === null || _f === void 0 ? void 0 : _f.applyBlurPostProcesses();\n        if (currentRenderTarget) {\n            this._engine.bindFramebuffer(currentRenderTarget);\n        }\n    }\n    /**\n     * Releases all the ressources used by the class\n     * @param onlyPostProcesses If true, releases only the ressources used by the render post processes\n     */\n    dispose(onlyPostProcesses = false) {\n        var _a, _b, _c, _d;\n        if (!onlyPostProcesses) {\n            (_a = this._depthRenderTarget) === null || _a === void 0 ? void 0 : _a.dispose();\n            this._depthRenderTarget = null;\n            (_b = this._diffuseRenderTarget) === null || _b === void 0 ? void 0 : _b.dispose();\n            this._diffuseRenderTarget = null;\n            (_c = this._thicknessRenderTarget) === null || _c === void 0 ? void 0 : _c.dispose();\n            this._thicknessRenderTarget = null;\n        }\n        if (this._renderPostProcess && this._camera) {\n            this._camera.detachPostProcess(this._renderPostProcess);\n        }\n        (_d = this._renderPostProcess) === null || _d === void 0 ? void 0 : _d.dispose();\n        this._renderPostProcess = null;\n        this._needInitialization = false;\n    }\n}\n//# sourceMappingURL=fluidRenderingTargetRenderer.js.map","import { VertexBuffer } from \"../../Buffers/buffer.js\";\n\nimport { EffectWrapper } from \"../../Materials/effectRenderer.js\";\nimport { FluidRenderingObject } from \"./fluidRenderingObject.js\";\n/**\n * Defines a rendering object based on a list of custom buffers\n * The list must contain at least a \"position\" buffer!\n */\nexport class FluidRenderingObjectCustomParticles extends FluidRenderingObject {\n    /**\n     * Gets the name of the class\n     */\n    getClassName() {\n        return \"FluidRenderingObjectCustomParticles\";\n    }\n    /**\n     * Gets the vertex buffers\n     */\n    get vertexBuffers() {\n        return this._vertexBuffers;\n    }\n    /**\n     * Creates a new instance of the class\n     * @param scene The scene the particles should be rendered into\n     * @param buffers The list of buffers (must contain at least one \"position\" buffer!). Note that you don't have to pass all (or any!) buffers at once in the constructor, you can use the addBuffers method to add more later.\n     * @param numParticles Number of vertices to take into account from the buffers\n     */\n    constructor(scene, buffers, numParticles) {\n        super(scene);\n        this._numParticles = numParticles;\n        this._diffuseEffectWrapper = null;\n        this._vertexBuffers = {};\n        this.addBuffers(buffers);\n    }\n    /**\n     * Add some new buffers\n     * @param buffers List of buffers\n     */\n    addBuffers(buffers) {\n        for (const name in buffers) {\n            let stride;\n            let instanced = true;\n            switch (name) {\n                case \"velocity\":\n                    stride = 3;\n                    break;\n                case \"offset\":\n                    instanced = false;\n                    break;\n            }\n            this._vertexBuffers[name] = new VertexBuffer(this._engine, buffers[name], name, true, false, stride, instanced);\n        }\n    }\n    _createEffects() {\n        super._createEffects();\n        const uniformNames = [\"view\", \"projection\", \"size\"];\n        const attributeNames = [\"position\", \"offset\", \"color\"];\n        this._diffuseEffectWrapper = new EffectWrapper({\n            engine: this._engine,\n            useShaderStore: true,\n            vertexShader: \"fluidRenderingParticleDiffuse\",\n            fragmentShader: \"fluidRenderingParticleDiffuse\",\n            attributeNames,\n            uniformNames,\n            samplerNames: [],\n        });\n    }\n    /**\n     * Indicates if the object is ready to be rendered\n     * @returns True if everything is ready for the object to be rendered, otherwise false\n     */\n    isReady() {\n        var _a, _b;\n        if (!this._vertexBuffers[\"offset\"]) {\n            this._vertexBuffers[\"offset\"] = new VertexBuffer(this._engine, [0, 0, 1, 0, 0, 1, 1, 1], \"offset\", false, false, 2);\n        }\n        return super.isReady() && ((_b = (_a = this._diffuseEffectWrapper) === null || _a === void 0 ? void 0 : _a.effect.isReady()) !== null && _b !== void 0 ? _b : false);\n    }\n    /**\n     * Gets the number of particles in this object\n     * @returns The number of particles\n     */\n    get numParticles() {\n        return this._numParticles;\n    }\n    /**\n     * Sets the number of particles in this object\n     * @param num The number of particles to take into account\n     */\n    setNumParticles(num) {\n        this._numParticles = num;\n    }\n    /**\n     * Render the diffuse texture for this object\n     */\n    renderDiffuseTexture() {\n        const numParticles = this.numParticles;\n        if (!this._diffuseEffectWrapper || numParticles === 0) {\n            return;\n        }\n        const diffuseDrawWrapper = this._diffuseEffectWrapper._drawWrapper;\n        const diffuseEffect = diffuseDrawWrapper.effect;\n        this._engine.enableEffect(diffuseDrawWrapper);\n        this._engine.bindBuffers(this.vertexBuffers, this.indexBuffer, diffuseEffect);\n        diffuseEffect.setMatrix(\"view\", this._scene.getViewMatrix());\n        diffuseEffect.setMatrix(\"projection\", this._scene.getProjectionMatrix());\n        if (this._particleSize !== null) {\n            diffuseEffect.setFloat2(\"size\", this._particleSize, this._particleSize);\n        }\n        if (this.useInstancing) {\n            this._engine.drawArraysType(7, 0, 4, numParticles);\n        }\n        else {\n            this._engine.drawElementsType(0, 0, numParticles);\n        }\n    }\n    /**\n     * Releases the ressources used by the class\n     */\n    dispose() {\n        var _a;\n        super.dispose();\n        (_a = this._diffuseEffectWrapper) === null || _a === void 0 ? void 0 : _a.dispose();\n        for (const name in this._vertexBuffers) {\n            this._vertexBuffers[name].dispose();\n        }\n        this._vertexBuffers = {};\n    }\n}\n//# sourceMappingURL=fluidRenderingObjectCustomParticles.js.map","\nimport { CopyTextureToTexture } from \"../../Misc/copyTextureToTexture.js\";\n/** @internal */\nexport class FluidRenderingDepthTextureCopy {\n    get depthRTWrapper() {\n        return this._depthRTWrapper;\n    }\n    constructor(engine, width, height, samples = 1) {\n        this._engine = engine;\n        this._copyTextureToTexture = new CopyTextureToTexture(engine, true);\n        this._depthRTWrapper = this._engine.createRenderTargetTexture({ width, height }, {\n            generateMipMaps: false,\n            type: 0,\n            format: 6,\n            samplingMode: 1,\n            generateDepthBuffer: true,\n            generateStencilBuffer: false,\n            samples,\n            noColorAttachment: true,\n        });\n        this._depthRTWrapper.createDepthStencilTexture(0, false, false, 1);\n    }\n    copy(source) {\n        return this._copyTextureToTexture.copy(source, this._depthRTWrapper);\n    }\n    dispose() {\n        this._depthRTWrapper.dispose();\n        this._copyTextureToTexture.dispose();\n    }\n}\n//# sourceMappingURL=fluidRenderingDepthTextureCopy.js.map","import { Scene } from \"../../scene.js\";\nimport { SceneComponentConstants } from \"../../sceneComponent.js\";\nimport { FluidRenderingObjectParticleSystem } from \"./fluidRenderingObjectParticleSystem.js\";\nimport { FluidRenderingTargetRenderer } from \"./fluidRenderingTargetRenderer.js\";\nimport { FluidRenderingObjectCustomParticles } from \"./fluidRenderingObjectCustomParticles.js\";\nimport { FluidRenderingDepthTextureCopy } from \"./fluidRenderingDepthTextureCopy.js\";\nimport \"../../Shaders/fluidRenderingParticleDepth.vertex.js\";\nimport \"../../Shaders/fluidRenderingParticleDepth.fragment.js\";\nimport \"../../Shaders/fluidRenderingParticleThickness.vertex.js\";\nimport \"../../Shaders/fluidRenderingParticleThickness.fragment.js\";\nimport \"../../Shaders/fluidRenderingParticleDiffuse.vertex.js\";\nimport \"../../Shaders/fluidRenderingParticleDiffuse.fragment.js\";\nimport \"../../Shaders/fluidRenderingBilateralBlur.fragment.js\";\nimport \"../../Shaders/fluidRenderingStandardBlur.fragment.js\";\nimport \"../../Shaders/fluidRenderingRender.fragment.js\";\nObject.defineProperty(Scene.prototype, \"fluidRenderer\", {\n    get: function () {\n        return this._fluidRenderer;\n    },\n    set: function (value) {\n        this._fluidRenderer = value;\n    },\n    enumerable: true,\n    configurable: true,\n});\nScene.prototype.enableFluidRenderer = function () {\n    if (this._fluidRenderer) {\n        return this._fluidRenderer;\n    }\n    this._fluidRenderer = new FluidRenderer(this);\n    return this._fluidRenderer;\n};\nScene.prototype.disableFluidRenderer = function () {\n    var _a;\n    (_a = this._fluidRenderer) === null || _a === void 0 ? void 0 : _a.dispose();\n    this._fluidRenderer = null;\n};\nfunction IsParticleSystemObject(obj) {\n    return !!obj.particleSystem;\n}\n/**\n * Defines the fluid renderer scene component responsible to render objects as fluids\n */\nexport class FluidRendererSceneComponent {\n    /**\n     * Creates a new instance of the component for the given scene\n     * @param scene Defines the scene to register the component in\n     */\n    constructor(scene) {\n        /**\n         * The component name helpful to identify the component in the list of scene components.\n         */\n        this.name = SceneComponentConstants.NAME_FLUIDRENDERER;\n        this.scene = scene;\n    }\n    /**\n     * Registers the component in a given scene\n     */\n    register() {\n        this.scene._gatherActiveCameraRenderTargetsStage.registerStep(SceneComponentConstants.STEP_GATHERACTIVECAMERARENDERTARGETS_FLUIDRENDERER, this, this._gatherActiveCameraRenderTargets);\n        this.scene._afterCameraDrawStage.registerStep(SceneComponentConstants.STEP_AFTERCAMERADRAW_FLUIDRENDERER, this, this._afterCameraDraw);\n    }\n    _gatherActiveCameraRenderTargets(_renderTargets) {\n        var _a;\n        (_a = this.scene.fluidRenderer) === null || _a === void 0 ? void 0 : _a._prepareRendering();\n    }\n    _afterCameraDraw(camera) {\n        var _a;\n        (_a = this.scene.fluidRenderer) === null || _a === void 0 ? void 0 : _a._render(camera);\n    }\n    /**\n     * Rebuilds the elements related to this component in case of\n     * context lost for instance.\n     */\n    rebuild() {\n        if (this.scene._fluidRenderer) {\n            // Release resources first\n            this.scene.disableFluidRenderer();\n            // Re-enable\n            this.scene.enableFluidRenderer();\n        }\n    }\n    /**\n     * Disposes the component and the associated resources\n     */\n    dispose() {\n        this.scene.disableFluidRenderer();\n    }\n}\n/**\n * Class responsible for fluid rendering.\n * It is implementing the method described in https://developer.download.nvidia.com/presentations/2010/gdc/Direct3D_Effects.pdf\n */\nexport class FluidRenderer {\n    /** @internal */\n    static _SceneComponentInitialization(scene) {\n        let component = scene._getComponent(SceneComponentConstants.NAME_FLUIDRENDERER);\n        if (!component) {\n            component = new FluidRendererSceneComponent(scene);\n            scene._addComponent(component);\n        }\n    }\n    /**\n     * Initializes the class\n     * @param scene Scene in which the objects are part of\n     */\n    constructor(scene) {\n        this._scene = scene;\n        this._engine = scene.getEngine();\n        this._onEngineResizeObserver = null;\n        this.renderObjects = [];\n        this.targetRenderers = [];\n        this._cameras = new Map();\n        FluidRenderer._SceneComponentInitialization(this._scene);\n        this._onEngineResizeObserver = this._engine.onResizeObservable.add(() => {\n            this._initialize();\n        });\n    }\n    /**\n     * Reinitializes the class\n     * Can be used if you change the object priority (FluidRenderingObject.priority), to make sure the objects are rendered in the right order\n     */\n    recreate() {\n        this._sortRenderingObjects();\n        this._initialize();\n    }\n    /**\n     * Gets the render object corresponding to a particle system (null if the particle system is not rendered as a fluid)\n     * @param ps The particle system\n     * @returns the render object corresponding to this particle system if any, otherwise null\n     */\n    getRenderObjectFromParticleSystem(ps) {\n        const index = this._getParticleSystemIndex(ps);\n        return index !== -1 ? this.renderObjects[index] : null;\n    }\n    /**\n     * Adds a particle system to the fluid renderer.\n     * Note that you should not normally call this method directly, as you can simply use the renderAsFluid property of the ParticleSystem/GPUParticleSystem class\n     * @param ps particle system\n     * @param generateDiffuseTexture True if you want to generate a diffuse texture from the particle system and use it as part of the fluid rendering (default: false)\n     * @param targetRenderer The target renderer used to display the particle system as a fluid. If not provided, the method will create a new one\n     * @param camera The camera used by the target renderer (if the target renderer is created by the method)\n     * @returns the render object corresponding to the particle system\n     */\n    addParticleSystem(ps, generateDiffuseTexture, targetRenderer, camera) {\n        const object = new FluidRenderingObjectParticleSystem(this._scene, ps);\n        object.onParticleSizeChanged.add(this._setParticleSizeForRenderTargets.bind(this));\n        if (!targetRenderer) {\n            targetRenderer = new FluidRenderingTargetRenderer(this._scene, camera);\n            this.targetRenderers.push(targetRenderer);\n        }\n        if (!targetRenderer._onUseVelocityChanged.hasObservers()) {\n            targetRenderer._onUseVelocityChanged.add(this._setUseVelocityForRenderObject.bind(this));\n        }\n        if (generateDiffuseTexture !== undefined) {\n            targetRenderer.generateDiffuseTexture = generateDiffuseTexture;\n        }\n        const renderObject = { object, targetRenderer };\n        this.renderObjects.push(renderObject);\n        this._sortRenderingObjects();\n        this._setParticleSizeForRenderTargets();\n        return renderObject;\n    }\n    /**\n     * Adds a custom particle set to the fluid renderer.\n     * @param buffers The list of buffers (should contain at least a \"position\" buffer!)\n     * @param numParticles Number of particles in each buffer\n     * @param generateDiffuseTexture True if you want to generate a diffuse texture from buffers and use it as part of the fluid rendering (default: false). For the texture to be generated correctly, you need a \"color\" buffer in the set!\n     * @param targetRenderer The target renderer used to display the particle system as a fluid. If not provided, the method will create a new one\n     * @param camera The camera used by the target renderer (if the target renderer is created by the method)\n     * @returns the render object corresponding to the custom particle set\n     */\n    addCustomParticles(buffers, numParticles, generateDiffuseTexture, targetRenderer, camera) {\n        const object = new FluidRenderingObjectCustomParticles(this._scene, buffers, numParticles);\n        object.onParticleSizeChanged.add(this._setParticleSizeForRenderTargets.bind(this));\n        if (!targetRenderer) {\n            targetRenderer = new FluidRenderingTargetRenderer(this._scene, camera);\n            this.targetRenderers.push(targetRenderer);\n        }\n        if (!targetRenderer._onUseVelocityChanged.hasObservers()) {\n            targetRenderer._onUseVelocityChanged.add(this._setUseVelocityForRenderObject.bind(this));\n        }\n        if (generateDiffuseTexture !== undefined) {\n            targetRenderer.generateDiffuseTexture = generateDiffuseTexture;\n        }\n        const renderObject = { object, targetRenderer };\n        this.renderObjects.push(renderObject);\n        this._sortRenderingObjects();\n        this._setParticleSizeForRenderTargets();\n        return renderObject;\n    }\n    /**\n     * Removes a render object from the fluid renderer\n     * @param renderObject the render object to remove\n     * @param removeUnusedTargetRenderer True to remove/dispose of the target renderer if it's not used anymore (default: true)\n     * @returns True if the render object has been found and released, else false\n     */\n    removeRenderObject(renderObject, removeUnusedTargetRenderer = true) {\n        const index = this.renderObjects.indexOf(renderObject);\n        if (index === -1) {\n            return false;\n        }\n        renderObject.object.dispose();\n        this.renderObjects.splice(index, 1);\n        if (removeUnusedTargetRenderer && this._removeUnusedTargetRenderers()) {\n            this._initialize();\n        }\n        else {\n            this._setParticleSizeForRenderTargets();\n        }\n        return true;\n    }\n    _sortRenderingObjects() {\n        this.renderObjects.sort((a, b) => {\n            return a.object.priority < b.object.priority ? -1 : a.object.priority > b.object.priority ? 1 : 0;\n        });\n    }\n    _removeUnusedTargetRenderers() {\n        const indexes = {};\n        for (let i = 0; i < this.renderObjects.length; ++i) {\n            const targetRenderer = this.renderObjects[i].targetRenderer;\n            indexes[this.targetRenderers.indexOf(targetRenderer)] = true;\n        }\n        let removed = false;\n        const newList = [];\n        for (let i = 0; i < this.targetRenderers.length; ++i) {\n            if (!indexes[i]) {\n                this.targetRenderers[i].dispose();\n                removed = true;\n            }\n            else {\n                newList.push(this.targetRenderers[i]);\n            }\n        }\n        if (removed) {\n            this.targetRenderers.length = 0;\n            this.targetRenderers.push(...newList);\n        }\n        return removed;\n    }\n    _getParticleSystemIndex(ps) {\n        for (let i = 0; i < this.renderObjects.length; ++i) {\n            const obj = this.renderObjects[i].object;\n            if (IsParticleSystemObject(obj) && obj.particleSystem === ps) {\n                return i;\n            }\n        }\n        return -1;\n    }\n    _initialize() {\n        for (let i = 0; i < this.targetRenderers.length; ++i) {\n            this.targetRenderers[i].dispose();\n        }\n        const cameras = new Map();\n        for (let i = 0; i < this.targetRenderers.length; ++i) {\n            const targetRenderer = this.targetRenderers[i];\n            targetRenderer._initialize();\n            if (targetRenderer.camera && targetRenderer._renderPostProcess) {\n                let list = cameras.get(targetRenderer.camera);\n                if (!list) {\n                    list = [[], {}];\n                    cameras.set(targetRenderer.camera, list);\n                }\n                list[0].push(targetRenderer);\n                targetRenderer.camera.attachPostProcess(targetRenderer._renderPostProcess, i);\n            }\n        }\n        let iterator = cameras.keys();\n        for (let key = iterator.next(); key.done !== true; key = iterator.next()) {\n            const camera = key.value;\n            const list = cameras.get(camera);\n            const firstPostProcess = camera._getFirstPostProcess();\n            if (!firstPostProcess) {\n                continue;\n            }\n            const [targetRenderers, copyDepthTextures] = list;\n            firstPostProcess.onSizeChangedObservable.add(() => {\n                var _a;\n                if (!firstPostProcess.inputTexture.depthStencilTexture) {\n                    firstPostProcess.inputTexture.createDepthStencilTexture(0, true, this._engine.isStencilEnable, targetRenderers[0].samples);\n                }\n                for (const targetRenderer of targetRenderers) {\n                    const thicknessRT = (_a = targetRenderer._thicknessRenderTarget) === null || _a === void 0 ? void 0 : _a.renderTarget;\n                    const thicknessTexture = thicknessRT === null || thicknessRT === void 0 ? void 0 : thicknessRT.texture;\n                    if (thicknessRT && thicknessTexture) {\n                        const key = thicknessTexture.width + \"_\" + thicknessTexture.height;\n                        let copyDepthTexture = copyDepthTextures[key];\n                        if (!copyDepthTexture) {\n                            copyDepthTexture = copyDepthTextures[key] = new FluidRenderingDepthTextureCopy(this._engine, thicknessTexture.width, thicknessTexture.height);\n                        }\n                        copyDepthTexture.depthRTWrapper._shareDepth(thicknessRT);\n                    }\n                }\n            });\n        }\n        // Dispose the CopyDepthTexture instances that we don't need anymore\n        iterator = this._cameras.keys();\n        for (let key = iterator.next(); key.done !== true; key = iterator.next()) {\n            const camera = key.value;\n            const list = this._cameras.get(camera);\n            const copyDepthTextures = list[1];\n            const list2 = cameras.get(camera);\n            if (!list2) {\n                for (const key in copyDepthTextures) {\n                    copyDepthTextures[key].dispose();\n                }\n            }\n            else {\n                for (const key in copyDepthTextures) {\n                    if (!list2[1][key]) {\n                        copyDepthTextures[key].dispose();\n                    }\n                }\n            }\n        }\n        this._cameras.clear();\n        this._cameras = cameras;\n        this._setParticleSizeForRenderTargets();\n    }\n    _setParticleSizeForRenderTargets() {\n        const particleSizes = new Map();\n        for (let i = 0; i < this.renderObjects.length; ++i) {\n            const renderingObject = this.renderObjects[i];\n            let curSize = particleSizes.get(renderingObject.targetRenderer);\n            if (curSize === undefined) {\n                curSize = 0;\n            }\n            particleSizes.set(renderingObject.targetRenderer, Math.max(curSize, renderingObject.object.particleSize));\n        }\n        particleSizes.forEach((particleSize, targetRenderer) => {\n            if (targetRenderer._depthRenderTarget) {\n                targetRenderer._depthRenderTarget.particleSize = particleSize;\n            }\n        });\n    }\n    _setUseVelocityForRenderObject() {\n        for (const renderingObject of this.renderObjects) {\n            renderingObject.object.useVelocity = renderingObject.targetRenderer.useVelocity;\n        }\n    }\n    /** @internal */\n    _prepareRendering() {\n        for (const renderer of this.targetRenderers) {\n            if (renderer.needInitialization) {\n                this._initialize();\n                return;\n            }\n        }\n    }\n    /** @internal */\n    _render(forCamera) {\n        var _a;\n        for (let i = 0; i < this.targetRenderers.length; ++i) {\n            if (!forCamera || this.targetRenderers[i].camera === forCamera) {\n                this.targetRenderers[i]._clearTargets();\n            }\n        }\n        const iterator = this._cameras.keys();\n        for (let key = iterator.next(); key.done !== true; key = iterator.next()) {\n            const camera = key.value;\n            const list = this._cameras.get(camera);\n            if (forCamera && camera !== forCamera) {\n                continue;\n            }\n            const firstPostProcess = camera._getFirstPostProcess();\n            if (!firstPostProcess) {\n                continue;\n            }\n            const sourceCopyDepth = (_a = firstPostProcess.inputTexture) === null || _a === void 0 ? void 0 : _a.depthStencilTexture;\n            if (sourceCopyDepth) {\n                const [targetRenderers, copyDepthTextures] = list;\n                for (const targetRenderer of targetRenderers) {\n                    targetRenderer._bgDepthTexture = sourceCopyDepth;\n                }\n                for (const key in copyDepthTextures) {\n                    copyDepthTextures[key].copy(sourceCopyDepth);\n                }\n            }\n        }\n        for (let i = 0; i < this.renderObjects.length; ++i) {\n            const renderingObject = this.renderObjects[i];\n            if (!forCamera || renderingObject.targetRenderer.camera === forCamera) {\n                renderingObject.targetRenderer._render(renderingObject.object);\n            }\n        }\n    }\n    /**\n     * Disposes of all the ressources used by the class\n     */\n    dispose() {\n        this._engine.onResizeObservable.remove(this._onEngineResizeObserver);\n        this._onEngineResizeObserver = null;\n        for (let i = 0; i < this.renderObjects.length; ++i) {\n            this.renderObjects[i].object.dispose();\n        }\n        for (let i = 0; i < this.targetRenderers.length; ++i) {\n            this.targetRenderers[i].dispose();\n        }\n        this._cameras.forEach((list) => {\n            const copyDepthTextures = list[1];\n            for (const key in copyDepthTextures) {\n                copyDepthTextures[key].dispose();\n            }\n        });\n        this.renderObjects = [];\n        this.targetRenderers = [];\n        this._cameras.clear();\n    }\n}\n//# sourceMappingURL=fluidRenderer.js.map","export * from \"./fluidRenderer.js\";\nexport * from \"./fluidRenderingObject.js\";\nexport * from \"./fluidRenderingObjectParticleSystem.js\";\nexport * from \"./fluidRenderingObjectCustomParticles.js\";\nexport * from \"./fluidRenderingTargetRenderer.js\";\n//# sourceMappingURL=index.js.map","/* eslint-disable import/no-internal-modules */\nexport * from \"./boundingBoxRenderer.js\";\nexport * from \"./depthRenderer.js\";\nexport * from \"./depthRendererSceneComponent.js\";\nexport * from \"./depthPeelingRenderer.js\";\nexport * from \"./depthPeelingSceneComponent.js\";\nexport * from \"./edgesRenderer.js\";\nexport * from \"./geometryBufferRenderer.js\";\nexport * from \"./geometryBufferRendererSceneComponent.js\";\nexport * from \"./prePassRenderer.js\";\nexport * from \"./prePassRendererSceneComponent.js\";\nexport * from \"./subSurfaceSceneComponent.js\";\nexport * from \"./outlineRenderer.js\";\nexport * from \"./renderingGroup.js\";\nexport * from \"./renderingManager.js\";\nexport * from \"./utilityLayerRenderer.js\";\nexport * from \"./fluidRenderer/index.js\";\n//# sourceMappingURL=index.js.map","\n/**\n * Contains all parameters needed for the prepass to perform\n * motion blur\n */\nexport class MotionBlurConfiguration {\n    constructor() {\n        /**\n         * Is motion blur enabled\n         */\n        this.enabled = false;\n        /**\n         * Name of the configuration\n         */\n        this.name = \"motionBlur\";\n        /**\n         * Textures that should be present in the MRT for this effect to work\n         */\n        this.texturesRequired = [2];\n    }\n}\n//# sourceMappingURL=motionBlurConfiguration.js.map","import { SmartArray, SmartArrayNoDuplicate } from \"../Misc/smartArray.js\";\nimport { Vector3 } from \"../Maths/math.vector.js\";\n\n/**\n * This represents the object necessary to create a rendering group.\n * This is exclusively used and created by the rendering manager.\n * To modify the behavior, you use the available helpers in your scene or meshes.\n * @internal\n */\nexport class RenderingGroup {\n    /**\n     * Set the opaque sort comparison function.\n     * If null the sub meshes will be render in the order they were created\n     */\n    set opaqueSortCompareFn(value) {\n        if (value) {\n            this._opaqueSortCompareFn = value;\n        }\n        else {\n            this._opaqueSortCompareFn = RenderingGroup.PainterSortCompare;\n        }\n        this._renderOpaque = this._renderOpaqueSorted;\n    }\n    /**\n     * Set the alpha test sort comparison function.\n     * If null the sub meshes will be render in the order they were created\n     */\n    set alphaTestSortCompareFn(value) {\n        if (value) {\n            this._alphaTestSortCompareFn = value;\n        }\n        else {\n            this._alphaTestSortCompareFn = RenderingGroup.PainterSortCompare;\n        }\n        this._renderAlphaTest = this._renderAlphaTestSorted;\n    }\n    /**\n     * Set the transparent sort comparison function.\n     * If null the sub meshes will be render in the order they were created\n     */\n    set transparentSortCompareFn(value) {\n        if (value) {\n            this._transparentSortCompareFn = value;\n        }\n        else {\n            this._transparentSortCompareFn = RenderingGroup.defaultTransparentSortCompare;\n        }\n        this._renderTransparent = this._renderTransparentSorted;\n    }\n    /**\n     * Creates a new rendering group.\n     * @param index The rendering group index\n     * @param scene\n     * @param opaqueSortCompareFn The opaque sort comparison function. If null no order is applied\n     * @param alphaTestSortCompareFn The alpha test sort comparison function. If null no order is applied\n     * @param transparentSortCompareFn The transparent sort comparison function. If null back to front + alpha index sort is applied\n     */\n    constructor(index, scene, opaqueSortCompareFn = null, alphaTestSortCompareFn = null, transparentSortCompareFn = null) {\n        this.index = index;\n        this._opaqueSubMeshes = new SmartArray(256);\n        this._transparentSubMeshes = new SmartArray(256);\n        this._alphaTestSubMeshes = new SmartArray(256);\n        this._depthOnlySubMeshes = new SmartArray(256);\n        this._particleSystems = new SmartArray(256);\n        this._spriteManagers = new SmartArray(256);\n        /** @internal */\n        this._empty = true;\n        /** @internal */\n        this._edgesRenderers = new SmartArrayNoDuplicate(16);\n        this._scene = scene;\n        this.opaqueSortCompareFn = opaqueSortCompareFn;\n        this.alphaTestSortCompareFn = alphaTestSortCompareFn;\n        this.transparentSortCompareFn = transparentSortCompareFn;\n    }\n    /**\n     * Render all the sub meshes contained in the group.\n     * @param customRenderFunction Used to override the default render behaviour of the group.\n     * @param renderSprites\n     * @param renderParticles\n     * @param activeMeshes\n     * @returns true if rendered some submeshes.\n     */\n    render(customRenderFunction, renderSprites, renderParticles, activeMeshes) {\n        if (customRenderFunction) {\n            customRenderFunction(this._opaqueSubMeshes, this._alphaTestSubMeshes, this._transparentSubMeshes, this._depthOnlySubMeshes);\n            return;\n        }\n        const engine = this._scene.getEngine();\n        // Depth only\n        if (this._depthOnlySubMeshes.length !== 0) {\n            engine.setColorWrite(false);\n            this._renderAlphaTest(this._depthOnlySubMeshes);\n            engine.setColorWrite(true);\n        }\n        // Opaque\n        if (this._opaqueSubMeshes.length !== 0) {\n            this._renderOpaque(this._opaqueSubMeshes);\n        }\n        // Alpha test\n        if (this._alphaTestSubMeshes.length !== 0) {\n            this._renderAlphaTest(this._alphaTestSubMeshes);\n        }\n        const stencilState = engine.getStencilBuffer();\n        engine.setStencilBuffer(false);\n        // Sprites\n        if (renderSprites) {\n            this._renderSprites();\n        }\n        // Particles\n        if (renderParticles) {\n            this._renderParticles(activeMeshes);\n        }\n        if (this.onBeforeTransparentRendering) {\n            this.onBeforeTransparentRendering();\n        }\n        // Transparent\n        if (this._transparentSubMeshes.length !== 0 || this._scene.useOrderIndependentTransparency) {\n            engine.setStencilBuffer(stencilState);\n            if (this._scene.useOrderIndependentTransparency) {\n                const excludedMeshes = this._scene.depthPeelingRenderer.render(this._transparentSubMeshes);\n                if (excludedMeshes.length) {\n                    // Render leftover meshes that could not be processed by depth peeling\n                    this._renderTransparent(excludedMeshes);\n                }\n            }\n            else {\n                this._renderTransparent(this._transparentSubMeshes);\n            }\n            engine.setAlphaMode(0);\n        }\n        // Set back stencil to false in case it changes before the edge renderer.\n        engine.setStencilBuffer(false);\n        // Edges\n        if (this._edgesRenderers.length) {\n            for (let edgesRendererIndex = 0; edgesRendererIndex < this._edgesRenderers.length; edgesRendererIndex++) {\n                this._edgesRenderers.data[edgesRendererIndex].render();\n            }\n            engine.setAlphaMode(0);\n        }\n        // Restore Stencil state.\n        engine.setStencilBuffer(stencilState);\n    }\n    /**\n     * Renders the opaque submeshes in the order from the opaqueSortCompareFn.\n     * @param subMeshes The submeshes to render\n     */\n    _renderOpaqueSorted(subMeshes) {\n        return RenderingGroup._RenderSorted(subMeshes, this._opaqueSortCompareFn, this._scene.activeCamera, false);\n    }\n    /**\n     * Renders the opaque submeshes in the order from the alphatestSortCompareFn.\n     * @param subMeshes The submeshes to render\n     */\n    _renderAlphaTestSorted(subMeshes) {\n        return RenderingGroup._RenderSorted(subMeshes, this._alphaTestSortCompareFn, this._scene.activeCamera, false);\n    }\n    /**\n     * Renders the opaque submeshes in the order from the transparentSortCompareFn.\n     * @param subMeshes The submeshes to render\n     */\n    _renderTransparentSorted(subMeshes) {\n        return RenderingGroup._RenderSorted(subMeshes, this._transparentSortCompareFn, this._scene.activeCamera, true);\n    }\n    /**\n     * Renders the submeshes in a specified order.\n     * @param subMeshes The submeshes to sort before render\n     * @param sortCompareFn The comparison function use to sort\n     * @param camera The camera position use to preprocess the submeshes to help sorting\n     * @param transparent Specifies to activate blending if true\n     */\n    static _RenderSorted(subMeshes, sortCompareFn, camera, transparent) {\n        let subIndex = 0;\n        let subMesh;\n        const cameraPosition = camera ? camera.globalPosition : RenderingGroup._ZeroVector;\n        if (transparent) {\n            for (; subIndex < subMeshes.length; subIndex++) {\n                subMesh = subMeshes.data[subIndex];\n                subMesh._alphaIndex = subMesh.getMesh().alphaIndex;\n                subMesh._distanceToCamera = Vector3.Distance(subMesh.getBoundingInfo().boundingSphere.centerWorld, cameraPosition);\n            }\n        }\n        const sortedArray = subMeshes.length === subMeshes.data.length ? subMeshes.data : subMeshes.data.slice(0, subMeshes.length);\n        if (sortCompareFn) {\n            sortedArray.sort(sortCompareFn);\n        }\n        const scene = sortedArray[0].getMesh().getScene();\n        for (subIndex = 0; subIndex < sortedArray.length; subIndex++) {\n            subMesh = sortedArray[subIndex];\n            if (scene._activeMeshesFrozenButKeepClipping && !subMesh.isInFrustum(scene._frustumPlanes)) {\n                continue;\n            }\n            if (transparent) {\n                const material = subMesh.getMaterial();\n                if (material && material.needDepthPrePass) {\n                    const engine = material.getScene().getEngine();\n                    engine.setColorWrite(false);\n                    engine.setAlphaMode(0);\n                    subMesh.render(false);\n                    engine.setColorWrite(true);\n                }\n            }\n            subMesh.render(transparent);\n        }\n    }\n    /**\n     * Build in function which can be applied to ensure meshes of a special queue (opaque, alpha test, transparent)\n     * are rendered back to front if in the same alpha index.\n     *\n     * @param a The first submesh\n     * @param b The second submesh\n     * @returns The result of the comparison\n     */\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    static defaultTransparentSortCompare(a, b) {\n        // Alpha index first\n        if (a._alphaIndex > b._alphaIndex) {\n            return 1;\n        }\n        if (a._alphaIndex < b._alphaIndex) {\n            return -1;\n        }\n        // Then distance to camera\n        return RenderingGroup.backToFrontSortCompare(a, b);\n    }\n    /**\n     * Build in function which can be applied to ensure meshes of a special queue (opaque, alpha test, transparent)\n     * are rendered back to front.\n     *\n     * @param a The first submesh\n     * @param b The second submesh\n     * @returns The result of the comparison\n     */\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    static backToFrontSortCompare(a, b) {\n        // Then distance to camera\n        if (a._distanceToCamera < b._distanceToCamera) {\n            return 1;\n        }\n        if (a._distanceToCamera > b._distanceToCamera) {\n            return -1;\n        }\n        return 0;\n    }\n    /**\n     * Build in function which can be applied to ensure meshes of a special queue (opaque, alpha test, transparent)\n     * are rendered front to back (prevent overdraw).\n     *\n     * @param a The first submesh\n     * @param b The second submesh\n     * @returns The result of the comparison\n     */\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    static frontToBackSortCompare(a, b) {\n        // Then distance to camera\n        if (a._distanceToCamera < b._distanceToCamera) {\n            return -1;\n        }\n        if (a._distanceToCamera > b._distanceToCamera) {\n            return 1;\n        }\n        return 0;\n    }\n    /**\n     * Build in function which can be applied to ensure meshes of a special queue (opaque, alpha test, transparent)\n     * are grouped by material then geometry.\n     *\n     * @param a The first submesh\n     * @param b The second submesh\n     * @returns The result of the comparison\n     */\n    static PainterSortCompare(a, b) {\n        const meshA = a.getMesh();\n        const meshB = b.getMesh();\n        if (meshA.material && meshB.material) {\n            return meshA.material.uniqueId - meshB.material.uniqueId;\n        }\n        return meshA.uniqueId - meshB.uniqueId;\n    }\n    /**\n     * Resets the different lists of submeshes to prepare a new frame.\n     */\n    prepare() {\n        this._opaqueSubMeshes.reset();\n        this._transparentSubMeshes.reset();\n        this._alphaTestSubMeshes.reset();\n        this._depthOnlySubMeshes.reset();\n        this._particleSystems.reset();\n        this.prepareSprites();\n        this._edgesRenderers.reset();\n        this._empty = true;\n    }\n    /**\n     * Resets the different lists of sprites to prepare a new frame.\n     */\n    prepareSprites() {\n        this._spriteManagers.reset();\n    }\n    dispose() {\n        this._opaqueSubMeshes.dispose();\n        this._transparentSubMeshes.dispose();\n        this._alphaTestSubMeshes.dispose();\n        this._depthOnlySubMeshes.dispose();\n        this._particleSystems.dispose();\n        this._spriteManagers.dispose();\n        this._edgesRenderers.dispose();\n    }\n    /**\n     * Inserts the submesh in its correct queue depending on its material.\n     * @param subMesh The submesh to dispatch\n     * @param [mesh] Optional reference to the submeshes's mesh. Provide if you have an exiting reference to improve performance.\n     * @param [material] Optional reference to the submeshes's material. Provide if you have an exiting reference to improve performance.\n     */\n    dispatch(subMesh, mesh, material) {\n        // Get mesh and materials if not provided\n        if (mesh === undefined) {\n            mesh = subMesh.getMesh();\n        }\n        if (material === undefined) {\n            material = subMesh.getMaterial();\n        }\n        if (material === null || material === undefined) {\n            return;\n        }\n        if (material.needAlphaBlendingForMesh(mesh)) {\n            // Transparent\n            this._transparentSubMeshes.push(subMesh);\n        }\n        else if (material.needAlphaTesting()) {\n            // Alpha test\n            if (material.needDepthPrePass) {\n                this._depthOnlySubMeshes.push(subMesh);\n            }\n            this._alphaTestSubMeshes.push(subMesh);\n        }\n        else {\n            if (material.needDepthPrePass) {\n                this._depthOnlySubMeshes.push(subMesh);\n            }\n            this._opaqueSubMeshes.push(subMesh); // Opaque\n        }\n        mesh._renderingGroup = this;\n        if (mesh._edgesRenderer && mesh._edgesRenderer.isEnabled) {\n            this._edgesRenderers.pushNoDuplicate(mesh._edgesRenderer);\n        }\n        this._empty = false;\n    }\n    dispatchSprites(spriteManager) {\n        this._spriteManagers.push(spriteManager);\n        this._empty = false;\n    }\n    dispatchParticles(particleSystem) {\n        this._particleSystems.push(particleSystem);\n        this._empty = false;\n    }\n    _renderParticles(activeMeshes) {\n        if (this._particleSystems.length === 0) {\n            return;\n        }\n        // Particles\n        const activeCamera = this._scene.activeCamera;\n        this._scene.onBeforeParticlesRenderingObservable.notifyObservers(this._scene);\n        for (let particleIndex = 0; particleIndex < this._particleSystems.length; particleIndex++) {\n            const particleSystem = this._particleSystems.data[particleIndex];\n            if ((activeCamera && activeCamera.layerMask & particleSystem.layerMask) === 0) {\n                continue;\n            }\n            const emitter = particleSystem.emitter;\n            if (!emitter.position || !activeMeshes || activeMeshes.indexOf(emitter) !== -1) {\n                this._scene._activeParticles.addCount(particleSystem.render(), false);\n            }\n        }\n        this._scene.onAfterParticlesRenderingObservable.notifyObservers(this._scene);\n    }\n    _renderSprites() {\n        if (!this._scene.spritesEnabled || this._spriteManagers.length === 0) {\n            return;\n        }\n        // Sprites\n        const activeCamera = this._scene.activeCamera;\n        this._scene.onBeforeSpritesRenderingObservable.notifyObservers(this._scene);\n        for (let id = 0; id < this._spriteManagers.length; id++) {\n            const spriteManager = this._spriteManagers.data[id];\n            if ((activeCamera && activeCamera.layerMask & spriteManager.layerMask) !== 0) {\n                spriteManager.render();\n            }\n        }\n        this._scene.onAfterSpritesRenderingObservable.notifyObservers(this._scene);\n    }\n}\nRenderingGroup._ZeroVector = Vector3.Zero();\n//# sourceMappingURL=renderingGroup.js.map","import { RenderingGroup } from \"./renderingGroup.js\";\n/**\n * This class is used by the onRenderingGroupObservable\n */\nexport class RenderingGroupInfo {\n}\n/**\n * This is the manager responsible of all the rendering for meshes sprites and particles.\n * It is enable to manage the different groups as well as the different necessary sort functions.\n * This should not be used directly aside of the few static configurations\n */\nexport class RenderingManager {\n    /**\n     * Gets or sets a boolean indicating that the manager will not reset between frames.\n     * This means that if a mesh becomes invisible or transparent it will not be visible until this boolean is set to false again.\n     * By default, the rendering manager will dispatch all active meshes per frame (moving them to the transparent, opaque or alpha testing lists).\n     * By turning this property on, you will accelerate the rendering by keeping all these lists unchanged between frames.\n     */\n    get maintainStateBetweenFrames() {\n        return this._maintainStateBetweenFrames;\n    }\n    set maintainStateBetweenFrames(value) {\n        if (value === this._maintainStateBetweenFrames) {\n            return;\n        }\n        this._maintainStateBetweenFrames = value;\n        // Restore wasDispatched flags when switching to maintainStateBetweenFrames to false\n        if (!this._maintainStateBetweenFrames) {\n            for (const mesh of this._scene.meshes) {\n                if (mesh.subMeshes) {\n                    for (const subMesh of mesh.subMeshes) {\n                        subMesh._wasDispatched = false;\n                    }\n                }\n            }\n            for (const spriteManager of this._scene.spriteManagers) {\n                spriteManager._wasDispatched = false;\n            }\n            for (const particleSystem of this._scene.particleSystems) {\n                particleSystem._wasDispatched = false;\n            }\n        }\n    }\n    /**\n     * Instantiates a new rendering group for a particular scene\n     * @param scene Defines the scene the groups belongs to\n     */\n    constructor(scene) {\n        /**\n         * @internal\n         */\n        this._useSceneAutoClearSetup = false;\n        this._renderingGroups = new Array();\n        this._autoClearDepthStencil = {};\n        this._customOpaqueSortCompareFn = {};\n        this._customAlphaTestSortCompareFn = {};\n        this._customTransparentSortCompareFn = {};\n        this._renderingGroupInfo = new RenderingGroupInfo();\n        this._maintainStateBetweenFrames = false;\n        this._scene = scene;\n        for (let i = RenderingManager.MIN_RENDERINGGROUPS; i < RenderingManager.MAX_RENDERINGGROUPS; i++) {\n            this._autoClearDepthStencil[i] = { autoClear: true, depth: true, stencil: true };\n        }\n    }\n    /**\n     * Gets the rendering group with the specified id.\n     */\n    getRenderingGroup(id) {\n        const renderingGroupId = id || 0;\n        this._prepareRenderingGroup(renderingGroupId);\n        return this._renderingGroups[renderingGroupId];\n    }\n    _clearDepthStencilBuffer(depth = true, stencil = true) {\n        if (this._depthStencilBufferAlreadyCleaned) {\n            return;\n        }\n        this._scene.getEngine().clear(null, false, depth, stencil);\n        this._depthStencilBufferAlreadyCleaned = true;\n    }\n    /**\n     * Renders the entire managed groups. This is used by the scene or the different render targets.\n     * @internal\n     */\n    render(customRenderFunction, activeMeshes, renderParticles, renderSprites) {\n        // Update the observable context (not null as it only goes away on dispose)\n        const info = this._renderingGroupInfo;\n        info.scene = this._scene;\n        info.camera = this._scene.activeCamera;\n        // Dispatch sprites\n        if (this._scene.spriteManagers && renderSprites) {\n            for (let index = 0; index < this._scene.spriteManagers.length; index++) {\n                const manager = this._scene.spriteManagers[index];\n                this.dispatchSprites(manager);\n            }\n        }\n        // Render\n        for (let index = RenderingManager.MIN_RENDERINGGROUPS; index < RenderingManager.MAX_RENDERINGGROUPS; index++) {\n            this._depthStencilBufferAlreadyCleaned = index === RenderingManager.MIN_RENDERINGGROUPS;\n            const renderingGroup = this._renderingGroups[index];\n            if (!renderingGroup || renderingGroup._empty) {\n                continue;\n            }\n            const renderingGroupMask = Math.pow(2, index);\n            info.renderingGroupId = index;\n            // Before Observable\n            this._scene.onBeforeRenderingGroupObservable.notifyObservers(info, renderingGroupMask);\n            // Clear depth/stencil if needed\n            if (RenderingManager.AUTOCLEAR) {\n                const autoClear = this._useSceneAutoClearSetup ? this._scene.getAutoClearDepthStencilSetup(index) : this._autoClearDepthStencil[index];\n                if (autoClear && autoClear.autoClear) {\n                    this._clearDepthStencilBuffer(autoClear.depth, autoClear.stencil);\n                }\n            }\n            // Render\n            for (const step of this._scene._beforeRenderingGroupDrawStage) {\n                step.action(index);\n            }\n            renderingGroup.render(customRenderFunction, renderSprites, renderParticles, activeMeshes);\n            for (const step of this._scene._afterRenderingGroupDrawStage) {\n                step.action(index);\n            }\n            // After Observable\n            this._scene.onAfterRenderingGroupObservable.notifyObservers(info, renderingGroupMask);\n        }\n    }\n    /**\n     * Resets the different information of the group to prepare a new frame\n     * @internal\n     */\n    reset() {\n        if (this.maintainStateBetweenFrames) {\n            return;\n        }\n        for (let index = RenderingManager.MIN_RENDERINGGROUPS; index < RenderingManager.MAX_RENDERINGGROUPS; index++) {\n            const renderingGroup = this._renderingGroups[index];\n            if (renderingGroup) {\n                renderingGroup.prepare();\n            }\n        }\n    }\n    /**\n     * Resets the sprites information of the group to prepare a new frame\n     * @internal\n     */\n    resetSprites() {\n        if (this.maintainStateBetweenFrames) {\n            return;\n        }\n        for (let index = RenderingManager.MIN_RENDERINGGROUPS; index < RenderingManager.MAX_RENDERINGGROUPS; index++) {\n            const renderingGroup = this._renderingGroups[index];\n            if (renderingGroup) {\n                renderingGroup.prepareSprites();\n            }\n        }\n    }\n    /**\n     * Dispose and release the group and its associated resources.\n     * @internal\n     */\n    dispose() {\n        this.freeRenderingGroups();\n        this._renderingGroups.length = 0;\n        this._renderingGroupInfo = null;\n    }\n    /**\n     * Clear the info related to rendering groups preventing retention points during dispose.\n     */\n    freeRenderingGroups() {\n        for (let index = RenderingManager.MIN_RENDERINGGROUPS; index < RenderingManager.MAX_RENDERINGGROUPS; index++) {\n            const renderingGroup = this._renderingGroups[index];\n            if (renderingGroup) {\n                renderingGroup.dispose();\n            }\n        }\n    }\n    _prepareRenderingGroup(renderingGroupId) {\n        if (this._renderingGroups[renderingGroupId] === undefined) {\n            this._renderingGroups[renderingGroupId] = new RenderingGroup(renderingGroupId, this._scene, this._customOpaqueSortCompareFn[renderingGroupId], this._customAlphaTestSortCompareFn[renderingGroupId], this._customTransparentSortCompareFn[renderingGroupId]);\n        }\n    }\n    /**\n     * Add a sprite manager to the rendering manager in order to render it this frame.\n     * @param spriteManager Define the sprite manager to render\n     */\n    dispatchSprites(spriteManager) {\n        if (this.maintainStateBetweenFrames && spriteManager._wasDispatched) {\n            return;\n        }\n        spriteManager._wasDispatched = true;\n        this.getRenderingGroup(spriteManager.renderingGroupId).dispatchSprites(spriteManager);\n    }\n    /**\n     * Add a particle system to the rendering manager in order to render it this frame.\n     * @param particleSystem Define the particle system to render\n     */\n    dispatchParticles(particleSystem) {\n        if (this.maintainStateBetweenFrames && particleSystem._wasDispatched) {\n            return;\n        }\n        particleSystem._wasDispatched = true;\n        this.getRenderingGroup(particleSystem.renderingGroupId).dispatchParticles(particleSystem);\n    }\n    /**\n     * Add a submesh to the manager in order to render it this frame\n     * @param subMesh The submesh to dispatch\n     * @param mesh Optional reference to the submeshes's mesh. Provide if you have an exiting reference to improve performance.\n     * @param material Optional reference to the submeshes's material. Provide if you have an exiting reference to improve performance.\n     */\n    dispatch(subMesh, mesh, material) {\n        if (mesh === undefined) {\n            mesh = subMesh.getMesh();\n        }\n        if (this.maintainStateBetweenFrames && subMesh._wasDispatched) {\n            return;\n        }\n        subMesh._wasDispatched = true;\n        this.getRenderingGroup(mesh.renderingGroupId).dispatch(subMesh, mesh, material);\n    }\n    /**\n     * Overrides the default sort function applied in the rendering group to prepare the meshes.\n     * This allowed control for front to back rendering or reversely depending of the special needs.\n     *\n     * @param renderingGroupId The rendering group id corresponding to its index\n     * @param opaqueSortCompareFn The opaque queue comparison function use to sort.\n     * @param alphaTestSortCompareFn The alpha test queue comparison function use to sort.\n     * @param transparentSortCompareFn The transparent queue comparison function use to sort.\n     */\n    setRenderingOrder(renderingGroupId, opaqueSortCompareFn = null, alphaTestSortCompareFn = null, transparentSortCompareFn = null) {\n        this._customOpaqueSortCompareFn[renderingGroupId] = opaqueSortCompareFn;\n        this._customAlphaTestSortCompareFn[renderingGroupId] = alphaTestSortCompareFn;\n        this._customTransparentSortCompareFn[renderingGroupId] = transparentSortCompareFn;\n        if (this._renderingGroups[renderingGroupId]) {\n            const group = this._renderingGroups[renderingGroupId];\n            group.opaqueSortCompareFn = this._customOpaqueSortCompareFn[renderingGroupId];\n            group.alphaTestSortCompareFn = this._customAlphaTestSortCompareFn[renderingGroupId];\n            group.transparentSortCompareFn = this._customTransparentSortCompareFn[renderingGroupId];\n        }\n    }\n    /**\n     * Specifies whether or not the stencil and depth buffer are cleared between two rendering groups.\n     *\n     * @param renderingGroupId The rendering group id corresponding to its index\n     * @param autoClearDepthStencil Automatically clears depth and stencil between groups if true.\n     * @param depth Automatically clears depth between groups if true and autoClear is true.\n     * @param stencil Automatically clears stencil between groups if true and autoClear is true.\n     */\n    setRenderingAutoClearDepthStencil(renderingGroupId, autoClearDepthStencil, depth = true, stencil = true) {\n        this._autoClearDepthStencil[renderingGroupId] = {\n            autoClear: autoClearDepthStencil,\n            depth: depth,\n            stencil: stencil,\n        };\n    }\n    /**\n     * Gets the current auto clear configuration for one rendering group of the rendering\n     * manager.\n     * @param index the rendering group index to get the information for\n     * @returns The auto clear setup for the requested rendering group\n     */\n    getAutoClearDepthStencilSetup(index) {\n        return this._autoClearDepthStencil[index];\n    }\n}\n/**\n * The max id used for rendering groups (not included)\n */\nRenderingManager.MAX_RENDERINGGROUPS = 4;\n/**\n * The min id used for rendering groups (included)\n */\nRenderingManager.MIN_RENDERINGGROUPS = 0;\n/**\n * Used to globally prevent autoclearing scenes.\n */\nRenderingManager.AUTOCLEAR = true;\n//# sourceMappingURL=renderingManager.js.map","\n/**\n * Contains all parameters needed for the prepass to perform\n * screen space reflections\n */\nexport class ScreenSpaceReflections2Configuration {\n    constructor() {\n        /**\n         * Is ssr enabled\n         */\n        this.enabled = false;\n        /**\n         * Name of the configuration\n         */\n        this.name = \"screenSpaceReflections2\";\n        /**\n         * Textures that should be present in the MRT for this effect to work\n         */\n        this.texturesRequired = [6, 3, 5];\n    }\n}\n//# sourceMappingURL=screenSpaceReflections2Configuration.js.map","\n/**\n * Contains all parameters needed for the prepass to perform\n * screen space reflections\n */\nexport class ScreenSpaceReflectionsConfiguration {\n    constructor() {\n        /**\n         * Is ssr enabled\n         */\n        this.enabled = false;\n        /**\n         * Name of the configuration\n         */\n        this.name = \"screenSpaceReflections\";\n        /**\n         * Textures that should be present in the MRT for this effect to work\n         */\n        this.texturesRequired = [6, 3, 1];\n    }\n}\n//# sourceMappingURL=screenSpaceReflectionsConfiguration.js.map","\n/**\n * Contains all parameters needed for the prepass to perform\n * screen space subsurface scattering\n */\nexport class SSAO2Configuration {\n    constructor() {\n        /**\n         * Is subsurface enabled\n         */\n        this.enabled = false;\n        /**\n         * Name of the configuration\n         */\n        this.name = \"ssao2\";\n        /**\n         * Textures that should be present in the MRT for this effect to work\n         */\n        this.texturesRequired = [6, 5];\n    }\n}\n//# sourceMappingURL=ssao2Configuration.js.map","import { Scene } from \"../scene.js\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { PointerInfo, PointerEventTypes } from \"../Events/pointerEvents.js\";\nimport { PickingInfo } from \"../Collisions/pickingInfo.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\nimport { HemisphericLight } from \"../Lights/hemisphericLight.js\";\nimport { Vector3 } from \"../Maths/math.vector.js\";\nimport { Color3 } from \"../Maths/math.color.js\";\n/**\n * Renders a layer on top of an existing scene\n */\nexport class UtilityLayerRenderer {\n    /**\n     * Gets the camera that is used to render the utility layer (when not set, this will be the last active camera)\n     * @param getRigParentIfPossible if the current active camera is a rig camera, should its parent camera be returned\n     * @returns the camera that is used when rendering the utility layer\n     */\n    getRenderCamera(getRigParentIfPossible) {\n        if (this._renderCamera) {\n            return this._renderCamera;\n        }\n        else {\n            let activeCam;\n            if (this.originalScene.activeCameras && this.originalScene.activeCameras.length > 1) {\n                activeCam = this.originalScene.activeCameras[this.originalScene.activeCameras.length - 1];\n            }\n            else {\n                activeCam = this.originalScene.activeCamera;\n            }\n            if (getRigParentIfPossible && activeCam && activeCam.isRigCamera) {\n                return activeCam.rigParent;\n            }\n            return activeCam;\n        }\n    }\n    /**\n     * Sets the camera that should be used when rendering the utility layer (If set to null the last active camera will be used)\n     * @param cam the camera that should be used when rendering the utility layer\n     */\n    setRenderCamera(cam) {\n        this._renderCamera = cam;\n    }\n    /**\n     * @internal\n     * Light which used by gizmos to get light shading\n     */\n    _getSharedGizmoLight() {\n        if (!this._sharedGizmoLight) {\n            this._sharedGizmoLight = new HemisphericLight(\"shared gizmo light\", new Vector3(0, 1, 0), this.utilityLayerScene);\n            this._sharedGizmoLight.intensity = 2;\n            this._sharedGizmoLight.groundColor = Color3.Gray();\n        }\n        return this._sharedGizmoLight;\n    }\n    /**\n     * A shared utility layer that can be used to overlay objects into a scene (Depth map of the previous scene is cleared before drawing on top of it)\n     */\n    static get DefaultUtilityLayer() {\n        if (UtilityLayerRenderer._DefaultUtilityLayer == null) {\n            return UtilityLayerRenderer._CreateDefaultUtilityLayerFromScene(EngineStore.LastCreatedScene);\n        }\n        return UtilityLayerRenderer._DefaultUtilityLayer;\n    }\n    /**\n     * Creates an utility layer, and set it as a default utility layer\n     * @param scene associated scene\n     * @internal\n     */\n    static _CreateDefaultUtilityLayerFromScene(scene) {\n        UtilityLayerRenderer._DefaultUtilityLayer = new UtilityLayerRenderer(scene);\n        UtilityLayerRenderer._DefaultUtilityLayer.originalScene.onDisposeObservable.addOnce(() => {\n            UtilityLayerRenderer._DefaultUtilityLayer = null;\n        });\n        return UtilityLayerRenderer._DefaultUtilityLayer;\n    }\n    /**\n     * A shared utility layer that can be used to embed objects into a scene (Depth map of the previous scene is not cleared before drawing on top of it)\n     */\n    static get DefaultKeepDepthUtilityLayer() {\n        if (UtilityLayerRenderer._DefaultKeepDepthUtilityLayer == null) {\n            UtilityLayerRenderer._DefaultKeepDepthUtilityLayer = new UtilityLayerRenderer(EngineStore.LastCreatedScene);\n            UtilityLayerRenderer._DefaultKeepDepthUtilityLayer.utilityLayerScene.autoClearDepthAndStencil = false;\n            UtilityLayerRenderer._DefaultKeepDepthUtilityLayer.originalScene.onDisposeObservable.addOnce(() => {\n                UtilityLayerRenderer._DefaultKeepDepthUtilityLayer = null;\n            });\n        }\n        return UtilityLayerRenderer._DefaultKeepDepthUtilityLayer;\n    }\n    /**\n     * Instantiates a UtilityLayerRenderer\n     * @param originalScene the original scene that will be rendered on top of\n     * @param handleEvents boolean indicating if the utility layer should handle events\n     */\n    constructor(\n    /** the original scene that will be rendered on top of */\n    originalScene, handleEvents = true) {\n        this.originalScene = originalScene;\n        this._pointerCaptures = {};\n        this._lastPointerEvents = {};\n        this._sharedGizmoLight = null;\n        this._renderCamera = null;\n        /**\n         * If the picking should be done on the utility layer prior to the actual scene (Default: true)\n         */\n        this.pickUtilitySceneFirst = true;\n        /**\n         *  If the utility layer should automatically be rendered on top of existing scene\n         */\n        this.shouldRender = true;\n        /**\n         * If set to true, only pointer down onPointerObservable events will be blocked when picking is occluded by original scene\n         */\n        this.onlyCheckPointerDownEvents = true;\n        /**\n         * If set to false, only pointerUp, pointerDown and pointerMove will be sent to the utilityLayerScene (false by default)\n         */\n        this.processAllEvents = false;\n        /**\n         * Set to false to disable picking\n         */\n        this.pickingEnabled = true;\n        /**\n         * Observable raised when the pointer moves from the utility layer scene to the main scene\n         */\n        this.onPointerOutObservable = new Observable();\n        // Create scene which will be rendered in the foreground and remove it from being referenced by engine to avoid interfering with existing app\n        this.utilityLayerScene = new Scene(originalScene.getEngine(), { virtual: true });\n        this.utilityLayerScene.useRightHandedSystem = originalScene.useRightHandedSystem;\n        this.utilityLayerScene._allowPostProcessClearColor = false;\n        // Deactivate post processes\n        this.utilityLayerScene.postProcessesEnabled = false;\n        // Detach controls on utility scene, events will be fired by logic below to handle picking priority\n        this.utilityLayerScene.detachControl();\n        if (handleEvents) {\n            this._originalPointerObserver = originalScene.onPrePointerObservable.add((prePointerInfo) => {\n                if (!this.utilityLayerScene.activeCamera) {\n                    return;\n                }\n                if (!this.pickingEnabled) {\n                    return;\n                }\n                if (!this.processAllEvents) {\n                    if (prePointerInfo.type !== PointerEventTypes.POINTERMOVE &&\n                        prePointerInfo.type !== PointerEventTypes.POINTERUP &&\n                        prePointerInfo.type !== PointerEventTypes.POINTERDOWN &&\n                        prePointerInfo.type !== PointerEventTypes.POINTERDOUBLETAP) {\n                        return;\n                    }\n                }\n                this.utilityLayerScene.pointerX = originalScene.pointerX;\n                this.utilityLayerScene.pointerY = originalScene.pointerY;\n                const pointerEvent = prePointerInfo.event;\n                if (originalScene.isPointerCaptured(pointerEvent.pointerId)) {\n                    this._pointerCaptures[pointerEvent.pointerId] = false;\n                    return;\n                }\n                const getNearPickDataForScene = (scene) => {\n                    let scenePick = null;\n                    if (prePointerInfo.nearInteractionPickingInfo) {\n                        if (prePointerInfo.nearInteractionPickingInfo.pickedMesh.getScene() == scene) {\n                            scenePick = prePointerInfo.nearInteractionPickingInfo;\n                        }\n                        else {\n                            scenePick = new PickingInfo();\n                        }\n                    }\n                    else if (scene !== this.utilityLayerScene && prePointerInfo.originalPickingInfo) {\n                        scenePick = prePointerInfo.originalPickingInfo;\n                    }\n                    else {\n                        let previousActiveCamera = null;\n                        // If a camera is set for rendering with this layer\n                        // it will also be used for the ray computation\n                        // To preserve back compat and because scene.pick always use activeCamera\n                        // it's substituted temporarily and a new scenePick is forced.\n                        // otherwise, the ray with previously active camera is always used.\n                        // It's set back to previous activeCamera after operation.\n                        if (this._renderCamera) {\n                            previousActiveCamera = scene._activeCamera;\n                            scene._activeCamera = this._renderCamera;\n                            prePointerInfo.ray = null;\n                        }\n                        scenePick = prePointerInfo.ray ? scene.pickWithRay(prePointerInfo.ray) : scene.pick(originalScene.pointerX, originalScene.pointerY);\n                        if (previousActiveCamera) {\n                            scene._activeCamera = previousActiveCamera;\n                        }\n                    }\n                    return scenePick;\n                };\n                const utilityScenePick = getNearPickDataForScene(this.utilityLayerScene);\n                if (!prePointerInfo.ray && utilityScenePick) {\n                    prePointerInfo.ray = utilityScenePick.ray;\n                }\n                // always fire the prepointer observable\n                this.utilityLayerScene.onPrePointerObservable.notifyObservers(prePointerInfo);\n                // allow every non pointer down event to flow to the utility layer\n                if (this.onlyCheckPointerDownEvents && prePointerInfo.type != PointerEventTypes.POINTERDOWN) {\n                    if (!prePointerInfo.skipOnPointerObservable) {\n                        this.utilityLayerScene.onPointerObservable.notifyObservers(new PointerInfo(prePointerInfo.type, prePointerInfo.event, utilityScenePick), prePointerInfo.type);\n                    }\n                    if (prePointerInfo.type === PointerEventTypes.POINTERUP && this._pointerCaptures[pointerEvent.pointerId]) {\n                        this._pointerCaptures[pointerEvent.pointerId] = false;\n                    }\n                    return;\n                }\n                if (this.utilityLayerScene.autoClearDepthAndStencil || this.pickUtilitySceneFirst) {\n                    // If this layer is an overlay, check if this layer was hit and if so, skip pointer events for the main scene\n                    if (utilityScenePick && utilityScenePick.hit) {\n                        if (!prePointerInfo.skipOnPointerObservable) {\n                            this.utilityLayerScene.onPointerObservable.notifyObservers(new PointerInfo(prePointerInfo.type, prePointerInfo.event, utilityScenePick), prePointerInfo.type);\n                        }\n                        prePointerInfo.skipOnPointerObservable = true;\n                    }\n                }\n                else {\n                    const originalScenePick = getNearPickDataForScene(originalScene);\n                    const pointerEvent = prePointerInfo.event;\n                    // If the layer can be occluded by the original scene, only fire pointer events to the first layer that hit they ray\n                    if (originalScenePick && utilityScenePick) {\n                        // No pick in utility scene\n                        if (utilityScenePick.distance === 0 && originalScenePick.pickedMesh) {\n                            if (this.mainSceneTrackerPredicate && this.mainSceneTrackerPredicate(originalScenePick.pickedMesh)) {\n                                // We touched an utility mesh present in the main scene\n                                this._notifyObservers(prePointerInfo, originalScenePick, pointerEvent);\n                                prePointerInfo.skipOnPointerObservable = true;\n                            }\n                            else if (prePointerInfo.type === PointerEventTypes.POINTERDOWN) {\n                                this._pointerCaptures[pointerEvent.pointerId] = true;\n                            }\n                            else if (prePointerInfo.type === PointerEventTypes.POINTERMOVE || prePointerInfo.type === PointerEventTypes.POINTERUP) {\n                                if (this._lastPointerEvents[pointerEvent.pointerId]) {\n                                    // We need to send a last pointerup to the utilityLayerScene to make sure animations can complete\n                                    this.onPointerOutObservable.notifyObservers(pointerEvent.pointerId);\n                                    delete this._lastPointerEvents[pointerEvent.pointerId];\n                                }\n                                this._notifyObservers(prePointerInfo, originalScenePick, pointerEvent);\n                            }\n                        }\n                        else if (!this._pointerCaptures[pointerEvent.pointerId] && (utilityScenePick.distance < originalScenePick.distance || originalScenePick.distance === 0)) {\n                            // We pick something in utility scene or the pick in utility is closer than the one in main scene\n                            this._notifyObservers(prePointerInfo, utilityScenePick, pointerEvent);\n                            // If a previous utility layer set this, do not unset this\n                            if (!prePointerInfo.skipOnPointerObservable) {\n                                prePointerInfo.skipOnPointerObservable = utilityScenePick.distance > 0;\n                            }\n                        }\n                        else if (!this._pointerCaptures[pointerEvent.pointerId] && utilityScenePick.distance >= originalScenePick.distance) {\n                            // We have a pick in both scenes but main is closer than utility\n                            // We touched an utility mesh present in the main scene\n                            if (this.mainSceneTrackerPredicate && this.mainSceneTrackerPredicate(originalScenePick.pickedMesh)) {\n                                this._notifyObservers(prePointerInfo, originalScenePick, pointerEvent);\n                                prePointerInfo.skipOnPointerObservable = true;\n                            }\n                            else {\n                                if (prePointerInfo.type === PointerEventTypes.POINTERMOVE || prePointerInfo.type === PointerEventTypes.POINTERUP) {\n                                    if (this._lastPointerEvents[pointerEvent.pointerId]) {\n                                        // We need to send a last pointerup to the utilityLayerScene to make sure animations can complete\n                                        this.onPointerOutObservable.notifyObservers(pointerEvent.pointerId);\n                                        delete this._lastPointerEvents[pointerEvent.pointerId];\n                                    }\n                                }\n                                this._notifyObservers(prePointerInfo, utilityScenePick, pointerEvent);\n                            }\n                        }\n                        if (prePointerInfo.type === PointerEventTypes.POINTERUP && this._pointerCaptures[pointerEvent.pointerId]) {\n                            this._pointerCaptures[pointerEvent.pointerId] = false;\n                        }\n                    }\n                }\n            });\n            // As a newly added utility layer will be rendered over the screen last, it's pointer events should be processed first\n            if (this._originalPointerObserver) {\n                originalScene.onPrePointerObservable.makeObserverTopPriority(this._originalPointerObserver);\n            }\n        }\n        // Render directly on top of existing scene without clearing\n        this.utilityLayerScene.autoClear = false;\n        this._afterRenderObserver = this.originalScene.onAfterRenderCameraObservable.add((camera) => {\n            // Only render when the render camera finishes rendering\n            if (this.shouldRender && camera == this.getRenderCamera()) {\n                this.render();\n            }\n        });\n        this._sceneDisposeObserver = this.originalScene.onDisposeObservable.add(() => {\n            this.dispose();\n        });\n        this._updateCamera();\n    }\n    _notifyObservers(prePointerInfo, pickInfo, pointerEvent) {\n        if (!prePointerInfo.skipOnPointerObservable) {\n            this.utilityLayerScene.onPointerObservable.notifyObservers(new PointerInfo(prePointerInfo.type, prePointerInfo.event, pickInfo), prePointerInfo.type);\n            this._lastPointerEvents[pointerEvent.pointerId] = true;\n        }\n    }\n    /**\n     * Renders the utility layers scene on top of the original scene\n     */\n    render() {\n        this._updateCamera();\n        if (this.utilityLayerScene.activeCamera) {\n            // Set the camera's scene to utility layers scene\n            const oldScene = this.utilityLayerScene.activeCamera.getScene();\n            const camera = this.utilityLayerScene.activeCamera;\n            camera._scene = this.utilityLayerScene;\n            if (camera.leftCamera) {\n                camera.leftCamera._scene = this.utilityLayerScene;\n            }\n            if (camera.rightCamera) {\n                camera.rightCamera._scene = this.utilityLayerScene;\n            }\n            this.utilityLayerScene.render(false);\n            // Reset camera's scene back to original\n            camera._scene = oldScene;\n            if (camera.leftCamera) {\n                camera.leftCamera._scene = oldScene;\n            }\n            if (camera.rightCamera) {\n                camera.rightCamera._scene = oldScene;\n            }\n        }\n    }\n    /**\n     * Disposes of the renderer\n     */\n    dispose() {\n        this.onPointerOutObservable.clear();\n        if (this._afterRenderObserver) {\n            this.originalScene.onAfterCameraRenderObservable.remove(this._afterRenderObserver);\n        }\n        if (this._sceneDisposeObserver) {\n            this.originalScene.onDisposeObservable.remove(this._sceneDisposeObserver);\n        }\n        if (this._originalPointerObserver) {\n            this.originalScene.onPrePointerObservable.remove(this._originalPointerObserver);\n        }\n        this.utilityLayerScene.dispose();\n    }\n    _updateCamera() {\n        this.utilityLayerScene.cameraToUseForPointers = this.getRenderCamera();\n        this.utilityLayerScene.activeCamera = this.getRenderCamera();\n    }\n}\n/** @internal */\nUtilityLayerRenderer._DefaultUtilityLayer = null;\n/** @internal */\nUtilityLayerRenderer._DefaultKeepDepthUtilityLayer = null;\n//# sourceMappingURL=utilityLayerRenderer.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nimport \"./sceneUboDeclaration.js\";\nconst name = \"backgroundUboDeclaration\";\nconst shader = `layout(std140,column_major) uniform;\runiform Material\r{\runiform vec4 vPrimaryColor;\runiform vec4 vPrimaryColorShadow;\runiform vec2 vDiffuseInfos;\runiform vec2 vReflectionInfos;\runiform mat4 diffuseMatrix;\runiform mat4 reflectionMatrix;\runiform vec3 vReflectionMicrosurfaceInfos;\runiform float fFovMultiplier;\runiform float pointSize;\runiform float shadowLevel;\runiform float alpha;\r#if defined(REFLECTIONFRESNEL) || defined(OPACITYFRESNEL)\nuniform vec3 vBackgroundCenter;\r#endif\n#ifdef REFLECTIONFRESNEL\nuniform vec4 vReflectionControl;\r#endif\n};\r#include<sceneUboDeclaration>\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const backgroundUboDeclaration = { name, shader };\n//# sourceMappingURL=backgroundUboDeclaration.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nconst name = \"bakedVertexAnimation\";\nconst shader = `#ifdef BAKED_VERTEX_ANIMATION_TEXTURE\n{\r#ifdef INSTANCES\n#define BVASNAME bakedVertexAnimationSettingsInstanced\n#else\n#define BVASNAME bakedVertexAnimationSettings\n#endif\nfloat VATStartFrame=BVASNAME.x;\rfloat VATEndFrame=BVASNAME.y;\rfloat VATOffsetFrame=BVASNAME.z;\rfloat VATSpeed=BVASNAME.w;\rfloat totalFrames=VATEndFrame-VATStartFrame+1.0;\rfloat time=bakedVertexAnimationTime*VATSpeed/totalFrames;\rfloat frameCorrection=time<1.0 ? 0.0 : 1.0;\rfloat numOfFrames=totalFrames-frameCorrection;\rfloat VATFrameNum=fract(time)*numOfFrames;\rVATFrameNum=mod(VATFrameNum+VATOffsetFrame,numOfFrames);\rVATFrameNum=floor(VATFrameNum);\rVATFrameNum+=VATStartFrame+frameCorrection;\rmat4 VATInfluence;\rVATInfluence=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndices[0],VATFrameNum)*matricesWeights[0];\r#if NUM_BONE_INFLUENCERS>1\nVATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndices[1],VATFrameNum)*matricesWeights[1];\r#endif\n#if NUM_BONE_INFLUENCERS>2\nVATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndices[2],VATFrameNum)*matricesWeights[2];\r#endif\n#if NUM_BONE_INFLUENCERS>3\nVATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndices[3],VATFrameNum)*matricesWeights[3];\r#endif\n#if NUM_BONE_INFLUENCERS>4\nVATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndicesExtra[0],VATFrameNum)*matricesWeightsExtra[0];\r#endif\n#if NUM_BONE_INFLUENCERS>5\nVATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndicesExtra[1],VATFrameNum)*matricesWeightsExtra[1];\r#endif\n#if NUM_BONE_INFLUENCERS>6\nVATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndicesExtra[2],VATFrameNum)*matricesWeightsExtra[2];\r#endif\n#if NUM_BONE_INFLUENCERS>7\nVATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndicesExtra[3],VATFrameNum)*matricesWeightsExtra[3];\r#endif\nfinalWorld=finalWorld*VATInfluence;\r}\r#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const bakedVertexAnimation = { name, shader };\n//# sourceMappingURL=bakedVertexAnimation.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nconst name = \"bakedVertexAnimationDeclaration\";\nconst shader = `#ifdef BAKED_VERTEX_ANIMATION_TEXTURE\nuniform float bakedVertexAnimationTime;\runiform vec2 bakedVertexAnimationTextureSizeInverted;\runiform vec4 bakedVertexAnimationSettings;\runiform sampler2D bakedVertexAnimationTexture;\r#ifdef INSTANCES\nattribute vec4 bakedVertexAnimationSettingsInstanced;\r#endif\n#define inline\nmat4 readMatrixFromRawSamplerVAT(sampler2D smp,float index,float frame)\r{\rfloat offset=index*4.0;\rfloat frameUV=(frame+0.5)*bakedVertexAnimationTextureSizeInverted.y;\rfloat dx=bakedVertexAnimationTextureSizeInverted.x;\rvec4 m0=texture2D(smp,vec2(dx*(offset+0.5),frameUV));\rvec4 m1=texture2D(smp,vec2(dx*(offset+1.5),frameUV));\rvec4 m2=texture2D(smp,vec2(dx*(offset+2.5),frameUV));\rvec4 m3=texture2D(smp,vec2(dx*(offset+3.5),frameUV));\rreturn mat4(m0,m1,m2,m3);\r}\r#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const bakedVertexAnimationDeclaration = { name, shader };\n//# sourceMappingURL=bakedVertexAnimationDeclaration.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nconst name = \"bonesVertex\";\nconst shader = `#ifndef BAKED_VERTEX_ANIMATION_TEXTURE\n#if NUM_BONE_INFLUENCERS>0\nmat4 influence;\r#ifdef BONETEXTURE\ninfluence=readMatrixFromRawSampler(boneSampler,matricesIndices[0])*matricesWeights[0];\r#if NUM_BONE_INFLUENCERS>1\ninfluence+=readMatrixFromRawSampler(boneSampler,matricesIndices[1])*matricesWeights[1];\r#endif\n#if NUM_BONE_INFLUENCERS>2\ninfluence+=readMatrixFromRawSampler(boneSampler,matricesIndices[2])*matricesWeights[2];\r#endif\n#if NUM_BONE_INFLUENCERS>3\ninfluence+=readMatrixFromRawSampler(boneSampler,matricesIndices[3])*matricesWeights[3];\r#endif\n#if NUM_BONE_INFLUENCERS>4\ninfluence+=readMatrixFromRawSampler(boneSampler,matricesIndicesExtra[0])*matricesWeightsExtra[0];\r#endif\n#if NUM_BONE_INFLUENCERS>5\ninfluence+=readMatrixFromRawSampler(boneSampler,matricesIndicesExtra[1])*matricesWeightsExtra[1];\r#endif\n#if NUM_BONE_INFLUENCERS>6\ninfluence+=readMatrixFromRawSampler(boneSampler,matricesIndicesExtra[2])*matricesWeightsExtra[2];\r#endif\n#if NUM_BONE_INFLUENCERS>7\ninfluence+=readMatrixFromRawSampler(boneSampler,matricesIndicesExtra[3])*matricesWeightsExtra[3];\r#endif\n#else\ninfluence=mBones[int(matricesIndices[0])]*matricesWeights[0];\r#if NUM_BONE_INFLUENCERS>1\ninfluence+=mBones[int(matricesIndices[1])]*matricesWeights[1];\r#endif\n#if NUM_BONE_INFLUENCERS>2\ninfluence+=mBones[int(matricesIndices[2])]*matricesWeights[2];\r#endif\n#if NUM_BONE_INFLUENCERS>3\ninfluence+=mBones[int(matricesIndices[3])]*matricesWeights[3];\r#endif\n#if NUM_BONE_INFLUENCERS>4\ninfluence+=mBones[int(matricesIndicesExtra[0])]*matricesWeightsExtra[0];\r#endif\n#if NUM_BONE_INFLUENCERS>5\ninfluence+=mBones[int(matricesIndicesExtra[1])]*matricesWeightsExtra[1];\r#endif\n#if NUM_BONE_INFLUENCERS>6\ninfluence+=mBones[int(matricesIndicesExtra[2])]*matricesWeightsExtra[2];\r#endif\n#if NUM_BONE_INFLUENCERS>7\ninfluence+=mBones[int(matricesIndicesExtra[3])]*matricesWeightsExtra[3];\r#endif\n#endif\nfinalWorld=finalWorld*influence;\r#endif\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const bonesVertex = { name, shader };\n//# sourceMappingURL=bonesVertex.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nconst name = \"bumpFragment\";\nconst shader = `vec2 uvOffset=vec2(0.0,0.0);\r#if defined(BUMP) || defined(PARALLAX) || defined(DETAIL)\n#ifdef NORMALXYSCALE\nfloat normalScale=1.0;\r#elif defined(BUMP)\nfloat normalScale=vBumpInfos.y;\r#else\nfloat normalScale=1.0;\r#endif\n#if defined(TANGENT) && defined(NORMAL)\nmat3 TBN=vTBN;\r#elif defined(BUMP)\nvec2 TBNUV=gl_FrontFacing ? vBumpUV : -vBumpUV;\rmat3 TBN=cotangent_frame(normalW*normalScale,vPositionW,TBNUV,vTangentSpaceParams);\r#else\nvec2 TBNUV=gl_FrontFacing ? vDetailUV : -vDetailUV;\rmat3 TBN=cotangent_frame(normalW*normalScale,vPositionW,TBNUV,vec2(1.,1.));\r#endif\n#elif defined(ANISOTROPIC)\n#if defined(TANGENT) && defined(NORMAL)\nmat3 TBN=vTBN;\r#else\nvec2 TBNUV=gl_FrontFacing ? vMainUV1 : -vMainUV1;\rmat3 TBN=cotangent_frame(normalW,vPositionW,TBNUV,vec2(1.,1.));\r#endif\n#endif\n#ifdef PARALLAX\nmat3 invTBN=transposeMat3(TBN);\r#ifdef PARALLAXOCCLUSION\nuvOffset=parallaxOcclusion(invTBN*-viewDirectionW,invTBN*normalW,vBumpUV,vBumpInfos.z);\r#else\nuvOffset=parallaxOffset(invTBN*viewDirectionW,vBumpInfos.z);\r#endif\n#endif\n#ifdef DETAIL\nvec4 detailColor=texture2D(detailSampler,vDetailUV+uvOffset);\rvec2 detailNormalRG=detailColor.wy*2.0-1.0;\rfloat detailNormalB=sqrt(1.-saturate(dot(detailNormalRG,detailNormalRG)));\rvec3 detailNormal=vec3(detailNormalRG,detailNormalB);\r#endif\n#ifdef BUMP\n#ifdef OBJECTSPACE_NORMALMAP\n#define CUSTOM_FRAGMENT_BUMP_FRAGMENT\nnormalW=normalize(texture2D(bumpSampler,vBumpUV).xyz *2.0-1.0);\rnormalW=normalize(mat3(normalMatrix)*normalW);\r#elif !defined(DETAIL)\nnormalW=perturbNormal(TBN,texture2D(bumpSampler,vBumpUV+uvOffset).xyz,vBumpInfos.y);\r#else\nvec3 bumpNormal=texture2D(bumpSampler,vBumpUV+uvOffset).xyz*2.0-1.0;\r#if DETAIL_NORMALBLENDMETHOD==0 \ndetailNormal.xy*=vDetailInfos.z;\rvec3 blendedNormal=normalize(vec3(bumpNormal.xy+detailNormal.xy,bumpNormal.z*detailNormal.z));\r#elif DETAIL_NORMALBLENDMETHOD==1 \ndetailNormal.xy*=vDetailInfos.z;\rbumpNormal+=vec3(0.0,0.0,1.0);\rdetailNormal*=vec3(-1.0,-1.0,1.0);\rvec3 blendedNormal=bumpNormal*dot(bumpNormal,detailNormal)/bumpNormal.z-detailNormal;\r#endif\nnormalW=perturbNormalBase(TBN,blendedNormal,vBumpInfos.y);\r#endif\n#elif defined(DETAIL)\ndetailNormal.xy*=vDetailInfos.z;\rnormalW=perturbNormalBase(TBN,detailNormal,vDetailInfos.z);\r#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const bumpFragment = { name, shader };\n//# sourceMappingURL=bumpFragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nimport \"./samplerFragmentDeclaration.js\";\nconst name = \"bumpFragmentFunctions\";\nconst shader = `#if defined(BUMP)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,BUMP,_VARYINGNAME_,Bump,_SAMPLERNAME_,bump)\n#endif\n#if defined(DETAIL)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,DETAIL,_VARYINGNAME_,Detail,_SAMPLERNAME_,detail)\n#endif\n#if defined(BUMP) && defined(PARALLAX)\nconst float minSamples=4.;\rconst float maxSamples=15.;\rconst int iMaxSamples=15;\rvec2 parallaxOcclusion(vec3 vViewDirCoT,vec3 vNormalCoT,vec2 texCoord,float parallaxScale) {\rfloat parallaxLimit=length(vViewDirCoT.xy)/vViewDirCoT.z;\rparallaxLimit*=parallaxScale;\rvec2 vOffsetDir=normalize(vViewDirCoT.xy);\rvec2 vMaxOffset=vOffsetDir*parallaxLimit;\rfloat numSamples=maxSamples+(dot(vViewDirCoT,vNormalCoT)*(minSamples-maxSamples));\rfloat stepSize=1.0/numSamples;\rfloat currRayHeight=1.0;\rvec2 vCurrOffset=vec2(0,0);\rvec2 vLastOffset=vec2(0,0);\rfloat lastSampledHeight=1.0;\rfloat currSampledHeight=1.0;\rbool keepWorking=true;\rfor (int i=0; i<iMaxSamples; i++)\r{\rcurrSampledHeight=texture2D(bumpSampler,texCoord+vCurrOffset).w;\rif (!keepWorking)\r{\r}\relse if (currSampledHeight>currRayHeight)\r{\rfloat delta1=currSampledHeight-currRayHeight;\rfloat delta2=(currRayHeight+stepSize)-lastSampledHeight;\rfloat ratio=delta1/(delta1+delta2);\rvCurrOffset=(ratio)* vLastOffset+(1.0-ratio)*vCurrOffset;\rkeepWorking=false;\r}\relse\r{\rcurrRayHeight-=stepSize;\rvLastOffset=vCurrOffset;\rvCurrOffset+=stepSize*vMaxOffset;\rlastSampledHeight=currSampledHeight;\r}\r}\rreturn vCurrOffset;\r}\rvec2 parallaxOffset(vec3 viewDir,float heightScale)\r{\rfloat height=texture2D(bumpSampler,vBumpUV).w;\rvec2 texCoordOffset=heightScale*viewDir.xy*height;\rreturn -texCoordOffset;\r}\r#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const bumpFragmentFunctions = { name, shader };\n//# sourceMappingURL=bumpFragmentFunctions.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nconst name = \"bumpVertex\";\nconst shader = `#if defined(BUMP) || defined(PARALLAX) || defined(CLEARCOAT_BUMP) || defined(ANISOTROPIC)\n#if defined(TANGENT) && defined(NORMAL)\nvec3 tbnNormal=normalize(normalUpdated);\rvec3 tbnTangent=normalize(tangentUpdated.xyz);\rvec3 tbnBitangent=cross(tbnNormal,tbnTangent)*tangentUpdated.w;\rvTBN=mat3(finalWorld)*mat3(tbnTangent,tbnBitangent,tbnNormal);\r#endif\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const bumpVertex = { name, shader };\n//# sourceMappingURL=bumpVertex.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nconst name = \"clipPlaneFragmentDeclaration\";\nconst shader = `#ifdef CLIPPLANE\nvarying float fClipDistance;\r#endif\n#ifdef CLIPPLANE2\nvarying float fClipDistance2;\r#endif\n#ifdef CLIPPLANE3\nvarying float fClipDistance3;\r#endif\n#ifdef CLIPPLANE4\nvarying float fClipDistance4;\r#endif\n#ifdef CLIPPLANE5\nvarying float fClipDistance5;\r#endif\n#ifdef CLIPPLANE6\nvarying float fClipDistance6;\r#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const clipPlaneFragmentDeclaration = { name, shader };\n//# sourceMappingURL=clipPlaneFragmentDeclaration.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nconst name = \"clipPlaneFragmentDeclaration2\";\nconst shader = `#ifdef CLIPPLANE\nin float fClipDistance;\r#endif\n#ifdef CLIPPLANE2\nin float fClipDistance2;\r#endif\n#ifdef CLIPPLANE3\nin float fClipDistance3;\r#endif\n#ifdef CLIPPLANE4\nin float fClipDistance4;\r#endif\n#ifdef CLIPPLANE5\nin float fClipDistance5;\r#endif\n#ifdef CLIPPLANE6\nin float fClipDistance6;\r#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const clipPlaneFragmentDeclaration2 = { name, shader };\n//# sourceMappingURL=clipPlaneFragmentDeclaration2.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nconst name = \"clipPlaneVertexDeclaration\";\nconst shader = `#ifdef CLIPPLANE\nuniform vec4 vClipPlane;\rvarying float fClipDistance;\r#endif\n#ifdef CLIPPLANE2\nuniform vec4 vClipPlane2;\rvarying float fClipDistance2;\r#endif\n#ifdef CLIPPLANE3\nuniform vec4 vClipPlane3;\rvarying float fClipDistance3;\r#endif\n#ifdef CLIPPLANE4\nuniform vec4 vClipPlane4;\rvarying float fClipDistance4;\r#endif\n#ifdef CLIPPLANE5\nuniform vec4 vClipPlane5;\rvarying float fClipDistance5;\r#endif\n#ifdef CLIPPLANE6\nuniform vec4 vClipPlane6;\rvarying float fClipDistance6;\r#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const clipPlaneVertexDeclaration = { name, shader };\n//# sourceMappingURL=clipPlaneVertexDeclaration.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nconst name = \"diffusionProfile\";\nconst shader = `uniform vec3 diffusionS[5];\runiform float diffusionD[5];\runiform float filterRadii[5];`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const diffusionProfile = { name, shader };\n//# sourceMappingURL=diffusionProfile.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nconst name = \"fibonacci\";\nconst shader = `#define rcp(x) 1./x\n#define GOLDEN_RATIO 1.618033988749895\n#define TWO_PI 6.2831855\nvec2 Golden2dSeq(int i,float n)\r{\rreturn vec2(float(i)/n+(0.5/n),fract(float(i)*rcp(GOLDEN_RATIO)));\r}\rvec2 SampleDiskGolden(int i,int sampleCount)\r{\rvec2 f=Golden2dSeq(i,float(sampleCount));\rreturn vec2(sqrt(f.x),TWO_PI*f.y);\r}`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const fibonacci = { name, shader };\n//# sourceMappingURL=fibonacci.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nconst name = \"fogFragment\";\nconst shader = `#ifdef FOG\nfloat fog=CalcFogFactor();\r#ifdef PBR\nfog=toLinearSpace(fog);\r#endif\ncolor.rgb=mix(vFogColor,color.rgb,fog);\r#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const fogFragment = { name, shader };\n//# sourceMappingURL=fogFragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nconst name = \"fogFragmentDeclaration\";\nconst shader = `#ifdef FOG\n#define FOGMODE_NONE 0.\n#define FOGMODE_EXP 1.\n#define FOGMODE_EXP2 2.\n#define FOGMODE_LINEAR 3.\n#define E 2.71828\nuniform vec4 vFogInfos;\runiform vec3 vFogColor;\rvarying vec3 vFogDistance;\rfloat CalcFogFactor()\r{\rfloat fogCoeff=1.0;\rfloat fogStart=vFogInfos.y;\rfloat fogEnd=vFogInfos.z;\rfloat fogDensity=vFogInfos.w;\rfloat fogDistance=length(vFogDistance);\rif (FOGMODE_LINEAR==vFogInfos.x)\r{\rfogCoeff=(fogEnd-fogDistance)/(fogEnd-fogStart);\r}\relse if (FOGMODE_EXP==vFogInfos.x)\r{\rfogCoeff=1.0/pow(E,fogDistance*fogDensity);\r}\relse if (FOGMODE_EXP2==vFogInfos.x)\r{\rfogCoeff=1.0/pow(E,fogDistance*fogDistance*fogDensity*fogDensity);\r}\rreturn clamp(fogCoeff,0.0,1.0);\r}\r#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const fogFragmentDeclaration = { name, shader };\n//# sourceMappingURL=fogFragmentDeclaration.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nconst name = \"fogVertexDeclaration\";\nconst shader = `#ifdef FOG\nvarying vec3 vFogDistance;\r#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const fogVertexDeclaration = { name, shader };\n//# sourceMappingURL=fogVertexDeclaration.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nconst name = \"fresnelFunction\";\nconst shader = `#ifdef FRESNEL\nfloat computeFresnelTerm(vec3 viewDirection,vec3 worldNormal,float bias,float power)\r{\rfloat fresnelTerm=pow(bias+abs(dot(viewDirection,worldNormal)),power);\rreturn clamp(fresnelTerm,0.,1.);\r}\r#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const fresnelFunction = { name, shader };\n//# sourceMappingURL=fresnelFunction.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nimport \"./sceneUboDeclaration.js\";\nconst name = \"geometryUboDeclaration\";\nconst shader = `#include<sceneUboDeclaration>\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const geometryUboDeclaration = { name, shader };\n//# sourceMappingURL=geometryUboDeclaration.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nconst name = \"harmonicsFunctions\";\nconst shader = `#ifdef USESPHERICALFROMREFLECTIONMAP\n#ifdef SPHERICAL_HARMONICS\nvec3 computeEnvironmentIrradiance(vec3 normal) {\rreturn vSphericalL00\r+ vSphericalL1_1*(normal.y)\r+ vSphericalL10*(normal.z)\r+ vSphericalL11*(normal.x)\r+ vSphericalL2_2*(normal.y*normal.x)\r+ vSphericalL2_1*(normal.y*normal.z)\r+ vSphericalL20*((3.0*normal.z*normal.z)-1.0)\r+ vSphericalL21*(normal.z*normal.x)\r+ vSphericalL22*(normal.x*normal.x-(normal.y*normal.y));\r}\r#else\nvec3 computeEnvironmentIrradiance(vec3 normal) {\rfloat Nx=normal.x;\rfloat Ny=normal.y;\rfloat Nz=normal.z;\rvec3 C1=vSphericalZZ.rgb;\rvec3 Cx=vSphericalX.rgb;\rvec3 Cy=vSphericalY.rgb;\rvec3 Cz=vSphericalZ.rgb;\rvec3 Cxx_zz=vSphericalXX_ZZ.rgb;\rvec3 Cyy_zz=vSphericalYY_ZZ.rgb;\rvec3 Cxy=vSphericalXY.rgb;\rvec3 Cyz=vSphericalYZ.rgb;\rvec3 Czx=vSphericalZX.rgb;\rvec3 a1=Cyy_zz*Ny+Cy;\rvec3 a2=Cyz*Nz+a1;\rvec3 b1=Czx*Nz+Cx;\rvec3 b2=Cxy*Ny+b1;\rvec3 b3=Cxx_zz*Nx+b2;\rvec3 t1=Cz *Nz+C1;\rvec3 t2=a2 *Ny+t1;\rvec3 t3=b3 *Nx+t2;\rreturn t3;\r}\r#endif\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const harmonicsFunctions = { name, shader };\n//# sourceMappingURL=harmonicsFunctions.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nconst name = \"hdrFilteringFunctions\";\nconst shader = `#ifdef NUM_SAMPLES\n#if NUM_SAMPLES>0\n#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)\nfloat radicalInverse_VdC(uint bits) \r{\rbits=(bits<<16u) | (bits>>16u);\rbits=((bits & 0x55555555u)<<1u) | ((bits & 0xAAAAAAAAu)>>1u);\rbits=((bits & 0x33333333u)<<2u) | ((bits & 0xCCCCCCCCu)>>2u);\rbits=((bits & 0x0F0F0F0Fu)<<4u) | ((bits & 0xF0F0F0F0u)>>4u);\rbits=((bits & 0x00FF00FFu)<<8u) | ((bits & 0xFF00FF00u)>>8u);\rreturn float(bits)*2.3283064365386963e-10; \r}\rvec2 hammersley(uint i,uint N)\r{\rreturn vec2(float(i)/float(N),radicalInverse_VdC(i));\r}\r#else\nfloat vanDerCorpus(int n,int base)\r{\rfloat invBase=1.0/float(base);\rfloat denom =1.0;\rfloat result =0.0;\rfor(int i=0; i<32; ++i)\r{\rif(n>0)\r{\rdenom =mod(float(n),2.0);\rresult+=denom*invBase;\rinvBase=invBase/2.0;\rn =int(float(n)/2.0);\r}\r}\rreturn result;\r}\rvec2 hammersley(int i,int N)\r{\rreturn vec2(float(i)/float(N),vanDerCorpus(i,2));\r}\r#endif\nfloat log4(float x) {\rreturn log2(x)/2.;\r}\rconst float NUM_SAMPLES_FLOAT=float(NUM_SAMPLES);\rconst float NUM_SAMPLES_FLOAT_INVERSED=1./NUM_SAMPLES_FLOAT;\rconst float K=4.;\r#define inline\nvec3 irradiance(samplerCube inputTexture,vec3 inputN,vec2 filteringInfo)\r{\rvec3 n=normalize(inputN);\rvec3 result=vec3(0.0);\rvec3 tangent=abs(n.z)<0.999 ? vec3(0.,0.,1.) : vec3(1.,0.,0.);\rtangent=normalize(cross(tangent,n));\rvec3 bitangent=cross(n,tangent);\rmat3 tbn=mat3(tangent,bitangent,n);\rfloat maxLevel=filteringInfo.y;\rfloat dim0=filteringInfo.x;\rfloat omegaP=(4.*PI)/(6.*dim0*dim0);\r#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)\nfor(uint i=0u; i<NUM_SAMPLES; ++i)\r#else\nfor(int i=0; i<NUM_SAMPLES; ++i)\r#endif\n{\rvec2 Xi=hammersley(i,NUM_SAMPLES);\rvec3 Ls=hemisphereCosSample(Xi);\rLs=normalize(Ls);\rvec3 Ns=vec3(0.,0.,1.);\rfloat NoL=dot(Ns,Ls);\rif (NoL>0.) {\rfloat pdf_inversed=PI/NoL;\rfloat omegaS=NUM_SAMPLES_FLOAT_INVERSED*pdf_inversed;\rfloat l=log4(omegaS)-log4(omegaP)+log4(K);\rfloat mipLevel=clamp(l,0.0,maxLevel);\rvec3 c=textureCubeLodEXT(inputTexture,tbn*Ls,mipLevel).rgb;\r#ifdef GAMMA_INPUT\nc=toLinearSpace(c);\r#endif\nresult+=c;\r}\r}\rresult=result*NUM_SAMPLES_FLOAT_INVERSED;\rreturn result;\r}\r#define inline\nvec3 radiance(float alphaG,samplerCube inputTexture,vec3 inputN,vec2 filteringInfo)\r{\rvec3 n=normalize(inputN);\rif (alphaG==0.) {\rvec3 c=textureCube(inputTexture,n).rgb;\r#ifdef GAMMA_INPUT\nc=toLinearSpace(c);\r#endif\nreturn c;\r} else {\rvec3 result=vec3(0.);\rvec3 tangent=abs(n.z)<0.999 ? vec3(0.,0.,1.) : vec3(1.,0.,0.);\rtangent=normalize(cross(tangent,n));\rvec3 bitangent=cross(n,tangent);\rmat3 tbn=mat3(tangent,bitangent,n);\rfloat maxLevel=filteringInfo.y;\rfloat dim0=filteringInfo.x;\rfloat omegaP=(4.*PI)/(6.*dim0*dim0);\rfloat weight=0.;\r#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)\nfor(uint i=0u; i<NUM_SAMPLES; ++i)\r#else\nfor(int i=0; i<NUM_SAMPLES; ++i)\r#endif\n{\rvec2 Xi=hammersley(i,NUM_SAMPLES);\rvec3 H=hemisphereImportanceSampleDggx(Xi,alphaG);\rfloat NoV=1.;\rfloat NoH=H.z;\rfloat NoH2=H.z*H.z;\rfloat NoL=2.*NoH2-1.;\rvec3 L=vec3(2.*NoH*H.x,2.*NoH*H.y,NoL);\rL=normalize(L);\rif (NoL>0.) {\rfloat pdf_inversed=4./normalDistributionFunction_TrowbridgeReitzGGX(NoH,alphaG);\rfloat omegaS=NUM_SAMPLES_FLOAT_INVERSED*pdf_inversed;\rfloat l=log4(omegaS)-log4(omegaP)+log4(K);\rfloat mipLevel=clamp(float(l),0.0,maxLevel);\rweight+=NoL;\rvec3 c=textureCubeLodEXT(inputTexture,tbn*L,mipLevel).rgb;\r#ifdef GAMMA_INPUT\nc=toLinearSpace(c);\r#endif\nresult+=c*NoL;\r}\r}\rresult=result/weight;\rreturn result;\r}\r}\r#endif\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const hdrFilteringFunctions = { name, shader };\n//# sourceMappingURL=hdrFilteringFunctions.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nconst name = \"helperFunctions\";\nconst shader = `const float PI=3.1415926535897932384626433832795;\rconst float HALF_MIN=5.96046448e-08; \rconst float LinearEncodePowerApprox=2.2;\rconst float GammaEncodePowerApprox=1.0/LinearEncodePowerApprox;\rconst vec3 LuminanceEncodeApprox=vec3(0.2126,0.7152,0.0722);\rconst float Epsilon=0.0000001;\r#define saturate(x) clamp(x,0.0,1.0)\n#define absEps(x) abs(x)+Epsilon\n#define maxEps(x) max(x,Epsilon)\n#define saturateEps(x) clamp(x,Epsilon,1.0)\nmat3 transposeMat3(mat3 inMatrix) {\rvec3 i0=inMatrix[0];\rvec3 i1=inMatrix[1];\rvec3 i2=inMatrix[2];\rmat3 outMatrix=mat3(\rvec3(i0.x,i1.x,i2.x),\rvec3(i0.y,i1.y,i2.y),\rvec3(i0.z,i1.z,i2.z)\r);\rreturn outMatrix;\r}\rmat3 inverseMat3(mat3 inMatrix) {\rfloat a00=inMatrix[0][0],a01=inMatrix[0][1],a02=inMatrix[0][2];\rfloat a10=inMatrix[1][0],a11=inMatrix[1][1],a12=inMatrix[1][2];\rfloat a20=inMatrix[2][0],a21=inMatrix[2][1],a22=inMatrix[2][2];\rfloat b01=a22*a11-a12*a21;\rfloat b11=-a22*a10+a12*a20;\rfloat b21=a21*a10-a11*a20;\rfloat det=a00*b01+a01*b11+a02*b21;\rreturn mat3(b01,(-a22*a01+a02*a21),(a12*a01-a02*a11),\rb11,(a22*a00-a02*a20),(-a12*a00+a02*a10),\rb21,(-a21*a00+a01*a20),(a11*a00-a01*a10))/det;\r}\r#if USE_EXACT_SRGB_CONVERSIONS\nvec3 toLinearSpaceExact(vec3 color)\r{\rvec3 nearZeroSection=0.0773993808*color;\rvec3 remainingSection=pow(0.947867299*(color+vec3(0.055)),vec3(2.4));\r#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)\nreturn mix(remainingSection,nearZeroSection,lessThanEqual(color,vec3(0.04045)));\r#else\nreturn\rvec3(\rcolor.r<=0.04045 ? nearZeroSection.r : remainingSection.r,\rcolor.g<=0.04045 ? nearZeroSection.g : remainingSection.g,\rcolor.b<=0.04045 ? nearZeroSection.b : remainingSection.b);\r#endif\n}\rvec3 toGammaSpaceExact(vec3 color)\r{\rvec3 nearZeroSection=12.92*color;\rvec3 remainingSection=1.055*pow(color,vec3(0.41666))-vec3(0.055);\r#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)\nreturn mix(remainingSection,nearZeroSection,lessThanEqual(color,vec3(0.0031308)));\r#else\nreturn\rvec3(\rcolor.r<=0.0031308 ? nearZeroSection.r : remainingSection.r,\rcolor.g<=0.0031308 ? nearZeroSection.g : remainingSection.g,\rcolor.b<=0.0031308 ? nearZeroSection.b : remainingSection.b);\r#endif\n}\r#endif\nfloat toLinearSpace(float color)\r{\r#if USE_EXACT_SRGB_CONVERSIONS\nfloat nearZeroSection=0.0773993808*color;\rfloat remainingSection=pow(0.947867299*(color+0.055),2.4);\rreturn color<=0.04045 ? nearZeroSection : remainingSection;\r#else\nreturn pow(color,LinearEncodePowerApprox);\r#endif\n}\rvec3 toLinearSpace(vec3 color)\r{\r#if USE_EXACT_SRGB_CONVERSIONS\nreturn toLinearSpaceExact(color);\r#else\nreturn pow(color,vec3(LinearEncodePowerApprox));\r#endif\n}\rvec4 toLinearSpace(vec4 color)\r{\r#if USE_EXACT_SRGB_CONVERSIONS\nreturn vec4(toLinearSpaceExact(color.rgb),color.a);\r#else\nreturn vec4(pow(color.rgb,vec3(LinearEncodePowerApprox)),color.a);\r#endif\n}\rfloat toGammaSpace(float color)\r{\r#if USE_EXACT_SRGB_CONVERSIONS\nfloat nearZeroSection=12.92*color;\rfloat remainingSection=1.055*pow(color,0.41666)-0.055;\rreturn color<=0.0031308 ? nearZeroSection : remainingSection;\r#else\nreturn pow(color,GammaEncodePowerApprox);\r#endif\n}\rvec3 toGammaSpace(vec3 color)\r{\r#if USE_EXACT_SRGB_CONVERSIONS\nreturn toGammaSpaceExact(color);\r#else\nreturn pow(color,vec3(GammaEncodePowerApprox));\r#endif\n}\rvec4 toGammaSpace(vec4 color)\r{\r#if USE_EXACT_SRGB_CONVERSIONS\nreturn vec4(toGammaSpaceExact(color.rgb),color.a);\r#else\nreturn vec4(pow(color.rgb,vec3(GammaEncodePowerApprox)),color.a);\r#endif\n}\rfloat square(float value)\r{\rreturn value*value;\r}\rvec3 square(vec3 value)\r{\rreturn value*value;\r}\rfloat pow5(float value) {\rfloat sq=value*value;\rreturn sq*sq*value;\r}\rfloat getLuminance(vec3 color)\r{\rreturn clamp(dot(color,LuminanceEncodeApprox),0.,1.);\r}\rfloat getRand(vec2 seed) {\rreturn fract(sin(dot(seed.xy ,vec2(12.9898,78.233)))*43758.5453);\r}\rfloat dither(vec2 seed,float varianceAmount) {\rfloat rand=getRand(seed);\rfloat normVariance=varianceAmount/255.0;\rfloat dither=mix(-normVariance,normVariance,rand);\rreturn dither;\r}\rconst float rgbdMaxRange=255.0;\rvec4 toRGBD(vec3 color) {\rfloat maxRGB=maxEps(max(color.r,max(color.g,color.b)));\rfloat D =max(rgbdMaxRange/maxRGB,1.);\rD =clamp(floor(D)/255.0,0.,1.);\rvec3 rgb=color.rgb*D;\rrgb=toGammaSpace(rgb);\rreturn vec4(clamp(rgb,0.,1.),D); \r}\rvec3 fromRGBD(vec4 rgbd) {\rrgbd.rgb=toLinearSpace(rgbd.rgb);\rreturn rgbd.rgb/rgbd.a;\r}\rvec3 parallaxCorrectNormal( vec3 vertexPos,vec3 origVec,vec3 cubeSize,vec3 cubePos ) {\rvec3 invOrigVec=vec3(1.0,1.0,1.0)/origVec;\rvec3 halfSize=cubeSize*0.5;\rvec3 intersecAtMaxPlane=(cubePos+halfSize-vertexPos)*invOrigVec;\rvec3 intersecAtMinPlane=(cubePos-halfSize-vertexPos)*invOrigVec;\rvec3 largestIntersec=max(intersecAtMaxPlane,intersecAtMinPlane);\rfloat distance=min(min(largestIntersec.x,largestIntersec.y),largestIntersec.z);\rvec3 intersectPositionWS=vertexPos+origVec*distance;\rreturn intersectPositionWS-cubePos;\r}\r`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const helperFunctions = { name, shader };\n//# sourceMappingURL=helperFunctions.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nconst name = \"imageProcessingDeclaration\";\nconst shader = `#ifdef EXPOSURE\nuniform float exposureLinear;\r#endif\n#ifdef CONTRAST\nuniform float contrast;\r#endif\n#if defined(VIGNETTE) || defined(DITHER)\nuniform vec2 vInverseScreenSize;\r#endif\n#ifdef VIGNETTE\nuniform vec4 vignetteSettings1;\runiform vec4 vignetteSettings2;\r#endif\n#ifdef COLORCURVES\nuniform vec4 vCameraColorCurveNegative;\runiform vec4 vCameraColorCurveNeutral;\runiform vec4 vCameraColorCurvePositive;\r#endif\n#ifdef COLORGRADING\n#ifdef COLORGRADING3D\nuniform highp sampler3D txColorTransform;\r#else\nuniform sampler2D txColorTransform;\r#endif\nuniform vec4 colorTransformSettings;\r#endif\n#ifdef DITHER\nuniform float ditherIntensity;\r#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const imageProcessingDeclaration = { name, shader };\n//# sourceMappingURL=imageProcessingDeclaration.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nconst name = \"imageProcessingFunctions\";\nconst shader = `#if defined(COLORGRADING) && !defined(COLORGRADING3D)\n/** \r* Polyfill for SAMPLE_TEXTURE_3D,which is unsupported in WebGL.\r* sampler3dSetting.x=textureOffset (0.5/textureSize).\r* sampler3dSetting.y=textureSize.\r*/\r#define inline\nvec3 sampleTexture3D(sampler2D colorTransform,vec3 color,vec2 sampler3dSetting)\r{\rfloat sliceSize=2.0*sampler3dSetting.x; \r#ifdef SAMPLER3DGREENDEPTH\nfloat sliceContinuous=(color.g-sampler3dSetting.x)*sampler3dSetting.y;\r#else\nfloat sliceContinuous=(color.b-sampler3dSetting.x)*sampler3dSetting.y;\r#endif\nfloat sliceInteger=floor(sliceContinuous);\rfloat sliceFraction=sliceContinuous-sliceInteger;\r#ifdef SAMPLER3DGREENDEPTH\nvec2 sliceUV=color.rb;\r#else\nvec2 sliceUV=color.rg;\r#endif\nsliceUV.x*=sliceSize;\rsliceUV.x+=sliceInteger*sliceSize;\rsliceUV=saturate(sliceUV);\rvec4 slice0Color=texture2D(colorTransform,sliceUV);\rsliceUV.x+=sliceSize;\rsliceUV=saturate(sliceUV);\rvec4 slice1Color=texture2D(colorTransform,sliceUV);\rvec3 result=mix(slice0Color.rgb,slice1Color.rgb,sliceFraction);\r#ifdef SAMPLER3DBGRMAP\ncolor.rgb=result.rgb;\r#else\ncolor.rgb=result.bgr;\r#endif\nreturn color;\r}\r#endif\n#ifdef TONEMAPPING_ACES\nconst mat3 ACESInputMat=mat3(\rvec3(0.59719,0.07600,0.02840),\rvec3(0.35458,0.90834,0.13383),\rvec3(0.04823,0.01566,0.83777)\r);\rconst mat3 ACESOutputMat=mat3(\rvec3( 1.60475,-0.10208,-0.00327),\rvec3(-0.53108, 1.10813,-0.07276),\rvec3(-0.07367,-0.00605, 1.07602)\r);\rvec3 RRTAndODTFit(vec3 v)\r{\rvec3 a=v*(v+0.0245786)-0.000090537;\rvec3 b=v*(0.983729*v+0.4329510)+0.238081;\rreturn a/b;\r}\rvec3 ACESFitted(vec3 color)\r{\rcolor=ACESInputMat*color;\rcolor=RRTAndODTFit(color);\rcolor=ACESOutputMat*color;\rcolor=saturate(color);\rreturn color;\r}\r#endif\n#define CUSTOM_IMAGEPROCESSINGFUNCTIONS_DEFINITIONS\nvec4 applyImageProcessing(vec4 result) {\r#define CUSTOM_IMAGEPROCESSINGFUNCTIONS_UPDATERESULT_ATSTART\n#ifdef EXPOSURE\nresult.rgb*=exposureLinear;\r#endif\n#ifdef VIGNETTE\nvec2 viewportXY=gl_FragCoord.xy*vInverseScreenSize;\rviewportXY=viewportXY*2.0-1.0;\rvec3 vignetteXY1=vec3(viewportXY*vignetteSettings1.xy+vignetteSettings1.zw,1.0);\rfloat vignetteTerm=dot(vignetteXY1,vignetteXY1);\rfloat vignette=pow(vignetteTerm,vignetteSettings2.w);\rvec3 vignetteColor=vignetteSettings2.rgb;\r#ifdef VIGNETTEBLENDMODEMULTIPLY\nvec3 vignetteColorMultiplier=mix(vignetteColor,vec3(1,1,1),vignette);\rresult.rgb*=vignetteColorMultiplier;\r#endif\n#ifdef VIGNETTEBLENDMODEOPAQUE\nresult.rgb=mix(vignetteColor,result.rgb,vignette);\r#endif\n#endif\n#ifdef TONEMAPPING\n#ifdef TONEMAPPING_ACES\nresult.rgb=ACESFitted(result.rgb);\r#else\nconst float tonemappingCalibration=1.590579;\rresult.rgb=1.0-exp2(-tonemappingCalibration*result.rgb);\r#endif\n#endif\nresult.rgb=toGammaSpace(result.rgb);\rresult.rgb=saturate(result.rgb);\r#ifdef CONTRAST\nvec3 resultHighContrast=result.rgb*result.rgb*(3.0-2.0*result.rgb);\rif (contrast<1.0) {\rresult.rgb=mix(vec3(0.5,0.5,0.5),result.rgb,contrast);\r} else {\rresult.rgb=mix(result.rgb,resultHighContrast,contrast-1.0);\r}\r#endif\n#ifdef COLORGRADING\nvec3 colorTransformInput=result.rgb*colorTransformSettings.xxx+colorTransformSettings.yyy;\r#ifdef COLORGRADING3D\nvec3 colorTransformOutput=texture(txColorTransform,colorTransformInput).rgb;\r#else\nvec3 colorTransformOutput=sampleTexture3D(txColorTransform,colorTransformInput,colorTransformSettings.yz).rgb;\r#endif\nresult.rgb=mix(result.rgb,colorTransformOutput,colorTransformSettings.www);\r#endif\n#ifdef COLORCURVES\nfloat luma=getLuminance(result.rgb);\rvec2 curveMix=clamp(vec2(luma*3.0-1.5,luma*-3.0+1.5),vec2(0.0),vec2(1.0));\rvec4 colorCurve=vCameraColorCurveNeutral+curveMix.x*vCameraColorCurvePositive-curveMix.y*vCameraColorCurveNegative;\rresult.rgb*=colorCurve.rgb;\rresult.rgb=mix(vec3(luma),result.rgb,colorCurve.a);\r#endif\n#ifdef DITHER\nfloat rand=getRand(gl_FragCoord.xy*vInverseScreenSize);\rfloat dither=mix(-ditherIntensity,ditherIntensity,rand);\rresult.rgb=saturate(result.rgb+vec3(dither));\r#endif\n#define CUSTOM_IMAGEPROCESSINGFUNCTIONS_UPDATERESULT_ATEND\nreturn result;\r}`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const imageProcessingFunctions = { name, shader };\n//# sourceMappingURL=imageProcessingFunctions.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nconst name = \"importanceSampling\";\nconst shader = `vec3 hemisphereCosSample(vec2 u) {\rfloat phi=2.*PI*u.x;\rfloat cosTheta2=1.-u.y;\rfloat cosTheta=sqrt(cosTheta2);\rfloat sinTheta=sqrt(1.-cosTheta2);\rreturn vec3(sinTheta*cos(phi),sinTheta*sin(phi),cosTheta);\r}\rvec3 hemisphereImportanceSampleDggx(vec2 u,float a) {\rfloat phi=2.*PI*u.x;\rfloat cosTheta2=(1.-u.y)/(1.+(a+1.)*((a-1.)*u.y));\rfloat cosTheta=sqrt(cosTheta2);\rfloat sinTheta=sqrt(1.-cosTheta2);\rreturn vec3(sinTheta*cos(phi),sinTheta*sin(phi),cosTheta);\r}\rvec3 hemisphereImportanceSampleDCharlie(vec2 u,float a) { \rfloat phi=2.*PI*u.x;\rfloat sinTheta=pow(u.y,a/(2.*a+1.));\rfloat cosTheta=sqrt(1.-sinTheta*sinTheta);\rreturn vec3(sinTheta*cos(phi),sinTheta*sin(phi),cosTheta);\r}`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const importanceSampling = { name, shader };\n//# sourceMappingURL=importanceSampling.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nconst name = \"instancesDeclaration\";\nconst shader = `#ifdef INSTANCES\nattribute vec4 world0;\rattribute vec4 world1;\rattribute vec4 world2;\rattribute vec4 world3;\r#ifdef INSTANCESCOLOR\nattribute vec4 instanceColor;\r#endif\n#if defined(THIN_INSTANCES) && !defined(WORLD_UBO)\nuniform mat4 world;\r#endif\n#if defined(VELOCITY) || defined(PREPASS_VELOCITY)\nattribute vec4 previousWorld0;\rattribute vec4 previousWorld1;\rattribute vec4 previousWorld2;\rattribute vec4 previousWorld3;\r#ifdef THIN_INSTANCES\nuniform mat4 previousWorld;\r#endif\n#endif\n#else\n#if !defined(WORLD_UBO)\nuniform mat4 world;\r#endif\n#if defined(VELOCITY) || defined(PREPASS_VELOCITY)\nuniform mat4 previousWorld;\r#endif\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const instancesDeclaration = { name, shader };\n//# sourceMappingURL=instancesDeclaration.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nconst name = \"instancesVertex\";\nconst shader = `#ifdef INSTANCES\nmat4 finalWorld=mat4(world0,world1,world2,world3);\r#if defined(PREPASS_VELOCITY) || defined(VELOCITY)\nmat4 finalPreviousWorld=mat4(previousWorld0,previousWorld1,previousWorld2,previousWorld3);\r#endif\n#ifdef THIN_INSTANCES\nfinalWorld=world*finalWorld;\r#if defined(PREPASS_VELOCITY) || defined(VELOCITY)\nfinalPreviousWorld=previousWorld*finalPreviousWorld;\r#endif\n#endif\n#else\nmat4 finalWorld=world;\r#if defined(PREPASS_VELOCITY) || defined(VELOCITY)\nmat4 finalPreviousWorld=previousWorld;\r#endif\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const instancesVertex = { name, shader };\n//# sourceMappingURL=instancesVertex.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nconst name = \"kernelBlurFragment2\";\nconst shader = `#ifdef DOF\nfactor=sampleCoC(sampleCenter+delta*KERNEL_DEP_OFFSET{X});\rcomputedWeight=KERNEL_DEP_WEIGHT{X}*factor;\rsumOfWeights+=computedWeight;\r#else\ncomputedWeight=KERNEL_DEP_WEIGHT{X};\r#endif\n#ifdef PACKEDFLOAT\nblend+=unpack(texture2D(textureSampler,sampleCenter+delta*KERNEL_DEP_OFFSET{X}))*computedWeight;\r#else\nblend+=texture2D(textureSampler,sampleCenter+delta*KERNEL_DEP_OFFSET{X})*computedWeight;\r#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const kernelBlurFragment2 = { name, shader };\n//# sourceMappingURL=kernelBlurFragment2.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nconst name = \"kernelBlurVaryingDeclaration\";\nconst shader = `varying vec2 sampleCoord{X};`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const kernelBlurVaryingDeclaration = { name, shader };\n//# sourceMappingURL=kernelBlurVaryingDeclaration.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nconst name = \"kernelBlurVertex\";\nconst shader = `sampleCoord{X}=sampleCenter+delta*KERNEL_OFFSET{X};`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const kernelBlurVertex = { name, shader };\n//# sourceMappingURL=kernelBlurVertex.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nconst name = \"lightFragment\";\nconst shader = `#ifdef LIGHT{X}\n#if defined(SHADOWONLY) || defined(LIGHTMAP) && defined(LIGHTMAPEXCLUDED{X}) && defined(LIGHTMAPNOSPECULAR{X})\n#else\n#ifdef PBR\n#ifdef SPOTLIGHT{X}\npreInfo=computePointAndSpotPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW);\r#elif defined(POINTLIGHT{X})\npreInfo=computePointAndSpotPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW);\r#elif defined(HEMILIGHT{X})\npreInfo=computeHemisphericPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW);\r#elif defined(DIRLIGHT{X})\npreInfo=computeDirectionalPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW);\r#endif\npreInfo.NdotV=NdotV;\r#ifdef SPOTLIGHT{X}\n#ifdef LIGHT_FALLOFF_GLTF{X}\npreInfo.attenuation=computeDistanceLightFalloff_GLTF(preInfo.lightDistanceSquared,light{X}.vLightFalloff.y);\rpreInfo.attenuation*=computeDirectionalLightFalloff_GLTF(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightFalloff.z,light{X}.vLightFalloff.w);\r#elif defined(LIGHT_FALLOFF_PHYSICAL{X})\npreInfo.attenuation=computeDistanceLightFalloff_Physical(preInfo.lightDistanceSquared);\rpreInfo.attenuation*=computeDirectionalLightFalloff_Physical(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightDirection.w);\r#elif defined(LIGHT_FALLOFF_STANDARD{X})\npreInfo.attenuation=computeDistanceLightFalloff_Standard(preInfo.lightOffset,light{X}.vLightFalloff.x);\rpreInfo.attenuation*=computeDirectionalLightFalloff_Standard(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightDirection.w,light{X}.vLightData.w);\r#else\npreInfo.attenuation=computeDistanceLightFalloff(preInfo.lightOffset,preInfo.lightDistanceSquared,light{X}.vLightFalloff.x,light{X}.vLightFalloff.y);\rpreInfo.attenuation*=computeDirectionalLightFalloff(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightDirection.w,light{X}.vLightData.w,light{X}.vLightFalloff.z,light{X}.vLightFalloff.w);\r#endif\n#elif defined(POINTLIGHT{X})\n#ifdef LIGHT_FALLOFF_GLTF{X}\npreInfo.attenuation=computeDistanceLightFalloff_GLTF(preInfo.lightDistanceSquared,light{X}.vLightFalloff.y);\r#elif defined(LIGHT_FALLOFF_PHYSICAL{X})\npreInfo.attenuation=computeDistanceLightFalloff_Physical(preInfo.lightDistanceSquared);\r#elif defined(LIGHT_FALLOFF_STANDARD{X})\npreInfo.attenuation=computeDistanceLightFalloff_Standard(preInfo.lightOffset,light{X}.vLightFalloff.x);\r#else\npreInfo.attenuation=computeDistanceLightFalloff(preInfo.lightOffset,preInfo.lightDistanceSquared,light{X}.vLightFalloff.x,light{X}.vLightFalloff.y);\r#endif\n#else\npreInfo.attenuation=1.0;\r#endif\n#ifdef HEMILIGHT{X}\npreInfo.roughness=roughness;\r#else\npreInfo.roughness=adjustRoughnessFromLightProperties(roughness,light{X}.vLightSpecular.a,preInfo.lightDistance);\r#endif\n#ifdef IRIDESCENCE\npreInfo.iridescenceIntensity=iridescenceIntensity;\r#endif\n#ifdef HEMILIGHT{X}\ninfo.diffuse=computeHemisphericDiffuseLighting(preInfo,light{X}.vLightDiffuse.rgb,light{X}.vLightGround);\r#elif defined(SS_TRANSLUCENCY)\ninfo.diffuse=computeDiffuseAndTransmittedLighting(preInfo,light{X}.vLightDiffuse.rgb,subSurfaceOut.transmittance);\r#else\ninfo.diffuse=computeDiffuseLighting(preInfo,light{X}.vLightDiffuse.rgb);\r#endif\n#ifdef SPECULARTERM\n#ifdef ANISOTROPIC\ninfo.specular=computeAnisotropicSpecularLighting(preInfo,viewDirectionW,normalW,anisotropicOut.anisotropicTangent,anisotropicOut.anisotropicBitangent,anisotropicOut.anisotropy,clearcoatOut.specularEnvironmentR0,specularEnvironmentR90,AARoughnessFactors.x,light{X}.vLightDiffuse.rgb);\r#else\ninfo.specular=computeSpecularLighting(preInfo,normalW,clearcoatOut.specularEnvironmentR0,specularEnvironmentR90,AARoughnessFactors.x,light{X}.vLightDiffuse.rgb);\r#endif\n#endif\n#ifdef SHEEN\n#ifdef SHEEN_LINKWITHALBEDO\npreInfo.roughness=sheenOut.sheenIntensity;\r#else\n#ifdef HEMILIGHT{X}\npreInfo.roughness=sheenOut.sheenRoughness;\r#else\npreInfo.roughness=adjustRoughnessFromLightProperties(sheenOut.sheenRoughness,light{X}.vLightSpecular.a,preInfo.lightDistance);\r#endif\n#endif\ninfo.sheen=computeSheenLighting(preInfo,normalW,sheenOut.sheenColor,specularEnvironmentR90,AARoughnessFactors.x,light{X}.vLightDiffuse.rgb);\r#endif\n#ifdef CLEARCOAT\n#ifdef HEMILIGHT{X}\npreInfo.roughness=clearcoatOut.clearCoatRoughness;\r#else\npreInfo.roughness=adjustRoughnessFromLightProperties(clearcoatOut.clearCoatRoughness,light{X}.vLightSpecular.a,preInfo.lightDistance);\r#endif\ninfo.clearCoat=computeClearCoatLighting(preInfo,clearcoatOut.clearCoatNormalW,clearcoatOut.clearCoatAARoughnessFactors.x,clearcoatOut.clearCoatIntensity,light{X}.vLightDiffuse.rgb);\r#ifdef CLEARCOAT_TINT\nabsorption=computeClearCoatLightingAbsorption(clearcoatOut.clearCoatNdotVRefract,preInfo.L,clearcoatOut.clearCoatNormalW,clearcoatOut.clearCoatColor,clearcoatOut.clearCoatThickness,clearcoatOut.clearCoatIntensity);\rinfo.diffuse*=absorption;\r#ifdef SPECULARTERM\ninfo.specular*=absorption;\r#endif\n#endif\ninfo.diffuse*=info.clearCoat.w;\r#ifdef SPECULARTERM\ninfo.specular*=info.clearCoat.w;\r#endif\n#ifdef SHEEN\ninfo.sheen*=info.clearCoat.w;\r#endif\n#endif\n#else\n#ifdef SPOTLIGHT{X}\ninfo=computeSpotLighting(viewDirectionW,normalW,light{X}.vLightData,light{X}.vLightDirection,light{X}.vLightDiffuse.rgb,light{X}.vLightSpecular.rgb,light{X}.vLightDiffuse.a,glossiness);\r#elif defined(HEMILIGHT{X})\ninfo=computeHemisphericLighting(viewDirectionW,normalW,light{X}.vLightData,light{X}.vLightDiffuse.rgb,light{X}.vLightSpecular.rgb,light{X}.vLightGround,glossiness);\r#elif defined(POINTLIGHT{X}) || defined(DIRLIGHT{X})\ninfo=computeLighting(viewDirectionW,normalW,light{X}.vLightData,light{X}.vLightDiffuse.rgb,light{X}.vLightSpecular.rgb,light{X}.vLightDiffuse.a,glossiness);\r#endif\n#endif\n#ifdef PROJECTEDLIGHTTEXTURE{X}\ninfo.diffuse*=computeProjectionTextureDiffuseLighting(projectionLightSampler{X},textureProjectionMatrix{X});\r#endif\n#endif\n#ifdef SHADOW{X}\n#ifdef SHADOWCSM{X}\nfor (int i=0; i<SHADOWCSMNUM_CASCADES{X}; i++) \r{\r#ifdef SHADOWCSM_RIGHTHANDED{X}\ndiff{X}=viewFrustumZ{X}[i]+vPositionFromCamera{X}.z;\r#else\ndiff{X}=viewFrustumZ{X}[i]-vPositionFromCamera{X}.z;\r#endif\nif (diff{X}>=0.) {\rindex{X}=i;\rbreak;\r}\r}\r#ifdef SHADOWCSMUSESHADOWMAXZ{X}\nif (index{X}>=0)\r#endif\n{\r#if defined(SHADOWPCF{X})\n#if defined(SHADOWLOWQUALITY{X})\nshadow=computeShadowWithCSMPCF1(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\r#elif defined(SHADOWMEDIUMQUALITY{X})\nshadow=computeShadowWithCSMPCF3(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\r#else\nshadow=computeShadowWithCSMPCF5(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\r#endif\n#elif defined(SHADOWPCSS{X})\n#if defined(SHADOWLOWQUALITY{X})\nshadow=computeShadowWithCSMPCSS16(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});\r#elif defined(SHADOWMEDIUMQUALITY{X})\nshadow=computeShadowWithCSMPCSS32(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});\r#else\nshadow=computeShadowWithCSMPCSS64(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});\r#endif\n#else\nshadow=computeShadowCSM(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\r#endif\n#ifdef SHADOWCSMDEBUG{X}\nshadowDebug{X}=vec3(shadow)*vCascadeColorsMultiplier{X}[index{X}];\r#endif\n#ifndef SHADOWCSMNOBLEND{X}\nfloat frustumLength=frustumLengths{X}[index{X}];\rfloat diffRatio=clamp(diff{X}/frustumLength,0.,1.)*cascadeBlendFactor{X};\rif (index{X}<(SHADOWCSMNUM_CASCADES{X}-1) && diffRatio<1.)\r{\rindex{X}+=1;\rfloat nextShadow=0.;\r#if defined(SHADOWPCF{X})\n#if defined(SHADOWLOWQUALITY{X})\nnextShadow=computeShadowWithCSMPCF1(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\r#elif defined(SHADOWMEDIUMQUALITY{X})\nnextShadow=computeShadowWithCSMPCF3(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\r#else\nnextShadow=computeShadowWithCSMPCF5(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\r#endif\n#elif defined(SHADOWPCSS{X})\n#if defined(SHADOWLOWQUALITY{X})\nnextShadow=computeShadowWithCSMPCSS16(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});\r#elif defined(SHADOWMEDIUMQUALITY{X})\nnextShadow=computeShadowWithCSMPCSS32(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});\r#else\nnextShadow=computeShadowWithCSMPCSS64(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});\r#endif\n#else\nnextShadow=computeShadowCSM(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\r#endif\nshadow=mix(nextShadow,shadow,diffRatio);\r#ifdef SHADOWCSMDEBUG{X}\nshadowDebug{X}=mix(vec3(nextShadow)*vCascadeColorsMultiplier{X}[index{X}],shadowDebug{X},diffRatio);\r#endif\n}\r#endif\n}\r#elif defined(SHADOWCLOSEESM{X})\n#if defined(SHADOWCUBE{X})\nshadow=computeShadowWithCloseESMCube(light{X}.vLightData.xyz,shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.z,light{X}.depthValues);\r#else\nshadow=computeShadowWithCloseESM(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.z,light{X}.shadowsInfo.w);\r#endif\n#elif defined(SHADOWESM{X})\n#if defined(SHADOWCUBE{X})\nshadow=computeShadowWithESMCube(light{X}.vLightData.xyz,shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.z,light{X}.depthValues);\r#else\nshadow=computeShadowWithESM(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.z,light{X}.shadowsInfo.w);\r#endif\n#elif defined(SHADOWPOISSON{X})\n#if defined(SHADOWCUBE{X})\nshadow=computeShadowWithPoissonSamplingCube(light{X}.vLightData.xyz,shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.x,light{X}.depthValues);\r#else\nshadow=computeShadowWithPoissonSampling(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\r#endif\n#elif defined(SHADOWPCF{X})\n#if defined(SHADOWLOWQUALITY{X})\nshadow=computeShadowWithPCF1(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\r#elif defined(SHADOWMEDIUMQUALITY{X})\nshadow=computeShadowWithPCF3(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\r#else\nshadow=computeShadowWithPCF5(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\r#endif\n#elif defined(SHADOWPCSS{X})\n#if defined(SHADOWLOWQUALITY{X})\nshadow=computeShadowWithPCSS16(vPositionFromLight{X},vDepthMetric{X},depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\r#elif defined(SHADOWMEDIUMQUALITY{X})\nshadow=computeShadowWithPCSS32(vPositionFromLight{X},vDepthMetric{X},depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\r#else\nshadow=computeShadowWithPCSS64(vPositionFromLight{X},vDepthMetric{X},depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\r#endif\n#else\n#if defined(SHADOWCUBE{X})\nshadow=computeShadowCube(light{X}.vLightData.xyz,shadowSampler{X},light{X}.shadowsInfo.x,light{X}.depthValues);\r#else\nshadow=computeShadow(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\r#endif\n#endif\n#ifdef SHADOWONLY\n#ifndef SHADOWINUSE\n#define SHADOWINUSE\n#endif\nglobalShadow+=shadow;\rshadowLightCount+=1.0;\r#endif\n#else\nshadow=1.;\r#endif\n#ifndef SHADOWONLY\n#ifdef CUSTOMUSERLIGHTING\ndiffuseBase+=computeCustomDiffuseLighting(info,diffuseBase,shadow);\r#ifdef SPECULARTERM\nspecularBase+=computeCustomSpecularLighting(info,specularBase,shadow);\r#endif\n#elif defined(LIGHTMAP) && defined(LIGHTMAPEXCLUDED{X})\ndiffuseBase+=lightmapColor.rgb*shadow;\r#ifdef SPECULARTERM\n#ifndef LIGHTMAPNOSPECULAR{X}\nspecularBase+=info.specular*shadow*lightmapColor.rgb;\r#endif\n#endif\n#ifdef CLEARCOAT\n#ifndef LIGHTMAPNOSPECULAR{X}\nclearCoatBase+=info.clearCoat.rgb*shadow*lightmapColor.rgb;\r#endif\n#endif\n#ifdef SHEEN\n#ifndef LIGHTMAPNOSPECULAR{X}\nsheenBase+=info.sheen.rgb*shadow;\r#endif\n#endif\n#else\n#ifdef SHADOWCSMDEBUG{X}\ndiffuseBase+=info.diffuse*shadowDebug{X};\r#else \ndiffuseBase+=info.diffuse*shadow;\r#endif\n#ifdef SPECULARTERM\nspecularBase+=info.specular*shadow;\r#endif\n#ifdef CLEARCOAT\nclearCoatBase+=info.clearCoat.rgb*shadow;\r#endif\n#ifdef SHEEN\nsheenBase+=info.sheen.rgb*shadow;\r#endif\n#endif\n#endif\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const lightFragment = { name, shader };\n//# sourceMappingURL=lightFragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nconst name = \"lightUboDeclaration\";\nconst shader = `#ifdef LIGHT{X}\nuniform Light{X}\r{\rvec4 vLightData;\rvec4 vLightDiffuse;\rvec4 vLightSpecular;\r#ifdef SPOTLIGHT{X}\nvec4 vLightDirection;\rvec4 vLightFalloff;\r#elif defined(POINTLIGHT{X})\nvec4 vLightFalloff;\r#elif defined(HEMILIGHT{X})\nvec3 vLightGround;\r#endif\nvec4 shadowsInfo;\rvec2 depthValues;\r} light{X};\r#ifdef PROJECTEDLIGHTTEXTURE{X}\nuniform mat4 textureProjectionMatrix{X};\runiform sampler2D projectionLightSampler{X};\r#endif\n#ifdef SHADOW{X}\n#ifdef SHADOWCSM{X}\nuniform mat4 lightMatrix{X}[SHADOWCSMNUM_CASCADES{X}];\runiform float viewFrustumZ{X}[SHADOWCSMNUM_CASCADES{X}];\runiform float frustumLengths{X}[SHADOWCSMNUM_CASCADES{X}];\runiform float cascadeBlendFactor{X};\rvarying vec4 vPositionFromLight{X}[SHADOWCSMNUM_CASCADES{X}];\rvarying float vDepthMetric{X}[SHADOWCSMNUM_CASCADES{X}];\rvarying vec4 vPositionFromCamera{X};\r#if defined(SHADOWPCSS{X})\nuniform highp sampler2DArrayShadow shadowSampler{X};\runiform highp sampler2DArray depthSampler{X};\runiform vec2 lightSizeUVCorrection{X}[SHADOWCSMNUM_CASCADES{X}];\runiform float depthCorrection{X}[SHADOWCSMNUM_CASCADES{X}];\runiform float penumbraDarkness{X};\r#elif defined(SHADOWPCF{X})\nuniform highp sampler2DArrayShadow shadowSampler{X};\r#else\nuniform highp sampler2DArray shadowSampler{X};\r#endif\n#ifdef SHADOWCSMDEBUG{X}\nconst vec3 vCascadeColorsMultiplier{X}[8]=vec3[8]\r(\rvec3 ( 1.5,0.0,0.0 ),\rvec3 ( 0.0,1.5,0.0 ),\rvec3 ( 0.0,0.0,5.5 ),\rvec3 ( 1.5,0.0,5.5 ),\rvec3 ( 1.5,1.5,0.0 ),\rvec3 ( 1.0,1.0,1.0 ),\rvec3 ( 0.0,1.0,5.5 ),\rvec3 ( 0.5,3.5,0.75 )\r);\rvec3 shadowDebug{X};\r#endif\n#ifdef SHADOWCSMUSESHADOWMAXZ{X}\nint index{X}=-1;\r#else\nint index{X}=SHADOWCSMNUM_CASCADES{X}-1;\r#endif\nfloat diff{X}=0.;\r#elif defined(SHADOWCUBE{X})\nuniform samplerCube shadowSampler{X}; \r#else\nvarying vec4 vPositionFromLight{X};\rvarying float vDepthMetric{X};\r#if defined(SHADOWPCSS{X})\nuniform highp sampler2DShadow shadowSampler{X};\runiform highp sampler2D depthSampler{X};\r#elif defined(SHADOWPCF{X})\nuniform highp sampler2DShadow shadowSampler{X};\r#else\nuniform sampler2D shadowSampler{X};\r#endif\nuniform mat4 lightMatrix{X};\r#endif\n#endif\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const lightUboDeclaration = { name, shader };\n//# sourceMappingURL=lightUboDeclaration.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nconst name = \"mainUVVaryingDeclaration\";\nconst shader = `#ifdef MAINUV{X}\nvarying vec2 vMainUV{X};\r#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const mainUVVaryingDeclaration = { name, shader };\n//# sourceMappingURL=mainUVVaryingDeclaration.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nconst name = \"meshUboDeclaration\";\nconst shader = `#ifdef WEBGL2\nuniform mat4 world;\runiform float visibility;\r#else\nlayout(std140,column_major) uniform;\runiform Mesh\r{\rmat4 world;\rfloat visibility;\r};\r#endif\n#define WORLD_UBO\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const meshUboDeclaration = { name, shader };\n//# sourceMappingURL=meshUboDeclaration.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nconst name = \"morphTargetsVertex\";\nconst shader = `#ifdef MORPHTARGETS\n#ifdef MORPHTARGETS_TEXTURE \nvertexID=float(gl_VertexID)*morphTargetTextureInfo.x;\rpositionUpdated+=(readVector3FromRawSampler({X},vertexID)-position)*morphTargetInfluences[{X}];\rvertexID+=1.0;\r#ifdef MORPHTARGETS_NORMAL\nnormalUpdated+=(readVector3FromRawSampler({X},vertexID) -normal)*morphTargetInfluences[{X}];\rvertexID+=1.0;\r#endif\n#ifdef MORPHTARGETS_UV\nuvUpdated+=(readVector3FromRawSampler({X},vertexID).xy-uv)*morphTargetInfluences[{X}];\rvertexID+=1.0;\r#endif\n#ifdef MORPHTARGETS_TANGENT\ntangentUpdated.xyz+=(readVector3FromRawSampler({X},vertexID) -tangent.xyz)*morphTargetInfluences[{X}];\r#endif\n#else\npositionUpdated+=(position{X}-position)*morphTargetInfluences[{X}];\r#ifdef MORPHTARGETS_NORMAL\nnormalUpdated+=(normal{X}-normal)*morphTargetInfluences[{X}];\r#endif\n#ifdef MORPHTARGETS_TANGENT\ntangentUpdated.xyz+=(tangent{X}-tangent.xyz)*morphTargetInfluences[{X}];\r#endif\n#ifdef MORPHTARGETS_UV\nuvUpdated+=(uv_{X}-uv)*morphTargetInfluences[{X}];\r#endif\n#endif\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const morphTargetsVertex = { name, shader };\n//# sourceMappingURL=morphTargetsVertex.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nconst name = \"morphTargetsVertexDeclaration\";\nconst shader = `#ifdef MORPHTARGETS\n#ifndef MORPHTARGETS_TEXTURE\nattribute vec3 position{X};\r#ifdef MORPHTARGETS_NORMAL\nattribute vec3 normal{X};\r#endif\n#ifdef MORPHTARGETS_TANGENT\nattribute vec3 tangent{X};\r#endif\n#ifdef MORPHTARGETS_UV\nattribute vec2 uv_{X};\r#endif\n#endif\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const morphTargetsVertexDeclaration = { name, shader };\n//# sourceMappingURL=morphTargetsVertexDeclaration.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nconst name = \"packingFunctions\";\nconst shader = `vec4 pack(float depth)\r{\rconst vec4 bit_shift=vec4(255.0*255.0*255.0,255.0*255.0,255.0,1.0);\rconst vec4 bit_mask=vec4(0.0,1.0/255.0,1.0/255.0,1.0/255.0);\rvec4 res=fract(depth*bit_shift);\rres-=res.xxyz*bit_mask;\rreturn res;\r}\rfloat unpack(vec4 color)\r{\rconst vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);\rreturn dot(color,bit_shift);\r}`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const packingFunctions = { name, shader };\n//# sourceMappingURL=packingFunctions.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nconst name = \"pbrBRDFFunctions\";\nconst shader = `#define FRESNEL_MAXIMUM_ON_ROUGH 0.25\n#ifdef MS_BRDF_ENERGY_CONSERVATION\nvec3 getEnergyConservationFactor(const vec3 specularEnvironmentR0,const vec3 environmentBrdf) {\rreturn 1.0+specularEnvironmentR0*(1.0/environmentBrdf.y-1.0);\r}\r#endif\n#ifdef ENVIRONMENTBRDF\nvec3 getBRDFLookup(float NdotV,float perceptualRoughness) {\rvec2 UV=vec2(NdotV,perceptualRoughness);\rvec4 brdfLookup=texture2D(environmentBrdfSampler,UV);\r#ifdef ENVIRONMENTBRDF_RGBD\nbrdfLookup.rgb=fromRGBD(brdfLookup.rgba);\r#endif\nreturn brdfLookup.rgb;\r}\rvec3 getReflectanceFromBRDFLookup(const vec3 specularEnvironmentR0,const vec3 specularEnvironmentR90,const vec3 environmentBrdf) {\r#ifdef BRDF_V_HEIGHT_CORRELATED\nvec3 reflectance=(specularEnvironmentR90-specularEnvironmentR0)*environmentBrdf.x+specularEnvironmentR0*environmentBrdf.y;\r#else\nvec3 reflectance=specularEnvironmentR0*environmentBrdf.x+specularEnvironmentR90*environmentBrdf.y;\r#endif\nreturn reflectance;\r}\rvec3 getReflectanceFromBRDFLookup(const vec3 specularEnvironmentR0,const vec3 environmentBrdf) {\r#ifdef BRDF_V_HEIGHT_CORRELATED\nvec3 reflectance=mix(environmentBrdf.xxx,environmentBrdf.yyy,specularEnvironmentR0);\r#else\nvec3 reflectance=specularEnvironmentR0*environmentBrdf.x+environmentBrdf.y;\r#endif\nreturn reflectance;\r}\r#endif\n/* NOT USED\r#if defined(SHEEN) && defined(SHEEN_SOFTER)\nfloat getBRDFLookupCharlieSheen(float NdotV,float perceptualRoughness)\r{\rfloat c=1.0-NdotV;\rfloat c3=c*c*c;\rreturn 0.65584461*c3+1.0/(4.16526551+exp(-7.97291361*perceptualRoughness+6.33516894));\r}\r#endif\n*/\r#if !defined(ENVIRONMENTBRDF) || defined(REFLECTIONMAP_SKYBOX) || defined(ALPHAFRESNEL)\nvec3 getReflectanceFromAnalyticalBRDFLookup_Jones(float VdotN,vec3 reflectance0,vec3 reflectance90,float smoothness)\r{\rfloat weight=mix(FRESNEL_MAXIMUM_ON_ROUGH,1.0,smoothness);\rreturn reflectance0+weight*(reflectance90-reflectance0)*pow5(saturate(1.0-VdotN));\r}\r#endif\n#if defined(SHEEN) && defined(ENVIRONMENTBRDF)\n/**\r* The sheen BRDF not containing F can be easily stored in the blue channel of the BRDF texture.\r* The blue channel contains DCharlie*VAshikhmin*NdotL as a lokkup table\r*/\rvec3 getSheenReflectanceFromBRDFLookup(const vec3 reflectance0,const vec3 environmentBrdf) {\rvec3 sheenEnvironmentReflectance=reflectance0*environmentBrdf.b;\rreturn sheenEnvironmentReflectance;\r}\r#endif\nvec3 fresnelSchlickGGX(float VdotH,vec3 reflectance0,vec3 reflectance90)\r{\rreturn reflectance0+(reflectance90-reflectance0)*pow5(1.0-VdotH);\r}\rfloat fresnelSchlickGGX(float VdotH,float reflectance0,float reflectance90)\r{\rreturn reflectance0+(reflectance90-reflectance0)*pow5(1.0-VdotH);\r}\r#ifdef CLEARCOAT\nvec3 getR0RemappedForClearCoat(vec3 f0) {\r#ifdef CLEARCOAT_DEFAULTIOR\n#ifdef MOBILE\nreturn saturate(f0*(f0*0.526868+0.529324)-0.0482256);\r#else\nreturn saturate(f0*(f0*(0.941892-0.263008*f0)+0.346479)-0.0285998);\r#endif\n#else\nvec3 s=sqrt(f0);\rvec3 t=(vClearCoatRefractionParams.z+vClearCoatRefractionParams.w*s)/(vClearCoatRefractionParams.w+vClearCoatRefractionParams.z*s);\rreturn square(t);\r#endif\n}\r#endif\n#ifdef IRIDESCENCE\nconst mat3 XYZ_TO_REC709=mat3(\r3.2404542,-0.9692660, 0.0556434,\r-1.5371385, 1.8760108,-0.2040259,\r-0.4985314, 0.0415560, 1.0572252\r);\rvec3 getIORTfromAirToSurfaceR0(vec3 f0) {\rvec3 sqrtF0=sqrt(f0);\rreturn (1.+sqrtF0)/(1.-sqrtF0);\r}\rvec3 getR0fromIORs(vec3 iorT,float iorI) {\rreturn square((iorT-vec3(iorI))/(iorT+vec3(iorI)));\r}\rfloat getR0fromIORs(float iorT,float iorI) {\rreturn square((iorT-iorI)/(iorT+iorI));\r}\rvec3 evalSensitivity(float opd,vec3 shift) {\rfloat phase=2.0*PI*opd*1.0e-9;\rconst vec3 val=vec3(5.4856e-13,4.4201e-13,5.2481e-13);\rconst vec3 pos=vec3(1.6810e+06,1.7953e+06,2.2084e+06);\rconst vec3 var=vec3(4.3278e+09,9.3046e+09,6.6121e+09);\rvec3 xyz=val*sqrt(2.0*PI*var)*cos(pos*phase+shift)*exp(-square(phase)*var);\rxyz.x+=9.7470e-14*sqrt(2.0*PI*4.5282e+09)*cos(2.2399e+06*phase+shift[0])*exp(-4.5282e+09*square(phase));\rxyz/=1.0685e-7;\rvec3 srgb=XYZ_TO_REC709*xyz;\rreturn srgb;\r}\rvec3 evalIridescence(float outsideIOR,float eta2,float cosTheta1,float thinFilmThickness,vec3 baseF0) {\rvec3 I=vec3(1.0);\rfloat iridescenceIOR=mix(outsideIOR,eta2,smoothstep(0.0,0.03,thinFilmThickness));\rfloat sinTheta2Sq=square(outsideIOR/iridescenceIOR)*(1.0-square(cosTheta1));\rfloat cosTheta2Sq=1.0-sinTheta2Sq;\rif (cosTheta2Sq<0.0) {\rreturn I;\r}\rfloat cosTheta2=sqrt(cosTheta2Sq);\rfloat R0=getR0fromIORs(iridescenceIOR,outsideIOR);\rfloat R12=fresnelSchlickGGX(cosTheta1,R0,1.);\rfloat R21=R12;\rfloat T121=1.0-R12;\rfloat phi12=0.0;\rif (iridescenceIOR<outsideIOR) phi12=PI;\rfloat phi21=PI-phi12;\rvec3 baseIOR=getIORTfromAirToSurfaceR0(clamp(baseF0,0.0,0.9999)); \rvec3 R1=getR0fromIORs(baseIOR,iridescenceIOR);\rvec3 R23=fresnelSchlickGGX(cosTheta2,R1,vec3(1.));\rvec3 phi23=vec3(0.0);\rif (baseIOR[0]<iridescenceIOR) phi23[0]=PI;\rif (baseIOR[1]<iridescenceIOR) phi23[1]=PI;\rif (baseIOR[2]<iridescenceIOR) phi23[2]=PI;\rfloat opd=2.0*iridescenceIOR*thinFilmThickness*cosTheta2;\rvec3 phi=vec3(phi21)+phi23;\rvec3 R123=clamp(R12*R23,1e-5,0.9999);\rvec3 r123=sqrt(R123);\rvec3 Rs=square(T121)*R23/(vec3(1.0)-R123);\rvec3 C0=R12+Rs;\rI=C0;\rvec3 Cm=Rs-T121;\rfor (int m=1; m<=2; ++m)\r{\rCm*=r123;\rvec3 Sm=2.0*evalSensitivity(float(m)*opd,float(m)*phi);\rI+=Cm*Sm;\r}\rreturn max(I,vec3(0.0));\r}\r#endif\nfloat normalDistributionFunction_TrowbridgeReitzGGX(float NdotH,float alphaG)\r{\rfloat a2=square(alphaG);\rfloat d=NdotH*NdotH*(a2-1.0)+1.0;\rreturn a2/(PI*d*d);\r}\r#ifdef SHEEN\nfloat normalDistributionFunction_CharlieSheen(float NdotH,float alphaG)\r{\rfloat invR=1./alphaG;\rfloat cos2h=NdotH*NdotH;\rfloat sin2h=1.-cos2h;\rreturn (2.+invR)*pow(sin2h,invR*.5)/(2.*PI);\r}\r#endif\n#ifdef ANISOTROPIC\nfloat normalDistributionFunction_BurleyGGX_Anisotropic(float NdotH,float TdotH,float BdotH,const vec2 alphaTB) {\rfloat a2=alphaTB.x*alphaTB.y;\rvec3 v=vec3(alphaTB.y*TdotH,alphaTB.x *BdotH,a2*NdotH);\rfloat v2=dot(v,v);\rfloat w2=a2/v2;\rreturn a2*w2*w2*RECIPROCAL_PI;\r}\r#endif\n#ifdef BRDF_V_HEIGHT_CORRELATED\nfloat smithVisibility_GGXCorrelated(float NdotL,float NdotV,float alphaG) {\r#ifdef MOBILE\nfloat GGXV=NdotL*(NdotV*(1.0-alphaG)+alphaG);\rfloat GGXL=NdotV*(NdotL*(1.0-alphaG)+alphaG);\rreturn 0.5/(GGXV+GGXL);\r#else\nfloat a2=alphaG*alphaG;\rfloat GGXV=NdotL*sqrt(NdotV*(NdotV-a2*NdotV)+a2);\rfloat GGXL=NdotV*sqrt(NdotL*(NdotL-a2*NdotL)+a2);\rreturn 0.5/(GGXV+GGXL);\r#endif\n}\r#else\nfloat smithVisibilityG1_TrowbridgeReitzGGXFast(float dot,float alphaG)\r{\r#ifdef MOBILE\nreturn 1.0/(dot+alphaG+(1.0-alphaG)*dot ));\r#else\nfloat alphaSquared=alphaG*alphaG;\rreturn 1.0/(dot+sqrt(alphaSquared+(1.0-alphaSquared)*dot*dot));\r#endif\n}\rfloat smithVisibility_TrowbridgeReitzGGXFast(float NdotL,float NdotV,float alphaG)\r{\rfloat visibility=smithVisibilityG1_TrowbridgeReitzGGXFast(NdotL,alphaG)*smithVisibilityG1_TrowbridgeReitzGGXFast(NdotV,alphaG);\rreturn visibility;\r}\r#endif\n#ifdef ANISOTROPIC\nfloat smithVisibility_GGXCorrelated_Anisotropic(float NdotL,float NdotV,float TdotV,float BdotV,float TdotL,float BdotL,const vec2 alphaTB) {\rfloat lambdaV=NdotL*length(vec3(alphaTB.x*TdotV,alphaTB.y*BdotV,NdotV));\rfloat lambdaL=NdotV*length(vec3(alphaTB.x*TdotL,alphaTB.y*BdotL,NdotL));\rfloat v=0.5/(lambdaV+lambdaL);\rreturn v;\r}\r#endif\n#ifdef CLEARCOAT\nfloat visibility_Kelemen(float VdotH) {\rreturn 0.25/(VdotH*VdotH); \r}\r#endif\n#ifdef SHEEN\nfloat visibility_Ashikhmin(float NdotL,float NdotV)\r{\rreturn 1./(4.*(NdotL+NdotV-NdotL*NdotV));\r}\r/* NOT USED\r#ifdef SHEEN_SOFTER\nfloat l(float x,float alphaG)\r{\rfloat oneMinusAlphaSq=(1.0-alphaG)*(1.0-alphaG);\rfloat a=mix(21.5473,25.3245,oneMinusAlphaSq);\rfloat b=mix(3.82987,3.32435,oneMinusAlphaSq);\rfloat c=mix(0.19823,0.16801,oneMinusAlphaSq);\rfloat d=mix(-1.97760,-1.27393,oneMinusAlphaSq);\rfloat e=mix(-4.32054,-4.85967,oneMinusAlphaSq);\rreturn a/(1.0+b*pow(x,c))+d*x+e;\r}\rfloat lambdaSheen(float cosTheta,float alphaG)\r{\rreturn abs(cosTheta)<0.5 ? exp(l(cosTheta,alphaG)) : exp(2.0*l(0.5,alphaG)-l(1.0-cosTheta,alphaG));\r}\rfloat visibility_CharlieSheen(float NdotL,float NdotV,float alphaG)\r{\rfloat G=1.0/(1.0+lambdaSheen(NdotV,alphaG)+lambdaSheen(NdotL,alphaG));\rreturn G/(4.0*NdotV*NdotL);\r}\r#endif\n*/\r#endif\nfloat diffuseBRDF_Burley(float NdotL,float NdotV,float VdotH,float roughness) {\rfloat diffuseFresnelNV=pow5(saturateEps(1.0-NdotL));\rfloat diffuseFresnelNL=pow5(saturateEps(1.0-NdotV));\rfloat diffuseFresnel90=0.5+2.0*VdotH*VdotH*roughness;\rfloat fresnel =\r(1.0+(diffuseFresnel90-1.0)*diffuseFresnelNL) *\r(1.0+(diffuseFresnel90-1.0)*diffuseFresnelNV);\rreturn fresnel/PI;\r}\r#ifdef SS_TRANSLUCENCY\nvec3 transmittanceBRDF_Burley(const vec3 tintColor,const vec3 diffusionDistance,float thickness) {\rvec3 S=1./maxEps(diffusionDistance);\rvec3 temp=exp((-0.333333333*thickness)*S);\rreturn tintColor.rgb*0.25*(temp*temp*temp+3.0*temp);\r}\rfloat computeWrappedDiffuseNdotL(float NdotL,float w) {\rfloat t=1.0+w;\rfloat invt2=1.0/square(t);\rreturn saturate((NdotL+w)*invt2);\r}\r#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const pbrBRDFFunctions = { name, shader };\n//# sourceMappingURL=pbrBRDFFunctions.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nconst name = \"pbrBlockAlbedoOpacity\";\nconst shader = `struct albedoOpacityOutParams\r{\rvec3 surfaceAlbedo;\rfloat alpha;\r};\r#define pbr_inline\nvoid albedoOpacityBlock(\rin vec4 vAlbedoColor,\r#ifdef ALBEDO\nin vec4 albedoTexture,\rin vec2 albedoInfos,\r#endif\n#ifdef OPACITY\nin vec4 opacityMap,\rin vec2 vOpacityInfos,\r#endif\n#ifdef DETAIL\nin vec4 detailColor,\rin vec4 vDetailInfos,\r#endif\nout albedoOpacityOutParams outParams\r)\r{\rvec3 surfaceAlbedo=vAlbedoColor.rgb;\rfloat alpha=vAlbedoColor.a;\r#ifdef ALBEDO\n#if defined(ALPHAFROMALBEDO) || defined(ALPHATEST)\nalpha*=albedoTexture.a;\r#endif\n#ifdef GAMMAALBEDO\nsurfaceAlbedo*=toLinearSpace(albedoTexture.rgb);\r#else\nsurfaceAlbedo*=albedoTexture.rgb;\r#endif\nsurfaceAlbedo*=albedoInfos.y;\r#endif\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nsurfaceAlbedo*=vColor.rgb;\r#endif\n#ifdef DETAIL\nfloat detailAlbedo=2.0*mix(0.5,detailColor.r,vDetailInfos.y);\rsurfaceAlbedo.rgb=surfaceAlbedo.rgb*detailAlbedo*detailAlbedo; \r#endif\n#define CUSTOM_FRAGMENT_UPDATE_ALBEDO\n#ifdef OPACITY\n#ifdef OPACITYRGB\nalpha=getLuminance(opacityMap.rgb);\r#else\nalpha*=opacityMap.a;\r#endif\nalpha*=vOpacityInfos.y;\r#endif\n#if defined(VERTEXALPHA) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nalpha*=vColor.a;\r#endif\n#if !defined(SS_LINKREFRACTIONTOTRANSPARENCY) && !defined(ALPHAFRESNEL)\n#ifdef ALPHATEST\nif (alpha<ALPHATESTVALUE)\rdiscard;\r#ifndef ALPHABLEND\nalpha=1.0;\r#endif\n#endif\n#endif\noutParams.surfaceAlbedo=surfaceAlbedo;\routParams.alpha=alpha;\r}\r`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const pbrBlockAlbedoOpacity = { name, shader };\n//# sourceMappingURL=pbrBlockAlbedoOpacity.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nconst name = \"pbrBlockAlphaFresnel\";\nconst shader = `#ifdef ALPHAFRESNEL\n#if defined(ALPHATEST) || defined(ALPHABLEND)\nstruct alphaFresnelOutParams\r{\rfloat alpha;\r};\r#define pbr_inline\nvoid alphaFresnelBlock(\rin vec3 normalW,\rin vec3 viewDirectionW,\rin float alpha,\rin float microSurface,\rout alphaFresnelOutParams outParams\r)\r{\rfloat opacityPerceptual=alpha;\r#ifdef LINEARALPHAFRESNEL\nfloat opacity0=opacityPerceptual;\r#else\nfloat opacity0=opacityPerceptual*opacityPerceptual;\r#endif\nfloat opacity90=fresnelGrazingReflectance(opacity0);\rvec3 normalForward=faceforward(normalW,-viewDirectionW,normalW);\routParams.alpha=getReflectanceFromAnalyticalBRDFLookup_Jones(saturate(dot(viewDirectionW,normalForward)),vec3(opacity0),vec3(opacity90),sqrt(microSurface)).x;\r#ifdef ALPHATEST\nif (outParams.alpha<ALPHATESTVALUE)\rdiscard;\r#ifndef ALPHABLEND\noutParams.alpha=1.0;\r#endif\n#endif\n}\r#endif\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const pbrBlockAlphaFresnel = { name, shader };\n//# sourceMappingURL=pbrBlockAlphaFresnel.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nconst name = \"pbrBlockAmbientOcclusion\";\nconst shader = `struct ambientOcclusionOutParams\r{\rvec3 ambientOcclusionColor;\r#if DEBUGMODE>0\nvec3 ambientOcclusionColorMap;\r#endif\n};\r#define pbr_inline\nvoid ambientOcclusionBlock(\r#ifdef AMBIENT\nin vec3 ambientOcclusionColorMap_,\rin vec4 vAmbientInfos,\r#endif\nout ambientOcclusionOutParams outParams\r)\r{\rvec3 ambientOcclusionColor=vec3(1.,1.,1.);\r#ifdef AMBIENT\nvec3 ambientOcclusionColorMap=ambientOcclusionColorMap_*vAmbientInfos.y;\r#ifdef AMBIENTINGRAYSCALE\nambientOcclusionColorMap=vec3(ambientOcclusionColorMap.r,ambientOcclusionColorMap.r,ambientOcclusionColorMap.r);\r#endif\nambientOcclusionColor=mix(ambientOcclusionColor,ambientOcclusionColorMap,vAmbientInfos.z);\r#if DEBUGMODE>0\noutParams.ambientOcclusionColorMap=ambientOcclusionColorMap;\r#endif\n#endif\noutParams.ambientOcclusionColor=ambientOcclusionColor;\r}\r`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const pbrBlockAmbientOcclusion = { name, shader };\n//# sourceMappingURL=pbrBlockAmbientOcclusion.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nconst name = \"pbrBlockAnisotropic\";\nconst shader = `#ifdef ANISOTROPIC\nstruct anisotropicOutParams\r{\rfloat anisotropy;\rvec3 anisotropicTangent;\rvec3 anisotropicBitangent;\rvec3 anisotropicNormal;\r#if DEBUGMODE>0\nvec3 anisotropyMapData;\r#endif\n};\r#define pbr_inline\nvoid anisotropicBlock(\rin vec3 vAnisotropy,\r#ifdef ANISOTROPIC_TEXTURE\nin vec3 anisotropyMapData,\r#endif\nin mat3 TBN,\rin vec3 normalW,\rin vec3 viewDirectionW,\rout anisotropicOutParams outParams\r)\r{\rfloat anisotropy=vAnisotropy.b;\rvec3 anisotropyDirection=vec3(vAnisotropy.xy,0.);\r#ifdef ANISOTROPIC_TEXTURE\nanisotropy*=anisotropyMapData.b;\ranisotropyDirection.rg*=anisotropyMapData.rg*2.0-1.0;\r#if DEBUGMODE>0\noutParams.anisotropyMapData=anisotropyMapData;\r#endif\n#endif\nmat3 anisoTBN=mat3(normalize(TBN[0]),normalize(TBN[1]),normalize(TBN[2]));\rvec3 anisotropicTangent=normalize(anisoTBN*anisotropyDirection);\rvec3 anisotropicBitangent=normalize(cross(anisoTBN[2],anisotropicTangent));\routParams.anisotropy=anisotropy;\routParams.anisotropicTangent=anisotropicTangent;\routParams.anisotropicBitangent=anisotropicBitangent;\routParams.anisotropicNormal=getAnisotropicBentNormals(anisotropicTangent,anisotropicBitangent,normalW,viewDirectionW,anisotropy);\r}\r#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const pbrBlockAnisotropic = { name, shader };\n//# sourceMappingURL=pbrBlockAnisotropic.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nconst name = \"pbrBlockClearcoat\";\nconst shader = `struct clearcoatOutParams\r{\rvec3 specularEnvironmentR0;\rfloat conservationFactor;\rvec3 clearCoatNormalW;\rvec2 clearCoatAARoughnessFactors;\rfloat clearCoatIntensity;\rfloat clearCoatRoughness;\r#ifdef REFLECTION\nvec3 finalClearCoatRadianceScaled;\r#endif\n#ifdef CLEARCOAT_TINT\nvec3 absorption;\rfloat clearCoatNdotVRefract;\rvec3 clearCoatColor;\rfloat clearCoatThickness;\r#endif\n#if defined(ENVIRONMENTBRDF) && defined(MS_BRDF_ENERGY_CONSERVATION)\nvec3 energyConservationFactorClearCoat;\r#endif\n#if DEBUGMODE>0\nmat3 TBNClearCoat;\rvec2 clearCoatMapData;\rvec4 clearCoatTintMapData;\rvec4 environmentClearCoatRadiance;\rfloat clearCoatNdotV;\rvec3 clearCoatEnvironmentReflectance;\r#endif\n};\r#ifdef CLEARCOAT\n#define pbr_inline\n#define inline\nvoid clearcoatBlock(\rin vec3 vPositionW,\rin vec3 geometricNormalW,\rin vec3 viewDirectionW,\rin vec2 vClearCoatParams,\r#if defined(CLEARCOAT_TEXTURE_ROUGHNESS) && !defined(CLEARCOAT_TEXTURE_ROUGHNESS_IDENTICAL) && !defined(CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE)\nin vec4 clearCoatMapRoughnessData,\r#endif\nin vec3 specularEnvironmentR0,\r#ifdef CLEARCOAT_TEXTURE\nin vec2 clearCoatMapData,\r#endif\n#ifdef CLEARCOAT_TINT\nin vec4 vClearCoatTintParams,\rin float clearCoatColorAtDistance,\rin vec4 vClearCoatRefractionParams,\r#ifdef CLEARCOAT_TINT_TEXTURE\nin vec4 clearCoatTintMapData,\r#endif\n#endif\n#ifdef CLEARCOAT_BUMP\nin vec2 vClearCoatBumpInfos,\rin vec4 clearCoatBumpMapData,\rin vec2 vClearCoatBumpUV,\r#if defined(TANGENT) && defined(NORMAL)\nin mat3 vTBN,\r#else\nin vec2 vClearCoatTangentSpaceParams,\r#endif\n#ifdef OBJECTSPACE_NORMALMAP\nin mat4 normalMatrix,\r#endif\n#endif\n#if defined(FORCENORMALFORWARD) && defined(NORMAL)\nin vec3 faceNormal,\r#endif\n#ifdef REFLECTION\nin vec3 vReflectionMicrosurfaceInfos,\rin vec2 vReflectionInfos,\rin vec3 vReflectionColor,\rin vec4 vLightingIntensity,\r#ifdef REFLECTIONMAP_3D\nin samplerCube reflectionSampler,\r#else\nin sampler2D reflectionSampler,\r#endif\n#ifndef LODBASEDMICROSFURACE\n#ifdef REFLECTIONMAP_3D\nin samplerCube reflectionSamplerLow,\rin samplerCube reflectionSamplerHigh,\r#else\nin sampler2D reflectionSamplerLow,\rin sampler2D reflectionSamplerHigh,\r#endif\n#endif\n#ifdef REALTIME_FILTERING\nin vec2 vReflectionFilteringInfo,\r#endif\n#endif\n#if defined(ENVIRONMENTBRDF) && !defined(REFLECTIONMAP_SKYBOX)\n#ifdef RADIANCEOCCLUSION\nin float ambientMonochrome,\r#endif\n#endif\n#if defined(CLEARCOAT_BUMP) || defined(TWOSIDEDLIGHTING)\nin float frontFacingMultiplier,\r#endif\nout clearcoatOutParams outParams\r)\r{\rfloat clearCoatIntensity=vClearCoatParams.x;\rfloat clearCoatRoughness=vClearCoatParams.y;\r#ifdef CLEARCOAT_TEXTURE\nclearCoatIntensity*=clearCoatMapData.x;\r#ifdef CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE\nclearCoatRoughness*=clearCoatMapData.y;\r#endif\n#if DEBUGMODE>0\noutParams.clearCoatMapData=clearCoatMapData;\r#endif\n#endif\n#if defined(CLEARCOAT_TEXTURE_ROUGHNESS) && !defined(CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE)\n#ifdef CLEARCOAT_TEXTURE_ROUGHNESS_IDENTICAL\nclearCoatRoughness*=clearCoatMapData.y;\r#else\nclearCoatRoughness*=clearCoatMapRoughnessData.y;\r#endif\n#endif\noutParams.clearCoatIntensity=clearCoatIntensity;\routParams.clearCoatRoughness=clearCoatRoughness;\r#ifdef CLEARCOAT_TINT\nvec3 clearCoatColor=vClearCoatTintParams.rgb;\rfloat clearCoatThickness=vClearCoatTintParams.a;\r#ifdef CLEARCOAT_TINT_TEXTURE\n#ifdef CLEARCOAT_TINT_GAMMATEXTURE\nclearCoatColor*=toLinearSpace(clearCoatTintMapData.rgb);\r#else\nclearCoatColor*=clearCoatTintMapData.rgb;\r#endif\nclearCoatThickness*=clearCoatTintMapData.a;\r#if DEBUGMODE>0\noutParams.clearCoatTintMapData=clearCoatTintMapData;\r#endif\n#endif\noutParams.clearCoatColor=computeColorAtDistanceInMedia(clearCoatColor,clearCoatColorAtDistance);\routParams.clearCoatThickness=clearCoatThickness;\r#endif\n#ifdef CLEARCOAT_REMAP_F0\nvec3 specularEnvironmentR0Updated=getR0RemappedForClearCoat(specularEnvironmentR0);\r#else\nvec3 specularEnvironmentR0Updated=specularEnvironmentR0;\r#endif\noutParams.specularEnvironmentR0=mix(specularEnvironmentR0,specularEnvironmentR0Updated,clearCoatIntensity);\rvec3 clearCoatNormalW=geometricNormalW;\r#ifdef CLEARCOAT_BUMP\n#ifdef NORMALXYSCALE\nfloat clearCoatNormalScale=1.0;\r#else\nfloat clearCoatNormalScale=vClearCoatBumpInfos.y;\r#endif\n#if defined(TANGENT) && defined(NORMAL)\nmat3 TBNClearCoat=vTBN;\r#else\nvec2 TBNClearCoatUV=vClearCoatBumpUV*frontFacingMultiplier;\rmat3 TBNClearCoat=cotangent_frame(clearCoatNormalW*clearCoatNormalScale,vPositionW,TBNClearCoatUV,vClearCoatTangentSpaceParams);\r#endif\n#if DEBUGMODE>0\noutParams.TBNClearCoat=TBNClearCoat;\r#endif\n#ifdef OBJECTSPACE_NORMALMAP\nclearCoatNormalW=normalize(clearCoatBumpMapData.xyz *2.0-1.0);\rclearCoatNormalW=normalize(mat3(normalMatrix)*clearCoatNormalW);\r#else\nclearCoatNormalW=perturbNormal(TBNClearCoat,clearCoatBumpMapData.xyz,vClearCoatBumpInfos.y);\r#endif\n#endif\n#if defined(FORCENORMALFORWARD) && defined(NORMAL)\nclearCoatNormalW*=sign(dot(clearCoatNormalW,faceNormal));\r#endif\n#if defined(TWOSIDEDLIGHTING) && defined(NORMAL)\nclearCoatNormalW=clearCoatNormalW*frontFacingMultiplier;\r#endif\noutParams.clearCoatNormalW=clearCoatNormalW;\routParams.clearCoatAARoughnessFactors=getAARoughnessFactors(clearCoatNormalW.xyz);\rfloat clearCoatNdotVUnclamped=dot(clearCoatNormalW,viewDirectionW);\rfloat clearCoatNdotV=absEps(clearCoatNdotVUnclamped);\r#if DEBUGMODE>0\noutParams.clearCoatNdotV=clearCoatNdotV;\r#endif\n#ifdef CLEARCOAT_TINT\nvec3 clearCoatVRefract=refract(-viewDirectionW,clearCoatNormalW,vClearCoatRefractionParams.y);\routParams.clearCoatNdotVRefract=absEps(dot(clearCoatNormalW,clearCoatVRefract));\r#endif\n#if defined(ENVIRONMENTBRDF) && (!defined(REFLECTIONMAP_SKYBOX) || defined(MS_BRDF_ENERGY_CONSERVATION))\nvec3 environmentClearCoatBrdf=getBRDFLookup(clearCoatNdotV,clearCoatRoughness);\r#endif\n#if defined(REFLECTION)\nfloat clearCoatAlphaG=convertRoughnessToAverageSlope(clearCoatRoughness);\r#ifdef SPECULARAA\nclearCoatAlphaG+=outParams.clearCoatAARoughnessFactors.y;\r#endif\nvec4 environmentClearCoatRadiance=vec4(0.,0.,0.,0.);\rvec3 clearCoatReflectionVector=computeReflectionCoords(vec4(vPositionW,1.0),clearCoatNormalW);\r#ifdef REFLECTIONMAP_OPPOSITEZ\nclearCoatReflectionVector.z*=-1.0;\r#endif\n#ifdef REFLECTIONMAP_3D\nvec3 clearCoatReflectionCoords=clearCoatReflectionVector;\r#else\nvec2 clearCoatReflectionCoords=clearCoatReflectionVector.xy;\r#ifdef REFLECTIONMAP_PROJECTION\nclearCoatReflectionCoords/=clearCoatReflectionVector.z;\r#endif\nclearCoatReflectionCoords.y=1.0-clearCoatReflectionCoords.y;\r#endif\nsampleReflectionTexture(\rclearCoatAlphaG,\rvReflectionMicrosurfaceInfos,\rvReflectionInfos,\rvReflectionColor,\r#if defined(LODINREFLECTIONALPHA) && !defined(REFLECTIONMAP_SKYBOX)\nclearCoatNdotVUnclamped,\r#endif\n#ifdef LINEARSPECULARREFLECTION\nclearCoatRoughness,\r#endif\nreflectionSampler,\rclearCoatReflectionCoords,\r#ifndef LODBASEDMICROSFURACE\nreflectionSamplerLow,\rreflectionSamplerHigh,\r#endif\n#ifdef REALTIME_FILTERING\nvReflectionFilteringInfo,\r#endif\nenvironmentClearCoatRadiance\r);\r#if DEBUGMODE>0\noutParams.environmentClearCoatRadiance=environmentClearCoatRadiance;\r#endif\n#if defined(ENVIRONMENTBRDF) && !defined(REFLECTIONMAP_SKYBOX)\nvec3 clearCoatEnvironmentReflectance=getReflectanceFromBRDFLookup(vec3(vClearCoatRefractionParams.x),environmentClearCoatBrdf);\r#ifdef HORIZONOCCLUSION\n#ifdef BUMP\n#ifdef REFLECTIONMAP_3D\nfloat clearCoatEho=environmentHorizonOcclusion(-viewDirectionW,clearCoatNormalW,geometricNormalW);\rclearCoatEnvironmentReflectance*=clearCoatEho;\r#endif\n#endif\n#endif\n#else\nvec3 clearCoatEnvironmentReflectance=getReflectanceFromAnalyticalBRDFLookup_Jones(clearCoatNdotV,vec3(1.),vec3(1.),sqrt(1.-clearCoatRoughness));\r#endif\nclearCoatEnvironmentReflectance*=clearCoatIntensity;\r#if DEBUGMODE>0\noutParams.clearCoatEnvironmentReflectance=clearCoatEnvironmentReflectance;\r#endif\noutParams.finalClearCoatRadianceScaled=\renvironmentClearCoatRadiance.rgb *\rclearCoatEnvironmentReflectance *\rvLightingIntensity.z;\r#endif\n#if defined(CLEARCOAT_TINT)\noutParams.absorption=computeClearCoatAbsorption(outParams.clearCoatNdotVRefract,outParams.clearCoatNdotVRefract,outParams.clearCoatColor,clearCoatThickness,clearCoatIntensity);\r#endif\nfloat fresnelIBLClearCoat=fresnelSchlickGGX(clearCoatNdotV,vClearCoatRefractionParams.x,CLEARCOATREFLECTANCE90);\rfresnelIBLClearCoat*=clearCoatIntensity;\routParams.conservationFactor=(1.-fresnelIBLClearCoat);\r#if defined(ENVIRONMENTBRDF) && defined(MS_BRDF_ENERGY_CONSERVATION)\noutParams.energyConservationFactorClearCoat=getEnergyConservationFactor(outParams.specularEnvironmentR0,environmentClearCoatBrdf);\r#endif\n}\r#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const pbrBlockClearcoat = { name, shader };\n//# sourceMappingURL=pbrBlockClearcoat.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nconst name = \"pbrBlockFinalUnlitComponents\";\nconst shader = `vec3 finalDiffuse=diffuseBase;\rfinalDiffuse*=surfaceAlbedo.rgb;\rfinalDiffuse=max(finalDiffuse,0.0);\rfinalDiffuse*=vLightingIntensity.x;\rvec3 finalAmbient=vAmbientColor;\rfinalAmbient*=surfaceAlbedo.rgb;\rvec3 finalEmissive=vEmissiveColor;\r#ifdef EMISSIVE\nvec3 emissiveColorTex=texture2D(emissiveSampler,vEmissiveUV+uvOffset).rgb;\r#ifdef GAMMAEMISSIVE\nfinalEmissive*=toLinearSpace(emissiveColorTex.rgb);\r#else\nfinalEmissive*=emissiveColorTex.rgb;\r#endif\nfinalEmissive*= vEmissiveInfos.y;\r#endif\nfinalEmissive*=vLightingIntensity.y;\r#ifdef AMBIENT\nvec3 ambientOcclusionForDirectDiffuse=mix(vec3(1.),aoOut.ambientOcclusionColor,vAmbientInfos.w);\r#else\nvec3 ambientOcclusionForDirectDiffuse=aoOut.ambientOcclusionColor;\r#endif\nfinalAmbient*=aoOut.ambientOcclusionColor;\rfinalDiffuse*=ambientOcclusionForDirectDiffuse;\r`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const pbrBlockFinalUnlitComponents = { name, shader };\n//# sourceMappingURL=pbrBlockFinalUnlitComponents.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nconst name = \"pbrBlockIridescence\";\nconst shader = `struct iridescenceOutParams\r{\rfloat iridescenceIntensity;\rfloat iridescenceIOR;\rfloat iridescenceThickness;\rvec3 specularEnvironmentR0;\r};\r#ifdef IRIDESCENCE\n#define pbr_inline\n#define inline\nvoid iridescenceBlock(\rin vec4 vIridescenceParams,\rin float viewAngle,\rin vec3 specularEnvironmentR0,\r#ifdef IRIDESCENCE_TEXTURE\nin vec2 iridescenceMapData,\r#endif\n#ifdef IRIDESCENCE_THICKNESS_TEXTURE\nin vec2 iridescenceThicknessMapData,\r#endif\n#ifdef CLEARCOAT\nin float NdotVUnclamped,\r#ifdef CLEARCOAT_TEXTURE\nin vec2 clearCoatMapData,\r#endif\n#endif\nout iridescenceOutParams outParams\r)\r{\rfloat iridescenceIntensity=vIridescenceParams.x;\rfloat iridescenceIOR=vIridescenceParams.y;\rfloat iridescenceThicknessMin=vIridescenceParams.z;\rfloat iridescenceThicknessMax=vIridescenceParams.w;\rfloat iridescenceThicknessWeight=1.;\r#ifdef IRIDESCENCE_TEXTURE\niridescenceIntensity*=iridescenceMapData.x;\r#ifdef IRIDESCENCE_USE_THICKNESS_FROM_MAINTEXTURE\niridescenceThicknessWeight=iridescenceMapData.g;\r#endif\n#endif\n#if defined(IRIDESCENCE_THICKNESS_TEXTURE)\niridescenceThicknessWeight=iridescenceThicknessMapData.g;\r#endif\nfloat iridescenceThickness=mix(iridescenceThicknessMin,iridescenceThicknessMax,iridescenceThicknessWeight);\rfloat topIor=1.; \r#ifdef CLEARCOAT\nfloat clearCoatIntensity=vClearCoatParams.x;\r#ifdef CLEARCOAT_TEXTURE\nclearCoatIntensity*=clearCoatMapData.x;\r#endif\ntopIor=mix(1.0,vClearCoatRefractionParams.w-1.,clearCoatIntensity);\rviewAngle=sqrt(1.0+square(1.0/topIor)*(square(NdotVUnclamped)-1.0));\r#endif\nvec3 iridescenceFresnel=evalIridescence(topIor,iridescenceIOR,viewAngle,iridescenceThickness,specularEnvironmentR0);\routParams.specularEnvironmentR0=mix(specularEnvironmentR0,iridescenceFresnel,iridescenceIntensity);\routParams.iridescenceIntensity=iridescenceIntensity;\routParams.iridescenceThickness=iridescenceThickness;\routParams.iridescenceIOR=iridescenceIOR;\r}\r#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const pbrBlockIridescence = { name, shader };\n//# sourceMappingURL=pbrBlockIridescence.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nconst name = \"pbrBlockReflectance\";\nconst shader = `#if defined(ENVIRONMENTBRDF) && !defined(REFLECTIONMAP_SKYBOX)\nvec3 specularEnvironmentReflectance=getReflectanceFromBRDFLookup(clearcoatOut.specularEnvironmentR0,specularEnvironmentR90,environmentBrdf);\r#ifdef RADIANCEOCCLUSION\nspecularEnvironmentReflectance*=seo;\r#endif\n#ifdef HORIZONOCCLUSION\n#ifdef BUMP\n#ifdef REFLECTIONMAP_3D\nspecularEnvironmentReflectance*=eho;\r#endif\n#endif\n#endif\n#else\nvec3 specularEnvironmentReflectance=getReflectanceFromAnalyticalBRDFLookup_Jones(NdotV,clearcoatOut.specularEnvironmentR0,specularEnvironmentR90,sqrt(microSurface));\r#endif\n#ifdef CLEARCOAT\nspecularEnvironmentReflectance*=clearcoatOut.conservationFactor;\r#if defined(CLEARCOAT_TINT)\nspecularEnvironmentReflectance*=clearcoatOut.absorption;\r#endif\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const pbrBlockReflectance = { name, shader };\n//# sourceMappingURL=pbrBlockReflectance.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nconst name = \"pbrBlockReflectance0\";\nconst shader = `float reflectance=max(max(reflectivityOut.surfaceReflectivityColor.r,reflectivityOut.surfaceReflectivityColor.g),reflectivityOut.surfaceReflectivityColor.b);\rvec3 specularEnvironmentR0=reflectivityOut.surfaceReflectivityColor.rgb;\r#ifdef METALLICWORKFLOW\nvec3 specularEnvironmentR90=vec3(metallicReflectanceFactors.a);\r#else \nvec3 specularEnvironmentR90=vec3(1.0,1.0,1.0);\r#endif\n#ifdef ALPHAFRESNEL\nfloat reflectance90=fresnelGrazingReflectance(reflectance);\rspecularEnvironmentR90=specularEnvironmentR90*reflectance90;\r#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const pbrBlockReflectance0 = { name, shader };\n//# sourceMappingURL=pbrBlockReflectance0.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nconst name = \"pbrBlockReflection\";\nconst shader = `#ifdef REFLECTION\nstruct reflectionOutParams\r{\rvec4 environmentRadiance;\rvec3 environmentIrradiance;\r#ifdef REFLECTIONMAP_3D\nvec3 reflectionCoords;\r#else\nvec2 reflectionCoords;\r#endif\n#ifdef SS_TRANSLUCENCY\n#ifdef USESPHERICALFROMREFLECTIONMAP\n#if !defined(NORMAL) || !defined(USESPHERICALINVERTEX)\nvec3 irradianceVector;\r#endif\n#endif\n#endif\n};\r#define pbr_inline\nvoid createReflectionCoords(\rin vec3 vPositionW,\rin vec3 normalW,\r#ifdef ANISOTROPIC\nin anisotropicOutParams anisotropicOut,\r#endif\n#ifdef REFLECTIONMAP_3D\nout vec3 reflectionCoords\r#else\nout vec2 reflectionCoords\r#endif\n)\r{\r#ifdef ANISOTROPIC\nvec3 reflectionVector=computeReflectionCoords(vec4(vPositionW,1.0),anisotropicOut.anisotropicNormal);\r#else\nvec3 reflectionVector=computeReflectionCoords(vec4(vPositionW,1.0),normalW);\r#endif\n#ifdef REFLECTIONMAP_OPPOSITEZ\nreflectionVector.z*=-1.0;\r#endif\n#ifdef REFLECTIONMAP_3D\nreflectionCoords=reflectionVector;\r#else\nreflectionCoords=reflectionVector.xy;\r#ifdef REFLECTIONMAP_PROJECTION\nreflectionCoords/=reflectionVector.z;\r#endif\nreflectionCoords.y=1.0-reflectionCoords.y;\r#endif\n}\r#define pbr_inline\n#define inline\nvoid sampleReflectionTexture(\rin float alphaG,\rin vec3 vReflectionMicrosurfaceInfos,\rin vec2 vReflectionInfos,\rin vec3 vReflectionColor,\r#if defined(LODINREFLECTIONALPHA) && !defined(REFLECTIONMAP_SKYBOX)\nin float NdotVUnclamped,\r#endif\n#ifdef LINEARSPECULARREFLECTION\nin float roughness,\r#endif\n#ifdef REFLECTIONMAP_3D\nin samplerCube reflectionSampler,\rconst vec3 reflectionCoords,\r#else\nin sampler2D reflectionSampler,\rconst vec2 reflectionCoords,\r#endif\n#ifndef LODBASEDMICROSFURACE\n#ifdef REFLECTIONMAP_3D\nin samplerCube reflectionSamplerLow,\rin samplerCube reflectionSamplerHigh,\r#else\nin sampler2D reflectionSamplerLow,\rin sampler2D reflectionSamplerHigh,\r#endif\n#endif\n#ifdef REALTIME_FILTERING\nin vec2 vReflectionFilteringInfo,\r#endif\nout vec4 environmentRadiance\r)\r{\r#if defined(LODINREFLECTIONALPHA) && !defined(REFLECTIONMAP_SKYBOX)\nfloat reflectionLOD=getLodFromAlphaG(vReflectionMicrosurfaceInfos.x,alphaG,NdotVUnclamped);\r#elif defined(LINEARSPECULARREFLECTION)\nfloat reflectionLOD=getLinearLodFromRoughness(vReflectionMicrosurfaceInfos.x,roughness);\r#else\nfloat reflectionLOD=getLodFromAlphaG(vReflectionMicrosurfaceInfos.x,alphaG);\r#endif\n#ifdef LODBASEDMICROSFURACE\nreflectionLOD=reflectionLOD*vReflectionMicrosurfaceInfos.y+vReflectionMicrosurfaceInfos.z;\r#ifdef LODINREFLECTIONALPHA\nfloat automaticReflectionLOD=UNPACK_LOD(sampleReflection(reflectionSampler,reflectionCoords).a);\rfloat requestedReflectionLOD=max(automaticReflectionLOD,reflectionLOD);\r#else\nfloat requestedReflectionLOD=reflectionLOD;\r#endif\n#ifdef REALTIME_FILTERING\nenvironmentRadiance=vec4(radiance(alphaG,reflectionSampler,reflectionCoords,vReflectionFilteringInfo),1.0);\r#else\nenvironmentRadiance=sampleReflectionLod(reflectionSampler,reflectionCoords,reflectionLOD);\r#endif\n#else\nfloat lodReflectionNormalized=saturate(reflectionLOD/log2(vReflectionMicrosurfaceInfos.x));\rfloat lodReflectionNormalizedDoubled=lodReflectionNormalized*2.0;\rvec4 environmentMid=sampleReflection(reflectionSampler,reflectionCoords);\rif (lodReflectionNormalizedDoubled<1.0){\renvironmentRadiance=mix(\rsampleReflection(reflectionSamplerHigh,reflectionCoords),\renvironmentMid,\rlodReflectionNormalizedDoubled\r);\r} else {\renvironmentRadiance=mix(\renvironmentMid,\rsampleReflection(reflectionSamplerLow,reflectionCoords),\rlodReflectionNormalizedDoubled-1.0\r);\r}\r#endif\n#ifdef RGBDREFLECTION\nenvironmentRadiance.rgb=fromRGBD(environmentRadiance);\r#endif\n#ifdef GAMMAREFLECTION\nenvironmentRadiance.rgb=toLinearSpace(environmentRadiance.rgb);\r#endif\nenvironmentRadiance.rgb*=vReflectionInfos.x;\renvironmentRadiance.rgb*=vReflectionColor.rgb;\r}\r#define pbr_inline\n#define inline\nvoid reflectionBlock(\rin vec3 vPositionW,\rin vec3 normalW,\rin float alphaG,\rin vec3 vReflectionMicrosurfaceInfos,\rin vec2 vReflectionInfos,\rin vec3 vReflectionColor,\r#ifdef ANISOTROPIC\nin anisotropicOutParams anisotropicOut,\r#endif\n#if defined(LODINREFLECTIONALPHA) && !defined(REFLECTIONMAP_SKYBOX)\nin float NdotVUnclamped,\r#endif\n#ifdef LINEARSPECULARREFLECTION\nin float roughness,\r#endif\n#ifdef REFLECTIONMAP_3D\nin samplerCube reflectionSampler,\r#else\nin sampler2D reflectionSampler,\r#endif\n#if defined(NORMAL) && defined(USESPHERICALINVERTEX)\nin vec3 vEnvironmentIrradiance,\r#endif\n#ifdef USESPHERICALFROMREFLECTIONMAP\n#if !defined(NORMAL) || !defined(USESPHERICALINVERTEX)\nin mat4 reflectionMatrix,\r#endif\n#endif\n#ifdef USEIRRADIANCEMAP\n#ifdef REFLECTIONMAP_3D\nin samplerCube irradianceSampler,\r#else\nin sampler2D irradianceSampler,\r#endif\n#endif\n#ifndef LODBASEDMICROSFURACE\n#ifdef REFLECTIONMAP_3D\nin samplerCube reflectionSamplerLow,\rin samplerCube reflectionSamplerHigh,\r#else\nin sampler2D reflectionSamplerLow,\rin sampler2D reflectionSamplerHigh,\r#endif\n#endif\n#ifdef REALTIME_FILTERING\nin vec2 vReflectionFilteringInfo,\r#endif\nout reflectionOutParams outParams\r)\r{\rvec4 environmentRadiance=vec4(0.,0.,0.,0.);\r#ifdef REFLECTIONMAP_3D\nvec3 reflectionCoords=vec3(0.);\r#else\nvec2 reflectionCoords=vec2(0.);\r#endif\ncreateReflectionCoords(\rvPositionW,\rnormalW,\r#ifdef ANISOTROPIC\nanisotropicOut,\r#endif\nreflectionCoords\r);\rsampleReflectionTexture(\ralphaG,\rvReflectionMicrosurfaceInfos,\rvReflectionInfos,\rvReflectionColor,\r#if defined(LODINREFLECTIONALPHA) && !defined(REFLECTIONMAP_SKYBOX)\nNdotVUnclamped,\r#endif\n#ifdef LINEARSPECULARREFLECTION\nroughness,\r#endif\n#ifdef REFLECTIONMAP_3D\nreflectionSampler,\rreflectionCoords,\r#else\nreflectionSampler,\rreflectionCoords,\r#endif\n#ifndef LODBASEDMICROSFURACE\nreflectionSamplerLow,\rreflectionSamplerHigh,\r#endif\n#ifdef REALTIME_FILTERING\nvReflectionFilteringInfo,\r#endif\nenvironmentRadiance\r);\rvec3 environmentIrradiance=vec3(0.,0.,0.);\r#ifdef USESPHERICALFROMREFLECTIONMAP\n#if defined(NORMAL) && defined(USESPHERICALINVERTEX)\nenvironmentIrradiance=vEnvironmentIrradiance;\r#else\n#ifdef ANISOTROPIC\nvec3 irradianceVector=vec3(reflectionMatrix*vec4(anisotropicOut.anisotropicNormal,0)).xyz;\r#else\nvec3 irradianceVector=vec3(reflectionMatrix*vec4(normalW,0)).xyz;\r#endif\n#ifdef REFLECTIONMAP_OPPOSITEZ\nirradianceVector.z*=-1.0;\r#endif\n#ifdef INVERTCUBICMAP\nirradianceVector.y*=-1.0;\r#endif\n#if defined(REALTIME_FILTERING)\nenvironmentIrradiance=irradiance(reflectionSampler,irradianceVector,vReflectionFilteringInfo);\r#else\nenvironmentIrradiance=computeEnvironmentIrradiance(irradianceVector);\r#endif\n#ifdef SS_TRANSLUCENCY\noutParams.irradianceVector=irradianceVector;\r#endif\n#endif\n#elif defined(USEIRRADIANCEMAP)\nvec4 environmentIrradiance4=sampleReflection(irradianceSampler,reflectionCoords);\renvironmentIrradiance=environmentIrradiance4.rgb;\r#ifdef RGBDREFLECTION\nenvironmentIrradiance.rgb=fromRGBD(environmentIrradiance4);\r#endif\n#ifdef GAMMAREFLECTION\nenvironmentIrradiance.rgb=toLinearSpace(environmentIrradiance.rgb);\r#endif\n#endif\nenvironmentIrradiance*=vReflectionColor.rgb;\routParams.environmentRadiance=environmentRadiance;\routParams.environmentIrradiance=environmentIrradiance;\routParams.reflectionCoords=reflectionCoords;\r}\r#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const pbrBlockReflection = { name, shader };\n//# sourceMappingURL=pbrBlockReflection.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nconst name = \"pbrBlockReflectivity\";\nconst shader = `struct reflectivityOutParams\r{\rfloat microSurface;\rfloat roughness;\rvec3 surfaceReflectivityColor;\r#ifdef METALLICWORKFLOW\nvec3 surfaceAlbedo;\r#endif\n#if defined(METALLICWORKFLOW) && defined(REFLECTIVITY) && defined(AOSTOREINMETALMAPRED)\nvec3 ambientOcclusionColor;\r#endif\n#if DEBUGMODE>0\nvec4 surfaceMetallicColorMap;\rvec4 surfaceReflectivityColorMap;\rvec2 metallicRoughness;\rvec3 metallicF0;\r#endif\n};\r#define pbr_inline\nvoid reflectivityBlock(\rin vec4 vReflectivityColor,\r#ifdef METALLICWORKFLOW\nin vec3 surfaceAlbedo,\rin vec4 metallicReflectanceFactors,\r#endif\n#ifdef REFLECTIVITY\nin vec3 reflectivityInfos,\rin vec4 surfaceMetallicOrReflectivityColorMap,\r#endif\n#if defined(METALLICWORKFLOW) && defined(REFLECTIVITY) && defined(AOSTOREINMETALMAPRED)\nin vec3 ambientOcclusionColorIn,\r#endif\n#ifdef MICROSURFACEMAP\nin vec4 microSurfaceTexel,\r#endif\n#ifdef DETAIL\nin vec4 detailColor,\rin vec4 vDetailInfos,\r#endif\nout reflectivityOutParams outParams\r)\r{\rfloat microSurface=vReflectivityColor.a;\rvec3 surfaceReflectivityColor=vReflectivityColor.rgb;\r#ifdef METALLICWORKFLOW\nvec2 metallicRoughness=surfaceReflectivityColor.rg;\r#ifdef REFLECTIVITY\n#if DEBUGMODE>0\noutParams.surfaceMetallicColorMap=surfaceMetallicOrReflectivityColorMap;\r#endif\n#ifdef AOSTOREINMETALMAPRED\nvec3 aoStoreInMetalMap=vec3(surfaceMetallicOrReflectivityColorMap.r,surfaceMetallicOrReflectivityColorMap.r,surfaceMetallicOrReflectivityColorMap.r);\routParams.ambientOcclusionColor=mix(ambientOcclusionColorIn,aoStoreInMetalMap,reflectivityInfos.z);\r#endif\n#ifdef METALLNESSSTOREINMETALMAPBLUE\nmetallicRoughness.r*=surfaceMetallicOrReflectivityColorMap.b;\r#else\nmetallicRoughness.r*=surfaceMetallicOrReflectivityColorMap.r;\r#endif\n#ifdef ROUGHNESSSTOREINMETALMAPALPHA\nmetallicRoughness.g*=surfaceMetallicOrReflectivityColorMap.a;\r#else\n#ifdef ROUGHNESSSTOREINMETALMAPGREEN\nmetallicRoughness.g*=surfaceMetallicOrReflectivityColorMap.g;\r#endif\n#endif\n#endif\n#ifdef DETAIL\nfloat detailRoughness=mix(0.5,detailColor.b,vDetailInfos.w);\rfloat loLerp=mix(0.,metallicRoughness.g,detailRoughness*2.);\rfloat hiLerp=mix(metallicRoughness.g,1.,(detailRoughness-0.5)*2.);\rmetallicRoughness.g=mix(loLerp,hiLerp,step(detailRoughness,0.5));\r#endif\n#ifdef MICROSURFACEMAP\nmetallicRoughness.g*=microSurfaceTexel.r;\r#endif\n#if DEBUGMODE>0\noutParams.metallicRoughness=metallicRoughness;\r#endif\n#define CUSTOM_FRAGMENT_UPDATE_METALLICROUGHNESS\nmicroSurface=1.0-metallicRoughness.g;\rvec3 baseColor=surfaceAlbedo;\r#ifdef FROSTBITE_REFLECTANCE\noutParams.surfaceAlbedo=baseColor.rgb*(1.0-metallicRoughness.r);\rsurfaceReflectivityColor=mix(0.16*reflectance*reflectance,baseColor,metallicRoughness.r);\r#else\nvec3 metallicF0=metallicReflectanceFactors.rgb;\r#if DEBUGMODE>0\noutParams.metallicF0=metallicF0;\r#endif\noutParams.surfaceAlbedo=mix(baseColor.rgb*(1.0-metallicF0),vec3(0.,0.,0.),metallicRoughness.r);\rsurfaceReflectivityColor=mix(metallicF0,baseColor,metallicRoughness.r);\r#endif\n#else\n#ifdef REFLECTIVITY\nsurfaceReflectivityColor*=surfaceMetallicOrReflectivityColorMap.rgb;\r#if DEBUGMODE>0\noutParams.surfaceReflectivityColorMap=surfaceMetallicOrReflectivityColorMap;\r#endif\n#ifdef MICROSURFACEFROMREFLECTIVITYMAP\nmicroSurface*=surfaceMetallicOrReflectivityColorMap.a;\rmicroSurface*=reflectivityInfos.z;\r#else\n#ifdef MICROSURFACEAUTOMATIC\nmicroSurface*=computeDefaultMicroSurface(microSurface,surfaceReflectivityColor);\r#endif\n#ifdef MICROSURFACEMAP\nmicroSurface*=microSurfaceTexel.r;\r#endif\n#define CUSTOM_FRAGMENT_UPDATE_MICROSURFACE\n#endif\n#endif\n#endif\nmicroSurface=saturate(microSurface);\rfloat roughness=1.-microSurface;\routParams.microSurface=microSurface;\routParams.roughness=roughness;\routParams.surfaceReflectivityColor=surfaceReflectivityColor;\r}\r`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const pbrBlockReflectivity = { name, shader };\n//# sourceMappingURL=pbrBlockReflectivity.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nconst name = \"pbrBlockSheen\";\nconst shader = `#ifdef SHEEN\nstruct sheenOutParams\r{\rfloat sheenIntensity;\rvec3 sheenColor;\rfloat sheenRoughness;\r#ifdef SHEEN_LINKWITHALBEDO\nvec3 surfaceAlbedo;\r#endif\n#if defined(ENVIRONMENTBRDF) && defined(SHEEN_ALBEDOSCALING)\nfloat sheenAlbedoScaling;\r#endif\n#if defined(REFLECTION) && defined(ENVIRONMENTBRDF)\nvec3 finalSheenRadianceScaled;\r#endif\n#if DEBUGMODE>0\nvec4 sheenMapData;\rvec3 sheenEnvironmentReflectance;\r#endif\n};\r#define pbr_inline\n#define inline\nvoid sheenBlock(\rin vec4 vSheenColor,\r#ifdef SHEEN_ROUGHNESS\nin float vSheenRoughness,\r#if defined(SHEEN_TEXTURE_ROUGHNESS) && !defined(SHEEN_TEXTURE_ROUGHNESS_IDENTICAL) && !defined(SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE)\nin vec4 sheenMapRoughnessData,\r#endif\n#endif\nin float roughness,\r#ifdef SHEEN_TEXTURE\nin vec4 sheenMapData,\rin float sheenMapLevel,\r#endif\nin float reflectance,\r#ifdef SHEEN_LINKWITHALBEDO\nin vec3 baseColor,\rin vec3 surfaceAlbedo,\r#endif\n#ifdef ENVIRONMENTBRDF\nin float NdotV,\rin vec3 environmentBrdf,\r#endif\n#if defined(REFLECTION) && defined(ENVIRONMENTBRDF)\nin vec2 AARoughnessFactors,\rin vec3 vReflectionMicrosurfaceInfos,\rin vec2 vReflectionInfos,\rin vec3 vReflectionColor,\rin vec4 vLightingIntensity,\r#ifdef REFLECTIONMAP_3D\nin samplerCube reflectionSampler,\rin vec3 reflectionCoords,\r#else\nin sampler2D reflectionSampler,\rin vec2 reflectionCoords,\r#endif\nin float NdotVUnclamped,\r#ifndef LODBASEDMICROSFURACE\n#ifdef REFLECTIONMAP_3D\nin samplerCube reflectionSamplerLow,\rin samplerCube reflectionSamplerHigh,\r#else\nin sampler2D reflectionSamplerLow,\rin sampler2D reflectionSamplerHigh,\r#endif\n#endif\n#ifdef REALTIME_FILTERING\nin vec2 vReflectionFilteringInfo,\r#endif\n#if !defined(REFLECTIONMAP_SKYBOX) && defined(RADIANCEOCCLUSION)\nin float seo,\r#endif\n#if !defined(REFLECTIONMAP_SKYBOX) && defined(HORIZONOCCLUSION) && defined(BUMP) && defined(REFLECTIONMAP_3D)\nin float eho,\r#endif\n#endif\nout sheenOutParams outParams\r)\r{\rfloat sheenIntensity=vSheenColor.a;\r#ifdef SHEEN_TEXTURE\n#if DEBUGMODE>0\noutParams.sheenMapData=sheenMapData;\r#endif\n#endif\n#ifdef SHEEN_LINKWITHALBEDO\nfloat sheenFactor=pow5(1.0-sheenIntensity);\rvec3 sheenColor=baseColor.rgb*(1.0-sheenFactor);\rfloat sheenRoughness=sheenIntensity;\routParams.surfaceAlbedo=surfaceAlbedo*sheenFactor;\r#ifdef SHEEN_TEXTURE\nsheenIntensity*=sheenMapData.a;\r#endif\n#else\nvec3 sheenColor=vSheenColor.rgb;\r#ifdef SHEEN_TEXTURE\n#ifdef SHEEN_GAMMATEXTURE\nsheenColor.rgb*=toLinearSpace(sheenMapData.rgb);\r#else\nsheenColor.rgb*=sheenMapData.rgb;\r#endif\nsheenColor.rgb*=sheenMapLevel;\r#endif\n#ifdef SHEEN_ROUGHNESS\nfloat sheenRoughness=vSheenRoughness;\r#ifdef SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE\n#if defined(SHEEN_TEXTURE)\nsheenRoughness*=sheenMapData.a;\r#endif\n#elif defined(SHEEN_TEXTURE_ROUGHNESS)\n#ifdef SHEEN_TEXTURE_ROUGHNESS_IDENTICAL\nsheenRoughness*=sheenMapData.a;\r#else\nsheenRoughness*=sheenMapRoughnessData.a;\r#endif\n#endif\n#else\nfloat sheenRoughness=roughness;\r#ifdef SHEEN_TEXTURE\nsheenIntensity*=sheenMapData.a;\r#endif\n#endif\n#if !defined(SHEEN_ALBEDOSCALING)\nsheenIntensity*=(1.-reflectance);\r#endif\nsheenColor*=sheenIntensity;\r#endif\n#ifdef ENVIRONMENTBRDF\n/*#ifdef SHEEN_SOFTER\rvec3 environmentSheenBrdf=vec3(0.,0.,getBRDFLookupCharlieSheen(NdotV,sheenRoughness));\r#else*/\n#ifdef SHEEN_ROUGHNESS\nvec3 environmentSheenBrdf=getBRDFLookup(NdotV,sheenRoughness);\r#else\nvec3 environmentSheenBrdf=environmentBrdf;\r#endif\n/*#endif*/\r#endif\n#if defined(REFLECTION) && defined(ENVIRONMENTBRDF)\nfloat sheenAlphaG=convertRoughnessToAverageSlope(sheenRoughness);\r#ifdef SPECULARAA\nsheenAlphaG+=AARoughnessFactors.y;\r#endif\nvec4 environmentSheenRadiance=vec4(0.,0.,0.,0.);\rsampleReflectionTexture(\rsheenAlphaG,\rvReflectionMicrosurfaceInfos,\rvReflectionInfos,\rvReflectionColor,\r#if defined(LODINREFLECTIONALPHA) && !defined(REFLECTIONMAP_SKYBOX)\nNdotVUnclamped,\r#endif\n#ifdef LINEARSPECULARREFLECTION\nsheenRoughness,\r#endif\nreflectionSampler,\rreflectionCoords,\r#ifndef LODBASEDMICROSFURACE\nreflectionSamplerLow,\rreflectionSamplerHigh,\r#endif\n#ifdef REALTIME_FILTERING\nvReflectionFilteringInfo,\r#endif\nenvironmentSheenRadiance\r);\rvec3 sheenEnvironmentReflectance=getSheenReflectanceFromBRDFLookup(sheenColor,environmentSheenBrdf);\r#if !defined(REFLECTIONMAP_SKYBOX) && defined(RADIANCEOCCLUSION)\nsheenEnvironmentReflectance*=seo;\r#endif\n#if !defined(REFLECTIONMAP_SKYBOX) && defined(HORIZONOCCLUSION) && defined(BUMP) && defined(REFLECTIONMAP_3D)\nsheenEnvironmentReflectance*=eho;\r#endif\n#if DEBUGMODE>0\noutParams.sheenEnvironmentReflectance=sheenEnvironmentReflectance;\r#endif\noutParams.finalSheenRadianceScaled=\renvironmentSheenRadiance.rgb *\rsheenEnvironmentReflectance *\rvLightingIntensity.z;\r#endif\n#if defined(ENVIRONMENTBRDF) && defined(SHEEN_ALBEDOSCALING)\noutParams.sheenAlbedoScaling=1.0-sheenIntensity*max(max(sheenColor.r,sheenColor.g),sheenColor.b)*environmentSheenBrdf.b;\r#endif\noutParams.sheenIntensity=sheenIntensity;\routParams.sheenColor=sheenColor;\routParams.sheenRoughness=sheenRoughness;\r}\r#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const pbrBlockSheen = { name, shader };\n//# sourceMappingURL=pbrBlockSheen.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nconst name = \"pbrBlockSubSurface\";\nconst shader = `struct subSurfaceOutParams\r{\rvec3 specularEnvironmentReflectance;\r#ifdef SS_REFRACTION\nvec3 finalRefraction;\rvec3 surfaceAlbedo;\r#ifdef SS_LINKREFRACTIONTOTRANSPARENCY\nfloat alpha;\r#endif\n#ifdef REFLECTION\nfloat refractionFactorForIrradiance;\r#endif\n#endif\n#ifdef SS_TRANSLUCENCY\nvec3 transmittance;\rfloat translucencyIntensity;\r#ifdef REFLECTION\nvec3 refractionIrradiance;\r#endif\n#endif\n#if DEBUGMODE>0\nvec4 thicknessMap;\rvec4 environmentRefraction;\rvec3 refractionTransmittance;\r#endif\n};\r#ifdef SUBSURFACE\n#define pbr_inline\n#define inline\nvoid subSurfaceBlock(\rin vec3 vSubSurfaceIntensity,\rin vec2 vThicknessParam,\rin vec4 vTintColor,\rin vec3 normalW,\rin vec3 specularEnvironmentReflectance,\r#ifdef SS_THICKNESSANDMASK_TEXTURE\nin vec4 thicknessMap,\r#endif\n#ifdef SS_REFRACTIONINTENSITY_TEXTURE\nin vec4 refractionIntensityMap,\r#endif\n#ifdef SS_TRANSLUCENCYINTENSITY_TEXTURE\nin vec4 translucencyIntensityMap,\r#endif\n#ifdef REFLECTION\n#ifdef SS_TRANSLUCENCY\nin mat4 reflectionMatrix,\r#ifdef USESPHERICALFROMREFLECTIONMAP\n#if !defined(NORMAL) || !defined(USESPHERICALINVERTEX)\nin vec3 irradianceVector_,\r#endif\n#if defined(REALTIME_FILTERING)\nin samplerCube reflectionSampler,\rin vec2 vReflectionFilteringInfo,\r#endif\n#endif\n#ifdef USEIRRADIANCEMAP\n#ifdef REFLECTIONMAP_3D\nin samplerCube irradianceSampler,\r#else\nin sampler2D irradianceSampler,\r#endif\n#endif\n#endif\n#endif\n#if defined(SS_REFRACTION) || defined(SS_TRANSLUCENCY)\nin vec3 surfaceAlbedo,\r#endif\n#ifdef SS_REFRACTION\nin vec3 vPositionW,\rin vec3 viewDirectionW,\rin mat4 view,\rin vec4 vRefractionInfos,\rin mat4 refractionMatrix,\rin vec4 vRefractionMicrosurfaceInfos,\rin vec4 vLightingIntensity,\r#ifdef SS_LINKREFRACTIONTOTRANSPARENCY\nin float alpha,\r#endif\n#ifdef SS_LODINREFRACTIONALPHA\nin float NdotVUnclamped,\r#endif\n#ifdef SS_LINEARSPECULARREFRACTION\nin float roughness,\r#endif\nin float alphaG,\r#ifdef SS_REFRACTIONMAP_3D\nin samplerCube refractionSampler,\r#ifndef LODBASEDMICROSFURACE\nin samplerCube refractionSamplerLow,\rin samplerCube refractionSamplerHigh,\r#endif\n#else\nin sampler2D refractionSampler,\r#ifndef LODBASEDMICROSFURACE\nin sampler2D refractionSamplerLow,\rin sampler2D refractionSamplerHigh,\r#endif\n#endif\n#ifdef ANISOTROPIC\nin anisotropicOutParams anisotropicOut,\r#endif\n#ifdef REALTIME_FILTERING\nin vec2 vRefractionFilteringInfo,\r#endif\n#ifdef SS_USE_LOCAL_REFRACTIONMAP_CUBIC\nin vec3 refractionPosition,\rin vec3 refractionSize,\r#endif\n#endif\n#ifdef SS_TRANSLUCENCY\nin vec3 vDiffusionDistance,\r#endif\nout subSurfaceOutParams outParams\r)\r{\routParams.specularEnvironmentReflectance=specularEnvironmentReflectance;\r#ifdef SS_REFRACTION\nfloat refractionIntensity=vSubSurfaceIntensity.x;\r#ifdef SS_LINKREFRACTIONTOTRANSPARENCY\nrefractionIntensity*=(1.0-alpha);\routParams.alpha=1.0;\r#endif\n#endif\n#ifdef SS_TRANSLUCENCY\nfloat translucencyIntensity=vSubSurfaceIntensity.y;\r#endif\n#ifdef SS_THICKNESSANDMASK_TEXTURE\n#if defined(SS_USE_GLTF_TEXTURES)\nfloat thickness=thicknessMap.g*vThicknessParam.y+vThicknessParam.x;\r#else\nfloat thickness=thicknessMap.r*vThicknessParam.y+vThicknessParam.x;\r#endif\n#if DEBUGMODE>0\noutParams.thicknessMap=thicknessMap;\r#endif\n#ifdef SS_MASK_FROM_THICKNESS_TEXTURE\n#if defined(SS_REFRACTION) && defined(SS_REFRACTION_USE_INTENSITY_FROM_TEXTURE)\n#if defined(SS_USE_GLTF_TEXTURES)\nrefractionIntensity*=thicknessMap.r;\r#else\nrefractionIntensity*=thicknessMap.g;\r#endif\n#endif\n#if defined(SS_TRANSLUCENCY) && defined(SS_TRANSLUCENCY_USE_INTENSITY_FROM_TEXTURE)\ntranslucencyIntensity*=thicknessMap.b;\r#endif\n#endif\n#else\nfloat thickness=vThicknessParam.y;\r#endif\n#ifdef SS_REFRACTIONINTENSITY_TEXTURE\n#ifdef SS_USE_GLTF_TEXTURES\nrefractionIntensity*=refractionIntensityMap.r;\r#else\nrefractionIntensity*=refractionIntensityMap.g;\r#endif\n#endif\n#ifdef SS_TRANSLUCENCYINTENSITY_TEXTURE\ntranslucencyIntensity*=translucencyIntensityMap.b;\r#endif\n#ifdef SS_TRANSLUCENCY\nthickness=maxEps(thickness);\rvec3 transmittance=transmittanceBRDF_Burley(vTintColor.rgb,vDiffusionDistance,thickness);\rtransmittance*=translucencyIntensity;\routParams.transmittance=transmittance;\routParams.translucencyIntensity=translucencyIntensity;\r#endif\n#ifdef SS_REFRACTION\nvec4 environmentRefraction=vec4(0.,0.,0.,0.);\r#ifdef ANISOTROPIC\nvec3 refractionVector=refract(-viewDirectionW,anisotropicOut.anisotropicNormal,vRefractionInfos.y);\r#else\nvec3 refractionVector=refract(-viewDirectionW,normalW,vRefractionInfos.y);\r#endif\n#ifdef SS_REFRACTIONMAP_OPPOSITEZ\nrefractionVector.z*=-1.0;\r#endif\n#ifdef SS_REFRACTIONMAP_3D\n#ifdef SS_USE_LOCAL_REFRACTIONMAP_CUBIC\nrefractionVector=parallaxCorrectNormal(vPositionW,refractionVector,refractionSize,refractionPosition);\r#endif\nrefractionVector.y=refractionVector.y*vRefractionInfos.w;\rvec3 refractionCoords=refractionVector;\rrefractionCoords=vec3(refractionMatrix*vec4(refractionCoords,0));\r#else\n#ifdef SS_USE_THICKNESS_AS_DEPTH\nvec3 vRefractionUVW=vec3(refractionMatrix*(view*vec4(vPositionW+refractionVector*thickness,1.0)));\r#else\nvec3 vRefractionUVW=vec3(refractionMatrix*(view*vec4(vPositionW+refractionVector*vRefractionInfos.z,1.0)));\r#endif\nvec2 refractionCoords=vRefractionUVW.xy/vRefractionUVW.z;\rrefractionCoords.y=1.0-refractionCoords.y;\r#endif\n#ifdef SS_HAS_THICKNESS\nfloat ior=vRefractionInfos.y;\r#else\nfloat ior=vRefractionMicrosurfaceInfos.w;\r#endif\n#ifdef SS_LODINREFRACTIONALPHA\nfloat refractionAlphaG=alphaG;\rrefractionAlphaG=mix(alphaG,0.0,clamp(ior*3.0-2.0,0.0,1.0));\rfloat refractionLOD=getLodFromAlphaG(vRefractionMicrosurfaceInfos.x,refractionAlphaG,NdotVUnclamped);\r#elif defined(SS_LINEARSPECULARREFRACTION)\nfloat refractionRoughness=alphaG;\rrefractionRoughness=mix(alphaG,0.0,clamp(ior*3.0-2.0,0.0,1.0));\rfloat refractionLOD=getLinearLodFromRoughness(vRefractionMicrosurfaceInfos.x,refractionRoughness);\r#else\nfloat refractionAlphaG=alphaG;\rrefractionAlphaG=mix(alphaG,0.0,clamp(ior*3.0-2.0,0.0,1.0));\rfloat refractionLOD=getLodFromAlphaG(vRefractionMicrosurfaceInfos.x,refractionAlphaG);\r#endif\n#ifdef LODBASEDMICROSFURACE\nrefractionLOD=refractionLOD*vRefractionMicrosurfaceInfos.y+vRefractionMicrosurfaceInfos.z;\r#ifdef SS_LODINREFRACTIONALPHA\nfloat automaticRefractionLOD=UNPACK_LOD(sampleRefraction(refractionSampler,refractionCoords).a);\rfloat requestedRefractionLOD=max(automaticRefractionLOD,refractionLOD);\r#else\nfloat requestedRefractionLOD=refractionLOD;\r#endif\n#if defined(REALTIME_FILTERING) && defined(SS_REFRACTIONMAP_3D)\nenvironmentRefraction=vec4(radiance(alphaG,refractionSampler,refractionCoords,vRefractionFilteringInfo),1.0);\r#else\nenvironmentRefraction=sampleRefractionLod(refractionSampler,refractionCoords,requestedRefractionLOD);\r#endif\n#else\nfloat lodRefractionNormalized=saturate(refractionLOD/log2(vRefractionMicrosurfaceInfos.x));\rfloat lodRefractionNormalizedDoubled=lodRefractionNormalized*2.0;\rvec4 environmentRefractionMid=sampleRefraction(refractionSampler,refractionCoords);\rif (lodRefractionNormalizedDoubled<1.0){\renvironmentRefraction=mix(\rsampleRefraction(refractionSamplerHigh,refractionCoords),\renvironmentRefractionMid,\rlodRefractionNormalizedDoubled\r);\r} else {\renvironmentRefraction=mix(\renvironmentRefractionMid,\rsampleRefraction(refractionSamplerLow,refractionCoords),\rlodRefractionNormalizedDoubled-1.0\r);\r}\r#endif\n#ifdef SS_RGBDREFRACTION\nenvironmentRefraction.rgb=fromRGBD(environmentRefraction);\r#endif\n#ifdef SS_GAMMAREFRACTION\nenvironmentRefraction.rgb=toLinearSpace(environmentRefraction.rgb);\r#endif\nenvironmentRefraction.rgb*=vRefractionInfos.x;\r#endif\n#ifdef SS_REFRACTION\nvec3 refractionTransmittance=vec3(refractionIntensity);\r#ifdef SS_THICKNESSANDMASK_TEXTURE\nvec3 volumeAlbedo=computeColorAtDistanceInMedia(vTintColor.rgb,vTintColor.w);\rrefractionTransmittance*=cocaLambert(volumeAlbedo,thickness);\r#elif defined(SS_LINKREFRACTIONTOTRANSPARENCY)\nfloat maxChannel=max(max(surfaceAlbedo.r,surfaceAlbedo.g),surfaceAlbedo.b);\rvec3 volumeAlbedo=saturate(maxChannel*surfaceAlbedo);\renvironmentRefraction.rgb*=volumeAlbedo;\r#else\nvec3 volumeAlbedo=computeColorAtDistanceInMedia(vTintColor.rgb,vTintColor.w);\rrefractionTransmittance*=cocaLambert(volumeAlbedo,vThicknessParam.y);\r#endif\n#ifdef SS_ALBEDOFORREFRACTIONTINT\nenvironmentRefraction.rgb*=surfaceAlbedo.rgb;\r#endif\noutParams.surfaceAlbedo=surfaceAlbedo*(1.-refractionIntensity);\r#ifdef REFLECTION\noutParams.refractionFactorForIrradiance=(1.-refractionIntensity);\r#endif\n#ifdef UNUSED_MULTIPLEBOUNCES\nvec3 bounceSpecularEnvironmentReflectance=(2.0*specularEnvironmentReflectance)/(1.0+specularEnvironmentReflectance);\routParams.specularEnvironmentReflectance=mix(bounceSpecularEnvironmentReflectance,specularEnvironmentReflectance,refractionIntensity);\r#endif\nrefractionTransmittance*=1.0-outParams.specularEnvironmentReflectance;\r#if DEBUGMODE>0\noutParams.refractionTransmittance=refractionTransmittance;\r#endif\noutParams.finalRefraction=environmentRefraction.rgb*refractionTransmittance*vLightingIntensity.z;\r#if DEBUGMODE>0\noutParams.environmentRefraction=environmentRefraction;\r#endif\n#endif\n#if defined(REFLECTION) && defined(SS_TRANSLUCENCY)\n#if defined(NORMAL) && defined(USESPHERICALINVERTEX) || !defined(USESPHERICALFROMREFLECTIONMAP)\nvec3 irradianceVector=vec3(reflectionMatrix*vec4(normalW,0)).xyz;\r#ifdef REFLECTIONMAP_OPPOSITEZ\nirradianceVector.z*=-1.0;\r#endif\n#ifdef INVERTCUBICMAP\nirradianceVector.y*=-1.0;\r#endif\n#else\nvec3 irradianceVector=irradianceVector_;\r#endif\n#if defined(USESPHERICALFROMREFLECTIONMAP)\n#if defined(REALTIME_FILTERING)\nvec3 refractionIrradiance=irradiance(reflectionSampler,-irradianceVector,vReflectionFilteringInfo);\r#else\nvec3 refractionIrradiance=computeEnvironmentIrradiance(-irradianceVector);\r#endif\n#elif defined(USEIRRADIANCEMAP)\n#ifdef REFLECTIONMAP_3D\nvec3 irradianceCoords=irradianceVector;\r#else\nvec2 irradianceCoords=irradianceVector.xy;\r#ifdef REFLECTIONMAP_PROJECTION\nirradianceCoords/=irradianceVector.z;\r#endif\nirradianceCoords.y=1.0-irradianceCoords.y;\r#endif\nvec4 refractionIrradiance=sampleReflection(irradianceSampler,-irradianceCoords);\r#ifdef RGBDREFLECTION\nrefractionIrradiance.rgb=fromRGBD(refractionIrradiance);\r#endif\n#ifdef GAMMAREFLECTION\nrefractionIrradiance.rgb=toLinearSpace(refractionIrradiance.rgb);\r#endif\n#else\nvec4 refractionIrradiance=vec4(0.);\r#endif\nrefractionIrradiance.rgb*=transmittance;\r#ifdef SS_ALBEDOFORTRANSLUCENCYTINT\nrefractionIrradiance.rgb*=surfaceAlbedo.rgb;\r#endif\noutParams.refractionIrradiance=refractionIrradiance.rgb;\r#endif\n}\r#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const pbrBlockSubSurface = { name, shader };\n//# sourceMappingURL=pbrBlockSubSurface.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nconst name = \"pbrDebug\";\nconst shader = `#if DEBUGMODE>0\nif (vClipSpacePosition.x/vClipSpacePosition.w>=vDebugMode.x) {\r#if DEBUGMODE==1\ngl_FragColor.rgb=vPositionW.rgb;\r#define DEBUGMODE_NORMALIZE\n#elif DEBUGMODE==2 && defined(NORMAL)\ngl_FragColor.rgb=vNormalW.rgb;\r#define DEBUGMODE_NORMALIZE\n#elif DEBUGMODE==3 && defined(BUMP) || DEBUGMODE==3 && defined(PARALLAX) || DEBUGMODE==3 && defined(ANISOTROPIC)\ngl_FragColor.rgb=TBN[0];\r#define DEBUGMODE_NORMALIZE\n#elif DEBUGMODE==4 && defined(BUMP) || DEBUGMODE==4 && defined(PARALLAX) || DEBUGMODE==4 && defined(ANISOTROPIC)\ngl_FragColor.rgb=TBN[1];\r#define DEBUGMODE_NORMALIZE\n#elif DEBUGMODE==5\ngl_FragColor.rgb=normalW;\r#define DEBUGMODE_NORMALIZE\n#elif DEBUGMODE==6 && defined(MAINUV1)\ngl_FragColor.rgb=vec3(vMainUV1,0.0);\r#elif DEBUGMODE==7 && defined(MAINUV2)\ngl_FragColor.rgb=vec3(vMainUV2,0.0);\r#elif DEBUGMODE==8 && defined(CLEARCOAT) && defined(CLEARCOAT_BUMP)\ngl_FragColor.rgb=clearcoatOut.TBNClearCoat[0];\r#define DEBUGMODE_NORMALIZE\n#elif DEBUGMODE==9 && defined(CLEARCOAT) && defined(CLEARCOAT_BUMP)\ngl_FragColor.rgb=clearcoatOut.TBNClearCoat[1];\r#define DEBUGMODE_NORMALIZE\n#elif DEBUGMODE==10 && defined(CLEARCOAT)\ngl_FragColor.rgb=clearcoatOut.clearCoatNormalW;\r#define DEBUGMODE_NORMALIZE\n#elif DEBUGMODE==11 && defined(ANISOTROPIC)\ngl_FragColor.rgb=anisotropicOut.anisotropicNormal;\r#define DEBUGMODE_NORMALIZE\n#elif DEBUGMODE==12 && defined(ANISOTROPIC)\ngl_FragColor.rgb=anisotropicOut.anisotropicTangent;\r#define DEBUGMODE_NORMALIZE\n#elif DEBUGMODE==13 && defined(ANISOTROPIC)\ngl_FragColor.rgb=anisotropicOut.anisotropicBitangent;\r#define DEBUGMODE_NORMALIZE\n#elif DEBUGMODE==20 && defined(ALBEDO)\ngl_FragColor.rgb=albedoTexture.rgb;\r#elif DEBUGMODE==21 && defined(AMBIENT)\ngl_FragColor.rgb=aoOut.ambientOcclusionColorMap.rgb;\r#elif DEBUGMODE==22 && defined(OPACITY)\ngl_FragColor.rgb=opacityMap.rgb;\r#elif DEBUGMODE==23 && defined(EMISSIVE)\ngl_FragColor.rgb=emissiveColorTex.rgb;\r#define DEBUGMODE_GAMMA\n#elif DEBUGMODE==24 && defined(LIGHTMAP)\ngl_FragColor.rgb=lightmapColor.rgb;\r#define DEBUGMODE_GAMMA\n#elif DEBUGMODE==25 && defined(REFLECTIVITY) && defined(METALLICWORKFLOW)\ngl_FragColor.rgb=reflectivityOut.surfaceMetallicColorMap.rgb;\r#elif DEBUGMODE==26 && defined(REFLECTIVITY) && !defined(METALLICWORKFLOW)\ngl_FragColor.rgb=reflectivityOut.surfaceReflectivityColorMap.rgb;\r#define DEBUGMODE_GAMMA\n#elif DEBUGMODE==27 && defined(CLEARCOAT) && defined(CLEARCOAT_TEXTURE)\ngl_FragColor.rgb=vec3(clearcoatOut.clearCoatMapData.rg,0.0);\r#elif DEBUGMODE==28 && defined(CLEARCOAT) && defined(CLEARCOAT_TINT) && defined(CLEARCOAT_TINT_TEXTURE)\ngl_FragColor.rgb=clearcoatOut.clearCoatTintMapData.rgb;\r#elif DEBUGMODE==29 && defined(SHEEN) && defined(SHEEN_TEXTURE)\ngl_FragColor.rgb=sheenOut.sheenMapData.rgb;\r#elif DEBUGMODE==30 && defined(ANISOTROPIC) && defined(ANISOTROPIC_TEXTURE)\ngl_FragColor.rgb=anisotropicOut.anisotropyMapData.rgb;\r#elif DEBUGMODE==31 && defined(SUBSURFACE) && defined(SS_THICKNESSANDMASK_TEXTURE)\ngl_FragColor.rgb=subSurfaceOut.thicknessMap.rgb;\r#elif DEBUGMODE==40 && defined(SS_REFRACTION)\ngl_FragColor.rgb=subSurfaceOut.environmentRefraction.rgb;\r#define DEBUGMODE_GAMMA\n#elif DEBUGMODE==41 && defined(REFLECTION)\ngl_FragColor.rgb=reflectionOut.environmentRadiance.rgb;\r#define DEBUGMODE_GAMMA\n#elif DEBUGMODE==42 && defined(CLEARCOAT) && defined(REFLECTION)\ngl_FragColor.rgb=clearcoatOut.environmentClearCoatRadiance.rgb;\r#define DEBUGMODE_GAMMA\n#elif DEBUGMODE==50\ngl_FragColor.rgb=diffuseBase.rgb;\r#define DEBUGMODE_GAMMA\n#elif DEBUGMODE==51 && defined(SPECULARTERM)\ngl_FragColor.rgb=specularBase.rgb;\r#define DEBUGMODE_GAMMA\n#elif DEBUGMODE==52 && defined(CLEARCOAT)\ngl_FragColor.rgb=clearCoatBase.rgb;\r#define DEBUGMODE_GAMMA\n#elif DEBUGMODE==53 && defined(SHEEN)\ngl_FragColor.rgb=sheenBase.rgb;\r#define DEBUGMODE_GAMMA\n#elif DEBUGMODE==54 && defined(REFLECTION)\ngl_FragColor.rgb=reflectionOut.environmentIrradiance.rgb;\r#define DEBUGMODE_GAMMA\n#elif DEBUGMODE==60\ngl_FragColor.rgb=surfaceAlbedo.rgb;\r#define DEBUGMODE_GAMMA\n#elif DEBUGMODE==61\ngl_FragColor.rgb=clearcoatOut.specularEnvironmentR0;\r#define DEBUGMODE_GAMMA\n#elif DEBUGMODE==62 && defined(METALLICWORKFLOW)\ngl_FragColor.rgb=vec3(reflectivityOut.metallicRoughness.r);\r#elif DEBUGMODE==71 && defined(METALLICWORKFLOW)\ngl_FragColor.rgb=reflectivityOut.metallicF0;\r#elif DEBUGMODE==63\ngl_FragColor.rgb=vec3(roughness);\r#elif DEBUGMODE==64\ngl_FragColor.rgb=vec3(alphaG);\r#elif DEBUGMODE==65\ngl_FragColor.rgb=vec3(NdotV);\r#elif DEBUGMODE==66 && defined(CLEARCOAT) && defined(CLEARCOAT_TINT)\ngl_FragColor.rgb=clearcoatOut.clearCoatColor.rgb;\r#define DEBUGMODE_GAMMA\n#elif DEBUGMODE==67 && defined(CLEARCOAT)\ngl_FragColor.rgb=vec3(clearcoatOut.clearCoatRoughness);\r#elif DEBUGMODE==68 && defined(CLEARCOAT)\ngl_FragColor.rgb=vec3(clearcoatOut.clearCoatNdotV);\r#elif DEBUGMODE==69 && defined(SUBSURFACE) && defined(SS_TRANSLUCENCY)\ngl_FragColor.rgb=subSurfaceOut.transmittance;\r#elif DEBUGMODE==70 && defined(SUBSURFACE) && defined(SS_REFRACTION)\ngl_FragColor.rgb=subSurfaceOut.refractionTransmittance;\r#elif DEBUGMODE==80 && defined(RADIANCEOCCLUSION)\ngl_FragColor.rgb=vec3(seo);\r#elif DEBUGMODE==81 && defined(HORIZONOCCLUSION)\ngl_FragColor.rgb=vec3(eho);\r#elif DEBUGMODE==82 && defined(MS_BRDF_ENERGY_CONSERVATION)\ngl_FragColor.rgb=vec3(energyConservationFactor);\r#elif DEBUGMODE==83 && defined(ENVIRONMENTBRDF) && !defined(REFLECTIONMAP_SKYBOX)\ngl_FragColor.rgb=specularEnvironmentReflectance;\r#define DEBUGMODE_GAMMA\n#elif DEBUGMODE==84 && defined(CLEARCOAT) && defined(ENVIRONMENTBRDF) && !defined(REFLECTIONMAP_SKYBOX)\ngl_FragColor.rgb=clearcoatOut.clearCoatEnvironmentReflectance;\r#define DEBUGMODE_GAMMA\n#elif DEBUGMODE==85 && defined(SHEEN) && defined(REFLECTION)\ngl_FragColor.rgb=sheenOut.sheenEnvironmentReflectance;\r#define DEBUGMODE_GAMMA\n#elif DEBUGMODE==86 && defined(ALPHABLEND)\ngl_FragColor.rgb=vec3(luminanceOverAlpha);\r#elif DEBUGMODE==87\ngl_FragColor.rgb=vec3(alpha);\r#endif\ngl_FragColor.rgb*=vDebugMode.y;\r#ifdef DEBUGMODE_NORMALIZE\ngl_FragColor.rgb=normalize(gl_FragColor.rgb)*0.5+0.5;\r#endif\n#ifdef DEBUGMODE_GAMMA\ngl_FragColor.rgb=toGammaSpace(gl_FragColor.rgb);\r#endif\ngl_FragColor.a=1.0;\r#ifdef PREPASS\ngl_FragData[0]=toLinearSpace(gl_FragColor); \rgl_FragData[1]=vec4(0.,0.,0.,0.); \r#endif\nreturn;\r}\r#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const pbrDebug = { name, shader };\n//# sourceMappingURL=pbrDebug.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nconst name = \"pbrFragmentDeclaration\";\nconst shader = `uniform vec4 vEyePosition;\runiform vec3 vReflectionColor;\runiform vec4 vAlbedoColor;\runiform vec4 vLightingIntensity;\runiform vec4 vReflectivityColor;\runiform vec4 vMetallicReflectanceFactors;\runiform vec3 vEmissiveColor;\runiform float visibility;\runiform vec3 vAmbientColor;\r#ifdef ALBEDO\nuniform vec2 vAlbedoInfos;\r#endif\n#ifdef AMBIENT\nuniform vec4 vAmbientInfos;\r#endif\n#ifdef BUMP\nuniform vec3 vBumpInfos;\runiform vec2 vTangentSpaceParams;\r#endif\n#ifdef OPACITY\nuniform vec2 vOpacityInfos;\r#endif\n#ifdef EMISSIVE\nuniform vec2 vEmissiveInfos;\r#endif\n#ifdef LIGHTMAP\nuniform vec2 vLightmapInfos;\r#endif\n#ifdef REFLECTIVITY\nuniform vec3 vReflectivityInfos;\r#endif\n#ifdef MICROSURFACEMAP\nuniform vec2 vMicroSurfaceSamplerInfos;\r#endif\n#if defined(REFLECTIONMAP_SPHERICAL) || defined(REFLECTIONMAP_PROJECTION) || defined(SS_REFRACTION) || defined(PREPASS)\nuniform mat4 view;\r#endif\n#ifdef REFLECTION\nuniform vec2 vReflectionInfos;\r#ifdef REALTIME_FILTERING\nuniform vec2 vReflectionFilteringInfo;\r#endif\nuniform mat4 reflectionMatrix;\runiform vec3 vReflectionMicrosurfaceInfos;\r#if defined(USE_LOCAL_REFLECTIONMAP_CUBIC) && defined(REFLECTIONMAP_CUBIC)\nuniform vec3 vReflectionPosition;\runiform vec3 vReflectionSize; \r#endif\n#endif\n#if defined(SS_REFRACTION) && defined(SS_USE_LOCAL_REFRACTIONMAP_CUBIC)\nuniform vec3 vRefractionPosition;\runiform vec3 vRefractionSize; \r#endif\n#ifdef CLEARCOAT\nuniform vec2 vClearCoatParams;\runiform vec4 vClearCoatRefractionParams;\r#if defined(CLEARCOAT_TEXTURE) || defined(CLEARCOAT_TEXTURE_ROUGHNESS)\nuniform vec4 vClearCoatInfos;\r#endif\n#ifdef CLEARCOAT_TEXTURE\nuniform mat4 clearCoatMatrix;\r#endif\n#ifdef CLEARCOAT_TEXTURE_ROUGHNESS\nuniform mat4 clearCoatRoughnessMatrix;\r#endif\n#ifdef CLEARCOAT_BUMP\nuniform vec2 vClearCoatBumpInfos;\runiform vec2 vClearCoatTangentSpaceParams;\runiform mat4 clearCoatBumpMatrix;\r#endif\n#ifdef CLEARCOAT_TINT\nuniform vec4 vClearCoatTintParams;\runiform float clearCoatColorAtDistance;\r#ifdef CLEARCOAT_TINT_TEXTURE\nuniform vec2 vClearCoatTintInfos;\runiform mat4 clearCoatTintMatrix;\r#endif\n#endif\n#endif\n#ifdef IRIDESCENCE\nuniform vec4 vIridescenceParams;\r#if defined(IRIDESCENCE_TEXTURE) || defined(IRIDESCENCE_THICKNESS_TEXTURE)\nuniform vec4 vIridescenceInfos;\r#endif\n#ifdef IRIDESCENCE_TEXTURE\nuniform mat4 iridescenceMatrix;\r#endif\n#ifdef IRIDESCENCE_THICKNESS_TEXTURE\nuniform mat4 iridescenceThicknessMatrix;\r#endif\n#endif\n#ifdef ANISOTROPIC\nuniform vec3 vAnisotropy;\r#ifdef ANISOTROPIC_TEXTURE\nuniform vec2 vAnisotropyInfos;\runiform mat4 anisotropyMatrix;\r#endif\n#endif\n#ifdef SHEEN\nuniform vec4 vSheenColor;\r#ifdef SHEEN_ROUGHNESS\nuniform float vSheenRoughness;\r#endif\n#if defined(SHEEN_TEXTURE) || defined(SHEEN_TEXTURE_ROUGHNESS)\nuniform vec4 vSheenInfos;\r#endif\n#ifdef SHEEN_TEXTURE\nuniform mat4 sheenMatrix;\r#endif\n#ifdef SHEEN_TEXTURE_ROUGHNESS\nuniform mat4 sheenRoughnessMatrix;\r#endif\n#endif\n#ifdef SUBSURFACE\n#ifdef SS_REFRACTION\nuniform vec4 vRefractionMicrosurfaceInfos;\runiform vec4 vRefractionInfos;\runiform mat4 refractionMatrix;\r#ifdef REALTIME_FILTERING\nuniform vec2 vRefractionFilteringInfo;\r#endif\n#endif\n#ifdef SS_THICKNESSANDMASK_TEXTURE\nuniform vec2 vThicknessInfos;\runiform mat4 thicknessMatrix;\r#endif\n#ifdef SS_REFRACTIONINTENSITY_TEXTURE\nuniform vec2 vRefractionIntensityInfos;\runiform mat4 refractionIntensityMatrix;\r#endif\n#ifdef SS_TRANSLUCENCYINTENSITY_TEXTURE\nuniform vec2 vTranslucencyIntensityInfos;\runiform mat4 translucencyIntensityMatrix;\r#endif\nuniform vec2 vThicknessParam;\runiform vec3 vDiffusionDistance;\runiform vec4 vTintColor;\runiform vec3 vSubSurfaceIntensity;\r#endif\n#ifdef PREPASS\n#ifdef SS_SCATTERING\nuniform float scatteringDiffusionProfile;\r#endif\n#endif\n#if DEBUGMODE>0\nuniform vec2 vDebugMode;\r#endif\n#ifdef DETAIL\nuniform vec4 vDetailInfos;\r#endif\n#ifdef USESPHERICALFROMREFLECTIONMAP\n#ifdef SPHERICAL_HARMONICS\nuniform vec3 vSphericalL00;\runiform vec3 vSphericalL1_1;\runiform vec3 vSphericalL10;\runiform vec3 vSphericalL11;\runiform vec3 vSphericalL2_2;\runiform vec3 vSphericalL2_1;\runiform vec3 vSphericalL20;\runiform vec3 vSphericalL21;\runiform vec3 vSphericalL22;\r#else\nuniform vec3 vSphericalX;\runiform vec3 vSphericalY;\runiform vec3 vSphericalZ;\runiform vec3 vSphericalXX_ZZ;\runiform vec3 vSphericalYY_ZZ;\runiform vec3 vSphericalZZ;\runiform vec3 vSphericalXY;\runiform vec3 vSphericalYZ;\runiform vec3 vSphericalZX;\r#endif\n#endif\n#define ADDITIONAL_FRAGMENT_DECLARATION\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const pbrFragmentDeclaration = { name, shader };\n//# sourceMappingURL=pbrFragmentDeclaration.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nimport \"./samplerFragmentDeclaration.js\";\nimport \"./samplerFragmentAlternateDeclaration.js\";\nconst name = \"pbrFragmentSamplersDeclaration\";\nconst shader = `#include<samplerFragmentDeclaration>(_DEFINENAME_,ALBEDO,_VARYINGNAME_,Albedo,_SAMPLERNAME_,albedo)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,AMBIENT,_VARYINGNAME_,Ambient,_SAMPLERNAME_,ambient)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,OPACITY,_VARYINGNAME_,Opacity,_SAMPLERNAME_,opacity)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,EMISSIVE,_VARYINGNAME_,Emissive,_SAMPLERNAME_,emissive)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,LIGHTMAP,_VARYINGNAME_,Lightmap,_SAMPLERNAME_,lightmap)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,REFLECTIVITY,_VARYINGNAME_,Reflectivity,_SAMPLERNAME_,reflectivity)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,MICROSURFACEMAP,_VARYINGNAME_,MicroSurfaceSampler,_SAMPLERNAME_,microSurface)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,METALLIC_REFLECTANCE,_VARYINGNAME_,MetallicReflectance,_SAMPLERNAME_,metallicReflectance)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,REFLECTANCE,_VARYINGNAME_,Reflectance,_SAMPLERNAME_,reflectance)\n#ifdef CLEARCOAT\n#include<samplerFragmentDeclaration>(_DEFINENAME_,CLEARCOAT_TEXTURE,_VARYINGNAME_,ClearCoat,_SAMPLERNAME_,clearCoat)\n#include<samplerFragmentAlternateDeclaration>(_DEFINENAME_,CLEARCOAT_TEXTURE_ROUGHNESS,_VARYINGNAME_,ClearCoatRoughness)\n#if defined(CLEARCOAT_TEXTURE_ROUGHNESS) && !defined(CLEARCOAT_TEXTURE_ROUGHNESS_IDENTICAL)\nuniform sampler2D clearCoatRoughnessSampler;\r#endif\n#include<samplerFragmentDeclaration>(_DEFINENAME_,CLEARCOAT_BUMP,_VARYINGNAME_,ClearCoatBump,_SAMPLERNAME_,clearCoatBump)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,CLEARCOAT_TINT_TEXTURE,_VARYINGNAME_,ClearCoatTint,_SAMPLERNAME_,clearCoatTint)\n#endif\n#ifdef IRIDESCENCE\n#include<samplerFragmentDeclaration>(_DEFINENAME_,IRIDESCENCE_TEXTURE,_VARYINGNAME_,Iridescence,_SAMPLERNAME_,iridescence)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,IRIDESCENCE_THICKNESS_TEXTURE,_VARYINGNAME_,IridescenceThickness,_SAMPLERNAME_,iridescenceThickness)\n#endif\n#ifdef SHEEN\n#include<samplerFragmentDeclaration>(_DEFINENAME_,SHEEN_TEXTURE,_VARYINGNAME_,Sheen,_SAMPLERNAME_,sheen)\n#include<samplerFragmentAlternateDeclaration>(_DEFINENAME_,SHEEN_TEXTURE_ROUGHNESS,_VARYINGNAME_,SheenRoughness)\n#if defined(SHEEN_ROUGHNESS) && defined(SHEEN_TEXTURE_ROUGHNESS) && !defined(SHEEN_TEXTURE_ROUGHNESS_IDENTICAL)\nuniform sampler2D sheenRoughnessSampler;\r#endif\n#endif\n#ifdef ANISOTROPIC\n#include<samplerFragmentDeclaration>(_DEFINENAME_,ANISOTROPIC_TEXTURE,_VARYINGNAME_,Anisotropy,_SAMPLERNAME_,anisotropy)\n#endif\n#ifdef REFLECTION\n#ifdef REFLECTIONMAP_3D\n#define sampleReflection(s,c) textureCube(s,c)\nuniform samplerCube reflectionSampler;\r#ifdef LODBASEDMICROSFURACE\n#define sampleReflectionLod(s,c,l) textureCubeLodEXT(s,c,l)\n#else\nuniform samplerCube reflectionSamplerLow;\runiform samplerCube reflectionSamplerHigh;\r#endif\n#ifdef USEIRRADIANCEMAP\nuniform samplerCube irradianceSampler;\r#endif\n#else\n#define sampleReflection(s,c) texture2D(s,c)\nuniform sampler2D reflectionSampler;\r#ifdef LODBASEDMICROSFURACE\n#define sampleReflectionLod(s,c,l) texture2DLodEXT(s,c,l)\n#else\nuniform sampler2D reflectionSamplerLow;\runiform sampler2D reflectionSamplerHigh;\r#endif\n#ifdef USEIRRADIANCEMAP\nuniform sampler2D irradianceSampler;\r#endif\n#endif\n#ifdef REFLECTIONMAP_SKYBOX\nvarying vec3 vPositionUVW;\r#else\n#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\nvarying vec3 vDirectionW;\r#endif\n#endif\n#endif\n#ifdef ENVIRONMENTBRDF\nuniform sampler2D environmentBrdfSampler;\r#endif\n#ifdef SUBSURFACE\n#ifdef SS_REFRACTION\n#ifdef SS_REFRACTIONMAP_3D\n#define sampleRefraction(s,c) textureCube(s,c)\nuniform samplerCube refractionSampler;\r#ifdef LODBASEDMICROSFURACE\n#define sampleRefractionLod(s,c,l) textureCubeLodEXT(s,c,l)\n#else\nuniform samplerCube refractionSamplerLow;\runiform samplerCube refractionSamplerHigh;\r#endif\n#else\n#define sampleRefraction(s,c) texture2D(s,c)\nuniform sampler2D refractionSampler;\r#ifdef LODBASEDMICROSFURACE\n#define sampleRefractionLod(s,c,l) texture2DLodEXT(s,c,l)\n#else\nuniform sampler2D refractionSamplerLow;\runiform sampler2D refractionSamplerHigh;\r#endif\n#endif\n#endif\n#include<samplerFragmentDeclaration>(_DEFINENAME_,SS_THICKNESSANDMASK_TEXTURE,_VARYINGNAME_,Thickness,_SAMPLERNAME_,thickness)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,SS_REFRACTIONINTENSITY_TEXTURE,_VARYINGNAME_,RefractionIntensity,_SAMPLERNAME_,refractionIntensity)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,SS_TRANSLUCENCYINTENSITY_TEXTURE,_VARYINGNAME_,TranslucencyIntensity,_SAMPLERNAME_,translucencyIntensity)\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const pbrFragmentSamplersDeclaration = { name, shader };\n//# sourceMappingURL=pbrFragmentSamplersDeclaration.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nconst name = \"pbrHelperFunctions\";\nconst shader = `#define RECIPROCAL_PI2 0.15915494\n#define RECIPROCAL_PI 0.31830988618\n#define MINIMUMVARIANCE 0.0005\nfloat convertRoughnessToAverageSlope(float roughness)\r{\rreturn square(roughness)+MINIMUMVARIANCE;\r}\rfloat fresnelGrazingReflectance(float reflectance0) {\rfloat reflectance90=saturate(reflectance0*25.0);\rreturn reflectance90;\r}\rvec2 getAARoughnessFactors(vec3 normalVector) {\r#ifdef SPECULARAA\nvec3 nDfdx=dFdx(normalVector.xyz);\rvec3 nDfdy=dFdy(normalVector.xyz);\rfloat slopeSquare=max(dot(nDfdx,nDfdx),dot(nDfdy,nDfdy));\rfloat geometricRoughnessFactor=pow(saturate(slopeSquare),0.333);\rfloat geometricAlphaGFactor=sqrt(slopeSquare);\rgeometricAlphaGFactor*=0.75;\rreturn vec2(geometricRoughnessFactor,geometricAlphaGFactor);\r#else\nreturn vec2(0.);\r#endif\n}\r#ifdef ANISOTROPIC\nvec2 getAnisotropicRoughness(float alphaG,float anisotropy) {\rfloat alphaT=max(alphaG*(1.0+anisotropy),MINIMUMVARIANCE);\rfloat alphaB=max(alphaG*(1.0-anisotropy),MINIMUMVARIANCE);\rreturn vec2(alphaT,alphaB);\r}\rvec3 getAnisotropicBentNormals(const vec3 T,const vec3 B,const vec3 N,const vec3 V,float anisotropy) {\rvec3 anisotropicFrameDirection=anisotropy>=0.0 ? B : T;\rvec3 anisotropicFrameTangent=cross(normalize(anisotropicFrameDirection),V);\rvec3 anisotropicFrameNormal=cross(anisotropicFrameTangent,anisotropicFrameDirection);\rvec3 anisotropicNormal=normalize(mix(N,anisotropicFrameNormal,abs(anisotropy)));\rreturn anisotropicNormal;\r}\r#endif\n#if defined(CLEARCOAT) || defined(SS_REFRACTION)\nvec3 cocaLambert(vec3 alpha,float distance) {\rreturn exp(-alpha*distance);\r}\rvec3 cocaLambert(float NdotVRefract,float NdotLRefract,vec3 alpha,float thickness) {\rreturn cocaLambert(alpha,(thickness*((NdotLRefract+NdotVRefract)/(NdotLRefract*NdotVRefract))));\r}\rvec3 computeColorAtDistanceInMedia(vec3 color,float distance) {\rreturn -log(color)/distance;\r}\rvec3 computeClearCoatAbsorption(float NdotVRefract,float NdotLRefract,vec3 clearCoatColor,float clearCoatThickness,float clearCoatIntensity) {\rvec3 clearCoatAbsorption=mix(vec3(1.0),\rcocaLambert(NdotVRefract,NdotLRefract,clearCoatColor,clearCoatThickness),\rclearCoatIntensity);\rreturn clearCoatAbsorption;\r}\r#endif\n#ifdef MICROSURFACEAUTOMATIC\nfloat computeDefaultMicroSurface(float microSurface,vec3 reflectivityColor)\r{\rconst float kReflectivityNoAlphaWorkflow_SmoothnessMax=0.95;\rfloat reflectivityLuminance=getLuminance(reflectivityColor);\rfloat reflectivityLuma=sqrt(reflectivityLuminance);\rmicroSurface=reflectivityLuma*kReflectivityNoAlphaWorkflow_SmoothnessMax;\rreturn microSurface;\r}\r#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const pbrHelperFunctions = { name, shader };\n//# sourceMappingURL=pbrHelperFunctions.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nimport \"./sceneUboDeclaration.js\";\nimport \"./meshUboDeclaration.js\";\nconst name = \"pbrUboDeclaration\";\nconst shader = `layout(std140,column_major) uniform;\runiform Material {\rvec2 vAlbedoInfos;\rvec4 vAmbientInfos;\rvec2 vOpacityInfos;\rvec2 vEmissiveInfos;\rvec2 vLightmapInfos;\rvec3 vReflectivityInfos;\rvec2 vMicroSurfaceSamplerInfos;\rvec2 vReflectionInfos;\rvec2 vReflectionFilteringInfo;\rvec3 vReflectionPosition;\rvec3 vReflectionSize;\rvec3 vBumpInfos;\rmat4 albedoMatrix;\rmat4 ambientMatrix;\rmat4 opacityMatrix;\rmat4 emissiveMatrix;\rmat4 lightmapMatrix;\rmat4 reflectivityMatrix;\rmat4 microSurfaceSamplerMatrix;\rmat4 bumpMatrix;\rvec2 vTangentSpaceParams;\rmat4 reflectionMatrix;\rvec3 vReflectionColor;\rvec4 vAlbedoColor;\rvec4 vLightingIntensity;\rvec3 vReflectionMicrosurfaceInfos;\rfloat pointSize;\rvec4 vReflectivityColor;\rvec3 vEmissiveColor;\rvec3 vAmbientColor;\rvec2 vDebugMode;\rvec4 vMetallicReflectanceFactors;\rvec2 vMetallicReflectanceInfos;\rmat4 metallicReflectanceMatrix;\rvec2 vReflectanceInfos;\rmat4 reflectanceMatrix;\rvec3 vSphericalL00;\rvec3 vSphericalL1_1;\rvec3 vSphericalL10;\rvec3 vSphericalL11;\rvec3 vSphericalL2_2;\rvec3 vSphericalL2_1;\rvec3 vSphericalL20;\rvec3 vSphericalL21;\rvec3 vSphericalL22;\rvec3 vSphericalX;\rvec3 vSphericalY;\rvec3 vSphericalZ;\rvec3 vSphericalXX_ZZ;\rvec3 vSphericalYY_ZZ;\rvec3 vSphericalZZ;\rvec3 vSphericalXY;\rvec3 vSphericalYZ;\rvec3 vSphericalZX;\r#define ADDITIONAL_UBO_DECLARATION\n};\r#include<sceneUboDeclaration>\n#include<meshUboDeclaration>\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const pbrUboDeclaration = { name, shader };\n//# sourceMappingURL=pbrUboDeclaration.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nconst name = \"samplerVertexDeclaration\";\nconst shader = `#if defined(_DEFINENAME_) && _DEFINENAME_DIRECTUV==0\nvarying vec2 v_VARYINGNAME_UV;\r#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const samplerVertexDeclaration = { name, shader };\n//# sourceMappingURL=samplerVertexDeclaration.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nconst name = \"samplerVertexImplementation\";\nconst shader = `#if defined(_DEFINENAME_) && _DEFINENAME_DIRECTUV==0\nif (v_INFONAME_==0.)\r{\rv_VARYINGNAME_UV=vec2(_MATRIXNAME_Matrix*vec4(uvUpdated,1.0,0.0));\r}\r#ifdef UV2\nelse if (v_INFONAME_==1.)\r{\rv_VARYINGNAME_UV=vec2(_MATRIXNAME_Matrix*vec4(uv2,1.0,0.0));\r}\r#endif\n#ifdef UV3\nelse if (v_INFONAME_==2.)\r{\rv_VARYINGNAME_UV=vec2(_MATRIXNAME_Matrix*vec4(uv3,1.0,0.0));\r}\r#endif\n#ifdef UV4\nelse if (v_INFONAME_==3.)\r{\rv_VARYINGNAME_UV=vec2(_MATRIXNAME_Matrix*vec4(uv4,1.0,0.0));\r}\r#endif\n#ifdef UV5\nelse if (v_INFONAME_==4.)\r{\rv_VARYINGNAME_UV=vec2(_MATRIXNAME_Matrix*vec4(uv5,1.0,0.0));\r}\r#endif\n#ifdef UV6\nelse if (v_INFONAME_==5.)\r{\rv_VARYINGNAME_UV=vec2(_MATRIXNAME_Matrix*vec4(uv6,1.0,0.0));\r}\r#endif\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const samplerVertexImplementation = { name, shader };\n//# sourceMappingURL=samplerVertexImplementation.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nconst name = \"sceneUboDeclaration\";\nconst shader = `layout(std140,column_major) uniform;\runiform Scene {\rmat4 viewProjection;\r#ifdef MULTIVIEW\nmat4 viewProjectionR;\r#endif \nmat4 view;\rmat4 projection;\rvec4 vEyePosition;\r};\r`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const sceneUboDeclaration = { name, shader };\n//# sourceMappingURL=sceneUboDeclaration.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nconst name = \"screenSpaceRayTrace\";\nconst shader = `float distanceSquared(vec2 a,vec2 b) { a-=b; return dot(a,a); }\r/**\r\\param csOrigin Camera-space ray origin,which must be \rwithin the view volume and must have z>0.01 and project within the valid screen rectangle\r\\param csDirection Unit length camera-space ray direction\r\\param projectToPixelMatrix A projection matrix that maps to **pixel** coordinates \r(**not** [-1,+1] normalized device coordinates).\r\\param csZBuffer The camera-space Z buffer\r\\param csZBufferSize Dimensions of csZBuffer\r\\param csZThickness Camera space csZThickness to ascribe to each pixel in the depth buffer\r\\param nearPlaneZ Positive number. Doesn't have to be THE actual near plane,just a reasonable value\rfor clipping rays headed towards the camera\r\\param stride Step in horizontal or vertical pixels between samples. This is a float\rbecause integer math is slow on GPUs,but should be set to an integer>=1\r\\param jitterFraction Number between 0 and 1 for how far to bump the ray in stride units\rto conceal banding artifacts,plus the stride ray offset.\r\\param maxSteps Maximum number of iterations. Higher gives better images but may be slow\r\\param maxRayTraceDistance Maximum camera-space distance to trace before returning a miss\r\\param selfCollisionNumSkip Number of steps to skip at start when raytracing to avoid self collisions.\r1 is a reasonable value,depending on the scene you may need to set this value to 2\r\\param hitPixel Pixel coordinates of the first intersection with the scene\r\\param csHitPoint Camera space location of the ray hit\r*/\r#define inline\nbool traceScreenSpaceRay1(\rvec3 csOrigin,\rvec3 csDirection,\rmat4 projectToPixelMatrix,\rsampler2D csZBuffer,\rvec2 csZBufferSize,\r#ifdef SSRAYTRACE_USE_BACK_DEPTHBUFFER\nsampler2D csZBackBuffer,\rfloat csZBackSizeFactor,\r#endif\nfloat csZThickness,\rfloat nearPlaneZ,\rfloat stride,\rfloat jitterFraction,\rfloat maxSteps,\rfloat maxRayTraceDistance,\rfloat selfCollisionNumSkip,\rout vec2 startPixel,\rout vec2 hitPixel,\rout vec3 csHitPoint\r#ifdef SSRAYTRACE_DEBUG\n,out vec3 debugColor\r#endif\n)\r{\r#ifdef SSRAYTRACE_RIGHT_HANDED_SCENE\nfloat rayLength=(csOrigin.z+csDirection.z*maxRayTraceDistance)>-nearPlaneZ ? (-nearPlaneZ-csOrigin.z)/csDirection.z : maxRayTraceDistance;\r#else\nfloat rayLength=(csOrigin.z+csDirection.z*maxRayTraceDistance)<nearPlaneZ ? (nearPlaneZ-csOrigin.z)/csDirection.z : maxRayTraceDistance;\r#endif\nvec3 csEndPoint=csOrigin+csDirection*rayLength;\rhitPixel=vec2(-1.0,-1.0);\rvec4 H0=projectToPixelMatrix*vec4(csOrigin,1.0);\rvec4 H1=projectToPixelMatrix*vec4(csEndPoint,1.0);\rfloat k0=1.0/H0.w;\rfloat k1=1.0/H1.w;\rvec3 Q0=csOrigin*k0;\rvec3 Q1=csEndPoint*k1;\rvec2 P0=H0.xy*k0;\rvec2 P1=H1.xy*k1;\r#ifdef SSRAYTRACE_CLIP_TO_FRUSTUM\nfloat xMax=csZBufferSize.x-0.5,xMin=0.5,yMax=csZBufferSize.y-0.5,yMin=0.5;\rfloat alpha=0.0;\rif ((P1.y>yMax) || (P1.y<yMin)) {\ralpha=(P1.y-((P1.y>yMax) ? yMax : yMin))/(P1.y-P0.y);\r}\rif ((P1.x>xMax) || (P1.x<xMin)) {\ralpha=max(alpha,(P1.x-((P1.x>xMax) ? xMax : xMin))/(P1.x-P0.x));\r}\rP1=mix(P1,P0,alpha); k1=mix(k1,k0,alpha); Q1=mix(Q1,Q0,alpha);\r#endif\nP1+=vec2((distanceSquared(P0,P1)<0.0001) ? 0.01 : 0.0);\rvec2 delta=P1-P0;\rbool permute=false;\rif (abs(delta.x)<abs(delta.y)) { \rpermute=true;\rdelta=delta.yx;\rP0=P0.yx;\rP1=P1.yx; \r}\rfloat stepDirection=sign(delta.x);\rfloat invdx=stepDirection/delta.x;\rvec2 dP=vec2(stepDirection,delta.y*invdx);\rvec3 dQ=(Q1-Q0)*invdx;\rfloat dk=(k1-k0)*invdx;\rfloat zMin=min(csEndPoint.z,csOrigin.z);\rfloat zMax=max(csEndPoint.z,csOrigin.z);\rdP*=stride; dQ*=stride; dk*=stride;\rP0+=dP*jitterFraction; Q0+=dQ*jitterFraction; k0+=dk*jitterFraction;\rvec4 pqk=vec4(P0,Q0.z,k0);\rvec4 dPQK=vec4(dP,dQ.z,dk);\rstartPixel=permute ? P0.yx : P0.xy;\rfloat prevZMaxEstimate=csOrigin.z;\rfloat rayZMin=prevZMaxEstimate,rayZMax=prevZMaxEstimate;\rfloat sceneZMax=rayZMax+1e4;\rfloat end=P1.x*stepDirection;\rbool hit=false;\rfloat stepCount;\rfor (stepCount=0.0;\rstepCount<=selfCollisionNumSkip ||\r(pqk.x*stepDirection)<=end &&\rstepCount<maxSteps &&\r!hit &&\rsceneZMax != 0.0; \rpqk+=dPQK,++stepCount)\r{\rhitPixel=permute ? pqk.yx : pqk.xy;\rrayZMin=prevZMaxEstimate;\rrayZMax=(dPQK.z*0.5+pqk.z)/(dPQK.w*0.5+pqk.w);\rrayZMax=clamp(rayZMax,zMin,zMax);\rprevZMaxEstimate=rayZMax;\rif (rayZMin>rayZMax) { \rfloat t=rayZMin; rayZMin=rayZMax; rayZMax=t;\r}\rsceneZMax=texelFetch(csZBuffer,ivec2(hitPixel),0).r;\r#ifdef SSRAYTRACE_RIGHT_HANDED_SCENE\n#ifdef SSRAYTRACE_USE_BACK_DEPTHBUFFER\nfloat sceneBackZ=texelFetch(csZBackBuffer,ivec2(hitPixel/csZBackSizeFactor),0).r;\rhit=(rayZMax>=sceneBackZ-csZThickness) && (rayZMin<=sceneZMax);\r#else\nhit=(rayZMax>=sceneZMax-csZThickness) && (rayZMin<=sceneZMax);\r#endif\n#else\n#ifdef SSRAYTRACE_USE_BACK_DEPTHBUFFER\nfloat sceneBackZ=texelFetch(csZBackBuffer,ivec2(hitPixel/csZBackSizeFactor),0).r;\rhit=(rayZMin<=sceneBackZ+csZThickness) && (rayZMax>=sceneZMax) && (sceneZMax != 0.0);\r#else\nhit=(rayZMin<=sceneZMax+csZThickness) && (rayZMax>=sceneZMax);\r#endif\n#endif\n}\rpqk-=dPQK;\rstepCount-=1.0;\r#ifdef SSRAYTRACE_ENABLE_REFINEMENT\nif (stride>1.0 && hit) {\rpqk-=dPQK;\rstepCount-=1.0;\rfloat invStride=1.0/stride;\rdPQK*=invStride;\rfloat refinementStepCount=0.0;\rprevZMaxEstimate=pqk.z/pqk.w;\rrayZMax=prevZMaxEstimate;\rsceneZMax=rayZMax+1e7;\rfor (;\rrefinementStepCount<=1.0 ||\r(refinementStepCount<=stride*1.4) &&\r(rayZMax<sceneZMax) && (sceneZMax != 0.0);\rpqk+=dPQK,refinementStepCount+=1.0)\r{\rrayZMin=prevZMaxEstimate;\rrayZMax=(dPQK.z*0.5+pqk.z)/(dPQK.w*0.5+pqk.w);\rrayZMax=clamp(rayZMax,zMin,zMax);\rprevZMaxEstimate=rayZMax;\rrayZMax=max(rayZMax,rayZMin);\rhitPixel=permute ? pqk.yx : pqk.xy;\rsceneZMax=texelFetch(csZBuffer,ivec2(hitPixel),0).r;\r}\rpqk-=dPQK;\rrefinementStepCount-=1.0;\rstepCount+=refinementStepCount/stride;\r}\r#endif\nQ0.xy+=dQ.xy*stepCount;\rQ0.z=pqk.z;\rcsHitPoint=Q0/pqk.w;\r#ifdef SSRAYTRACE_DEBUG\nif (((pqk.x+dPQK.x)*stepDirection)>end) {\rdebugColor=vec3(0,0,1);\r} else if ((stepCount+1.0)>=maxSteps) {\rdebugColor=vec3(1,0,0);\r} else if (sceneZMax==0.0) {\rdebugColor=vec3(1,1,0);\r} else {\rdebugColor=vec3(0,stepCount/maxSteps,0);\r}\r#endif\nreturn hit;\r}\r`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const screenSpaceRayTrace = { name, shader };\n//# sourceMappingURL=screenSpaceRayTrace.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nconst name = \"shadowMapFragment\";\nconst shader = `float depthSM=vDepthMetricSM;\r#if defined(SM_DEPTHCLAMP) && SM_DEPTHCLAMP==1\n#if SM_USEDISTANCE==1\ndepthSM=(length(vPositionWSM-lightDataSM)+depthValuesSM.x)/depthValuesSM.y+biasAndScaleSM.x;\r#else\n#ifdef USE_REVERSE_DEPTHBUFFER\ndepthSM=(-zSM+depthValuesSM.x)/depthValuesSM.y+biasAndScaleSM.x;\r#else\ndepthSM=(zSM+depthValuesSM.x)/depthValuesSM.y+biasAndScaleSM.x;\r#endif\n#endif\n#ifdef USE_REVERSE_DEPTHBUFFER\ngl_FragDepth=clamp(1.0-depthSM,0.0,1.0);\r#else\ngl_FragDepth=clamp(depthSM,0.0,1.0); \r#endif\n#elif SM_USEDISTANCE==1\ndepthSM=(length(vPositionWSM-lightDataSM)+depthValuesSM.x)/depthValuesSM.y+biasAndScaleSM.x;\r#endif\n#if SM_ESM==1\ndepthSM=clamp(exp(-min(87.,biasAndScaleSM.z*depthSM)),0.,1.);\r#endif\n#if SM_FLOAT==1\ngl_FragColor=vec4(depthSM,1.0,1.0,1.0);\r#else\ngl_FragColor=pack(depthSM);\r#endif\nreturn;`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const shadowMapFragment = { name, shader };\n//# sourceMappingURL=shadowMapFragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nimport \"./sceneUboDeclaration.js\";\nimport \"./meshUboDeclaration.js\";\nconst name = \"shadowMapUboDeclaration\";\nconst shader = `layout(std140,column_major) uniform;\r#include<sceneUboDeclaration>\n#include<meshUboDeclaration>\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const shadowMapUboDeclaration = { name, shader };\n//# sourceMappingURL=shadowMapUboDeclaration.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nconst name = \"meshVertexDeclaration\";\nconst shader = `uniform mat4 world;\runiform float visibility;\r`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const meshVertexDeclaration = { name, shader };\n//# sourceMappingURL=meshVertexDeclaration.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nimport \"./sceneVertexDeclaration.js\";\nimport \"./meshVertexDeclaration.js\";\nconst name = \"shadowMapVertexDeclaration\";\nconst shader = `#include<sceneVertexDeclaration>\n#include<meshVertexDeclaration>\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const shadowMapVertexDeclaration = { name, shader };\n//# sourceMappingURL=shadowMapVertexDeclaration.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nconst name = \"shadowMapVertexMetric\";\nconst shader = `#if SM_USEDISTANCE==1\nvPositionWSM=worldPos.xyz;\r#endif\n#if SM_DEPTHTEXTURE==1\n#ifdef IS_NDC_HALF_ZRANGE\n#define BIASFACTOR 0.5\n#else\n#define BIASFACTOR 1.0\n#endif\n#ifdef USE_REVERSE_DEPTHBUFFER\ngl_Position.z-=biasAndScaleSM.x*gl_Position.w*BIASFACTOR;\r#else\ngl_Position.z+=biasAndScaleSM.x*gl_Position.w*BIASFACTOR;\r#endif\n#endif\n#if defined(SM_DEPTHCLAMP) && SM_DEPTHCLAMP==1\nzSM=gl_Position.z;\rgl_Position.z=0.0;\r#elif SM_USEDISTANCE==0\n#ifdef USE_REVERSE_DEPTHBUFFER\nvDepthMetricSM=(-gl_Position.z+depthValuesSM.x)/depthValuesSM.y+biasAndScaleSM.x;\r#else\nvDepthMetricSM=(gl_Position.z+depthValuesSM.x)/depthValuesSM.y+biasAndScaleSM.x;\r#endif\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const shadowMapVertexMetric = { name, shader };\n//# sourceMappingURL=shadowMapVertexMetric.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nconst name = \"shadowMapVertexNormalBias\";\nconst shader = `#if SM_NORMALBIAS==1\n#if SM_DIRECTIONINLIGHTDATA==1\nvec3 worldLightDirSM=normalize(-lightDataSM.xyz);\r#else\nvec3 directionToLightSM=lightDataSM.xyz-worldPos.xyz;\rvec3 worldLightDirSM=normalize(directionToLightSM);\r#endif\nfloat ndlSM=dot(vNormalW,worldLightDirSM);\rfloat sinNLSM=sqrt(1.0-ndlSM*ndlSM);\rfloat normalBiasSM=biasAndScaleSM.y*sinNLSM;\rworldPos.xyz-=vNormalW*normalBiasSM;\r#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const shadowMapVertexNormalBias = { name, shader };\n//# sourceMappingURL=shadowMapVertexNormalBias.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nconst name = \"shadowsFragmentFunctions\";\nconst shader = `#ifdef SHADOWS\n#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)\n#define TEXTUREFUNC(s,c,l) texture2DLodEXT(s,c,l)\n#else\n#define TEXTUREFUNC(s,c,b) texture2D(s,c,b)\n#endif\n#ifndef SHADOWFLOAT\nfloat unpack(vec4 color)\r{\rconst vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);\rreturn dot(color,bit_shift);\r}\r#endif\nfloat computeFallOff(float value,vec2 clipSpace,float frustumEdgeFalloff)\r{\rfloat mask=smoothstep(1.0-frustumEdgeFalloff,1.00000012,clamp(dot(clipSpace,clipSpace),0.,1.));\rreturn mix(value,1.0,mask);\r}\r#define inline\nfloat computeShadowCube(vec3 lightPosition,samplerCube shadowSampler,float darkness,vec2 depthValues)\r{\rvec3 directionToLight=vPositionW-lightPosition;\rfloat depth=length(directionToLight);\rdepth=(depth+depthValues.x)/(depthValues.y);\rdepth=clamp(depth,0.,1.0);\rdirectionToLight=normalize(directionToLight);\rdirectionToLight.y=-directionToLight.y;\r#ifndef SHADOWFLOAT\nfloat shadow=unpack(textureCube(shadowSampler,directionToLight));\r#else\nfloat shadow=textureCube(shadowSampler,directionToLight).x;\r#endif\nreturn depth>shadow ? darkness : 1.0;\r}\r#define inline\nfloat computeShadowWithPoissonSamplingCube(vec3 lightPosition,samplerCube shadowSampler,float mapSize,float darkness,vec2 depthValues)\r{\rvec3 directionToLight=vPositionW-lightPosition;\rfloat depth=length(directionToLight);\rdepth=(depth+depthValues.x)/(depthValues.y);\rdepth=clamp(depth,0.,1.0);\rdirectionToLight=normalize(directionToLight);\rdirectionToLight.y=-directionToLight.y;\rfloat visibility=1.;\rvec3 poissonDisk[4];\rpoissonDisk[0]=vec3(-1.0,1.0,-1.0);\rpoissonDisk[1]=vec3(1.0,-1.0,-1.0);\rpoissonDisk[2]=vec3(-1.0,-1.0,-1.0);\rpoissonDisk[3]=vec3(1.0,-1.0,1.0);\r#ifndef SHADOWFLOAT\nif (unpack(textureCube(shadowSampler,directionToLight+poissonDisk[0]*mapSize))<depth) visibility-=0.25;\rif (unpack(textureCube(shadowSampler,directionToLight+poissonDisk[1]*mapSize))<depth) visibility-=0.25;\rif (unpack(textureCube(shadowSampler,directionToLight+poissonDisk[2]*mapSize))<depth) visibility-=0.25;\rif (unpack(textureCube(shadowSampler,directionToLight+poissonDisk[3]*mapSize))<depth) visibility-=0.25;\r#else\nif (textureCube(shadowSampler,directionToLight+poissonDisk[0]*mapSize).x<depth) visibility-=0.25;\rif (textureCube(shadowSampler,directionToLight+poissonDisk[1]*mapSize).x<depth) visibility-=0.25;\rif (textureCube(shadowSampler,directionToLight+poissonDisk[2]*mapSize).x<depth) visibility-=0.25;\rif (textureCube(shadowSampler,directionToLight+poissonDisk[3]*mapSize).x<depth) visibility-=0.25;\r#endif\nreturn min(1.0,visibility+darkness);\r}\r#define inline\nfloat computeShadowWithESMCube(vec3 lightPosition,samplerCube shadowSampler,float darkness,float depthScale,vec2 depthValues)\r{\rvec3 directionToLight=vPositionW-lightPosition;\rfloat depth=length(directionToLight);\rdepth=(depth+depthValues.x)/(depthValues.y);\rfloat shadowPixelDepth=clamp(depth,0.,1.0);\rdirectionToLight=normalize(directionToLight);\rdirectionToLight.y=-directionToLight.y;\r#ifndef SHADOWFLOAT\nfloat shadowMapSample=unpack(textureCube(shadowSampler,directionToLight));\r#else\nfloat shadowMapSample=textureCube(shadowSampler,directionToLight).x;\r#endif\nfloat esm=1.0-clamp(exp(min(87.,depthScale*shadowPixelDepth))*shadowMapSample,0.,1.-darkness); \rreturn esm;\r}\r#define inline\nfloat computeShadowWithCloseESMCube(vec3 lightPosition,samplerCube shadowSampler,float darkness,float depthScale,vec2 depthValues)\r{\rvec3 directionToLight=vPositionW-lightPosition;\rfloat depth=length(directionToLight);\rdepth=(depth+depthValues.x)/(depthValues.y);\rfloat shadowPixelDepth=clamp(depth,0.,1.0);\rdirectionToLight=normalize(directionToLight);\rdirectionToLight.y=-directionToLight.y;\r#ifndef SHADOWFLOAT\nfloat shadowMapSample=unpack(textureCube(shadowSampler,directionToLight));\r#else\nfloat shadowMapSample=textureCube(shadowSampler,directionToLight).x;\r#endif\nfloat esm=clamp(exp(min(87.,-depthScale*(shadowPixelDepth-shadowMapSample))),darkness,1.);\rreturn esm;\r}\r#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)\n#define inline\nfloat computeShadowCSM(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray shadowSampler,float darkness,float frustumEdgeFalloff)\r{\rvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\rvec2 uv=0.5*clipSpace.xy+vec2(0.5);\rvec3 uvLayer=vec3(uv.x,uv.y,layer);\rfloat shadowPixelDepth=clamp(depthMetric,0.,1.0);\r#ifndef SHADOWFLOAT\nfloat shadow=unpack(texture2D(shadowSampler,uvLayer));\r#else\nfloat shadow=texture2D(shadowSampler,uvLayer).x;\r#endif\nreturn shadowPixelDepth>shadow ? computeFallOff(darkness,clipSpace.xy,frustumEdgeFalloff) : 1.;\r}\r#endif\n#define inline\nfloat computeShadow(vec4 vPositionFromLight,float depthMetric,sampler2D shadowSampler,float darkness,float frustumEdgeFalloff)\r{\rvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\rvec2 uv=0.5*clipSpace.xy+vec2(0.5);\rif (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)\r{\rreturn 1.0;\r}\relse\r{\rfloat shadowPixelDepth=clamp(depthMetric,0.,1.0);\r#ifndef SHADOWFLOAT\nfloat shadow=unpack(TEXTUREFUNC(shadowSampler,uv,0.));\r#else\nfloat shadow=TEXTUREFUNC(shadowSampler,uv,0.).x;\r#endif\nreturn shadowPixelDepth>shadow ? computeFallOff(darkness,clipSpace.xy,frustumEdgeFalloff) : 1.;\r}\r}\r#define inline\nfloat computeShadowWithPoissonSampling(vec4 vPositionFromLight,float depthMetric,sampler2D shadowSampler,float mapSize,float darkness,float frustumEdgeFalloff)\r{\rvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\rvec2 uv=0.5*clipSpace.xy+vec2(0.5);\rif (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)\r{\rreturn 1.0;\r}\relse\r{\rfloat shadowPixelDepth=clamp(depthMetric,0.,1.0);\rfloat visibility=1.;\rvec2 poissonDisk[4];\rpoissonDisk[0]=vec2(-0.94201624,-0.39906216);\rpoissonDisk[1]=vec2(0.94558609,-0.76890725);\rpoissonDisk[2]=vec2(-0.094184101,-0.92938870);\rpoissonDisk[3]=vec2(0.34495938,0.29387760);\r#ifndef SHADOWFLOAT\nif (unpack(TEXTUREFUNC(shadowSampler,uv+poissonDisk[0]*mapSize,0.))<shadowPixelDepth) visibility-=0.25;\rif (unpack(TEXTUREFUNC(shadowSampler,uv+poissonDisk[1]*mapSize,0.))<shadowPixelDepth) visibility-=0.25;\rif (unpack(TEXTUREFUNC(shadowSampler,uv+poissonDisk[2]*mapSize,0.))<shadowPixelDepth) visibility-=0.25;\rif (unpack(TEXTUREFUNC(shadowSampler,uv+poissonDisk[3]*mapSize,0.))<shadowPixelDepth) visibility-=0.25;\r#else\nif (TEXTUREFUNC(shadowSampler,uv+poissonDisk[0]*mapSize,0.).x<shadowPixelDepth) visibility-=0.25;\rif (TEXTUREFUNC(shadowSampler,uv+poissonDisk[1]*mapSize,0.).x<shadowPixelDepth) visibility-=0.25;\rif (TEXTUREFUNC(shadowSampler,uv+poissonDisk[2]*mapSize,0.).x<shadowPixelDepth) visibility-=0.25;\rif (TEXTUREFUNC(shadowSampler,uv+poissonDisk[3]*mapSize,0.).x<shadowPixelDepth) visibility-=0.25;\r#endif\nreturn computeFallOff(min(1.0,visibility+darkness),clipSpace.xy,frustumEdgeFalloff);\r}\r}\r#define inline\nfloat computeShadowWithESM(vec4 vPositionFromLight,float depthMetric,sampler2D shadowSampler,float darkness,float depthScale,float frustumEdgeFalloff)\r{\rvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\rvec2 uv=0.5*clipSpace.xy+vec2(0.5);\rif (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)\r{\rreturn 1.0;\r}\relse\r{\rfloat shadowPixelDepth=clamp(depthMetric,0.,1.0);\r#ifndef SHADOWFLOAT\nfloat shadowMapSample=unpack(TEXTUREFUNC(shadowSampler,uv,0.));\r#else\nfloat shadowMapSample=TEXTUREFUNC(shadowSampler,uv,0.).x;\r#endif\nfloat esm=1.0-clamp(exp(min(87.,depthScale*shadowPixelDepth))*shadowMapSample,0.,1.-darkness);\rreturn computeFallOff(esm,clipSpace.xy,frustumEdgeFalloff);\r}\r}\r#define inline\nfloat computeShadowWithCloseESM(vec4 vPositionFromLight,float depthMetric,sampler2D shadowSampler,float darkness,float depthScale,float frustumEdgeFalloff)\r{\rvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\rvec2 uv=0.5*clipSpace.xy+vec2(0.5);\rif (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)\r{\rreturn 1.0;\r}\relse\r{\rfloat shadowPixelDepth=clamp(depthMetric,0.,1.0); \r#ifndef SHADOWFLOAT\nfloat shadowMapSample=unpack(TEXTUREFUNC(shadowSampler,uv,0.));\r#else\nfloat shadowMapSample=TEXTUREFUNC(shadowSampler,uv,0.).x;\r#endif\nfloat esm=clamp(exp(min(87.,-depthScale*(shadowPixelDepth-shadowMapSample))),darkness,1.);\rreturn computeFallOff(esm,clipSpace.xy,frustumEdgeFalloff);\r}\r}\r#ifdef IS_NDC_HALF_ZRANGE\n#define ZINCLIP clipSpace.z\n#else\n#define ZINCLIP uvDepth.z\n#endif\n#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)\n#define GREATEST_LESS_THAN_ONE 0.99999994\n#define inline\nfloat computeShadowWithCSMPCF1(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArrayShadow shadowSampler,float darkness,float frustumEdgeFalloff)\r{\rvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\rvec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));\ruvDepth.z=clamp(ZINCLIP,0.,GREATEST_LESS_THAN_ONE);\rvec4 uvDepthLayer=vec4(uvDepth.x,uvDepth.y,layer,uvDepth.z);\rfloat shadow=texture2D(shadowSampler,uvDepthLayer);\rshadow=mix(darkness,1.,shadow);\rreturn computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);\r}\r#define inline\nfloat computeShadowWithCSMPCF3(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArrayShadow shadowSampler,vec2 shadowMapSizeAndInverse,float darkness,float frustumEdgeFalloff)\r{\rvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\rvec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));\ruvDepth.z=clamp(ZINCLIP,0.,GREATEST_LESS_THAN_ONE);\rvec2 uv=uvDepth.xy*shadowMapSizeAndInverse.x; \ruv+=0.5; \rvec2 st=fract(uv); \rvec2 base_uv=floor(uv)-0.5; \rbase_uv*=shadowMapSizeAndInverse.y; \rvec2 uvw0=3.-2.*st;\rvec2 uvw1=1.+2.*st;\rvec2 u=vec2((2.-st.x)/uvw0.x-1.,st.x/uvw1.x+1.)*shadowMapSizeAndInverse.y;\rvec2 v=vec2((2.-st.y)/uvw0.y-1.,st.y/uvw1.y+1.)*shadowMapSizeAndInverse.y;\rfloat shadow=0.;\rshadow+=uvw0.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[0]),layer,uvDepth.z));\rshadow+=uvw1.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[0]),layer,uvDepth.z));\rshadow+=uvw0.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[1]),layer,uvDepth.z));\rshadow+=uvw1.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[1]),layer,uvDepth.z));\rshadow=shadow/16.;\rshadow=mix(darkness,1.,shadow);\rreturn computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);\r}\r#define inline\nfloat computeShadowWithCSMPCF5(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArrayShadow shadowSampler,vec2 shadowMapSizeAndInverse,float darkness,float frustumEdgeFalloff)\r{\rvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\rvec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));\ruvDepth.z=clamp(ZINCLIP,0.,GREATEST_LESS_THAN_ONE);\rvec2 uv=uvDepth.xy*shadowMapSizeAndInverse.x; \ruv+=0.5; \rvec2 st=fract(uv); \rvec2 base_uv=floor(uv)-0.5; \rbase_uv*=shadowMapSizeAndInverse.y; \rvec2 uvw0=4.-3.*st;\rvec2 uvw1=vec2(7.);\rvec2 uvw2=1.+3.*st;\rvec3 u=vec3((3.-2.*st.x)/uvw0.x-2.,(3.+st.x)/uvw1.x,st.x/uvw2.x+2.)*shadowMapSizeAndInverse.y;\rvec3 v=vec3((3.-2.*st.y)/uvw0.y-2.,(3.+st.y)/uvw1.y,st.y/uvw2.y+2.)*shadowMapSizeAndInverse.y;\rfloat shadow=0.;\rshadow+=uvw0.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[0]),layer,uvDepth.z));\rshadow+=uvw1.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[0]),layer,uvDepth.z));\rshadow+=uvw2.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[2],v[0]),layer,uvDepth.z));\rshadow+=uvw0.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[1]),layer,uvDepth.z));\rshadow+=uvw1.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[1]),layer,uvDepth.z));\rshadow+=uvw2.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[2],v[1]),layer,uvDepth.z));\rshadow+=uvw0.x*uvw2.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[2]),layer,uvDepth.z));\rshadow+=uvw1.x*uvw2.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[2]),layer,uvDepth.z));\rshadow+=uvw2.x*uvw2.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[2],v[2]),layer,uvDepth.z));\rshadow=shadow/144.;\rshadow=mix(darkness,1.,shadow);\rreturn computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);\r}\r#define inline\nfloat computeShadowWithPCF1(vec4 vPositionFromLight,float depthMetric,highp sampler2DShadow shadowSampler,float darkness,float frustumEdgeFalloff)\r{\rif (depthMetric>1.0 || depthMetric<0.0) {\rreturn 1.0;\r}\relse\r{\rvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\rvec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));\ruvDepth.z=ZINCLIP;\rfloat shadow=TEXTUREFUNC(shadowSampler,uvDepth,0.);\rshadow=mix(darkness,1.,shadow);\rreturn computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);\r}\r}\r#define inline\nfloat computeShadowWithPCF3(vec4 vPositionFromLight,float depthMetric,highp sampler2DShadow shadowSampler,vec2 shadowMapSizeAndInverse,float darkness,float frustumEdgeFalloff)\r{\rif (depthMetric>1.0 || depthMetric<0.0) {\rreturn 1.0;\r}\relse\r{\rvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\rvec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));\ruvDepth.z=ZINCLIP;\rvec2 uv=uvDepth.xy*shadowMapSizeAndInverse.x; \ruv+=0.5; \rvec2 st=fract(uv); \rvec2 base_uv=floor(uv)-0.5; \rbase_uv*=shadowMapSizeAndInverse.y; \rvec2 uvw0=3.-2.*st;\rvec2 uvw1=1.+2.*st;\rvec2 u=vec2((2.-st.x)/uvw0.x-1.,st.x/uvw1.x+1.)*shadowMapSizeAndInverse.y;\rvec2 v=vec2((2.-st.y)/uvw0.y-1.,st.y/uvw1.y+1.)*shadowMapSizeAndInverse.y;\rfloat shadow=0.;\rshadow+=uvw0.x*uvw0.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[0]),uvDepth.z),0.);\rshadow+=uvw1.x*uvw0.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[0]),uvDepth.z),0.);\rshadow+=uvw0.x*uvw1.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[1]),uvDepth.z),0.);\rshadow+=uvw1.x*uvw1.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[1]),uvDepth.z),0.);\rshadow=shadow/16.;\rshadow=mix(darkness,1.,shadow);\rreturn computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);\r}\r}\r#define inline\nfloat computeShadowWithPCF5(vec4 vPositionFromLight,float depthMetric,highp sampler2DShadow shadowSampler,vec2 shadowMapSizeAndInverse,float darkness,float frustumEdgeFalloff)\r{\rif (depthMetric>1.0 || depthMetric<0.0) {\rreturn 1.0;\r}\relse\r{\rvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\rvec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));\ruvDepth.z=ZINCLIP;\rvec2 uv=uvDepth.xy*shadowMapSizeAndInverse.x; \ruv+=0.5; \rvec2 st=fract(uv); \rvec2 base_uv=floor(uv)-0.5; \rbase_uv*=shadowMapSizeAndInverse.y; \rvec2 uvw0=4.-3.*st;\rvec2 uvw1=vec2(7.);\rvec2 uvw2=1.+3.*st;\rvec3 u=vec3((3.-2.*st.x)/uvw0.x-2.,(3.+st.x)/uvw1.x,st.x/uvw2.x+2.)*shadowMapSizeAndInverse.y;\rvec3 v=vec3((3.-2.*st.y)/uvw0.y-2.,(3.+st.y)/uvw1.y,st.y/uvw2.y+2.)*shadowMapSizeAndInverse.y;\rfloat shadow=0.;\rshadow+=uvw0.x*uvw0.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[0]),uvDepth.z),0.);\rshadow+=uvw1.x*uvw0.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[0]),uvDepth.z),0.);\rshadow+=uvw2.x*uvw0.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[2],v[0]),uvDepth.z),0.);\rshadow+=uvw0.x*uvw1.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[1]),uvDepth.z),0.);\rshadow+=uvw1.x*uvw1.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[1]),uvDepth.z),0.);\rshadow+=uvw2.x*uvw1.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[2],v[1]),uvDepth.z),0.);\rshadow+=uvw0.x*uvw2.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[2]),uvDepth.z),0.);\rshadow+=uvw1.x*uvw2.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[2]),uvDepth.z),0.);\rshadow+=uvw2.x*uvw2.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[2],v[2]),uvDepth.z),0.);\rshadow=shadow/144.;\rshadow=mix(darkness,1.,shadow);\rreturn computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);\r}\r}\rconst vec3 PoissonSamplers32[64]=vec3[64](\rvec3(0.06407013,0.05409927,0.),\rvec3(0.7366577,0.5789394,0.),\rvec3(-0.6270542,-0.5320278,0.),\rvec3(-0.4096107,0.8411095,0.),\rvec3(0.6849564,-0.4990818,0.),\rvec3(-0.874181,-0.04579735,0.),\rvec3(0.9989998,0.0009880066,0.),\rvec3(-0.004920578,-0.9151649,0.),\rvec3(0.1805763,0.9747483,0.),\rvec3(-0.2138451,0.2635818,0.),\rvec3(0.109845,0.3884785,0.),\rvec3(0.06876755,-0.3581074,0.),\rvec3(0.374073,-0.7661266,0.),\rvec3(0.3079132,-0.1216763,0.),\rvec3(-0.3794335,-0.8271583,0.),\rvec3(-0.203878,-0.07715034,0.),\rvec3(0.5912697,0.1469799,0.),\rvec3(-0.88069,0.3031784,0.),\rvec3(0.5040108,0.8283722,0.),\rvec3(-0.5844124,0.5494877,0.),\rvec3(0.6017799,-0.1726654,0.),\rvec3(-0.5554981,0.1559997,0.),\rvec3(-0.3016369,-0.3900928,0.),\rvec3(-0.5550632,-0.1723762,0.),\rvec3(0.925029,0.2995041,0.),\rvec3(-0.2473137,0.5538505,0.),\rvec3(0.9183037,-0.2862392,0.),\rvec3(0.2469421,0.6718712,0.),\rvec3(0.3916397,-0.4328209,0.),\rvec3(-0.03576927,-0.6220032,0.),\rvec3(-0.04661255,0.7995201,0.),\rvec3(0.4402924,0.3640312,0.),\rvec3(0.,0.,0.),\rvec3(0.,0.,0.),\rvec3(0.,0.,0.),\rvec3(0.,0.,0.),\rvec3(0.,0.,0.),\rvec3(0.,0.,0.),\rvec3(0.,0.,0.),\rvec3(0.,0.,0.),\rvec3(0.,0.,0.),\rvec3(0.,0.,0.),\rvec3(0.,0.,0.),\rvec3(0.,0.,0.),\rvec3(0.,0.,0.),\rvec3(0.,0.,0.),\rvec3(0.,0.,0.),\rvec3(0.,0.,0.),\rvec3(0.,0.,0.),\rvec3(0.,0.,0.),\rvec3(0.,0.,0.),\rvec3(0.,0.,0.),\rvec3(0.,0.,0.),\rvec3(0.,0.,0.),\rvec3(0.,0.,0.),\rvec3(0.,0.,0.),\rvec3(0.,0.,0.),\rvec3(0.,0.,0.),\rvec3(0.,0.,0.),\rvec3(0.,0.,0.),\rvec3(0.,0.,0.),\rvec3(0.,0.,0.),\rvec3(0.,0.,0.),\rvec3(0.,0.,0.)\r);\rconst vec3 PoissonSamplers64[64]=vec3[64](\rvec3(-0.613392,0.617481,0.),\rvec3(0.170019,-0.040254,0.),\rvec3(-0.299417,0.791925,0.),\rvec3(0.645680,0.493210,0.),\rvec3(-0.651784,0.717887,0.),\rvec3(0.421003,0.027070,0.),\rvec3(-0.817194,-0.271096,0.),\rvec3(-0.705374,-0.668203,0.),\rvec3(0.977050,-0.108615,0.),\rvec3(0.063326,0.142369,0.),\rvec3(0.203528,0.214331,0.),\rvec3(-0.667531,0.326090,0.),\rvec3(-0.098422,-0.295755,0.),\rvec3(-0.885922,0.215369,0.),\rvec3(0.566637,0.605213,0.),\rvec3(0.039766,-0.396100,0.),\rvec3(0.751946,0.453352,0.),\rvec3(0.078707,-0.715323,0.),\rvec3(-0.075838,-0.529344,0.),\rvec3(0.724479,-0.580798,0.),\rvec3(0.222999,-0.215125,0.),\rvec3(-0.467574,-0.405438,0.),\rvec3(-0.248268,-0.814753,0.),\rvec3(0.354411,-0.887570,0.),\rvec3(0.175817,0.382366,0.),\rvec3(0.487472,-0.063082,0.),\rvec3(-0.084078,0.898312,0.),\rvec3(0.488876,-0.783441,0.),\rvec3(0.470016,0.217933,0.),\rvec3(-0.696890,-0.549791,0.),\rvec3(-0.149693,0.605762,0.),\rvec3(0.034211,0.979980,0.),\rvec3(0.503098,-0.308878,0.),\rvec3(-0.016205,-0.872921,0.),\rvec3(0.385784,-0.393902,0.),\rvec3(-0.146886,-0.859249,0.),\rvec3(0.643361,0.164098,0.),\rvec3(0.634388,-0.049471,0.),\rvec3(-0.688894,0.007843,0.),\rvec3(0.464034,-0.188818,0.),\rvec3(-0.440840,0.137486,0.),\rvec3(0.364483,0.511704,0.),\rvec3(0.034028,0.325968,0.),\rvec3(0.099094,-0.308023,0.),\rvec3(0.693960,-0.366253,0.),\rvec3(0.678884,-0.204688,0.),\rvec3(0.001801,0.780328,0.),\rvec3(0.145177,-0.898984,0.),\rvec3(0.062655,-0.611866,0.),\rvec3(0.315226,-0.604297,0.),\rvec3(-0.780145,0.486251,0.),\rvec3(-0.371868,0.882138,0.),\rvec3(0.200476,0.494430,0.),\rvec3(-0.494552,-0.711051,0.),\rvec3(0.612476,0.705252,0.),\rvec3(-0.578845,-0.768792,0.),\rvec3(-0.772454,-0.090976,0.),\rvec3(0.504440,0.372295,0.),\rvec3(0.155736,0.065157,0.),\rvec3(0.391522,0.849605,0.),\rvec3(-0.620106,-0.328104,0.),\rvec3(0.789239,-0.419965,0.),\rvec3(-0.545396,0.538133,0.),\rvec3(-0.178564,-0.596057,0.)\r);\r#define inline\nfloat computeShadowWithCSMPCSS(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray depthSampler,highp sampler2DArrayShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,int searchTapCount,int pcfTapCount,vec3[64] poissonSamplers,vec2 lightSizeUVCorrection,float depthCorrection,float penumbraDarkness)\r{\rvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\rvec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));\ruvDepth.z=clamp(ZINCLIP,0.,GREATEST_LESS_THAN_ONE);\rvec4 uvDepthLayer=vec4(uvDepth.x,uvDepth.y,layer,uvDepth.z);\rfloat blockerDepth=0.0;\rfloat sumBlockerDepth=0.0;\rfloat numBlocker=0.0;\rfor (int i=0; i<searchTapCount; i ++) {\rblockerDepth=texture2D(depthSampler,vec3(uvDepth.xy+(lightSizeUV*lightSizeUVCorrection*shadowMapSizeInverse*PoissonSamplers32[i].xy),layer)).r;\rif (blockerDepth<depthMetric) {\rsumBlockerDepth+=blockerDepth;\rnumBlocker++;\r}\r}\rfloat avgBlockerDepth=sumBlockerDepth/numBlocker;\rfloat AAOffset=shadowMapSizeInverse*10.;\rfloat penumbraRatio=((depthMetric-avgBlockerDepth)*depthCorrection+AAOffset);\rvec4 filterRadius=vec4(penumbraRatio*lightSizeUV*lightSizeUVCorrection*shadowMapSizeInverse,0.,0.);\rfloat random=getRand(vPositionFromLight.xy);\rfloat rotationAngle=random*3.1415926;\rvec2 rotationVector=vec2(cos(rotationAngle),sin(rotationAngle));\rfloat shadow=0.;\rfor (int i=0; i<pcfTapCount; i++) {\rvec4 offset=vec4(poissonSamplers[i],0.);\roffset=vec4(offset.x*rotationVector.x-offset.y*rotationVector.y,offset.y*rotationVector.x+offset.x*rotationVector.y,0.,0.);\rshadow+=texture2D(shadowSampler,uvDepthLayer+offset*filterRadius);\r}\rshadow/=float(pcfTapCount);\rshadow=mix(shadow,1.,min((depthMetric-avgBlockerDepth)*depthCorrection*penumbraDarkness,1.));\rshadow=mix(darkness,1.,shadow);\rif (numBlocker<1.0) {\rreturn 1.0;\r}\relse\r{\rreturn computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);\r}\r}\r#define inline\nfloat computeShadowWithPCSS(vec4 vPositionFromLight,float depthMetric,sampler2D depthSampler,highp sampler2DShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,int searchTapCount,int pcfTapCount,vec3[64] poissonSamplers)\r{\rif (depthMetric>1.0 || depthMetric<0.0) {\rreturn 1.0;\r}\relse\r{\rvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\rvec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));\ruvDepth.z=ZINCLIP;\rfloat blockerDepth=0.0;\rfloat sumBlockerDepth=0.0;\rfloat numBlocker=0.0;\rfor (int i=0; i<searchTapCount; i ++) {\rblockerDepth=TEXTUREFUNC(depthSampler,uvDepth.xy+(lightSizeUV*shadowMapSizeInverse*PoissonSamplers32[i].xy),0.).r;\rif (blockerDepth<depthMetric) {\rsumBlockerDepth+=blockerDepth;\rnumBlocker++;\r}\r}\rif (numBlocker<1.0) {\rreturn 1.0;\r}\relse\r{\rfloat avgBlockerDepth=sumBlockerDepth/numBlocker;\rfloat AAOffset=shadowMapSizeInverse*10.;\rfloat penumbraRatio=((depthMetric-avgBlockerDepth)+AAOffset);\rfloat filterRadius=penumbraRatio*lightSizeUV*shadowMapSizeInverse;\rfloat random=getRand(vPositionFromLight.xy);\rfloat rotationAngle=random*3.1415926;\rvec2 rotationVector=vec2(cos(rotationAngle),sin(rotationAngle));\rfloat shadow=0.;\rfor (int i=0; i<pcfTapCount; i++) {\rvec3 offset=poissonSamplers[i];\roffset=vec3(offset.x*rotationVector.x-offset.y*rotationVector.y,offset.y*rotationVector.x+offset.x*rotationVector.y,0.);\rshadow+=TEXTUREFUNC(shadowSampler,uvDepth+offset*filterRadius,0.);\r}\rshadow/=float(pcfTapCount);\rshadow=mix(shadow,1.,depthMetric-avgBlockerDepth);\rshadow=mix(darkness,1.,shadow);\rreturn computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);\r}\r}\r}\r#define inline\nfloat computeShadowWithPCSS16(vec4 vPositionFromLight,float depthMetric,sampler2D depthSampler,highp sampler2DShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff)\r{\rreturn computeShadowWithPCSS(vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,16,16,PoissonSamplers32);\r}\r#define inline\nfloat computeShadowWithPCSS32(vec4 vPositionFromLight,float depthMetric,sampler2D depthSampler,highp sampler2DShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff)\r{\rreturn computeShadowWithPCSS(vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,16,32,PoissonSamplers32);\r}\r#define inline\nfloat computeShadowWithPCSS64(vec4 vPositionFromLight,float depthMetric,sampler2D depthSampler,highp sampler2DShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff)\r{\rreturn computeShadowWithPCSS(vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,32,64,PoissonSamplers64);\r}\r#define inline\nfloat computeShadowWithCSMPCSS16(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray depthSampler,highp sampler2DArrayShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,vec2 lightSizeUVCorrection,float depthCorrection,float penumbraDarkness)\r{\rreturn computeShadowWithCSMPCSS(layer,vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,16,16,PoissonSamplers32,lightSizeUVCorrection,depthCorrection,penumbraDarkness);\r}\r#define inline\nfloat computeShadowWithCSMPCSS32(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray depthSampler,highp sampler2DArrayShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,vec2 lightSizeUVCorrection,float depthCorrection,float penumbraDarkness)\r{\rreturn computeShadowWithCSMPCSS(layer,vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,16,32,PoissonSamplers32,lightSizeUVCorrection,depthCorrection,penumbraDarkness);\r}\r#define inline\nfloat computeShadowWithCSMPCSS64(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray depthSampler,highp sampler2DArrayShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,vec2 lightSizeUVCorrection,float depthCorrection,float penumbraDarkness)\r{\rreturn computeShadowWithCSMPCSS(layer,vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,32,64,PoissonSamplers64,lightSizeUVCorrection,depthCorrection,penumbraDarkness);\r}\r#endif\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const shadowsFragmentFunctions = { name, shader };\n//# sourceMappingURL=shadowsFragmentFunctions.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nconst name = \"shadowsVertex\";\nconst shader = `#ifdef SHADOWS\n#if defined(SHADOWCSM{X})\nvPositionFromCamera{X}=view*worldPos;\rfor (int i=0; i<SHADOWCSMNUM_CASCADES{X}; i++) {\rvPositionFromLight{X}[i]=lightMatrix{X}[i]*worldPos;\r#ifdef USE_REVERSE_DEPTHBUFFER\nvDepthMetric{X}[i]=(-vPositionFromLight{X}[i].z+light{X}.depthValues.x)/light{X}.depthValues.y;\r#else\nvDepthMetric{X}[i]=(vPositionFromLight{X}[i].z+light{X}.depthValues.x)/light{X}.depthValues.y;\r#endif\n}\r#elif defined(SHADOW{X}) && !defined(SHADOWCUBE{X})\nvPositionFromLight{X}=lightMatrix{X}*worldPos;\r#ifdef USE_REVERSE_DEPTHBUFFER\nvDepthMetric{X}=(-vPositionFromLight{X}.z+light{X}.depthValues.x)/light{X}.depthValues.y;\r#else\nvDepthMetric{X}=(vPositionFromLight{X}.z+light{X}.depthValues.x)/light{X}.depthValues.y;\r#endif\n#endif\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const shadowsVertex = { name, shader };\n//# sourceMappingURL=shadowsVertex.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nconst name = \"subSurfaceScatteringFunctions\";\nconst shader = `bool testLightingForSSS(float diffusionProfile)\r{\rreturn diffusionProfile<1.;\r}`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const subSurfaceScatteringFunctions = { name, shader };\n//# sourceMappingURL=subSurfaceScatteringFunctions.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nconst name = \"uvAttributeDeclaration\";\nconst shader = `#ifdef UV{X}\nattribute vec2 uv{X};\r#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const uvAttributeDeclaration = { name, shader };\n//# sourceMappingURL=uvAttributeDeclaration.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nconst name = \"vertexColorMixing\";\nconst shader = `#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nvColor=vec4(1.0);\r#ifdef VERTEXCOLOR\n#ifdef VERTEXALPHA\nvColor*=color;\r#else\nvColor.rgb*=color.rgb;\r#endif\n#endif\n#ifdef INSTANCESCOLOR\nvColor*=instanceColor;\r#endif\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const vertexColorMixing = { name, shader };\n//# sourceMappingURL=vertexColorMixing.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nconst name = \"anaglyphPixelShader\";\nconst shader = `varying vec2 vUV;\runiform sampler2D textureSampler;\runiform sampler2D leftSampler;\r#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void)\r{\rvec4 leftFrag=texture2D(leftSampler,vUV);\rleftFrag=vec4(1.0,leftFrag.g,leftFrag.b,1.0);\rvec4 rightFrag=texture2D(textureSampler,vUV);\rrightFrag=vec4(rightFrag.r,1.0,1.0,1.0);\rgl_FragColor=vec4(rightFrag.rgb*leftFrag.rgb,1.0);\r}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const anaglyphPixelShader = { name, shader };\n//# sourceMappingURL=anaglyph.fragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nimport \"./ShadersInclude/backgroundVertexDeclaration.js\";\nimport \"./ShadersInclude/backgroundUboDeclaration.js\";\nimport \"./ShadersInclude/helperFunctions.js\";\nimport \"./ShadersInclude/bonesDeclaration.js\";\nimport \"./ShadersInclude/bakedVertexAnimationDeclaration.js\";\nimport \"./ShadersInclude/instancesDeclaration.js\";\nimport \"./ShadersInclude/clipPlaneVertexDeclaration.js\";\nimport \"./ShadersInclude/fogVertexDeclaration.js\";\nimport \"./ShadersInclude/lightVxFragmentDeclaration.js\";\nimport \"./ShadersInclude/lightVxUboDeclaration.js\";\nimport \"./ShadersInclude/instancesVertex.js\";\nimport \"./ShadersInclude/bonesVertex.js\";\nimport \"./ShadersInclude/bakedVertexAnimation.js\";\nimport \"./ShadersInclude/clipPlaneVertex.js\";\nimport \"./ShadersInclude/fogVertex.js\";\nimport \"./ShadersInclude/shadowsVertex.js\";\nconst name = \"backgroundVertexShader\";\nconst shader = `precision highp float;\r#include<__decl__backgroundVertex>\n#include<helperFunctions>\nattribute vec3 position;\r#ifdef NORMAL\nattribute vec3 normal;\r#endif\n#include<bonesDeclaration>\n#include<bakedVertexAnimationDeclaration>\n#include<instancesDeclaration>\nvarying vec3 vPositionW;\r#ifdef NORMAL\nvarying vec3 vNormalW;\r#endif\n#ifdef UV1\nattribute vec2 uv;\r#endif\n#ifdef UV2\nattribute vec2 uv2;\r#endif\n#ifdef MAINUV1\nvarying vec2 vMainUV1;\r#endif\n#ifdef MAINUV2\nvarying vec2 vMainUV2;\r#endif\n#if defined(DIFFUSE) && DIFFUSEDIRECTUV==0\nvarying vec2 vDiffuseUV;\r#endif\n#include<clipPlaneVertexDeclaration>\n#include<fogVertexDeclaration>\n#include<__decl__lightVxFragment>[0..maxSimultaneousLights]\n#ifdef REFLECTIONMAP_SKYBOX\nvarying vec3 vPositionUVW;\r#endif\n#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\nvarying vec3 vDirectionW;\r#endif\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void) {\r#define CUSTOM_VERTEX_MAIN_BEGIN\n#ifdef REFLECTIONMAP_SKYBOX\nvPositionUVW=position;\r#endif\n#include<instancesVertex>\n#include<bonesVertex>\n#include<bakedVertexAnimation>\n#ifdef MULTIVIEW\nif (gl_ViewID_OVR==0u) {\rgl_Position=viewProjection*finalWorld*vec4(position,1.0);\r} else {\rgl_Position=viewProjectionR*finalWorld*vec4(position,1.0);\r}\r#else\ngl_Position=viewProjection*finalWorld*vec4(position,1.0);\r#endif\nvec4 worldPos=finalWorld*vec4(position,1.0);\rvPositionW=vec3(worldPos);\r#ifdef NORMAL\nmat3 normalWorld=mat3(finalWorld);\r#ifdef NONUNIFORMSCALING\nnormalWorld=transposeMat3(inverseMat3(normalWorld));\r#endif\nvNormalW=normalize(normalWorld*normal);\r#endif\n#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\nvDirectionW=normalize(vec3(finalWorld*vec4(position,0.0)));\r#ifdef EQUIRECTANGULAR_RELFECTION_FOV\nmat3 screenToWorld=inverseMat3(mat3(finalWorld*viewProjection));\rvec3 segment=mix(vDirectionW,screenToWorld*vec3(0.0,0.0,1.0),abs(fFovMultiplier-1.0));\rif (fFovMultiplier<=1.0) {\rvDirectionW=normalize(segment);\r} else {\rvDirectionW=normalize(vDirectionW+(vDirectionW-segment));\r}\r#endif\n#endif\n#ifndef UV1\nvec2 uv=vec2(0.,0.);\r#endif\n#ifndef UV2\nvec2 uv2=vec2(0.,0.);\r#endif\n#ifdef MAINUV1\nvMainUV1=uv;\r#endif\n#ifdef MAINUV2\nvMainUV2=uv2;\r#endif\n#if defined(DIFFUSE) && DIFFUSEDIRECTUV==0\nif (vDiffuseInfos.x==0.)\r{\rvDiffuseUV=vec2(diffuseMatrix*vec4(uv,1.0,0.0));\r}\relse\r{\rvDiffuseUV=vec2(diffuseMatrix*vec4(uv2,1.0,0.0));\r}\r#endif\n#include<clipPlaneVertex>\n#include<fogVertex>\n#include<shadowsVertex>[0..maxSimultaneousLights]\n#ifdef VERTEXCOLOR\nvColor=color;\r#endif\n#if defined(POINTSIZE) && !defined(WEBGPU)\ngl_PointSize=pointSize;\r#endif\n#define CUSTOM_VERTEX_MAIN_END\n}\r`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const backgroundVertexShader = { name, shader };\n//# sourceMappingURL=background.vertex.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nconst name = \"chromaticAberrationPixelShader\";\nconst shader = `uniform sampler2D textureSampler; \runiform float chromatic_aberration;\runiform float radialIntensity;\runiform vec2 direction;\runiform vec2 centerPosition;\runiform float screen_width;\runiform float screen_height;\rvarying vec2 vUV;\r#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void)\r{\rvec2 centered_screen_pos=vec2(vUV.x-centerPosition.x,vUV.y-centerPosition.y);\rvec2 directionOfEffect=direction;\rif(directionOfEffect.x==0. && directionOfEffect.y==0.){\rdirectionOfEffect=normalize(centered_screen_pos);\r}\rfloat radius2=centered_screen_pos.x*centered_screen_pos.x\r+ centered_screen_pos.y*centered_screen_pos.y;\rfloat radius=sqrt(radius2);\rvec4 original=texture2D(textureSampler,vUV);\rvec3 ref_indices=vec3(-0.3,0.0,0.3);\rfloat ref_shiftX=chromatic_aberration*pow(radius,radialIntensity)*directionOfEffect.x/screen_width;\rfloat ref_shiftY=chromatic_aberration*pow(radius,radialIntensity)*directionOfEffect.y/screen_height;\rvec2 ref_coords_r=vec2(vUV.x+ref_indices.r*ref_shiftX,vUV.y+ref_indices.r*ref_shiftY*0.5);\rvec2 ref_coords_g=vec2(vUV.x+ref_indices.g*ref_shiftX,vUV.y+ref_indices.g*ref_shiftY*0.5);\rvec2 ref_coords_b=vec2(vUV.x+ref_indices.b*ref_shiftX,vUV.y+ref_indices.b*ref_shiftY*0.5);\roriginal.r=texture2D(textureSampler,ref_coords_r).r;\roriginal.g=texture2D(textureSampler,ref_coords_g).g;\roriginal.b=texture2D(textureSampler,ref_coords_b).b;\roriginal.a=clamp(texture2D(textureSampler,ref_coords_r).a+texture2D(textureSampler,ref_coords_g).a+texture2D(textureSampler,ref_coords_b).a,0.,1.);\rgl_FragColor=original;\r}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const chromaticAberrationPixelShader = { name, shader };\n//# sourceMappingURL=chromaticAberration.fragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nconst name = \"circleOfConfusionPixelShader\";\nconst shader = `uniform sampler2D depthSampler;\rvarying vec2 vUV;\runiform vec2 cameraMinMaxZ;\runiform float focusDistance;\runiform float cocPrecalculation;\r#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void)\r{\rfloat depth=texture2D(depthSampler,vUV).r;\r#define CUSTOM_COC_DEPTH\nfloat pixelDistance=(cameraMinMaxZ.x+cameraMinMaxZ.y*depth)*1000.0; \r#define CUSTOM_COC_PIXELDISTANCE\nfloat coc=abs(cocPrecalculation*((focusDistance-pixelDistance)/pixelDistance));\rcoc=clamp(coc,0.0,1.0);\rgl_FragColor=vec4(coc,coc,coc,1.0);\r}\r`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const circleOfConfusionPixelShader = { name, shader };\n//# sourceMappingURL=circleOfConfusion.fragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nimport \"./ShadersInclude/helperFunctions.js\";\nconst name = \"copyTextureToTexturePixelShader\";\nconst shader = `uniform float conversion;\runiform sampler2D textureSampler;\rvarying vec2 vUV;\r#include<helperFunctions>\nvoid main(void) \r{\rvec4 color=texture2D(textureSampler,vUV);\r#ifdef DEPTH_TEXTURE\ngl_FragDepth=color.r;\r#else\nif (conversion==1.) {\rcolor=toLinearSpace(color);\r} else if (conversion==2.) {\rcolor=toGammaSpace(color);\r}\rgl_FragColor=color;\r#endif\n}\r`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const copyTextureToTexturePixelShader = { name, shader };\n//# sourceMappingURL=copyTextureToTexture.fragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nconst name = \"defaultFragmentDeclaration\";\nconst shader = `uniform vec4 vEyePosition;\runiform vec4 vDiffuseColor;\r#ifdef SPECULARTERM\nuniform vec4 vSpecularColor;\r#endif\nuniform vec3 vEmissiveColor;\runiform vec3 vAmbientColor;\runiform float visibility;\r#ifdef DIFFUSE\nuniform vec2 vDiffuseInfos;\r#endif\n#ifdef AMBIENT\nuniform vec2 vAmbientInfos;\r#endif\n#ifdef OPACITY \nuniform vec2 vOpacityInfos;\r#endif\n#ifdef EMISSIVE\nuniform vec2 vEmissiveInfos;\r#endif\n#ifdef LIGHTMAP\nuniform vec2 vLightmapInfos;\r#endif\n#ifdef BUMP\nuniform vec3 vBumpInfos;\runiform vec2 vTangentSpaceParams;\r#endif\n#ifdef ALPHATEST\nuniform float alphaCutOff;\r#endif\n#if defined(REFLECTIONMAP_SPHERICAL) || defined(REFLECTIONMAP_PROJECTION) || defined(REFRACTION) || defined(PREPASS)\nuniform mat4 view;\r#endif\n#ifdef REFRACTION\nuniform vec4 vRefractionInfos;\r#ifndef REFRACTIONMAP_3D\nuniform mat4 refractionMatrix;\r#endif\n#ifdef REFRACTIONFRESNEL\nuniform vec4 refractionLeftColor;\runiform vec4 refractionRightColor;\r#endif\n#if defined(USE_LOCAL_REFRACTIONMAP_CUBIC) && defined(REFRACTIONMAP_3D)\nuniform vec3 vRefractionPosition;\runiform vec3 vRefractionSize; \r#endif\n#endif\n#if defined(SPECULAR) && defined(SPECULARTERM)\nuniform vec2 vSpecularInfos;\r#endif\n#ifdef DIFFUSEFRESNEL\nuniform vec4 diffuseLeftColor;\runiform vec4 diffuseRightColor;\r#endif\n#ifdef OPACITYFRESNEL\nuniform vec4 opacityParts;\r#endif\n#ifdef EMISSIVEFRESNEL\nuniform vec4 emissiveLeftColor;\runiform vec4 emissiveRightColor;\r#endif\n#ifdef REFLECTION\nuniform vec2 vReflectionInfos;\r#if defined(REFLECTIONMAP_PLANAR) || defined(REFLECTIONMAP_CUBIC) || defined(REFLECTIONMAP_PROJECTION) || defined(REFLECTIONMAP_EQUIRECTANGULAR) || defined(REFLECTIONMAP_SPHERICAL) || defined(REFLECTIONMAP_SKYBOX)\nuniform mat4 reflectionMatrix;\r#endif\n#ifndef REFLECTIONMAP_SKYBOX\n#if defined(USE_LOCAL_REFLECTIONMAP_CUBIC) && defined(REFLECTIONMAP_CUBIC)\nuniform vec3 vReflectionPosition;\runiform vec3 vReflectionSize; \r#endif\n#endif\n#ifdef REFLECTIONFRESNEL\nuniform vec4 reflectionLeftColor;\runiform vec4 reflectionRightColor;\r#endif\n#endif\n#ifdef DETAIL\nuniform vec4 vDetailInfos;\r#endif\n#define ADDITIONAL_FRAGMENT_DECLARATION\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const defaultFragmentDeclaration = { name, shader };\n//# sourceMappingURL=defaultFragmentDeclaration.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nimport \"./ShadersInclude/defaultFragmentDeclaration.js\";\nimport \"./ShadersInclude/defaultUboDeclaration.js\";\nimport \"./ShadersInclude/prePassDeclaration.js\";\nimport \"./ShadersInclude/oitDeclaration.js\";\nimport \"./ShadersInclude/mainUVVaryingDeclaration.js\";\nimport \"./ShadersInclude/helperFunctions.js\";\nimport \"./ShadersInclude/lightFragmentDeclaration.js\";\nimport \"./ShadersInclude/lightUboDeclaration.js\";\nimport \"./ShadersInclude/lightsFragmentFunctions.js\";\nimport \"./ShadersInclude/shadowsFragmentFunctions.js\";\nimport \"./ShadersInclude/samplerFragmentDeclaration.js\";\nimport \"./ShadersInclude/fresnelFunction.js\";\nimport \"./ShadersInclude/reflectionFunction.js\";\nimport \"./ShadersInclude/imageProcessingDeclaration.js\";\nimport \"./ShadersInclude/imageProcessingFunctions.js\";\nimport \"./ShadersInclude/bumpFragmentMainFunctions.js\";\nimport \"./ShadersInclude/bumpFragmentFunctions.js\";\nimport \"./ShadersInclude/clipPlaneFragmentDeclaration.js\";\nimport \"./ShadersInclude/logDepthDeclaration.js\";\nimport \"./ShadersInclude/fogFragmentDeclaration.js\";\nimport \"./ShadersInclude/clipPlaneFragment.js\";\nimport \"./ShadersInclude/bumpFragment.js\";\nimport \"./ShadersInclude/depthPrePass.js\";\nimport \"./ShadersInclude/lightFragment.js\";\nimport \"./ShadersInclude/logDepthFragment.js\";\nimport \"./ShadersInclude/fogFragment.js\";\nimport \"./ShadersInclude/oitFragment.js\";\nconst name = \"defaultPixelShader\";\nconst shader = `#include<__decl__defaultFragment>\n#if defined(BUMP) || !defined(NORMAL)\n#extension GL_OES_standard_derivatives : enable\n#endif\n#include<prePassDeclaration>[SCENE_MRT_COUNT]\n#include<oitDeclaration>\n#define CUSTOM_FRAGMENT_BEGIN\n#ifdef LOGARITHMICDEPTH\n#extension GL_EXT_frag_depth : enable\n#endif\n#define RECIPROCAL_PI2 0.15915494\nvarying vec3 vPositionW;\r#ifdef NORMAL\nvarying vec3 vNormalW;\r#endif\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nvarying vec4 vColor;\r#endif\n#include<mainUVVaryingDeclaration>[1..7]\n#include<helperFunctions>\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\n#include<lightsFragmentFunctions>\n#include<shadowsFragmentFunctions>\n#include<samplerFragmentDeclaration>(_DEFINENAME_,DIFFUSE,_VARYINGNAME_,Diffuse,_SAMPLERNAME_,diffuse)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,AMBIENT,_VARYINGNAME_,Ambient,_SAMPLERNAME_,ambient)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,OPACITY,_VARYINGNAME_,Opacity,_SAMPLERNAME_,opacity)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,EMISSIVE,_VARYINGNAME_,Emissive,_SAMPLERNAME_,emissive)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,LIGHTMAP,_VARYINGNAME_,Lightmap,_SAMPLERNAME_,lightmap)\n#ifdef REFRACTION\n#ifdef REFRACTIONMAP_3D\nuniform samplerCube refractionCubeSampler;\r#else\nuniform sampler2D refraction2DSampler;\r#endif\n#endif\n#if defined(SPECULARTERM)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,SPECULAR,_VARYINGNAME_,Specular,_SAMPLERNAME_,specular)\n#endif\n#include<fresnelFunction>\n#ifdef REFLECTION\n#ifdef REFLECTIONMAP_3D\nuniform samplerCube reflectionCubeSampler;\r#else\nuniform sampler2D reflection2DSampler;\r#endif\n#ifdef REFLECTIONMAP_SKYBOX\nvarying vec3 vPositionUVW;\r#else\n#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\nvarying vec3 vDirectionW;\r#endif\n#endif\n#include<reflectionFunction>\n#endif\n#include<imageProcessingDeclaration>\n#include<imageProcessingFunctions>\n#include<bumpFragmentMainFunctions>\n#include<bumpFragmentFunctions>\n#include<clipPlaneFragmentDeclaration>\n#include<logDepthDeclaration>\n#include<fogFragmentDeclaration>\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) {\r#define CUSTOM_FRAGMENT_MAIN_BEGIN\n#include<clipPlaneFragment>\nvec3 viewDirectionW=normalize(vEyePosition.xyz-vPositionW);\rvec4 baseColor=vec4(1.,1.,1.,1.);\rvec3 diffuseColor=vDiffuseColor.rgb;\rfloat alpha=vDiffuseColor.a;\r#ifdef NORMAL\nvec3 normalW=normalize(vNormalW);\r#else\nvec3 normalW=normalize(-cross(dFdx(vPositionW),dFdy(vPositionW)));\r#endif\n#include<bumpFragment>\n#ifdef TWOSIDEDLIGHTING\nnormalW=gl_FrontFacing ? normalW : -normalW;\r#endif\n#ifdef DIFFUSE\nbaseColor=texture2D(diffuseSampler,vDiffuseUV+uvOffset);\r#if defined(ALPHATEST) && !defined(ALPHATEST_AFTERALLALPHACOMPUTATIONS)\nif (baseColor.a<alphaCutOff)\rdiscard;\r#endif\n#ifdef ALPHAFROMDIFFUSE\nalpha*=baseColor.a;\r#endif\n#define CUSTOM_FRAGMENT_UPDATE_ALPHA\nbaseColor.rgb*=vDiffuseInfos.y;\r#endif\n#include<depthPrePass>\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nbaseColor.rgb*=vColor.rgb;\r#endif\n#ifdef DETAIL\nbaseColor.rgb=baseColor.rgb*2.0*mix(0.5,detailColor.r,vDetailInfos.y);\r#endif\n#define CUSTOM_FRAGMENT_UPDATE_DIFFUSE\nvec3 baseAmbientColor=vec3(1.,1.,1.);\r#ifdef AMBIENT\nbaseAmbientColor=texture2D(ambientSampler,vAmbientUV+uvOffset).rgb*vAmbientInfos.y;\r#endif\n#define CUSTOM_FRAGMENT_BEFORE_LIGHTS\n#ifdef SPECULARTERM\nfloat glossiness=vSpecularColor.a;\rvec3 specularColor=vSpecularColor.rgb;\r#ifdef SPECULAR\nvec4 specularMapColor=texture2D(specularSampler,vSpecularUV+uvOffset);\rspecularColor=specularMapColor.rgb;\r#ifdef GLOSSINESS\nglossiness=glossiness*specularMapColor.a;\r#endif\n#endif\n#else\nfloat glossiness=0.;\r#endif\nvec3 diffuseBase=vec3(0.,0.,0.);\rlightingInfo info;\r#ifdef SPECULARTERM\nvec3 specularBase=vec3(0.,0.,0.);\r#endif\nfloat shadow=1.;\r#ifdef LIGHTMAP\nvec4 lightmapColor=texture2D(lightmapSampler,vLightmapUV+uvOffset);\r#ifdef RGBDLIGHTMAP\nlightmapColor.rgb=fromRGBD(lightmapColor);\r#endif\nlightmapColor.rgb*=vLightmapInfos.y;\r#endif\n#include<lightFragment>[0..maxSimultaneousLights]\nvec4 refractionColor=vec4(0.,0.,0.,1.);\r#ifdef REFRACTION\nvec3 refractionVector=normalize(refract(-viewDirectionW,normalW,vRefractionInfos.y));\r#ifdef REFRACTIONMAP_3D\n#ifdef USE_LOCAL_REFRACTIONMAP_CUBIC\nrefractionVector=parallaxCorrectNormal(vPositionW,refractionVector,vRefractionSize,vRefractionPosition);\r#endif\nrefractionVector.y=refractionVector.y*vRefractionInfos.w;\rif (dot(refractionVector,viewDirectionW)<1.0) {\rrefractionColor=textureCube(refractionCubeSampler,refractionVector);\r}\r#else\nvec3 vRefractionUVW=vec3(refractionMatrix*(view*vec4(vPositionW+refractionVector*vRefractionInfos.z,1.0)));\rvec2 refractionCoords=vRefractionUVW.xy/vRefractionUVW.z;\rrefractionCoords.y=1.0-refractionCoords.y;\rrefractionColor=texture2D(refraction2DSampler,refractionCoords);\r#endif\n#ifdef RGBDREFRACTION\nrefractionColor.rgb=fromRGBD(refractionColor);\r#endif\n#ifdef IS_REFRACTION_LINEAR\nrefractionColor.rgb=toGammaSpace(refractionColor.rgb);\r#endif\nrefractionColor.rgb*=vRefractionInfos.x;\r#endif\nvec4 reflectionColor=vec4(0.,0.,0.,1.);\r#ifdef REFLECTION\nvec3 vReflectionUVW=computeReflectionCoords(vec4(vPositionW,1.0),normalW);\r#ifdef REFLECTIONMAP_OPPOSITEZ\nvReflectionUVW.z*=-1.0;\r#endif\n#ifdef REFLECTIONMAP_3D\n#ifdef ROUGHNESS\nfloat bias=vReflectionInfos.y;\r#ifdef SPECULARTERM\n#ifdef SPECULAR\n#ifdef GLOSSINESS\nbias*=(1.0-specularMapColor.a);\r#endif\n#endif\n#endif\nreflectionColor=textureCube(reflectionCubeSampler,vReflectionUVW,bias);\r#else\nreflectionColor=textureCube(reflectionCubeSampler,vReflectionUVW);\r#endif\n#else\nvec2 coords=vReflectionUVW.xy;\r#ifdef REFLECTIONMAP_PROJECTION\ncoords/=vReflectionUVW.z;\r#endif\ncoords.y=1.0-coords.y;\rreflectionColor=texture2D(reflection2DSampler,coords);\r#endif\n#ifdef RGBDREFLECTION\nreflectionColor.rgb=fromRGBD(reflectionColor);\r#endif\n#ifdef IS_REFLECTION_LINEAR\nreflectionColor.rgb=toGammaSpace(reflectionColor.rgb);\r#endif\nreflectionColor.rgb*=vReflectionInfos.x;\r#ifdef REFLECTIONFRESNEL\nfloat reflectionFresnelTerm=computeFresnelTerm(viewDirectionW,normalW,reflectionRightColor.a,reflectionLeftColor.a);\r#ifdef REFLECTIONFRESNELFROMSPECULAR\n#ifdef SPECULARTERM\nreflectionColor.rgb*=specularColor.rgb*(1.0-reflectionFresnelTerm)+reflectionFresnelTerm*reflectionRightColor.rgb;\r#else\nreflectionColor.rgb*=reflectionLeftColor.rgb*(1.0-reflectionFresnelTerm)+reflectionFresnelTerm*reflectionRightColor.rgb;\r#endif\n#else\nreflectionColor.rgb*=reflectionLeftColor.rgb*(1.0-reflectionFresnelTerm)+reflectionFresnelTerm*reflectionRightColor.rgb;\r#endif\n#endif\n#endif\n#ifdef REFRACTIONFRESNEL\nfloat refractionFresnelTerm=computeFresnelTerm(viewDirectionW,normalW,refractionRightColor.a,refractionLeftColor.a);\rrefractionColor.rgb*=refractionLeftColor.rgb*(1.0-refractionFresnelTerm)+refractionFresnelTerm*refractionRightColor.rgb;\r#endif\n#ifdef OPACITY\nvec4 opacityMap=texture2D(opacitySampler,vOpacityUV+uvOffset);\r#ifdef OPACITYRGB\nopacityMap.rgb=opacityMap.rgb*vec3(0.3,0.59,0.11);\ralpha*=(opacityMap.x+opacityMap.y+opacityMap.z)* vOpacityInfos.y;\r#else\nalpha*=opacityMap.a*vOpacityInfos.y;\r#endif\n#endif\n#if defined(VERTEXALPHA) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nalpha*=vColor.a;\r#endif\n#ifdef OPACITYFRESNEL\nfloat opacityFresnelTerm=computeFresnelTerm(viewDirectionW,normalW,opacityParts.z,opacityParts.w);\ralpha+=opacityParts.x*(1.0-opacityFresnelTerm)+opacityFresnelTerm*opacityParts.y;\r#endif\n#ifdef ALPHATEST\n#ifdef ALPHATEST_AFTERALLALPHACOMPUTATIONS\nif (alpha<alphaCutOff)\rdiscard;\r#endif\n#ifndef ALPHABLEND\nalpha=1.0;\r#endif\n#endif\nvec3 emissiveColor=vEmissiveColor;\r#ifdef EMISSIVE\nemissiveColor+=texture2D(emissiveSampler,vEmissiveUV+uvOffset).rgb*vEmissiveInfos.y;\r#endif\n#ifdef EMISSIVEFRESNEL\nfloat emissiveFresnelTerm=computeFresnelTerm(viewDirectionW,normalW,emissiveRightColor.a,emissiveLeftColor.a);\remissiveColor*=emissiveLeftColor.rgb*(1.0-emissiveFresnelTerm)+emissiveFresnelTerm*emissiveRightColor.rgb;\r#endif\n#ifdef DIFFUSEFRESNEL\nfloat diffuseFresnelTerm=computeFresnelTerm(viewDirectionW,normalW,diffuseRightColor.a,diffuseLeftColor.a);\rdiffuseBase*=diffuseLeftColor.rgb*(1.0-diffuseFresnelTerm)+diffuseFresnelTerm*diffuseRightColor.rgb;\r#endif\n#ifdef EMISSIVEASILLUMINATION\nvec3 finalDiffuse=clamp(diffuseBase*diffuseColor+vAmbientColor,0.0,1.0)*baseColor.rgb;\r#else\n#ifdef LINKEMISSIVEWITHDIFFUSE\nvec3 finalDiffuse=clamp((diffuseBase+emissiveColor)*diffuseColor+vAmbientColor,0.0,1.0)*baseColor.rgb;\r#else\nvec3 finalDiffuse=clamp(diffuseBase*diffuseColor+emissiveColor+vAmbientColor,0.0,1.0)*baseColor.rgb;\r#endif\n#endif\n#ifdef SPECULARTERM\nvec3 finalSpecular=specularBase*specularColor;\r#ifdef SPECULAROVERALPHA\nalpha=clamp(alpha+dot(finalSpecular,vec3(0.3,0.59,0.11)),0.,1.);\r#endif\n#else\nvec3 finalSpecular=vec3(0.0);\r#endif\n#ifdef REFLECTIONOVERALPHA\nalpha=clamp(alpha+dot(reflectionColor.rgb,vec3(0.3,0.59,0.11)),0.,1.);\r#endif\n#ifdef EMISSIVEASILLUMINATION\nvec4 color=vec4(clamp(finalDiffuse*baseAmbientColor+finalSpecular+reflectionColor.rgb+emissiveColor+refractionColor.rgb,0.0,1.0),alpha);\r#else\nvec4 color=vec4(finalDiffuse*baseAmbientColor+finalSpecular+reflectionColor.rgb+refractionColor.rgb,alpha);\r#endif\n#ifdef LIGHTMAP\n#ifndef LIGHTMAPEXCLUDED\n#ifdef USELIGHTMAPASSHADOWMAP\ncolor.rgb*=lightmapColor.rgb;\r#else\ncolor.rgb+=lightmapColor.rgb;\r#endif\n#endif\n#endif\n#define CUSTOM_FRAGMENT_BEFORE_FOG\ncolor.rgb=max(color.rgb,0.);\r#include<logDepthFragment>\n#include<fogFragment>\n#ifdef IMAGEPROCESSINGPOSTPROCESS\ncolor.rgb=toLinearSpace(color.rgb);\r#else\n#ifdef IMAGEPROCESSING\ncolor.rgb=toLinearSpace(color.rgb);\rcolor=applyImageProcessing(color);\r#endif\n#endif\ncolor.a*=visibility;\r#ifdef PREMULTIPLYALPHA\ncolor.rgb*=color.a;\r#endif\n#define CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR\n#ifdef PREPASS\nfloat writeGeometryInfo=color.a>0.4 ? 1.0 : 0.0;\rgl_FragData[0]=color; \r#ifdef PREPASS_POSITION\ngl_FragData[PREPASS_POSITION_INDEX]=vec4(vPositionW,writeGeometryInfo);\r#endif\n#ifdef PREPASS_VELOCITY\nvec2 a=(vCurrentPosition.xy/vCurrentPosition.w)*0.5+0.5;\rvec2 b=(vPreviousPosition.xy/vPreviousPosition.w)*0.5+0.5;\rvec2 velocity=abs(a-b);\rvelocity=vec2(pow(velocity.x,1.0/3.0),pow(velocity.y,1.0/3.0))*sign(a-b)*0.5+0.5;\rgl_FragData[PREPASS_VELOCITY_INDEX]=vec4(velocity,0.0,writeGeometryInfo);\r#endif\n#ifdef PREPASS_IRRADIANCE\ngl_FragData[PREPASS_IRRADIANCE_INDEX]=vec4(0.0,0.0,0.0,writeGeometryInfo); \r#endif\n#ifdef PREPASS_DEPTH\ngl_FragData[PREPASS_DEPTH_INDEX]=vec4(vViewPos.z,0.0,0.0,writeGeometryInfo); \r#endif\n#ifdef PREPASS_NORMAL\ngl_FragData[PREPASS_NORMAL_INDEX]=vec4(normalize((view*vec4(normalW,0.0)).rgb),writeGeometryInfo); \r#endif\n#ifdef PREPASS_ALBEDO_SQRT\ngl_FragData[PREPASS_ALBEDO_SQRT_INDEX]=vec4(0.0,0.0,0.0,writeGeometryInfo); \r#endif\n#ifdef PREPASS_REFLECTIVITY\n#if defined(SPECULARTERM)\n#if defined(SPECULAR)\ngl_FragData[PREPASS_REFLECTIVITY_INDEX]=vec4(toLinearSpace(specularMapColor))*writeGeometryInfo; \r#else\ngl_FragData[PREPASS_REFLECTIVITY_INDEX]=vec4(toLinearSpace(specularColor),1.0)*writeGeometryInfo;\r#endif\n#else\ngl_FragData[PREPASS_REFLECTIVITY_INDEX]=vec4(0.0,0.0,0.0,1.0)*writeGeometryInfo;\r#endif\n#endif\n#endif\n#if !defined(PREPASS) || defined(WEBGL2)\ngl_FragColor=color;\r#endif\n#include<oitFragment>\n#if ORDER_INDEPENDENT_TRANSPARENCY\nif (fragDepth==nearestDepth) {\rfrontColor.rgb+=color.rgb*color.a*alphaMultiplier;\rfrontColor.a=1.0-alphaMultiplier*(1.0-color.a);\r} else {\rbackColor+=color;\r}\r#endif\n#define CUSTOM_FRAGMENT_MAIN_END\n}\r`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const defaultPixelShader = { name, shader };\n//# sourceMappingURL=default.fragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nimport \"./ShadersInclude/defaultVertexDeclaration.js\";\nimport \"./ShadersInclude/defaultUboDeclaration.js\";\nimport \"./ShadersInclude/uvAttributeDeclaration.js\";\nimport \"./ShadersInclude/helperFunctions.js\";\nimport \"./ShadersInclude/bonesDeclaration.js\";\nimport \"./ShadersInclude/bakedVertexAnimationDeclaration.js\";\nimport \"./ShadersInclude/instancesDeclaration.js\";\nimport \"./ShadersInclude/prePassVertexDeclaration.js\";\nimport \"./ShadersInclude/mainUVVaryingDeclaration.js\";\nimport \"./ShadersInclude/samplerVertexDeclaration.js\";\nimport \"./ShadersInclude/bumpVertexDeclaration.js\";\nimport \"./ShadersInclude/clipPlaneVertexDeclaration.js\";\nimport \"./ShadersInclude/fogVertexDeclaration.js\";\nimport \"./ShadersInclude/lightVxFragmentDeclaration.js\";\nimport \"./ShadersInclude/lightVxUboDeclaration.js\";\nimport \"./ShadersInclude/morphTargetsVertexGlobalDeclaration.js\";\nimport \"./ShadersInclude/morphTargetsVertexDeclaration.js\";\nimport \"./ShadersInclude/logDepthDeclaration.js\";\nimport \"./ShadersInclude/morphTargetsVertexGlobal.js\";\nimport \"./ShadersInclude/morphTargetsVertex.js\";\nimport \"./ShadersInclude/instancesVertex.js\";\nimport \"./ShadersInclude/bonesVertex.js\";\nimport \"./ShadersInclude/bakedVertexAnimation.js\";\nimport \"./ShadersInclude/prePassVertex.js\";\nimport \"./ShadersInclude/uvVariableDeclaration.js\";\nimport \"./ShadersInclude/samplerVertexImplementation.js\";\nimport \"./ShadersInclude/bumpVertex.js\";\nimport \"./ShadersInclude/clipPlaneVertex.js\";\nimport \"./ShadersInclude/fogVertex.js\";\nimport \"./ShadersInclude/shadowsVertex.js\";\nimport \"./ShadersInclude/vertexColorMixing.js\";\nimport \"./ShadersInclude/pointCloudVertex.js\";\nimport \"./ShadersInclude/logDepthVertex.js\";\nconst name = \"defaultVertexShader\";\nconst shader = `#include<__decl__defaultVertex>\n#define CUSTOM_VERTEX_BEGIN\nattribute vec3 position;\r#ifdef NORMAL\nattribute vec3 normal;\r#endif\n#ifdef TANGENT\nattribute vec4 tangent;\r#endif\n#ifdef UV1\nattribute vec2 uv;\r#endif\n#include<uvAttributeDeclaration>[2..7]\n#ifdef VERTEXCOLOR\nattribute vec4 color;\r#endif\n#include<helperFunctions>\n#include<bonesDeclaration>\n#include<bakedVertexAnimationDeclaration>\n#include<instancesDeclaration>\n#include<prePassVertexDeclaration>\n#include<mainUVVaryingDeclaration>[1..7]\n#include<samplerVertexDeclaration>(_DEFINENAME_,DIFFUSE,_VARYINGNAME_,Diffuse)\n#include<samplerVertexDeclaration>(_DEFINENAME_,DETAIL,_VARYINGNAME_,Detail)\n#include<samplerVertexDeclaration>(_DEFINENAME_,AMBIENT,_VARYINGNAME_,Ambient)\n#include<samplerVertexDeclaration>(_DEFINENAME_,OPACITY,_VARYINGNAME_,Opacity)\n#include<samplerVertexDeclaration>(_DEFINENAME_,EMISSIVE,_VARYINGNAME_,Emissive)\n#include<samplerVertexDeclaration>(_DEFINENAME_,LIGHTMAP,_VARYINGNAME_,Lightmap)\n#if defined(SPECULARTERM)\n#include<samplerVertexDeclaration>(_DEFINENAME_,SPECULAR,_VARYINGNAME_,Specular)\n#endif\n#include<samplerVertexDeclaration>(_DEFINENAME_,BUMP,_VARYINGNAME_,Bump)\nvarying vec3 vPositionW;\r#ifdef NORMAL\nvarying vec3 vNormalW;\r#endif\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nvarying vec4 vColor;\r#endif\n#include<bumpVertexDeclaration>\n#include<clipPlaneVertexDeclaration>\n#include<fogVertexDeclaration>\n#include<__decl__lightVxFragment>[0..maxSimultaneousLights]\n#include<morphTargetsVertexGlobalDeclaration>\n#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]\n#ifdef REFLECTIONMAP_SKYBOX\nvarying vec3 vPositionUVW;\r#endif\n#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\nvarying vec3 vDirectionW;\r#endif\n#include<logDepthDeclaration>\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void) {\r#define CUSTOM_VERTEX_MAIN_BEGIN\nvec3 positionUpdated=position;\r#ifdef NORMAL\nvec3 normalUpdated=normal;\r#endif\n#ifdef TANGENT\nvec4 tangentUpdated=tangent;\r#endif\n#ifdef UV1\nvec2 uvUpdated=uv;\r#endif\n#include<morphTargetsVertexGlobal>\n#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]\n#ifdef REFLECTIONMAP_SKYBOX\nvPositionUVW=positionUpdated;\r#endif\n#define CUSTOM_VERTEX_UPDATE_POSITION\n#define CUSTOM_VERTEX_UPDATE_NORMAL\n#include<instancesVertex>\n#if defined(PREPASS) && defined(PREPASS_VELOCITY) && !defined(BONES_VELOCITY_ENABLED)\nvCurrentPosition=viewProjection*finalWorld*vec4(positionUpdated,1.0);\rvPreviousPosition=previousViewProjection*finalPreviousWorld*vec4(positionUpdated,1.0);\r#endif\n#include<bonesVertex>\n#include<bakedVertexAnimation>\nvec4 worldPos=finalWorld*vec4(positionUpdated,1.0);\r#ifdef NORMAL\nmat3 normalWorld=mat3(finalWorld);\r#if defined(INSTANCES) && defined(THIN_INSTANCES)\nvNormalW=normalUpdated/vec3(dot(normalWorld[0],normalWorld[0]),dot(normalWorld[1],normalWorld[1]),dot(normalWorld[2],normalWorld[2]));\rvNormalW=normalize(normalWorld*vNormalW);\r#else\n#ifdef NONUNIFORMSCALING\nnormalWorld=transposeMat3(inverseMat3(normalWorld));\r#endif\nvNormalW=normalize(normalWorld*normalUpdated);\r#endif\n#endif\n#define CUSTOM_VERTEX_UPDATE_WORLDPOS\n#ifdef MULTIVIEW\nif (gl_ViewID_OVR==0u) {\rgl_Position=viewProjection*worldPos;\r} else {\rgl_Position=viewProjectionR*worldPos;\r}\r#else\ngl_Position=viewProjection*worldPos;\r#endif\nvPositionW=vec3(worldPos);\r#include<prePassVertex>\n#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\nvDirectionW=normalize(vec3(finalWorld*vec4(positionUpdated,0.0)));\r#endif\n#ifndef UV1\nvec2 uvUpdated=vec2(0.,0.);\r#endif\n#ifdef MAINUV1\nvMainUV1=uvUpdated;\r#endif\n#include<uvVariableDeclaration>[2..7]\n#include<samplerVertexImplementation>(_DEFINENAME_,DIFFUSE,_VARYINGNAME_,Diffuse,_MATRIXNAME_,diffuse,_INFONAME_,DiffuseInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,DETAIL,_VARYINGNAME_,Detail,_MATRIXNAME_,detail,_INFONAME_,DetailInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,AMBIENT,_VARYINGNAME_,Ambient,_MATRIXNAME_,ambient,_INFONAME_,AmbientInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,OPACITY,_VARYINGNAME_,Opacity,_MATRIXNAME_,opacity,_INFONAME_,OpacityInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,EMISSIVE,_VARYINGNAME_,Emissive,_MATRIXNAME_,emissive,_INFONAME_,EmissiveInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,LIGHTMAP,_VARYINGNAME_,Lightmap,_MATRIXNAME_,lightmap,_INFONAME_,LightmapInfos.x)\n#if defined(SPECULARTERM)\n#include<samplerVertexImplementation>(_DEFINENAME_,SPECULAR,_VARYINGNAME_,Specular,_MATRIXNAME_,specular,_INFONAME_,SpecularInfos.x)\n#endif\n#include<samplerVertexImplementation>(_DEFINENAME_,BUMP,_VARYINGNAME_,Bump,_MATRIXNAME_,bump,_INFONAME_,BumpInfos.x)\n#include<bumpVertex>\n#include<clipPlaneVertex>\n#include<fogVertex>\n#include<shadowsVertex>[0..maxSimultaneousLights]\n#include<vertexColorMixing>\n#include<pointCloudVertex>\n#include<logDepthVertex>\n#define CUSTOM_VERTEX_MAIN_END\n}\r`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const defaultVertexShader = { name, shader };\n//# sourceMappingURL=default.vertex.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nconst name = \"bonesVertex\";\nconst shader = `#ifndef BAKED_VERTEX_ANIMATION_TEXTURE\n#if NUM_BONE_INFLUENCERS>0\nvar influence : mat4x4<f32>;\r#ifdef BONETEXTURE\ninfluence=readMatrixFromRawSampler(boneSampler,matricesIndices[0])*matricesWeights[0];\r#if NUM_BONE_INFLUENCERS>1\ninfluence=influence+readMatrixFromRawSampler(boneSampler,matricesIndices[1])*matricesWeights[1];\r#endif \n#if NUM_BONE_INFLUENCERS>2\ninfluence=influence+readMatrixFromRawSampler(boneSampler,matricesIndices[2])*matricesWeights[2];\r#endif \n#if NUM_BONE_INFLUENCERS>3\ninfluence=influence+readMatrixFromRawSampler(boneSampler,matricesIndices[3])*matricesWeights[3];\r#endif \n#if NUM_BONE_INFLUENCERS>4\ninfluence=influence+readMatrixFromRawSampler(boneSampler,matricesIndicesExtra[0])*matricesWeightsExtra[0];\r#endif \n#if NUM_BONE_INFLUENCERS>5\ninfluence=influence+readMatrixFromRawSampler(boneSampler,matricesIndicesExtra[1])*matricesWeightsExtra[1];\r#endif \n#if NUM_BONE_INFLUENCERS>6\ninfluence=influence+readMatrixFromRawSampler(boneSampler,matricesIndicesExtra[2])*matricesWeightsExtra[2];\r#endif \n#if NUM_BONE_INFLUENCERS>7\ninfluence=influence+readMatrixFromRawSampler(boneSampler,matricesIndicesExtra[3])*matricesWeightsExtra[3];\r#endif \n#else \ninfluence=uniforms.mBones[int(matricesIndices[0])]*matricesWeights[0];\r#if NUM_BONE_INFLUENCERS>1\ninfluence=influence+uniforms.mBones[int(matricesIndices[1])]*matricesWeights[1];\r#endif \n#if NUM_BONE_INFLUENCERS>2\ninfluence=influence+uniforms.mBones[int(matricesIndices[2])]*matricesWeights[2];\r#endif \n#if NUM_BONE_INFLUENCERS>3\ninfluence=influence+uniforms.mBones[int(matricesIndices[3])]*matricesWeights[3];\r#endif \n#if NUM_BONE_INFLUENCERS>4\ninfluence=influence+uniforms.mBones[int(matricesIndicesExtra[0])]*matricesWeightsExtra[0];\r#endif \n#if NUM_BONE_INFLUENCERS>5\ninfluence=influence+uniforms.mBones[int(matricesIndicesExtra[1])]*matricesWeightsExtra[1];\r#endif \n#if NUM_BONE_INFLUENCERS>6\ninfluence=influence+uniforms.mBones[int(matricesIndicesExtra[2])]*matricesWeightsExtra[2];\r#endif \n#if NUM_BONE_INFLUENCERS>7\ninfluence=influence+uniforms.mBones[int(matricesIndicesExtra[3])]*matricesWeightsExtra[3];\r#endif \n#endif\nfinalWorld=finalWorld*influence;\r#endif\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStoreWGSL[name] = shader;\n/** @internal */\nexport const bonesVertex = { name, shader };\n//# sourceMappingURL=bonesVertex.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nconst name = \"clipPlaneFragmentDeclaration\";\nconst shader = `#ifdef CLIPPLANE\nvarying fClipDistance: f32;\r#endif\n#ifdef CLIPPLANE2\nvarying fClipDistance2: f32;\r#endif\n#ifdef CLIPPLANE3\nvarying fClipDistance3: f32;\r#endif\n#ifdef CLIPPLANE4\nvarying fClipDistance4: f32;\r#endif\n#ifdef CLIPPLANE5\nvarying fClipDistance5: f32;\r#endif\n#ifdef CLIPPLANE6\nvarying fClipDistance6: f32;\r#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStoreWGSL[name] = shader;\n/** @internal */\nexport const clipPlaneFragmentDeclaration = { name, shader };\n//# sourceMappingURL=clipPlaneFragmentDeclaration.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nconst name = \"morphTargetsVertex\";\nconst shader = `#ifdef MORPHTARGETS\n#ifdef MORPHTARGETS_TEXTURE \nvertexID=f32(gl_VertexID)*uniforms.morphTargetTextureInfo.x;\rpositionUpdated=positionUpdated+(readVector3FromRawSampler({X},vertexID)-position)*uniforms.morphTargetInfluences[{X}];\rvertexID=vertexID+1.0;\r#ifdef MORPHTARGETS_NORMAL\nnormalUpdated=normalUpdated+(readVector3FromRawSampler({X},vertexID) -normal)*uniforms.morphTargetInfluences[{X}];\rvertexID=vertexID+1.0;\r#endif\n#ifdef MORPHTARGETS_UV\nuvUpdated=uvUpdated+(readVector3FromRawSampler({X},vertexID).xy-uv)*uniforms.morphTargetInfluences[{X}];\rvertexID=vertexID+1.0;\r#endif\n#ifdef MORPHTARGETS_TANGENT\ntangentUpdated.xyz=tangentUpdated.xyz+(readVector3FromRawSampler({X},vertexID) -tangent.xyz)*uniforms.morphTargetInfluences[{X}];\r#endif\n#else\npositionUpdated=positionUpdated+(position{X}-position)*uniforms.morphTargetInfluences[{X}];\r#ifdef MORPHTARGETS_NORMAL\nnormalUpdated+=(normal{X}-normal)*uniforms.morphTargetInfluences[{X}];\r#endif\n#ifdef MORPHTARGETS_TANGENT\ntangentUpdated.xyz=tangentUpdated.xyz+(tangent{X}-tangent.xyz)*uniforms.morphTargetInfluences[{X}];\r#endif\n#ifdef MORPHTARGETS_UV\nuvUpdated=uvUpdated+(uv_{X}-uv)*uniforms.morphTargetInfluences[{X}];\r#endif\n#endif\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStoreWGSL[name] = shader;\n/** @internal */\nexport const morphTargetsVertex = { name, shader };\n//# sourceMappingURL=morphTargetsVertex.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nconst name = \"morphTargetsVertexDeclaration\";\nconst shader = `#ifdef MORPHTARGETS\n#ifndef MORPHTARGETS_TEXTURE\nattribute position{X} : vec3<f32>;\r#ifdef MORPHTARGETS_NORMAL\nattribute normal{X} : vec3<f32>;\r#endif\n#ifdef MORPHTARGETS_TANGENT\nattribute tangent{X} : vec3<f32>;\r#endif\n#ifdef MORPHTARGETS_UV\nattribute uv_{X} : vec2<f32>;\r#endif\n#endif\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStoreWGSL[name] = shader;\n/** @internal */\nexport const morphTargetsVertexDeclaration = { name, shader };\n//# sourceMappingURL=morphTargetsVertexDeclaration.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nconst name = \"morphTargetsVertexGlobal\";\nconst shader = `#ifdef MORPHTARGETS\n#ifdef MORPHTARGETS_TEXTURE\nvar vertexID : f32;\r#endif\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStoreWGSL[name] = shader;\n/** @internal */\nexport const morphTargetsVertexGlobal = { name, shader };\n//# sourceMappingURL=morphTargetsVertexGlobal.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nconst name = \"morphTargetsVertexGlobalDeclaration\";\nconst shader = `#ifdef MORPHTARGETS\nuniform morphTargetInfluences : array<f32,NUM_MORPH_INFLUENCERS>;\r#ifdef MORPHTARGETS_TEXTURE \nuniform morphTargetTextureIndices : array<f32,NUM_MORPH_INFLUENCERS>;\runiform morphTargetTextureInfo : vec3<f32>;\rvar morphTargets : texture_2d_array<f32>;\rvar morphTargetsSampler : sampler;\rfn readVector3FromRawSampler(targetIndex : i32,vertexIndex : f32)->vec3<f32>\r{ \rlet y=floor(vertexIndex/uniforms.morphTargetTextureInfo.y);\rlet x=vertexIndex-y*uniforms.morphTargetTextureInfo.y;\rlet textureUV=vec2<f32>((x+0.5)/uniforms.morphTargetTextureInfo.y,(y+0.5)/uniforms.morphTargetTextureInfo.z);\rreturn textureSampleLevel(morphTargets,morphTargetsSampler,textureUV,i32(uniforms.morphTargetTextureIndices[targetIndex]),0.0).xyz;\r}\r#endif\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStoreWGSL[name] = shader;\n/** @internal */\nexport const morphTargetsVertexGlobalDeclaration = { name, shader };\n//# sourceMappingURL=morphTargetsVertexGlobalDeclaration.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nconst name = \"gpuUpdateParticlesComputeShader\";\nconst shader = `struct Particle {\rposition : vec3<f32>,\rage : f32,\rsize : vec3<f32>,\rlife : f32,\rseed : vec4<f32>,\rdirection : vec3<f32>,\rdummy0: f32,\r#ifdef CUSTOMEMITTER\ninitialPosition : vec3<f32>,\rdummy1: f32,\r#endif\n#ifndef COLORGRADIENTS\ncolor : vec4<f32>,\r#endif\n#ifndef BILLBOARD\ninitialDirection : vec3<f32>,\rdummy2: f32,\r#endif\n#ifdef NOISE\nnoiseCoordinates1 : vec3<f32>,\rdummy3: f32,\rnoiseCoordinates2 : vec3<f32>,\rdummy4: f32,\r#endif\n#ifdef ANGULARSPEEDGRADIENTS\nangle : f32,\r#else\nangle : vec2<f32>,\r#endif\n#ifdef ANIMATESHEET\ncellIndex : f32,\r#ifdef ANIMATESHEETRANDOMSTART\ncellStartOffset : f32,\r#endif\n#endif\n};\rstruct Particles {\rparticles : array<Particle>,\r};\rstruct SimParams {\rcurrentCount : f32,\rtimeDelta : f32,\rstopFactor : f32,\rrandomTextureSize: i32,\rlifeTime : vec2<f32>,\remitPower : vec2<f32>,\r#ifndef COLORGRADIENTS\ncolor1 : vec4<f32>,\rcolor2 : vec4<f32>,\r#endif\nsizeRange : vec2<f32>,\rscaleRange : vec4<f32>,\rangleRange : vec4<f32>,\rgravity : vec3<f32>,\r#ifdef LIMITVELOCITYGRADIENTS\nlimitVelocityDamping : f32,\r#endif\n#ifdef ANIMATESHEET\ncellInfos : vec4<f32>,\r#endif\n#ifdef NOISE\nnoiseStrength : vec3<f32>,\r#endif\n#ifndef LOCAL\nemitterWM : mat4x4<f32>,\r#endif\n#ifdef BOXEMITTER\ndirection1 : vec3<f32>,\rdirection2 : vec3<f32>,\rminEmitBox : vec3<f32>,\rmaxEmitBox : vec3<f32>,\r#endif\n#ifdef CONEEMITTER\nradius : vec2<f32>,\rconeAngle : f32,\rheight : vec2<f32>,\rdirectionRandomizer : f32,\r#endif\n#ifdef CYLINDEREMITTER\nradius : f32,\rheight : f32,\rradiusRange : f32,\r#ifdef DIRECTEDCYLINDEREMITTER\ndirection1 : vec3<f32>,\rdirection2 : vec3<f32>,\r#else\ndirectionRandomizer : f32,\r#endif\n#endif\n#ifdef HEMISPHERICEMITTER\nradius : f32,\rradiusRange : f32,\rdirectionRandomizer : f32,\r#endif\n#ifdef POINTEMITTER\ndirection1 : vec3<f32>,\rdirection2 : vec3<f32>,\r#endif\n#ifdef SPHEREEMITTER\nradius : f32,\rradiusRange : f32,\r#ifdef DIRECTEDSPHEREEMITTER\ndirection1 : vec3<f32>,\rdirection2 : vec3<f32>,\r#else\ndirectionRandomizer : f32,\r#endif\n#endif\n};\r@binding(0) @group(0) var<uniform> params : SimParams;\r@binding(1) @group(0) var<storage,read> particlesIn : Particles;\r@binding(2) @group(0) var<storage,read_write> particlesOut : Particles;\r@binding(3) @group(0) var randomTexture : texture_2d<f32>;\r@binding(4) @group(0) var randomTexture2 : texture_2d<f32>;\r#ifdef SIZEGRADIENTS\n@binding(0) @group(1) var sizeGradientSampler : sampler;\r@binding(1) @group(1) var sizeGradientTexture : texture_2d<f32>;\r#endif \n#ifdef ANGULARSPEEDGRADIENTS\n@binding(2) @group(1) var angularSpeedGradientSampler : sampler;\r@binding(3) @group(1) var angularSpeedGradientTexture : texture_2d<f32>;\r#endif \n#ifdef VELOCITYGRADIENTS\n@binding(4) @group(1) var velocityGradientSampler : sampler;\r@binding(5) @group(1) var velocityGradientTexture : texture_2d<f32>;\r#endif\n#ifdef LIMITVELOCITYGRADIENTS\n@binding(6) @group(1) var limitVelocityGradientSampler : sampler;\r@binding(7) @group(1) var limitVelocityGradientTexture : texture_2d<f32>;\r#endif\n#ifdef DRAGGRADIENTS\n@binding(8) @group(1) var dragGradientSampler : sampler;\r@binding(9) @group(1) var dragGradientTexture : texture_2d<f32>;\r#endif\n#ifdef NOISE\n@binding(10) @group(1) var noiseSampler : sampler;\r@binding(11) @group(1) var noiseTexture : texture_2d<f32>;\r#endif\nfn getRandomVec3(offset : f32,vertexID : f32)->vec3<f32> {\rreturn textureLoad(randomTexture2,vec2<i32>(i32(vertexID*offset/params.currentCount*f32(params.randomTextureSize)) % params.randomTextureSize,0),0).rgb;\r}\rfn getRandomVec4(offset : f32,vertexID : f32)->vec4<f32> {\rreturn textureLoad(randomTexture,vec2<i32>(i32(vertexID*offset/params.currentCount*f32(params.randomTextureSize)) % params.randomTextureSize,0),0);\r}\r@stage(compute) @workgroup_size(64)\rfn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {\rlet index : u32=GlobalInvocationID.x;\rlet vertexID : f32=f32(index);\rif (index>=u32(params.currentCount)) {\rreturn;\r}\rlet PI : f32=3.14159;\rlet timeDelta : f32=params.timeDelta;\rlet newAge : f32=particlesIn.particles[index].age+timeDelta;\rlet life : f32=particlesIn.particles[index].life;\rlet seed : vec4<f32>=particlesIn.particles[index].seed;\rlet direction : vec3<f32>=particlesIn.particles[index].direction;\rif (newAge>=life && params.stopFactor != 0.) {\rvar newPosition : vec3<f32>;\rvar newDirection : vec3<f32>;\rlet randoms : vec4<f32>=getRandomVec4(seed.x,vertexID);\rlet outLife : f32=params.lifeTime.x+(params.lifeTime.y-params.lifeTime.x)*randoms.r;\rparticlesOut.particles[index].life=outLife;\rparticlesOut.particles[index].age=newAge-life;\rparticlesOut.particles[index].seed=seed;\rvar sizex : f32;\r#ifdef SIZEGRADIENTS \nsizex=textureSampleLevel(sizeGradientTexture,sizeGradientSampler,vec2<f32>(0.,0.),0.).r;\r#else\nsizex=params.sizeRange.x+(params.sizeRange.y-params.sizeRange.x)*randoms.g;\r#endif\nparticlesOut.particles[index].size=vec3<f32>(\rsizex,\rparams.scaleRange.x+(params.scaleRange.y-params.scaleRange.x)*randoms.b,\rparams.scaleRange.z+(params.scaleRange.w-params.scaleRange.z)*randoms.a);\r#ifndef COLORGRADIENTS\nparticlesOut.particles[index].color=params.color1+(params.color2-params.color1)*randoms.b;\r#endif\n#ifndef ANGULARSPEEDGRADIENTS \nparticlesOut.particles[index].angle=vec2<f32>(\rparams.angleRange.z+(params.angleRange.w-params.angleRange.z)*randoms.r,\rparams.angleRange.x+(params.angleRange.y-params.angleRange.x)*randoms.a);\r#else\nparticlesOut.particles[index].angle=params.angleRange.z+(params.angleRange.w-params.angleRange.z)*randoms.r;\r#endif \n#if defined(POINTEMITTER)\nlet randoms2 : vec3<f32>=getRandomVec3(seed.y,vertexID);\rlet randoms3 : vec3<f32>=getRandomVec3(seed.z,vertexID);\rnewPosition=vec3<f32>(0.,0.,0.);\rnewDirection=params.direction1+(params.direction2-params.direction1)*randoms3;\r#elif defined(BOXEMITTER)\nlet randoms2 : vec3<f32>=getRandomVec3(seed.y,vertexID);\rlet randoms3 : vec3<f32>=getRandomVec3(seed.z,vertexID);\rnewPosition=params.minEmitBox+(params.maxEmitBox-params.minEmitBox)*randoms2;\rnewDirection=params.direction1+(params.direction2-params.direction1)*randoms3; \r#elif defined(HEMISPHERICEMITTER)\nlet randoms2 : vec3<f32>=getRandomVec3(seed.y,vertexID);\rlet randoms3 : vec3<f32>=getRandomVec3(seed.z,vertexID);\rlet phi : f32=2.0*PI*randoms2.x;\rlet theta : f32=acos(-1.0+2.0*randoms2.y);\rlet randX : f32=cos(phi)*sin(theta);\rlet randY : f32=cos(theta);\rlet randZ : f32=sin(phi)*sin(theta);\rnewPosition=(params.radius-(params.radius*params.radiusRange*randoms2.z))*vec3<f32>(randX,abs(randY),randZ);\rnewDirection=normalize(newPosition+params.directionRandomizer*randoms3);\r#elif defined(SPHEREEMITTER)\nlet randoms2 : vec3<f32>=getRandomVec3(seed.y,vertexID);\rlet randoms3 : vec3<f32>=getRandomVec3(seed.z,vertexID);\rlet phi : f32=2.0*PI*randoms2.x;\rlet theta : f32=acos(-1.0+2.0*randoms2.y);\rlet randX : f32=cos(phi)*sin(theta);\rlet randY : f32=cos(theta);\rlet randZ : f32=sin(phi)*sin(theta);\rnewPosition=(params.radius-(params.radius*params.radiusRange*randoms2.z))*vec3<f32>(randX,randY,randZ);\r#ifdef DIRECTEDSPHEREEMITTER\nnewDirection=normalize(params.direction1+(params.direction2-params.direction1)*randoms3);\r#else\nnewDirection=normalize(newPosition+params.directionRandomizer*randoms3);\r#endif\n#elif defined(CYLINDEREMITTER)\nlet randoms2 : vec3<f32>=getRandomVec3(seed.y,vertexID);\rlet randoms3 : vec3<f32>=getRandomVec3(seed.z,vertexID);\rlet yPos : f32=(-0.5+randoms2.x)*params.height;\rvar angle : f32=randoms2.y*PI*2.;\rlet inverseRadiusRangeSquared : f32=(1.-params.radiusRange)*(1.-params.radiusRange);\rlet positionRadius : f32=params.radius*sqrt(inverseRadiusRangeSquared+randoms2.z*(1.-inverseRadiusRangeSquared));\rlet xPos : f32=positionRadius*cos(angle);\rlet zPos : f32=positionRadius*sin(angle);\rnewPosition=vec3<f32>(xPos,yPos,zPos);\r#ifdef DIRECTEDCYLINDEREMITTER\nnewDirection=params.direction1+(params.direction2-params.direction1)*randoms3;\r#else\nangle=angle+(-0.5+randoms3.x)*PI*params.directionRandomizer;\rnewDirection=vec3<f32>(cos(angle),(-0.5+randoms3.y)*params.directionRandomizer,sin(angle));\rnewDirection=normalize(newDirection);\r#endif\n#elif defined(CONEEMITTER)\nlet randoms2 : vec3<f32>=getRandomVec3(seed.y,vertexID);\rlet s : f32=2.0*PI*randoms2.x;\r#ifdef CONEEMITTERSPAWNPOINT\nlet h : f32=0.0001;\r#else\nvar h : f32=randoms2.y*params.height.y;\rh=1.-h*h; \r#endif\nvar lRadius : f32=params.radius.x-params.radius.x*randoms2.z*params.radius.y;\rlRadius=lRadius*h;\rlet randX : f32=lRadius*sin(s);\rlet randZ : f32=lRadius*cos(s);\rlet randY : f32=h *params.height.x;\rnewPosition=vec3<f32>(randX,randY,randZ); \rif (abs(cos(params.coneAngle))==1.0) {\rnewDirection=vec3<f32>(0.,1.0,0.);\r} else {\rlet randoms3 : vec3<f32>=getRandomVec3(seed.z,vertexID);\rnewDirection=normalize(newPosition+params.directionRandomizer*randoms3); \r}\r#elif defined(CUSTOMEMITTER)\nnewPosition=particlesIn.particles[index].initialPosition;\rparticlesOut.particles[index].initialPosition=newPosition;\r#else \nnewPosition=vec3<f32>(0.,0.,0.);\rnewDirection=2.0*(getRandomVec3(seed.w,vertexID)-vec3<f32>(0.5,0.5,0.5));\r#endif\nlet power : f32=params.emitPower.x+(params.emitPower.y-params.emitPower.x)*randoms.a;\r#ifdef LOCAL\nparticlesOut.particles[index].position=newPosition;\r#else\nparticlesOut.particles[index].position=(params.emitterWM*vec4<f32>(newPosition,1.)).xyz;\r#endif\n#ifdef CUSTOMEMITTER\nparticlesOut.particles[index].direction=direction;\r#ifndef BILLBOARD \nparticlesOut.particles[index].initialDirection=direction;\r#endif\n#else\n#ifdef LOCAL\nlet initial : vec3<f32>=newDirection;\r#else \nlet initial : vec3<f32>=(params.emitterWM*vec4<f32>(newDirection,0.)).xyz;\r#endif\nparticlesOut.particles[index].direction=initial*power;\r#ifndef BILLBOARD \nparticlesOut.particles[index].initialDirection=initial;\r#endif\n#endif\n#ifdef ANIMATESHEET \nparticlesOut.particles[index].cellIndex=params.cellInfos.x;\r#ifdef ANIMATESHEETRANDOMSTART\nparticlesOut.particles[index].cellStartOffset=randoms.a*outLife;\r#endif \n#endif\n#ifdef NOISE\nparticlesOut.particles[index].noiseCoordinates1=particlesIn.particles[index].noiseCoordinates1;\rparticlesOut.particles[index].noiseCoordinates2=particlesIn.particles[index].noiseCoordinates2;\r#endif\n} else {\rvar directionScale : f32=timeDelta;\rparticlesOut.particles[index].age=newAge;\rlet ageGradient : f32=newAge/life;\r#ifdef VELOCITYGRADIENTS\ndirectionScale=directionScale*textureSampleLevel(velocityGradientTexture,velocityGradientSampler,vec2<f32>(ageGradient,0.),0.).r;\r#endif\n#ifdef DRAGGRADIENTS\ndirectionScale=directionScale*(1.0-textureSampleLevel(dragGradientTexture,dragGradientSampler,vec2<f32>(ageGradient,0.),0.).r);\r#endif\nlet position : vec3<f32>=particlesIn.particles[index].position;\r#if defined(CUSTOMEMITTER)\nparticlesOut.particles[index].position=position+(direction-position)*ageGradient; \rparticlesOut.particles[index].initialPosition=particlesIn.particles[index].initialPosition;\r#else\nparticlesOut.particles[index].position=position+direction*directionScale;\r#endif\nparticlesOut.particles[index].life=life;\rparticlesOut.particles[index].seed=seed;\r#ifndef COLORGRADIENTS \nparticlesOut.particles[index].color=particlesIn.particles[index].color;\r#endif\n#ifdef SIZEGRADIENTS\nparticlesOut.particles[index].size=vec3<f32>(\rtextureSampleLevel(sizeGradientTexture,sizeGradientSampler,vec2<f32>(ageGradient,0.),0.).r,\rparticlesIn.particles[index].size.yz);\r#else\nparticlesOut.particles[index].size=particlesIn.particles[index].size;\r#endif \n#ifndef BILLBOARD \nparticlesOut.particles[index].initialDirection=particlesIn.particles[index].initialDirection;\r#endif\n#ifdef CUSTOMEMITTER\nparticlesOut.particles[index].direction=direction;\r#else\nvar updatedDirection : vec3<f32>=direction+params.gravity*timeDelta;\r#ifdef LIMITVELOCITYGRADIENTS\nlet limitVelocity : f32=textureSampleLevel(limitVelocityGradientTexture,limitVelocityGradientSampler,vec2<f32>(ageGradient,0.),0.).r;\rlet currentVelocity : f32=length(updatedDirection);\rif (currentVelocity>limitVelocity) {\rupdatedDirection=updatedDirection*params.limitVelocityDamping;\r}\r#endif\nparticlesOut.particles[index].direction=updatedDirection;\r#ifdef NOISE\nlet noiseCoordinates1 : vec3<f32>=particlesIn.particles[index].noiseCoordinates1;\rlet noiseCoordinates2 : vec3<f32>=particlesIn.particles[index].noiseCoordinates2;\rlet fetchedR : f32=textureSampleLevel(noiseTexture,noiseSampler,vec2<f32>(noiseCoordinates1.x,noiseCoordinates1.y)*vec2<f32>(0.5,0.5)+vec2<f32>(0.5,0.5),0.).r;\rlet fetchedG : f32=textureSampleLevel(noiseTexture,noiseSampler,vec2<f32>(noiseCoordinates1.z,noiseCoordinates2.x)*vec2<f32>(0.5,0.5)+vec2<f32>(0.5,0.5),0.).r;\rlet fetchedB : f32=textureSampleLevel(noiseTexture,noiseSampler,vec2<f32>(noiseCoordinates2.y,noiseCoordinates2.z)*vec2<f32>(0.5,0.5)+vec2<f32>(0.5,0.5),0.).r;\rlet force : vec3<f32>=vec3<f32>(-1.+2.*fetchedR,-1.+2.*fetchedG,-1.+2.*fetchedB)*params.noiseStrength;\rparticlesOut.particles[index].direction=particlesOut.particles[index].direction+force*timeDelta;\rparticlesOut.particles[index].noiseCoordinates1=noiseCoordinates1;\rparticlesOut.particles[index].noiseCoordinates2=noiseCoordinates2;\r#endif \n#endif \n#ifdef ANGULARSPEEDGRADIENTS\nlet angularSpeed : f32=textureSampleLevel(angularSpeedGradientTexture,angularSpeedGradientSampler,vec2<f32>(ageGradient,0.),0.).r;\rparticlesOut.particles[index].angle=particlesIn.particles[index].angle+angularSpeed*timeDelta;\r#else\nlet angle : vec2<f32>=particlesIn.particles[index].angle;\rparticlesOut.particles[index].angle=vec2<f32>(angle.x+angle.y*timeDelta,angle.y);\r#endif\n#ifdef ANIMATESHEET \nvar offsetAge : f32=particlesOut.particles[index].age;\rlet dist : f32=params.cellInfos.y-params.cellInfos.x;\r#ifdef ANIMATESHEETRANDOMSTART\nlet cellStartOffset : f32=particlesIn.particles[index].cellStartOffset;\rparticlesOut.particles[index].cellStartOffset=cellStartOffset;\roffsetAge=offsetAge+cellStartOffset;\r#else\nlet cellStartOffset : f32=0.;\r#endif \nvar ratio : f32;\rif (params.cellInfos.w==1.0) {\rratio=clamp(((cellStartOffset+params.cellInfos.z*offsetAge) % life)/life,0.,1.0);\r}\relse {\rratio=clamp((cellStartOffset+params.cellInfos.z*offsetAge)/life,0.,1.0);\r}\rparticlesOut.particles[index].cellIndex=f32(i32(params.cellInfos.x+ratio*dist));\r#endif\n}\r}\r`;\n// Sideeffect\nShaderStore.ShadersStoreWGSL[name] = shader;\n/** @internal */\nexport const gpuUpdateParticlesComputeShader = { name, shader };\n//# sourceMappingURL=gpuUpdateParticles.compute.js.map"],"names":["toRemove","this","reflectionProbes","index","indexOf","splice","newReflectionProbe","push","ReflectionProbe","constructor","name","size","scene","generateMipMaps","useFloat","linearSpace","_viewMatrix","_target","_add","_invertYAxis","position","metadata","_parentContainer","_scene","getEngine","supportsUniformBuffers","_sceneUBOs","i","createSceneUniformBuffer","Array","textureType","caps","getCaps","textureHalfFloatRender","textureFloatRender","_renderTargetTexture","gammaSpace","useReverseDepthBuffer","currentApplyByPostProcess","onBeforeRenderObservable","add","faceIndex","setSceneUniformBuffer","getSceneUniformBuffer","unbindEffect","copyFromFloats","useRightHandedSystem","_attachedMesh","copyFrom","getAbsolutePosition","addToRef","lookAtFunction","perspectiveFunction","activeCamera","_projectionMatrix","Math","PI","maxZ","minZ","isNDCHalfZRange","setTransformMatrix","isRigCamera","rigParent","_forcedViewPosition","onBeforeBindObservable","_a","_b","_currentSceneUBO","_debugPushGroup","call","imageProcessingConfiguration","applyByPostProcess","onAfterUnbindObservable","updateTransformMatrix","_debugPopGroup","samples","value","refreshRate","getScene","cubeTexture","renderList","attachToMesh","mesh","setRenderingAutoClearDepthStencil","renderingGroupId","autoClearDepthStencil","dispose","ubo","toString","fullDetails","ret","getClassName","serialize","serializationObject","isReflectionProbe","static","parsedReflectionProbe","rootUrl","reflectionProbe","length","rp","renderTargetSize","_generateMipMaps","_waitingRenderList","getMeshById","prototype","shader","engine","_uniformBufferFront","defines","e","indices","material","effect","_engine","setPrePassRenderer","prePassRenderer","n","_originalRender","rt","_needInitialization","_t","renderTarget","fluidObject","_diffuseEffectWrapper","renderObjects","renderingGroup","maintainStateBetweenFrames","getRenderingGroup","_notifyObservers","prePointerInfo","originalScenePick","pointerEvent","skipOnPointerObservable"],"sourceRoot":""}