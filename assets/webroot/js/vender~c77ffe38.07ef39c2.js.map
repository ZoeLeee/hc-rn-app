{"version":3,"file":"js/vender~c77ffe38.07ef39c2.js","mappings":"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","sources":["webpack:///../../../node_modules/@babylonjs/core/Bones/bone.js","webpack:///../../../node_modules/@babylonjs/core/Bones/boneIKController.js","webpack:///../../../node_modules/@babylonjs/core/Bones/boneLookController.js","webpack:///../../../node_modules/@babylonjs/core/Bones/skeleton.js","webpack:///../../../node_modules/@babylonjs/core/Buffers/buffer.js","webpack:///../../../node_modules/@babylonjs/core/Buffers/dataBuffer.js","webpack:///../../../node_modules/@babylonjs/core/Buffers/storageBuffer.js","webpack:///../../../node_modules/@babylonjs/core/Cameras/Inputs/BaseCameraMouseWheelInput.js","webpack:///../../../node_modules/@babylonjs/core/Cameras/Inputs/BaseCameraPointersInput.js","webpack:///../../../node_modules/@babylonjs/core/Cameras/Inputs/arcRotateCameraGamepadInput.js","webpack:///../../../node_modules/@babylonjs/core/Cameras/Inputs/arcRotateCameraKeyboardMoveInput.js","webpack:///../../../node_modules/@babylonjs/core/Cameras/Inputs/arcRotateCameraMouseWheelInput.js","webpack:///../../../node_modules/@babylonjs/core/Cameras/Inputs/arcRotateCameraPointersInput.js","webpack:///../../../node_modules/@babylonjs/core/Cameras/Inputs/freeCameraDeviceOrientationInput.js","webpack:///../../../node_modules/@babylonjs/core/Cameras/Inputs/freeCameraGamepadInput.js","webpack:///../../../node_modules/@babylonjs/core/Cameras/Inputs/freeCameraKeyboardMoveInput.js","webpack:///../../../node_modules/@babylonjs/core/Cameras/Inputs/freeCameraMouseInput.js","webpack:///../../../node_modules/@babylonjs/core/Cameras/Inputs/freeCameraMouseWheelInput.js","webpack:///../../../node_modules/@babylonjs/core/Cameras/Inputs/freeCameraTouchInput.js","webpack:///../../../node_modules/@babylonjs/core/Cameras/RigModes/vrRigMode.js","webpack:///../../../node_modules/@babylonjs/core/Cameras/RigModes/webVRRigMode.js","webpack:///../../../node_modules/@babylonjs/core/Cameras/VR/vrCameraMetrics.js","webpack:///../../../node_modules/@babylonjs/core/Cameras/VR/vrDeviceOrientationFreeCamera.js","webpack:///../../../node_modules/@babylonjs/core/Cameras/VR/vrExperienceHelper.js","webpack:///../../../node_modules/@babylonjs/core/Cameras/VR/webVRCamera.js","webpack:///../../../node_modules/@babylonjs/core/Cameras/arcRotateCamera.js","webpack:///../../../node_modules/@babylonjs/core/Cameras/arcRotateCameraInputsManager.js","webpack:///../../../node_modules/@babylonjs/core/Cameras/camera.js","webpack:///../../../node_modules/@babylonjs/core/Cameras/cameraInputsManager.js","webpack:///../../../node_modules/@babylonjs/core/Cameras/deviceOrientationCamera.js","webpack:///../../../node_modules/@babylonjs/core/Cameras/freeCamera.js","webpack:///../../../node_modules/@babylonjs/core/Cameras/freeCameraInputsManager.js","webpack:///../../../node_modules/@babylonjs/core/Cameras/Inputs/arcRotateCameraVRDeviceOrientationInput.js","webpack:///../../../node_modules/@babylonjs/core/Cameras/Inputs/flyCameraKeyboardInput.js","webpack:///../../../node_modules/@babylonjs/core/Cameras/Inputs/flyCameraMouseInput.js","webpack:///../../../node_modules/@babylonjs/core/Cameras/Inputs/followCameraKeyboardMoveInput.js","webpack:///../../../node_modules/@babylonjs/core/Cameras/Inputs/followCameraMouseWheelInput.js","webpack:///../../../node_modules/@babylonjs/core/Cameras/Inputs/followCameraPointersInput.js","webpack:///../../../node_modules/@babylonjs/core/Cameras/Inputs/freeCameraVirtualJoystickInput.js","webpack:///../../../node_modules/@babylonjs/core/Cameras/flyCameraInputsManager.js","webpack:///../../../node_modules/@babylonjs/core/Cameras/flyCamera.js","webpack:///../../../node_modules/@babylonjs/core/Cameras/followCameraInputsManager.js","webpack:///../../../node_modules/@babylonjs/core/Cameras/followCamera.js","webpack:///../../../node_modules/@babylonjs/core/Cameras/gamepadCamera.js","webpack:///../../../node_modules/@babylonjs/core/Cameras/RigModes/stereoscopicAnaglyphRigMode.js","webpack:///../../../node_modules/@babylonjs/core/Cameras/Stereoscopic/anaglyphArcRotateCamera.js","webpack:///../../../node_modules/@babylonjs/core/Cameras/Stereoscopic/anaglyphFreeCamera.js","webpack:///../../../node_modules/@babylonjs/core/Cameras/Stereoscopic/anaglyphGamepadCamera.js","webpack:///../../../node_modules/@babylonjs/core/Cameras/Stereoscopic/anaglyphUniversalCamera.js","webpack:///../../../node_modules/@babylonjs/core/Cameras/RigModes/stereoscopicRigMode.js","webpack:///../../../node_modules/@babylonjs/core/Cameras/Stereoscopic/stereoscopicArcRotateCamera.js","webpack:///../../../node_modules/@babylonjs/core/Cameras/Stereoscopic/stereoscopicFreeCamera.js","webpack:///../../../node_modules/@babylonjs/core/Cameras/Stereoscopic/stereoscopicGamepadCamera.js","webpack:///../../../node_modules/@babylonjs/core/Cameras/Stereoscopic/stereoscopicUniversalCamera.js","webpack:///../../../node_modules/@babylonjs/core/Cameras/virtualJoysticksCamera.js","webpack:///../../../node_modules/@babylonjs/core/Cameras/VR/vrDeviceOrientationArcRotateCamera.js","webpack:///../../../node_modules/@babylonjs/core/Cameras/VR/vrDeviceOrientationGamepadCamera.js","webpack:///../../../node_modules/@babylonjs/core/Cameras/targetCamera.js","webpack:///../../../node_modules/@babylonjs/core/Cameras/touchCamera.js","webpack:///../../../node_modules/@babylonjs/core/Cameras/universalCamera.js","webpack:///../../../node_modules/@babylonjs/core/Collisions/collider.js","webpack:///../../../node_modules/@babylonjs/core/Collisions/collisionCoordinator.js","webpack:///../../../node_modules/@babylonjs/core/Collisions/intersectionInfo.js","webpack:///../../../node_modules/@babylonjs/core/Collisions/meshCollisionData.js","webpack:///../../../node_modules/@babylonjs/core/Collisions/pickingInfo.js","webpack:///../../../node_modules/@babylonjs/core/Compat/compatibilityOptions.js","webpack:///../../../node_modules/@babylonjs/core/Compute/computeEffect.js","webpack:///../../../node_modules/@babylonjs/core/Compute/computeShader.js","webpack:///../../../node_modules/@babylonjs/core/Culling/boundingBox.js","webpack:///../../../node_modules/@babylonjs/core/Culling/boundingInfo.js","webpack:///../../../node_modules/@babylonjs/core/Culling/boundingSphere.js","webpack:///../../../node_modules/@babylonjs/core/Culling/Octrees/octreeBlock.js","webpack:///../../../node_modules/@babylonjs/core/Culling/Octrees/octree.js","webpack:///../../../node_modules/@babylonjs/core/Culling/Octrees/octreeSceneComponent.js","webpack:///../../../node_modules/@babylonjs/core/Culling/ray.js"],"sourcesContent":["import { Vector3, Quaternion, Matrix, TmpVectors } from \"../Maths/math.vector.js\";\nimport { ArrayTools } from \"../Misc/arrayTools.js\";\nimport { Node } from \"../node.js\";\nimport { Space } from \"../Maths/math.axis.js\";\n/**\n * Class used to store bone information\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/bonesSkeletons\n */\nexport class Bone extends Node {\n    /** @internal */\n    get _matrix() {\n        this._compose();\n        return this._localMatrix;\n    }\n    /** @internal */\n    set _matrix(value) {\n        this._needToCompose = false; // in case there was a pending compose\n        // skip if the matrices are the same\n        if (value.updateFlag === this._localMatrix.updateFlag) {\n            return;\n        }\n        this._localMatrix.copyFrom(value);\n        this._markAsDirtyAndDecompose();\n    }\n    /**\n     * Create a new bone\n     * @param name defines the bone name\n     * @param skeleton defines the parent skeleton\n     * @param parentBone defines the parent (can be null if the bone is the root)\n     * @param localMatrix defines the local matrix\n     * @param restPose defines the rest pose matrix\n     * @param baseMatrix defines the base matrix\n     * @param index defines index of the bone in the hierarchy\n     */\n    constructor(\n    /**\n     * defines the bone name\n     */\n    name, skeleton, parentBone = null, localMatrix = null, restPose = null, baseMatrix = null, index = null) {\n        super(name, skeleton.getScene());\n        this.name = name;\n        /**\n         * Gets the list of child bones\n         */\n        this.children = new Array();\n        /** Gets the animations associated with this bone */\n        this.animations = new Array();\n        /**\n         * @internal Internal only\n         * Set this value to map this bone to a different index in the transform matrices\n         * Set this value to -1 to exclude the bone from the transform matrices\n         */\n        this._index = null;\n        this._absoluteTransform = new Matrix();\n        this._invertedAbsoluteTransform = new Matrix();\n        this._scalingDeterminant = 1;\n        this._worldTransform = new Matrix();\n        this._needToDecompose = true;\n        this._needToCompose = false;\n        /** @internal */\n        this._linkedTransformNode = null;\n        /** @internal */\n        this._waitingTransformNodeId = null;\n        this._skeleton = skeleton;\n        this._localMatrix = localMatrix ? localMatrix.clone() : Matrix.Identity();\n        this._restPose = restPose ? restPose : this._localMatrix.clone();\n        this._baseMatrix = baseMatrix ? baseMatrix : this._localMatrix.clone();\n        this._index = index;\n        skeleton.bones.push(this);\n        this.setParent(parentBone, false);\n        if (baseMatrix || localMatrix) {\n            this._updateDifferenceMatrix();\n        }\n    }\n    /**\n     * Gets the current object class name.\n     * @returns the class name\n     */\n    getClassName() {\n        return \"Bone\";\n    }\n    // Members\n    /**\n     * Gets the parent skeleton\n     * @returns a skeleton\n     */\n    getSkeleton() {\n        return this._skeleton;\n    }\n    get parent() {\n        return this._parentNode;\n    }\n    /**\n     * Gets parent bone\n     * @returns a bone or null if the bone is the root of the bone hierarchy\n     */\n    getParent() {\n        return this.parent;\n    }\n    /**\n     * Returns an array containing the root bones\n     * @returns an array containing the root bones\n     */\n    getChildren() {\n        return this.children;\n    }\n    /**\n     * Gets the node index in matrix array generated for rendering\n     * @returns the node index\n     */\n    getIndex() {\n        return this._index === null ? this.getSkeleton().bones.indexOf(this) : this._index;\n    }\n    set parent(newParent) {\n        this.setParent(newParent);\n    }\n    /**\n     * Sets the parent bone\n     * @param parent defines the parent (can be null if the bone is the root)\n     * @param updateDifferenceMatrix defines if the difference matrix must be updated\n     */\n    setParent(parent, updateDifferenceMatrix = true) {\n        if (this.parent === parent) {\n            return;\n        }\n        if (this.parent) {\n            const index = this.parent.children.indexOf(this);\n            if (index !== -1) {\n                this.parent.children.splice(index, 1);\n            }\n        }\n        this._parentNode = parent;\n        if (this.parent) {\n            this.parent.children.push(this);\n        }\n        if (updateDifferenceMatrix) {\n            this._updateDifferenceMatrix();\n        }\n        this.markAsDirty();\n    }\n    /**\n     * Gets the local matrix\n     * @returns a matrix\n     */\n    getLocalMatrix() {\n        this._compose();\n        return this._localMatrix;\n    }\n    /**\n     * Gets the base matrix (initial matrix which remains unchanged)\n     * @returns the base matrix (as known as bind pose matrix)\n     */\n    getBaseMatrix() {\n        return this._baseMatrix;\n    }\n    /**\n     * Gets the rest pose matrix\n     * @returns a matrix\n     */\n    getRestPose() {\n        return this._restPose;\n    }\n    /**\n     * Sets the rest pose matrix\n     * @param matrix the local-space rest pose to set for this bone\n     */\n    setRestPose(matrix) {\n        this._restPose.copyFrom(matrix);\n    }\n    /**\n     * Gets the bind pose matrix\n     * @returns the bind pose matrix\n     * @deprecated Please use getBaseMatrix instead\n     */\n    getBindPose() {\n        return this._baseMatrix;\n    }\n    /**\n     * Sets the bind pose matrix\n     * @param matrix the local-space bind pose to set for this bone\n     * @deprecated Please use updateMatrix instead\n     */\n    setBindPose(matrix) {\n        this.updateMatrix(matrix);\n    }\n    /**\n     * Gets a matrix used to store world matrix (ie. the matrix sent to shaders)\n     */\n    getWorldMatrix() {\n        return this._worldTransform;\n    }\n    /**\n     * Sets the local matrix to rest pose matrix\n     */\n    returnToRest() {\n        var _a;\n        if (this._linkedTransformNode) {\n            const localScaling = TmpVectors.Vector3[0];\n            const localRotation = TmpVectors.Quaternion[0];\n            const localPosition = TmpVectors.Vector3[1];\n            this.getRestPose().decompose(localScaling, localRotation, localPosition);\n            this._linkedTransformNode.position.copyFrom(localPosition);\n            this._linkedTransformNode.rotationQuaternion = (_a = this._linkedTransformNode.rotationQuaternion) !== null && _a !== void 0 ? _a : Quaternion.Identity();\n            this._linkedTransformNode.rotationQuaternion.copyFrom(localRotation);\n            this._linkedTransformNode.scaling.copyFrom(localScaling);\n        }\n        else {\n            this._matrix = this._restPose;\n        }\n    }\n    /**\n     * Gets the inverse of the absolute transform matrix.\n     * This matrix will be multiplied by local matrix to get the difference matrix (ie. the difference between original state and current state)\n     * @returns a matrix\n     */\n    getInvertedAbsoluteTransform() {\n        return this._invertedAbsoluteTransform;\n    }\n    /**\n     * Gets the absolute transform matrix (ie base matrix * parent world matrix)\n     * @returns a matrix\n     */\n    getAbsoluteTransform() {\n        return this._absoluteTransform;\n    }\n    /**\n     * Links with the given transform node.\n     * The local matrix of this bone is copied from the transform node every frame.\n     * @param transformNode defines the transform node to link to\n     */\n    linkTransformNode(transformNode) {\n        if (this._linkedTransformNode) {\n            this._skeleton._numBonesWithLinkedTransformNode--;\n        }\n        this._linkedTransformNode = transformNode;\n        if (this._linkedTransformNode) {\n            this._skeleton._numBonesWithLinkedTransformNode++;\n        }\n    }\n    // Properties (matches TransformNode properties)\n    /**\n     * Gets the node used to drive the bone's transformation\n     * @returns a transform node or null\n     */\n    getTransformNode() {\n        return this._linkedTransformNode;\n    }\n    /** Gets or sets current position (in local space) */\n    get position() {\n        this._decompose();\n        return this._localPosition;\n    }\n    set position(newPosition) {\n        this._decompose();\n        this._localPosition.copyFrom(newPosition);\n        this._markAsDirtyAndCompose();\n    }\n    /** Gets or sets current rotation (in local space) */\n    get rotation() {\n        return this.getRotation();\n    }\n    set rotation(newRotation) {\n        this.setRotation(newRotation);\n    }\n    /** Gets or sets current rotation quaternion (in local space) */\n    get rotationQuaternion() {\n        this._decompose();\n        return this._localRotation;\n    }\n    set rotationQuaternion(newRotation) {\n        this.setRotationQuaternion(newRotation);\n    }\n    /** Gets or sets current scaling (in local space) */\n    get scaling() {\n        return this.getScale();\n    }\n    set scaling(newScaling) {\n        this.setScale(newScaling);\n    }\n    /**\n     * Gets the animation properties override\n     */\n    get animationPropertiesOverride() {\n        return this._skeleton.animationPropertiesOverride;\n    }\n    // Methods\n    _decompose() {\n        if (!this._needToDecompose) {\n            return;\n        }\n        this._needToDecompose = false;\n        if (!this._localScaling) {\n            this._localScaling = Vector3.Zero();\n            this._localRotation = Quaternion.Zero();\n            this._localPosition = Vector3.Zero();\n        }\n        this._localMatrix.decompose(this._localScaling, this._localRotation, this._localPosition);\n    }\n    _compose() {\n        if (!this._needToCompose) {\n            return;\n        }\n        if (!this._localScaling) {\n            this._needToCompose = false;\n            return;\n        }\n        this._needToCompose = false;\n        Matrix.ComposeToRef(this._localScaling, this._localRotation, this._localPosition, this._localMatrix);\n    }\n    /**\n     * Update the base and local matrices\n     * @param matrix defines the new base or local matrix\n     * @param updateDifferenceMatrix defines if the difference matrix must be updated\n     * @param updateLocalMatrix defines if the local matrix should be updated\n     */\n    updateMatrix(matrix, updateDifferenceMatrix = true, updateLocalMatrix = true) {\n        this._baseMatrix.copyFrom(matrix);\n        if (updateDifferenceMatrix) {\n            this._updateDifferenceMatrix();\n        }\n        if (updateLocalMatrix) {\n            this._matrix = matrix;\n        }\n        else {\n            this.markAsDirty();\n        }\n    }\n    /**\n     * @internal\n     */\n    _updateDifferenceMatrix(rootMatrix, updateChildren = true) {\n        if (!rootMatrix) {\n            rootMatrix = this._baseMatrix;\n        }\n        if (this.parent) {\n            rootMatrix.multiplyToRef(this.parent._absoluteTransform, this._absoluteTransform);\n        }\n        else {\n            this._absoluteTransform.copyFrom(rootMatrix);\n        }\n        this._absoluteTransform.invertToRef(this._invertedAbsoluteTransform);\n        if (updateChildren) {\n            for (let index = 0; index < this.children.length; index++) {\n                this.children[index]._updateDifferenceMatrix();\n            }\n        }\n        this._scalingDeterminant = this._absoluteTransform.determinant() < 0 ? -1 : 1;\n    }\n    /**\n     * Flag the bone as dirty (Forcing it to update everything)\n     * @returns this bone\n     */\n    markAsDirty() {\n        this._currentRenderId++;\n        this._childUpdateId++;\n        this._skeleton._markAsDirty();\n        return this;\n    }\n    /** @internal */\n    _markAsDirtyAndCompose() {\n        this.markAsDirty();\n        this._needToCompose = true;\n    }\n    _markAsDirtyAndDecompose() {\n        this.markAsDirty();\n        this._needToDecompose = true;\n    }\n    /**\n     * Translate the bone in local or world space\n     * @param vec The amount to translate the bone\n     * @param space The space that the translation is in\n     * @param tNode The TransformNode that this bone is attached to. This is only used in world space\n     */\n    translate(vec, space = Space.LOCAL, tNode) {\n        const lm = this.getLocalMatrix();\n        if (space == Space.LOCAL) {\n            lm.addAtIndex(12, vec.x);\n            lm.addAtIndex(13, vec.y);\n            lm.addAtIndex(14, vec.z);\n        }\n        else {\n            let wm = null;\n            //tNode.getWorldMatrix() needs to be called before skeleton.computeAbsoluteTransforms()\n            if (tNode) {\n                wm = tNode.getWorldMatrix();\n            }\n            this._skeleton.computeAbsoluteTransforms();\n            const tmat = Bone._TmpMats[0];\n            const tvec = Bone._TmpVecs[0];\n            if (this.parent) {\n                if (tNode && wm) {\n                    tmat.copyFrom(this.parent.getAbsoluteTransform());\n                    tmat.multiplyToRef(wm, tmat);\n                }\n                else {\n                    tmat.copyFrom(this.parent.getAbsoluteTransform());\n                }\n            }\n            else {\n                Matrix.IdentityToRef(tmat);\n            }\n            tmat.setTranslationFromFloats(0, 0, 0);\n            tmat.invert();\n            Vector3.TransformCoordinatesToRef(vec, tmat, tvec);\n            lm.addAtIndex(12, tvec.x);\n            lm.addAtIndex(13, tvec.y);\n            lm.addAtIndex(14, tvec.z);\n        }\n        this._markAsDirtyAndDecompose();\n    }\n    /**\n     * Set the position of the bone in local or world space\n     * @param position The position to set the bone\n     * @param space The space that the position is in\n     * @param tNode The TransformNode that this bone is attached to.  This is only used in world space\n     */\n    setPosition(position, space = Space.LOCAL, tNode) {\n        const lm = this.getLocalMatrix();\n        if (space == Space.LOCAL) {\n            lm.setTranslationFromFloats(position.x, position.y, position.z);\n        }\n        else {\n            let wm = null;\n            //tNode.getWorldMatrix() needs to be called before skeleton.computeAbsoluteTransforms()\n            if (tNode) {\n                wm = tNode.getWorldMatrix();\n            }\n            this._skeleton.computeAbsoluteTransforms();\n            const tmat = Bone._TmpMats[0];\n            const vec = Bone._TmpVecs[0];\n            if (this.parent) {\n                if (tNode && wm) {\n                    tmat.copyFrom(this.parent.getAbsoluteTransform());\n                    tmat.multiplyToRef(wm, tmat);\n                }\n                else {\n                    tmat.copyFrom(this.parent.getAbsoluteTransform());\n                }\n                tmat.invert();\n            }\n            else {\n                Matrix.IdentityToRef(tmat);\n            }\n            Vector3.TransformCoordinatesToRef(position, tmat, vec);\n            lm.setTranslationFromFloats(vec.x, vec.y, vec.z);\n        }\n        this._markAsDirtyAndDecompose();\n    }\n    /**\n     * Set the absolute position of the bone (world space)\n     * @param position The position to set the bone\n     * @param tNode The TransformNode that this bone is attached to\n     */\n    setAbsolutePosition(position, tNode) {\n        this.setPosition(position, Space.WORLD, tNode);\n    }\n    /**\n     * Scale the bone on the x, y and z axes (in local space)\n     * @param x The amount to scale the bone on the x axis\n     * @param y The amount to scale the bone on the y axis\n     * @param z The amount to scale the bone on the z axis\n     * @param scaleChildren sets this to true if children of the bone should be scaled as well (false by default)\n     */\n    scale(x, y, z, scaleChildren = false) {\n        const locMat = this.getLocalMatrix();\n        // Apply new scaling on top of current local matrix\n        const scaleMat = Bone._TmpMats[0];\n        Matrix.ScalingToRef(x, y, z, scaleMat);\n        scaleMat.multiplyToRef(locMat, locMat);\n        // Invert scaling matrix and apply the inverse to all children\n        scaleMat.invert();\n        for (const child of this.children) {\n            const cm = child.getLocalMatrix();\n            cm.multiplyToRef(scaleMat, cm);\n            cm.multiplyAtIndex(12, x);\n            cm.multiplyAtIndex(13, y);\n            cm.multiplyAtIndex(14, z);\n            child._markAsDirtyAndDecompose();\n        }\n        this._markAsDirtyAndDecompose();\n        if (scaleChildren) {\n            for (const child of this.children) {\n                child.scale(x, y, z, scaleChildren);\n            }\n        }\n    }\n    /**\n     * Set the bone scaling in local space\n     * @param scale defines the scaling vector\n     */\n    setScale(scale) {\n        this._decompose();\n        this._localScaling.copyFrom(scale);\n        this._markAsDirtyAndCompose();\n    }\n    /**\n     * Gets the current scaling in local space\n     * @returns the current scaling vector\n     */\n    getScale() {\n        this._decompose();\n        return this._localScaling;\n    }\n    /**\n     * Gets the current scaling in local space and stores it in a target vector\n     * @param result defines the target vector\n     */\n    getScaleToRef(result) {\n        this._decompose();\n        result.copyFrom(this._localScaling);\n    }\n    /**\n     * Set the yaw, pitch, and roll of the bone in local or world space\n     * @param yaw The rotation of the bone on the y axis\n     * @param pitch The rotation of the bone on the x axis\n     * @param roll The rotation of the bone on the z axis\n     * @param space The space that the axes of rotation are in\n     * @param tNode The TransformNode that this bone is attached to.  This is only used in world space\n     */\n    setYawPitchRoll(yaw, pitch, roll, space = Space.LOCAL, tNode) {\n        if (space === Space.LOCAL) {\n            const quat = Bone._TmpQuat;\n            Quaternion.RotationYawPitchRollToRef(yaw, pitch, roll, quat);\n            this.setRotationQuaternion(quat, space, tNode);\n            return;\n        }\n        const rotMatInv = Bone._TmpMats[0];\n        if (!this._getNegativeRotationToRef(rotMatInv, tNode)) {\n            return;\n        }\n        const rotMat = Bone._TmpMats[1];\n        Matrix.RotationYawPitchRollToRef(yaw, pitch, roll, rotMat);\n        rotMatInv.multiplyToRef(rotMat, rotMat);\n        this._rotateWithMatrix(rotMat, space, tNode);\n    }\n    /**\n     * Add a rotation to the bone on an axis in local or world space\n     * @param axis The axis to rotate the bone on\n     * @param amount The amount to rotate the bone\n     * @param space The space that the axis is in\n     * @param tNode The TransformNode that this bone is attached to. This is only used in world space\n     */\n    rotate(axis, amount, space = Space.LOCAL, tNode) {\n        const rmat = Bone._TmpMats[0];\n        rmat.setTranslationFromFloats(0, 0, 0);\n        Matrix.RotationAxisToRef(axis, amount, rmat);\n        this._rotateWithMatrix(rmat, space, tNode);\n    }\n    /**\n     * Set the rotation of the bone to a particular axis angle in local or world space\n     * @param axis The axis to rotate the bone on\n     * @param angle The angle that the bone should be rotated to\n     * @param space The space that the axis is in\n     * @param tNode The TransformNode that this bone is attached to.  This is only used in world space\n     */\n    setAxisAngle(axis, angle, space = Space.LOCAL, tNode) {\n        if (space === Space.LOCAL) {\n            const quat = Bone._TmpQuat;\n            Quaternion.RotationAxisToRef(axis, angle, quat);\n            this.setRotationQuaternion(quat, space, tNode);\n            return;\n        }\n        const rotMatInv = Bone._TmpMats[0];\n        if (!this._getNegativeRotationToRef(rotMatInv, tNode)) {\n            return;\n        }\n        const rotMat = Bone._TmpMats[1];\n        Matrix.RotationAxisToRef(axis, angle, rotMat);\n        rotMatInv.multiplyToRef(rotMat, rotMat);\n        this._rotateWithMatrix(rotMat, space, tNode);\n    }\n    /**\n     * Set the euler rotation of the bone in local or world space\n     * @param rotation The euler rotation that the bone should be set to\n     * @param space The space that the rotation is in\n     * @param tNode The TransformNode that this bone is attached to. This is only used in world space\n     */\n    setRotation(rotation, space = Space.LOCAL, tNode) {\n        this.setYawPitchRoll(rotation.y, rotation.x, rotation.z, space, tNode);\n    }\n    /**\n     * Set the quaternion rotation of the bone in local or world space\n     * @param quat The quaternion rotation that the bone should be set to\n     * @param space The space that the rotation is in\n     * @param tNode The TransformNode that this bone is attached to. This is only used in world space\n     */\n    setRotationQuaternion(quat, space = Space.LOCAL, tNode) {\n        if (space === Space.LOCAL) {\n            this._decompose();\n            this._localRotation.copyFrom(quat);\n            this._markAsDirtyAndCompose();\n            return;\n        }\n        const rotMatInv = Bone._TmpMats[0];\n        if (!this._getNegativeRotationToRef(rotMatInv, tNode)) {\n            return;\n        }\n        const rotMat = Bone._TmpMats[1];\n        Matrix.FromQuaternionToRef(quat, rotMat);\n        rotMatInv.multiplyToRef(rotMat, rotMat);\n        this._rotateWithMatrix(rotMat, space, tNode);\n    }\n    /**\n     * Set the rotation matrix of the bone in local or world space\n     * @param rotMat The rotation matrix that the bone should be set to\n     * @param space The space that the rotation is in\n     * @param tNode The TransformNode that this bone is attached to. This is only used in world space\n     */\n    setRotationMatrix(rotMat, space = Space.LOCAL, tNode) {\n        if (space === Space.LOCAL) {\n            const quat = Bone._TmpQuat;\n            Quaternion.FromRotationMatrixToRef(rotMat, quat);\n            this.setRotationQuaternion(quat, space, tNode);\n            return;\n        }\n        const rotMatInv = Bone._TmpMats[0];\n        if (!this._getNegativeRotationToRef(rotMatInv, tNode)) {\n            return;\n        }\n        const rotMat2 = Bone._TmpMats[1];\n        rotMat2.copyFrom(rotMat);\n        rotMatInv.multiplyToRef(rotMat, rotMat2);\n        this._rotateWithMatrix(rotMat2, space, tNode);\n    }\n    _rotateWithMatrix(rmat, space = Space.LOCAL, tNode) {\n        const lmat = this.getLocalMatrix();\n        const lx = lmat.m[12];\n        const ly = lmat.m[13];\n        const lz = lmat.m[14];\n        const parent = this.getParent();\n        const parentScale = Bone._TmpMats[3];\n        const parentScaleInv = Bone._TmpMats[4];\n        if (parent && space == Space.WORLD) {\n            if (tNode) {\n                parentScale.copyFrom(tNode.getWorldMatrix());\n                parent.getAbsoluteTransform().multiplyToRef(parentScale, parentScale);\n            }\n            else {\n                parentScale.copyFrom(parent.getAbsoluteTransform());\n            }\n            parentScaleInv.copyFrom(parentScale);\n            parentScaleInv.invert();\n            lmat.multiplyToRef(parentScale, lmat);\n            lmat.multiplyToRef(rmat, lmat);\n            lmat.multiplyToRef(parentScaleInv, lmat);\n        }\n        else {\n            if (space == Space.WORLD && tNode) {\n                parentScale.copyFrom(tNode.getWorldMatrix());\n                parentScaleInv.copyFrom(parentScale);\n                parentScaleInv.invert();\n                lmat.multiplyToRef(parentScale, lmat);\n                lmat.multiplyToRef(rmat, lmat);\n                lmat.multiplyToRef(parentScaleInv, lmat);\n            }\n            else {\n                lmat.multiplyToRef(rmat, lmat);\n            }\n        }\n        lmat.setTranslationFromFloats(lx, ly, lz);\n        this.computeAbsoluteTransforms();\n        this._markAsDirtyAndDecompose();\n    }\n    _getNegativeRotationToRef(rotMatInv, tNode) {\n        const scaleMatrix = Bone._TmpMats[2];\n        rotMatInv.copyFrom(this.getAbsoluteTransform());\n        if (tNode) {\n            rotMatInv.multiplyToRef(tNode.getWorldMatrix(), rotMatInv);\n            Matrix.ScalingToRef(tNode.scaling.x, tNode.scaling.y, tNode.scaling.z, scaleMatrix);\n        }\n        else {\n            Matrix.IdentityToRef(scaleMatrix);\n        }\n        rotMatInv.invert();\n        if (isNaN(rotMatInv.m[0])) {\n            // Matrix failed to invert.\n            // This can happen if scale is zero for example.\n            return false;\n        }\n        scaleMatrix.multiplyAtIndex(0, this._scalingDeterminant);\n        rotMatInv.multiplyToRef(scaleMatrix, rotMatInv);\n        return true;\n    }\n    /**\n     * Get the position of the bone in local or world space\n     * @param space The space that the returned position is in\n     * @param tNode The TransformNode that this bone is attached to. This is only used in world space\n     * @returns The position of the bone\n     */\n    getPosition(space = Space.LOCAL, tNode = null) {\n        const pos = Vector3.Zero();\n        this.getPositionToRef(space, tNode, pos);\n        return pos;\n    }\n    /**\n     * Copy the position of the bone to a vector3 in local or world space\n     * @param space The space that the returned position is in\n     * @param tNode The TransformNode that this bone is attached to. This is only used in world space\n     * @param result The vector3 to copy the position to\n     */\n    getPositionToRef(space = Space.LOCAL, tNode, result) {\n        if (space == Space.LOCAL) {\n            const lm = this.getLocalMatrix();\n            result.x = lm.m[12];\n            result.y = lm.m[13];\n            result.z = lm.m[14];\n        }\n        else {\n            let wm = null;\n            //tNode.getWorldMatrix() needs to be called before skeleton.computeAbsoluteTransforms()\n            if (tNode) {\n                wm = tNode.getWorldMatrix();\n            }\n            this._skeleton.computeAbsoluteTransforms();\n            let tmat = Bone._TmpMats[0];\n            if (tNode && wm) {\n                tmat.copyFrom(this.getAbsoluteTransform());\n                tmat.multiplyToRef(wm, tmat);\n            }\n            else {\n                tmat = this.getAbsoluteTransform();\n            }\n            result.x = tmat.m[12];\n            result.y = tmat.m[13];\n            result.z = tmat.m[14];\n        }\n    }\n    /**\n     * Get the absolute position of the bone (world space)\n     * @param tNode The TransformNode that this bone is attached to\n     * @returns The absolute position of the bone\n     */\n    getAbsolutePosition(tNode = null) {\n        const pos = Vector3.Zero();\n        this.getPositionToRef(Space.WORLD, tNode, pos);\n        return pos;\n    }\n    /**\n     * Copy the absolute position of the bone (world space) to the result param\n     * @param tNode The TransformNode that this bone is attached to\n     * @param result The vector3 to copy the absolute position to\n     */\n    getAbsolutePositionToRef(tNode, result) {\n        this.getPositionToRef(Space.WORLD, tNode, result);\n    }\n    /**\n     * Compute the absolute transforms of this bone and its children\n     */\n    computeAbsoluteTransforms() {\n        this._compose();\n        if (this.parent) {\n            this._localMatrix.multiplyToRef(this.parent._absoluteTransform, this._absoluteTransform);\n        }\n        else {\n            this._absoluteTransform.copyFrom(this._localMatrix);\n            const poseMatrix = this._skeleton.getPoseMatrix();\n            if (poseMatrix) {\n                this._absoluteTransform.multiplyToRef(poseMatrix, this._absoluteTransform);\n            }\n        }\n        const children = this.children;\n        const len = children.length;\n        for (let i = 0; i < len; i++) {\n            children[i].computeAbsoluteTransforms();\n        }\n    }\n    /**\n     * Get the world direction from an axis that is in the local space of the bone\n     * @param localAxis The local direction that is used to compute the world direction\n     * @param tNode The TransformNode that this bone is attached to\n     * @returns The world direction\n     */\n    getDirection(localAxis, tNode = null) {\n        const result = Vector3.Zero();\n        this.getDirectionToRef(localAxis, tNode, result);\n        return result;\n    }\n    /**\n     * Copy the world direction to a vector3 from an axis that is in the local space of the bone\n     * @param localAxis The local direction that is used to compute the world direction\n     * @param tNode The TransformNode that this bone is attached to\n     * @param result The vector3 that the world direction will be copied to\n     */\n    getDirectionToRef(localAxis, tNode = null, result) {\n        let wm = null;\n        //tNode.getWorldMatrix() needs to be called before skeleton.computeAbsoluteTransforms()\n        if (tNode) {\n            wm = tNode.getWorldMatrix();\n        }\n        this._skeleton.computeAbsoluteTransforms();\n        const mat = Bone._TmpMats[0];\n        mat.copyFrom(this.getAbsoluteTransform());\n        if (tNode && wm) {\n            mat.multiplyToRef(wm, mat);\n        }\n        Vector3.TransformNormalToRef(localAxis, mat, result);\n        result.normalize();\n    }\n    /**\n     * Get the euler rotation of the bone in local or world space\n     * @param space The space that the rotation should be in\n     * @param tNode The TransformNode that this bone is attached to.  This is only used in world space\n     * @returns The euler rotation\n     */\n    getRotation(space = Space.LOCAL, tNode = null) {\n        const result = Vector3.Zero();\n        this.getRotationToRef(space, tNode, result);\n        return result;\n    }\n    /**\n     * Copy the euler rotation of the bone to a vector3.  The rotation can be in either local or world space\n     * @param space The space that the rotation should be in\n     * @param tNode The TransformNode that this bone is attached to.  This is only used in world space\n     * @param result The vector3 that the rotation should be copied to\n     */\n    getRotationToRef(space = Space.LOCAL, tNode = null, result) {\n        const quat = Bone._TmpQuat;\n        this.getRotationQuaternionToRef(space, tNode, quat);\n        quat.toEulerAnglesToRef(result);\n    }\n    /**\n     * Get the quaternion rotation of the bone in either local or world space\n     * @param space The space that the rotation should be in\n     * @param tNode The TransformNode that this bone is attached to.  This is only used in world space\n     * @returns The quaternion rotation\n     */\n    getRotationQuaternion(space = Space.LOCAL, tNode = null) {\n        const result = Quaternion.Identity();\n        this.getRotationQuaternionToRef(space, tNode, result);\n        return result;\n    }\n    /**\n     * Copy the quaternion rotation of the bone to a quaternion.  The rotation can be in either local or world space\n     * @param space The space that the rotation should be in\n     * @param tNode The TransformNode that this bone is attached to.  This is only used in world space\n     * @param result The quaternion that the rotation should be copied to\n     */\n    getRotationQuaternionToRef(space = Space.LOCAL, tNode = null, result) {\n        if (space == Space.LOCAL) {\n            this._decompose();\n            result.copyFrom(this._localRotation);\n        }\n        else {\n            const mat = Bone._TmpMats[0];\n            const amat = this.getAbsoluteTransform();\n            if (tNode) {\n                amat.multiplyToRef(tNode.getWorldMatrix(), mat);\n            }\n            else {\n                mat.copyFrom(amat);\n            }\n            mat.multiplyAtIndex(0, this._scalingDeterminant);\n            mat.multiplyAtIndex(1, this._scalingDeterminant);\n            mat.multiplyAtIndex(2, this._scalingDeterminant);\n            mat.decompose(undefined, result, undefined);\n        }\n    }\n    /**\n     * Get the rotation matrix of the bone in local or world space\n     * @param space The space that the rotation should be in\n     * @param tNode The TransformNode that this bone is attached to.  This is only used in world space\n     * @returns The rotation matrix\n     */\n    getRotationMatrix(space = Space.LOCAL, tNode) {\n        const result = Matrix.Identity();\n        this.getRotationMatrixToRef(space, tNode, result);\n        return result;\n    }\n    /**\n     * Copy the rotation matrix of the bone to a matrix.  The rotation can be in either local or world space\n     * @param space The space that the rotation should be in\n     * @param tNode The TransformNode that this bone is attached to.  This is only used in world space\n     * @param result The quaternion that the rotation should be copied to\n     */\n    getRotationMatrixToRef(space = Space.LOCAL, tNode, result) {\n        if (space == Space.LOCAL) {\n            this.getLocalMatrix().getRotationMatrixToRef(result);\n        }\n        else {\n            const mat = Bone._TmpMats[0];\n            const amat = this.getAbsoluteTransform();\n            if (tNode) {\n                amat.multiplyToRef(tNode.getWorldMatrix(), mat);\n            }\n            else {\n                mat.copyFrom(amat);\n            }\n            mat.multiplyAtIndex(0, this._scalingDeterminant);\n            mat.multiplyAtIndex(1, this._scalingDeterminant);\n            mat.multiplyAtIndex(2, this._scalingDeterminant);\n            mat.getRotationMatrixToRef(result);\n        }\n    }\n    /**\n     * Get the world position of a point that is in the local space of the bone\n     * @param position The local position\n     * @param tNode The TransformNode that this bone is attached to\n     * @returns The world position\n     */\n    getAbsolutePositionFromLocal(position, tNode = null) {\n        const result = Vector3.Zero();\n        this.getAbsolutePositionFromLocalToRef(position, tNode, result);\n        return result;\n    }\n    /**\n     * Get the world position of a point that is in the local space of the bone and copy it to the result param\n     * @param position The local position\n     * @param tNode The TransformNode that this bone is attached to\n     * @param result The vector3 that the world position should be copied to\n     */\n    getAbsolutePositionFromLocalToRef(position, tNode = null, result) {\n        let wm = null;\n        //tNode.getWorldMatrix() needs to be called before skeleton.computeAbsoluteTransforms()\n        if (tNode) {\n            wm = tNode.getWorldMatrix();\n        }\n        this._skeleton.computeAbsoluteTransforms();\n        let tmat = Bone._TmpMats[0];\n        if (tNode && wm) {\n            tmat.copyFrom(this.getAbsoluteTransform());\n            tmat.multiplyToRef(wm, tmat);\n        }\n        else {\n            tmat = this.getAbsoluteTransform();\n        }\n        Vector3.TransformCoordinatesToRef(position, tmat, result);\n    }\n    /**\n     * Get the local position of a point that is in world space\n     * @param position The world position\n     * @param tNode The TransformNode that this bone is attached to\n     * @returns The local position\n     */\n    getLocalPositionFromAbsolute(position, tNode = null) {\n        const result = Vector3.Zero();\n        this.getLocalPositionFromAbsoluteToRef(position, tNode, result);\n        return result;\n    }\n    /**\n     * Get the local position of a point that is in world space and copy it to the result param\n     * @param position The world position\n     * @param tNode The TransformNode that this bone is attached to\n     * @param result The vector3 that the local position should be copied to\n     */\n    getLocalPositionFromAbsoluteToRef(position, tNode = null, result) {\n        let wm = null;\n        //tNode.getWorldMatrix() needs to be called before skeleton.computeAbsoluteTransforms()\n        if (tNode) {\n            wm = tNode.getWorldMatrix();\n        }\n        this._skeleton.computeAbsoluteTransforms();\n        const tmat = Bone._TmpMats[0];\n        tmat.copyFrom(this.getAbsoluteTransform());\n        if (tNode && wm) {\n            tmat.multiplyToRef(wm, tmat);\n        }\n        tmat.invert();\n        Vector3.TransformCoordinatesToRef(position, tmat, result);\n    }\n    /**\n     * Set the current local matrix as the restPose for this bone.\n     */\n    setCurrentPoseAsRest() {\n        this.setRestPose(this.getLocalMatrix());\n    }\n}\nBone._TmpVecs = ArrayTools.BuildArray(2, Vector3.Zero);\nBone._TmpQuat = Quaternion.Identity();\nBone._TmpMats = ArrayTools.BuildArray(5, Matrix.Identity);\n//# sourceMappingURL=bone.js.map","import { Vector3, Quaternion, Matrix } from \"../Maths/math.vector.js\";\nimport { Space } from \"../Maths/math.axis.js\";\nimport { Logger } from \"../Misc/logger.js\";\n/**\n * Class used to apply inverse kinematics to bones\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/bonesSkeletons#boneikcontroller\n */\nexport class BoneIKController {\n    /**\n     * Gets or sets maximum allowed angle\n     */\n    get maxAngle() {\n        return this._maxAngle;\n    }\n    set maxAngle(value) {\n        this._setMaxAngle(value);\n    }\n    /**\n     * Creates a new BoneIKController\n     * @param mesh defines the TransformNode to control\n     * @param bone defines the bone to control. The bone needs to have a parent bone. It also needs to have a length greater than 0 or a children we can use to infer its length.\n     * @param options defines options to set up the controller\n     * @param options.targetMesh\n     * @param options.poleTargetMesh\n     * @param options.poleTargetBone\n     * @param options.poleTargetLocalOffset\n     * @param options.poleAngle\n     * @param options.bendAxis\n     * @param options.maxAngle\n     * @param options.slerpAmount\n     */\n    constructor(mesh, bone, options) {\n        /**\n         * Gets or sets the target position\n         */\n        this.targetPosition = Vector3.Zero();\n        /**\n         * Gets or sets the pole target position\n         */\n        this.poleTargetPosition = Vector3.Zero();\n        /**\n         * Gets or sets the pole target local offset\n         */\n        this.poleTargetLocalOffset = Vector3.Zero();\n        /**\n         * Gets or sets the pole angle\n         */\n        this.poleAngle = 0;\n        /**\n         * The amount to slerp (spherical linear interpolation) to the target.  Set this to a value between 0 and 1 (a value of 1 disables slerp)\n         */\n        this.slerpAmount = 1;\n        this._bone1Quat = Quaternion.Identity();\n        this._bone1Mat = Matrix.Identity();\n        this._bone2Ang = Math.PI;\n        this._maxAngle = Math.PI;\n        this._rightHandedSystem = false;\n        this._bendAxis = Vector3.Right();\n        this._slerping = false;\n        this._adjustRoll = 0;\n        this._notEnoughInformation = false;\n        this._bone2 = bone;\n        const bone1 = bone.getParent();\n        if (!bone1) {\n            this._notEnoughInformation = true;\n            Logger.Error(\"BoneIKController: bone must have a parent for IK to work.\");\n            return;\n        }\n        this._bone1 = bone1;\n        if (this._bone2.children.length === 0 && !this._bone2.length) {\n            this._notEnoughInformation = true;\n            Logger.Error(\"BoneIKController: bone must not be a leaf or it should have a length for IK to work.\");\n            return;\n        }\n        this.mesh = mesh;\n        const bonePos = bone.getPosition();\n        if (bone.getAbsoluteTransform().determinant() > 0) {\n            this._rightHandedSystem = true;\n            this._bendAxis.x = 0;\n            this._bendAxis.y = 0;\n            this._bendAxis.z = -1;\n            if (bonePos.x > bonePos.y && bonePos.x > bonePos.z) {\n                this._adjustRoll = Math.PI * 0.5;\n                this._bendAxis.z = 1;\n            }\n        }\n        if (this._bone1.length && this._bone2.length) {\n            const boneScale1 = this._bone1.getScale();\n            const boneScale2 = this._bone2.getScale();\n            this._bone1Length = this._bone1.length * boneScale1.y * this.mesh.scaling.y;\n            this._bone2Length = this._bone2.length * boneScale2.y * this.mesh.scaling.y;\n        }\n        else if (this._bone2.children[0]) {\n            mesh.computeWorldMatrix(true);\n            const pos1 = this._bone2.children[0].getAbsolutePosition(mesh);\n            const pos2 = this._bone2.getAbsolutePosition(mesh);\n            const pos3 = this._bone1.getAbsolutePosition(mesh);\n            this._bone2Length = Vector3.Distance(pos1, pos2);\n            this._bone1Length = Vector3.Distance(pos2, pos3);\n        }\n        else {\n            mesh.computeWorldMatrix(true);\n            const boneScale2 = this._bone2.getScale();\n            this._bone2Length = this._bone2.length * boneScale2.y * this.mesh.scaling.y;\n            const pos2 = this._bone2.getAbsolutePosition(mesh);\n            const pos3 = this._bone1.getAbsolutePosition(mesh);\n            this._bone1Length = Vector3.Distance(pos2, pos3);\n        }\n        this._bone1.getRotationMatrixToRef(Space.WORLD, mesh, this._bone1Mat);\n        this.maxAngle = Math.PI;\n        if (options) {\n            if (options.targetMesh) {\n                this.targetMesh = options.targetMesh;\n                this.targetMesh.computeWorldMatrix(true);\n            }\n            if (options.poleTargetMesh) {\n                this.poleTargetMesh = options.poleTargetMesh;\n                this.poleTargetMesh.computeWorldMatrix(true);\n            }\n            else if (options.poleTargetBone) {\n                this.poleTargetBone = options.poleTargetBone;\n            }\n            else if (this._bone1.getParent()) {\n                this.poleTargetBone = this._bone1.getParent();\n            }\n            if (options.poleTargetLocalOffset) {\n                this.poleTargetLocalOffset.copyFrom(options.poleTargetLocalOffset);\n            }\n            if (options.poleAngle) {\n                this.poleAngle = options.poleAngle;\n            }\n            if (options.bendAxis) {\n                this._bendAxis.copyFrom(options.bendAxis);\n            }\n            if (options.maxAngle) {\n                this.maxAngle = options.maxAngle;\n            }\n            if (options.slerpAmount) {\n                this.slerpAmount = options.slerpAmount;\n            }\n        }\n    }\n    _setMaxAngle(ang) {\n        if (ang < 0) {\n            ang = 0;\n        }\n        if (ang > Math.PI || ang == undefined) {\n            ang = Math.PI;\n        }\n        this._maxAngle = ang;\n        const a = this._bone1Length;\n        const b = this._bone2Length;\n        this._maxReach = Math.sqrt(a * a + b * b - 2 * a * b * Math.cos(ang));\n    }\n    /**\n     * Force the controller to update the bones\n     */\n    update() {\n        if (this._notEnoughInformation) {\n            return;\n        }\n        const target = this.targetPosition;\n        const poleTarget = this.poleTargetPosition;\n        const mat1 = BoneIKController._TmpMats[0];\n        const mat2 = BoneIKController._TmpMats[1];\n        if (this.targetMesh) {\n            target.copyFrom(this.targetMesh.getAbsolutePosition());\n        }\n        if (this.poleTargetBone) {\n            this.poleTargetBone.getAbsolutePositionFromLocalToRef(this.poleTargetLocalOffset, this.mesh, poleTarget);\n        }\n        else if (this.poleTargetMesh) {\n            Vector3.TransformCoordinatesToRef(this.poleTargetLocalOffset, this.poleTargetMesh.getWorldMatrix(), poleTarget);\n        }\n        const bonePos = BoneIKController._TmpVecs[0];\n        const zaxis = BoneIKController._TmpVecs[1];\n        const xaxis = BoneIKController._TmpVecs[2];\n        const yaxis = BoneIKController._TmpVecs[3];\n        const upAxis = BoneIKController._TmpVecs[4];\n        const tmpQuat = BoneIKController._TmpQuat;\n        this._bone1.getAbsolutePositionToRef(this.mesh, bonePos);\n        poleTarget.subtractToRef(bonePos, upAxis);\n        if (upAxis.x == 0 && upAxis.y == 0 && upAxis.z == 0) {\n            upAxis.y = 1;\n        }\n        else {\n            upAxis.normalize();\n        }\n        target.subtractToRef(bonePos, yaxis);\n        yaxis.normalize();\n        Vector3.CrossToRef(yaxis, upAxis, zaxis);\n        zaxis.normalize();\n        Vector3.CrossToRef(yaxis, zaxis, xaxis);\n        xaxis.normalize();\n        Matrix.FromXYZAxesToRef(xaxis, yaxis, zaxis, mat1);\n        const a = this._bone1Length;\n        const b = this._bone2Length;\n        let c = Vector3.Distance(bonePos, target);\n        if (this._maxReach > 0) {\n            c = Math.min(this._maxReach, c);\n        }\n        let acosa = (b * b + c * c - a * a) / (2 * b * c);\n        let acosb = (c * c + a * a - b * b) / (2 * c * a);\n        if (acosa > 1) {\n            acosa = 1;\n        }\n        if (acosb > 1) {\n            acosb = 1;\n        }\n        if (acosa < -1) {\n            acosa = -1;\n        }\n        if (acosb < -1) {\n            acosb = -1;\n        }\n        const angA = Math.acos(acosa);\n        const angB = Math.acos(acosb);\n        let angC = -angA - angB;\n        if (this._rightHandedSystem) {\n            Matrix.RotationYawPitchRollToRef(0, 0, this._adjustRoll, mat2);\n            mat2.multiplyToRef(mat1, mat1);\n            Matrix.RotationAxisToRef(this._bendAxis, angB, mat2);\n            mat2.multiplyToRef(mat1, mat1);\n        }\n        else {\n            const _tmpVec = BoneIKController._TmpVecs[5];\n            _tmpVec.copyFrom(this._bendAxis);\n            _tmpVec.x *= -1;\n            Matrix.RotationAxisToRef(_tmpVec, -angB, mat2);\n            mat2.multiplyToRef(mat1, mat1);\n        }\n        if (this.poleAngle) {\n            Matrix.RotationAxisToRef(yaxis, this.poleAngle, mat2);\n            mat1.multiplyToRef(mat2, mat1);\n        }\n        if (this._bone1) {\n            if (this.slerpAmount < 1) {\n                if (!this._slerping) {\n                    Quaternion.FromRotationMatrixToRef(this._bone1Mat, this._bone1Quat);\n                }\n                Quaternion.FromRotationMatrixToRef(mat1, tmpQuat);\n                Quaternion.SlerpToRef(this._bone1Quat, tmpQuat, this.slerpAmount, this._bone1Quat);\n                angC = this._bone2Ang * (1.0 - this.slerpAmount) + angC * this.slerpAmount;\n                this._bone1.setRotationQuaternion(this._bone1Quat, Space.WORLD, this.mesh);\n                this._slerping = true;\n            }\n            else {\n                this._bone1.setRotationMatrix(mat1, Space.WORLD, this.mesh);\n                this._bone1Mat.copyFrom(mat1);\n                this._slerping = false;\n            }\n            this._updateLinkedTransformRotation(this._bone1);\n        }\n        this._bone2.setAxisAngle(this._bendAxis, angC, Space.LOCAL);\n        this._updateLinkedTransformRotation(this._bone2);\n        this._bone2Ang = angC;\n    }\n    _updateLinkedTransformRotation(bone) {\n        if (bone._linkedTransformNode) {\n            if (!bone._linkedTransformNode.rotationQuaternion) {\n                bone._linkedTransformNode.rotationQuaternion = new Quaternion();\n            }\n            bone.getRotationQuaternionToRef(Space.LOCAL, null, bone._linkedTransformNode.rotationQuaternion);\n        }\n    }\n}\nBoneIKController._TmpVecs = [Vector3.Zero(), Vector3.Zero(), Vector3.Zero(), Vector3.Zero(), Vector3.Zero(), Vector3.Zero()];\nBoneIKController._TmpQuat = Quaternion.Identity();\nBoneIKController._TmpMats = [Matrix.Identity(), Matrix.Identity()];\n//# sourceMappingURL=boneIKController.js.map","import { ArrayTools } from \"../Misc/arrayTools.js\";\nimport { Vector3, Quaternion, Matrix } from \"../Maths/math.vector.js\";\nimport { Space, Axis } from \"../Maths/math.axis.js\";\n/**\n * Class used to make a bone look toward a point in space\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/bonesSkeletons#bonelookcontroller\n */\nexport class BoneLookController {\n    /**\n     * Gets or sets the minimum yaw angle that the bone can look to\n     */\n    get minYaw() {\n        return this._minYaw;\n    }\n    set minYaw(value) {\n        this._minYaw = value;\n        this._minYawSin = Math.sin(value);\n        this._minYawCos = Math.cos(value);\n        if (this._maxYaw != null) {\n            this._midYawConstraint = this._getAngleDiff(this._minYaw, this._maxYaw) * 0.5 + this._minYaw;\n            this._yawRange = this._maxYaw - this._minYaw;\n        }\n    }\n    /**\n     * Gets or sets the maximum yaw angle that the bone can look to\n     */\n    get maxYaw() {\n        return this._maxYaw;\n    }\n    set maxYaw(value) {\n        this._maxYaw = value;\n        this._maxYawSin = Math.sin(value);\n        this._maxYawCos = Math.cos(value);\n        if (this._minYaw != null) {\n            this._midYawConstraint = this._getAngleDiff(this._minYaw, this._maxYaw) * 0.5 + this._minYaw;\n            this._yawRange = this._maxYaw - this._minYaw;\n        }\n    }\n    /**\n     * Gets or sets the minimum pitch angle that the bone can look to\n     */\n    get minPitch() {\n        return this._minPitch;\n    }\n    set minPitch(value) {\n        this._minPitch = value;\n        this._minPitchTan = Math.tan(value);\n    }\n    /**\n     * Gets or sets the maximum pitch angle that the bone can look to\n     */\n    get maxPitch() {\n        return this._maxPitch;\n    }\n    set maxPitch(value) {\n        this._maxPitch = value;\n        this._maxPitchTan = Math.tan(value);\n    }\n    /**\n     * Create a BoneLookController\n     * @param mesh the TransformNode that the bone belongs to\n     * @param bone the bone that will be looking to the target\n     * @param target the target Vector3 to look at\n     * @param options optional settings:\n     * * maxYaw: the maximum angle the bone will yaw to\n     * * minYaw: the minimum angle the bone will yaw to\n     * * maxPitch: the maximum angle the bone will pitch to\n     * * minPitch: the minimum angle the bone will yaw to\n     * * slerpAmount: set the between 0 and 1 to make the bone slerp to the target.\n     * * upAxis: the up axis of the coordinate system\n     * * upAxisSpace: the space that the up axis is in - Space.BONE, Space.LOCAL (default), or Space.WORLD.\n     * * yawAxis: set yawAxis if the bone does not yaw on the y axis\n     * * pitchAxis: set pitchAxis if the bone does not pitch on the x axis\n     * * adjustYaw: used to make an adjustment to the yaw of the bone\n     * * adjustPitch: used to make an adjustment to the pitch of the bone\n     * * adjustRoll: used to make an adjustment to the roll of the bone\n     * @param options.maxYaw\n     * @param options.minYaw\n     * @param options.maxPitch\n     * @param options.minPitch\n     * @param options.slerpAmount\n     * @param options.upAxis\n     * @param options.upAxisSpace\n     * @param options.yawAxis\n     * @param options.pitchAxis\n     * @param options.adjustYaw\n     * @param options.adjustPitch\n     * @param options.adjustRoll\n     **/\n    constructor(mesh, bone, target, options) {\n        /**\n         * The up axis of the coordinate system that is used when the bone is rotated\n         */\n        this.upAxis = Vector3.Up();\n        /**\n         * The space that the up axis is in - Space.BONE, Space.LOCAL (default), or Space.WORLD\n         */\n        this.upAxisSpace = Space.LOCAL;\n        /**\n         * Used to make an adjustment to the yaw of the bone\n         */\n        this.adjustYaw = 0;\n        /**\n         * Used to make an adjustment to the pitch of the bone\n         */\n        this.adjustPitch = 0;\n        /**\n         * Used to make an adjustment to the roll of the bone\n         */\n        this.adjustRoll = 0;\n        /**\n         * The amount to slerp (spherical linear interpolation) to the target.  Set this to a value between 0 and 1 (a value of 1 disables slerp)\n         */\n        this.slerpAmount = 1;\n        this._boneQuat = Quaternion.Identity();\n        this._slerping = false;\n        this._firstFrameSkipped = false;\n        this._fowardAxis = Vector3.Forward();\n        this.mesh = mesh;\n        this.bone = bone;\n        this.target = target;\n        if (options) {\n            if (options.adjustYaw) {\n                this.adjustYaw = options.adjustYaw;\n            }\n            if (options.adjustPitch) {\n                this.adjustPitch = options.adjustPitch;\n            }\n            if (options.adjustRoll) {\n                this.adjustRoll = options.adjustRoll;\n            }\n            if (options.maxYaw != null) {\n                this.maxYaw = options.maxYaw;\n            }\n            else {\n                this.maxYaw = Math.PI;\n            }\n            if (options.minYaw != null) {\n                this.minYaw = options.minYaw;\n            }\n            else {\n                this.minYaw = -Math.PI;\n            }\n            if (options.maxPitch != null) {\n                this.maxPitch = options.maxPitch;\n            }\n            else {\n                this.maxPitch = Math.PI;\n            }\n            if (options.minPitch != null) {\n                this.minPitch = options.minPitch;\n            }\n            else {\n                this.minPitch = -Math.PI;\n            }\n            if (options.slerpAmount != null) {\n                this.slerpAmount = options.slerpAmount;\n            }\n            if (options.upAxis != null) {\n                this.upAxis = options.upAxis;\n            }\n            if (options.upAxisSpace != null) {\n                this.upAxisSpace = options.upAxisSpace;\n            }\n            if (options.yawAxis != null || options.pitchAxis != null) {\n                let newYawAxis = Axis.Y;\n                let newPitchAxis = Axis.X;\n                if (options.yawAxis != null) {\n                    newYawAxis = options.yawAxis.clone();\n                    newYawAxis.normalize();\n                }\n                if (options.pitchAxis != null) {\n                    newPitchAxis = options.pitchAxis.clone();\n                    newPitchAxis.normalize();\n                }\n                const newRollAxis = Vector3.Cross(newPitchAxis, newYawAxis);\n                this._transformYawPitch = Matrix.Identity();\n                Matrix.FromXYZAxesToRef(newPitchAxis, newYawAxis, newRollAxis, this._transformYawPitch);\n                this._transformYawPitchInv = this._transformYawPitch.clone();\n                this._transformYawPitch.invert();\n            }\n        }\n        if (!bone.getParent() && this.upAxisSpace == Space.BONE) {\n            this.upAxisSpace = Space.LOCAL;\n        }\n    }\n    /**\n     * Update the bone to look at the target.  This should be called before the scene is rendered (use scene.registerBeforeRender())\n     */\n    update() {\n        //skip the first frame when slerping so that the TransformNode rotation is correct\n        if (this.slerpAmount < 1 && !this._firstFrameSkipped) {\n            this._firstFrameSkipped = true;\n            return;\n        }\n        const bone = this.bone;\n        const bonePos = BoneLookController._TmpVecs[0];\n        bone.getAbsolutePositionToRef(this.mesh, bonePos);\n        let target = this.target;\n        const _tmpMat1 = BoneLookController._TmpMats[0];\n        const _tmpMat2 = BoneLookController._TmpMats[1];\n        const mesh = this.mesh;\n        const parentBone = bone.getParent();\n        const upAxis = BoneLookController._TmpVecs[1];\n        upAxis.copyFrom(this.upAxis);\n        if (this.upAxisSpace == Space.BONE && parentBone) {\n            if (this._transformYawPitch) {\n                Vector3.TransformCoordinatesToRef(upAxis, this._transformYawPitchInv, upAxis);\n            }\n            parentBone.getDirectionToRef(upAxis, this.mesh, upAxis);\n        }\n        else if (this.upAxisSpace == Space.LOCAL) {\n            mesh.getDirectionToRef(upAxis, upAxis);\n            if (mesh.scaling.x != 1 || mesh.scaling.y != 1 || mesh.scaling.z != 1) {\n                upAxis.normalize();\n            }\n        }\n        let checkYaw = false;\n        let checkPitch = false;\n        if (this._maxYaw != Math.PI || this._minYaw != -Math.PI) {\n            checkYaw = true;\n        }\n        if (this._maxPitch != Math.PI || this._minPitch != -Math.PI) {\n            checkPitch = true;\n        }\n        if (checkYaw || checkPitch) {\n            const spaceMat = BoneLookController._TmpMats[2];\n            const spaceMatInv = BoneLookController._TmpMats[3];\n            if (this.upAxisSpace == Space.BONE && upAxis.y == 1 && parentBone) {\n                parentBone.getRotationMatrixToRef(Space.WORLD, this.mesh, spaceMat);\n            }\n            else if (this.upAxisSpace == Space.LOCAL && upAxis.y == 1 && !parentBone) {\n                spaceMat.copyFrom(mesh.getWorldMatrix());\n            }\n            else {\n                let forwardAxis = BoneLookController._TmpVecs[2];\n                forwardAxis.copyFrom(this._fowardAxis);\n                if (this._transformYawPitch) {\n                    Vector3.TransformCoordinatesToRef(forwardAxis, this._transformYawPitchInv, forwardAxis);\n                }\n                if (parentBone) {\n                    parentBone.getDirectionToRef(forwardAxis, this.mesh, forwardAxis);\n                }\n                else {\n                    mesh.getDirectionToRef(forwardAxis, forwardAxis);\n                }\n                const rightAxis = Vector3.Cross(upAxis, forwardAxis);\n                rightAxis.normalize();\n                forwardAxis = Vector3.Cross(rightAxis, upAxis);\n                Matrix.FromXYZAxesToRef(rightAxis, upAxis, forwardAxis, spaceMat);\n            }\n            spaceMat.invertToRef(spaceMatInv);\n            let xzlen = null;\n            if (checkPitch) {\n                const localTarget = BoneLookController._TmpVecs[3];\n                target.subtractToRef(bonePos, localTarget);\n                Vector3.TransformCoordinatesToRef(localTarget, spaceMatInv, localTarget);\n                xzlen = Math.sqrt(localTarget.x * localTarget.x + localTarget.z * localTarget.z);\n                const pitch = Math.atan2(localTarget.y, xzlen);\n                let newPitch = pitch;\n                if (pitch > this._maxPitch) {\n                    localTarget.y = this._maxPitchTan * xzlen;\n                    newPitch = this._maxPitch;\n                }\n                else if (pitch < this._minPitch) {\n                    localTarget.y = this._minPitchTan * xzlen;\n                    newPitch = this._minPitch;\n                }\n                if (pitch != newPitch) {\n                    Vector3.TransformCoordinatesToRef(localTarget, spaceMat, localTarget);\n                    localTarget.addInPlace(bonePos);\n                    target = localTarget;\n                }\n            }\n            if (checkYaw) {\n                const localTarget = BoneLookController._TmpVecs[4];\n                target.subtractToRef(bonePos, localTarget);\n                Vector3.TransformCoordinatesToRef(localTarget, spaceMatInv, localTarget);\n                const yaw = Math.atan2(localTarget.x, localTarget.z);\n                let newYaw = yaw;\n                if (yaw > this._maxYaw || yaw < this._minYaw) {\n                    if (xzlen == null) {\n                        xzlen = Math.sqrt(localTarget.x * localTarget.x + localTarget.z * localTarget.z);\n                    }\n                    if (this._yawRange > Math.PI) {\n                        if (this._isAngleBetween(yaw, this._maxYaw, this._midYawConstraint)) {\n                            localTarget.z = this._maxYawCos * xzlen;\n                            localTarget.x = this._maxYawSin * xzlen;\n                            newYaw = this._maxYaw;\n                        }\n                        else if (this._isAngleBetween(yaw, this._midYawConstraint, this._minYaw)) {\n                            localTarget.z = this._minYawCos * xzlen;\n                            localTarget.x = this._minYawSin * xzlen;\n                            newYaw = this._minYaw;\n                        }\n                    }\n                    else {\n                        if (yaw > this._maxYaw) {\n                            localTarget.z = this._maxYawCos * xzlen;\n                            localTarget.x = this._maxYawSin * xzlen;\n                            newYaw = this._maxYaw;\n                        }\n                        else if (yaw < this._minYaw) {\n                            localTarget.z = this._minYawCos * xzlen;\n                            localTarget.x = this._minYawSin * xzlen;\n                            newYaw = this._minYaw;\n                        }\n                    }\n                }\n                if (this._slerping && this._yawRange > Math.PI) {\n                    //are we going to be crossing into the min/max region?\n                    const boneFwd = BoneLookController._TmpVecs[8];\n                    boneFwd.copyFrom(Axis.Z);\n                    if (this._transformYawPitch) {\n                        Vector3.TransformCoordinatesToRef(boneFwd, this._transformYawPitchInv, boneFwd);\n                    }\n                    const boneRotMat = BoneLookController._TmpMats[4];\n                    this._boneQuat.toRotationMatrix(boneRotMat);\n                    this.mesh.getWorldMatrix().multiplyToRef(boneRotMat, boneRotMat);\n                    Vector3.TransformCoordinatesToRef(boneFwd, boneRotMat, boneFwd);\n                    Vector3.TransformCoordinatesToRef(boneFwd, spaceMatInv, boneFwd);\n                    const boneYaw = Math.atan2(boneFwd.x, boneFwd.z);\n                    const angBtwTar = this._getAngleBetween(boneYaw, yaw);\n                    const angBtwMidYaw = this._getAngleBetween(boneYaw, this._midYawConstraint);\n                    if (angBtwTar > angBtwMidYaw) {\n                        if (xzlen == null) {\n                            xzlen = Math.sqrt(localTarget.x * localTarget.x + localTarget.z * localTarget.z);\n                        }\n                        const angBtwMax = this._getAngleBetween(boneYaw, this._maxYaw);\n                        const angBtwMin = this._getAngleBetween(boneYaw, this._minYaw);\n                        if (angBtwMin < angBtwMax) {\n                            newYaw = boneYaw + Math.PI * 0.75;\n                            localTarget.z = Math.cos(newYaw) * xzlen;\n                            localTarget.x = Math.sin(newYaw) * xzlen;\n                        }\n                        else {\n                            newYaw = boneYaw - Math.PI * 0.75;\n                            localTarget.z = Math.cos(newYaw) * xzlen;\n                            localTarget.x = Math.sin(newYaw) * xzlen;\n                        }\n                    }\n                }\n                if (yaw != newYaw) {\n                    Vector3.TransformCoordinatesToRef(localTarget, spaceMat, localTarget);\n                    localTarget.addInPlace(bonePos);\n                    target = localTarget;\n                }\n            }\n        }\n        const zaxis = BoneLookController._TmpVecs[5];\n        const xaxis = BoneLookController._TmpVecs[6];\n        const yaxis = BoneLookController._TmpVecs[7];\n        const tmpQuat = BoneLookController._TmpQuat;\n        target.subtractToRef(bonePos, zaxis);\n        zaxis.normalize();\n        Vector3.CrossToRef(upAxis, zaxis, xaxis);\n        xaxis.normalize();\n        Vector3.CrossToRef(zaxis, xaxis, yaxis);\n        yaxis.normalize();\n        Matrix.FromXYZAxesToRef(xaxis, yaxis, zaxis, _tmpMat1);\n        if (xaxis.x === 0 && xaxis.y === 0 && xaxis.z === 0) {\n            return;\n        }\n        if (yaxis.x === 0 && yaxis.y === 0 && yaxis.z === 0) {\n            return;\n        }\n        if (zaxis.x === 0 && zaxis.y === 0 && zaxis.z === 0) {\n            return;\n        }\n        if (this.adjustYaw || this.adjustPitch || this.adjustRoll) {\n            Matrix.RotationYawPitchRollToRef(this.adjustYaw, this.adjustPitch, this.adjustRoll, _tmpMat2);\n            _tmpMat2.multiplyToRef(_tmpMat1, _tmpMat1);\n        }\n        if (this.slerpAmount < 1) {\n            if (!this._slerping) {\n                this.bone.getRotationQuaternionToRef(Space.WORLD, this.mesh, this._boneQuat);\n            }\n            if (this._transformYawPitch) {\n                this._transformYawPitch.multiplyToRef(_tmpMat1, _tmpMat1);\n            }\n            Quaternion.FromRotationMatrixToRef(_tmpMat1, tmpQuat);\n            Quaternion.SlerpToRef(this._boneQuat, tmpQuat, this.slerpAmount, this._boneQuat);\n            this.bone.setRotationQuaternion(this._boneQuat, Space.WORLD, this.mesh);\n            this._slerping = true;\n        }\n        else {\n            if (this._transformYawPitch) {\n                this._transformYawPitch.multiplyToRef(_tmpMat1, _tmpMat1);\n            }\n            this.bone.setRotationMatrix(_tmpMat1, Space.WORLD, this.mesh);\n            this._slerping = false;\n        }\n        this._updateLinkedTransformRotation();\n    }\n    _getAngleDiff(ang1, ang2) {\n        let angDiff = ang2 - ang1;\n        angDiff %= Math.PI * 2;\n        if (angDiff > Math.PI) {\n            angDiff -= Math.PI * 2;\n        }\n        else if (angDiff < -Math.PI) {\n            angDiff += Math.PI * 2;\n        }\n        return angDiff;\n    }\n    _getAngleBetween(ang1, ang2) {\n        ang1 %= 2 * Math.PI;\n        ang1 = ang1 < 0 ? ang1 + 2 * Math.PI : ang1;\n        ang2 %= 2 * Math.PI;\n        ang2 = ang2 < 0 ? ang2 + 2 * Math.PI : ang2;\n        let ab = 0;\n        if (ang1 < ang2) {\n            ab = ang2 - ang1;\n        }\n        else {\n            ab = ang1 - ang2;\n        }\n        if (ab > Math.PI) {\n            ab = Math.PI * 2 - ab;\n        }\n        return ab;\n    }\n    _isAngleBetween(ang, ang1, ang2) {\n        ang %= 2 * Math.PI;\n        ang = ang < 0 ? ang + 2 * Math.PI : ang;\n        ang1 %= 2 * Math.PI;\n        ang1 = ang1 < 0 ? ang1 + 2 * Math.PI : ang1;\n        ang2 %= 2 * Math.PI;\n        ang2 = ang2 < 0 ? ang2 + 2 * Math.PI : ang2;\n        if (ang1 < ang2) {\n            if (ang > ang1 && ang < ang2) {\n                return true;\n            }\n        }\n        else {\n            if (ang > ang2 && ang < ang1) {\n                return true;\n            }\n        }\n        return false;\n    }\n    _updateLinkedTransformRotation() {\n        const bone = this.bone;\n        if (bone._linkedTransformNode) {\n            if (!bone._linkedTransformNode.rotationQuaternion) {\n                bone._linkedTransformNode.rotationQuaternion = new Quaternion();\n            }\n            bone.getRotationQuaternionToRef(Space.LOCAL, null, bone._linkedTransformNode.rotationQuaternion);\n        }\n    }\n}\nBoneLookController._TmpVecs = ArrayTools.BuildArray(10, Vector3.Zero);\nBoneLookController._TmpQuat = Quaternion.Identity();\nBoneLookController._TmpMats = ArrayTools.BuildArray(5, Matrix.Identity);\n//# sourceMappingURL=boneLookController.js.map","import { Bone } from \"./bone.js\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { Vector3, Matrix, TmpVectors } from \"../Maths/math.vector.js\";\nimport { RawTexture } from \"../Materials/Textures/rawTexture.js\";\nimport { Animation } from \"../Animations/animation.js\";\nimport { AnimationRange } from \"../Animations/animationRange.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\n\nimport { Logger } from \"../Misc/logger.js\";\nimport { DeepCopier } from \"../Misc/deepCopier.js\";\n/**\n * Class used to handle skinning animations\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/bonesSkeletons\n */\nexport class Skeleton {\n    /**\n     * Gets or sets a boolean indicating that bone matrices should be stored as a texture instead of using shader uniforms (default is true).\n     * Please note that this option is not available if the hardware does not support it\n     */\n    get useTextureToStoreBoneMatrices() {\n        return this._useTextureToStoreBoneMatrices;\n    }\n    set useTextureToStoreBoneMatrices(value) {\n        this._useTextureToStoreBoneMatrices = value;\n        this._markAsDirty();\n    }\n    /**\n     * Gets or sets the animation properties override\n     */\n    get animationPropertiesOverride() {\n        if (!this._animationPropertiesOverride) {\n            return this._scene.animationPropertiesOverride;\n        }\n        return this._animationPropertiesOverride;\n    }\n    set animationPropertiesOverride(value) {\n        this._animationPropertiesOverride = value;\n    }\n    /**\n     * Gets a boolean indicating that the skeleton effectively stores matrices into a texture\n     */\n    get isUsingTextureForMatrices() {\n        return this.useTextureToStoreBoneMatrices && this._canUseTextureForBones;\n    }\n    /**\n     * Gets the unique ID of this skeleton\n     */\n    get uniqueId() {\n        return this._uniqueId;\n    }\n    /**\n     * Creates a new skeleton\n     * @param name defines the skeleton name\n     * @param id defines the skeleton Id\n     * @param scene defines the hosting scene\n     */\n    constructor(\n    /** defines the skeleton name */\n    name, \n    /** defines the skeleton Id */\n    id, scene) {\n        this.name = name;\n        this.id = id;\n        /**\n         * Defines the list of child bones\n         */\n        this.bones = new Array();\n        /**\n         * Defines a boolean indicating if the root matrix is provided by meshes or by the current skeleton (this is the default value)\n         */\n        this.needInitialSkinMatrix = false;\n        this._isDirty = true;\n        this._meshesWithPoseMatrix = new Array();\n        this._identity = Matrix.Identity();\n        this._ranges = {};\n        this._absoluteTransformIsDirty = true;\n        this._canUseTextureForBones = false;\n        this._uniqueId = 0;\n        /** @internal */\n        this._numBonesWithLinkedTransformNode = 0;\n        /** @internal */\n        this._hasWaitingData = null;\n        /** @internal */\n        this._parentContainer = null;\n        /**\n         * Specifies if the skeleton should be serialized\n         */\n        this.doNotSerialize = false;\n        this._useTextureToStoreBoneMatrices = true;\n        this._animationPropertiesOverride = null;\n        // Events\n        /**\n         * An observable triggered before computing the skeleton's matrices\n         */\n        this.onBeforeComputeObservable = new Observable();\n        this.bones = [];\n        this._scene = scene || EngineStore.LastCreatedScene;\n        this._uniqueId = this._scene.getUniqueId();\n        this._scene.addSkeleton(this);\n        //make sure it will recalculate the matrix next time prepare is called.\n        this._isDirty = true;\n        const engineCaps = this._scene.getEngine().getCaps();\n        this._canUseTextureForBones = engineCaps.textureFloat && engineCaps.maxVertexTextureImageUnits > 0;\n    }\n    /**\n     * Gets the current object class name.\n     * @returns the class name\n     */\n    getClassName() {\n        return \"Skeleton\";\n    }\n    /**\n     * Returns an array containing the root bones\n     * @returns an array containing the root bones\n     */\n    getChildren() {\n        return this.bones.filter((b) => !b.getParent());\n    }\n    // Members\n    /**\n     * Gets the list of transform matrices to send to shaders (one matrix per bone)\n     * @param mesh defines the mesh to use to get the root matrix (if needInitialSkinMatrix === true)\n     * @returns a Float32Array containing matrices data\n     */\n    getTransformMatrices(mesh) {\n        if (this.needInitialSkinMatrix) {\n            if (!mesh._bonesTransformMatrices) {\n                this.prepare();\n            }\n            return mesh._bonesTransformMatrices;\n        }\n        if (!this._transformMatrices) {\n            this.prepare();\n        }\n        return this._transformMatrices;\n    }\n    /**\n     * Gets the list of transform matrices to send to shaders inside a texture (one matrix per bone)\n     * @param mesh defines the mesh to use to get the root matrix (if needInitialSkinMatrix === true)\n     * @returns a raw texture containing the data\n     */\n    getTransformMatrixTexture(mesh) {\n        if (this.needInitialSkinMatrix && mesh._transformMatrixTexture) {\n            return mesh._transformMatrixTexture;\n        }\n        return this._transformMatrixTexture;\n    }\n    /**\n     * Gets the current hosting scene\n     * @returns a scene object\n     */\n    getScene() {\n        return this._scene;\n    }\n    // Methods\n    /**\n     * Gets a string representing the current skeleton data\n     * @param fullDetails defines a boolean indicating if we want a verbose version\n     * @returns a string representing the current skeleton data\n     */\n    toString(fullDetails) {\n        let ret = `Name: ${this.name}, nBones: ${this.bones.length}`;\n        ret += `, nAnimationRanges: ${this._ranges ? Object.keys(this._ranges).length : \"none\"}`;\n        if (fullDetails) {\n            ret += \", Ranges: {\";\n            let first = true;\n            for (const name in this._ranges) {\n                if (first) {\n                    ret += \", \";\n                    first = false;\n                }\n                ret += name;\n            }\n            ret += \"}\";\n        }\n        return ret;\n    }\n    /**\n     * Get bone's index searching by name\n     * @param name defines bone's name to search for\n     * @returns the indice of the bone. Returns -1 if not found\n     */\n    getBoneIndexByName(name) {\n        for (let boneIndex = 0, cache = this.bones.length; boneIndex < cache; boneIndex++) {\n            if (this.bones[boneIndex].name === name) {\n                return boneIndex;\n            }\n        }\n        return -1;\n    }\n    /**\n     * Create a new animation range\n     * @param name defines the name of the range\n     * @param from defines the start key\n     * @param to defines the end key\n     */\n    createAnimationRange(name, from, to) {\n        // check name not already in use\n        if (!this._ranges[name]) {\n            this._ranges[name] = new AnimationRange(name, from, to);\n            for (let i = 0, nBones = this.bones.length; i < nBones; i++) {\n                if (this.bones[i].animations[0]) {\n                    this.bones[i].animations[0].createRange(name, from, to);\n                }\n            }\n        }\n    }\n    /**\n     * Delete a specific animation range\n     * @param name defines the name of the range\n     * @param deleteFrames defines if frames must be removed as well\n     */\n    deleteAnimationRange(name, deleteFrames = true) {\n        for (let i = 0, nBones = this.bones.length; i < nBones; i++) {\n            if (this.bones[i].animations[0]) {\n                this.bones[i].animations[0].deleteRange(name, deleteFrames);\n            }\n        }\n        this._ranges[name] = null; // said much faster than 'delete this._range[name]'\n    }\n    /**\n     * Gets a specific animation range\n     * @param name defines the name of the range to look for\n     * @returns the requested animation range or null if not found\n     */\n    getAnimationRange(name) {\n        return this._ranges[name] || null;\n    }\n    /**\n     * Gets the list of all animation ranges defined on this skeleton\n     * @returns an array\n     */\n    getAnimationRanges() {\n        const animationRanges = [];\n        let name;\n        for (name in this._ranges) {\n            animationRanges.push(this._ranges[name]);\n        }\n        return animationRanges;\n    }\n    /**\n     * Copy animation range from a source skeleton.\n     * This is not for a complete retargeting, only between very similar skeleton's with only possible bone length differences\n     * @param source defines the source skeleton\n     * @param name defines the name of the range to copy\n     * @param rescaleAsRequired defines if rescaling must be applied if required\n     * @returns true if operation was successful\n     */\n    copyAnimationRange(source, name, rescaleAsRequired = false) {\n        if (this._ranges[name] || !source.getAnimationRange(name)) {\n            return false;\n        }\n        let ret = true;\n        const frameOffset = this._getHighestAnimationFrame() + 1;\n        // make a dictionary of source skeleton's bones, so exact same order or doubly nested loop is not required\n        const boneDict = {};\n        const sourceBones = source.bones;\n        let nBones;\n        let i;\n        for (i = 0, nBones = sourceBones.length; i < nBones; i++) {\n            boneDict[sourceBones[i].name] = sourceBones[i];\n        }\n        if (this.bones.length !== sourceBones.length) {\n            Logger.Warn(`copyAnimationRange: this rig has ${this.bones.length} bones, while source as ${sourceBones.length}`);\n            ret = false;\n        }\n        const skelDimensionsRatio = rescaleAsRequired && this.dimensionsAtRest && source.dimensionsAtRest ? this.dimensionsAtRest.divide(source.dimensionsAtRest) : null;\n        for (i = 0, nBones = this.bones.length; i < nBones; i++) {\n            const boneName = this.bones[i].name;\n            const sourceBone = boneDict[boneName];\n            if (sourceBone) {\n                ret = ret && this.bones[i].copyAnimationRange(sourceBone, name, frameOffset, rescaleAsRequired, skelDimensionsRatio);\n            }\n            else {\n                Logger.Warn(\"copyAnimationRange: not same rig, missing source bone \" + boneName);\n                ret = false;\n            }\n        }\n        // do not call createAnimationRange(), since it also is done to bones, which was already done\n        const range = source.getAnimationRange(name);\n        if (range) {\n            this._ranges[name] = new AnimationRange(name, range.from + frameOffset, range.to + frameOffset);\n        }\n        return ret;\n    }\n    /**\n     * Forces the skeleton to go to rest pose\n     */\n    returnToRest() {\n        for (const bone of this.bones) {\n            if (bone._index !== -1) {\n                bone.returnToRest();\n            }\n        }\n    }\n    _getHighestAnimationFrame() {\n        let ret = 0;\n        for (let i = 0, nBones = this.bones.length; i < nBones; i++) {\n            if (this.bones[i].animations[0]) {\n                const highest = this.bones[i].animations[0].getHighestFrame();\n                if (ret < highest) {\n                    ret = highest;\n                }\n            }\n        }\n        return ret;\n    }\n    /**\n     * Begin a specific animation range\n     * @param name defines the name of the range to start\n     * @param loop defines if looping must be turned on (false by default)\n     * @param speedRatio defines the speed ratio to apply (1 by default)\n     * @param onAnimationEnd defines a callback which will be called when animation will end\n     * @returns a new animatable\n     */\n    beginAnimation(name, loop, speedRatio, onAnimationEnd) {\n        const range = this.getAnimationRange(name);\n        if (!range) {\n            return null;\n        }\n        return this._scene.beginAnimation(this, range.from, range.to, loop, speedRatio, onAnimationEnd);\n    }\n    /**\n     * Convert the keyframes for a range of animation on a skeleton to be relative to a given reference frame.\n     * @param skeleton defines the Skeleton containing the animation range to convert\n     * @param referenceFrame defines the frame that keyframes in the range will be relative to\n     * @param range defines the name of the AnimationRange belonging to the Skeleton to convert\n     * @returns the original skeleton\n     */\n    static MakeAnimationAdditive(skeleton, referenceFrame = 0, range) {\n        const rangeValue = skeleton.getAnimationRange(range);\n        // We can't make a range additive if it doesn't exist\n        if (!rangeValue) {\n            return null;\n        }\n        // Find any current scene-level animatable belonging to the target that matches the range\n        const sceneAnimatables = skeleton._scene.getAllAnimatablesByTarget(skeleton);\n        let rangeAnimatable = null;\n        for (let index = 0; index < sceneAnimatables.length; index++) {\n            const sceneAnimatable = sceneAnimatables[index];\n            if (sceneAnimatable.fromFrame === (rangeValue === null || rangeValue === void 0 ? void 0 : rangeValue.from) && sceneAnimatable.toFrame === (rangeValue === null || rangeValue === void 0 ? void 0 : rangeValue.to)) {\n                rangeAnimatable = sceneAnimatable;\n                break;\n            }\n        }\n        // Convert the animations belonging to the skeleton to additive keyframes\n        const animatables = skeleton.getAnimatables();\n        for (let index = 0; index < animatables.length; index++) {\n            const animatable = animatables[index];\n            const animations = animatable.animations;\n            if (!animations) {\n                continue;\n            }\n            for (let animIndex = 0; animIndex < animations.length; animIndex++) {\n                Animation.MakeAnimationAdditive(animations[animIndex], referenceFrame, range);\n            }\n        }\n        // Mark the scene-level animatable as additive\n        if (rangeAnimatable) {\n            rangeAnimatable.isAdditive = true;\n        }\n        return skeleton;\n    }\n    /** @internal */\n    _markAsDirty() {\n        this._isDirty = true;\n        this._absoluteTransformIsDirty = true;\n    }\n    /**\n     * @internal\n     */\n    _registerMeshWithPoseMatrix(mesh) {\n        this._meshesWithPoseMatrix.push(mesh);\n    }\n    /**\n     * @internal\n     */\n    _unregisterMeshWithPoseMatrix(mesh) {\n        const index = this._meshesWithPoseMatrix.indexOf(mesh);\n        if (index > -1) {\n            this._meshesWithPoseMatrix.splice(index, 1);\n        }\n    }\n    _computeTransformMatrices(targetMatrix, initialSkinMatrix) {\n        this.onBeforeComputeObservable.notifyObservers(this);\n        for (let index = 0; index < this.bones.length; index++) {\n            const bone = this.bones[index];\n            bone._childUpdateId++;\n            const parentBone = bone.getParent();\n            if (parentBone) {\n                bone.getLocalMatrix().multiplyToRef(parentBone.getWorldMatrix(), bone.getWorldMatrix());\n            }\n            else {\n                if (initialSkinMatrix) {\n                    bone.getLocalMatrix().multiplyToRef(initialSkinMatrix, bone.getWorldMatrix());\n                }\n                else {\n                    bone.getWorldMatrix().copyFrom(bone.getLocalMatrix());\n                }\n            }\n            if (bone._index !== -1) {\n                const mappedIndex = bone._index === null ? index : bone._index;\n                bone.getInvertedAbsoluteTransform().multiplyToArray(bone.getWorldMatrix(), targetMatrix, mappedIndex * 16);\n            }\n        }\n        this._identity.copyToArray(targetMatrix, this.bones.length * 16);\n    }\n    /**\n     * Build all resources required to render a skeleton\n     */\n    prepare() {\n        // Update the local matrix of bones with linked transform nodes.\n        if (this._numBonesWithLinkedTransformNode > 0) {\n            for (const bone of this.bones) {\n                if (bone._linkedTransformNode) {\n                    const node = bone._linkedTransformNode;\n                    bone.position = node.position;\n                    if (node.rotationQuaternion) {\n                        bone.rotationQuaternion = node.rotationQuaternion;\n                    }\n                    else {\n                        bone.rotation = node.rotation;\n                    }\n                    bone.scaling = node.scaling;\n                }\n            }\n        }\n        if (this.needInitialSkinMatrix) {\n            for (const mesh of this._meshesWithPoseMatrix) {\n                const poseMatrix = mesh.getPoseMatrix();\n                let needsUpdate = this._isDirty;\n                if (!mesh._bonesTransformMatrices || mesh._bonesTransformMatrices.length !== 16 * (this.bones.length + 1)) {\n                    mesh._bonesTransformMatrices = new Float32Array(16 * (this.bones.length + 1));\n                    needsUpdate = true;\n                }\n                if (!needsUpdate) {\n                    continue;\n                }\n                if (this._synchronizedWithMesh !== mesh) {\n                    this._synchronizedWithMesh = mesh;\n                    // Prepare bones\n                    for (const bone of this.bones) {\n                        if (!bone.getParent()) {\n                            const matrix = bone.getBaseMatrix();\n                            matrix.multiplyToRef(poseMatrix, TmpVectors.Matrix[1]);\n                            bone._updateDifferenceMatrix(TmpVectors.Matrix[1]);\n                        }\n                    }\n                    if (this.isUsingTextureForMatrices) {\n                        const textureWidth = (this.bones.length + 1) * 4;\n                        if (!mesh._transformMatrixTexture || mesh._transformMatrixTexture.getSize().width !== textureWidth) {\n                            if (mesh._transformMatrixTexture) {\n                                mesh._transformMatrixTexture.dispose();\n                            }\n                            mesh._transformMatrixTexture = RawTexture.CreateRGBATexture(mesh._bonesTransformMatrices, (this.bones.length + 1) * 4, 1, this._scene, false, false, 1, 1);\n                        }\n                    }\n                }\n                this._computeTransformMatrices(mesh._bonesTransformMatrices, poseMatrix);\n                if (this.isUsingTextureForMatrices && mesh._transformMatrixTexture) {\n                    mesh._transformMatrixTexture.update(mesh._bonesTransformMatrices);\n                }\n            }\n        }\n        else {\n            if (!this._isDirty) {\n                return;\n            }\n            if (!this._transformMatrices || this._transformMatrices.length !== 16 * (this.bones.length + 1)) {\n                this._transformMatrices = new Float32Array(16 * (this.bones.length + 1));\n                if (this.isUsingTextureForMatrices) {\n                    if (this._transformMatrixTexture) {\n                        this._transformMatrixTexture.dispose();\n                    }\n                    this._transformMatrixTexture = RawTexture.CreateRGBATexture(this._transformMatrices, (this.bones.length + 1) * 4, 1, this._scene, false, false, 1, 1);\n                }\n            }\n            this._computeTransformMatrices(this._transformMatrices, null);\n            if (this.isUsingTextureForMatrices && this._transformMatrixTexture) {\n                this._transformMatrixTexture.update(this._transformMatrices);\n            }\n        }\n        this._isDirty = false;\n    }\n    /**\n     * Gets the list of animatables currently running for this skeleton\n     * @returns an array of animatables\n     */\n    getAnimatables() {\n        if (!this._animatables || this._animatables.length !== this.bones.length) {\n            this._animatables = [];\n            for (let index = 0; index < this.bones.length; index++) {\n                this._animatables.push(this.bones[index]);\n            }\n        }\n        return this._animatables;\n    }\n    /**\n     * Clone the current skeleton\n     * @param name defines the name of the new skeleton\n     * @param id defines the id of the new skeleton\n     * @returns the new skeleton\n     */\n    clone(name, id) {\n        const result = new Skeleton(name, id || name, this._scene);\n        result.needInitialSkinMatrix = this.needInitialSkinMatrix;\n        for (let index = 0; index < this.bones.length; index++) {\n            const source = this.bones[index];\n            let parentBone = null;\n            const parent = source.getParent();\n            if (parent) {\n                const parentIndex = this.bones.indexOf(parent);\n                parentBone = result.bones[parentIndex];\n            }\n            const bone = new Bone(source.name, result, parentBone, source.getBaseMatrix().clone(), source.getRestPose().clone());\n            bone._index = source._index;\n            if (source._linkedTransformNode) {\n                bone.linkTransformNode(source._linkedTransformNode);\n            }\n            DeepCopier.DeepCopy(source.animations, bone.animations);\n        }\n        if (this._ranges) {\n            result._ranges = {};\n            for (const rangeName in this._ranges) {\n                const range = this._ranges[rangeName];\n                if (range) {\n                    result._ranges[rangeName] = range.clone();\n                }\n            }\n        }\n        this._isDirty = true;\n        return result;\n    }\n    /**\n     * Enable animation blending for this skeleton\n     * @param blendingSpeed defines the blending speed to apply\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#animation-blending\n     */\n    enableBlending(blendingSpeed = 0.01) {\n        this.bones.forEach((bone) => {\n            bone.animations.forEach((animation) => {\n                animation.enableBlending = true;\n                animation.blendingSpeed = blendingSpeed;\n            });\n        });\n    }\n    /**\n     * Releases all resources associated with the current skeleton\n     */\n    dispose() {\n        this._meshesWithPoseMatrix.length = 0;\n        // Animations\n        this.getScene().stopAnimation(this);\n        // Remove from scene\n        this.getScene().removeSkeleton(this);\n        if (this._parentContainer) {\n            const index = this._parentContainer.skeletons.indexOf(this);\n            if (index > -1) {\n                this._parentContainer.skeletons.splice(index, 1);\n            }\n            this._parentContainer = null;\n        }\n        if (this._transformMatrixTexture) {\n            this._transformMatrixTexture.dispose();\n            this._transformMatrixTexture = null;\n        }\n    }\n    /**\n     * Serialize the skeleton in a JSON object\n     * @returns a JSON object\n     */\n    serialize() {\n        var _a;\n        const serializationObject = {};\n        serializationObject.name = this.name;\n        serializationObject.id = this.id;\n        if (this.dimensionsAtRest) {\n            serializationObject.dimensionsAtRest = this.dimensionsAtRest.asArray();\n        }\n        serializationObject.bones = [];\n        serializationObject.needInitialSkinMatrix = this.needInitialSkinMatrix;\n        for (let index = 0; index < this.bones.length; index++) {\n            const bone = this.bones[index];\n            const parent = bone.getParent();\n            const serializedBone = {\n                parentBoneIndex: parent ? this.bones.indexOf(parent) : -1,\n                index: bone.getIndex(),\n                name: bone.name,\n                id: bone.id,\n                matrix: bone.getBaseMatrix().toArray(),\n                rest: bone.getRestPose().toArray(),\n                linkedTransformNodeId: (_a = bone.getTransformNode()) === null || _a === void 0 ? void 0 : _a.id,\n            };\n            serializationObject.bones.push(serializedBone);\n            if (bone.length) {\n                serializedBone.length = bone.length;\n            }\n            if (bone.metadata) {\n                serializedBone.metadata = bone.metadata;\n            }\n            if (bone.animations && bone.animations.length > 0) {\n                serializedBone.animation = bone.animations[0].serialize();\n            }\n            serializationObject.ranges = [];\n            for (const name in this._ranges) {\n                const source = this._ranges[name];\n                if (!source) {\n                    continue;\n                }\n                const range = {};\n                range.name = name;\n                range.from = source.from;\n                range.to = source.to;\n                serializationObject.ranges.push(range);\n            }\n        }\n        return serializationObject;\n    }\n    /**\n     * Creates a new skeleton from serialized data\n     * @param parsedSkeleton defines the serialized data\n     * @param scene defines the hosting scene\n     * @returns a new skeleton\n     */\n    static Parse(parsedSkeleton, scene) {\n        const skeleton = new Skeleton(parsedSkeleton.name, parsedSkeleton.id, scene);\n        if (parsedSkeleton.dimensionsAtRest) {\n            skeleton.dimensionsAtRest = Vector3.FromArray(parsedSkeleton.dimensionsAtRest);\n        }\n        skeleton.needInitialSkinMatrix = parsedSkeleton.needInitialSkinMatrix;\n        let index;\n        for (index = 0; index < parsedSkeleton.bones.length; index++) {\n            const parsedBone = parsedSkeleton.bones[index];\n            const parsedBoneIndex = parsedSkeleton.bones[index].index;\n            let parentBone = null;\n            if (parsedBone.parentBoneIndex > -1) {\n                parentBone = skeleton.bones[parsedBone.parentBoneIndex];\n            }\n            const rest = parsedBone.rest ? Matrix.FromArray(parsedBone.rest) : null;\n            const bone = new Bone(parsedBone.name, skeleton, parentBone, Matrix.FromArray(parsedBone.matrix), rest, null, parsedBoneIndex);\n            if (parsedBone.id !== undefined && parsedBone.id !== null) {\n                bone.id = parsedBone.id;\n            }\n            if (parsedBone.length) {\n                bone.length = parsedBone.length;\n            }\n            if (parsedBone.metadata) {\n                bone.metadata = parsedBone.metadata;\n            }\n            if (parsedBone.animation) {\n                bone.animations.push(Animation.Parse(parsedBone.animation));\n            }\n            if (parsedBone.linkedTransformNodeId !== undefined && parsedBone.linkedTransformNodeId !== null) {\n                skeleton._hasWaitingData = true;\n                bone._waitingTransformNodeId = parsedBone.linkedTransformNodeId;\n            }\n        }\n        // placed after bones, so createAnimationRange can cascade down\n        if (parsedSkeleton.ranges) {\n            for (index = 0; index < parsedSkeleton.ranges.length; index++) {\n                const data = parsedSkeleton.ranges[index];\n                skeleton.createAnimationRange(data.name, data.from, data.to);\n            }\n        }\n        return skeleton;\n    }\n    /**\n     * Compute all node absolute transforms\n     * @param forceUpdate defines if computation must be done even if cache is up to date\n     */\n    computeAbsoluteTransforms(forceUpdate = false) {\n        if (this._absoluteTransformIsDirty || forceUpdate) {\n            this.bones[0].computeAbsoluteTransforms();\n            this._absoluteTransformIsDirty = false;\n        }\n    }\n    /**\n     * Gets the root pose matrix\n     * @returns a matrix\n     */\n    getPoseMatrix() {\n        let poseMatrix = null;\n        if (this._meshesWithPoseMatrix.length > 0) {\n            poseMatrix = this._meshesWithPoseMatrix[0].getPoseMatrix();\n        }\n        return poseMatrix;\n    }\n    /**\n     * Sorts bones per internal index\n     */\n    sortBones() {\n        const bones = new Array();\n        const visited = new Array(this.bones.length);\n        for (let index = 0; index < this.bones.length; index++) {\n            this._sortBones(index, bones, visited);\n        }\n        this.bones = bones;\n    }\n    _sortBones(index, bones, visited) {\n        if (visited[index]) {\n            return;\n        }\n        visited[index] = true;\n        const bone = this.bones[index];\n        if (!bone)\n            return;\n        if (bone._index === undefined) {\n            bone._index = index;\n        }\n        const parentBone = bone.getParent();\n        if (parentBone) {\n            this._sortBones(this.bones.indexOf(parentBone), bones, visited);\n        }\n        bones.push(bone);\n    }\n    /**\n     * Set the current local matrix as the restPose for all bones in the skeleton.\n     */\n    setCurrentPoseAsRest() {\n        this.bones.forEach((b) => {\n            b.setCurrentPoseAsRest();\n        });\n    }\n}\n//# sourceMappingURL=skeleton.js.map","import { DataBuffer } from \"./dataBuffer.js\";\n/**\n * Class used to store data that will be store in GPU memory\n */\nexport class Buffer {\n    /**\n     * Constructor\n     * @param engine the engine\n     * @param data the data to use for this buffer\n     * @param updatable whether the data is updatable\n     * @param stride the stride (optional)\n     * @param postponeInternalCreation whether to postpone creating the internal WebGL buffer (optional)\n     * @param instanced whether the buffer is instanced (optional)\n     * @param useBytes set to true if the stride in in bytes (optional)\n     * @param divisor sets an optional divisor for instances (1 by default)\n     */\n    constructor(engine, data, updatable, stride = 0, postponeInternalCreation = false, instanced = false, useBytes = false, divisor) {\n        this._isAlreadyOwned = false;\n        if (engine.getScene) {\n            // old versions of VertexBuffer accepted 'mesh' instead of 'engine'\n            this._engine = engine.getScene().getEngine();\n        }\n        else {\n            this._engine = engine;\n        }\n        this._updatable = updatable;\n        this._instanced = instanced;\n        this._divisor = divisor || 1;\n        if (data instanceof DataBuffer) {\n            this._data = null;\n            this._buffer = data;\n        }\n        else {\n            this._data = data;\n            this._buffer = null;\n        }\n        this.byteStride = useBytes ? stride : stride * Float32Array.BYTES_PER_ELEMENT;\n        if (!postponeInternalCreation) {\n            // by default\n            this.create();\n        }\n    }\n    /**\n     * Create a new VertexBuffer based on the current buffer\n     * @param kind defines the vertex buffer kind (position, normal, etc.)\n     * @param offset defines offset in the buffer (0 by default)\n     * @param size defines the size in floats of attributes (position is 3 for instance)\n     * @param stride defines the stride size in floats in the buffer (the offset to apply to reach next value when data is interleaved)\n     * @param instanced defines if the vertex buffer contains indexed data\n     * @param useBytes defines if the offset and stride are in bytes     *\n     * @param divisor sets an optional divisor for instances (1 by default)\n     * @returns the new vertex buffer\n     */\n    createVertexBuffer(kind, offset, size, stride, instanced, useBytes = false, divisor) {\n        const byteOffset = useBytes ? offset : offset * Float32Array.BYTES_PER_ELEMENT;\n        const byteStride = stride ? (useBytes ? stride : stride * Float32Array.BYTES_PER_ELEMENT) : this.byteStride;\n        // a lot of these parameters are ignored as they are overridden by the buffer\n        return new VertexBuffer(this._engine, this, kind, this._updatable, true, byteStride, instanced === undefined ? this._instanced : instanced, byteOffset, size, undefined, undefined, true, this._divisor || divisor);\n    }\n    // Properties\n    /**\n     * Gets a boolean indicating if the Buffer is updatable?\n     * @returns true if the buffer is updatable\n     */\n    isUpdatable() {\n        return this._updatable;\n    }\n    /**\n     * Gets current buffer's data\n     * @returns a DataArray or null\n     */\n    getData() {\n        return this._data;\n    }\n    /**\n     * Gets underlying native buffer\n     * @returns underlying native buffer\n     */\n    getBuffer() {\n        return this._buffer;\n    }\n    /**\n     * Gets the stride in float32 units (i.e. byte stride / 4).\n     * May not be an integer if the byte stride is not divisible by 4.\n     * @returns the stride in float32 units\n     * @deprecated Please use byteStride instead.\n     */\n    getStrideSize() {\n        return this.byteStride / Float32Array.BYTES_PER_ELEMENT;\n    }\n    // Methods\n    /**\n     * Store data into the buffer. Creates the buffer if not used already.\n     * If the buffer was already used, it will be updated only if it is updatable, otherwise it will do nothing.\n     * @param data defines the data to store\n     */\n    create(data = null) {\n        if (!data && this._buffer) {\n            return; // nothing to do\n        }\n        data = data || this._data;\n        if (!data) {\n            return;\n        }\n        if (!this._buffer) {\n            // create buffer\n            if (this._updatable) {\n                this._buffer = this._engine.createDynamicVertexBuffer(data);\n                this._data = data;\n            }\n            else {\n                this._buffer = this._engine.createVertexBuffer(data);\n            }\n        }\n        else if (this._updatable) {\n            // update buffer\n            this._engine.updateDynamicVertexBuffer(this._buffer, data);\n            this._data = data;\n        }\n    }\n    /** @internal */\n    _rebuild() {\n        this._buffer = null;\n        this.create(this._data);\n    }\n    /**\n     * Update current buffer data\n     * @param data defines the data to store\n     */\n    update(data) {\n        this.create(data);\n    }\n    /**\n     * Updates the data directly.\n     * @param data the new data\n     * @param offset the new offset\n     * @param vertexCount the vertex count (optional)\n     * @param useBytes set to true if the offset is in bytes\n     */\n    updateDirectly(data, offset, vertexCount, useBytes = false) {\n        if (!this._buffer) {\n            return;\n        }\n        if (this._updatable) {\n            // update buffer\n            this._engine.updateDynamicVertexBuffer(this._buffer, data, useBytes ? offset : offset * Float32Array.BYTES_PER_ELEMENT, vertexCount ? vertexCount * this.byteStride : undefined);\n            if (offset === 0 && vertexCount === undefined) {\n                // Keep the data if we easily can\n                this._data = data;\n            }\n            else {\n                this._data = null;\n            }\n        }\n    }\n    /** @internal */\n    _increaseReferences() {\n        if (!this._buffer) {\n            return;\n        }\n        if (!this._isAlreadyOwned) {\n            this._isAlreadyOwned = true;\n            return;\n        }\n        this._buffer.references++;\n    }\n    /**\n     * Release all resources\n     */\n    dispose() {\n        if (!this._buffer) {\n            return;\n        }\n        if (this._engine._releaseBuffer(this._buffer)) {\n            this._buffer = null;\n            this._data = null;\n        }\n    }\n}\n/**\n * Specialized buffer used to store vertex data\n */\nexport class VertexBuffer {\n    /**\n     * Gets or sets the instance divisor when in instanced mode\n     */\n    get instanceDivisor() {\n        return this._instanceDivisor;\n    }\n    set instanceDivisor(value) {\n        const isInstanced = value != 0;\n        this._instanceDivisor = value;\n        if (isInstanced !== this._instanced) {\n            this._instanced = isInstanced;\n            this._computeHashCode();\n        }\n    }\n    /**\n     * Constructor\n     * @param engine the engine\n     * @param data the data to use for this vertex buffer\n     * @param kind the vertex buffer kind\n     * @param updatable whether the data is updatable\n     * @param postponeInternalCreation whether to postpone creating the internal WebGL buffer (optional)\n     * @param stride the stride (optional)\n     * @param instanced whether the buffer is instanced (optional)\n     * @param offset the offset of the data (optional)\n     * @param size the number of components (optional)\n     * @param type the type of the component (optional)\n     * @param normalized whether the data contains normalized data (optional)\n     * @param useBytes set to true if stride and offset are in bytes (optional)\n     * @param divisor defines the instance divisor to use (1 by default)\n     * @param takeBufferOwnership defines if the buffer should be released when the vertex buffer is disposed\n     */\n    constructor(engine, data, kind, updatable, postponeInternalCreation, stride, instanced, offset, size, type, normalized = false, useBytes = false, divisor = 1, takeBufferOwnership = false) {\n        if (data instanceof Buffer) {\n            this._buffer = data;\n            this._ownsBuffer = takeBufferOwnership;\n        }\n        else {\n            this._buffer = new Buffer(engine, data, updatable, stride, postponeInternalCreation, instanced, useBytes);\n            this._ownsBuffer = true;\n        }\n        this.uniqueId = VertexBuffer._Counter++;\n        this._kind = kind;\n        if (type == undefined) {\n            const vertexData = this.getData();\n            this.type = VertexBuffer.FLOAT;\n            if (vertexData instanceof Int8Array) {\n                this.type = VertexBuffer.BYTE;\n            }\n            else if (vertexData instanceof Uint8Array) {\n                this.type = VertexBuffer.UNSIGNED_BYTE;\n            }\n            else if (vertexData instanceof Int16Array) {\n                this.type = VertexBuffer.SHORT;\n            }\n            else if (vertexData instanceof Uint16Array) {\n                this.type = VertexBuffer.UNSIGNED_SHORT;\n            }\n            else if (vertexData instanceof Int32Array) {\n                this.type = VertexBuffer.INT;\n            }\n            else if (vertexData instanceof Uint32Array) {\n                this.type = VertexBuffer.UNSIGNED_INT;\n            }\n        }\n        else {\n            this.type = type;\n        }\n        const typeByteLength = VertexBuffer.GetTypeByteLength(this.type);\n        if (useBytes) {\n            this._size = size || (stride ? stride / typeByteLength : VertexBuffer.DeduceStride(kind));\n            this.byteStride = stride || this._buffer.byteStride || this._size * typeByteLength;\n            this.byteOffset = offset || 0;\n        }\n        else {\n            this._size = size || stride || VertexBuffer.DeduceStride(kind);\n            this.byteStride = stride ? stride * typeByteLength : this._buffer.byteStride || this._size * typeByteLength;\n            this.byteOffset = (offset || 0) * typeByteLength;\n        }\n        this.normalized = normalized;\n        this._instanced = instanced !== undefined ? instanced : false;\n        this._instanceDivisor = instanced ? divisor : 0;\n        this._computeHashCode();\n    }\n    _computeHashCode() {\n        // note: cast to any because the property is declared readonly\n        this.hashCode =\n            ((this.type - 5120) << 0) +\n                ((this.normalized ? 1 : 0) << 3) +\n                (this._size << 4) +\n                ((this._instanced ? 1 : 0) << 6) +\n                /* keep 5 bits free */\n                (this.byteStride << 12);\n    }\n    /** @internal */\n    _rebuild() {\n        if (!this._buffer) {\n            return;\n        }\n        this._buffer._rebuild();\n    }\n    /**\n     * Returns the kind of the VertexBuffer (string)\n     * @returns a string\n     */\n    getKind() {\n        return this._kind;\n    }\n    // Properties\n    /**\n     * Gets a boolean indicating if the VertexBuffer is updatable?\n     * @returns true if the buffer is updatable\n     */\n    isUpdatable() {\n        return this._buffer.isUpdatable();\n    }\n    /**\n     * Gets current buffer's data\n     * @returns a DataArray or null\n     */\n    getData() {\n        return this._buffer.getData();\n    }\n    /**\n     * Gets current buffer's data as a float array. Float data is constructed if the vertex buffer data cannot be returned directly.\n     * @param totalVertices number of vertices in the buffer to take into account\n     * @param forceCopy defines a boolean indicating that the returned array must be cloned upon returning it\n     * @returns a float array containing vertex data\n     */\n    getFloatData(totalVertices, forceCopy) {\n        const data = this.getData();\n        if (!data) {\n            return null;\n        }\n        const tightlyPackedByteStride = this.getSize() * VertexBuffer.GetTypeByteLength(this.type);\n        const count = totalVertices * this.getSize();\n        if (this.type !== VertexBuffer.FLOAT || this.byteStride !== tightlyPackedByteStride) {\n            const copy = new Float32Array(count);\n            this.forEach(count, (value, index) => (copy[index] = value));\n            return copy;\n        }\n        if (!(data instanceof Array || data instanceof Float32Array) || this.byteOffset !== 0 || data.length !== count) {\n            if (data instanceof Array) {\n                const offset = this.byteOffset / 4;\n                return data.slice(offset, offset + count);\n            }\n            else if (data instanceof ArrayBuffer) {\n                return new Float32Array(data, this.byteOffset, count);\n            }\n            else {\n                let offset = data.byteOffset + this.byteOffset;\n                if (forceCopy) {\n                    const result = new Float32Array(count);\n                    const source = new Float32Array(data.buffer, offset, count);\n                    result.set(source);\n                    return result;\n                }\n                // Protect against bad data\n                const remainder = offset % 4;\n                if (remainder) {\n                    offset = Math.max(0, offset - remainder);\n                }\n                return new Float32Array(data.buffer, offset, count);\n            }\n        }\n        if (forceCopy) {\n            return data.slice();\n        }\n        return data;\n    }\n    /**\n     * Gets underlying native buffer\n     * @returns underlying native buffer\n     */\n    getBuffer() {\n        return this._buffer.getBuffer();\n    }\n    /**\n     * Gets the stride in float32 units (i.e. byte stride / 4).\n     * May not be an integer if the byte stride is not divisible by 4.\n     * @returns the stride in float32 units\n     * @deprecated Please use byteStride instead.\n     */\n    getStrideSize() {\n        return this.byteStride / VertexBuffer.GetTypeByteLength(this.type);\n    }\n    /**\n     * Returns the offset as a multiple of the type byte length.\n     * @returns the offset in bytes\n     * @deprecated Please use byteOffset instead.\n     */\n    getOffset() {\n        return this.byteOffset / VertexBuffer.GetTypeByteLength(this.type);\n    }\n    /**\n     * Returns the number of components or the byte size per vertex attribute\n     * @param sizeInBytes If true, returns the size in bytes or else the size in number of components of the vertex attribute (default: false)\n     * @returns the number of components\n     */\n    getSize(sizeInBytes = false) {\n        return sizeInBytes ? this._size * VertexBuffer.GetTypeByteLength(this.type) : this._size;\n    }\n    /**\n     * Gets a boolean indicating is the internal buffer of the VertexBuffer is instanced\n     * @returns true if this buffer is instanced\n     */\n    getIsInstanced() {\n        return this._instanced;\n    }\n    /**\n     * Returns the instancing divisor, zero for non-instanced (integer).\n     * @returns a number\n     */\n    getInstanceDivisor() {\n        return this._instanceDivisor;\n    }\n    // Methods\n    /**\n     * Store data into the buffer. If the buffer was already used it will be either recreated or updated depending on isUpdatable property\n     * @param data defines the data to store\n     */\n    create(data) {\n        this._buffer.create(data);\n    }\n    /**\n     * Updates the underlying buffer according to the passed numeric array or Float32Array.\n     * This function will create a new buffer if the current one is not updatable\n     * @param data defines the data to store\n     */\n    update(data) {\n        this._buffer.update(data);\n    }\n    /**\n     * Updates directly the underlying WebGLBuffer according to the passed numeric array or Float32Array.\n     * Returns the directly updated WebGLBuffer.\n     * @param data the new data\n     * @param offset the new offset\n     * @param useBytes set to true if the offset is in bytes\n     */\n    updateDirectly(data, offset, useBytes = false) {\n        this._buffer.updateDirectly(data, offset, undefined, useBytes);\n    }\n    /**\n     * Disposes the VertexBuffer and the underlying WebGLBuffer.\n     */\n    dispose() {\n        if (this._ownsBuffer) {\n            this._buffer.dispose();\n        }\n    }\n    /**\n     * Enumerates each value of this vertex buffer as numbers.\n     * @param count the number of values to enumerate\n     * @param callback the callback function called for each value\n     */\n    forEach(count, callback) {\n        VertexBuffer.ForEach(this._buffer.getData(), this.byteOffset, this.byteStride, this._size, this.type, count, this.normalized, callback);\n    }\n    /**\n     * Deduces the stride given a kind.\n     * @param kind The kind string to deduce\n     * @returns The deduced stride\n     */\n    static DeduceStride(kind) {\n        switch (kind) {\n            case VertexBuffer.UVKind:\n            case VertexBuffer.UV2Kind:\n            case VertexBuffer.UV3Kind:\n            case VertexBuffer.UV4Kind:\n            case VertexBuffer.UV5Kind:\n            case VertexBuffer.UV6Kind:\n                return 2;\n            case VertexBuffer.NormalKind:\n            case VertexBuffer.PositionKind:\n                return 3;\n            case VertexBuffer.ColorKind:\n            case VertexBuffer.MatricesIndicesKind:\n            case VertexBuffer.MatricesIndicesExtraKind:\n            case VertexBuffer.MatricesWeightsKind:\n            case VertexBuffer.MatricesWeightsExtraKind:\n            case VertexBuffer.TangentKind:\n                return 4;\n            default:\n                throw new Error(\"Invalid kind '\" + kind + \"'\");\n        }\n    }\n    /**\n     * Gets the byte length of the given type.\n     * @param type the type\n     * @returns the number of bytes\n     */\n    static GetTypeByteLength(type) {\n        switch (type) {\n            case VertexBuffer.BYTE:\n            case VertexBuffer.UNSIGNED_BYTE:\n                return 1;\n            case VertexBuffer.SHORT:\n            case VertexBuffer.UNSIGNED_SHORT:\n                return 2;\n            case VertexBuffer.INT:\n            case VertexBuffer.UNSIGNED_INT:\n            case VertexBuffer.FLOAT:\n                return 4;\n            default:\n                throw new Error(`Invalid type '${type}'`);\n        }\n    }\n    /**\n     * Enumerates each value of the given parameters as numbers.\n     * @param data the data to enumerate\n     * @param byteOffset the byte offset of the data\n     * @param byteStride the byte stride of the data\n     * @param componentCount the number of components per element\n     * @param componentType the type of the component\n     * @param count the number of values to enumerate\n     * @param normalized whether the data is normalized\n     * @param callback the callback function called for each value\n     */\n    static ForEach(data, byteOffset, byteStride, componentCount, componentType, count, normalized, callback) {\n        if (data instanceof Array) {\n            let offset = byteOffset / 4;\n            const stride = byteStride / 4;\n            for (let index = 0; index < count; index += componentCount) {\n                for (let componentIndex = 0; componentIndex < componentCount; componentIndex++) {\n                    callback(data[offset + componentIndex], index + componentIndex);\n                }\n                offset += stride;\n            }\n        }\n        else {\n            const dataView = data instanceof ArrayBuffer ? new DataView(data) : new DataView(data.buffer, data.byteOffset, data.byteLength);\n            const componentByteLength = VertexBuffer.GetTypeByteLength(componentType);\n            for (let index = 0; index < count; index += componentCount) {\n                let componentByteOffset = byteOffset;\n                for (let componentIndex = 0; componentIndex < componentCount; componentIndex++) {\n                    const value = VertexBuffer._GetFloatValue(dataView, componentType, componentByteOffset, normalized);\n                    callback(value, index + componentIndex);\n                    componentByteOffset += componentByteLength;\n                }\n                byteOffset += byteStride;\n            }\n        }\n    }\n    static _GetFloatValue(dataView, type, byteOffset, normalized) {\n        switch (type) {\n            case VertexBuffer.BYTE: {\n                let value = dataView.getInt8(byteOffset);\n                if (normalized) {\n                    value = Math.max(value / 127, -1);\n                }\n                return value;\n            }\n            case VertexBuffer.UNSIGNED_BYTE: {\n                let value = dataView.getUint8(byteOffset);\n                if (normalized) {\n                    value = value / 255;\n                }\n                return value;\n            }\n            case VertexBuffer.SHORT: {\n                let value = dataView.getInt16(byteOffset, true);\n                if (normalized) {\n                    value = Math.max(value / 32767, -1);\n                }\n                return value;\n            }\n            case VertexBuffer.UNSIGNED_SHORT: {\n                let value = dataView.getUint16(byteOffset, true);\n                if (normalized) {\n                    value = value / 65535;\n                }\n                return value;\n            }\n            case VertexBuffer.INT: {\n                return dataView.getInt32(byteOffset, true);\n            }\n            case VertexBuffer.UNSIGNED_INT: {\n                return dataView.getUint32(byteOffset, true);\n            }\n            case VertexBuffer.FLOAT: {\n                return dataView.getFloat32(byteOffset, true);\n            }\n            default: {\n                throw new Error(`Invalid component type ${type}`);\n            }\n        }\n    }\n}\nVertexBuffer._Counter = 0;\n/**\n * The byte type.\n */\nVertexBuffer.BYTE = 5120;\n/**\n * The unsigned byte type.\n */\nVertexBuffer.UNSIGNED_BYTE = 5121;\n/**\n * The short type.\n */\nVertexBuffer.SHORT = 5122;\n/**\n * The unsigned short type.\n */\nVertexBuffer.UNSIGNED_SHORT = 5123;\n/**\n * The integer type.\n */\nVertexBuffer.INT = 5124;\n/**\n * The unsigned integer type.\n */\nVertexBuffer.UNSIGNED_INT = 5125;\n/**\n * The float type.\n */\nVertexBuffer.FLOAT = 5126;\n// Enums\n/**\n * Positions\n */\nVertexBuffer.PositionKind = \"position\";\n/**\n * Normals\n */\nVertexBuffer.NormalKind = \"normal\";\n/**\n * Tangents\n */\nVertexBuffer.TangentKind = \"tangent\";\n/**\n * Texture coordinates\n */\nVertexBuffer.UVKind = \"uv\";\n/**\n * Texture coordinates 2\n */\nVertexBuffer.UV2Kind = \"uv2\";\n/**\n * Texture coordinates 3\n */\nVertexBuffer.UV3Kind = \"uv3\";\n/**\n * Texture coordinates 4\n */\nVertexBuffer.UV4Kind = \"uv4\";\n/**\n * Texture coordinates 5\n */\nVertexBuffer.UV5Kind = \"uv5\";\n/**\n * Texture coordinates 6\n */\nVertexBuffer.UV6Kind = \"uv6\";\n/**\n * Colors\n */\nVertexBuffer.ColorKind = \"color\";\n/**\n * Instance Colors\n */\nVertexBuffer.ColorInstanceKind = \"instanceColor\";\n/**\n * Matrix indices (for bones)\n */\nVertexBuffer.MatricesIndicesKind = \"matricesIndices\";\n/**\n * Matrix weights (for bones)\n */\nVertexBuffer.MatricesWeightsKind = \"matricesWeights\";\n/**\n * Additional matrix indices (for bones)\n */\nVertexBuffer.MatricesIndicesExtraKind = \"matricesIndicesExtra\";\n/**\n * Additional matrix weights (for bones)\n */\nVertexBuffer.MatricesWeightsExtraKind = \"matricesWeightsExtra\";\n//# sourceMappingURL=buffer.js.map","/**\n * Class used to store gfx data (like WebGLBuffer)\n */\nexport class DataBuffer {\n    /**\n     * Gets the underlying buffer\n     */\n    get underlyingResource() {\n        return null;\n    }\n    /**\n     * Constructs the buffer\n     */\n    constructor() {\n        /**\n         * Gets or sets the number of objects referencing this buffer\n         */\n        this.references = 0;\n        /** Gets or sets the size of the underlying buffer */\n        this.capacity = 0;\n        /**\n         * Gets or sets a boolean indicating if the buffer contains 32bits indices\n         */\n        this.is32Bits = false;\n        this.uniqueId = DataBuffer._Counter++;\n    }\n}\nDataBuffer._Counter = 0;\n//# sourceMappingURL=dataBuffer.js.map","\n/**\n * This class is a small wrapper around a native buffer that can be read and/or written\n */\nexport class StorageBuffer {\n    /**\n     * Creates a new storage buffer instance\n     * @param engine The engine the buffer will be created inside\n     * @param size The size of the buffer in bytes\n     * @param creationFlags flags to use when creating the buffer (see undefined). The BUFFER_CREATIONFLAG_STORAGE flag will be automatically added.\n     */\n    constructor(engine, size, creationFlags = 3) {\n        this._engine = engine;\n        this._engine._storageBuffers.push(this);\n        this._create(size, creationFlags);\n    }\n    _create(size, creationFlags) {\n        this._bufferSize = size;\n        this._creationFlags = creationFlags;\n        this._buffer = this._engine.createStorageBuffer(size, creationFlags);\n    }\n    /** @internal */\n    _rebuild() {\n        this._create(this._bufferSize, this._creationFlags);\n    }\n    /**\n     * Gets underlying native buffer\n     * @returns underlying native buffer\n     */\n    getBuffer() {\n        return this._buffer;\n    }\n    /**\n     * Updates the storage buffer\n     * @param data the data used to update the storage buffer\n     * @param byteOffset the byte offset of the data (optional)\n     * @param byteLength the byte length of the data (optional)\n     */\n    update(data, byteOffset, byteLength) {\n        if (!this._buffer) {\n            return;\n        }\n        this._engine.updateStorageBuffer(this._buffer, data, byteOffset, byteLength);\n    }\n    /**\n     * Reads data from the storage buffer\n     * @param offset The offset in the storage buffer to start reading from (default: 0)\n     * @param size  The number of bytes to read from the storage buffer (default: capacity of the buffer)\n     * @param buffer The buffer to write the data we have read from the storage buffer to (optional)\n     * @returns If not undefined, returns the (promise) buffer (as provided by the 4th parameter) filled with the data, else it returns a (promise) Uint8Array with the data read from the storage buffer\n     */\n    read(offset, size, buffer) {\n        return this._engine.readFromStorageBuffer(this._buffer, offset, size, buffer);\n    }\n    /**\n     * Disposes the storage buffer\n     */\n    dispose() {\n        const storageBuffers = this._engine._storageBuffers;\n        const index = storageBuffers.indexOf(this);\n        if (index !== -1) {\n            storageBuffers[index] = storageBuffers[storageBuffers.length - 1];\n            storageBuffers.pop();\n        }\n        this._engine._releaseBuffer(this._buffer);\n        this._buffer = null;\n    }\n}\n//# sourceMappingURL=storageBuffer.js.map","import { __decorate } from \"../../tslib.es6.js\";\nimport { serialize } from \"../../Misc/decorators.js\";\nimport { Observable } from \"../../Misc/observable.js\";\nimport { PointerEventTypes } from \"../../Events/pointerEvents.js\";\nimport { EventConstants } from \"../../Events/deviceInputEvents.js\";\nimport { Tools } from \"../../Misc/tools.js\";\n/**\n * Base class for mouse wheel input..\n * See FollowCameraMouseWheelInput in src/Cameras/Inputs/freeCameraMouseWheelInput.ts\n * for example usage.\n */\nexport class BaseCameraMouseWheelInput {\n    constructor() {\n        /**\n         * How fast is the camera moves in relation to X axis mouseWheel events.\n         * Use negative value to reverse direction.\n         */\n        this.wheelPrecisionX = 3.0;\n        /**\n         * How fast is the camera moves in relation to Y axis mouseWheel events.\n         * Use negative value to reverse direction.\n         */\n        this.wheelPrecisionY = 3.0;\n        /**\n         * How fast is the camera moves in relation to Z axis mouseWheel events.\n         * Use negative value to reverse direction.\n         */\n        this.wheelPrecisionZ = 3.0;\n        /**\n         * Observable for when a mouse wheel move event occurs.\n         */\n        this.onChangedObservable = new Observable();\n        /**\n         * Incremental value of multiple mouse wheel movements of the X axis.\n         * Should be zero-ed when read.\n         */\n        this._wheelDeltaX = 0;\n        /**\n         * Incremental value of multiple mouse wheel movements of the Y axis.\n         * Should be zero-ed when read.\n         */\n        this._wheelDeltaY = 0;\n        /**\n         * Incremental value of multiple mouse wheel movements of the Z axis.\n         * Should be zero-ed when read.\n         */\n        this._wheelDeltaZ = 0;\n        /**\n         * Firefox uses a different scheme to report scroll distances to other\n         * browsers. Rather than use complicated methods to calculate the exact\n         * multiple we need to apply, let's just cheat and use a constant.\n         * https://developer.mozilla.org/en-US/docs/Web/API/WheelEvent/deltaMode\n         * https://stackoverflow.com/questions/20110224/what-is-the-height-of-a-line-in-a-wheel-event-deltamode-dom-delta-line\n         */\n        this._ffMultiplier = 12;\n        /**\n         * Different event attributes for wheel data fall into a few set ranges.\n         * Some relevant but dated date here:\n         * https://stackoverflow.com/questions/5527601/normalizing-mousewheel-speed-across-browsers\n         */\n        this._normalize = 120;\n    }\n    /**\n     * Attach the input controls to a specific dom element to get the input from.\n     * @param noPreventDefault Defines whether event caught by the controls\n     *   should call preventdefault().\n     *   (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\n     */\n    attachControl(noPreventDefault) {\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\n        this._wheel = (pointer) => {\n            // sanity check - this should be a PointerWheel event.\n            if (pointer.type !== PointerEventTypes.POINTERWHEEL) {\n                return;\n            }\n            const event = pointer.event;\n            const platformScale = event.deltaMode === EventConstants.DOM_DELTA_LINE ? this._ffMultiplier : 1; // If this happens to be set to DOM_DELTA_LINE, adjust accordingly\n            this._wheelDeltaX += (this.wheelPrecisionX * platformScale * event.deltaX) / this._normalize;\n            this._wheelDeltaY -= (this.wheelPrecisionY * platformScale * event.deltaY) / this._normalize;\n            this._wheelDeltaZ += (this.wheelPrecisionZ * platformScale * event.deltaZ) / this._normalize;\n            if (event.preventDefault) {\n                if (!noPreventDefault) {\n                    event.preventDefault();\n                }\n            }\n        };\n        this._observer = this.camera.getScene()._inputManager._addCameraPointerObserver(this._wheel, PointerEventTypes.POINTERWHEEL);\n    }\n    /**\n     * Detach the current controls from the specified dom element.\n     */\n    detachControl() {\n        if (this._observer) {\n            this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer);\n            this._observer = null;\n            this._wheel = null;\n        }\n        if (this.onChangedObservable) {\n            this.onChangedObservable.clear();\n        }\n    }\n    /**\n     * Called for each rendered frame.\n     */\n    checkInputs() {\n        this.onChangedObservable.notifyObservers({\n            wheelDeltaX: this._wheelDeltaX,\n            wheelDeltaY: this._wheelDeltaY,\n            wheelDeltaZ: this._wheelDeltaZ,\n        });\n        // Clear deltas.\n        this._wheelDeltaX = 0;\n        this._wheelDeltaY = 0;\n        this._wheelDeltaZ = 0;\n    }\n    /**\n     * Gets the class name of the current input.\n     * @returns the class name\n     */\n    getClassName() {\n        return \"BaseCameraMouseWheelInput\";\n    }\n    /**\n     * Get the friendly name associated with the input class.\n     * @returns the input friendly name\n     */\n    getSimpleName() {\n        return \"mousewheel\";\n    }\n}\n__decorate([\n    serialize()\n], BaseCameraMouseWheelInput.prototype, \"wheelPrecisionX\", void 0);\n__decorate([\n    serialize()\n], BaseCameraMouseWheelInput.prototype, \"wheelPrecisionY\", void 0);\n__decorate([\n    serialize()\n], BaseCameraMouseWheelInput.prototype, \"wheelPrecisionZ\", void 0);\n//# sourceMappingURL=BaseCameraMouseWheelInput.js.map","import { __decorate } from \"../../tslib.es6.js\";\nimport { serialize } from \"../../Misc/decorators.js\";\nimport { Tools } from \"../../Misc/tools.js\";\nimport { PointerEventTypes } from \"../../Events/pointerEvents.js\";\n/**\n * Base class for Camera Pointer Inputs.\n * See FollowCameraPointersInput in src/Cameras/Inputs/followCameraPointersInput.ts\n * for example usage.\n */\nexport class BaseCameraPointersInput {\n    constructor() {\n        this._currentActiveButton = -1;\n        /**\n         * Defines the buttons associated with the input to handle camera move.\n         */\n        this.buttons = [0, 1, 2];\n    }\n    /**\n     * Attach the input controls to a specific dom element to get the input from.\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\n     */\n    attachControl(noPreventDefault) {\n        // eslint-disable-next-line prefer-rest-params\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\n        const engine = this.camera.getEngine();\n        const element = engine.getInputElement();\n        let previousPinchSquaredDistance = 0;\n        let previousMultiTouchPanPosition = null;\n        this._pointA = null;\n        this._pointB = null;\n        this._altKey = false;\n        this._ctrlKey = false;\n        this._metaKey = false;\n        this._shiftKey = false;\n        this._buttonsPressed = 0;\n        this._pointerInput = (p) => {\n            var _a, _b;\n            const evt = p.event;\n            const isTouch = evt.pointerType === \"touch\";\n            if (engine.isInVRExclusivePointerMode) {\n                return;\n            }\n            if (p.type !== PointerEventTypes.POINTERMOVE && this.buttons.indexOf(evt.button) === -1) {\n                return;\n            }\n            const srcElement = evt.target;\n            this._altKey = evt.altKey;\n            this._ctrlKey = evt.ctrlKey;\n            this._metaKey = evt.metaKey;\n            this._shiftKey = evt.shiftKey;\n            this._buttonsPressed = evt.buttons;\n            if (engine.isPointerLock) {\n                const offsetX = evt.movementX;\n                const offsetY = evt.movementY;\n                this.onTouch(null, offsetX, offsetY);\n                this._pointA = null;\n                this._pointB = null;\n            }\n            else if (p.type !== PointerEventTypes.POINTERDOWN && isTouch && ((_a = this._pointA) === null || _a === void 0 ? void 0 : _a.pointerId) !== evt.pointerId && ((_b = this._pointB) === null || _b === void 0 ? void 0 : _b.pointerId) !== evt.pointerId) {\n                return; // If we get a non-down event for a touch that we're not tracking, ignore it\n            }\n            else if (p.type === PointerEventTypes.POINTERDOWN && (this._currentActiveButton === -1 || isTouch)) {\n                try {\n                    srcElement === null || srcElement === void 0 ? void 0 : srcElement.setPointerCapture(evt.pointerId);\n                }\n                catch (e) {\n                    //Nothing to do with the error. Execution will continue.\n                }\n                if (this._pointA === null) {\n                    this._pointA = {\n                        x: evt.clientX,\n                        y: evt.clientY,\n                        pointerId: evt.pointerId,\n                        type: evt.pointerType,\n                    };\n                }\n                else if (this._pointB === null) {\n                    this._pointB = {\n                        x: evt.clientX,\n                        y: evt.clientY,\n                        pointerId: evt.pointerId,\n                        type: evt.pointerType,\n                    };\n                }\n                else {\n                    return; // We are already tracking two pointers so ignore this one\n                }\n                if (this._currentActiveButton === -1 && !isTouch) {\n                    this._currentActiveButton = evt.button;\n                }\n                this.onButtonDown(evt);\n                if (!noPreventDefault) {\n                    evt.preventDefault();\n                    element && element.focus();\n                }\n            }\n            else if (p.type === PointerEventTypes.POINTERDOUBLETAP) {\n                this.onDoubleTap(evt.pointerType);\n            }\n            else if (p.type === PointerEventTypes.POINTERUP && (this._currentActiveButton === evt.button || isTouch)) {\n                try {\n                    srcElement === null || srcElement === void 0 ? void 0 : srcElement.releasePointerCapture(evt.pointerId);\n                }\n                catch (e) {\n                    //Nothing to do with the error.\n                }\n                if (!isTouch) {\n                    this._pointB = null; // Mouse and pen are mono pointer\n                }\n                //would be better to use pointers.remove(evt.pointerId) for multitouch gestures,\n                //but emptying completely pointers collection is required to fix a bug on iPhone :\n                //when changing orientation while pinching camera,\n                //one pointer stay pressed forever if we don't release all pointers\n                //will be ok to put back pointers.remove(evt.pointerId); when iPhone bug corrected\n                if (engine._badOS) {\n                    this._pointA = this._pointB = null;\n                }\n                else {\n                    //only remove the impacted pointer in case of multitouch allowing on most\n                    //platforms switching from rotate to zoom and pan seamlessly.\n                    if (this._pointB && this._pointA && this._pointA.pointerId == evt.pointerId) {\n                        this._pointA = this._pointB;\n                        this._pointB = null;\n                    }\n                    else if (this._pointA && this._pointB && this._pointB.pointerId == evt.pointerId) {\n                        this._pointB = null;\n                    }\n                    else {\n                        this._pointA = this._pointB = null;\n                    }\n                }\n                if (previousPinchSquaredDistance !== 0 || previousMultiTouchPanPosition) {\n                    // Previous pinch data is populated but a button has been lifted\n                    // so pinch has ended.\n                    this.onMultiTouch(this._pointA, this._pointB, previousPinchSquaredDistance, 0, // pinchSquaredDistance\n                    previousMultiTouchPanPosition, null // multiTouchPanPosition\n                    );\n                    previousPinchSquaredDistance = 0;\n                    previousMultiTouchPanPosition = null;\n                }\n                this._currentActiveButton = -1;\n                this.onButtonUp(evt);\n                if (!noPreventDefault) {\n                    evt.preventDefault();\n                }\n            }\n            else if (p.type === PointerEventTypes.POINTERMOVE) {\n                if (!noPreventDefault) {\n                    evt.preventDefault();\n                }\n                // One button down\n                if (this._pointA && this._pointB === null) {\n                    const offsetX = evt.clientX - this._pointA.x;\n                    const offsetY = evt.clientY - this._pointA.y;\n                    this.onTouch(this._pointA, offsetX, offsetY);\n                    this._pointA.x = evt.clientX;\n                    this._pointA.y = evt.clientY;\n                }\n                // Two buttons down: pinch\n                else if (this._pointA && this._pointB) {\n                    const ed = this._pointA.pointerId === evt.pointerId ? this._pointA : this._pointB;\n                    ed.x = evt.clientX;\n                    ed.y = evt.clientY;\n                    const distX = this._pointA.x - this._pointB.x;\n                    const distY = this._pointA.y - this._pointB.y;\n                    const pinchSquaredDistance = distX * distX + distY * distY;\n                    const multiTouchPanPosition = {\n                        x: (this._pointA.x + this._pointB.x) / 2,\n                        y: (this._pointA.y + this._pointB.y) / 2,\n                        pointerId: evt.pointerId,\n                        type: p.type,\n                    };\n                    this.onMultiTouch(this._pointA, this._pointB, previousPinchSquaredDistance, pinchSquaredDistance, previousMultiTouchPanPosition, multiTouchPanPosition);\n                    previousMultiTouchPanPosition = multiTouchPanPosition;\n                    previousPinchSquaredDistance = pinchSquaredDistance;\n                }\n            }\n        };\n        this._observer = this.camera\n            .getScene()\n            ._inputManager._addCameraPointerObserver(this._pointerInput, PointerEventTypes.POINTERDOWN | PointerEventTypes.POINTERUP | PointerEventTypes.POINTERMOVE | PointerEventTypes.POINTERDOUBLETAP);\n        this._onLostFocus = () => {\n            this._pointA = this._pointB = null;\n            previousPinchSquaredDistance = 0;\n            previousMultiTouchPanPosition = null;\n            this.onLostFocus();\n        };\n        this._contextMenuBind = this.onContextMenu.bind(this);\n        element && element.addEventListener(\"contextmenu\", this._contextMenuBind, false);\n        const hostWindow = this.camera.getScene().getEngine().getHostWindow();\n        if (hostWindow) {\n            Tools.RegisterTopRootEvents(hostWindow, [{ name: \"blur\", handler: this._onLostFocus }]);\n        }\n    }\n    /**\n     * Detach the current controls from the specified dom element.\n     */\n    detachControl() {\n        if (this._onLostFocus) {\n            const hostWindow = this.camera.getScene().getEngine().getHostWindow();\n            if (hostWindow) {\n                Tools.UnregisterTopRootEvents(hostWindow, [{ name: \"blur\", handler: this._onLostFocus }]);\n            }\n        }\n        if (this._observer) {\n            this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer);\n            this._observer = null;\n            if (this._contextMenuBind) {\n                const inputElement = this.camera.getScene().getEngine().getInputElement();\n                inputElement && inputElement.removeEventListener(\"contextmenu\", this._contextMenuBind);\n            }\n            this._onLostFocus = null;\n        }\n        this._altKey = false;\n        this._ctrlKey = false;\n        this._metaKey = false;\n        this._shiftKey = false;\n        this._buttonsPressed = 0;\n        this._currentActiveButton = -1;\n    }\n    /**\n     * Gets the class name of the current input.\n     * @returns the class name\n     */\n    getClassName() {\n        return \"BaseCameraPointersInput\";\n    }\n    /**\n     * Get the friendly name associated with the input class.\n     * @returns the input friendly name\n     */\n    getSimpleName() {\n        return \"pointers\";\n    }\n    /**\n     * Called on pointer POINTERDOUBLETAP event.\n     * Override this method to provide functionality on POINTERDOUBLETAP event.\n     * @param type\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    onDoubleTap(type) { }\n    /**\n     * Called on pointer POINTERMOVE event if only a single touch is active.\n     * Override this method to provide functionality.\n     * @param point\n     * @param offsetX\n     * @param offsetY\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    onTouch(point, offsetX, offsetY) { }\n    /**\n     * Called on pointer POINTERMOVE event if multiple touches are active.\n     * Override this method to provide functionality.\n     * @param _pointA\n     * @param _pointB\n     * @param previousPinchSquaredDistance\n     * @param pinchSquaredDistance\n     * @param previousMultiTouchPanPosition\n     * @param multiTouchPanPosition\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    onMultiTouch(_pointA, _pointB, previousPinchSquaredDistance, pinchSquaredDistance, previousMultiTouchPanPosition, multiTouchPanPosition) { }\n    /**\n     * Called on JS contextmenu event.\n     * Override this method to provide functionality.\n     * @param evt\n     */\n    onContextMenu(evt) {\n        evt.preventDefault();\n    }\n    /**\n     * Called each time a new POINTERDOWN event occurs. Ie, for each button\n     * press.\n     * Override this method to provide functionality.\n     * @param evt\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    onButtonDown(evt) { }\n    /**\n     * Called each time a new POINTERUP event occurs. Ie, for each button\n     * release.\n     * Override this method to provide functionality.\n     * @param evt\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    onButtonUp(evt) { }\n    /**\n     * Called when window becomes inactive.\n     * Override this method to provide functionality.\n     */\n    onLostFocus() { }\n}\n__decorate([\n    serialize()\n], BaseCameraPointersInput.prototype, \"buttons\", void 0);\n//# sourceMappingURL=BaseCameraPointersInput.js.map","import { __decorate } from \"../../tslib.es6.js\";\nimport { serialize } from \"../../Misc/decorators.js\";\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager.js\";\nimport { Gamepad } from \"../../Gamepads/gamepad.js\";\n/**\n * Manage the gamepad inputs to control an arc rotate camera.\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\n */\nexport class ArcRotateCameraGamepadInput {\n    constructor() {\n        /**\n         * Defines the gamepad rotation sensibility.\n         * This is the threshold from when rotation starts to be accounted for to prevent jittering.\n         */\n        this.gamepadRotationSensibility = 80;\n        /**\n         * Defines the gamepad move sensibility.\n         * This is the threshold from when moving starts to be accounted for for to prevent jittering.\n         */\n        this.gamepadMoveSensibility = 40;\n        this._yAxisScale = 1.0;\n    }\n    /**\n     * Gets or sets a boolean indicating that Yaxis (for right stick) should be inverted\n     */\n    get invertYAxis() {\n        return this._yAxisScale !== 1.0;\n    }\n    set invertYAxis(value) {\n        this._yAxisScale = value ? -1.0 : 1.0;\n    }\n    /**\n     * Attach the input controls to a specific dom element to get the input from.\n     */\n    attachControl() {\n        const manager = this.camera.getScene().gamepadManager;\n        this._onGamepadConnectedObserver = manager.onGamepadConnectedObservable.add((gamepad) => {\n            if (gamepad.type !== Gamepad.POSE_ENABLED) {\n                // prioritize XBOX gamepads.\n                if (!this.gamepad || gamepad.type === Gamepad.XBOX) {\n                    this.gamepad = gamepad;\n                }\n            }\n        });\n        this._onGamepadDisconnectedObserver = manager.onGamepadDisconnectedObservable.add((gamepad) => {\n            if (this.gamepad === gamepad) {\n                this.gamepad = null;\n            }\n        });\n        this.gamepad = manager.getGamepadByType(Gamepad.XBOX);\n    }\n    /**\n     * Detach the current controls from the specified dom element.\n     */\n    detachControl() {\n        this.camera.getScene().gamepadManager.onGamepadConnectedObservable.remove(this._onGamepadConnectedObserver);\n        this.camera.getScene().gamepadManager.onGamepadDisconnectedObservable.remove(this._onGamepadDisconnectedObserver);\n        this.gamepad = null;\n    }\n    /**\n     * Update the current camera state depending on the inputs that have been used this frame.\n     * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.\n     */\n    checkInputs() {\n        if (this.gamepad) {\n            const camera = this.camera;\n            const rsValues = this.gamepad.rightStick;\n            if (rsValues) {\n                if (rsValues.x != 0) {\n                    const normalizedRX = rsValues.x / this.gamepadRotationSensibility;\n                    if (normalizedRX != 0 && Math.abs(normalizedRX) > 0.005) {\n                        camera.inertialAlphaOffset += normalizedRX;\n                    }\n                }\n                if (rsValues.y != 0) {\n                    const normalizedRY = (rsValues.y / this.gamepadRotationSensibility) * this._yAxisScale;\n                    if (normalizedRY != 0 && Math.abs(normalizedRY) > 0.005) {\n                        camera.inertialBetaOffset += normalizedRY;\n                    }\n                }\n            }\n            const lsValues = this.gamepad.leftStick;\n            if (lsValues && lsValues.y != 0) {\n                const normalizedLY = lsValues.y / this.gamepadMoveSensibility;\n                if (normalizedLY != 0 && Math.abs(normalizedLY) > 0.005) {\n                    this.camera.inertialRadiusOffset -= normalizedLY;\n                }\n            }\n        }\n    }\n    /**\n     * Gets the class name of the current intput.\n     * @returns the class name\n     */\n    getClassName() {\n        return \"ArcRotateCameraGamepadInput\";\n    }\n    /**\n     * Get the friendly name associated with the input class.\n     * @returns the input friendly name\n     */\n    getSimpleName() {\n        return \"gamepad\";\n    }\n}\n__decorate([\n    serialize()\n], ArcRotateCameraGamepadInput.prototype, \"gamepadRotationSensibility\", void 0);\n__decorate([\n    serialize()\n], ArcRotateCameraGamepadInput.prototype, \"gamepadMoveSensibility\", void 0);\nCameraInputTypes[\"ArcRotateCameraGamepadInput\"] = ArcRotateCameraGamepadInput;\n//# sourceMappingURL=arcRotateCameraGamepadInput.js.map","import { __decorate } from \"../../tslib.es6.js\";\nimport { serialize } from \"../../Misc/decorators.js\";\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager.js\";\nimport { KeyboardEventTypes } from \"../../Events/keyboardEvents.js\";\nimport { Tools } from \"../../Misc/tools.js\";\n/**\n * Manage the keyboard inputs to control the movement of an arc rotate camera.\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\n */\nexport class ArcRotateCameraKeyboardMoveInput {\n    constructor() {\n        /**\n         * Defines the list of key codes associated with the up action (increase alpha)\n         */\n        this.keysUp = [38];\n        /**\n         * Defines the list of key codes associated with the down action (decrease alpha)\n         */\n        this.keysDown = [40];\n        /**\n         * Defines the list of key codes associated with the left action (increase beta)\n         */\n        this.keysLeft = [37];\n        /**\n         * Defines the list of key codes associated with the right action (decrease beta)\n         */\n        this.keysRight = [39];\n        /**\n         * Defines the list of key codes associated with the reset action.\n         * Those keys reset the camera to its last stored state (with the method camera.storeState())\n         */\n        this.keysReset = [220];\n        /**\n         * Defines the panning sensibility of the inputs.\n         * (How fast is the camera panning)\n         */\n        this.panningSensibility = 50.0;\n        /**\n         * Defines the zooming sensibility of the inputs.\n         * (How fast is the camera zooming)\n         */\n        this.zoomingSensibility = 25.0;\n        /**\n         * Defines whether maintaining the alt key down switch the movement mode from\n         * orientation to zoom.\n         */\n        this.useAltToZoom = true;\n        /**\n         * Rotation speed of the camera\n         */\n        this.angularSpeed = 0.01;\n        this._keys = new Array();\n    }\n    /**\n     * Attach the input controls to a specific dom element to get the input from.\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\n     */\n    attachControl(noPreventDefault) {\n        // was there a second variable defined?\n        // eslint-disable-next-line prefer-rest-params\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\n        if (this._onCanvasBlurObserver) {\n            return;\n        }\n        this._scene = this.camera.getScene();\n        this._engine = this._scene.getEngine();\n        this._onCanvasBlurObserver = this._engine.onCanvasBlurObservable.add(() => {\n            this._keys.length = 0;\n        });\n        this._onKeyboardObserver = this._scene.onKeyboardObservable.add((info) => {\n            const evt = info.event;\n            if (!evt.metaKey) {\n                if (info.type === KeyboardEventTypes.KEYDOWN) {\n                    this._ctrlPressed = evt.ctrlKey;\n                    this._altPressed = evt.altKey;\n                    if (this.keysUp.indexOf(evt.keyCode) !== -1 ||\n                        this.keysDown.indexOf(evt.keyCode) !== -1 ||\n                        this.keysLeft.indexOf(evt.keyCode) !== -1 ||\n                        this.keysRight.indexOf(evt.keyCode) !== -1 ||\n                        this.keysReset.indexOf(evt.keyCode) !== -1) {\n                        const index = this._keys.indexOf(evt.keyCode);\n                        if (index === -1) {\n                            this._keys.push(evt.keyCode);\n                        }\n                        if (evt.preventDefault) {\n                            if (!noPreventDefault) {\n                                evt.preventDefault();\n                            }\n                        }\n                    }\n                }\n                else {\n                    if (this.keysUp.indexOf(evt.keyCode) !== -1 ||\n                        this.keysDown.indexOf(evt.keyCode) !== -1 ||\n                        this.keysLeft.indexOf(evt.keyCode) !== -1 ||\n                        this.keysRight.indexOf(evt.keyCode) !== -1 ||\n                        this.keysReset.indexOf(evt.keyCode) !== -1) {\n                        const index = this._keys.indexOf(evt.keyCode);\n                        if (index >= 0) {\n                            this._keys.splice(index, 1);\n                        }\n                        if (evt.preventDefault) {\n                            if (!noPreventDefault) {\n                                evt.preventDefault();\n                            }\n                        }\n                    }\n                }\n            }\n        });\n    }\n    /**\n     * Detach the current controls from the specified dom element.\n     */\n    detachControl() {\n        if (this._scene) {\n            if (this._onKeyboardObserver) {\n                this._scene.onKeyboardObservable.remove(this._onKeyboardObserver);\n            }\n            if (this._onCanvasBlurObserver) {\n                this._engine.onCanvasBlurObservable.remove(this._onCanvasBlurObserver);\n            }\n            this._onKeyboardObserver = null;\n            this._onCanvasBlurObserver = null;\n        }\n        this._keys.length = 0;\n    }\n    /**\n     * Update the current camera state depending on the inputs that have been used this frame.\n     * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.\n     */\n    checkInputs() {\n        if (this._onKeyboardObserver) {\n            const camera = this.camera;\n            for (let index = 0; index < this._keys.length; index++) {\n                const keyCode = this._keys[index];\n                if (this.keysLeft.indexOf(keyCode) !== -1) {\n                    if (this._ctrlPressed && this.camera._useCtrlForPanning) {\n                        camera.inertialPanningX -= 1 / this.panningSensibility;\n                    }\n                    else {\n                        camera.inertialAlphaOffset -= this.angularSpeed;\n                    }\n                }\n                else if (this.keysUp.indexOf(keyCode) !== -1) {\n                    if (this._ctrlPressed && this.camera._useCtrlForPanning) {\n                        camera.inertialPanningY += 1 / this.panningSensibility;\n                    }\n                    else if (this._altPressed && this.useAltToZoom) {\n                        camera.inertialRadiusOffset += 1 / this.zoomingSensibility;\n                    }\n                    else {\n                        camera.inertialBetaOffset -= this.angularSpeed;\n                    }\n                }\n                else if (this.keysRight.indexOf(keyCode) !== -1) {\n                    if (this._ctrlPressed && this.camera._useCtrlForPanning) {\n                        camera.inertialPanningX += 1 / this.panningSensibility;\n                    }\n                    else {\n                        camera.inertialAlphaOffset += this.angularSpeed;\n                    }\n                }\n                else if (this.keysDown.indexOf(keyCode) !== -1) {\n                    if (this._ctrlPressed && this.camera._useCtrlForPanning) {\n                        camera.inertialPanningY -= 1 / this.panningSensibility;\n                    }\n                    else if (this._altPressed && this.useAltToZoom) {\n                        camera.inertialRadiusOffset -= 1 / this.zoomingSensibility;\n                    }\n                    else {\n                        camera.inertialBetaOffset += this.angularSpeed;\n                    }\n                }\n                else if (this.keysReset.indexOf(keyCode) !== -1) {\n                    if (camera.useInputToRestoreState) {\n                        camera.restoreState();\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * Gets the class name of the current input.\n     * @returns the class name\n     */\n    getClassName() {\n        return \"ArcRotateCameraKeyboardMoveInput\";\n    }\n    /**\n     * Get the friendly name associated with the input class.\n     * @returns the input friendly name\n     */\n    getSimpleName() {\n        return \"keyboard\";\n    }\n}\n__decorate([\n    serialize()\n], ArcRotateCameraKeyboardMoveInput.prototype, \"keysUp\", void 0);\n__decorate([\n    serialize()\n], ArcRotateCameraKeyboardMoveInput.prototype, \"keysDown\", void 0);\n__decorate([\n    serialize()\n], ArcRotateCameraKeyboardMoveInput.prototype, \"keysLeft\", void 0);\n__decorate([\n    serialize()\n], ArcRotateCameraKeyboardMoveInput.prototype, \"keysRight\", void 0);\n__decorate([\n    serialize()\n], ArcRotateCameraKeyboardMoveInput.prototype, \"keysReset\", void 0);\n__decorate([\n    serialize()\n], ArcRotateCameraKeyboardMoveInput.prototype, \"panningSensibility\", void 0);\n__decorate([\n    serialize()\n], ArcRotateCameraKeyboardMoveInput.prototype, \"zoomingSensibility\", void 0);\n__decorate([\n    serialize()\n], ArcRotateCameraKeyboardMoveInput.prototype, \"useAltToZoom\", void 0);\n__decorate([\n    serialize()\n], ArcRotateCameraKeyboardMoveInput.prototype, \"angularSpeed\", void 0);\nCameraInputTypes[\"ArcRotateCameraKeyboardMoveInput\"] = ArcRotateCameraKeyboardMoveInput;\n//# sourceMappingURL=arcRotateCameraKeyboardMoveInput.js.map","import { __decorate } from \"../../tslib.es6.js\";\nimport { serialize } from \"../../Misc/decorators.js\";\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager.js\";\nimport { PointerEventTypes } from \"../../Events/pointerEvents.js\";\nimport { Plane } from \"../../Maths/math.plane.js\";\nimport { Vector3, Matrix, TmpVectors } from \"../../Maths/math.vector.js\";\nimport { Epsilon } from \"../../Maths/math.constants.js\";\nimport { EventConstants } from \"../../Events/deviceInputEvents.js\";\nimport { Scalar } from \"../../Maths/math.scalar.js\";\nimport { Tools } from \"../../Misc/tools.js\";\n/**\n * Firefox uses a different scheme to report scroll distances to other\n * browsers. Rather than use complicated methods to calculate the exact\n * multiple we need to apply, let's just cheat and use a constant.\n * https://developer.mozilla.org/en-US/docs/Web/API/WheelEvent/deltaMode\n * https://stackoverflow.com/questions/20110224/what-is-the-height-of-a-line-in-a-wheel-event-deltamode-dom-delta-line\n */\nconst ffMultiplier = 40;\n/**\n * Manage the mouse wheel inputs to control an arc rotate camera.\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\n */\nexport class ArcRotateCameraMouseWheelInput {\n    constructor() {\n        /**\n         * Gets or Set the mouse wheel precision or how fast is the camera zooming.\n         */\n        this.wheelPrecision = 3.0;\n        /**\n         * Gets or Set the boolean value that controls whether or not the mouse wheel\n         * zooms to the location of the mouse pointer or not.  The default is false.\n         */\n        this.zoomToMouseLocation = false;\n        /**\n         * wheelDeltaPercentage will be used instead of wheelPrecision if different from 0.\n         * It defines the percentage of current camera.radius to use as delta when wheel is used.\n         */\n        this.wheelDeltaPercentage = 0;\n        /**\n         * If set, this function will be used to set the radius delta that will be added to the current camera radius\n         */\n        this.customComputeDeltaFromMouseWheel = null;\n        this._inertialPanning = Vector3.Zero();\n    }\n    _computeDeltaFromMouseWheelLegacyEvent(mouseWheelDelta, radius) {\n        let delta = 0;\n        const wheelDelta = mouseWheelDelta * 0.01 * this.wheelDeltaPercentage * radius;\n        if (mouseWheelDelta > 0) {\n            delta = wheelDelta / (1.0 + this.wheelDeltaPercentage);\n        }\n        else {\n            delta = wheelDelta * (1.0 + this.wheelDeltaPercentage);\n        }\n        return delta;\n    }\n    /**\n     * Attach the input controls to a specific dom element to get the input from.\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\n     */\n    attachControl(noPreventDefault) {\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\n        this._wheel = (p) => {\n            //sanity check - this should be a PointerWheel event.\n            if (p.type !== PointerEventTypes.POINTERWHEEL) {\n                return;\n            }\n            const event = p.event;\n            let delta = 0;\n            const platformScale = event.deltaMode === EventConstants.DOM_DELTA_LINE ? ffMultiplier : 1; // If this happens to be set to DOM_DELTA_LINE, adjust accordingly\n            const wheelDelta = -(event.deltaY * platformScale);\n            if (this.customComputeDeltaFromMouseWheel) {\n                delta = this.customComputeDeltaFromMouseWheel(wheelDelta, this, event);\n            }\n            else {\n                if (this.wheelDeltaPercentage) {\n                    delta = this._computeDeltaFromMouseWheelLegacyEvent(wheelDelta, this.camera.radius);\n                    // If zooming in, estimate the target radius and use that to compute the delta for inertia\n                    // this will stop multiple scroll events zooming in from adding too much inertia\n                    if (delta > 0) {\n                        let estimatedTargetRadius = this.camera.radius;\n                        let targetInertia = this.camera.inertialRadiusOffset + delta;\n                        for (let i = 0; i < 20 && Math.abs(targetInertia) > 0.001; i++) {\n                            estimatedTargetRadius -= targetInertia;\n                            targetInertia *= this.camera.inertia;\n                        }\n                        estimatedTargetRadius = Scalar.Clamp(estimatedTargetRadius, 0, Number.MAX_VALUE);\n                        delta = this._computeDeltaFromMouseWheelLegacyEvent(wheelDelta, estimatedTargetRadius);\n                    }\n                }\n                else {\n                    delta = wheelDelta / (this.wheelPrecision * 40);\n                }\n            }\n            if (delta) {\n                if (this.zoomToMouseLocation && this._hitPlane) {\n                    this._zoomToMouse(delta);\n                }\n                else {\n                    this.camera.inertialRadiusOffset += delta;\n                }\n            }\n            if (event.preventDefault) {\n                if (!noPreventDefault) {\n                    event.preventDefault();\n                }\n            }\n        };\n        this._observer = this.camera.getScene()._inputManager._addCameraPointerObserver(this._wheel, PointerEventTypes.POINTERWHEEL);\n        if (this.zoomToMouseLocation) {\n            this._inertialPanning.setAll(0);\n        }\n    }\n    /**\n     * Detach the current controls from the specified dom element.\n     */\n    detachControl() {\n        if (this._observer) {\n            this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer);\n            this._observer = null;\n            this._wheel = null;\n        }\n    }\n    /**\n     * Update the current camera state depending on the inputs that have been used this frame.\n     * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.\n     */\n    checkInputs() {\n        if (!this.zoomToMouseLocation) {\n            return;\n        }\n        const camera = this.camera;\n        const motion = 0.0 + camera.inertialAlphaOffset + camera.inertialBetaOffset + camera.inertialRadiusOffset;\n        if (motion) {\n            // if zooming is still happening as a result of inertia, then we also need to update\n            // the hit plane.\n            this._updateHitPlane();\n            // Note we cannot  use arcRotateCamera.inertialPlanning here because arcRotateCamera panning\n            // uses a different panningInertia which could cause this panning to get out of sync with\n            // the zooming, and for this to work they must be exactly in sync.\n            camera.target.addInPlace(this._inertialPanning);\n            this._inertialPanning.scaleInPlace(camera.inertia);\n            this._zeroIfClose(this._inertialPanning);\n        }\n    }\n    /**\n     * Gets the class name of the current input.\n     * @returns the class name\n     */\n    getClassName() {\n        return \"ArcRotateCameraMouseWheelInput\";\n    }\n    /**\n     * Get the friendly name associated with the input class.\n     * @returns the input friendly name\n     */\n    getSimpleName() {\n        return \"mousewheel\";\n    }\n    _updateHitPlane() {\n        const camera = this.camera;\n        const direction = camera.target.subtract(camera.position);\n        this._hitPlane = Plane.FromPositionAndNormal(camera.target, direction);\n    }\n    // Get position on the hit plane\n    _getPosition() {\n        var _a;\n        const camera = this.camera;\n        const scene = camera.getScene();\n        // since the _hitPlane is always updated to be orthogonal to the camera position vector\n        // we don't have to worry about this ray shooting off to infinity. This ray creates\n        // a vector defining where we want to zoom to.\n        const ray = scene.createPickingRay(scene.pointerX, scene.pointerY, Matrix.Identity(), camera, false);\n        let distance = 0;\n        if (this._hitPlane) {\n            distance = (_a = ray.intersectsPlane(this._hitPlane)) !== null && _a !== void 0 ? _a : 0;\n        }\n        // not using this ray again, so modifying its vectors here is fine\n        return ray.origin.addInPlace(ray.direction.scaleInPlace(distance));\n    }\n    _zoomToMouse(delta) {\n        var _a, _b;\n        const camera = this.camera;\n        const inertiaComp = 1 - camera.inertia;\n        if (camera.lowerRadiusLimit) {\n            const lowerLimit = (_a = camera.lowerRadiusLimit) !== null && _a !== void 0 ? _a : 0;\n            if (camera.radius - (camera.inertialRadiusOffset + delta) / inertiaComp < lowerLimit) {\n                delta = (camera.radius - lowerLimit) * inertiaComp - camera.inertialRadiusOffset;\n            }\n        }\n        if (camera.upperRadiusLimit) {\n            const upperLimit = (_b = camera.upperRadiusLimit) !== null && _b !== void 0 ? _b : 0;\n            if (camera.radius - (camera.inertialRadiusOffset + delta) / inertiaComp > upperLimit) {\n                delta = (camera.radius - upperLimit) * inertiaComp - camera.inertialRadiusOffset;\n            }\n        }\n        const zoomDistance = delta / inertiaComp;\n        const ratio = zoomDistance / camera.radius;\n        const vec = this._getPosition();\n        // Now this vector tells us how much we also need to pan the camera\n        // so the targeted mouse location becomes the center of zooming.\n        const directionToZoomLocation = TmpVectors.Vector3[6];\n        vec.subtractToRef(camera.target, directionToZoomLocation);\n        directionToZoomLocation.scaleInPlace(ratio);\n        directionToZoomLocation.scaleInPlace(inertiaComp);\n        this._inertialPanning.addInPlace(directionToZoomLocation);\n        camera.inertialRadiusOffset += delta;\n    }\n    // Sets x y or z of passed in vector to zero if less than Epsilon.\n    _zeroIfClose(vec) {\n        if (Math.abs(vec.x) < Epsilon) {\n            vec.x = 0;\n        }\n        if (Math.abs(vec.y) < Epsilon) {\n            vec.y = 0;\n        }\n        if (Math.abs(vec.z) < Epsilon) {\n            vec.z = 0;\n        }\n    }\n}\n__decorate([\n    serialize()\n], ArcRotateCameraMouseWheelInput.prototype, \"wheelPrecision\", void 0);\n__decorate([\n    serialize()\n], ArcRotateCameraMouseWheelInput.prototype, \"zoomToMouseLocation\", void 0);\n__decorate([\n    serialize()\n], ArcRotateCameraMouseWheelInput.prototype, \"wheelDeltaPercentage\", void 0);\nCameraInputTypes[\"ArcRotateCameraMouseWheelInput\"] = ArcRotateCameraMouseWheelInput;\n//# sourceMappingURL=arcRotateCameraMouseWheelInput.js.map","import { __decorate } from \"../../tslib.es6.js\";\nimport { serialize } from \"../../Misc/decorators.js\";\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager.js\";\nimport { BaseCameraPointersInput } from \"../../Cameras/Inputs/BaseCameraPointersInput.js\";\n/**\n * Manage the pointers inputs to control an arc rotate camera.\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\n */\nexport class ArcRotateCameraPointersInput extends BaseCameraPointersInput {\n    constructor() {\n        super(...arguments);\n        /**\n         * Defines the buttons associated with the input to handle camera move.\n         */\n        this.buttons = [0, 1, 2];\n        /**\n         * Defines the pointer angular sensibility  along the X axis or how fast is\n         * the camera rotating.\n         */\n        this.angularSensibilityX = 1000.0;\n        /**\n         * Defines the pointer angular sensibility along the Y axis or how fast is\n         * the camera rotating.\n         */\n        this.angularSensibilityY = 1000.0;\n        /**\n         * Defines the pointer pinch precision or how fast is the camera zooming.\n         */\n        this.pinchPrecision = 12.0;\n        /**\n         * pinchDeltaPercentage will be used instead of pinchPrecision if different\n         * from 0.\n         * It defines the percentage of current camera.radius to use as delta when\n         * pinch zoom is used.\n         */\n        this.pinchDeltaPercentage = 0;\n        /**\n         * When useNaturalPinchZoom is true, multi touch zoom will zoom in such\n         * that any object in the plane at the camera's target point will scale\n         * perfectly with finger motion.\n         * Overrides pinchDeltaPercentage and pinchPrecision.\n         */\n        this.useNaturalPinchZoom = false;\n        /**\n         * Defines whether zoom (2 fingers pinch) is enabled through multitouch\n         */\n        this.pinchZoom = true;\n        /**\n         * Defines the pointer panning sensibility or how fast is the camera moving.\n         */\n        this.panningSensibility = 1000.0;\n        /**\n         * Defines whether panning (2 fingers swipe) is enabled through multitouch.\n         */\n        this.multiTouchPanning = true;\n        /**\n         * Defines whether panning is enabled for both pan (2 fingers swipe) and\n         * zoom (pinch) through multitouch.\n         */\n        this.multiTouchPanAndZoom = true;\n        /**\n         * Revers pinch action direction.\n         */\n        this.pinchInwards = true;\n        this._isPanClick = false;\n        this._twoFingerActivityCount = 0;\n        this._isPinching = false;\n    }\n    /**\n     * Gets the class name of the current input.\n     * @returns the class name\n     */\n    getClassName() {\n        return \"ArcRotateCameraPointersInput\";\n    }\n    /**\n     * Move camera from multi touch panning positions.\n     * @param previousMultiTouchPanPosition\n     * @param multiTouchPanPosition\n     */\n    _computeMultiTouchPanning(previousMultiTouchPanPosition, multiTouchPanPosition) {\n        if (this.panningSensibility !== 0 && previousMultiTouchPanPosition && multiTouchPanPosition) {\n            const moveDeltaX = multiTouchPanPosition.x - previousMultiTouchPanPosition.x;\n            const moveDeltaY = multiTouchPanPosition.y - previousMultiTouchPanPosition.y;\n            this.camera.inertialPanningX += -moveDeltaX / this.panningSensibility;\n            this.camera.inertialPanningY += moveDeltaY / this.panningSensibility;\n        }\n    }\n    /**\n     * Move camera from pinch zoom distances.\n     * @param previousPinchSquaredDistance\n     * @param pinchSquaredDistance\n     */\n    _computePinchZoom(previousPinchSquaredDistance, pinchSquaredDistance) {\n        const radius = this.camera.radius || ArcRotateCameraPointersInput.MinimumRadiusForPinch;\n        if (this.useNaturalPinchZoom) {\n            this.camera.radius = (radius * Math.sqrt(previousPinchSquaredDistance)) / Math.sqrt(pinchSquaredDistance);\n        }\n        else if (this.pinchDeltaPercentage) {\n            this.camera.inertialRadiusOffset += (pinchSquaredDistance - previousPinchSquaredDistance) * 0.001 * radius * this.pinchDeltaPercentage;\n        }\n        else {\n            this.camera.inertialRadiusOffset +=\n                (pinchSquaredDistance - previousPinchSquaredDistance) /\n                    ((this.pinchPrecision * (this.pinchInwards ? 1 : -1) * (this.angularSensibilityX + this.angularSensibilityY)) / 2);\n        }\n    }\n    /**\n     * Called on pointer POINTERMOVE event if only a single touch is active.\n     * @param point\n     * @param offsetX\n     * @param offsetY\n     */\n    onTouch(point, offsetX, offsetY) {\n        if (this.panningSensibility !== 0 && ((this._ctrlKey && this.camera._useCtrlForPanning) || this._isPanClick)) {\n            this.camera.inertialPanningX += -offsetX / this.panningSensibility;\n            this.camera.inertialPanningY += offsetY / this.panningSensibility;\n        }\n        else {\n            this.camera.inertialAlphaOffset -= offsetX / this.angularSensibilityX;\n            this.camera.inertialBetaOffset -= offsetY / this.angularSensibilityY;\n        }\n    }\n    /**\n     * Called on pointer POINTERDOUBLETAP event.\n     */\n    onDoubleTap() {\n        if (this.camera.useInputToRestoreState) {\n            this.camera.restoreState();\n        }\n    }\n    /**\n     * Called on pointer POINTERMOVE event if multiple touches are active.\n     * @param pointA\n     * @param pointB\n     * @param previousPinchSquaredDistance\n     * @param pinchSquaredDistance\n     * @param previousMultiTouchPanPosition\n     * @param multiTouchPanPosition\n     */\n    onMultiTouch(pointA, pointB, previousPinchSquaredDistance, pinchSquaredDistance, previousMultiTouchPanPosition, multiTouchPanPosition) {\n        if (previousPinchSquaredDistance === 0 && previousMultiTouchPanPosition === null) {\n            // First time this method is called for new pinch.\n            // Next time this is called there will be a\n            // previousPinchSquaredDistance and pinchSquaredDistance to compare.\n            return;\n        }\n        if (pinchSquaredDistance === 0 && multiTouchPanPosition === null) {\n            // Last time this method is called at the end of a pinch.\n            return;\n        }\n        // Zoom and panning enabled together\n        if (this.multiTouchPanAndZoom) {\n            this._computePinchZoom(previousPinchSquaredDistance, pinchSquaredDistance);\n            this._computeMultiTouchPanning(previousMultiTouchPanPosition, multiTouchPanPosition);\n            // Zoom and panning enabled but only one at a time\n        }\n        else if (this.multiTouchPanning && this.pinchZoom) {\n            this._twoFingerActivityCount++;\n            if (this._isPinching ||\n                (this._twoFingerActivityCount < 20 && Math.abs(Math.sqrt(pinchSquaredDistance) - Math.sqrt(previousPinchSquaredDistance)) > this.camera.pinchToPanMaxDistance)) {\n                // Since pinch has not been active long, assume we intend to zoom.\n                this._computePinchZoom(previousPinchSquaredDistance, pinchSquaredDistance);\n                // Since we are pinching, remain pinching on next iteration.\n                this._isPinching = true;\n            }\n            else {\n                // Pause between pinch starting and moving implies not a zoom event. Pan instead.\n                this._computeMultiTouchPanning(previousMultiTouchPanPosition, multiTouchPanPosition);\n            }\n            // Panning enabled, zoom disabled\n        }\n        else if (this.multiTouchPanning) {\n            this._computeMultiTouchPanning(previousMultiTouchPanPosition, multiTouchPanPosition);\n            // Zoom enabled, panning disabled\n        }\n        else if (this.pinchZoom) {\n            this._computePinchZoom(previousPinchSquaredDistance, pinchSquaredDistance);\n        }\n    }\n    /**\n     * Called each time a new POINTERDOWN event occurs. Ie, for each button\n     * press.\n     * @param evt\n     */\n    onButtonDown(evt) {\n        this._isPanClick = evt.button === this.camera._panningMouseButton;\n    }\n    /**\n     * Called each time a new POINTERUP event occurs. Ie, for each button\n     * release.\n     */\n    onButtonUp() {\n        this._twoFingerActivityCount = 0;\n        this._isPinching = false;\n    }\n    /**\n     * Called when window becomes inactive.\n     */\n    onLostFocus() {\n        this._isPanClick = false;\n        this._twoFingerActivityCount = 0;\n        this._isPinching = false;\n    }\n}\n/**\n * The minimum radius used for pinch, to avoid radius lock at 0\n */\nArcRotateCameraPointersInput.MinimumRadiusForPinch = 0.001;\n__decorate([\n    serialize()\n], ArcRotateCameraPointersInput.prototype, \"buttons\", void 0);\n__decorate([\n    serialize()\n], ArcRotateCameraPointersInput.prototype, \"angularSensibilityX\", void 0);\n__decorate([\n    serialize()\n], ArcRotateCameraPointersInput.prototype, \"angularSensibilityY\", void 0);\n__decorate([\n    serialize()\n], ArcRotateCameraPointersInput.prototype, \"pinchPrecision\", void 0);\n__decorate([\n    serialize()\n], ArcRotateCameraPointersInput.prototype, \"pinchDeltaPercentage\", void 0);\n__decorate([\n    serialize()\n], ArcRotateCameraPointersInput.prototype, \"useNaturalPinchZoom\", void 0);\n__decorate([\n    serialize()\n], ArcRotateCameraPointersInput.prototype, \"pinchZoom\", void 0);\n__decorate([\n    serialize()\n], ArcRotateCameraPointersInput.prototype, \"panningSensibility\", void 0);\n__decorate([\n    serialize()\n], ArcRotateCameraPointersInput.prototype, \"multiTouchPanning\", void 0);\n__decorate([\n    serialize()\n], ArcRotateCameraPointersInput.prototype, \"multiTouchPanAndZoom\", void 0);\nCameraInputTypes[\"ArcRotateCameraPointersInput\"] = ArcRotateCameraPointersInput;\n//# sourceMappingURL=arcRotateCameraPointersInput.js.map","import { CameraInputTypes } from \"../../Cameras/cameraInputsManager.js\";\nimport { Quaternion } from \"../../Maths/math.vector.js\";\nimport { Tools } from \"../../Misc/tools.js\";\nimport { FreeCameraInputsManager } from \"../../Cameras/freeCameraInputsManager.js\";\nimport { Observable } from \"../../Misc/observable.js\";\n/**\n * Add orientation input support to the input manager.\n * @param smoothFactor deviceOrientation smoothing. 0: no smoothing, 1: new data ignored, 0.9 recommended for smoothing\n * @returns the current input manager\n */\nFreeCameraInputsManager.prototype.addDeviceOrientation = function (smoothFactor) {\n    if (!this._deviceOrientationInput) {\n        this._deviceOrientationInput = new FreeCameraDeviceOrientationInput();\n        if (smoothFactor) {\n            this._deviceOrientationInput.smoothFactor = smoothFactor;\n        }\n        this.add(this._deviceOrientationInput);\n    }\n    return this;\n};\n/**\n * Takes information about the orientation of the device as reported by the deviceorientation event to orient the camera.\n * Screen rotation is taken into account.\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\n */\nexport class FreeCameraDeviceOrientationInput {\n    /**\n     * Can be used to detect if a device orientation sensor is available on a device\n     * @param timeout amount of time in milliseconds to wait for a response from the sensor (default: infinite)\n     * @returns a promise that will resolve on orientation change\n     */\n    static WaitForOrientationChangeAsync(timeout) {\n        return new Promise((res, rej) => {\n            let gotValue = false;\n            const eventHandler = () => {\n                window.removeEventListener(\"deviceorientation\", eventHandler);\n                gotValue = true;\n                res();\n            };\n            // If timeout is populated reject the promise\n            if (timeout) {\n                setTimeout(() => {\n                    if (!gotValue) {\n                        window.removeEventListener(\"deviceorientation\", eventHandler);\n                        rej(\"WaitForOrientationChangeAsync timed out\");\n                    }\n                }, timeout);\n            }\n            if (typeof DeviceOrientationEvent !== \"undefined\" && typeof DeviceOrientationEvent.requestPermission === \"function\") {\n                DeviceOrientationEvent\n                    .requestPermission()\n                    .then((response) => {\n                    if (response == \"granted\") {\n                        window.addEventListener(\"deviceorientation\", eventHandler);\n                    }\n                    else {\n                        Tools.Warn(\"Permission not granted.\");\n                    }\n                })\n                    .catch((error) => {\n                    Tools.Error(error);\n                });\n            }\n            else {\n                window.addEventListener(\"deviceorientation\", eventHandler);\n            }\n        });\n    }\n    /**\n     * Instantiates a new input\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\n     */\n    constructor() {\n        this._screenOrientationAngle = 0;\n        this._screenQuaternion = new Quaternion();\n        this._alpha = 0;\n        this._beta = 0;\n        this._gamma = 0;\n        /** alpha+beta+gamma smoothing. 0: no smoothing, 1: new data ignored, 0.9 recommended for smoothing */\n        this.smoothFactor = 0;\n        /**\n         * @internal\n         */\n        this._onDeviceOrientationChangedObservable = new Observable();\n        this._orientationChanged = () => {\n            this._screenOrientationAngle =\n                window.orientation !== undefined\n                    ? +window.orientation\n                    : window.screen.orientation && window.screen.orientation[\"angle\"]\n                        ? window.screen.orientation.angle\n                        : 0;\n            this._screenOrientationAngle = -Tools.ToRadians(this._screenOrientationAngle / 2);\n            this._screenQuaternion.copyFromFloats(0, Math.sin(this._screenOrientationAngle), 0, Math.cos(this._screenOrientationAngle));\n        };\n        this._deviceOrientation = (evt) => {\n            if (this.smoothFactor) {\n                this._alpha = evt.alpha !== null ? Tools.SmoothAngleChange(this._alpha, evt.alpha, this.smoothFactor) : 0;\n                this._beta = evt.beta !== null ? Tools.SmoothAngleChange(this._beta, evt.beta, this.smoothFactor) : 0;\n                this._gamma = evt.gamma !== null ? Tools.SmoothAngleChange(this._gamma, evt.gamma, this.smoothFactor) : 0;\n            }\n            else {\n                this._alpha = evt.alpha !== null ? evt.alpha : 0;\n                this._beta = evt.beta !== null ? evt.beta : 0;\n                this._gamma = evt.gamma !== null ? evt.gamma : 0;\n            }\n            if (evt.alpha !== null) {\n                this._onDeviceOrientationChangedObservable.notifyObservers();\n            }\n        };\n        this._constantTranform = new Quaternion(-Math.sqrt(0.5), 0, 0, Math.sqrt(0.5));\n        this._orientationChanged();\n    }\n    /**\n     * Define the camera controlled by the input.\n     */\n    get camera() {\n        return this._camera;\n    }\n    set camera(camera) {\n        this._camera = camera;\n        if (this._camera != null && !this._camera.rotationQuaternion) {\n            this._camera.rotationQuaternion = new Quaternion();\n        }\n        if (this._camera) {\n            this._camera.onDisposeObservable.add(() => {\n                this._onDeviceOrientationChangedObservable.clear();\n            });\n        }\n    }\n    /**\n     * Attach the input controls to a specific dom element to get the input from.\n     */\n    attachControl() {\n        const hostWindow = this.camera.getScene().getEngine().getHostWindow();\n        if (hostWindow) {\n            const eventHandler = () => {\n                hostWindow.addEventListener(\"orientationchange\", this._orientationChanged);\n                hostWindow.addEventListener(\"deviceorientation\", this._deviceOrientation);\n                //In certain cases, the attach control is called AFTER orientation was changed,\n                //So this is needed.\n                this._orientationChanged();\n            };\n            if (typeof DeviceOrientationEvent !== \"undefined\" && typeof DeviceOrientationEvent.requestPermission === \"function\") {\n                DeviceOrientationEvent\n                    .requestPermission()\n                    .then((response) => {\n                    if (response === \"granted\") {\n                        eventHandler();\n                    }\n                    else {\n                        Tools.Warn(\"Permission not granted.\");\n                    }\n                })\n                    .catch((error) => {\n                    Tools.Error(error);\n                });\n            }\n            else {\n                eventHandler();\n            }\n        }\n    }\n    /**\n     * Detach the current controls from the specified dom element.\n     */\n    detachControl() {\n        window.removeEventListener(\"orientationchange\", this._orientationChanged);\n        window.removeEventListener(\"deviceorientation\", this._deviceOrientation);\n        this._alpha = 0;\n    }\n    /**\n     * Update the current camera state depending on the inputs that have been used this frame.\n     * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.\n     */\n    checkInputs() {\n        //if no device orientation provided, don't update the rotation.\n        //Only testing against alpha under the assumption thatnorientation will never be so exact when set.\n        if (!this._alpha) {\n            return;\n        }\n        Quaternion.RotationYawPitchRollToRef(Tools.ToRadians(this._alpha), Tools.ToRadians(this._beta), -Tools.ToRadians(this._gamma), this.camera.rotationQuaternion);\n        this._camera.rotationQuaternion.multiplyInPlace(this._screenQuaternion);\n        this._camera.rotationQuaternion.multiplyInPlace(this._constantTranform);\n        //Mirror on XY Plane\n        this._camera.rotationQuaternion.z *= -1;\n        this._camera.rotationQuaternion.w *= -1;\n    }\n    /**\n     * Gets the class name of the current input.\n     * @returns the class name\n     */\n    getClassName() {\n        return \"FreeCameraDeviceOrientationInput\";\n    }\n    /**\n     * Get the friendly name associated with the input class.\n     * @returns the input friendly name\n     */\n    getSimpleName() {\n        return \"deviceOrientation\";\n    }\n}\nCameraInputTypes[\"FreeCameraDeviceOrientationInput\"] = FreeCameraDeviceOrientationInput;\n//# sourceMappingURL=freeCameraDeviceOrientationInput.js.map","import { __decorate } from \"../../tslib.es6.js\";\nimport { serialize } from \"../../Misc/decorators.js\";\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager.js\";\nimport { Matrix, Vector3, Vector2 } from \"../../Maths/math.vector.js\";\nimport { Gamepad } from \"../../Gamepads/gamepad.js\";\n/**\n * Manage the gamepad inputs to control a free camera.\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\n */\nexport class FreeCameraGamepadInput {\n    constructor() {\n        /**\n         * Defines the gamepad rotation sensibility.\n         * This is the threshold from when rotation starts to be accounted for to prevent jittering.\n         */\n        this.gamepadAngularSensibility = 200;\n        /**\n         * Defines the gamepad move sensibility.\n         * This is the threshold from when moving starts to be accounted for for to prevent jittering.\n         */\n        this.gamepadMoveSensibility = 40;\n        /**\n         * Defines the minimum value at which any analog stick input is ignored.\n         * Note: This value should only be a value between 0 and 1.\n         */\n        this.deadzoneDelta = 0.1;\n        this._yAxisScale = 1.0;\n        this._cameraTransform = Matrix.Identity();\n        this._deltaTransform = Vector3.Zero();\n        this._vector3 = Vector3.Zero();\n        this._vector2 = Vector2.Zero();\n    }\n    /**\n     * Gets or sets a boolean indicating that Yaxis (for right stick) should be inverted\n     */\n    get invertYAxis() {\n        return this._yAxisScale !== 1.0;\n    }\n    set invertYAxis(value) {\n        this._yAxisScale = value ? -1.0 : 1.0;\n    }\n    /**\n     * Attach the input controls to a specific dom element to get the input from.\n     */\n    attachControl() {\n        const manager = this.camera.getScene().gamepadManager;\n        this._onGamepadConnectedObserver = manager.onGamepadConnectedObservable.add((gamepad) => {\n            if (gamepad.type !== Gamepad.POSE_ENABLED) {\n                // prioritize XBOX gamepads.\n                if (!this.gamepad || gamepad.type === Gamepad.XBOX) {\n                    this.gamepad = gamepad;\n                }\n            }\n        });\n        this._onGamepadDisconnectedObserver = manager.onGamepadDisconnectedObservable.add((gamepad) => {\n            if (this.gamepad === gamepad) {\n                this.gamepad = null;\n            }\n        });\n        // check if there are already other controllers connected\n        this.gamepad = manager.getGamepadByType(Gamepad.XBOX);\n        // if no xbox controller was found, but there are gamepad controllers, take the first one\n        if (!this.gamepad && manager.gamepads.length) {\n            this.gamepad = manager.gamepads[0];\n        }\n    }\n    /**\n     * Detach the current controls from the specified dom element.\n     */\n    detachControl() {\n        this.camera.getScene().gamepadManager.onGamepadConnectedObservable.remove(this._onGamepadConnectedObserver);\n        this.camera.getScene().gamepadManager.onGamepadDisconnectedObservable.remove(this._onGamepadDisconnectedObserver);\n        this.gamepad = null;\n    }\n    /**\n     * Update the current camera state depending on the inputs that have been used this frame.\n     * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.\n     */\n    checkInputs() {\n        if (this.gamepad && this.gamepad.leftStick) {\n            const camera = this.camera;\n            const lsValues = this.gamepad.leftStick;\n            if (this.gamepadMoveSensibility !== 0) {\n                lsValues.x = Math.abs(lsValues.x) > this.deadzoneDelta ? lsValues.x / this.gamepadMoveSensibility : 0;\n                lsValues.y = Math.abs(lsValues.y) > this.deadzoneDelta ? lsValues.y / this.gamepadMoveSensibility : 0;\n            }\n            let rsValues = this.gamepad.rightStick;\n            if (rsValues && this.gamepadAngularSensibility !== 0) {\n                rsValues.x = Math.abs(rsValues.x) > this.deadzoneDelta ? rsValues.x / this.gamepadAngularSensibility : 0;\n                rsValues.y = (Math.abs(rsValues.y) > this.deadzoneDelta ? rsValues.y / this.gamepadAngularSensibility : 0) * this._yAxisScale;\n            }\n            else {\n                rsValues = { x: 0, y: 0 };\n            }\n            if (!camera.rotationQuaternion) {\n                Matrix.RotationYawPitchRollToRef(camera.rotation.y, camera.rotation.x, 0, this._cameraTransform);\n            }\n            else {\n                camera.rotationQuaternion.toRotationMatrix(this._cameraTransform);\n            }\n            const speed = camera._computeLocalCameraSpeed() * 50.0;\n            this._vector3.copyFromFloats(lsValues.x * speed, 0, -lsValues.y * speed);\n            Vector3.TransformCoordinatesToRef(this._vector3, this._cameraTransform, this._deltaTransform);\n            camera.cameraDirection.addInPlace(this._deltaTransform);\n            this._vector2.copyFromFloats(rsValues.y, rsValues.x);\n            camera.cameraRotation.addInPlace(this._vector2);\n        }\n    }\n    /**\n     * Gets the class name of the current input.\n     * @returns the class name\n     */\n    getClassName() {\n        return \"FreeCameraGamepadInput\";\n    }\n    /**\n     * Get the friendly name associated with the input class.\n     * @returns the input friendly name\n     */\n    getSimpleName() {\n        return \"gamepad\";\n    }\n}\n__decorate([\n    serialize()\n], FreeCameraGamepadInput.prototype, \"gamepadAngularSensibility\", void 0);\n__decorate([\n    serialize()\n], FreeCameraGamepadInput.prototype, \"gamepadMoveSensibility\", void 0);\nCameraInputTypes[\"FreeCameraGamepadInput\"] = FreeCameraGamepadInput;\n//# sourceMappingURL=freeCameraGamepadInput.js.map","import { __decorate } from \"../../tslib.es6.js\";\nimport { serialize } from \"../../Misc/decorators.js\";\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager.js\";\nimport { KeyboardEventTypes } from \"../../Events/keyboardEvents.js\";\nimport { Vector3 } from \"../../Maths/math.vector.js\";\nimport { Tools } from \"../../Misc/tools.js\";\n/**\n * Manage the keyboard inputs to control the movement of a free camera.\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\n */\nexport class FreeCameraKeyboardMoveInput {\n    constructor() {\n        /**\n         * Gets or Set the list of keyboard keys used to control the forward move of the camera.\n         */\n        this.keysUp = [38];\n        /**\n         * Gets or Set the list of keyboard keys used to control the upward move of the camera.\n         */\n        this.keysUpward = [33];\n        /**\n         * Gets or Set the list of keyboard keys used to control the backward move of the camera.\n         */\n        this.keysDown = [40];\n        /**\n         * Gets or Set the list of keyboard keys used to control the downward move of the camera.\n         */\n        this.keysDownward = [34];\n        /**\n         * Gets or Set the list of keyboard keys used to control the left strafe move of the camera.\n         */\n        this.keysLeft = [37];\n        /**\n         * Gets or Set the list of keyboard keys used to control the right strafe move of the camera.\n         */\n        this.keysRight = [39];\n        /**\n         * Defines the pointer angular sensibility  along the X and Y axis or how fast is the camera rotating.\n         */\n        this.rotationSpeed = 0.5;\n        /**\n         * Gets or Set the list of keyboard keys used to control the left rotation move of the camera.\n         */\n        this.keysRotateLeft = [];\n        /**\n         * Gets or Set the list of keyboard keys used to control the right rotation move of the camera.\n         */\n        this.keysRotateRight = [];\n        this._keys = new Array();\n    }\n    /**\n     * Attach the input controls to a specific dom element to get the input from.\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\n     */\n    attachControl(noPreventDefault) {\n        // eslint-disable-next-line prefer-rest-params\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\n        if (this._onCanvasBlurObserver) {\n            return;\n        }\n        this._scene = this.camera.getScene();\n        this._engine = this._scene.getEngine();\n        this._onCanvasBlurObserver = this._engine.onCanvasBlurObservable.add(() => {\n            this._keys.length = 0;\n        });\n        this._onKeyboardObserver = this._scene.onKeyboardObservable.add((info) => {\n            const evt = info.event;\n            if (!evt.metaKey) {\n                if (info.type === KeyboardEventTypes.KEYDOWN) {\n                    if (this.keysUp.indexOf(evt.keyCode) !== -1 ||\n                        this.keysDown.indexOf(evt.keyCode) !== -1 ||\n                        this.keysLeft.indexOf(evt.keyCode) !== -1 ||\n                        this.keysRight.indexOf(evt.keyCode) !== -1 ||\n                        this.keysUpward.indexOf(evt.keyCode) !== -1 ||\n                        this.keysDownward.indexOf(evt.keyCode) !== -1 ||\n                        this.keysRotateLeft.indexOf(evt.keyCode) !== -1 ||\n                        this.keysRotateRight.indexOf(evt.keyCode) !== -1) {\n                        const index = this._keys.indexOf(evt.keyCode);\n                        if (index === -1) {\n                            this._keys.push(evt.keyCode);\n                        }\n                        if (!noPreventDefault) {\n                            evt.preventDefault();\n                        }\n                    }\n                }\n                else {\n                    if (this.keysUp.indexOf(evt.keyCode) !== -1 ||\n                        this.keysDown.indexOf(evt.keyCode) !== -1 ||\n                        this.keysLeft.indexOf(evt.keyCode) !== -1 ||\n                        this.keysRight.indexOf(evt.keyCode) !== -1 ||\n                        this.keysUpward.indexOf(evt.keyCode) !== -1 ||\n                        this.keysDownward.indexOf(evt.keyCode) !== -1 ||\n                        this.keysRotateLeft.indexOf(evt.keyCode) !== -1 ||\n                        this.keysRotateRight.indexOf(evt.keyCode) !== -1) {\n                        const index = this._keys.indexOf(evt.keyCode);\n                        if (index >= 0) {\n                            this._keys.splice(index, 1);\n                        }\n                        if (!noPreventDefault) {\n                            evt.preventDefault();\n                        }\n                    }\n                }\n            }\n        });\n    }\n    /**\n     * Detach the current controls from the specified dom element.\n     */\n    detachControl() {\n        if (this._scene) {\n            if (this._onKeyboardObserver) {\n                this._scene.onKeyboardObservable.remove(this._onKeyboardObserver);\n            }\n            if (this._onCanvasBlurObserver) {\n                this._engine.onCanvasBlurObservable.remove(this._onCanvasBlurObserver);\n            }\n            this._onKeyboardObserver = null;\n            this._onCanvasBlurObserver = null;\n        }\n        this._keys.length = 0;\n    }\n    /**\n     * Update the current camera state depending on the inputs that have been used this frame.\n     * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.\n     */\n    checkInputs() {\n        if (this._onKeyboardObserver) {\n            const camera = this.camera;\n            // Keyboard\n            for (let index = 0; index < this._keys.length; index++) {\n                const keyCode = this._keys[index];\n                const speed = camera._computeLocalCameraSpeed();\n                if (this.keysLeft.indexOf(keyCode) !== -1) {\n                    camera._localDirection.copyFromFloats(-speed, 0, 0);\n                }\n                else if (this.keysUp.indexOf(keyCode) !== -1) {\n                    camera._localDirection.copyFromFloats(0, 0, speed);\n                }\n                else if (this.keysRight.indexOf(keyCode) !== -1) {\n                    camera._localDirection.copyFromFloats(speed, 0, 0);\n                }\n                else if (this.keysDown.indexOf(keyCode) !== -1) {\n                    camera._localDirection.copyFromFloats(0, 0, -speed);\n                }\n                else if (this.keysUpward.indexOf(keyCode) !== -1) {\n                    camera._localDirection.copyFromFloats(0, speed, 0);\n                }\n                else if (this.keysDownward.indexOf(keyCode) !== -1) {\n                    camera._localDirection.copyFromFloats(0, -speed, 0);\n                }\n                else if (this.keysRotateLeft.indexOf(keyCode) !== -1) {\n                    camera._localDirection.copyFromFloats(0, 0, 0);\n                    camera.cameraRotation.y -= this._getLocalRotation();\n                }\n                else if (this.keysRotateRight.indexOf(keyCode) !== -1) {\n                    camera._localDirection.copyFromFloats(0, 0, 0);\n                    camera.cameraRotation.y += this._getLocalRotation();\n                }\n                if (camera.getScene().useRightHandedSystem) {\n                    camera._localDirection.z *= -1;\n                }\n                camera.getViewMatrix().invertToRef(camera._cameraTransformMatrix);\n                Vector3.TransformNormalToRef(camera._localDirection, camera._cameraTransformMatrix, camera._transformedDirection);\n                camera.cameraDirection.addInPlace(camera._transformedDirection);\n            }\n        }\n    }\n    /**\n     * Gets the class name of the current input.\n     * @returns the class name\n     */\n    getClassName() {\n        return \"FreeCameraKeyboardMoveInput\";\n    }\n    /** @internal */\n    _onLostFocus() {\n        this._keys.length = 0;\n    }\n    /**\n     * Get the friendly name associated with the input class.\n     * @returns the input friendly name\n     */\n    getSimpleName() {\n        return \"keyboard\";\n    }\n    _getLocalRotation() {\n        let rotation = (this.rotationSpeed * this._engine.getDeltaTime()) / 1000;\n        if (this.camera.getScene().useRightHandedSystem) {\n            rotation *= -1;\n        }\n        if (this.camera.parent && this.camera.parent._getWorldMatrixDeterminant() < 0) {\n            rotation *= -1;\n        }\n        return rotation;\n    }\n}\n__decorate([\n    serialize()\n], FreeCameraKeyboardMoveInput.prototype, \"keysUp\", void 0);\n__decorate([\n    serialize()\n], FreeCameraKeyboardMoveInput.prototype, \"keysUpward\", void 0);\n__decorate([\n    serialize()\n], FreeCameraKeyboardMoveInput.prototype, \"keysDown\", void 0);\n__decorate([\n    serialize()\n], FreeCameraKeyboardMoveInput.prototype, \"keysDownward\", void 0);\n__decorate([\n    serialize()\n], FreeCameraKeyboardMoveInput.prototype, \"keysLeft\", void 0);\n__decorate([\n    serialize()\n], FreeCameraKeyboardMoveInput.prototype, \"keysRight\", void 0);\n__decorate([\n    serialize()\n], FreeCameraKeyboardMoveInput.prototype, \"rotationSpeed\", void 0);\n__decorate([\n    serialize()\n], FreeCameraKeyboardMoveInput.prototype, \"keysRotateLeft\", void 0);\n__decorate([\n    serialize()\n], FreeCameraKeyboardMoveInput.prototype, \"keysRotateRight\", void 0);\nCameraInputTypes[\"FreeCameraKeyboardMoveInput\"] = FreeCameraKeyboardMoveInput;\n//# sourceMappingURL=freeCameraKeyboardMoveInput.js.map","import { __decorate } from \"../../tslib.es6.js\";\nimport { Observable } from \"../../Misc/observable.js\";\nimport { serialize } from \"../../Misc/decorators.js\";\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager.js\";\nimport { PointerEventTypes } from \"../../Events/pointerEvents.js\";\nimport { Tools } from \"../../Misc/tools.js\";\n/**\n * Manage the mouse inputs to control the movement of a free camera.\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\n */\nexport class FreeCameraMouseInput {\n    /**\n     * Manage the mouse inputs to control the movement of a free camera.\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\n     * @param touchEnabled Defines if touch is enabled or not\n     */\n    constructor(\n    /**\n     * Define if touch is enabled in the mouse input\n     */\n    touchEnabled = true) {\n        this.touchEnabled = touchEnabled;\n        /**\n         * Defines the buttons associated with the input to handle camera move.\n         */\n        this.buttons = [0, 1, 2];\n        /**\n         * Defines the pointer angular sensibility  along the X and Y axis or how fast is the camera rotating.\n         */\n        this.angularSensibility = 2000.0;\n        this._previousPosition = null;\n        /**\n         * Observable for when a pointer move event occurs containing the move offset\n         */\n        this.onPointerMovedObservable = new Observable();\n        /**\n         * @internal\n         * If the camera should be rotated automatically based on pointer movement\n         */\n        this._allowCameraRotation = true;\n        this._currentActiveButton = -1;\n        this._activePointerId = -1;\n    }\n    /**\n     * Attach the input controls to a specific dom element to get the input from.\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\n     */\n    attachControl(noPreventDefault) {\n        // eslint-disable-next-line prefer-rest-params\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\n        const engine = this.camera.getEngine();\n        const element = engine.getInputElement();\n        if (!this._pointerInput) {\n            this._pointerInput = (p) => {\n                const evt = p.event;\n                const isTouch = evt.pointerType === \"touch\";\n                if (engine.isInVRExclusivePointerMode) {\n                    return;\n                }\n                if (!this.touchEnabled && isTouch) {\n                    return;\n                }\n                if (p.type !== PointerEventTypes.POINTERMOVE && this.buttons.indexOf(evt.button) === -1) {\n                    return;\n                }\n                const srcElement = evt.target;\n                if (p.type === PointerEventTypes.POINTERDOWN) {\n                    // If the input is touch with more than one touch OR if the input is mouse and there is already an active button, return\n                    if ((isTouch && this._activePointerId !== -1) || (!isTouch && this._currentActiveButton !== -1)) {\n                        return;\n                    }\n                    this._activePointerId = evt.pointerId;\n                    try {\n                        srcElement === null || srcElement === void 0 ? void 0 : srcElement.setPointerCapture(evt.pointerId);\n                    }\n                    catch (e) {\n                        //Nothing to do with the error. Execution will continue.\n                    }\n                    if (this._currentActiveButton === -1) {\n                        this._currentActiveButton = evt.button;\n                    }\n                    this._previousPosition = {\n                        x: evt.clientX,\n                        y: evt.clientY,\n                    };\n                    if (!noPreventDefault) {\n                        evt.preventDefault();\n                        element && element.focus();\n                    }\n                    // This is required to move while pointer button is down\n                    if (engine.isPointerLock && this._onMouseMove) {\n                        this._onMouseMove(p.event);\n                    }\n                }\n                else if (p.type === PointerEventTypes.POINTERUP) {\n                    // If input is touch with a different touch id OR if input is mouse with a different button, return\n                    if ((isTouch && this._activePointerId !== evt.pointerId) || (!isTouch && this._currentActiveButton !== evt.button)) {\n                        return;\n                    }\n                    try {\n                        srcElement === null || srcElement === void 0 ? void 0 : srcElement.releasePointerCapture(evt.pointerId);\n                    }\n                    catch (e) {\n                        //Nothing to do with the error.\n                    }\n                    this._currentActiveButton = -1;\n                    this._previousPosition = null;\n                    if (!noPreventDefault) {\n                        evt.preventDefault();\n                    }\n                    this._activePointerId = -1;\n                }\n                else if (p.type === PointerEventTypes.POINTERMOVE && (this._activePointerId === evt.pointerId || !isTouch)) {\n                    if (engine.isPointerLock && this._onMouseMove) {\n                        this._onMouseMove(p.event);\n                    }\n                    else if (this._previousPosition) {\n                        let offsetX = evt.clientX - this._previousPosition.x;\n                        const offsetY = evt.clientY - this._previousPosition.y;\n                        if (this.camera.getScene().useRightHandedSystem) {\n                            offsetX *= -1;\n                        }\n                        if (this.camera.parent && this.camera.parent._getWorldMatrixDeterminant() < 0) {\n                            offsetX *= -1;\n                        }\n                        if (this._allowCameraRotation) {\n                            this.camera.cameraRotation.y += offsetX / this.angularSensibility;\n                            this.camera.cameraRotation.x += offsetY / this.angularSensibility;\n                        }\n                        this.onPointerMovedObservable.notifyObservers({ offsetX: offsetX, offsetY: offsetY });\n                        this._previousPosition = {\n                            x: evt.clientX,\n                            y: evt.clientY,\n                        };\n                        if (!noPreventDefault) {\n                            evt.preventDefault();\n                        }\n                    }\n                }\n            };\n        }\n        this._onMouseMove = (evt) => {\n            if (!engine.isPointerLock) {\n                return;\n            }\n            if (engine.isInVRExclusivePointerMode) {\n                return;\n            }\n            let offsetX = evt.movementX;\n            if (this.camera.getScene().useRightHandedSystem) {\n                offsetX *= -1;\n            }\n            if (this.camera.parent && this.camera.parent._getWorldMatrixDeterminant() < 0) {\n                offsetX *= -1;\n            }\n            this.camera.cameraRotation.y += offsetX / this.angularSensibility;\n            const offsetY = evt.movementY;\n            this.camera.cameraRotation.x += offsetY / this.angularSensibility;\n            this._previousPosition = null;\n            if (!noPreventDefault) {\n                evt.preventDefault();\n            }\n        };\n        this._observer = this.camera\n            .getScene()\n            ._inputManager._addCameraPointerObserver(this._pointerInput, PointerEventTypes.POINTERDOWN | PointerEventTypes.POINTERUP | PointerEventTypes.POINTERMOVE);\n        if (element) {\n            this._contextMenuBind = this.onContextMenu.bind(this);\n            element.addEventListener(\"contextmenu\", this._contextMenuBind, false); // TODO: We need to figure out how to handle this for Native\n        }\n    }\n    /**\n     * Called on JS contextmenu event.\n     * Override this method to provide functionality.\n     * @param evt\n     */\n    onContextMenu(evt) {\n        evt.preventDefault();\n    }\n    /**\n     * Detach the current controls from the specified dom element.\n     */\n    detachControl() {\n        if (this._observer) {\n            this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer);\n            if (this._contextMenuBind) {\n                const engine = this.camera.getEngine();\n                const element = engine.getInputElement();\n                element && element.removeEventListener(\"contextmenu\", this._contextMenuBind);\n            }\n            if (this.onPointerMovedObservable) {\n                this.onPointerMovedObservable.clear();\n            }\n            this._observer = null;\n            this._onMouseMove = null;\n            this._previousPosition = null;\n        }\n        this._currentActiveButton = -1;\n    }\n    /**\n     * Gets the class name of the current input.\n     * @returns the class name\n     */\n    getClassName() {\n        return \"FreeCameraMouseInput\";\n    }\n    /**\n     * Get the friendly name associated with the input class.\n     * @returns the input friendly name\n     */\n    getSimpleName() {\n        return \"mouse\";\n    }\n}\n__decorate([\n    serialize()\n], FreeCameraMouseInput.prototype, \"buttons\", void 0);\n__decorate([\n    serialize()\n], FreeCameraMouseInput.prototype, \"angularSensibility\", void 0);\nCameraInputTypes[\"FreeCameraMouseInput\"] = FreeCameraMouseInput;\n//# sourceMappingURL=freeCameraMouseInput.js.map","import { __decorate } from \"../../tslib.es6.js\";\nimport { serialize } from \"../../Misc/decorators.js\";\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager.js\";\nimport { BaseCameraMouseWheelInput } from \"../../Cameras/Inputs/BaseCameraMouseWheelInput.js\";\nimport { Matrix, Vector3 } from \"../../Maths/math.vector.js\";\nimport { Coordinate } from \"../../Maths/math.axis.js\";\n// eslint-disable-next-line @typescript-eslint/naming-convention\nvar _CameraProperty;\n(function (_CameraProperty) {\n    _CameraProperty[_CameraProperty[\"MoveRelative\"] = 0] = \"MoveRelative\";\n    _CameraProperty[_CameraProperty[\"RotateRelative\"] = 1] = \"RotateRelative\";\n    _CameraProperty[_CameraProperty[\"MoveScene\"] = 2] = \"MoveScene\";\n})(_CameraProperty || (_CameraProperty = {}));\n/**\n * Manage the mouse wheel inputs to control a free camera.\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\n */\nexport class FreeCameraMouseWheelInput extends BaseCameraMouseWheelInput {\n    constructor() {\n        super(...arguments);\n        this._moveRelative = Vector3.Zero();\n        this._rotateRelative = Vector3.Zero();\n        this._moveScene = Vector3.Zero();\n        /**\n         * These are set to the desired default behaviour.\n         */\n        this._wheelXAction = _CameraProperty.MoveRelative;\n        this._wheelXActionCoordinate = Coordinate.X;\n        this._wheelYAction = _CameraProperty.MoveRelative;\n        this._wheelYActionCoordinate = Coordinate.Z;\n        this._wheelZAction = null;\n        this._wheelZActionCoordinate = null;\n    }\n    /**\n     * Gets the class name of the current input.\n     * @returns the class name\n     */\n    getClassName() {\n        return \"FreeCameraMouseWheelInput\";\n    }\n    /**\n     * Set which movement axis (relative to camera's orientation) the mouse\n     * wheel's X axis controls.\n     * @param axis The axis to be moved. Set null to clear.\n     */\n    set wheelXMoveRelative(axis) {\n        if (axis === null && this._wheelXAction !== _CameraProperty.MoveRelative) {\n            // Attempting to clear different _wheelXAction.\n            return;\n        }\n        this._wheelXAction = _CameraProperty.MoveRelative;\n        this._wheelXActionCoordinate = axis;\n    }\n    /**\n     * Get the configured movement axis (relative to camera's orientation) the\n     * mouse wheel's X axis controls.\n     * @returns The configured axis or null if none.\n     */\n    get wheelXMoveRelative() {\n        if (this._wheelXAction !== _CameraProperty.MoveRelative) {\n            return null;\n        }\n        return this._wheelXActionCoordinate;\n    }\n    /**\n     * Set which movement axis (relative to camera's orientation) the mouse\n     * wheel's Y axis controls.\n     * @param axis The axis to be moved. Set null to clear.\n     */\n    set wheelYMoveRelative(axis) {\n        if (axis === null && this._wheelYAction !== _CameraProperty.MoveRelative) {\n            // Attempting to clear different _wheelYAction.\n            return;\n        }\n        this._wheelYAction = _CameraProperty.MoveRelative;\n        this._wheelYActionCoordinate = axis;\n    }\n    /**\n     * Get the configured movement axis (relative to camera's orientation) the\n     * mouse wheel's Y axis controls.\n     * @returns The configured axis or null if none.\n     */\n    get wheelYMoveRelative() {\n        if (this._wheelYAction !== _CameraProperty.MoveRelative) {\n            return null;\n        }\n        return this._wheelYActionCoordinate;\n    }\n    /**\n     * Set which movement axis (relative to camera's orientation) the mouse\n     * wheel's Z axis controls.\n     * @param axis The axis to be moved. Set null to clear.\n     */\n    set wheelZMoveRelative(axis) {\n        if (axis === null && this._wheelZAction !== _CameraProperty.MoveRelative) {\n            // Attempting to clear different _wheelZAction.\n            return;\n        }\n        this._wheelZAction = _CameraProperty.MoveRelative;\n        this._wheelZActionCoordinate = axis;\n    }\n    /**\n     * Get the configured movement axis (relative to camera's orientation) the\n     * mouse wheel's Z axis controls.\n     * @returns The configured axis or null if none.\n     */\n    get wheelZMoveRelative() {\n        if (this._wheelZAction !== _CameraProperty.MoveRelative) {\n            return null;\n        }\n        return this._wheelZActionCoordinate;\n    }\n    /**\n     * Set which rotation axis (relative to camera's orientation) the mouse\n     * wheel's X axis controls.\n     * @param axis The axis to be moved. Set null to clear.\n     */\n    set wheelXRotateRelative(axis) {\n        if (axis === null && this._wheelXAction !== _CameraProperty.RotateRelative) {\n            // Attempting to clear different _wheelXAction.\n            return;\n        }\n        this._wheelXAction = _CameraProperty.RotateRelative;\n        this._wheelXActionCoordinate = axis;\n    }\n    /**\n     * Get the configured rotation axis (relative to camera's orientation) the\n     * mouse wheel's X axis controls.\n     * @returns The configured axis or null if none.\n     */\n    get wheelXRotateRelative() {\n        if (this._wheelXAction !== _CameraProperty.RotateRelative) {\n            return null;\n        }\n        return this._wheelXActionCoordinate;\n    }\n    /**\n     * Set which rotation axis (relative to camera's orientation) the mouse\n     * wheel's Y axis controls.\n     * @param axis The axis to be moved. Set null to clear.\n     */\n    set wheelYRotateRelative(axis) {\n        if (axis === null && this._wheelYAction !== _CameraProperty.RotateRelative) {\n            // Attempting to clear different _wheelYAction.\n            return;\n        }\n        this._wheelYAction = _CameraProperty.RotateRelative;\n        this._wheelYActionCoordinate = axis;\n    }\n    /**\n     * Get the configured rotation axis (relative to camera's orientation) the\n     * mouse wheel's Y axis controls.\n     * @returns The configured axis or null if none.\n     */\n    get wheelYRotateRelative() {\n        if (this._wheelYAction !== _CameraProperty.RotateRelative) {\n            return null;\n        }\n        return this._wheelYActionCoordinate;\n    }\n    /**\n     * Set which rotation axis (relative to camera's orientation) the mouse\n     * wheel's Z axis controls.\n     * @param axis The axis to be moved. Set null to clear.\n     */\n    set wheelZRotateRelative(axis) {\n        if (axis === null && this._wheelZAction !== _CameraProperty.RotateRelative) {\n            // Attempting to clear different _wheelZAction.\n            return;\n        }\n        this._wheelZAction = _CameraProperty.RotateRelative;\n        this._wheelZActionCoordinate = axis;\n    }\n    /**\n     * Get the configured rotation axis (relative to camera's orientation) the\n     * mouse wheel's Z axis controls.\n     * @returns The configured axis or null if none.\n     */\n    get wheelZRotateRelative() {\n        if (this._wheelZAction !== _CameraProperty.RotateRelative) {\n            return null;\n        }\n        return this._wheelZActionCoordinate;\n    }\n    /**\n     * Set which movement axis (relative to the scene) the mouse wheel's X axis\n     * controls.\n     * @param axis The axis to be moved. Set null to clear.\n     */\n    set wheelXMoveScene(axis) {\n        if (axis === null && this._wheelXAction !== _CameraProperty.MoveScene) {\n            // Attempting to clear different _wheelXAction.\n            return;\n        }\n        this._wheelXAction = _CameraProperty.MoveScene;\n        this._wheelXActionCoordinate = axis;\n    }\n    /**\n     * Get the configured movement axis (relative to the scene) the mouse wheel's\n     * X axis controls.\n     * @returns The configured axis or null if none.\n     */\n    get wheelXMoveScene() {\n        if (this._wheelXAction !== _CameraProperty.MoveScene) {\n            return null;\n        }\n        return this._wheelXActionCoordinate;\n    }\n    /**\n     * Set which movement axis (relative to the scene) the mouse wheel's Y axis\n     * controls.\n     * @param axis The axis to be moved. Set null to clear.\n     */\n    set wheelYMoveScene(axis) {\n        if (axis === null && this._wheelYAction !== _CameraProperty.MoveScene) {\n            // Attempting to clear different _wheelYAction.\n            return;\n        }\n        this._wheelYAction = _CameraProperty.MoveScene;\n        this._wheelYActionCoordinate = axis;\n    }\n    /**\n     * Get the configured movement axis (relative to the scene) the mouse wheel's\n     * Y axis controls.\n     * @returns The configured axis or null if none.\n     */\n    get wheelYMoveScene() {\n        if (this._wheelYAction !== _CameraProperty.MoveScene) {\n            return null;\n        }\n        return this._wheelYActionCoordinate;\n    }\n    /**\n     * Set which movement axis (relative to the scene) the mouse wheel's Z axis\n     * controls.\n     * @param axis The axis to be moved. Set null to clear.\n     */\n    set wheelZMoveScene(axis) {\n        if (axis === null && this._wheelZAction !== _CameraProperty.MoveScene) {\n            // Attempting to clear different _wheelZAction.\n            return;\n        }\n        this._wheelZAction = _CameraProperty.MoveScene;\n        this._wheelZActionCoordinate = axis;\n    }\n    /**\n     * Get the configured movement axis (relative to the scene) the mouse wheel's\n     * Z axis controls.\n     * @returns The configured axis or null if none.\n     */\n    get wheelZMoveScene() {\n        if (this._wheelZAction !== _CameraProperty.MoveScene) {\n            return null;\n        }\n        return this._wheelZActionCoordinate;\n    }\n    /**\n     * Called for each rendered frame.\n     */\n    checkInputs() {\n        if (this._wheelDeltaX === 0 && this._wheelDeltaY === 0 && this._wheelDeltaZ == 0) {\n            return;\n        }\n        // Clear the camera properties that we might be updating.\n        this._moveRelative.setAll(0);\n        this._rotateRelative.setAll(0);\n        this._moveScene.setAll(0);\n        // Set the camera properties that are to be updated.\n        this._updateCamera();\n        if (this.camera.getScene().useRightHandedSystem) {\n            // TODO: Does this need done for worldUpdate too?\n            this._moveRelative.z *= -1;\n        }\n        // Convert updates relative to camera to world position update.\n        const cameraTransformMatrix = Matrix.Zero();\n        this.camera.getViewMatrix().invertToRef(cameraTransformMatrix);\n        const transformedDirection = Vector3.Zero();\n        Vector3.TransformNormalToRef(this._moveRelative, cameraTransformMatrix, transformedDirection);\n        // Apply updates to camera position.\n        this.camera.cameraRotation.x += this._rotateRelative.x / 200;\n        this.camera.cameraRotation.y += this._rotateRelative.y / 200;\n        this.camera.cameraDirection.addInPlace(transformedDirection);\n        this.camera.cameraDirection.addInPlace(this._moveScene);\n        // Call the base class implementation to handle observers and do cleanup.\n        super.checkInputs();\n    }\n    /**\n     * Update the camera according to any configured properties for the 3\n     * mouse-wheel axis.\n     */\n    _updateCamera() {\n        // Do the camera updates for each of the 3 touch-wheel axis.\n        this._updateCameraProperty(this._wheelDeltaX, this._wheelXAction, this._wheelXActionCoordinate);\n        this._updateCameraProperty(this._wheelDeltaY, this._wheelYAction, this._wheelYActionCoordinate);\n        this._updateCameraProperty(this._wheelDeltaZ, this._wheelZAction, this._wheelZActionCoordinate);\n    }\n    /**\n     * Update one property of the camera.\n     * @param value\n     * @param cameraProperty\n     * @param coordinate\n     */\n    _updateCameraProperty(\n    /* Mouse-wheel delta. */\n    value, \n    /* Camera property to be changed. */\n    cameraProperty, \n    /* Axis of Camera property to be changed. */\n    coordinate) {\n        if (value === 0) {\n            // Mouse wheel has not moved.\n            return;\n        }\n        if (cameraProperty === null || coordinate === null) {\n            // Mouse wheel axis not configured.\n            return;\n        }\n        let action = null;\n        switch (cameraProperty) {\n            case _CameraProperty.MoveRelative:\n                action = this._moveRelative;\n                break;\n            case _CameraProperty.RotateRelative:\n                action = this._rotateRelative;\n                break;\n            case _CameraProperty.MoveScene:\n                action = this._moveScene;\n                break;\n        }\n        switch (coordinate) {\n            case Coordinate.X:\n                action.set(value, 0, 0);\n                break;\n            case Coordinate.Y:\n                action.set(0, value, 0);\n                break;\n            case Coordinate.Z:\n                action.set(0, 0, value);\n                break;\n        }\n    }\n}\n__decorate([\n    serialize()\n], FreeCameraMouseWheelInput.prototype, \"wheelXMoveRelative\", null);\n__decorate([\n    serialize()\n], FreeCameraMouseWheelInput.prototype, \"wheelYMoveRelative\", null);\n__decorate([\n    serialize()\n], FreeCameraMouseWheelInput.prototype, \"wheelZMoveRelative\", null);\n__decorate([\n    serialize()\n], FreeCameraMouseWheelInput.prototype, \"wheelXRotateRelative\", null);\n__decorate([\n    serialize()\n], FreeCameraMouseWheelInput.prototype, \"wheelYRotateRelative\", null);\n__decorate([\n    serialize()\n], FreeCameraMouseWheelInput.prototype, \"wheelZRotateRelative\", null);\n__decorate([\n    serialize()\n], FreeCameraMouseWheelInput.prototype, \"wheelXMoveScene\", null);\n__decorate([\n    serialize()\n], FreeCameraMouseWheelInput.prototype, \"wheelYMoveScene\", null);\n__decorate([\n    serialize()\n], FreeCameraMouseWheelInput.prototype, \"wheelZMoveScene\", null);\nCameraInputTypes[\"FreeCameraMouseWheelInput\"] = FreeCameraMouseWheelInput;\n//# sourceMappingURL=freeCameraMouseWheelInput.js.map","import { __decorate } from \"../../tslib.es6.js\";\nimport { serialize } from \"../../Misc/decorators.js\";\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager.js\";\nimport { PointerEventTypes } from \"../../Events/pointerEvents.js\";\nimport { Matrix, Vector3 } from \"../../Maths/math.vector.js\";\nimport { Tools } from \"../../Misc/tools.js\";\n/**\n * Manage the touch inputs to control the movement of a free camera.\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\n */\nexport class FreeCameraTouchInput {\n    /**\n     * Manage the touch inputs to control the movement of a free camera.\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\n     * @param allowMouse Defines if mouse events can be treated as touch events\n     */\n    constructor(\n    /**\n     * Define if mouse events can be treated as touch events\n     */\n    allowMouse = false) {\n        this.allowMouse = allowMouse;\n        /**\n         * Defines the touch sensibility for rotation.\n         * The lower the faster.\n         */\n        this.touchAngularSensibility = 200000.0;\n        /**\n         * Defines the touch sensibility for move.\n         * The lower the faster.\n         */\n        this.touchMoveSensibility = 250.0;\n        /**\n         * Swap touch actions so that one touch is used for rotation and multiple for movement\n         */\n        this.singleFingerRotate = false;\n        this._offsetX = null;\n        this._offsetY = null;\n        this._pointerPressed = new Array();\n        this._isSafari = Tools.IsSafari();\n    }\n    /**\n     * Attach the input controls to a specific dom element to get the input from.\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\n     */\n    attachControl(noPreventDefault) {\n        // eslint-disable-next-line prefer-rest-params\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\n        let previousPosition = null;\n        if (this._pointerInput === undefined) {\n            this._onLostFocus = () => {\n                this._offsetX = null;\n                this._offsetY = null;\n            };\n            this._pointerInput = (p) => {\n                const evt = p.event;\n                const isMouseEvent = evt.pointerType === \"mouse\" || (this._isSafari && typeof evt.pointerType === \"undefined\");\n                if (!this.allowMouse && isMouseEvent) {\n                    return;\n                }\n                if (p.type === PointerEventTypes.POINTERDOWN) {\n                    if (!noPreventDefault) {\n                        evt.preventDefault();\n                    }\n                    this._pointerPressed.push(evt.pointerId);\n                    if (this._pointerPressed.length !== 1) {\n                        return;\n                    }\n                    previousPosition = {\n                        x: evt.clientX,\n                        y: evt.clientY,\n                    };\n                }\n                else if (p.type === PointerEventTypes.POINTERUP) {\n                    if (!noPreventDefault) {\n                        evt.preventDefault();\n                    }\n                    const index = this._pointerPressed.indexOf(evt.pointerId);\n                    if (index === -1) {\n                        return;\n                    }\n                    this._pointerPressed.splice(index, 1);\n                    if (index != 0) {\n                        return;\n                    }\n                    previousPosition = null;\n                    this._offsetX = null;\n                    this._offsetY = null;\n                }\n                else if (p.type === PointerEventTypes.POINTERMOVE) {\n                    if (!noPreventDefault) {\n                        evt.preventDefault();\n                    }\n                    if (!previousPosition) {\n                        return;\n                    }\n                    const index = this._pointerPressed.indexOf(evt.pointerId);\n                    if (index != 0) {\n                        return;\n                    }\n                    this._offsetX = evt.clientX - previousPosition.x;\n                    this._offsetY = -(evt.clientY - previousPosition.y);\n                }\n            };\n        }\n        this._observer = this.camera\n            .getScene()\n            ._inputManager._addCameraPointerObserver(this._pointerInput, PointerEventTypes.POINTERDOWN | PointerEventTypes.POINTERUP | PointerEventTypes.POINTERMOVE);\n        if (this._onLostFocus) {\n            const engine = this.camera.getEngine();\n            const element = engine.getInputElement();\n            element && element.addEventListener(\"blur\", this._onLostFocus);\n        }\n    }\n    /**\n     * Detach the current controls from the specified dom element.\n     */\n    detachControl() {\n        if (this._pointerInput) {\n            if (this._observer) {\n                this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer);\n                this._observer = null;\n            }\n            if (this._onLostFocus) {\n                const engine = this.camera.getEngine();\n                const element = engine.getInputElement();\n                element && element.removeEventListener(\"blur\", this._onLostFocus);\n                this._onLostFocus = null;\n            }\n            this._pointerPressed.length = 0;\n            this._offsetX = null;\n            this._offsetY = null;\n        }\n    }\n    /**\n     * Update the current camera state depending on the inputs that have been used this frame.\n     * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.\n     */\n    checkInputs() {\n        if (this._offsetX === null || this._offsetY === null) {\n            return;\n        }\n        if (this._offsetX === 0 && this._offsetY === 0) {\n            return;\n        }\n        const camera = this.camera;\n        camera.cameraRotation.y = this._offsetX / this.touchAngularSensibility;\n        const rotateCamera = (this.singleFingerRotate && this._pointerPressed.length === 1) || (!this.singleFingerRotate && this._pointerPressed.length > 1);\n        if (rotateCamera) {\n            camera.cameraRotation.x = -this._offsetY / this.touchAngularSensibility;\n        }\n        else {\n            const speed = camera._computeLocalCameraSpeed();\n            const direction = new Vector3(0, 0, this.touchMoveSensibility !== 0 ? (speed * this._offsetY) / this.touchMoveSensibility : 0);\n            Matrix.RotationYawPitchRollToRef(camera.rotation.y, camera.rotation.x, 0, camera._cameraRotationMatrix);\n            camera.cameraDirection.addInPlace(Vector3.TransformCoordinates(direction, camera._cameraRotationMatrix));\n        }\n    }\n    /**\n     * Gets the class name of the current input.\n     * @returns the class name\n     */\n    getClassName() {\n        return \"FreeCameraTouchInput\";\n    }\n    /**\n     * Get the friendly name associated with the input class.\n     * @returns the input friendly name\n     */\n    getSimpleName() {\n        return \"touch\";\n    }\n}\n__decorate([\n    serialize()\n], FreeCameraTouchInput.prototype, \"touchAngularSensibility\", void 0);\n__decorate([\n    serialize()\n], FreeCameraTouchInput.prototype, \"touchMoveSensibility\", void 0);\nCameraInputTypes[\"FreeCameraTouchInput\"] = FreeCameraTouchInput;\n//# sourceMappingURL=freeCameraTouchInput.js.map","import { Matrix } from \"../../Maths/math.vector.js\";\nimport { VRDistortionCorrectionPostProcess } from \"../../PostProcesses/vrDistortionCorrectionPostProcess.js\";\nimport { VRMultiviewToSingleviewPostProcess } from \"../../PostProcesses/vrMultiviewToSingleviewPostProcess.js\";\nimport { VRCameraMetrics } from \"../VR/vrCameraMetrics.js\";\nimport { Logger } from \"../../Misc/logger.js\";\nimport { Viewport } from \"../../Maths/math.viewport.js\";\n/**\n * @internal\n */\nexport function setVRRigMode(camera, rigParams) {\n    const metrics = rigParams.vrCameraMetrics || VRCameraMetrics.GetDefault();\n    camera._rigCameras[0]._cameraRigParams.vrMetrics = metrics;\n    camera._rigCameras[0].viewport = new Viewport(0, 0, 0.5, 1.0);\n    camera._rigCameras[0]._cameraRigParams.vrWorkMatrix = new Matrix();\n    camera._rigCameras[0]._cameraRigParams.vrHMatrix = metrics.leftHMatrix;\n    camera._rigCameras[0]._cameraRigParams.vrPreViewMatrix = metrics.leftPreViewMatrix;\n    camera._rigCameras[0].getProjectionMatrix = camera._rigCameras[0]._getVRProjectionMatrix;\n    camera._rigCameras[1]._cameraRigParams.vrMetrics = metrics;\n    camera._rigCameras[1].viewport = new Viewport(0.5, 0, 0.5, 1.0);\n    camera._rigCameras[1]._cameraRigParams.vrWorkMatrix = new Matrix();\n    camera._rigCameras[1]._cameraRigParams.vrHMatrix = metrics.rightHMatrix;\n    camera._rigCameras[1]._cameraRigParams.vrPreViewMatrix = metrics.rightPreViewMatrix;\n    camera._rigCameras[1].getProjectionMatrix = camera._rigCameras[1]._getVRProjectionMatrix;\n    // For multiview on a webVR camera\n    // First multiview will be rendered to camera._multiviewTexture\n    // Then this postprocess will run on each eye to copy the right texture to each eye\n    if (metrics.multiviewEnabled) {\n        if (!camera.getScene().getEngine().getCaps().multiview) {\n            Logger.Warn(\"Multiview is not supported, falling back to standard rendering\");\n            metrics.multiviewEnabled = false;\n        }\n        else {\n            camera._useMultiviewToSingleView = true;\n            camera._rigPostProcess = new VRMultiviewToSingleviewPostProcess(\"VRMultiviewToSingleview\", camera, metrics.postProcessScaleFactor);\n        }\n    }\n    if (metrics.compensateDistortion) {\n        camera._rigCameras[0]._rigPostProcess = new VRDistortionCorrectionPostProcess(\"VR_Distort_Compensation_Left\", camera._rigCameras[0], false, metrics);\n        camera._rigCameras[1]._rigPostProcess = new VRDistortionCorrectionPostProcess(\"VR_Distort_Compensation_Right\", camera._rigCameras[1], true, metrics);\n    }\n}\n//# sourceMappingURL=vrRigMode.js.map","import { Matrix } from \"../../Maths/math.vector.js\";\nimport { Viewport } from \"../../Maths/math.viewport.js\";\n/**\n * @internal\n */\nexport function setWebVRRigMode(camera, rigParams) {\n    if (rigParams.vrDisplay) {\n        const leftEye = rigParams.vrDisplay.getEyeParameters(\"left\");\n        const rightEye = rigParams.vrDisplay.getEyeParameters(\"right\");\n        //Left eye\n        camera._rigCameras[0].viewport = new Viewport(0, 0, 0.5, 1.0);\n        camera._rigCameras[0].setCameraRigParameter(\"left\", true);\n        //leaving this for future reference\n        camera._rigCameras[0].setCameraRigParameter(\"specs\", rigParams.specs);\n        camera._rigCameras[0].setCameraRigParameter(\"eyeParameters\", leftEye);\n        camera._rigCameras[0].setCameraRigParameter(\"frameData\", rigParams.frameData);\n        camera._rigCameras[0].setCameraRigParameter(\"parentCamera\", rigParams.parentCamera);\n        camera._rigCameras[0]._cameraRigParams.vrWorkMatrix = new Matrix();\n        camera._rigCameras[0].getProjectionMatrix = camera._getWebVRProjectionMatrix;\n        camera._rigCameras[0].parent = camera;\n        camera._rigCameras[0]._getViewMatrix = camera._getWebVRViewMatrix;\n        //Right eye\n        camera._rigCameras[1].viewport = new Viewport(0.5, 0, 0.5, 1.0);\n        camera._rigCameras[1].setCameraRigParameter(\"eyeParameters\", rightEye);\n        camera._rigCameras[1].setCameraRigParameter(\"specs\", rigParams.specs);\n        camera._rigCameras[1].setCameraRigParameter(\"frameData\", rigParams.frameData);\n        camera._rigCameras[1].setCameraRigParameter(\"parentCamera\", rigParams.parentCamera);\n        camera._rigCameras[1]._cameraRigParams.vrWorkMatrix = new Matrix();\n        camera._rigCameras[1].getProjectionMatrix = camera._getWebVRProjectionMatrix;\n        camera._rigCameras[1].parent = camera;\n        camera._rigCameras[1]._getViewMatrix = camera._getWebVRViewMatrix;\n    }\n}\n//# sourceMappingURL=webVRRigMode.js.map","import { Matrix } from \"../../Maths/math.vector.js\";\n/**\n * This represents all the required metrics to create a VR camera.\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_introduction#device-orientation-camera\n */\nexport class VRCameraMetrics {\n    constructor() {\n        /**\n         * Define if the current vr camera should compensate the distortion of the lens or not.\n         */\n        this.compensateDistortion = true;\n        /**\n         * Defines if multiview should be enabled when rendering (Default: false)\n         */\n        this.multiviewEnabled = false;\n    }\n    /**\n     * Gets the rendering aspect ratio based on the provided resolutions.\n     */\n    get aspectRatio() {\n        return this.hResolution / (2 * this.vResolution);\n    }\n    /**\n     * Gets the aspect ratio based on the FOV, scale factors, and real screen sizes.\n     */\n    get aspectRatioFov() {\n        return 2 * Math.atan((this.postProcessScaleFactor * this.vScreenSize) / (2 * this.eyeToScreenDistance));\n    }\n    /**\n     * @internal\n     */\n    get leftHMatrix() {\n        const meters = this.hScreenSize / 4 - this.lensSeparationDistance / 2;\n        const h = (4 * meters) / this.hScreenSize;\n        return Matrix.Translation(h, 0, 0);\n    }\n    /**\n     * @internal\n     */\n    get rightHMatrix() {\n        const meters = this.hScreenSize / 4 - this.lensSeparationDistance / 2;\n        const h = (4 * meters) / this.hScreenSize;\n        return Matrix.Translation(-h, 0, 0);\n    }\n    /**\n     * @internal\n     */\n    get leftPreViewMatrix() {\n        return Matrix.Translation(0.5 * this.interpupillaryDistance, 0, 0);\n    }\n    /**\n     * @internal\n     */\n    get rightPreViewMatrix() {\n        return Matrix.Translation(-0.5 * this.interpupillaryDistance, 0, 0);\n    }\n    /**\n     * Get the default VRMetrics based on the most generic setup.\n     * @returns the default vr metrics\n     */\n    static GetDefault() {\n        const result = new VRCameraMetrics();\n        result.hResolution = 1280;\n        result.vResolution = 800;\n        result.hScreenSize = 0.149759993;\n        result.vScreenSize = 0.0935999975;\n        result.vScreenCenter = 0.0467999987;\n        result.eyeToScreenDistance = 0.0410000011;\n        result.lensSeparationDistance = 0.063500002;\n        result.interpupillaryDistance = 0.064000003;\n        result.distortionK = [1.0, 0.219999999, 0.239999995, 0.0];\n        result.chromaAbCorrection = [0.995999992, -0.00400000019, 1.01400006, 0.0];\n        result.postProcessScaleFactor = 1.714605507808412;\n        result.lensCenterOffset = 0.151976421;\n        return result;\n    }\n}\n//# sourceMappingURL=vrCameraMetrics.js.map","import { Camera } from \"../../Cameras/camera.js\";\nimport { DeviceOrientationCamera } from \"../../Cameras/deviceOrientationCamera.js\";\nimport { VRCameraMetrics } from \"./vrCameraMetrics.js\";\nimport { Vector3 } from \"../../Maths/math.vector.js\";\nimport { Node } from \"../../node.js\";\nimport { setVRRigMode } from \"../RigModes/vrRigMode.js\";\nNode.AddNodeConstructor(\"VRDeviceOrientationFreeCamera\", (name, scene) => {\n    return () => new VRDeviceOrientationFreeCamera(name, Vector3.Zero(), scene);\n});\n/**\n * Camera used to simulate VR rendering (based on FreeCamera)\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_introduction#vr-device-orientation-cameras\n */\nexport class VRDeviceOrientationFreeCamera extends DeviceOrientationCamera {\n    /**\n     * Creates a new VRDeviceOrientationFreeCamera\n     * @param name defines camera name\n     * @param position defines the start position of the camera\n     * @param scene defines the scene the camera belongs to\n     * @param compensateDistortion defines if the camera needs to compensate the lens distortion\n     * @param vrCameraMetrics defines the vr metrics associated to the camera\n     */\n    constructor(name, position, scene, compensateDistortion = true, vrCameraMetrics = VRCameraMetrics.GetDefault()) {\n        super(name, position, scene);\n        this._setRigMode = setVRRigMode.bind(null, this);\n        vrCameraMetrics.compensateDistortion = compensateDistortion;\n        this.setCameraRigMode(Camera.RIG_MODE_VR, { vrCameraMetrics: vrCameraMetrics });\n    }\n    /**\n     * Gets camera class name\n     * @returns VRDeviceOrientationFreeCamera\n     */\n    getClassName() {\n        return \"VRDeviceOrientationFreeCamera\";\n    }\n}\n//# sourceMappingURL=vrDeviceOrientationFreeCamera.js.map","import { Logger } from \"../../Misc/logger.js\";\nimport { Observable } from \"../../Misc/observable.js\";\nimport { FreeCamera } from \"../../Cameras/freeCamera.js\";\nimport { TargetCamera } from \"../../Cameras/targetCamera.js\";\nimport { DeviceOrientationCamera } from \"../../Cameras/deviceOrientationCamera.js\";\nimport { VRDeviceOrientationFreeCamera } from \"../../Cameras/VR/vrDeviceOrientationFreeCamera.js\";\nimport { WebVRFreeCamera } from \"../../Cameras/VR/webVRCamera.js\";\nimport { PointerEventTypes } from \"../../Events/pointerEvents.js\";\nimport { Quaternion, Matrix, Vector3 } from \"../../Maths/math.vector.js\";\nimport { Color3, Color4 } from \"../../Maths/math.color.js\";\nimport { Gamepad } from \"../../Gamepads/gamepad.js\";\nimport { PoseEnabledController, PoseEnabledControllerType } from \"../../Gamepads/Controllers/poseEnabledController.js\";\nimport { WebVRController } from \"../../Gamepads/Controllers/webVRController.js\";\nimport { Xbox360Button } from \"../../Gamepads/xboxGamepad.js\";\nimport { Mesh } from \"../../Meshes/mesh.js\";\nimport { Ray } from \"../../Culling/ray.js\";\nimport { ImageProcessingConfiguration } from \"../../Materials/imageProcessingConfiguration.js\";\nimport { StandardMaterial } from \"../../Materials/standardMaterial.js\";\nimport { DynamicTexture } from \"../../Materials/Textures/dynamicTexture.js\";\nimport { ImageProcessingPostProcess } from \"../../PostProcesses/imageProcessingPostProcess.js\";\nimport { SineEase, EasingFunction, CircleEase } from \"../../Animations/easing.js\";\nimport { Animation } from \"../../Animations/animation.js\";\nimport { VRCameraMetrics } from \"../../Cameras/VR/vrCameraMetrics.js\";\nimport \"../../Gamepads/gamepadSceneComponent.js\";\nimport \"../../Animations/animatable.js\";\nimport { Axis } from \"../../Maths/math.axis.js\";\nimport { WebXRSessionManager } from \"../../XR/webXRSessionManager.js\";\nimport { WebXRState } from \"../../XR/webXRTypes.js\";\nimport { CreateCylinder } from \"../../Meshes/Builders/cylinderBuilder.js\";\nimport { CreateTorus } from \"../../Meshes/Builders/torusBuilder.js\";\nimport { CreateGround } from \"../../Meshes/Builders/groundBuilder.js\";\nclass VRExperienceHelperGazer {\n    constructor(scene, gazeTrackerToClone = null) {\n        this.scene = scene;\n        /** @internal */\n        this._pointerDownOnMeshAsked = false;\n        /** @internal */\n        this._isActionableMesh = false;\n        /** @internal */\n        this._teleportationRequestInitiated = false;\n        /** @internal */\n        this._teleportationBackRequestInitiated = false;\n        /** @internal */\n        this._rotationRightAsked = false;\n        /** @internal */\n        this._rotationLeftAsked = false;\n        /** @internal */\n        this._dpadPressed = true;\n        /** @internal */\n        this._activePointer = false;\n        this._id = VRExperienceHelperGazer._IdCounter++;\n        // Gaze tracker\n        if (!gazeTrackerToClone) {\n            this._gazeTracker = CreateTorus(\"gazeTracker\", {\n                diameter: 0.0035,\n                thickness: 0.0025,\n                tessellation: 20,\n                updatable: false,\n            }, scene);\n            this._gazeTracker.bakeCurrentTransformIntoVertices();\n            this._gazeTracker.isPickable = false;\n            this._gazeTracker.isVisible = false;\n            const targetMat = new StandardMaterial(\"targetMat\", scene);\n            targetMat.specularColor = Color3.Black();\n            targetMat.emissiveColor = new Color3(0.7, 0.7, 0.7);\n            targetMat.backFaceCulling = false;\n            this._gazeTracker.material = targetMat;\n        }\n        else {\n            this._gazeTracker = gazeTrackerToClone.clone(\"gazeTracker\");\n        }\n    }\n    /**\n     * @internal\n     */\n    _getForwardRay(length) {\n        return new Ray(Vector3.Zero(), new Vector3(0, 0, length));\n    }\n    /** @internal */\n    _selectionPointerDown() {\n        this._pointerDownOnMeshAsked = true;\n        if (this._currentHit) {\n            this.scene.simulatePointerDown(this._currentHit, { pointerId: this._id });\n        }\n    }\n    /** @internal */\n    _selectionPointerUp() {\n        if (this._currentHit) {\n            this.scene.simulatePointerUp(this._currentHit, { pointerId: this._id });\n        }\n        this._pointerDownOnMeshAsked = false;\n    }\n    /** @internal */\n    _activatePointer() {\n        this._activePointer = true;\n    }\n    /** @internal */\n    _deactivatePointer() {\n        this._activePointer = false;\n    }\n    /**\n     * @internal\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _updatePointerDistance(distance = 100) { }\n    dispose() {\n        this._interactionsEnabled = false;\n        this._teleportationEnabled = false;\n        if (this._gazeTracker) {\n            this._gazeTracker.dispose();\n        }\n    }\n}\nVRExperienceHelperGazer._IdCounter = 0;\nclass VRExperienceHelperControllerGazer extends VRExperienceHelperGazer {\n    constructor(webVRController, scene, gazeTrackerToClone) {\n        super(scene, gazeTrackerToClone);\n        this.webVRController = webVRController;\n        // Laser pointer\n        this._laserPointer = CreateCylinder(\"laserPointer\", {\n            updatable: false,\n            height: 1,\n            diameterTop: 0.004,\n            diameterBottom: 0.0002,\n            tessellation: 20,\n            subdivisions: 1,\n        }, scene);\n        const laserPointerMaterial = new StandardMaterial(\"laserPointerMat\", scene);\n        laserPointerMaterial.emissiveColor = new Color3(0.7, 0.7, 0.7);\n        laserPointerMaterial.alpha = 0.6;\n        this._laserPointer.material = laserPointerMaterial;\n        this._laserPointer.rotation.x = Math.PI / 2;\n        this._laserPointer.position.z = -0.5;\n        this._laserPointer.isVisible = false;\n        this._laserPointer.isPickable = false;\n        if (!webVRController.mesh) {\n            // Create an empty mesh that is used prior to loading the high quality model\n            const preloadMesh = new Mesh(\"preloadControllerMesh\", scene);\n            const preloadPointerPose = new Mesh(PoseEnabledController.POINTING_POSE, scene);\n            preloadPointerPose.rotation.x = -0.7;\n            preloadMesh.addChild(preloadPointerPose);\n            webVRController.attachToMesh(preloadMesh);\n        }\n        this._setLaserPointerParent(webVRController.mesh);\n        this._meshAttachedObserver = webVRController._meshAttachedObservable.add((mesh) => {\n            this._setLaserPointerParent(mesh);\n        });\n    }\n    _getForwardRay(length) {\n        return this.webVRController.getForwardRay(length);\n    }\n    /** @internal */\n    _activatePointer() {\n        super._activatePointer();\n        this._laserPointer.isVisible = true;\n    }\n    /** @internal */\n    _deactivatePointer() {\n        super._deactivatePointer();\n        this._laserPointer.isVisible = false;\n    }\n    /**\n     * @internal\n     */\n    _setLaserPointerColor(color) {\n        this._laserPointer.material.emissiveColor = color;\n    }\n    /**\n     * @internal\n     */\n    _setLaserPointerLightingDisabled(disabled) {\n        this._laserPointer.material.disableLighting = disabled;\n    }\n    /**\n     * @internal\n     */\n    _setLaserPointerParent(mesh) {\n        const makeNotPick = (root) => {\n            root.isPickable = false;\n            root.getChildMeshes().forEach((c) => {\n                makeNotPick(c);\n            });\n        };\n        makeNotPick(mesh);\n        const meshChildren = mesh.getChildren(undefined, false);\n        let laserParent = mesh;\n        this.webVRController._pointingPoseNode = null;\n        for (let i = 0; i < meshChildren.length; i++) {\n            if (meshChildren[i].name && meshChildren[i].name.indexOf(PoseEnabledController.POINTING_POSE) >= 0) {\n                laserParent = meshChildren[i];\n                this.webVRController._pointingPoseNode = laserParent;\n                break;\n            }\n        }\n        this._laserPointer.parent = laserParent;\n    }\n    _updatePointerDistance(distance = 100) {\n        this._laserPointer.scaling.y = distance;\n        this._laserPointer.position.z = -distance / 2;\n    }\n    dispose() {\n        super.dispose();\n        this._laserPointer.dispose();\n        if (this._meshAttachedObserver) {\n            this.webVRController._meshAttachedObservable.remove(this._meshAttachedObserver);\n        }\n    }\n}\nclass VRExperienceHelperCameraGazer extends VRExperienceHelperGazer {\n    constructor(_getCamera, scene) {\n        super(scene);\n        this._getCamera = _getCamera;\n    }\n    _getForwardRay(length) {\n        const camera = this._getCamera();\n        if (camera) {\n            return camera.getForwardRay(length);\n        }\n        else {\n            return new Ray(Vector3.Zero(), Vector3.Forward());\n        }\n    }\n}\n/**\n * Event containing information after VR has been entered\n */\nexport class OnAfterEnteringVRObservableEvent {\n}\n/**\n * Helps to quickly add VR support to an existing scene.\n * See https://doc.babylonjs.com/features/featuresDeepDive/cameras/webVRHelper\n * @deprecated\n */\nexport class VRExperienceHelper {\n    /** Return this.onEnteringVRObservable\n     * Note: This one is for backward compatibility. Please use onEnteringVRObservable directly\n     */\n    get onEnteringVR() {\n        return this.onEnteringVRObservable;\n    }\n    /** Return this.onExitingVRObservable\n     * Note: This one is for backward compatibility. Please use onExitingVRObservable directly\n     */\n    get onExitingVR() {\n        return this.onExitingVRObservable;\n    }\n    /** Return this.onControllerMeshLoadedObservable\n     * Note: This one is for backward compatibility. Please use onControllerMeshLoadedObservable directly\n     */\n    get onControllerMeshLoaded() {\n        return this.onControllerMeshLoadedObservable;\n    }\n    /**\n     * The mesh used to display where the user is going to teleport.\n     */\n    get teleportationTarget() {\n        return this._teleportationTarget;\n    }\n    /**\n     * Sets the mesh to be used to display where the user is going to teleport.\n     */\n    set teleportationTarget(value) {\n        if (value) {\n            value.name = \"teleportationTarget\";\n            this._isDefaultTeleportationTarget = false;\n            this._teleportationTarget = value;\n        }\n    }\n    /**\n     * The mesh used to display where the user is selecting, this mesh will be cloned and set as the gazeTracker for the left and right controller\n     * when set bakeCurrentTransformIntoVertices will be called on the mesh.\n     * See https://doc.babylonjs.com/features/featuresDeepDive/mesh/transforms/center_origin/bakingTransforms\n     */\n    get gazeTrackerMesh() {\n        return this._cameraGazer._gazeTracker;\n    }\n    set gazeTrackerMesh(value) {\n        if (value) {\n            // Dispose of existing meshes\n            if (this._cameraGazer._gazeTracker) {\n                this._cameraGazer._gazeTracker.dispose();\n            }\n            if (this._leftController && this._leftController._gazeTracker) {\n                this._leftController._gazeTracker.dispose();\n            }\n            if (this._rightController && this._rightController._gazeTracker) {\n                this._rightController._gazeTracker.dispose();\n            }\n            // Set and create gaze trackers on head and controllers\n            this._cameraGazer._gazeTracker = value;\n            this._cameraGazer._gazeTracker.bakeCurrentTransformIntoVertices();\n            this._cameraGazer._gazeTracker.isPickable = false;\n            this._cameraGazer._gazeTracker.isVisible = false;\n            this._cameraGazer._gazeTracker.name = \"gazeTracker\";\n            if (this._leftController) {\n                this._leftController._gazeTracker = this._cameraGazer._gazeTracker.clone(\"gazeTracker\");\n            }\n            if (this._rightController) {\n                this._rightController._gazeTracker = this._cameraGazer._gazeTracker.clone(\"gazeTracker\");\n            }\n        }\n    }\n    /**\n     * The gaze tracking mesh corresponding to the left controller\n     */\n    get leftControllerGazeTrackerMesh() {\n        if (this._leftController) {\n            return this._leftController._gazeTracker;\n        }\n        return null;\n    }\n    /**\n     * The gaze tracking mesh corresponding to the right controller\n     */\n    get rightControllerGazeTrackerMesh() {\n        if (this._rightController) {\n            return this._rightController._gazeTracker;\n        }\n        return null;\n    }\n    /**\n     * If the ray of the gaze should be displayed.\n     */\n    get displayGaze() {\n        return this._displayGaze;\n    }\n    /**\n     * Sets if the ray of the gaze should be displayed.\n     */\n    set displayGaze(value) {\n        this._displayGaze = value;\n        if (!value) {\n            this._cameraGazer._gazeTracker.isVisible = false;\n            if (this._leftController) {\n                this._leftController._gazeTracker.isVisible = false;\n            }\n            if (this._rightController) {\n                this._rightController._gazeTracker.isVisible = false;\n            }\n        }\n    }\n    /**\n     * If the ray of the LaserPointer should be displayed.\n     */\n    get displayLaserPointer() {\n        return this._displayLaserPointer;\n    }\n    /**\n     * Sets if the ray of the LaserPointer should be displayed.\n     */\n    set displayLaserPointer(value) {\n        this._displayLaserPointer = value;\n        if (!value) {\n            if (this._rightController) {\n                this._rightController._deactivatePointer();\n                this._rightController._gazeTracker.isVisible = false;\n            }\n            if (this._leftController) {\n                this._leftController._deactivatePointer();\n                this._leftController._gazeTracker.isVisible = false;\n            }\n        }\n        else {\n            if (this._rightController) {\n                this._rightController._activatePointer();\n            }\n            if (this._leftController) {\n                this._leftController._activatePointer();\n            }\n        }\n    }\n    /**\n     * The deviceOrientationCamera used as the camera when not in VR.\n     */\n    get deviceOrientationCamera() {\n        return this._deviceOrientationCamera;\n    }\n    /**\n     * Based on the current WebVR support, returns the current VR camera used.\n     */\n    get currentVRCamera() {\n        if (this._webVRready) {\n            return this._webVRCamera;\n        }\n        else {\n            return this._scene.activeCamera;\n        }\n    }\n    /**\n     * The webVRCamera which is used when in VR.\n     */\n    get webVRCamera() {\n        return this._webVRCamera;\n    }\n    /**\n     * The deviceOrientationCamera that is used as a fallback when vr device is not connected.\n     */\n    get vrDeviceOrientationCamera() {\n        return this._vrDeviceOrientationCamera;\n    }\n    /**\n     * The html button that is used to trigger entering into VR.\n     */\n    get vrButton() {\n        return this._btnVR;\n    }\n    get _teleportationRequestInitiated() {\n        const result = this._cameraGazer._teleportationRequestInitiated ||\n            (this._leftController !== null && this._leftController._teleportationRequestInitiated) ||\n            (this._rightController !== null && this._rightController._teleportationRequestInitiated);\n        return result;\n    }\n    /**\n     * Instantiates a VRExperienceHelper.\n     * Helps to quickly add VR support to an existing scene.\n     * @param scene The scene the VRExperienceHelper belongs to.\n     * @param webVROptions Options to modify the vr experience helper's behavior.\n     */\n    constructor(scene, \n    /** Options to modify the vr experience helper's behavior. */\n    webVROptions = {}) {\n        this.webVROptions = webVROptions;\n        // Can the system support WebVR, even if a headset isn't plugged in?\n        this._webVRsupported = false;\n        // If WebVR is supported, is a headset plugged in and are we ready to present?\n        this._webVRready = false;\n        // Are we waiting for the requestPresent callback to complete?\n        this._webVRrequesting = false;\n        // Are we presenting to the headset right now? (this is the vrDevice state)\n        this._webVRpresenting = false;\n        // Are we presenting in the fullscreen fallback?\n        this._fullscreenVRpresenting = false;\n        /**\n         * Gets or sets a boolean indicating that gaze can be enabled even if pointer lock is not engage (useful on iOS where fullscreen mode and pointer lock are not supported)\n         */\n        this.enableGazeEvenWhenNoPointerLock = false;\n        /**\n         * Gets or sets a boolean indicating that the VREXperienceHelper will exit VR if double tap is detected\n         */\n        this.exitVROnDoubleTap = true;\n        /**\n         * Observable raised right before entering VR.\n         */\n        this.onEnteringVRObservable = new Observable();\n        /**\n         * Observable raised when entering VR has completed.\n         */\n        this.onAfterEnteringVRObservable = new Observable();\n        /**\n         * Observable raised when exiting VR.\n         */\n        this.onExitingVRObservable = new Observable();\n        /**\n         * Observable raised when controller mesh is loaded.\n         */\n        this.onControllerMeshLoadedObservable = new Observable();\n        this._useCustomVRButton = false;\n        this._teleportationRequested = false;\n        this._teleportActive = false;\n        this._floorMeshesCollection = [];\n        this._teleportationMode = VRExperienceHelper.TELEPORTATIONMODE_CONSTANTTIME;\n        this._teleportationTime = 122;\n        this._teleportationSpeed = 20;\n        this._rotationAllowed = true;\n        this._teleportBackwardsVector = new Vector3(0, -1, -1);\n        this._isDefaultTeleportationTarget = true;\n        this._teleportationFillColor = \"#444444\";\n        this._teleportationBorderColor = \"#FFFFFF\";\n        this._rotationAngle = 0;\n        this._haloCenter = new Vector3(0, 0, 0);\n        this._padSensibilityUp = 0.65;\n        this._padSensibilityDown = 0.35;\n        this._leftController = null;\n        this._rightController = null;\n        this._gazeColor = new Color3(0.7, 0.7, 0.7);\n        this._laserColor = new Color3(0.7, 0.7, 0.7);\n        this._pickedLaserColor = new Color3(0.2, 0.2, 1);\n        this._pickedGazeColor = new Color3(0, 0, 1);\n        /**\n         * Observable raised when a new mesh is selected based on meshSelectionPredicate\n         */\n        this.onNewMeshSelected = new Observable();\n        /**\n         * Observable raised when a new mesh is selected based on meshSelectionPredicate.\n         * This observable will provide the mesh and the controller used to select the mesh\n         */\n        this.onMeshSelectedWithController = new Observable();\n        /**\n         * Observable raised when a new mesh is picked based on meshSelectionPredicate\n         */\n        this.onNewMeshPicked = new Observable();\n        /**\n         * Observable raised before camera teleportation\n         */\n        this.onBeforeCameraTeleport = new Observable();\n        /**\n         *  Observable raised after camera teleportation\n         */\n        this.onAfterCameraTeleport = new Observable();\n        /**\n         * Observable raised when current selected mesh gets unselected\n         */\n        this.onSelectedMeshUnselected = new Observable();\n        /**\n         * Set teleportation enabled. If set to false camera teleportation will be disabled but camera rotation will be kept.\n         */\n        this.teleportationEnabled = true;\n        this._teleportationInitialized = false;\n        this._interactionsEnabled = false;\n        this._interactionsRequested = false;\n        this._displayGaze = true;\n        this._displayLaserPointer = true;\n        /**\n         * If the gaze trackers scale should be updated to be constant size when pointing at near/far meshes\n         */\n        this.updateGazeTrackerScale = true;\n        /**\n         * If the gaze trackers color should be updated when selecting meshes\n         */\n        this.updateGazeTrackerColor = true;\n        /**\n         * If the controller laser color should be updated when selecting meshes\n         */\n        this.updateControllerLaserColor = true;\n        /**\n         * Defines whether or not Pointer lock should be requested when switching to\n         * full screen.\n         */\n        this.requestPointerLockOnFullScreen = true;\n        /**\n         * Was the XR test done already. If this is true AND this.xr exists, xr is initialized.\n         * If this is true and no this.xr, xr exists but is not supported, using WebVR.\n         */\n        this.xrTestDone = false;\n        this._onResize = () => {\n            this._moveButtonToBottomRight();\n            if (this._fullscreenVRpresenting && this._webVRready) {\n                this.exitVR();\n            }\n        };\n        this._onFullscreenChange = () => {\n            this._fullscreenVRpresenting = !!document.fullscreenElement;\n            if (!this._fullscreenVRpresenting && this._inputElement) {\n                this.exitVR();\n                if (!this._useCustomVRButton && this._btnVR) {\n                    this._btnVR.style.top = this._inputElement.offsetTop + this._inputElement.offsetHeight - 70 + \"px\";\n                    this._btnVR.style.left = this._inputElement.offsetLeft + this._inputElement.offsetWidth - 100 + \"px\";\n                    // make sure the button is visible after setting its position\n                    this._updateButtonVisibility();\n                }\n            }\n        };\n        this._cachedAngularSensibility = { angularSensibilityX: null, angularSensibilityY: null, angularSensibility: null };\n        this._beforeRender = () => {\n            if (this._leftController && this._leftController._activePointer) {\n                this._castRayAndSelectObject(this._leftController);\n            }\n            if (this._rightController && this._rightController._activePointer) {\n                this._castRayAndSelectObject(this._rightController);\n            }\n            if (this._noControllerIsActive && (this._scene.getEngine().isPointerLock || this.enableGazeEvenWhenNoPointerLock)) {\n                this._castRayAndSelectObject(this._cameraGazer);\n            }\n            else {\n                this._cameraGazer._gazeTracker.isVisible = false;\n            }\n        };\n        this._onNewGamepadConnected = (gamepad) => {\n            if (gamepad.type !== Gamepad.POSE_ENABLED) {\n                if (gamepad.leftStick) {\n                    gamepad.onleftstickchanged((stickValues) => {\n                        if (this._teleportationInitialized && this.teleportationEnabled) {\n                            // Listening to classic/xbox gamepad only if no VR controller is active\n                            if ((!this._leftController && !this._rightController) ||\n                                (this._leftController && !this._leftController._activePointer && this._rightController && !this._rightController._activePointer)) {\n                                this._checkTeleportWithRay(stickValues, this._cameraGazer);\n                                this._checkTeleportBackwards(stickValues, this._cameraGazer);\n                            }\n                        }\n                    });\n                }\n                if (gamepad.rightStick) {\n                    gamepad.onrightstickchanged((stickValues) => {\n                        if (this._teleportationInitialized) {\n                            this._checkRotate(stickValues, this._cameraGazer);\n                        }\n                    });\n                }\n                if (gamepad.type === Gamepad.XBOX) {\n                    gamepad.onbuttondown((buttonPressed) => {\n                        if (this._interactionsEnabled && buttonPressed === Xbox360Button.A) {\n                            this._cameraGazer._selectionPointerDown();\n                        }\n                    });\n                    gamepad.onbuttonup((buttonPressed) => {\n                        if (this._interactionsEnabled && buttonPressed === Xbox360Button.A) {\n                            this._cameraGazer._selectionPointerUp();\n                        }\n                    });\n                }\n            }\n            else {\n                const webVRController = gamepad;\n                const controller = new VRExperienceHelperControllerGazer(webVRController, this._scene, this._cameraGazer._gazeTracker);\n                if (webVRController.hand === \"right\" || (this._leftController && this._leftController.webVRController != webVRController)) {\n                    this._rightController = controller;\n                }\n                else {\n                    this._leftController = controller;\n                }\n                this._tryEnableInteractionOnController(controller);\n            }\n        };\n        // This only succeeds if the controller's mesh exists for the controller so this must be called whenever new controller is connected or when mesh is loaded\n        this._tryEnableInteractionOnController = (controller) => {\n            if (this._interactionsRequested && !controller._interactionsEnabled) {\n                this._enableInteractionOnController(controller);\n            }\n            if (this._teleportationRequested && !controller._teleportationEnabled) {\n                this._enableTeleportationOnController(controller);\n            }\n        };\n        this._onNewGamepadDisconnected = (gamepad) => {\n            if (gamepad instanceof WebVRController) {\n                if (gamepad.hand === \"left\" && this._leftController != null) {\n                    this._leftController.dispose();\n                    this._leftController = null;\n                }\n                if (gamepad.hand === \"right\" && this._rightController != null) {\n                    this._rightController.dispose();\n                    this._rightController = null;\n                }\n            }\n        };\n        this._workingVector = Vector3.Zero();\n        this._workingQuaternion = Quaternion.Identity();\n        this._workingMatrix = Matrix.Identity();\n        Logger.Warn(\"WebVR is deprecated. Please avoid using this experience helper and use the WebXR experience helper instead\");\n        this._scene = scene;\n        this._inputElement = scene.getEngine().getInputElement();\n        // check for VR support:\n        const vrSupported = \"getVRDisplays\" in navigator;\n        // no VR support? force XR but only when it is not set because web vr can work without the getVRDisplays\n        if (!vrSupported && webVROptions.useXR === undefined) {\n            webVROptions.useXR = true;\n        }\n        // Parse options\n        if (webVROptions.createFallbackVRDeviceOrientationFreeCamera === undefined) {\n            webVROptions.createFallbackVRDeviceOrientationFreeCamera = true;\n        }\n        if (webVROptions.createDeviceOrientationCamera === undefined) {\n            webVROptions.createDeviceOrientationCamera = true;\n        }\n        if (webVROptions.laserToggle === undefined) {\n            webVROptions.laserToggle = true;\n        }\n        if (webVROptions.defaultHeight === undefined) {\n            webVROptions.defaultHeight = 1.7;\n        }\n        if (webVROptions.useCustomVRButton) {\n            this._useCustomVRButton = true;\n            if (webVROptions.customVRButton) {\n                this._btnVR = webVROptions.customVRButton;\n            }\n        }\n        if (webVROptions.rayLength) {\n            this._rayLength = webVROptions.rayLength;\n        }\n        this._defaultHeight = webVROptions.defaultHeight;\n        if (webVROptions.positionScale) {\n            this._rayLength *= webVROptions.positionScale;\n            this._defaultHeight *= webVROptions.positionScale;\n        }\n        this._hasEnteredVR = false;\n        // Set position\n        if (this._scene.activeCamera) {\n            this._position = this._scene.activeCamera.position.clone();\n        }\n        else {\n            this._position = new Vector3(0, this._defaultHeight, 0);\n        }\n        // Set non-vr camera\n        if (webVROptions.createDeviceOrientationCamera || !this._scene.activeCamera) {\n            this._deviceOrientationCamera = new DeviceOrientationCamera(\"deviceOrientationVRHelper\", this._position.clone(), scene);\n            // Copy data from existing camera\n            if (this._scene.activeCamera) {\n                this._deviceOrientationCamera.minZ = this._scene.activeCamera.minZ;\n                this._deviceOrientationCamera.maxZ = this._scene.activeCamera.maxZ;\n                // Set rotation from previous camera\n                if (this._scene.activeCamera instanceof TargetCamera && this._scene.activeCamera.rotation) {\n                    const targetCamera = this._scene.activeCamera;\n                    if (targetCamera.rotationQuaternion) {\n                        this._deviceOrientationCamera.rotationQuaternion.copyFrom(targetCamera.rotationQuaternion);\n                    }\n                    else {\n                        this._deviceOrientationCamera.rotationQuaternion.copyFrom(Quaternion.RotationYawPitchRoll(targetCamera.rotation.y, targetCamera.rotation.x, targetCamera.rotation.z));\n                    }\n                    this._deviceOrientationCamera.rotation = targetCamera.rotation.clone();\n                }\n            }\n            this._scene.activeCamera = this._deviceOrientationCamera;\n            if (this._inputElement) {\n                this._scene.activeCamera.attachControl();\n            }\n        }\n        else {\n            this._existingCamera = this._scene.activeCamera;\n        }\n        if (this.webVROptions.useXR && navigator.xr) {\n            // force-check XR session support\n            WebXRSessionManager.IsSessionSupportedAsync(\"immersive-vr\").then((supported) => {\n                if (supported) {\n                    Logger.Log(\"Using WebXR. It is recommended to use the WebXRDefaultExperience directly\");\n                    // it is possible to use XR, let's do it!\n                    scene\n                        .createDefaultXRExperienceAsync({\n                        floorMeshes: webVROptions.floorMeshes || [],\n                    })\n                        .then((xr) => {\n                        this.xr = xr;\n                        // connect observables\n                        this.xrTestDone = true;\n                        this._cameraGazer = new VRExperienceHelperCameraGazer(() => {\n                            return this.xr.baseExperience.camera;\n                        }, scene);\n                        this.xr.baseExperience.onStateChangedObservable.add((state) => {\n                            // support for entering / exiting\n                            switch (state) {\n                                case WebXRState.ENTERING_XR:\n                                    this.onEnteringVRObservable.notifyObservers(this);\n                                    if (!this._interactionsEnabled) {\n                                        this.xr.pointerSelection.detach();\n                                    }\n                                    this.xr.pointerSelection.displayLaserPointer = this._displayLaserPointer;\n                                    break;\n                                case WebXRState.EXITING_XR:\n                                    this.onExitingVRObservable.notifyObservers(this);\n                                    // resize to update width and height when exiting vr exits fullscreen\n                                    this._scene.getEngine().resize();\n                                    break;\n                                case WebXRState.IN_XR:\n                                    this._hasEnteredVR = true;\n                                    break;\n                                case WebXRState.NOT_IN_XR:\n                                    this._hasEnteredVR = false;\n                                    break;\n                            }\n                        });\n                    });\n                }\n                else {\n                    // XR not supported (thou exists), continue WebVR init\n                    this._completeVRInit(scene, webVROptions);\n                }\n            });\n        }\n        else {\n            // no XR, continue init synchronous\n            this._completeVRInit(scene, webVROptions);\n        }\n    }\n    _completeVRInit(scene, webVROptions) {\n        this.xrTestDone = true;\n        // Create VR cameras\n        if (webVROptions.createFallbackVRDeviceOrientationFreeCamera) {\n            if (webVROptions.useMultiview) {\n                if (!webVROptions.vrDeviceOrientationCameraMetrics) {\n                    webVROptions.vrDeviceOrientationCameraMetrics = VRCameraMetrics.GetDefault();\n                }\n                webVROptions.vrDeviceOrientationCameraMetrics.multiviewEnabled = true;\n            }\n            this._vrDeviceOrientationCamera = new VRDeviceOrientationFreeCamera(\"VRDeviceOrientationVRHelper\", this._position, this._scene, true, webVROptions.vrDeviceOrientationCameraMetrics);\n            this._vrDeviceOrientationCamera.angularSensibility = Number.MAX_VALUE;\n        }\n        this._webVRCamera = new WebVRFreeCamera(\"WebVRHelper\", this._position, this._scene, webVROptions);\n        this._webVRCamera.useStandingMatrix();\n        this._cameraGazer = new VRExperienceHelperCameraGazer(() => {\n            return this.currentVRCamera;\n        }, scene);\n        // Create default button\n        if (!this._useCustomVRButton) {\n            this._btnVR = document.createElement(\"BUTTON\");\n            this._btnVR.className = \"babylonVRicon\";\n            this._btnVR.id = \"babylonVRiconbtn\";\n            this._btnVR.title = \"Click to switch to VR\";\n            const url = !window.SVGSVGElement\n                ? \"https://cdn.babylonjs.com/Assets/vrButton.png\"\n                : \"data:image/svg+xml;charset=UTF-8,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20width%3D%222048%22%20height%3D%221152%22%20viewBox%3D%220%200%202048%201152%22%20version%3D%221.1%22%3E%3Cpath%20transform%3D%22rotate%28180%201024%2C576.0000000000001%29%22%20d%3D%22m1109%2C896q17%2C0%2030%2C-12t13%2C-30t-12.5%2C-30.5t-30.5%2C-12.5l-170%2C0q-18%2C0%20-30.5%2C12.5t-12.5%2C30.5t13%2C30t30%2C12l170%2C0zm-85%2C256q59%2C0%20132.5%2C-1.5t154.5%2C-5.5t164.5%2C-11.5t163%2C-20t150%2C-30t124.5%2C-41.5q23%2C-11%2042%2C-24t38%2C-30q27%2C-25%2041%2C-61.5t14%2C-72.5l0%2C-257q0%2C-123%20-47%2C-232t-128%2C-190t-190%2C-128t-232%2C-47l-81%2C0q-37%2C0%20-68.5%2C14t-60.5%2C34.5t-55.5%2C45t-53%2C45t-53%2C34.5t-55.5%2C14t-55.5%2C-14t-53%2C-34.5t-53%2C-45t-55.5%2C-45t-60.5%2C-34.5t-68.5%2C-14l-81%2C0q-123%2C0%20-232%2C47t-190%2C128t-128%2C190t-47%2C232l0%2C257q0%2C68%2038%2C115t97%2C73q54%2C24%20124.5%2C41.5t150%2C30t163%2C20t164.5%2C11.5t154.5%2C5.5t132.5%2C1.5zm939%2C-298q0%2C39%20-24.5%2C67t-58.5%2C42q-54%2C23%20-122%2C39.5t-143.5%2C28t-155.5%2C19t-157%2C11t-148.5%2C5t-129.5%2C1.5q-59%2C0%20-130%2C-1.5t-148%2C-5t-157%2C-11t-155.5%2C-19t-143.5%2C-28t-122%2C-39.5q-34%2C-14%20-58.5%2C-42t-24.5%2C-67l0%2C-257q0%2C-106%2040.5%2C-199t110%2C-162.5t162.5%2C-109.5t199%2C-40l81%2C0q27%2C0%2052%2C14t50%2C34.5t51%2C44.5t55.5%2C44.5t63.5%2C34.5t74%2C14t74%2C-14t63.5%2C-34.5t55.5%2C-44.5t51%2C-44.5t50%2C-34.5t52%2C-14l14%2C0q37%2C0%2070%2C0.5t64.5%2C4.5t63.5%2C12t68%2C23q71%2C30%20128.5%2C78.5t98.5%2C110t63.5%2C133.5t22.5%2C149l0%2C257z%22%20fill%3D%22white%22%20/%3E%3C/svg%3E%0A\";\n            let css = \".babylonVRicon { position: absolute; right: 20px; height: 50px; width: 80px; background-color: rgba(51,51,51,0.7); background-image: url(\" +\n                url +\n                \"); background-size: 80%; background-repeat:no-repeat; background-position: center; border: none; outline: none; transition: transform 0.125s ease-out } .babylonVRicon:hover { transform: scale(1.05) } .babylonVRicon:active {background-color: rgba(51,51,51,1) } .babylonVRicon:focus {background-color: rgba(51,51,51,1) }\";\n            css += \".babylonVRicon.vrdisplaypresenting { display: none; }\";\n            // TODO: Add user feedback so that they know what state the VRDisplay is in (disconnected, connected, entering-VR)\n            // css += \".babylonVRicon.vrdisplaysupported { }\";\n            // css += \".babylonVRicon.vrdisplayready { }\";\n            // css += \".babylonVRicon.vrdisplayrequesting { }\";\n            const style = document.createElement(\"style\");\n            style.appendChild(document.createTextNode(css));\n            document.getElementsByTagName(\"head\")[0].appendChild(style);\n            this._moveButtonToBottomRight();\n        }\n        // VR button click event\n        if (this._btnVR) {\n            this._btnVR.addEventListener(\"click\", () => {\n                if (!this.isInVRMode) {\n                    this.enterVR();\n                }\n                else {\n                    this._scene.getEngine().disableVR();\n                }\n            });\n        }\n        // Window events\n        const hostWindow = this._scene.getEngine().getHostWindow();\n        if (!hostWindow) {\n            return;\n        }\n        hostWindow.addEventListener(\"resize\", this._onResize);\n        document.addEventListener(\"fullscreenchange\", this._onFullscreenChange, false);\n        // Display vr button when headset is connected\n        if (webVROptions.createFallbackVRDeviceOrientationFreeCamera) {\n            this._displayVRButton();\n        }\n        else {\n            this._scene.getEngine().onVRDisplayChangedObservable.add((e) => {\n                if (e.vrDisplay) {\n                    this._displayVRButton();\n                }\n            });\n        }\n        // Exiting VR mode using 'ESC' key on desktop\n        this._onKeyDown = (event) => {\n            if (event.keyCode === 27 && this.isInVRMode) {\n                this.exitVR();\n            }\n        };\n        document.addEventListener(\"keydown\", this._onKeyDown);\n        // Exiting VR mode double tapping the touch screen\n        this._scene.onPrePointerObservable.add(() => {\n            if (this._hasEnteredVR && this.exitVROnDoubleTap) {\n                this.exitVR();\n                if (this._fullscreenVRpresenting) {\n                    this._scene.getEngine().exitFullscreen();\n                }\n            }\n        }, PointerEventTypes.POINTERDOUBLETAP, false);\n        // Listen for WebVR display changes\n        this._onVRDisplayChangedBind = (eventArgs) => this._onVRDisplayChanged(eventArgs);\n        this._onVrDisplayPresentChangeBind = () => this._onVrDisplayPresentChange();\n        this._onVRRequestPresentStart = () => {\n            this._webVRrequesting = true;\n            this._updateButtonVisibility();\n        };\n        this._onVRRequestPresentComplete = () => {\n            this._webVRrequesting = false;\n            this._updateButtonVisibility();\n        };\n        scene.getEngine().onVRDisplayChangedObservable.add(this._onVRDisplayChangedBind);\n        scene.getEngine().onVRRequestPresentStart.add(this._onVRRequestPresentStart);\n        scene.getEngine().onVRRequestPresentComplete.add(this._onVRRequestPresentComplete);\n        hostWindow.addEventListener(\"vrdisplaypresentchange\", this._onVrDisplayPresentChangeBind);\n        scene.onDisposeObservable.add(() => {\n            this.dispose();\n        });\n        // Gamepad connection events\n        this._webVRCamera.onControllerMeshLoadedObservable.add((webVRController) => this._onDefaultMeshLoaded(webVRController));\n        this._scene.gamepadManager.onGamepadConnectedObservable.add(this._onNewGamepadConnected);\n        this._scene.gamepadManager.onGamepadDisconnectedObservable.add(this._onNewGamepadDisconnected);\n        this._updateButtonVisibility();\n        //create easing functions\n        this._circleEase = new CircleEase();\n        this._circleEase.setEasingMode(EasingFunction.EASINGMODE_EASEINOUT);\n        this._teleportationEasing = this._circleEase;\n        // Allow clicking in the vrDeviceOrientationCamera\n        scene.onPointerObservable.add((e) => {\n            if (this._interactionsEnabled) {\n                if (scene.activeCamera === this.vrDeviceOrientationCamera && e.event.pointerType === \"mouse\") {\n                    if (e.type === PointerEventTypes.POINTERDOWN) {\n                        this._cameraGazer._selectionPointerDown();\n                    }\n                    else if (e.type === PointerEventTypes.POINTERUP) {\n                        this._cameraGazer._selectionPointerUp();\n                    }\n                }\n            }\n        });\n        if (this.webVROptions.floorMeshes) {\n            this.enableTeleportation({ floorMeshes: this.webVROptions.floorMeshes });\n        }\n    }\n    // Raised when one of the controller has loaded successfully its associated default mesh\n    _onDefaultMeshLoaded(webVRController) {\n        if (this._leftController && this._leftController.webVRController == webVRController) {\n            if (webVRController.mesh) {\n                this._leftController._setLaserPointerParent(webVRController.mesh);\n            }\n        }\n        if (this._rightController && this._rightController.webVRController == webVRController) {\n            if (webVRController.mesh) {\n                this._rightController._setLaserPointerParent(webVRController.mesh);\n            }\n        }\n        try {\n            this.onControllerMeshLoadedObservable.notifyObservers(webVRController);\n        }\n        catch (err) {\n            Logger.Warn(\"Error in your custom logic onControllerMeshLoaded: \" + err);\n        }\n    }\n    /**\n     * Gets a value indicating if we are currently in VR mode.\n     */\n    get isInVRMode() {\n        return (this.xr && this.webVROptions.useXR && this.xr.baseExperience.state === WebXRState.IN_XR) || this._webVRpresenting || this._fullscreenVRpresenting;\n    }\n    _onVrDisplayPresentChange() {\n        const vrDisplay = this._scene.getEngine().getVRDevice();\n        if (vrDisplay) {\n            const wasPresenting = this._webVRpresenting;\n            this._webVRpresenting = vrDisplay.isPresenting;\n            if (wasPresenting && !this._webVRpresenting) {\n                this.exitVR();\n            }\n        }\n        else {\n            Logger.Warn(\"Detected VRDisplayPresentChange on an unknown VRDisplay. Did you can enterVR on the vrExperienceHelper?\");\n        }\n        this._updateButtonVisibility();\n    }\n    _onVRDisplayChanged(eventArgs) {\n        this._webVRsupported = eventArgs.vrSupported;\n        this._webVRready = !!eventArgs.vrDisplay;\n        this._webVRpresenting = eventArgs.vrDisplay && eventArgs.vrDisplay.isPresenting;\n        this._updateButtonVisibility();\n    }\n    _moveButtonToBottomRight() {\n        if (this._inputElement && !this._useCustomVRButton && this._btnVR) {\n            const rect = this._inputElement.getBoundingClientRect();\n            this._btnVR.style.top = rect.top + rect.height - 70 + \"px\";\n            this._btnVR.style.left = rect.left + rect.width - 100 + \"px\";\n        }\n    }\n    _displayVRButton() {\n        if (!this._useCustomVRButton && !this._btnVRDisplayed && this._btnVR) {\n            document.body.appendChild(this._btnVR);\n            this._btnVRDisplayed = true;\n        }\n    }\n    _updateButtonVisibility() {\n        if (!this._btnVR || this._useCustomVRButton) {\n            return;\n        }\n        this._btnVR.className = \"babylonVRicon\";\n        if (this.isInVRMode) {\n            this._btnVR.className += \" vrdisplaypresenting\";\n        }\n        else {\n            if (this._webVRready) {\n                this._btnVR.className += \" vrdisplayready\";\n            }\n            if (this._webVRsupported) {\n                this._btnVR.className += \" vrdisplaysupported\";\n            }\n            if (this._webVRrequesting) {\n                this._btnVR.className += \" vrdisplayrequesting\";\n            }\n        }\n    }\n    /**\n     * Attempt to enter VR. If a headset is connected and ready, will request present on that.\n     * Otherwise, will use the fullscreen API.\n     */\n    enterVR() {\n        if (this.xr) {\n            this.xr.baseExperience.enterXRAsync(\"immersive-vr\", \"local-floor\", this.xr.renderTarget);\n            return;\n        }\n        if (this.onEnteringVRObservable) {\n            try {\n                this.onEnteringVRObservable.notifyObservers(this);\n            }\n            catch (err) {\n                Logger.Warn(\"Error in your custom logic onEnteringVR: \" + err);\n            }\n        }\n        if (this._scene.activeCamera) {\n            this._position = this._scene.activeCamera.position.clone();\n            if (this.vrDeviceOrientationCamera) {\n                this.vrDeviceOrientationCamera.rotation = Quaternion.FromRotationMatrix(this._scene.activeCamera.getWorldMatrix().getRotationMatrix()).toEulerAngles();\n                this.vrDeviceOrientationCamera.angularSensibility = 2000;\n            }\n            if (this.webVRCamera) {\n                const currentYRotation = this.webVRCamera.deviceRotationQuaternion.toEulerAngles().y;\n                const desiredYRotation = Quaternion.FromRotationMatrix(this._scene.activeCamera.getWorldMatrix().getRotationMatrix()).toEulerAngles().y;\n                const delta = desiredYRotation - currentYRotation;\n                const currentGlobalRotation = this.webVRCamera.rotationQuaternion.toEulerAngles().y;\n                this.webVRCamera.rotationQuaternion = Quaternion.FromEulerAngles(0, currentGlobalRotation + delta, 0);\n            }\n            // make sure that we return to the last active camera\n            this._existingCamera = this._scene.activeCamera;\n            // Remove and cache angular sensability to avoid camera rotation when in VR\n            if (this._existingCamera.angularSensibilityX) {\n                this._cachedAngularSensibility.angularSensibilityX = this._existingCamera.angularSensibilityX;\n                this._existingCamera.angularSensibilityX = Number.MAX_VALUE;\n            }\n            if (this._existingCamera.angularSensibilityY) {\n                this._cachedAngularSensibility.angularSensibilityY = this._existingCamera.angularSensibilityY;\n                this._existingCamera.angularSensibilityY = Number.MAX_VALUE;\n            }\n            if (this._existingCamera.angularSensibility) {\n                this._cachedAngularSensibility.angularSensibility = this._existingCamera.angularSensibility;\n                this._existingCamera.angularSensibility = Number.MAX_VALUE;\n            }\n        }\n        if (this._webVRrequesting) {\n            return;\n        }\n        // If WebVR is supported and a headset is connected\n        if (this._webVRready) {\n            if (!this._webVRpresenting) {\n                this._scene.getEngine().onVRRequestPresentComplete.addOnce((result) => {\n                    this.onAfterEnteringVRObservable.notifyObservers({ success: result });\n                });\n                this._webVRCamera.position = this._position;\n                this._scene.activeCamera = this._webVRCamera;\n            }\n        }\n        else if (this._vrDeviceOrientationCamera) {\n            this._vrDeviceOrientationCamera.position = this._position;\n            if (this._scene.activeCamera) {\n                this._vrDeviceOrientationCamera.minZ = this._scene.activeCamera.minZ;\n            }\n            this._scene.activeCamera = this._vrDeviceOrientationCamera;\n            this._scene.getEngine().enterFullscreen(this.requestPointerLockOnFullScreen);\n            this._updateButtonVisibility();\n            this._vrDeviceOrientationCamera.onViewMatrixChangedObservable.addOnce(() => {\n                this.onAfterEnteringVRObservable.notifyObservers({ success: true });\n            });\n        }\n        if (this._scene.activeCamera && this._inputElement) {\n            this._scene.activeCamera.attachControl();\n        }\n        if (this._interactionsEnabled) {\n            this._scene.registerBeforeRender(this._beforeRender);\n        }\n        if (this._displayLaserPointer) {\n            [this._leftController, this._rightController].forEach((controller) => {\n                if (controller) {\n                    controller._activatePointer();\n                }\n            });\n        }\n        this._hasEnteredVR = true;\n    }\n    /**\n     * Attempt to exit VR, or fullscreen.\n     */\n    exitVR() {\n        if (this.xr) {\n            this.xr.baseExperience.exitXRAsync();\n            return;\n        }\n        if (this._hasEnteredVR) {\n            if (this.onExitingVRObservable) {\n                try {\n                    this.onExitingVRObservable.notifyObservers(this);\n                }\n                catch (err) {\n                    Logger.Warn(\"Error in your custom logic onExitingVR: \" + err);\n                }\n            }\n            if (this._webVRpresenting) {\n                this._scene.getEngine().disableVR();\n            }\n            if (this._scene.activeCamera) {\n                this._position = this._scene.activeCamera.position.clone();\n            }\n            if (this.vrDeviceOrientationCamera) {\n                this.vrDeviceOrientationCamera.angularSensibility = Number.MAX_VALUE;\n            }\n            if (this._deviceOrientationCamera) {\n                this._deviceOrientationCamera.position = this._position;\n                this._scene.activeCamera = this._deviceOrientationCamera;\n                // Restore angular sensibility\n                if (this._cachedAngularSensibility.angularSensibilityX) {\n                    this._deviceOrientationCamera.angularSensibilityX = this._cachedAngularSensibility.angularSensibilityX;\n                    this._cachedAngularSensibility.angularSensibilityX = null;\n                }\n                if (this._cachedAngularSensibility.angularSensibilityY) {\n                    this._deviceOrientationCamera.angularSensibilityY = this._cachedAngularSensibility.angularSensibilityY;\n                    this._cachedAngularSensibility.angularSensibilityY = null;\n                }\n                if (this._cachedAngularSensibility.angularSensibility) {\n                    this._deviceOrientationCamera.angularSensibility = this._cachedAngularSensibility.angularSensibility;\n                    this._cachedAngularSensibility.angularSensibility = null;\n                }\n            }\n            else if (this._existingCamera) {\n                this._existingCamera.position = this._position;\n                this._scene.activeCamera = this._existingCamera;\n                if (this._inputElement) {\n                    this._scene.activeCamera.attachControl();\n                }\n                // Restore angular sensibility\n                if (this._cachedAngularSensibility.angularSensibilityX) {\n                    this._existingCamera.angularSensibilityX = this._cachedAngularSensibility.angularSensibilityX;\n                    this._cachedAngularSensibility.angularSensibilityX = null;\n                }\n                if (this._cachedAngularSensibility.angularSensibilityY) {\n                    this._existingCamera.angularSensibilityY = this._cachedAngularSensibility.angularSensibilityY;\n                    this._cachedAngularSensibility.angularSensibilityY = null;\n                }\n                if (this._cachedAngularSensibility.angularSensibility) {\n                    this._existingCamera.angularSensibility = this._cachedAngularSensibility.angularSensibility;\n                    this._cachedAngularSensibility.angularSensibility = null;\n                }\n            }\n            this._updateButtonVisibility();\n            if (this._interactionsEnabled) {\n                this._scene.unregisterBeforeRender(this._beforeRender);\n                this._cameraGazer._gazeTracker.isVisible = false;\n                if (this._leftController) {\n                    this._leftController._gazeTracker.isVisible = false;\n                }\n                if (this._rightController) {\n                    this._rightController._gazeTracker.isVisible = false;\n                }\n            }\n            // resize to update width and height when exiting vr exits fullscreen\n            this._scene.getEngine().resize();\n            [this._leftController, this._rightController].forEach((controller) => {\n                if (controller) {\n                    controller._deactivatePointer();\n                }\n            });\n            this._hasEnteredVR = false;\n            // Update engine state to re enable non-vr camera input\n            const engine = this._scene.getEngine();\n            if (engine._onVrDisplayPresentChange) {\n                engine._onVrDisplayPresentChange();\n            }\n        }\n    }\n    /**\n     * The position of the vr experience helper.\n     */\n    get position() {\n        return this._position;\n    }\n    /**\n     * Sets the position of the vr experience helper.\n     */\n    set position(value) {\n        this._position = value;\n        if (this._scene.activeCamera) {\n            this._scene.activeCamera.position = value;\n        }\n    }\n    /**\n     * Enables controllers and user interactions such as selecting and object or clicking on an object.\n     */\n    enableInteractions() {\n        if (!this._interactionsEnabled) {\n            this._interactionsRequested = true;\n            // in XR it is enabled by default, but just to make sure, re-attach\n            if (this.xr) {\n                if (this.xr.baseExperience.state === WebXRState.IN_XR) {\n                    this.xr.pointerSelection.attach();\n                }\n                return;\n            }\n            if (this._leftController) {\n                this._enableInteractionOnController(this._leftController);\n            }\n            if (this._rightController) {\n                this._enableInteractionOnController(this._rightController);\n            }\n            this.raySelectionPredicate = (mesh) => {\n                return mesh.isVisible && (mesh.isPickable || mesh.name === this._floorMeshName);\n            };\n            this.meshSelectionPredicate = () => {\n                return true;\n            };\n            this._raySelectionPredicate = (mesh) => {\n                if (this._isTeleportationFloor(mesh) ||\n                    (mesh.name.indexOf(\"gazeTracker\") === -1 && mesh.name.indexOf(\"teleportationTarget\") === -1 && mesh.name.indexOf(\"torusTeleportation\") === -1)) {\n                    return this.raySelectionPredicate(mesh);\n                }\n                return false;\n            };\n            this._interactionsEnabled = true;\n        }\n    }\n    get _noControllerIsActive() {\n        return !(this._leftController && this._leftController._activePointer) && !(this._rightController && this._rightController._activePointer);\n    }\n    _isTeleportationFloor(mesh) {\n        for (let i = 0; i < this._floorMeshesCollection.length; i++) {\n            if (this._floorMeshesCollection[i].id === mesh.id) {\n                return true;\n            }\n        }\n        if (this._floorMeshName && mesh.name === this._floorMeshName) {\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Adds a floor mesh to be used for teleportation.\n     * @param floorMesh the mesh to be used for teleportation.\n     */\n    addFloorMesh(floorMesh) {\n        if (!this._floorMeshesCollection) {\n            return;\n        }\n        if (this._floorMeshesCollection.indexOf(floorMesh) > -1) {\n            return;\n        }\n        this._floorMeshesCollection.push(floorMesh);\n    }\n    /**\n     * Removes a floor mesh from being used for teleportation.\n     * @param floorMesh the mesh to be removed.\n     */\n    removeFloorMesh(floorMesh) {\n        if (!this._floorMeshesCollection) {\n            return;\n        }\n        const meshIndex = this._floorMeshesCollection.indexOf(floorMesh);\n        if (meshIndex !== -1) {\n            this._floorMeshesCollection.splice(meshIndex, 1);\n        }\n    }\n    /**\n     * Enables interactions and teleportation using the VR controllers and gaze.\n     * @param vrTeleportationOptions options to modify teleportation behavior.\n     */\n    enableTeleportation(vrTeleportationOptions = {}) {\n        if (!this._teleportationInitialized) {\n            this._teleportationRequested = true;\n            this.enableInteractions();\n            if (this.webVROptions.useXR && (vrTeleportationOptions.floorMeshes || vrTeleportationOptions.floorMeshName)) {\n                const floorMeshes = vrTeleportationOptions.floorMeshes || [];\n                if (!floorMeshes.length) {\n                    const floorMesh = this._scene.getMeshByName(vrTeleportationOptions.floorMeshName);\n                    if (floorMesh) {\n                        floorMeshes.push(floorMesh);\n                    }\n                }\n                if (this.xr) {\n                    floorMeshes.forEach((mesh) => {\n                        this.xr.teleportation.addFloorMesh(mesh);\n                    });\n                    if (!this.xr.teleportation.attached) {\n                        this.xr.teleportation.attach();\n                    }\n                    return;\n                }\n                else if (!this.xrTestDone) {\n                    const waitForXr = () => {\n                        if (this.xrTestDone) {\n                            this._scene.unregisterBeforeRender(waitForXr);\n                            if (this.xr) {\n                                if (!this.xr.teleportation.attached) {\n                                    this.xr.teleportation.attach();\n                                }\n                            }\n                            else {\n                                this.enableTeleportation(vrTeleportationOptions);\n                            }\n                        }\n                    };\n                    this._scene.registerBeforeRender(waitForXr);\n                    return;\n                }\n            }\n            if (vrTeleportationOptions.floorMeshName) {\n                this._floorMeshName = vrTeleportationOptions.floorMeshName;\n            }\n            if (vrTeleportationOptions.floorMeshes) {\n                this._floorMeshesCollection = vrTeleportationOptions.floorMeshes;\n            }\n            if (vrTeleportationOptions.teleportationMode) {\n                this._teleportationMode = vrTeleportationOptions.teleportationMode;\n            }\n            if (vrTeleportationOptions.teleportationTime && vrTeleportationOptions.teleportationTime > 0) {\n                this._teleportationTime = vrTeleportationOptions.teleportationTime;\n            }\n            if (vrTeleportationOptions.teleportationSpeed && vrTeleportationOptions.teleportationSpeed > 0) {\n                this._teleportationSpeed = vrTeleportationOptions.teleportationSpeed;\n            }\n            if (vrTeleportationOptions.easingFunction !== undefined) {\n                this._teleportationEasing = vrTeleportationOptions.easingFunction;\n            }\n            if (this._leftController != null) {\n                this._enableTeleportationOnController(this._leftController);\n            }\n            if (this._rightController != null) {\n                this._enableTeleportationOnController(this._rightController);\n            }\n            // Creates an image processing post process for the vignette not relying\n            // on the main scene configuration for image processing to reduce setup and spaces\n            // (gamma/linear) conflicts.\n            const imageProcessingConfiguration = new ImageProcessingConfiguration();\n            imageProcessingConfiguration.vignetteColor = new Color4(0, 0, 0, 0);\n            imageProcessingConfiguration.vignetteEnabled = true;\n            this._postProcessMove = new ImageProcessingPostProcess(\"postProcessMove\", 1.0, this._webVRCamera, undefined, undefined, undefined, undefined, imageProcessingConfiguration);\n            this._webVRCamera.detachPostProcess(this._postProcessMove);\n            this._teleportationInitialized = true;\n            if (this._isDefaultTeleportationTarget) {\n                this._createTeleportationCircles();\n                this._teleportationTarget.scaling.scaleInPlace(this._webVRCamera.deviceScaleFactor);\n            }\n        }\n    }\n    _enableInteractionOnController(controller) {\n        const controllerMesh = controller.webVRController.mesh;\n        if (controllerMesh) {\n            controller._interactionsEnabled = true;\n            if (this.isInVRMode && this._displayLaserPointer) {\n                controller._activatePointer();\n            }\n            if (this.webVROptions.laserToggle) {\n                controller.webVRController.onMainButtonStateChangedObservable.add((stateObject) => {\n                    // Enabling / disabling laserPointer\n                    if (this._displayLaserPointer && stateObject.value === 1) {\n                        if (controller._activePointer) {\n                            controller._deactivatePointer();\n                        }\n                        else {\n                            controller._activatePointer();\n                        }\n                        if (this.displayGaze) {\n                            controller._gazeTracker.isVisible = controller._activePointer;\n                        }\n                    }\n                });\n            }\n            controller.webVRController.onTriggerStateChangedObservable.add((stateObject) => {\n                let gazer = controller;\n                if (this._noControllerIsActive) {\n                    gazer = this._cameraGazer;\n                }\n                if (!gazer._pointerDownOnMeshAsked) {\n                    if (stateObject.value > this._padSensibilityUp) {\n                        gazer._selectionPointerDown();\n                    }\n                }\n                else if (stateObject.value < this._padSensibilityDown) {\n                    gazer._selectionPointerUp();\n                }\n            });\n        }\n    }\n    _checkTeleportWithRay(stateObject, gazer) {\n        // Dont teleport if another gaze already requested teleportation\n        if (this._teleportationRequestInitiated && !gazer._teleportationRequestInitiated) {\n            return;\n        }\n        if (!gazer._teleportationRequestInitiated) {\n            if (stateObject.y < -this._padSensibilityUp && gazer._dpadPressed) {\n                gazer._activatePointer();\n                gazer._teleportationRequestInitiated = true;\n            }\n        }\n        else {\n            // Listening to the proper controller values changes to confirm teleportation\n            if (Math.sqrt(stateObject.y * stateObject.y + stateObject.x * stateObject.x) < this._padSensibilityDown) {\n                if (this._teleportActive) {\n                    this.teleportCamera(this._haloCenter);\n                }\n                gazer._teleportationRequestInitiated = false;\n            }\n        }\n    }\n    _checkRotate(stateObject, gazer) {\n        // Only rotate when user is not currently selecting a teleportation location\n        if (gazer._teleportationRequestInitiated) {\n            return;\n        }\n        if (!gazer._rotationLeftAsked) {\n            if (stateObject.x < -this._padSensibilityUp && gazer._dpadPressed) {\n                gazer._rotationLeftAsked = true;\n                if (this._rotationAllowed) {\n                    this._rotateCamera(false);\n                }\n            }\n        }\n        else {\n            if (stateObject.x > -this._padSensibilityDown) {\n                gazer._rotationLeftAsked = false;\n            }\n        }\n        if (!gazer._rotationRightAsked) {\n            if (stateObject.x > this._padSensibilityUp && gazer._dpadPressed) {\n                gazer._rotationRightAsked = true;\n                if (this._rotationAllowed) {\n                    this._rotateCamera(true);\n                }\n            }\n        }\n        else {\n            if (stateObject.x < this._padSensibilityDown) {\n                gazer._rotationRightAsked = false;\n            }\n        }\n    }\n    _checkTeleportBackwards(stateObject, gazer) {\n        // Only teleport backwards when user is not currently selecting a teleportation location\n        if (gazer._teleportationRequestInitiated) {\n            return;\n        }\n        // Teleport backwards\n        if (stateObject.y > this._padSensibilityUp && gazer._dpadPressed) {\n            if (!gazer._teleportationBackRequestInitiated) {\n                if (!this.currentVRCamera) {\n                    return;\n                }\n                // Get rotation and position of the current camera\n                let rotation = Quaternion.FromRotationMatrix(this.currentVRCamera.getWorldMatrix().getRotationMatrix());\n                let position = this.currentVRCamera.position;\n                // If the camera has device position, use that instead\n                if (this.currentVRCamera.devicePosition && this.currentVRCamera.deviceRotationQuaternion) {\n                    rotation = this.currentVRCamera.deviceRotationQuaternion;\n                    position = this.currentVRCamera.devicePosition;\n                }\n                // Get matrix with only the y rotation of the device rotation\n                rotation.toEulerAnglesToRef(this._workingVector);\n                this._workingVector.z = 0;\n                this._workingVector.x = 0;\n                Quaternion.RotationYawPitchRollToRef(this._workingVector.y, this._workingVector.x, this._workingVector.z, this._workingQuaternion);\n                this._workingQuaternion.toRotationMatrix(this._workingMatrix);\n                // Rotate backwards ray by device rotation to cast at the ground behind the user\n                Vector3.TransformCoordinatesToRef(this._teleportBackwardsVector, this._workingMatrix, this._workingVector);\n                // Teleport if ray hit the ground and is not to far away eg. backwards off a cliff\n                const ray = new Ray(position, this._workingVector);\n                const hit = this._scene.pickWithRay(ray, this._raySelectionPredicate);\n                if (hit && hit.pickedPoint && hit.pickedMesh && this._isTeleportationFloor(hit.pickedMesh) && hit.distance < 5) {\n                    this.teleportCamera(hit.pickedPoint);\n                }\n                gazer._teleportationBackRequestInitiated = true;\n            }\n        }\n        else {\n            gazer._teleportationBackRequestInitiated = false;\n        }\n    }\n    _enableTeleportationOnController(controller) {\n        const controllerMesh = controller.webVRController.mesh;\n        if (controllerMesh) {\n            if (!controller._interactionsEnabled) {\n                this._enableInteractionOnController(controller);\n            }\n            controller._interactionsEnabled = true;\n            controller._teleportationEnabled = true;\n            if (controller.webVRController.controllerType === PoseEnabledControllerType.VIVE) {\n                controller._dpadPressed = false;\n                controller.webVRController.onPadStateChangedObservable.add((stateObject) => {\n                    controller._dpadPressed = stateObject.pressed;\n                    if (!controller._dpadPressed) {\n                        controller._rotationLeftAsked = false;\n                        controller._rotationRightAsked = false;\n                        controller._teleportationBackRequestInitiated = false;\n                    }\n                });\n            }\n            controller.webVRController.onPadValuesChangedObservable.add((stateObject) => {\n                if (this.teleportationEnabled) {\n                    this._checkTeleportBackwards(stateObject, controller);\n                    this._checkTeleportWithRay(stateObject, controller);\n                }\n                this._checkRotate(stateObject, controller);\n            });\n        }\n    }\n    _createTeleportationCircles() {\n        this._teleportationTarget = CreateGround(\"teleportationTarget\", { width: 2, height: 2, subdivisions: 2 }, this._scene);\n        this._teleportationTarget.isPickable = false;\n        const length = 512;\n        const dynamicTexture = new DynamicTexture(\"DynamicTexture\", length, this._scene, true);\n        dynamicTexture.hasAlpha = true;\n        const context = dynamicTexture.getContext();\n        const centerX = length / 2;\n        const centerY = length / 2;\n        const radius = 200;\n        context.beginPath();\n        context.arc(centerX, centerY, radius, 0, 2 * Math.PI, false);\n        context.fillStyle = this._teleportationFillColor;\n        context.fill();\n        context.lineWidth = 10;\n        context.strokeStyle = this._teleportationBorderColor;\n        context.stroke();\n        context.closePath();\n        dynamicTexture.update();\n        const teleportationCircleMaterial = new StandardMaterial(\"TextPlaneMaterial\", this._scene);\n        teleportationCircleMaterial.diffuseTexture = dynamicTexture;\n        this._teleportationTarget.material = teleportationCircleMaterial;\n        const torus = CreateTorus(\"torusTeleportation\", {\n            diameter: 0.75,\n            thickness: 0.1,\n            tessellation: 25,\n            updatable: false,\n        }, this._scene);\n        torus.isPickable = false;\n        torus.parent = this._teleportationTarget;\n        const animationInnerCircle = new Animation(\"animationInnerCircle\", \"position.y\", 30, Animation.ANIMATIONTYPE_FLOAT, Animation.ANIMATIONLOOPMODE_CYCLE);\n        const keys = [];\n        keys.push({\n            frame: 0,\n            value: 0,\n        });\n        keys.push({\n            frame: 30,\n            value: 0.4,\n        });\n        keys.push({\n            frame: 60,\n            value: 0,\n        });\n        animationInnerCircle.setKeys(keys);\n        const easingFunction = new SineEase();\n        easingFunction.setEasingMode(EasingFunction.EASINGMODE_EASEINOUT);\n        animationInnerCircle.setEasingFunction(easingFunction);\n        torus.animations = [];\n        torus.animations.push(animationInnerCircle);\n        this._scene.beginAnimation(torus, 0, 60, true);\n        this._hideTeleportationTarget();\n    }\n    _displayTeleportationTarget() {\n        this._teleportActive = true;\n        if (this._teleportationInitialized) {\n            this._teleportationTarget.isVisible = true;\n            if (this._isDefaultTeleportationTarget) {\n                this._teleportationTarget.getChildren()[0].isVisible = true;\n            }\n        }\n    }\n    _hideTeleportationTarget() {\n        this._teleportActive = false;\n        if (this._teleportationInitialized) {\n            this._teleportationTarget.isVisible = false;\n            if (this._isDefaultTeleportationTarget) {\n                this._teleportationTarget.getChildren()[0].isVisible = false;\n            }\n        }\n    }\n    _rotateCamera(right) {\n        if (!(this.currentVRCamera instanceof FreeCamera)) {\n            return;\n        }\n        if (right) {\n            this._rotationAngle++;\n        }\n        else {\n            this._rotationAngle--;\n        }\n        this.currentVRCamera.animations = [];\n        const target = Quaternion.FromRotationMatrix(Matrix.RotationY((Math.PI / 4) * this._rotationAngle));\n        const animationRotation = new Animation(\"animationRotation\", \"rotationQuaternion\", 90, Animation.ANIMATIONTYPE_QUATERNION, Animation.ANIMATIONLOOPMODE_CONSTANT);\n        const animationRotationKeys = [];\n        animationRotationKeys.push({\n            frame: 0,\n            value: this.currentVRCamera.rotationQuaternion,\n        });\n        animationRotationKeys.push({\n            frame: 6,\n            value: target,\n        });\n        animationRotation.setKeys(animationRotationKeys);\n        animationRotation.setEasingFunction(this._circleEase);\n        this.currentVRCamera.animations.push(animationRotation);\n        this._postProcessMove.animations = [];\n        const animationPP = new Animation(\"animationPP\", \"vignetteWeight\", 90, Animation.ANIMATIONTYPE_FLOAT, Animation.ANIMATIONLOOPMODE_CONSTANT);\n        const vignetteWeightKeys = [];\n        vignetteWeightKeys.push({\n            frame: 0,\n            value: 0,\n        });\n        vignetteWeightKeys.push({\n            frame: 3,\n            value: 4,\n        });\n        vignetteWeightKeys.push({\n            frame: 6,\n            value: 0,\n        });\n        animationPP.setKeys(vignetteWeightKeys);\n        animationPP.setEasingFunction(this._circleEase);\n        this._postProcessMove.animations.push(animationPP);\n        const animationPP2 = new Animation(\"animationPP2\", \"vignetteStretch\", 90, Animation.ANIMATIONTYPE_FLOAT, Animation.ANIMATIONLOOPMODE_CONSTANT);\n        const vignetteStretchKeys = [];\n        vignetteStretchKeys.push({\n            frame: 0,\n            value: 0,\n        });\n        vignetteStretchKeys.push({\n            frame: 3,\n            value: 10,\n        });\n        vignetteStretchKeys.push({\n            frame: 6,\n            value: 0,\n        });\n        animationPP2.setKeys(vignetteStretchKeys);\n        animationPP2.setEasingFunction(this._circleEase);\n        this._postProcessMove.animations.push(animationPP2);\n        this._postProcessMove.imageProcessingConfiguration.vignetteWeight = 0;\n        this._postProcessMove.imageProcessingConfiguration.vignetteStretch = 0;\n        this._postProcessMove.samples = 4;\n        this._webVRCamera.attachPostProcess(this._postProcessMove);\n        this._scene.beginAnimation(this._postProcessMove, 0, 6, false, 1, () => {\n            this._webVRCamera.detachPostProcess(this._postProcessMove);\n        });\n        this._scene.beginAnimation(this.currentVRCamera, 0, 6, false, 1);\n    }\n    _moveTeleportationSelectorTo(hit, gazer, ray) {\n        if (hit.pickedPoint) {\n            if (gazer._teleportationRequestInitiated) {\n                this._displayTeleportationTarget();\n                this._haloCenter.copyFrom(hit.pickedPoint);\n                this._teleportationTarget.position.copyFrom(hit.pickedPoint);\n            }\n            const pickNormal = this._convertNormalToDirectionOfRay(hit.getNormal(true, false), ray);\n            if (pickNormal) {\n                const axis1 = Vector3.Cross(Axis.Y, pickNormal);\n                const axis2 = Vector3.Cross(pickNormal, axis1);\n                Vector3.RotationFromAxisToRef(axis2, pickNormal, axis1, this._teleportationTarget.rotation);\n            }\n            this._teleportationTarget.position.y += 0.1;\n        }\n    }\n    /**\n     * Teleports the users feet to the desired location\n     * @param location The location where the user's feet should be placed\n     */\n    teleportCamera(location) {\n        if (!(this.currentVRCamera instanceof FreeCamera)) {\n            return;\n        }\n        // Teleport the hmd to where the user is looking by moving the anchor to where they are looking minus the\n        // offset of the headset from the anchor.\n        if (this.webVRCamera.leftCamera) {\n            this._workingVector.copyFrom(this.webVRCamera.leftCamera.globalPosition);\n            this._workingVector.subtractInPlace(this.webVRCamera.position);\n            location.subtractToRef(this._workingVector, this._workingVector);\n        }\n        else {\n            this._workingVector.copyFrom(location);\n        }\n        // Add height to account for user's height offset\n        if (this.isInVRMode) {\n            this._workingVector.y += this.webVRCamera.deviceDistanceToRoomGround() * this._webVRCamera.deviceScaleFactor;\n        }\n        else {\n            this._workingVector.y += this._defaultHeight;\n        }\n        this.onBeforeCameraTeleport.notifyObservers(this._workingVector);\n        // Animations FPS\n        const FPS = 90;\n        let speedRatio, lastFrame;\n        if (this._teleportationMode == VRExperienceHelper.TELEPORTATIONMODE_CONSTANTSPEED) {\n            lastFrame = FPS;\n            const dist = Vector3.Distance(this.currentVRCamera.position, this._workingVector);\n            speedRatio = this._teleportationSpeed / dist;\n        }\n        else {\n            // teleportationMode is TELEPORTATIONMODE_CONSTANTTIME\n            lastFrame = Math.round((this._teleportationTime * FPS) / 1000);\n            speedRatio = 1;\n        }\n        // Create animation from the camera's position to the new location\n        this.currentVRCamera.animations = [];\n        const animationCameraTeleportation = new Animation(\"animationCameraTeleportation\", \"position\", FPS, Animation.ANIMATIONTYPE_VECTOR3, Animation.ANIMATIONLOOPMODE_CONSTANT);\n        const animationCameraTeleportationKeys = [\n            {\n                frame: 0,\n                value: this.currentVRCamera.position,\n            },\n            {\n                frame: lastFrame,\n                value: this._workingVector,\n            },\n        ];\n        animationCameraTeleportation.setKeys(animationCameraTeleportationKeys);\n        animationCameraTeleportation.setEasingFunction(this._teleportationEasing);\n        this.currentVRCamera.animations.push(animationCameraTeleportation);\n        this._postProcessMove.animations = [];\n        // Calculate the mid frame for vignette animations\n        const midFrame = Math.round(lastFrame / 2);\n        const animationPP = new Animation(\"animationPP\", \"vignetteWeight\", FPS, Animation.ANIMATIONTYPE_FLOAT, Animation.ANIMATIONLOOPMODE_CONSTANT);\n        const vignetteWeightKeys = [];\n        vignetteWeightKeys.push({\n            frame: 0,\n            value: 0,\n        });\n        vignetteWeightKeys.push({\n            frame: midFrame,\n            value: 8,\n        });\n        vignetteWeightKeys.push({\n            frame: lastFrame,\n            value: 0,\n        });\n        animationPP.setKeys(vignetteWeightKeys);\n        this._postProcessMove.animations.push(animationPP);\n        const animationPP2 = new Animation(\"animationPP2\", \"vignetteStretch\", FPS, Animation.ANIMATIONTYPE_FLOAT, Animation.ANIMATIONLOOPMODE_CONSTANT);\n        const vignetteStretchKeys = [];\n        vignetteStretchKeys.push({\n            frame: 0,\n            value: 0,\n        });\n        vignetteStretchKeys.push({\n            frame: midFrame,\n            value: 10,\n        });\n        vignetteStretchKeys.push({\n            frame: lastFrame,\n            value: 0,\n        });\n        animationPP2.setKeys(vignetteStretchKeys);\n        this._postProcessMove.animations.push(animationPP2);\n        this._postProcessMove.imageProcessingConfiguration.vignetteWeight = 0;\n        this._postProcessMove.imageProcessingConfiguration.vignetteStretch = 0;\n        this._webVRCamera.attachPostProcess(this._postProcessMove);\n        this._scene.beginAnimation(this._postProcessMove, 0, lastFrame, false, speedRatio, () => {\n            this._webVRCamera.detachPostProcess(this._postProcessMove);\n        });\n        this._scene.beginAnimation(this.currentVRCamera, 0, lastFrame, false, speedRatio, () => {\n            this.onAfterCameraTeleport.notifyObservers(this._workingVector);\n        });\n        this._hideTeleportationTarget();\n    }\n    _convertNormalToDirectionOfRay(normal, ray) {\n        if (normal) {\n            const angle = Math.acos(Vector3.Dot(normal, ray.direction));\n            if (angle < Math.PI / 2) {\n                normal.scaleInPlace(-1);\n            }\n        }\n        return normal;\n    }\n    _castRayAndSelectObject(gazer) {\n        if (!(this.currentVRCamera instanceof FreeCamera)) {\n            return;\n        }\n        const ray = gazer._getForwardRay(this._rayLength);\n        const hit = this._scene.pickWithRay(ray, this._raySelectionPredicate);\n        if (hit) {\n            this._scene.simulatePointerMove(hit, { pointerId: gazer._id });\n        }\n        gazer._currentHit = hit;\n        // Moving the gazeTracker on the mesh face targetted\n        if (hit && hit.pickedPoint) {\n            if (this._displayGaze) {\n                let multiplier = 1;\n                gazer._gazeTracker.isVisible = true;\n                if (gazer._isActionableMesh) {\n                    multiplier = 3;\n                }\n                if (this.updateGazeTrackerScale) {\n                    gazer._gazeTracker.scaling.x = hit.distance * multiplier;\n                    gazer._gazeTracker.scaling.y = hit.distance * multiplier;\n                    gazer._gazeTracker.scaling.z = hit.distance * multiplier;\n                }\n                const pickNormal = this._convertNormalToDirectionOfRay(hit.getNormal(), ray);\n                // To avoid z-fighting\n                const deltaFighting = 0.002;\n                if (pickNormal) {\n                    const axis1 = Vector3.Cross(Axis.Y, pickNormal);\n                    const axis2 = Vector3.Cross(pickNormal, axis1);\n                    Vector3.RotationFromAxisToRef(axis2, pickNormal, axis1, gazer._gazeTracker.rotation);\n                }\n                gazer._gazeTracker.position.copyFrom(hit.pickedPoint);\n                if (gazer._gazeTracker.position.x < 0) {\n                    gazer._gazeTracker.position.x += deltaFighting;\n                }\n                else {\n                    gazer._gazeTracker.position.x -= deltaFighting;\n                }\n                if (gazer._gazeTracker.position.y < 0) {\n                    gazer._gazeTracker.position.y += deltaFighting;\n                }\n                else {\n                    gazer._gazeTracker.position.y -= deltaFighting;\n                }\n                if (gazer._gazeTracker.position.z < 0) {\n                    gazer._gazeTracker.position.z += deltaFighting;\n                }\n                else {\n                    gazer._gazeTracker.position.z -= deltaFighting;\n                }\n            }\n            // Changing the size of the laser pointer based on the distance from the targetted point\n            gazer._updatePointerDistance(hit.distance);\n        }\n        else {\n            gazer._updatePointerDistance();\n            gazer._gazeTracker.isVisible = false;\n        }\n        if (hit && hit.pickedMesh) {\n            // The object selected is the floor, we're in a teleportation scenario\n            if (this._teleportationInitialized && this._isTeleportationFloor(hit.pickedMesh) && hit.pickedPoint) {\n                // Moving the teleportation area to this targetted point\n                //Raise onSelectedMeshUnselected observable if ray collided floor mesh/meshes and a non floor mesh was previously selected\n                if (gazer._currentMeshSelected && !this._isTeleportationFloor(gazer._currentMeshSelected)) {\n                    this._notifySelectedMeshUnselected(gazer._currentMeshSelected);\n                }\n                gazer._currentMeshSelected = null;\n                if (gazer._teleportationRequestInitiated) {\n                    this._moveTeleportationSelectorTo(hit, gazer, ray);\n                }\n                return;\n            }\n            // If not, we're in a selection scenario\n            //this._teleportationAllowed = false;\n            if (hit.pickedMesh !== gazer._currentMeshSelected) {\n                if (this.meshSelectionPredicate(hit.pickedMesh)) {\n                    this.onNewMeshPicked.notifyObservers(hit);\n                    gazer._currentMeshSelected = hit.pickedMesh;\n                    if (hit.pickedMesh.isPickable && hit.pickedMesh.actionManager) {\n                        this.changeGazeColor(this._pickedGazeColor);\n                        this.changeLaserColor(this._pickedLaserColor);\n                        gazer._isActionableMesh = true;\n                    }\n                    else {\n                        this.changeGazeColor(this._gazeColor);\n                        this.changeLaserColor(this._laserColor);\n                        gazer._isActionableMesh = false;\n                    }\n                    try {\n                        this.onNewMeshSelected.notifyObservers(hit.pickedMesh);\n                        const gazerAsControllerGazer = gazer;\n                        if (gazerAsControllerGazer.webVRController) {\n                            this.onMeshSelectedWithController.notifyObservers({ mesh: hit.pickedMesh, controller: gazerAsControllerGazer.webVRController });\n                        }\n                    }\n                    catch (err) {\n                        Logger.Warn(\"Error while raising onNewMeshSelected or onMeshSelectedWithController: \" + err);\n                    }\n                }\n                else {\n                    this._notifySelectedMeshUnselected(gazer._currentMeshSelected);\n                    gazer._currentMeshSelected = null;\n                    this.changeGazeColor(this._gazeColor);\n                    this.changeLaserColor(this._laserColor);\n                }\n            }\n        }\n        else {\n            this._notifySelectedMeshUnselected(gazer._currentMeshSelected);\n            gazer._currentMeshSelected = null;\n            //this._teleportationAllowed = false;\n            this.changeGazeColor(this._gazeColor);\n            this.changeLaserColor(this._laserColor);\n        }\n    }\n    _notifySelectedMeshUnselected(mesh) {\n        if (mesh) {\n            this.onSelectedMeshUnselected.notifyObservers(mesh);\n        }\n    }\n    /**\n     * Permanently set new colors for the laser pointer\n     * @param color the new laser color\n     * @param pickedColor the new laser color when picked mesh detected\n     */\n    setLaserColor(color, pickedColor = this._pickedLaserColor) {\n        this._laserColor = color;\n        this._pickedLaserColor = pickedColor;\n    }\n    /**\n     * Set lighting enabled / disabled on the laser pointer of both controllers\n     * @param enabled should the lighting be enabled on the laser pointer\n     */\n    setLaserLightingState(enabled = true) {\n        if (this._leftController) {\n            this._leftController._setLaserPointerLightingDisabled(!enabled);\n        }\n        if (this._rightController) {\n            this._rightController._setLaserPointerLightingDisabled(!enabled);\n        }\n    }\n    /**\n     * Permanently set new colors for the gaze pointer\n     * @param color the new gaze color\n     * @param pickedColor the new gaze color when picked mesh detected\n     */\n    setGazeColor(color, pickedColor = this._pickedGazeColor) {\n        this._gazeColor = color;\n        this._pickedGazeColor = pickedColor;\n    }\n    /**\n     * Sets the color of the laser ray from the vr controllers.\n     * @param color new color for the ray.\n     */\n    changeLaserColor(color) {\n        if (!this.updateControllerLaserColor) {\n            return;\n        }\n        if (this._leftController) {\n            this._leftController._setLaserPointerColor(color);\n        }\n        if (this._rightController) {\n            this._rightController._setLaserPointerColor(color);\n        }\n    }\n    /**\n     * Sets the color of the ray from the vr headsets gaze.\n     * @param color new color for the ray.\n     */\n    changeGazeColor(color) {\n        if (!this.updateGazeTrackerColor) {\n            return;\n        }\n        if (!this._cameraGazer._gazeTracker.material) {\n            return;\n        }\n        this._cameraGazer._gazeTracker.material.emissiveColor = color;\n        if (this._leftController) {\n            this._leftController._gazeTracker.material.emissiveColor = color;\n        }\n        if (this._rightController) {\n            this._rightController._gazeTracker.material.emissiveColor = color;\n        }\n    }\n    /**\n     * Exits VR and disposes of the vr experience helper\n     */\n    dispose() {\n        if (this.isInVRMode) {\n            this.exitVR();\n        }\n        if (this._postProcessMove) {\n            this._postProcessMove.dispose();\n        }\n        if (this._webVRCamera) {\n            this._webVRCamera.dispose();\n        }\n        if (this._vrDeviceOrientationCamera) {\n            this._vrDeviceOrientationCamera.dispose();\n        }\n        if (!this._useCustomVRButton && this._btnVR && this._btnVR.parentNode) {\n            document.body.removeChild(this._btnVR);\n        }\n        if (this._deviceOrientationCamera && this._scene.activeCamera != this._deviceOrientationCamera) {\n            this._deviceOrientationCamera.dispose();\n        }\n        if (this._cameraGazer) {\n            this._cameraGazer.dispose();\n        }\n        if (this._leftController) {\n            this._leftController.dispose();\n        }\n        if (this._rightController) {\n            this._rightController.dispose();\n        }\n        if (this._teleportationTarget) {\n            this._teleportationTarget.dispose();\n        }\n        if (this.xr) {\n            this.xr.dispose();\n        }\n        this._floorMeshesCollection.length = 0;\n        document.removeEventListener(\"keydown\", this._onKeyDown);\n        window.removeEventListener(\"vrdisplaypresentchange\", this._onVrDisplayPresentChangeBind);\n        window.removeEventListener(\"resize\", this._onResize);\n        document.removeEventListener(\"fullscreenchange\", this._onFullscreenChange);\n        this._scene.getEngine().onVRDisplayChangedObservable.removeCallback(this._onVRDisplayChangedBind);\n        this._scene.getEngine().onVRRequestPresentStart.removeCallback(this._onVRRequestPresentStart);\n        this._scene.getEngine().onVRRequestPresentComplete.removeCallback(this._onVRRequestPresentComplete);\n        this._scene.gamepadManager.onGamepadConnectedObservable.removeCallback(this._onNewGamepadConnected);\n        this._scene.gamepadManager.onGamepadDisconnectedObservable.removeCallback(this._onNewGamepadDisconnected);\n        this._scene.unregisterBeforeRender(this._beforeRender);\n    }\n    /**\n     * Gets the name of the VRExperienceHelper class\n     * @returns \"VRExperienceHelper\"\n     */\n    getClassName() {\n        return \"VRExperienceHelper\";\n    }\n}\n/**\n * Time Constant Teleportation Mode\n */\nVRExperienceHelper.TELEPORTATIONMODE_CONSTANTTIME = 0;\n/**\n * Speed Constant Teleportation Mode\n */\nVRExperienceHelper.TELEPORTATIONMODE_CONSTANTSPEED = 1;\n//# sourceMappingURL=vrExperienceHelper.js.map","import { Observable } from \"../../Misc/observable.js\";\nimport { FreeCamera } from \"../../Cameras/freeCamera.js\";\nimport { Camera } from \"../../Cameras/camera.js\";\nimport { Quaternion, Matrix, Vector3 } from \"../../Maths/math.vector.js\";\nimport { Gamepad } from \"../../Gamepads/gamepad.js\";\nimport { PoseEnabledControllerType } from \"../../Gamepads/Controllers/poseEnabledController.js\";\nimport { Node } from \"../../node.js\";\nimport { HemisphericLight } from \"../../Lights/hemisphericLight.js\";\nimport { Logger } from \"../../Misc/logger.js\";\nimport { VRMultiviewToSingleviewPostProcess } from \"../../PostProcesses/vrMultiviewToSingleviewPostProcess.js\";\nimport { Tools } from \"../../Misc/tools.js\";\nimport { setWebVRRigMode } from \"../RigModes/webVRRigMode.js\";\n// Side effect import to add webvr support to engine\nimport \"../../Engines/Extensions/engine.webVR.js\";\nNode.AddNodeConstructor(\"WebVRFreeCamera\", (name, scene) => {\n    return () => new WebVRFreeCamera(name, Vector3.Zero(), scene);\n});\nNode.AddNodeConstructor(\"WebVRGamepadCamera\", (name, scene) => {\n    return () => new WebVRFreeCamera(name, Vector3.Zero(), scene);\n});\n/**\n * This represents a WebVR camera.\n * The WebVR camera is Babylon's simple interface to interaction with Windows Mixed Reality, HTC Vive and Oculus Rift.\n * @deprecated Use WebXR instead - https://doc.babylonjs.com/features/featuresDeepDive/webXR\n * @example https://doc.babylonjs.com/features/featuresDeepDive/cameras/webVRCamera\n */\nexport class WebVRFreeCamera extends FreeCamera {\n    /**\n     * Instantiates a WebVRFreeCamera.\n     * @param name The name of the WebVRFreeCamera\n     * @param position The starting anchor position for the camera\n     * @param scene The scene the camera belongs to\n     * @param _webVROptions a set of customizable options for the webVRCamera\n     */\n    constructor(name, position, scene, _webVROptions = {}) {\n        super(name, position, scene);\n        this._webVROptions = _webVROptions;\n        /**\n         * @internal\n         * The vrDisplay tied to the camera. See https://developer.mozilla.org/en-US/docs/Web/API/VRDisplay\n         */\n        this._vrDevice = null;\n        /**\n         * The rawPose of the vrDevice.\n         */\n        this.rawPose = null;\n        this._specsVersion = \"1.1\";\n        this._attached = false;\n        this._descendants = [];\n        // Represents device position and rotation in room space. Should only be used to help calculate babylon space values\n        this._deviceRoomPosition = Vector3.Zero();\n        /** @internal */\n        this._deviceRoomRotationQuaternion = Quaternion.Identity();\n        this._standingMatrix = null;\n        /**\n         * Represents device position in babylon space.\n         */\n        this.devicePosition = Vector3.Zero();\n        /**\n         * Represents device rotation in babylon space.\n         */\n        this.deviceRotationQuaternion = Quaternion.Identity();\n        /**\n         * The scale of the device to be used when translating from device space to babylon space.\n         */\n        this.deviceScaleFactor = 1;\n        this._deviceToWorld = Matrix.Identity();\n        this._worldToDevice = Matrix.Identity();\n        /**\n         * References to the webVR controllers for the vrDevice.\n         */\n        this.controllers = [];\n        /**\n         * Emits an event when a controller is attached.\n         */\n        this.onControllersAttachedObservable = new Observable();\n        /**\n         * Emits an event when a controller's mesh has been loaded;\n         */\n        this.onControllerMeshLoadedObservable = new Observable();\n        /**\n         * Emits an event when the HMD's pose has been updated.\n         */\n        this.onPoseUpdatedFromDeviceObservable = new Observable();\n        this._poseSet = false;\n        /**\n         * If the rig cameras be used as parent instead of this camera.\n         */\n        this.rigParenting = true;\n        this._defaultHeight = undefined;\n        this._setRigMode = setWebVRRigMode.bind(null, this);\n        this._detachIfAttached = () => {\n            const vrDisplay = this.getEngine().getVRDevice();\n            if (vrDisplay && !vrDisplay.isPresenting) {\n                this.detachControl();\n            }\n        };\n        this._workingVector = Vector3.Zero();\n        this._oneVector = Vector3.One();\n        this._workingMatrix = Matrix.Identity();\n        this._tmpMatrix = new Matrix();\n        this._cache.position = Vector3.Zero();\n        if (_webVROptions.defaultHeight) {\n            this._defaultHeight = _webVROptions.defaultHeight;\n            this.position.y = this._defaultHeight;\n        }\n        this.minZ = 0.1;\n        //legacy support - the compensation boolean was removed.\n        if (arguments.length === 5) {\n            // eslint-disable-next-line prefer-rest-params\n            this._webVROptions = arguments[4];\n        }\n        // default webVR options\n        if (this._webVROptions.trackPosition == undefined) {\n            this._webVROptions.trackPosition = true;\n        }\n        if (this._webVROptions.controllerMeshes == undefined) {\n            this._webVROptions.controllerMeshes = true;\n        }\n        if (this._webVROptions.defaultLightingOnControllers == undefined) {\n            this._webVROptions.defaultLightingOnControllers = true;\n        }\n        this.rotationQuaternion = new Quaternion();\n        if (this._webVROptions && this._webVROptions.positionScale) {\n            this.deviceScaleFactor = this._webVROptions.positionScale;\n        }\n        //enable VR\n        const engine = this.getEngine();\n        this._onVREnabled = (success) => {\n            if (success) {\n                this.initControllers();\n            }\n        };\n        engine.onVRRequestPresentComplete.add(this._onVREnabled);\n        engine.initWebVR().add((event) => {\n            if (!event.vrDisplay || this._vrDevice === event.vrDisplay) {\n                return;\n            }\n            this._vrDevice = event.vrDisplay;\n            //reset the rig parameters.\n            this.setCameraRigMode(Camera.RIG_MODE_WEBVR, { parentCamera: this, vrDisplay: this._vrDevice, frameData: this._frameData, specs: this._specsVersion });\n            if (this._attached) {\n                this.getEngine().enableVR(this._webVROptions);\n            }\n        });\n        if (typeof VRFrameData !== \"undefined\") {\n            this._frameData = new VRFrameData();\n        }\n        if (_webVROptions.useMultiview) {\n            if (!this.getScene().getEngine().getCaps().multiview) {\n                Logger.Warn(\"Multiview is not supported, falling back to standard rendering\");\n                this._useMultiviewToSingleView = false;\n            }\n            else {\n                this._useMultiviewToSingleView = true;\n                this._rigPostProcess = new VRMultiviewToSingleviewPostProcess(\"VRMultiviewToSingleview\", this, 1.0);\n            }\n        }\n        /**\n         * The idea behind the following lines:\n         * objects that have the camera as parent should actually have the rig cameras as a parent.\n         * BUT, each of those cameras has a different view matrix, which means that if we set the parent to the first rig camera,\n         * the second will not show it correctly.\n         *\n         * To solve this - each object that has the camera as parent will be added to a protected array.\n         * When the rig camera renders, it will take this array and set all of those to be its children.\n         * This way, the right camera will be used as a parent, and the mesh will be rendered correctly.\n         * Amazing!\n         */\n        this.getScene().onBeforeCameraRenderObservable.add((camera) => {\n            if (camera.parent === this && this.rigParenting) {\n                this._descendants = this.getDescendants(true, (n) => {\n                    // don't take the cameras or the controllers!\n                    const isController = this.controllers.some((controller) => {\n                        return controller._mesh === n;\n                    });\n                    const isRigCamera = this._rigCameras.indexOf(n) !== -1;\n                    return !isController && !isRigCamera;\n                });\n                this._descendants.forEach((node) => {\n                    node.parent = camera;\n                });\n            }\n        });\n        this.getScene().onAfterCameraRenderObservable.add((camera) => {\n            if (camera.parent === this && this.rigParenting) {\n                this._descendants.forEach((node) => {\n                    node.parent = this;\n                });\n            }\n        });\n    }\n    /**\n     * Gets the device distance from the ground in meters.\n     * @returns the distance in meters from the vrDevice to ground in device space. If standing matrix is not supported for the vrDevice 0 is returned.\n     */\n    deviceDistanceToRoomGround() {\n        if (this._standingMatrix) {\n            // Add standing matrix offset to get real offset from ground in room\n            this._standingMatrix.getTranslationToRef(this._workingVector);\n            return this._deviceRoomPosition.y + this._workingVector.y;\n        }\n        //If VRDisplay does not inform stage parameters and no default height is set we fallback to zero.\n        return this._defaultHeight || 0;\n    }\n    /**\n     * Enables the standing matrix when supported. This can be used to position the user's view the correct height from the ground.\n     * @param callback will be called when the standing matrix is set. Callback parameter is if the standing matrix is supported.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    useStandingMatrix(callback = (bool) => { }) {\n        // Use standing matrix if available\n        this.getEngine()\n            .initWebVRAsync()\n            .then((result) => {\n            if (!result.vrDisplay || !result.vrDisplay.stageParameters || !result.vrDisplay.stageParameters.sittingToStandingTransform || !this._webVROptions.trackPosition) {\n                callback(false);\n            }\n            else {\n                this._standingMatrix = new Matrix();\n                Matrix.FromFloat32ArrayToRefScaled(result.vrDisplay.stageParameters.sittingToStandingTransform, 0, 1, this._standingMatrix);\n                if (!this.getScene().useRightHandedSystem) {\n                    if (this._standingMatrix) {\n                        this._standingMatrix.toggleModelMatrixHandInPlace();\n                    }\n                }\n                callback(true);\n            }\n        });\n    }\n    /**\n     * Enables the standing matrix when supported. This can be used to position the user's view the correct height from the ground.\n     * @returns A promise with a boolean set to if the standing matrix is supported.\n     */\n    useStandingMatrixAsync() {\n        return new Promise((res) => {\n            this.useStandingMatrix((supported) => {\n                res(supported);\n            });\n        });\n    }\n    /**\n     * Disposes the camera\n     */\n    dispose() {\n        this._detachIfAttached();\n        this.getEngine().onVRRequestPresentComplete.removeCallback(this._onVREnabled);\n        if (this._updateCacheWhenTrackingDisabledObserver) {\n            this._scene.onBeforeRenderObservable.remove(this._updateCacheWhenTrackingDisabledObserver);\n        }\n        super.dispose();\n    }\n    /**\n     * Gets a vrController by name.\n     * @param name The name of the controller to retrieve\n     * @returns the controller matching the name specified or null if not found\n     */\n    getControllerByName(name) {\n        for (const gp of this.controllers) {\n            if (gp.hand === name) {\n                return gp;\n            }\n        }\n        return null;\n    }\n    /**\n     * The controller corresponding to the users left hand.\n     */\n    get leftController() {\n        if (!this._leftController) {\n            this._leftController = this.getControllerByName(\"left\");\n        }\n        return this._leftController;\n    }\n    /**\n     * The controller corresponding to the users right hand.\n     */\n    get rightController() {\n        if (!this._rightController) {\n            this._rightController = this.getControllerByName(\"right\");\n        }\n        return this._rightController;\n    }\n    /**\n     * Casts a ray forward from the vrCamera's gaze.\n     * @param length Length of the ray (default: 100)\n     * @returns the ray corresponding to the gaze\n     */\n    getForwardRay(length = 100) {\n        if (this.leftCamera) {\n            // Use left eye to avoid computation to compute center on every call\n            return super.getForwardRay(length, this.leftCamera.getWorldMatrix(), this.leftCamera.globalPosition); // Need the actual rendered camera\n        }\n        else {\n            return super.getForwardRay(length);\n        }\n    }\n    /**\n     * @internal\n     * Updates the camera based on device's frame data\n     */\n    _checkInputs() {\n        if (this._vrDevice && this._vrDevice.isPresenting) {\n            this._vrDevice.getFrameData(this._frameData);\n            this.updateFromDevice(this._frameData.pose);\n        }\n        super._checkInputs();\n    }\n    /**\n     * Updates the poseControlled values based on the input device pose.\n     * @param poseData Pose coming from the device\n     */\n    updateFromDevice(poseData) {\n        if (poseData && poseData.orientation && poseData.orientation.length === 4) {\n            this.rawPose = poseData;\n            this._deviceRoomRotationQuaternion.copyFromFloats(poseData.orientation[0], poseData.orientation[1], -poseData.orientation[2], -poseData.orientation[3]);\n            if (this.getScene().useRightHandedSystem) {\n                this._deviceRoomRotationQuaternion.z *= -1;\n                this._deviceRoomRotationQuaternion.w *= -1;\n            }\n            if (this._webVROptions.trackPosition && this.rawPose.position) {\n                this._deviceRoomPosition.copyFromFloats(this.rawPose.position[0], this.rawPose.position[1], -this.rawPose.position[2]);\n                if (this.getScene().useRightHandedSystem) {\n                    this._deviceRoomPosition.z *= -1;\n                }\n            }\n            this._poseSet = true;\n        }\n    }\n    /**\n     * WebVR's attach control will start broadcasting frames to the device.\n     * Note that in certain browsers (chrome for example) this function must be called\n     * within a user-interaction callback. Example:\n     * <pre> scene.onPointerDown = function() { camera.attachControl(canvas); }</pre>\n     *\n     * @param noPreventDefault prevent the default html element operation when attaching the vrDevice\n     */\n    attachControl(noPreventDefault) {\n        // eslint-disable-next-line prefer-rest-params\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\n        super.attachControl(noPreventDefault);\n        this._attached = true;\n        noPreventDefault = Camera.ForceAttachControlToAlwaysPreventDefault ? false : noPreventDefault;\n        if (this._vrDevice) {\n            this.getEngine().enableVR(this._webVROptions);\n        }\n        const hostWindow = this._scene.getEngine().getHostWindow();\n        if (hostWindow) {\n            hostWindow.addEventListener(\"vrdisplaypresentchange\", this._detachIfAttached);\n        }\n    }\n    /**\n     * Detach the current controls from the specified dom element.\n     */\n    detachControl() {\n        this.getScene().gamepadManager.onGamepadConnectedObservable.remove(this._onGamepadConnectedObserver);\n        this.getScene().gamepadManager.onGamepadDisconnectedObservable.remove(this._onGamepadDisconnectedObserver);\n        super.detachControl();\n        this._attached = false;\n        this.getEngine().disableVR();\n        window.removeEventListener(\"vrdisplaypresentchange\", this._detachIfAttached);\n    }\n    /**\n     * @returns the name of this class\n     */\n    getClassName() {\n        return \"WebVRFreeCamera\";\n    }\n    /**\n     * Calls resetPose on the vrDisplay\n     * See: https://developer.mozilla.org/en-US/docs/Web/API/VRDisplay/resetPose\n     */\n    resetToCurrentRotation() {\n        //uses the vrDisplay's \"resetPose()\".\n        //pitch and roll won't be affected.\n        this._vrDevice.resetPose();\n    }\n    /**\n     * @internal\n     * Updates the rig cameras (left and right eye)\n     */\n    _updateRigCameras() {\n        const camLeft = this._rigCameras[0];\n        const camRight = this._rigCameras[1];\n        camLeft.rotationQuaternion.copyFrom(this._deviceRoomRotationQuaternion);\n        camRight.rotationQuaternion.copyFrom(this._deviceRoomRotationQuaternion);\n        camLeft.position.copyFrom(this._deviceRoomPosition);\n        camRight.position.copyFrom(this._deviceRoomPosition);\n    }\n    // Remove translation from 6dof headset if trackposition is set to false\n    _correctPositionIfNotTrackPosition(matrix, isViewMatrix = false) {\n        if (this.rawPose && this.rawPose.position && !this._webVROptions.trackPosition) {\n            Matrix.TranslationToRef(this.rawPose.position[0], this.rawPose.position[1], -this.rawPose.position[2], this._tmpMatrix);\n            if (!isViewMatrix) {\n                this._tmpMatrix.invert();\n            }\n            this._tmpMatrix.multiplyToRef(matrix, matrix);\n        }\n    }\n    /**\n     * @internal\n     * Updates the cached values of the camera\n     * @param ignoreParentClass ignores updating the parent class's cache (default: false)\n     */\n    _updateCache(ignoreParentClass) {\n        if (!this.rotationQuaternion.equals(this._cache.rotationQuaternion) || !this.position.equals(this._cache.position)) {\n            // Update to ensure devicePosition is up to date with most recent _deviceRoomPosition\n            if (!this._updateCacheCalled) {\n                // make sure it is only called once per loop. this.update() might cause an infinite loop.\n                this._updateCacheCalled = true;\n                this.update();\n            }\n            // Set working vector to the device position in room space rotated by the new rotation\n            this.rotationQuaternion.toRotationMatrix(this._workingMatrix);\n            Vector3.TransformCoordinatesToRef(this._deviceRoomPosition, this._workingMatrix, this._workingVector);\n            // Subtract this vector from the current device position in world to get the translation for the device world matrix\n            this.devicePosition.subtractToRef(this._workingVector, this._workingVector);\n            Matrix.ComposeToRef(this._oneVector, this.rotationQuaternion, this._workingVector, this._deviceToWorld);\n            // Add translation from anchor position\n            this._deviceToWorld.getTranslationToRef(this._workingVector);\n            this._workingVector.addInPlace(this.position);\n            this._workingVector.subtractInPlace(this._cache.position);\n            this._deviceToWorld.setTranslation(this._workingVector);\n            // Set an inverted matrix to be used when updating the camera\n            this._deviceToWorld.invertToRef(this._worldToDevice);\n            // Update the gamepad to ensure the mesh is updated on the same frame as camera\n            this.controllers.forEach((controller) => {\n                controller._deviceToWorld.copyFrom(this._deviceToWorld);\n                this._correctPositionIfNotTrackPosition(controller._deviceToWorld);\n                controller.update();\n            });\n        }\n        if (!ignoreParentClass) {\n            super._updateCache();\n        }\n        this._updateCacheCalled = false;\n    }\n    /**\n     * @internal\n     * Get current device position in babylon world\n     */\n    _computeDevicePosition() {\n        Vector3.TransformCoordinatesToRef(this._deviceRoomPosition, this._deviceToWorld, this.devicePosition);\n    }\n    /**\n     * Updates the current device position and rotation in the babylon world\n     */\n    update() {\n        this._computeDevicePosition();\n        // Get current device rotation in babylon world\n        Matrix.FromQuaternionToRef(this._deviceRoomRotationQuaternion, this._workingMatrix);\n        this._workingMatrix.multiplyToRef(this._deviceToWorld, this._workingMatrix);\n        Quaternion.FromRotationMatrixToRef(this._workingMatrix, this.deviceRotationQuaternion);\n        if (this._poseSet) {\n            this.onPoseUpdatedFromDeviceObservable.notifyObservers(null);\n        }\n        super.update();\n    }\n    /**\n     * @internal\n     * Gets the view matrix of this camera (Always set to identity as left and right eye cameras contain the actual view matrix)\n     * @returns an identity matrix\n     */\n    _getViewMatrix() {\n        return Matrix.Identity();\n    }\n    /**\n     * This function is called by the two RIG cameras.\n     * 'this' is the left or right camera (and NOT (!!!) the WebVRFreeCamera instance)\n     * @internal\n     */\n    _getWebVRViewMatrix() {\n        // Update the parent camera prior to using a child camera to avoid desynchronization\n        const parentCamera = this._cameraRigParams[\"parentCamera\"];\n        parentCamera._updateCache();\n        //WebVR 1.1\n        const viewArray = this._cameraRigParams[\"left\"] ? this._cameraRigParams[\"frameData\"].leftViewMatrix : this._cameraRigParams[\"frameData\"].rightViewMatrix;\n        Matrix.FromArrayToRef(viewArray, 0, this._webvrViewMatrix);\n        if (!this.getScene().useRightHandedSystem) {\n            this._webvrViewMatrix.toggleModelMatrixHandInPlace();\n        }\n        // update the camera rotation matrix\n        this._webvrViewMatrix.getRotationMatrixToRef(this._cameraRotationMatrix);\n        Vector3.TransformCoordinatesToRef(this._referencePoint, this._cameraRotationMatrix, this._transformedReferencePoint);\n        // Computing target and final matrix\n        this.position.addToRef(this._transformedReferencePoint, this._currentTarget);\n        // should the view matrix be updated with scale and position offset?\n        if (parentCamera.deviceScaleFactor !== 1) {\n            this._webvrViewMatrix.invert();\n            // scale the position, if set\n            if (parentCamera.deviceScaleFactor) {\n                this._webvrViewMatrix.multiplyAtIndex(12, parentCamera.deviceScaleFactor);\n                this._webvrViewMatrix.multiplyAtIndex(13, parentCamera.deviceScaleFactor);\n                this._webvrViewMatrix.multiplyAtIndex(14, parentCamera.deviceScaleFactor);\n            }\n            this._webvrViewMatrix.invert();\n        }\n        // Remove translation from 6dof headset if trackposition is set to false\n        parentCamera._correctPositionIfNotTrackPosition(this._webvrViewMatrix, true);\n        parentCamera._worldToDevice.multiplyToRef(this._webvrViewMatrix, this._webvrViewMatrix);\n        // Compute global position\n        this._workingMatrix = this._workingMatrix || Matrix.Identity();\n        this._webvrViewMatrix.invertToRef(this._workingMatrix);\n        this._workingMatrix.multiplyToRef(parentCamera.getWorldMatrix(), this._workingMatrix);\n        this._workingMatrix.getTranslationToRef(this._globalPosition);\n        this._markSyncedWithParent();\n        return this._webvrViewMatrix;\n    }\n    /** @internal */\n    _getWebVRProjectionMatrix() {\n        const parentCamera = this.parent;\n        parentCamera._vrDevice.depthNear = parentCamera.minZ;\n        parentCamera._vrDevice.depthFar = parentCamera.maxZ;\n        const projectionArray = this._cameraRigParams[\"left\"] ? this._cameraRigParams[\"frameData\"].leftProjectionMatrix : this._cameraRigParams[\"frameData\"].rightProjectionMatrix;\n        Matrix.FromArrayToRef(projectionArray, 0, this._projectionMatrix);\n        //babylon compatible matrix\n        if (!this.getScene().useRightHandedSystem) {\n            this._projectionMatrix.toggleProjectionMatrixHandInPlace();\n        }\n        return this._projectionMatrix;\n    }\n    /**\n     * Initializes the controllers and their meshes\n     */\n    initControllers() {\n        this.controllers.length = 0;\n        const manager = this.getScene().gamepadManager;\n        this._onGamepadDisconnectedObserver = manager.onGamepadDisconnectedObservable.add((gamepad) => {\n            if (gamepad.type === Gamepad.POSE_ENABLED) {\n                const webVrController = gamepad;\n                if (webVrController.defaultModel) {\n                    webVrController.defaultModel.setEnabled(false);\n                }\n                if (webVrController.hand === \"right\") {\n                    this._rightController = null;\n                }\n                if (webVrController.hand === \"left\") {\n                    this._leftController = null;\n                }\n                const controllerIndex = this.controllers.indexOf(webVrController);\n                if (controllerIndex !== -1) {\n                    this.controllers.splice(controllerIndex, 1);\n                }\n            }\n        });\n        this._onGamepadConnectedObserver = manager.onGamepadConnectedObservable.add((gamepad) => {\n            if (gamepad.type === Gamepad.POSE_ENABLED) {\n                const webVrController = gamepad;\n                if (!this._webVROptions.trackPosition) {\n                    webVrController._disableTrackPosition(new Vector3(webVrController.hand == \"left\" ? -0.15 : 0.15, -0.5, 0.25));\n                    // Cache must be updated before rendering controllers to avoid them being one frame behind\n                    if (!this._updateCacheWhenTrackingDisabledObserver) {\n                        this._updateCacheWhenTrackingDisabledObserver = this._scene.onBeforeRenderObservable.add(() => {\n                            this._updateCache();\n                        });\n                    }\n                }\n                webVrController.deviceScaleFactor = this.deviceScaleFactor;\n                webVrController._deviceToWorld.copyFrom(this._deviceToWorld);\n                this._correctPositionIfNotTrackPosition(webVrController._deviceToWorld);\n                if (this._webVROptions.controllerMeshes) {\n                    if (webVrController.defaultModel) {\n                        webVrController.defaultModel.setEnabled(true);\n                    }\n                    else {\n                        // Load the meshes\n                        webVrController.initControllerMesh(this.getScene(), (loadedMesh) => {\n                            loadedMesh.scaling.scaleInPlace(this.deviceScaleFactor);\n                            this.onControllerMeshLoadedObservable.notifyObservers(webVrController);\n                            if (this._webVROptions.defaultLightingOnControllers) {\n                                if (!this._lightOnControllers) {\n                                    this._lightOnControllers = new HemisphericLight(\"vrControllersLight\", new Vector3(0, 1, 0), this.getScene());\n                                }\n                                const activateLightOnSubMeshes = function (mesh, light) {\n                                    const children = mesh.getChildren();\n                                    if (children && children.length !== 0) {\n                                        children.forEach((mesh) => {\n                                            light.includedOnlyMeshes.push(mesh);\n                                            activateLightOnSubMeshes(mesh, light);\n                                        });\n                                    }\n                                };\n                                this._lightOnControllers.includedOnlyMeshes.push(loadedMesh);\n                                activateLightOnSubMeshes(loadedMesh, this._lightOnControllers);\n                            }\n                        });\n                    }\n                }\n                webVrController.attachToPoseControlledCamera(this);\n                // since this is async - sanity check. Is the controller already stored?\n                if (this.controllers.indexOf(webVrController) === -1) {\n                    //add to the controllers array\n                    this.controllers.push(webVrController);\n                    // Forced to add some control code for Vive as it doesn't always fill properly the \"hand\" property\n                    // Sometimes, both controllers are set correctly (left and right), sometimes none, sometimes only one of them...\n                    // So we're overriding setting left & right manually to be sure\n                    let firstViveWandDetected = false;\n                    for (let i = 0; i < this.controllers.length; i++) {\n                        if (this.controllers[i].controllerType === PoseEnabledControllerType.VIVE) {\n                            if (!firstViveWandDetected) {\n                                firstViveWandDetected = true;\n                                this.controllers[i].hand = \"left\";\n                            }\n                            else {\n                                this.controllers[i].hand = \"right\";\n                            }\n                        }\n                    }\n                    //did we find enough controllers? Great! let the developer know.\n                    if (this.controllers.length >= 2) {\n                        this.onControllersAttachedObservable.notifyObservers(this.controllers);\n                    }\n                }\n            }\n        });\n    }\n}\n//# sourceMappingURL=webVRCamera.js.map","import { __decorate } from \"../tslib.es6.js\";\nimport { serialize, serializeAsVector3, serializeAsMeshReference, serializeAsVector2 } from \"../Misc/decorators.js\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { Matrix, Vector3, Vector2 } from \"../Maths/math.vector.js\";\nimport { Node } from \"../node.js\";\nimport { Mesh } from \"../Meshes/mesh.js\";\nimport { AutoRotationBehavior } from \"../Behaviors/Cameras/autoRotationBehavior.js\";\nimport { BouncingBehavior } from \"../Behaviors/Cameras/bouncingBehavior.js\";\nimport { FramingBehavior } from \"../Behaviors/Cameras/framingBehavior.js\";\nimport { Camera } from \"./camera.js\";\nimport { TargetCamera } from \"./targetCamera.js\";\nimport { ArcRotateCameraInputsManager } from \"../Cameras/arcRotateCameraInputsManager.js\";\nimport { Epsilon } from \"../Maths/math.constants.js\";\nimport { Tools } from \"../Misc/tools.js\";\nNode.AddNodeConstructor(\"ArcRotateCamera\", (name, scene) => {\n    return () => new ArcRotateCamera(name, 0, 0, 1.0, Vector3.Zero(), scene);\n});\n/**\n * This represents an orbital type of camera.\n *\n * This camera always points towards a given target position and can be rotated around that target with the target as the centre of rotation. It can be controlled with cursors and mouse, or with touch events.\n * Think of this camera as one orbiting its target position, or more imaginatively as a spy satellite orbiting the earth. Its position relative to the target (earth) can be set by three parameters, alpha (radians) the longitudinal rotation, beta (radians) the latitudinal rotation and radius the distance from the target position.\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_introduction#arc-rotate-camera\n */\nexport class ArcRotateCamera extends TargetCamera {\n    /**\n     * Defines the target point of the camera.\n     * The camera looks towards it from the radius distance.\n     */\n    get target() {\n        return this._target;\n    }\n    set target(value) {\n        this.setTarget(value);\n    }\n    /**\n     * Defines the target mesh of the camera.\n     * The camera looks towards it from the radius distance.\n     * Please note that setting a target host will disable panning.\n     */\n    get targetHost() {\n        return this._targetHost;\n    }\n    set targetHost(value) {\n        if (value) {\n            this.setTarget(value);\n        }\n    }\n    /**\n     * Return the current target position of the camera. This value is expressed in local space.\n     * @returns the target position\n     */\n    getTarget() {\n        return this.target;\n    }\n    /**\n     * Define the current local position of the camera in the scene\n     */\n    get position() {\n        return this._position;\n    }\n    set position(newPosition) {\n        this.setPosition(newPosition);\n    }\n    /**\n     * The vector the camera should consider as up. (default is Vector3(0, 1, 0) as returned by Vector3.Up())\n     * Setting this will copy the given vector to the camera's upVector, and set rotation matrices to and from Y up.\n     * DO NOT set the up vector using copyFrom or copyFromFloats, as this bypasses setting the above matrices.\n     */\n    set upVector(vec) {\n        if (!this._upToYMatrix) {\n            this._yToUpMatrix = new Matrix();\n            this._upToYMatrix = new Matrix();\n            this._upVector = Vector3.Zero();\n        }\n        vec.normalize();\n        this._upVector.copyFrom(vec);\n        this.setMatUp();\n    }\n    get upVector() {\n        return this._upVector;\n    }\n    /**\n     * Sets the Y-up to camera up-vector rotation matrix, and the up-vector to Y-up rotation matrix.\n     */\n    setMatUp() {\n        // from y-up to custom-up (used in _getViewMatrix)\n        Matrix.RotationAlignToRef(Vector3.UpReadOnly, this._upVector, this._yToUpMatrix);\n        // from custom-up to y-up (used in rebuildAnglesAndRadius)\n        Matrix.RotationAlignToRef(this._upVector, Vector3.UpReadOnly, this._upToYMatrix);\n    }\n    //-- begin properties for backward compatibility for inputs\n    /**\n     * Gets or Set the pointer angular sensibility  along the X axis or how fast is the camera rotating.\n     */\n    get angularSensibilityX() {\n        const pointers = this.inputs.attached[\"pointers\"];\n        if (pointers) {\n            return pointers.angularSensibilityX;\n        }\n        return 0;\n    }\n    set angularSensibilityX(value) {\n        const pointers = this.inputs.attached[\"pointers\"];\n        if (pointers) {\n            pointers.angularSensibilityX = value;\n        }\n    }\n    /**\n     * Gets or Set the pointer angular sensibility along the Y axis or how fast is the camera rotating.\n     */\n    get angularSensibilityY() {\n        const pointers = this.inputs.attached[\"pointers\"];\n        if (pointers) {\n            return pointers.angularSensibilityY;\n        }\n        return 0;\n    }\n    set angularSensibilityY(value) {\n        const pointers = this.inputs.attached[\"pointers\"];\n        if (pointers) {\n            pointers.angularSensibilityY = value;\n        }\n    }\n    /**\n     * Gets or Set the pointer pinch precision or how fast is the camera zooming.\n     */\n    get pinchPrecision() {\n        const pointers = this.inputs.attached[\"pointers\"];\n        if (pointers) {\n            return pointers.pinchPrecision;\n        }\n        return 0;\n    }\n    set pinchPrecision(value) {\n        const pointers = this.inputs.attached[\"pointers\"];\n        if (pointers) {\n            pointers.pinchPrecision = value;\n        }\n    }\n    /**\n     * Gets or Set the pointer pinch delta percentage or how fast is the camera zooming.\n     * It will be used instead of pinchDeltaPrecision if different from 0.\n     * It defines the percentage of current camera.radius to use as delta when pinch zoom is used.\n     */\n    get pinchDeltaPercentage() {\n        const pointers = this.inputs.attached[\"pointers\"];\n        if (pointers) {\n            return pointers.pinchDeltaPercentage;\n        }\n        return 0;\n    }\n    set pinchDeltaPercentage(value) {\n        const pointers = this.inputs.attached[\"pointers\"];\n        if (pointers) {\n            pointers.pinchDeltaPercentage = value;\n        }\n    }\n    /**\n     * Gets or Set the pointer use natural pinch zoom to override the pinch precision\n     * and pinch delta percentage.\n     * When useNaturalPinchZoom is true, multi touch zoom will zoom in such\n     * that any object in the plane at the camera's target point will scale\n     * perfectly with finger motion.\n     */\n    get useNaturalPinchZoom() {\n        const pointers = this.inputs.attached[\"pointers\"];\n        if (pointers) {\n            return pointers.useNaturalPinchZoom;\n        }\n        return false;\n    }\n    set useNaturalPinchZoom(value) {\n        const pointers = this.inputs.attached[\"pointers\"];\n        if (pointers) {\n            pointers.useNaturalPinchZoom = value;\n        }\n    }\n    /**\n     * Gets or Set the pointer panning sensibility or how fast is the camera moving.\n     */\n    get panningSensibility() {\n        const pointers = this.inputs.attached[\"pointers\"];\n        if (pointers) {\n            return pointers.panningSensibility;\n        }\n        return 0;\n    }\n    set panningSensibility(value) {\n        const pointers = this.inputs.attached[\"pointers\"];\n        if (pointers) {\n            pointers.panningSensibility = value;\n        }\n    }\n    /**\n     * Gets or Set the list of keyboard keys used to control beta angle in a positive direction.\n     */\n    get keysUp() {\n        const keyboard = this.inputs.attached[\"keyboard\"];\n        if (keyboard) {\n            return keyboard.keysUp;\n        }\n        return [];\n    }\n    set keysUp(value) {\n        const keyboard = this.inputs.attached[\"keyboard\"];\n        if (keyboard) {\n            keyboard.keysUp = value;\n        }\n    }\n    /**\n     * Gets or Set the list of keyboard keys used to control beta angle in a negative direction.\n     */\n    get keysDown() {\n        const keyboard = this.inputs.attached[\"keyboard\"];\n        if (keyboard) {\n            return keyboard.keysDown;\n        }\n        return [];\n    }\n    set keysDown(value) {\n        const keyboard = this.inputs.attached[\"keyboard\"];\n        if (keyboard) {\n            keyboard.keysDown = value;\n        }\n    }\n    /**\n     * Gets or Set the list of keyboard keys used to control alpha angle in a negative direction.\n     */\n    get keysLeft() {\n        const keyboard = this.inputs.attached[\"keyboard\"];\n        if (keyboard) {\n            return keyboard.keysLeft;\n        }\n        return [];\n    }\n    set keysLeft(value) {\n        const keyboard = this.inputs.attached[\"keyboard\"];\n        if (keyboard) {\n            keyboard.keysLeft = value;\n        }\n    }\n    /**\n     * Gets or Set the list of keyboard keys used to control alpha angle in a positive direction.\n     */\n    get keysRight() {\n        const keyboard = this.inputs.attached[\"keyboard\"];\n        if (keyboard) {\n            return keyboard.keysRight;\n        }\n        return [];\n    }\n    set keysRight(value) {\n        const keyboard = this.inputs.attached[\"keyboard\"];\n        if (keyboard) {\n            keyboard.keysRight = value;\n        }\n    }\n    /**\n     * Gets or Set the mouse wheel precision or how fast is the camera zooming.\n     */\n    get wheelPrecision() {\n        const mousewheel = this.inputs.attached[\"mousewheel\"];\n        if (mousewheel) {\n            return mousewheel.wheelPrecision;\n        }\n        return 0;\n    }\n    set wheelPrecision(value) {\n        const mousewheel = this.inputs.attached[\"mousewheel\"];\n        if (mousewheel) {\n            mousewheel.wheelPrecision = value;\n        }\n    }\n    /**\n     * Gets or Set the boolean value that controls whether or not the mouse wheel\n     * zooms to the location of the mouse pointer or not.  The default is false.\n     */\n    get zoomToMouseLocation() {\n        const mousewheel = this.inputs.attached[\"mousewheel\"];\n        if (mousewheel) {\n            return mousewheel.zoomToMouseLocation;\n        }\n        return false;\n    }\n    set zoomToMouseLocation(value) {\n        const mousewheel = this.inputs.attached[\"mousewheel\"];\n        if (mousewheel) {\n            mousewheel.zoomToMouseLocation = value;\n        }\n    }\n    /**\n     * Gets or Set the mouse wheel delta percentage or how fast is the camera zooming.\n     * It will be used instead of pinchDeltaPrecision if different from 0.\n     * It defines the percentage of current camera.radius to use as delta when pinch zoom is used.\n     */\n    get wheelDeltaPercentage() {\n        const mousewheel = this.inputs.attached[\"mousewheel\"];\n        if (mousewheel) {\n            return mousewheel.wheelDeltaPercentage;\n        }\n        return 0;\n    }\n    set wheelDeltaPercentage(value) {\n        const mousewheel = this.inputs.attached[\"mousewheel\"];\n        if (mousewheel) {\n            mousewheel.wheelDeltaPercentage = value;\n        }\n    }\n    /**\n     * Gets the bouncing behavior of the camera if it has been enabled.\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/behaviors/cameraBehaviors#bouncing-behavior\n     */\n    get bouncingBehavior() {\n        return this._bouncingBehavior;\n    }\n    /**\n     * Defines if the bouncing behavior of the camera is enabled on the camera.\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/behaviors/cameraBehaviors#bouncing-behavior\n     */\n    get useBouncingBehavior() {\n        return this._bouncingBehavior != null;\n    }\n    set useBouncingBehavior(value) {\n        if (value === this.useBouncingBehavior) {\n            return;\n        }\n        if (value) {\n            this._bouncingBehavior = new BouncingBehavior();\n            this.addBehavior(this._bouncingBehavior);\n        }\n        else if (this._bouncingBehavior) {\n            this.removeBehavior(this._bouncingBehavior);\n            this._bouncingBehavior = null;\n        }\n    }\n    /**\n     * Gets the framing behavior of the camera if it has been enabled.\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/behaviors/cameraBehaviors#framing-behavior\n     */\n    get framingBehavior() {\n        return this._framingBehavior;\n    }\n    /**\n     * Defines if the framing behavior of the camera is enabled on the camera.\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/behaviors/cameraBehaviors#framing-behavior\n     */\n    get useFramingBehavior() {\n        return this._framingBehavior != null;\n    }\n    set useFramingBehavior(value) {\n        if (value === this.useFramingBehavior) {\n            return;\n        }\n        if (value) {\n            this._framingBehavior = new FramingBehavior();\n            this.addBehavior(this._framingBehavior);\n        }\n        else if (this._framingBehavior) {\n            this.removeBehavior(this._framingBehavior);\n            this._framingBehavior = null;\n        }\n    }\n    /**\n     * Gets the auto rotation behavior of the camera if it has been enabled.\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/behaviors/cameraBehaviors#autorotation-behavior\n     */\n    get autoRotationBehavior() {\n        return this._autoRotationBehavior;\n    }\n    /**\n     * Defines if the auto rotation behavior of the camera is enabled on the camera.\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/behaviors/cameraBehaviors#autorotation-behavior\n     */\n    get useAutoRotationBehavior() {\n        return this._autoRotationBehavior != null;\n    }\n    set useAutoRotationBehavior(value) {\n        if (value === this.useAutoRotationBehavior) {\n            return;\n        }\n        if (value) {\n            this._autoRotationBehavior = new AutoRotationBehavior();\n            this.addBehavior(this._autoRotationBehavior);\n        }\n        else if (this._autoRotationBehavior) {\n            this.removeBehavior(this._autoRotationBehavior);\n            this._autoRotationBehavior = null;\n        }\n    }\n    /**\n     * Instantiates a new ArcRotateCamera in a given scene\n     * @param name Defines the name of the camera\n     * @param alpha Defines the camera rotation along the longitudinal axis\n     * @param beta Defines the camera rotation along the latitudinal axis\n     * @param radius Defines the camera distance from its target\n     * @param target Defines the camera target\n     * @param scene Defines the scene the camera belongs to\n     * @param setActiveOnSceneIfNoneActive Defines whether the camera should be marked as active if not other active cameras have been defined\n     */\n    constructor(name, alpha, beta, radius, target, scene, setActiveOnSceneIfNoneActive = true) {\n        super(name, Vector3.Zero(), scene, setActiveOnSceneIfNoneActive);\n        /**\n         * Current inertia value on the longitudinal axis.\n         * The bigger this number the longer it will take for the camera to stop.\n         */\n        this.inertialAlphaOffset = 0;\n        /**\n         * Current inertia value on the latitudinal axis.\n         * The bigger this number the longer it will take for the camera to stop.\n         */\n        this.inertialBetaOffset = 0;\n        /**\n         * Current inertia value on the radius axis.\n         * The bigger this number the longer it will take for the camera to stop.\n         */\n        this.inertialRadiusOffset = 0;\n        /**\n         * Minimum allowed angle on the longitudinal axis.\n         * This can help limiting how the Camera is able to move in the scene.\n         */\n        this.lowerAlphaLimit = null;\n        /**\n         * Maximum allowed angle on the longitudinal axis.\n         * This can help limiting how the Camera is able to move in the scene.\n         */\n        this.upperAlphaLimit = null;\n        /**\n         * Minimum allowed angle on the latitudinal axis.\n         * This can help limiting how the Camera is able to move in the scene.\n         */\n        this.lowerBetaLimit = 0.01;\n        /**\n         * Maximum allowed angle on the latitudinal axis.\n         * This can help limiting how the Camera is able to move in the scene.\n         */\n        this.upperBetaLimit = Math.PI - 0.01;\n        /**\n         * Minimum allowed distance of the camera to the target (The camera can not get closer).\n         * This can help limiting how the Camera is able to move in the scene.\n         */\n        this.lowerRadiusLimit = null;\n        /**\n         * Maximum allowed distance of the camera to the target (The camera can not get further).\n         * This can help limiting how the Camera is able to move in the scene.\n         */\n        this.upperRadiusLimit = null;\n        /**\n         * Defines the current inertia value used during panning of the camera along the X axis.\n         */\n        this.inertialPanningX = 0;\n        /**\n         * Defines the current inertia value used during panning of the camera along the Y axis.\n         */\n        this.inertialPanningY = 0;\n        /**\n         * Defines the distance used to consider the camera in pan mode vs pinch/zoom.\n         * Basically if your fingers moves away from more than this distance you will be considered\n         * in pinch mode.\n         */\n        this.pinchToPanMaxDistance = 20;\n        /**\n         * Defines the maximum distance the camera can pan.\n         * This could help keeping the camera always in your scene.\n         */\n        this.panningDistanceLimit = null;\n        /**\n         * Defines the target of the camera before panning.\n         */\n        this.panningOriginTarget = Vector3.Zero();\n        /**\n         * Defines the value of the inertia used during panning.\n         * 0 would mean stop inertia and one would mean no deceleration at all.\n         */\n        this.panningInertia = 0.9;\n        //-- end properties for backward compatibility for inputs\n        /**\n         * Defines how much the radius should be scaled while zooming on a particular mesh (through the zoomOn function)\n         */\n        this.zoomOnFactor = 1;\n        /**\n         * Defines a screen offset for the camera position.\n         */\n        this.targetScreenOffset = Vector2.Zero();\n        /**\n         * Allows the camera to be completely reversed.\n         * If false the camera can not arrive upside down.\n         */\n        this.allowUpsideDown = true;\n        /**\n         * Define if double tap/click is used to restore the previously saved state of the camera.\n         */\n        this.useInputToRestoreState = true;\n        /** @internal */\n        this._viewMatrix = new Matrix();\n        /**\n         * Defines the allowed panning axis.\n         */\n        this.panningAxis = new Vector3(1, 1, 0);\n        this._transformedDirection = new Vector3();\n        /**\n         * Defines if camera will eliminate transform on y axis.\n         */\n        this.mapPanning = false;\n        /**\n         * Observable triggered when the mesh target has been changed on the camera.\n         */\n        this.onMeshTargetChangedObservable = new Observable();\n        /**\n         * Defines whether the camera should check collision with the objects oh the scene.\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_collisions#how-can-i-do-this-\n         */\n        this.checkCollisions = false;\n        /**\n         * Defines the collision radius of the camera.\n         * This simulates a sphere around the camera.\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_collisions#arcrotatecamera\n         */\n        this.collisionRadius = new Vector3(0.5, 0.5, 0.5);\n        this._previousPosition = Vector3.Zero();\n        this._collisionVelocity = Vector3.Zero();\n        this._newPosition = Vector3.Zero();\n        this._computationVector = Vector3.Zero();\n        this._onCollisionPositionChange = (collisionId, newPosition, collidedMesh = null) => {\n            if (!collidedMesh) {\n                this._previousPosition.copyFrom(this._position);\n            }\n            else {\n                this.setPosition(newPosition);\n                if (this.onCollide) {\n                    this.onCollide(collidedMesh);\n                }\n            }\n            // Recompute because of constraints\n            const cosa = Math.cos(this.alpha);\n            const sina = Math.sin(this.alpha);\n            const cosb = Math.cos(this.beta);\n            let sinb = Math.sin(this.beta);\n            if (sinb === 0) {\n                sinb = 0.0001;\n            }\n            const target = this._getTargetPosition();\n            this._computationVector.copyFromFloats(this.radius * cosa * sinb, this.radius * cosb, this.radius * sina * sinb);\n            target.addToRef(this._computationVector, this._newPosition);\n            this._position.copyFrom(this._newPosition);\n            let up = this.upVector;\n            if (this.allowUpsideDown && this.beta < 0) {\n                up = up.clone();\n                up = up.negate();\n            }\n            this._computeViewMatrix(this._position, target, up);\n            this._viewMatrix.addAtIndex(12, this.targetScreenOffset.x);\n            this._viewMatrix.addAtIndex(13, this.targetScreenOffset.y);\n            this._collisionTriggered = false;\n        };\n        this._target = Vector3.Zero();\n        if (target) {\n            this.setTarget(target);\n        }\n        this.alpha = alpha;\n        this.beta = beta;\n        this.radius = radius;\n        this.getViewMatrix();\n        this.inputs = new ArcRotateCameraInputsManager(this);\n        this.inputs.addKeyboard().addMouseWheel().addPointers();\n    }\n    // Cache\n    /** @internal */\n    _initCache() {\n        super._initCache();\n        this._cache._target = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\n        this._cache.alpha = undefined;\n        this._cache.beta = undefined;\n        this._cache.radius = undefined;\n        this._cache.targetScreenOffset = Vector2.Zero();\n    }\n    /**\n     * @internal\n     */\n    _updateCache(ignoreParentClass) {\n        if (!ignoreParentClass) {\n            super._updateCache();\n        }\n        this._cache._target.copyFrom(this._getTargetPosition());\n        this._cache.alpha = this.alpha;\n        this._cache.beta = this.beta;\n        this._cache.radius = this.radius;\n        this._cache.targetScreenOffset.copyFrom(this.targetScreenOffset);\n    }\n    _getTargetPosition() {\n        if (this._targetHost && this._targetHost.getAbsolutePosition) {\n            const pos = this._targetHost.getAbsolutePosition();\n            if (this._targetBoundingCenter) {\n                pos.addToRef(this._targetBoundingCenter, this._target);\n            }\n            else {\n                this._target.copyFrom(pos);\n            }\n        }\n        const lockedTargetPosition = this._getLockedTargetPosition();\n        if (lockedTargetPosition) {\n            return lockedTargetPosition;\n        }\n        return this._target;\n    }\n    /**\n     * Stores the current state of the camera (alpha, beta, radius and target)\n     * @returns the camera itself\n     */\n    storeState() {\n        this._storedAlpha = this.alpha;\n        this._storedBeta = this.beta;\n        this._storedRadius = this.radius;\n        this._storedTarget = this._getTargetPosition().clone();\n        this._storedTargetScreenOffset = this.targetScreenOffset.clone();\n        return super.storeState();\n    }\n    /**\n     * @internal\n     * Restored camera state. You must call storeState() first\n     */\n    _restoreStateValues() {\n        if (!super._restoreStateValues()) {\n            return false;\n        }\n        this.setTarget(this._storedTarget.clone());\n        this.alpha = this._storedAlpha;\n        this.beta = this._storedBeta;\n        this.radius = this._storedRadius;\n        this.targetScreenOffset = this._storedTargetScreenOffset.clone();\n        this.inertialAlphaOffset = 0;\n        this.inertialBetaOffset = 0;\n        this.inertialRadiusOffset = 0;\n        this.inertialPanningX = 0;\n        this.inertialPanningY = 0;\n        return true;\n    }\n    // Synchronized\n    /** @internal */\n    _isSynchronizedViewMatrix() {\n        if (!super._isSynchronizedViewMatrix()) {\n            return false;\n        }\n        return (this._cache._target.equals(this._getTargetPosition()) &&\n            this._cache.alpha === this.alpha &&\n            this._cache.beta === this.beta &&\n            this._cache.radius === this.radius &&\n            this._cache.targetScreenOffset.equals(this.targetScreenOffset));\n    }\n    /**\n     * Attached controls to the current camera.\n     * @param ignored defines an ignored parameter kept for backward compatibility.\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\n     * @param useCtrlForPanning  Defines whether ctrl is used for panning within the controls\n     * @param panningMouseButton Defines whether panning is allowed through mouse click button\n     */\n    attachControl(ignored, noPreventDefault, useCtrlForPanning = true, panningMouseButton = 2) {\n        // eslint-disable-next-line prefer-rest-params\n        const args = arguments;\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(args);\n        this._useCtrlForPanning = useCtrlForPanning;\n        this._panningMouseButton = panningMouseButton;\n        // backwards compatibility\n        if (typeof args[0] === \"boolean\") {\n            if (args.length > 1) {\n                this._useCtrlForPanning = args[1];\n            }\n            if (args.length > 2) {\n                this._panningMouseButton = args[2];\n            }\n        }\n        this.inputs.attachElement(noPreventDefault);\n        this._reset = () => {\n            this.inertialAlphaOffset = 0;\n            this.inertialBetaOffset = 0;\n            this.inertialRadiusOffset = 0;\n            this.inertialPanningX = 0;\n            this.inertialPanningY = 0;\n        };\n    }\n    /**\n     * Detach the current controls from the specified dom element.\n     */\n    detachControl() {\n        this.inputs.detachElement();\n        if (this._reset) {\n            this._reset();\n        }\n    }\n    /** @internal */\n    _checkInputs() {\n        //if (async) collision inspection was triggered, don't update the camera's position - until the collision callback was called.\n        if (this._collisionTriggered) {\n            return;\n        }\n        this.inputs.checkInputs();\n        // Inertia\n        if (this.inertialAlphaOffset !== 0 || this.inertialBetaOffset !== 0 || this.inertialRadiusOffset !== 0) {\n            const directionModifier = this.invertRotation ? -1 : 1;\n            let inertialAlphaOffset = this.inertialAlphaOffset;\n            if (this.beta <= 0) {\n                inertialAlphaOffset *= -1;\n            }\n            if (this.getScene().useRightHandedSystem) {\n                inertialAlphaOffset *= -1;\n            }\n            if (this.parent && this.parent._getWorldMatrixDeterminant() < 0) {\n                inertialAlphaOffset *= -1;\n            }\n            this.alpha += inertialAlphaOffset * directionModifier;\n            this.beta += this.inertialBetaOffset * directionModifier;\n            this.radius -= this.inertialRadiusOffset;\n            this.inertialAlphaOffset *= this.inertia;\n            this.inertialBetaOffset *= this.inertia;\n            this.inertialRadiusOffset *= this.inertia;\n            if (Math.abs(this.inertialAlphaOffset) < Epsilon) {\n                this.inertialAlphaOffset = 0;\n            }\n            if (Math.abs(this.inertialBetaOffset) < Epsilon) {\n                this.inertialBetaOffset = 0;\n            }\n            if (Math.abs(this.inertialRadiusOffset) < this.speed * Epsilon) {\n                this.inertialRadiusOffset = 0;\n            }\n        }\n        // Panning inertia\n        if (this.inertialPanningX !== 0 || this.inertialPanningY !== 0) {\n            const localDirection = new Vector3(this.inertialPanningX, this.inertialPanningY, this.inertialPanningY);\n            this._viewMatrix.invertToRef(this._cameraTransformMatrix);\n            localDirection.multiplyInPlace(this.panningAxis);\n            Vector3.TransformNormalToRef(localDirection, this._cameraTransformMatrix, this._transformedDirection);\n            // Eliminate y if mapPanning is enabled\n            if (this.mapPanning || !this.panningAxis.y) {\n                this._transformedDirection.y = 0;\n            }\n            if (!this._targetHost) {\n                if (this.panningDistanceLimit) {\n                    this._transformedDirection.addInPlace(this._target);\n                    const distanceSquared = Vector3.DistanceSquared(this._transformedDirection, this.panningOriginTarget);\n                    if (distanceSquared <= this.panningDistanceLimit * this.panningDistanceLimit) {\n                        this._target.copyFrom(this._transformedDirection);\n                    }\n                }\n                else {\n                    this._target.addInPlace(this._transformedDirection);\n                }\n            }\n            this.inertialPanningX *= this.panningInertia;\n            this.inertialPanningY *= this.panningInertia;\n            if (Math.abs(this.inertialPanningX) < this.speed * Epsilon) {\n                this.inertialPanningX = 0;\n            }\n            if (Math.abs(this.inertialPanningY) < this.speed * Epsilon) {\n                this.inertialPanningY = 0;\n            }\n        }\n        // Limits\n        this._checkLimits();\n        super._checkInputs();\n    }\n    _checkLimits() {\n        if (this.lowerBetaLimit === null || this.lowerBetaLimit === undefined) {\n            if (this.allowUpsideDown && this.beta > Math.PI) {\n                this.beta = this.beta - 2 * Math.PI;\n            }\n        }\n        else {\n            if (this.beta < this.lowerBetaLimit) {\n                this.beta = this.lowerBetaLimit;\n            }\n        }\n        if (this.upperBetaLimit === null || this.upperBetaLimit === undefined) {\n            if (this.allowUpsideDown && this.beta < -Math.PI) {\n                this.beta = this.beta + 2 * Math.PI;\n            }\n        }\n        else {\n            if (this.beta > this.upperBetaLimit) {\n                this.beta = this.upperBetaLimit;\n            }\n        }\n        if (this.lowerAlphaLimit !== null && this.alpha < this.lowerAlphaLimit) {\n            this.alpha = this.lowerAlphaLimit;\n        }\n        if (this.upperAlphaLimit !== null && this.alpha > this.upperAlphaLimit) {\n            this.alpha = this.upperAlphaLimit;\n        }\n        if (this.lowerRadiusLimit !== null && this.radius < this.lowerRadiusLimit) {\n            this.radius = this.lowerRadiusLimit;\n            this.inertialRadiusOffset = 0;\n        }\n        if (this.upperRadiusLimit !== null && this.radius > this.upperRadiusLimit) {\n            this.radius = this.upperRadiusLimit;\n            this.inertialRadiusOffset = 0;\n        }\n    }\n    /**\n     * Rebuilds angles (alpha, beta) and radius from the give position and target\n     */\n    rebuildAnglesAndRadius() {\n        this._position.subtractToRef(this._getTargetPosition(), this._computationVector);\n        // need to rotate to Y up equivalent if up vector not Axis.Y\n        if (this._upVector.x !== 0 || this._upVector.y !== 1.0 || this._upVector.z !== 0) {\n            Vector3.TransformCoordinatesToRef(this._computationVector, this._upToYMatrix, this._computationVector);\n        }\n        this.radius = this._computationVector.length();\n        if (this.radius === 0) {\n            this.radius = 0.0001; // Just to avoid division by zero\n        }\n        // Alpha\n        const previousAlpha = this.alpha;\n        if (this._computationVector.x === 0 && this._computationVector.z === 0) {\n            this.alpha = Math.PI / 2; // avoid division by zero when looking along up axis, and set to acos(0)\n        }\n        else {\n            this.alpha = Math.acos(this._computationVector.x / Math.sqrt(Math.pow(this._computationVector.x, 2) + Math.pow(this._computationVector.z, 2)));\n        }\n        if (this._computationVector.z < 0) {\n            this.alpha = 2 * Math.PI - this.alpha;\n        }\n        // Calculate the number of revolutions between the new and old alpha values.\n        const alphaCorrectionTurns = Math.round((previousAlpha - this.alpha) / (2.0 * Math.PI));\n        // Adjust alpha so that its numerical representation is the closest one to the old value.\n        this.alpha += alphaCorrectionTurns * 2.0 * Math.PI;\n        // Beta\n        this.beta = Math.acos(this._computationVector.y / this.radius);\n        this._checkLimits();\n    }\n    /**\n     * Use a position to define the current camera related information like alpha, beta and radius\n     * @param position Defines the position to set the camera at\n     */\n    setPosition(position) {\n        if (this._position.equals(position)) {\n            return;\n        }\n        this._position.copyFrom(position);\n        this.rebuildAnglesAndRadius();\n    }\n    /**\n     * Defines the target the camera should look at.\n     * This will automatically adapt alpha beta and radius to fit within the new target.\n     * Please note that setting a target as a mesh will disable panning.\n     * @param target Defines the new target as a Vector or a mesh\n     * @param toBoundingCenter In case of a mesh target, defines whether to target the mesh position or its bounding information center\n     * @param allowSamePosition If false, prevents reapplying the new computed position if it is identical to the current one (optim)\n     * @param cloneAlphaBetaRadius If true, replicate the current setup (alpha, beta, radius) on the new target\n     */\n    setTarget(target, toBoundingCenter = false, allowSamePosition = false, cloneAlphaBetaRadius = false) {\n        var _a;\n        cloneAlphaBetaRadius = (_a = this.overrideCloneAlphaBetaRadius) !== null && _a !== void 0 ? _a : cloneAlphaBetaRadius;\n        if (target.getBoundingInfo) {\n            if (toBoundingCenter) {\n                this._targetBoundingCenter = target.getBoundingInfo().boundingBox.centerWorld.clone();\n            }\n            else {\n                this._targetBoundingCenter = null;\n            }\n            target.computeWorldMatrix();\n            this._targetHost = target;\n            this._target = this._getTargetPosition();\n            this.onMeshTargetChangedObservable.notifyObservers(this._targetHost);\n        }\n        else {\n            const newTarget = target;\n            const currentTarget = this._getTargetPosition();\n            if (currentTarget && !allowSamePosition && currentTarget.equals(newTarget)) {\n                return;\n            }\n            this._targetHost = null;\n            this._target = newTarget;\n            this._targetBoundingCenter = null;\n            this.onMeshTargetChangedObservable.notifyObservers(null);\n        }\n        if (!cloneAlphaBetaRadius) {\n            this.rebuildAnglesAndRadius();\n        }\n    }\n    /** @internal */\n    _getViewMatrix() {\n        // Compute\n        const cosa = Math.cos(this.alpha);\n        const sina = Math.sin(this.alpha);\n        const cosb = Math.cos(this.beta);\n        let sinb = Math.sin(this.beta);\n        if (sinb === 0) {\n            sinb = 0.0001;\n        }\n        if (this.radius === 0) {\n            this.radius = 0.0001; // Just to avoid division by zero\n        }\n        const target = this._getTargetPosition();\n        this._computationVector.copyFromFloats(this.radius * cosa * sinb, this.radius * cosb, this.radius * sina * sinb);\n        // Rotate according to up vector\n        if (this._upVector.x !== 0 || this._upVector.y !== 1.0 || this._upVector.z !== 0) {\n            Vector3.TransformCoordinatesToRef(this._computationVector, this._yToUpMatrix, this._computationVector);\n        }\n        target.addToRef(this._computationVector, this._newPosition);\n        if (this.getScene().collisionsEnabled && this.checkCollisions) {\n            const coordinator = this.getScene().collisionCoordinator;\n            if (!this._collider) {\n                this._collider = coordinator.createCollider();\n            }\n            this._collider._radius = this.collisionRadius;\n            this._newPosition.subtractToRef(this._position, this._collisionVelocity);\n            this._collisionTriggered = true;\n            coordinator.getNewPosition(this._position, this._collisionVelocity, this._collider, 3, null, this._onCollisionPositionChange, this.uniqueId);\n        }\n        else {\n            this._position.copyFrom(this._newPosition);\n            let up = this.upVector;\n            if (this.allowUpsideDown && sinb < 0) {\n                up = up.negate();\n            }\n            this._computeViewMatrix(this._position, target, up);\n            this._viewMatrix.addAtIndex(12, this.targetScreenOffset.x);\n            this._viewMatrix.addAtIndex(13, this.targetScreenOffset.y);\n        }\n        this._currentTarget = target;\n        return this._viewMatrix;\n    }\n    /**\n     * Zooms on a mesh to be at the min distance where we could see it fully in the current viewport.\n     * @param meshes Defines the mesh to zoom on\n     * @param doNotUpdateMaxZ Defines whether or not maxZ should be updated whilst zooming on the mesh (this can happen if the mesh is big and the maxradius pretty small for instance)\n     */\n    zoomOn(meshes, doNotUpdateMaxZ = false) {\n        meshes = meshes || this.getScene().meshes;\n        const minMaxVector = Mesh.MinMax(meshes);\n        const distance = Vector3.Distance(minMaxVector.min, minMaxVector.max);\n        this.radius = distance * this.zoomOnFactor;\n        this.focusOn({ min: minMaxVector.min, max: minMaxVector.max, distance: distance }, doNotUpdateMaxZ);\n    }\n    /**\n     * Focus on a mesh or a bounding box. This adapts the target and maxRadius if necessary but does not update the current radius.\n     * The target will be changed but the radius\n     * @param meshesOrMinMaxVectorAndDistance Defines the mesh or bounding info to focus on\n     * @param doNotUpdateMaxZ Defines whether or not maxZ should be updated whilst zooming on the mesh (this can happen if the mesh is big and the maxradius pretty small for instance)\n     */\n    focusOn(meshesOrMinMaxVectorAndDistance, doNotUpdateMaxZ = false) {\n        let meshesOrMinMaxVector;\n        let distance;\n        if (meshesOrMinMaxVectorAndDistance.min === undefined) {\n            // meshes\n            const meshes = meshesOrMinMaxVectorAndDistance || this.getScene().meshes;\n            meshesOrMinMaxVector = Mesh.MinMax(meshes);\n            distance = Vector3.Distance(meshesOrMinMaxVector.min, meshesOrMinMaxVector.max);\n        }\n        else {\n            //minMaxVector and distance\n            const minMaxVectorAndDistance = meshesOrMinMaxVectorAndDistance;\n            meshesOrMinMaxVector = minMaxVectorAndDistance;\n            distance = minMaxVectorAndDistance.distance;\n        }\n        this._target = Mesh.Center(meshesOrMinMaxVector);\n        if (!doNotUpdateMaxZ) {\n            this.maxZ = distance * 2;\n        }\n    }\n    /**\n     * @override\n     * Override Camera.createRigCamera\n     */\n    createRigCamera(name, cameraIndex) {\n        let alphaShift = 0;\n        switch (this.cameraRigMode) {\n            case Camera.RIG_MODE_STEREOSCOPIC_ANAGLYPH:\n            case Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL:\n            case Camera.RIG_MODE_STEREOSCOPIC_OVERUNDER:\n            case Camera.RIG_MODE_STEREOSCOPIC_INTERLACED:\n            case Camera.RIG_MODE_VR:\n                alphaShift = this._cameraRigParams.stereoHalfAngle * (cameraIndex === 0 ? 1 : -1);\n                break;\n            case Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED:\n                alphaShift = this._cameraRigParams.stereoHalfAngle * (cameraIndex === 0 ? -1 : 1);\n                break;\n        }\n        const rigCam = new ArcRotateCamera(name, this.alpha + alphaShift, this.beta, this.radius, this._target, this.getScene());\n        rigCam._cameraRigParams = {};\n        rigCam.isRigCamera = true;\n        rigCam.rigParent = this;\n        rigCam.upVector = this.upVector;\n        rigCam.mode = this.mode;\n        rigCam.orthoLeft = this.orthoLeft;\n        rigCam.orthoRight = this.orthoRight;\n        rigCam.orthoBottom = this.orthoBottom;\n        rigCam.orthoTop = this.orthoTop;\n        return rigCam;\n    }\n    /**\n     * @internal\n     * @override\n     * Override Camera._updateRigCameras\n     */\n    _updateRigCameras() {\n        const camLeft = this._rigCameras[0];\n        const camRight = this._rigCameras[1];\n        camLeft.beta = camRight.beta = this.beta;\n        switch (this.cameraRigMode) {\n            case Camera.RIG_MODE_STEREOSCOPIC_ANAGLYPH:\n            case Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL:\n            case Camera.RIG_MODE_STEREOSCOPIC_OVERUNDER:\n            case Camera.RIG_MODE_STEREOSCOPIC_INTERLACED:\n            case Camera.RIG_MODE_VR:\n                camLeft.alpha = this.alpha - this._cameraRigParams.stereoHalfAngle;\n                camRight.alpha = this.alpha + this._cameraRigParams.stereoHalfAngle;\n                break;\n            case Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED:\n                camLeft.alpha = this.alpha + this._cameraRigParams.stereoHalfAngle;\n                camRight.alpha = this.alpha - this._cameraRigParams.stereoHalfAngle;\n                break;\n        }\n        super._updateRigCameras();\n    }\n    /**\n     * Destroy the camera and release the current resources hold by it.\n     */\n    dispose() {\n        this.inputs.clear();\n        super.dispose();\n    }\n    /**\n     * Gets the current object class name.\n     * @returns the class name\n     */\n    getClassName() {\n        return \"ArcRotateCamera\";\n    }\n}\n__decorate([\n    serialize()\n], ArcRotateCamera.prototype, \"alpha\", void 0);\n__decorate([\n    serialize()\n], ArcRotateCamera.prototype, \"beta\", void 0);\n__decorate([\n    serialize()\n], ArcRotateCamera.prototype, \"radius\", void 0);\n__decorate([\n    serialize()\n], ArcRotateCamera.prototype, \"overrideCloneAlphaBetaRadius\", void 0);\n__decorate([\n    serializeAsVector3(\"target\")\n], ArcRotateCamera.prototype, \"_target\", void 0);\n__decorate([\n    serializeAsMeshReference(\"targetHost\")\n], ArcRotateCamera.prototype, \"_targetHost\", void 0);\n__decorate([\n    serialize()\n], ArcRotateCamera.prototype, \"inertialAlphaOffset\", void 0);\n__decorate([\n    serialize()\n], ArcRotateCamera.prototype, \"inertialBetaOffset\", void 0);\n__decorate([\n    serialize()\n], ArcRotateCamera.prototype, \"inertialRadiusOffset\", void 0);\n__decorate([\n    serialize()\n], ArcRotateCamera.prototype, \"lowerAlphaLimit\", void 0);\n__decorate([\n    serialize()\n], ArcRotateCamera.prototype, \"upperAlphaLimit\", void 0);\n__decorate([\n    serialize()\n], ArcRotateCamera.prototype, \"lowerBetaLimit\", void 0);\n__decorate([\n    serialize()\n], ArcRotateCamera.prototype, \"upperBetaLimit\", void 0);\n__decorate([\n    serialize()\n], ArcRotateCamera.prototype, \"lowerRadiusLimit\", void 0);\n__decorate([\n    serialize()\n], ArcRotateCamera.prototype, \"upperRadiusLimit\", void 0);\n__decorate([\n    serialize()\n], ArcRotateCamera.prototype, \"inertialPanningX\", void 0);\n__decorate([\n    serialize()\n], ArcRotateCamera.prototype, \"inertialPanningY\", void 0);\n__decorate([\n    serialize()\n], ArcRotateCamera.prototype, \"pinchToPanMaxDistance\", void 0);\n__decorate([\n    serialize()\n], ArcRotateCamera.prototype, \"panningDistanceLimit\", void 0);\n__decorate([\n    serializeAsVector3()\n], ArcRotateCamera.prototype, \"panningOriginTarget\", void 0);\n__decorate([\n    serialize()\n], ArcRotateCamera.prototype, \"panningInertia\", void 0);\n__decorate([\n    serialize()\n], ArcRotateCamera.prototype, \"zoomToMouseLocation\", null);\n__decorate([\n    serialize()\n], ArcRotateCamera.prototype, \"zoomOnFactor\", void 0);\n__decorate([\n    serializeAsVector2()\n], ArcRotateCamera.prototype, \"targetScreenOffset\", void 0);\n__decorate([\n    serialize()\n], ArcRotateCamera.prototype, \"allowUpsideDown\", void 0);\n__decorate([\n    serialize()\n], ArcRotateCamera.prototype, \"useInputToRestoreState\", void 0);\n//# sourceMappingURL=arcRotateCamera.js.map","import { ArcRotateCameraPointersInput } from \"../Cameras/Inputs/arcRotateCameraPointersInput.js\";\nimport { ArcRotateCameraKeyboardMoveInput } from \"../Cameras/Inputs/arcRotateCameraKeyboardMoveInput.js\";\nimport { ArcRotateCameraMouseWheelInput } from \"../Cameras/Inputs/arcRotateCameraMouseWheelInput.js\";\nimport { CameraInputsManager } from \"../Cameras/cameraInputsManager.js\";\n/**\n * Default Inputs manager for the ArcRotateCamera.\n * It groups all the default supported inputs for ease of use.\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\n */\nexport class ArcRotateCameraInputsManager extends CameraInputsManager {\n    /**\n     * Instantiates a new ArcRotateCameraInputsManager.\n     * @param camera Defines the camera the inputs belong to\n     */\n    constructor(camera) {\n        super(camera);\n    }\n    /**\n     * Add mouse wheel input support to the input manager.\n     * @returns the current input manager\n     */\n    addMouseWheel() {\n        this.add(new ArcRotateCameraMouseWheelInput());\n        return this;\n    }\n    /**\n     * Add pointers input support to the input manager.\n     * @returns the current input manager\n     */\n    addPointers() {\n        this.add(new ArcRotateCameraPointersInput());\n        return this;\n    }\n    /**\n     * Add keyboard input support to the input manager.\n     * @returns the current input manager\n     */\n    addKeyboard() {\n        this.add(new ArcRotateCameraKeyboardMoveInput());\n        return this;\n    }\n}\n//# sourceMappingURL=arcRotateCameraInputsManager.js.map","import { __decorate } from \"../tslib.es6.js\";\nimport { serialize, SerializationHelper, serializeAsVector3 } from \"../Misc/decorators.js\";\nimport { SmartArray } from \"../Misc/smartArray.js\";\nimport { Tools } from \"../Misc/tools.js\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { Matrix, Vector3, Quaternion } from \"../Maths/math.vector.js\";\nimport { Node } from \"../node.js\";\nimport { Logger } from \"../Misc/logger.js\";\nimport { GetClass } from \"../Misc/typeStore.js\";\nimport { _WarnImport } from \"../Misc/devTools.js\";\nimport { Viewport } from \"../Maths/math.viewport.js\";\nimport { Frustum } from \"../Maths/math.frustum.js\";\n\n/**\n * This is the base class of all the camera used in the application.\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras\n */\nexport class Camera extends Node {\n    /**\n     * Define the current local position of the camera in the scene\n     */\n    get position() {\n        return this._position;\n    }\n    set position(newPosition) {\n        this._position = newPosition;\n    }\n    /**\n     * The vector the camera should consider as up.\n     * (default is Vector3(0, 1, 0) aka Vector3.Up())\n     */\n    set upVector(vec) {\n        this._upVector = vec;\n    }\n    get upVector() {\n        return this._upVector;\n    }\n    /**\n     * The screen area in scene units squared\n     */\n    get screenArea() {\n        var _a, _b, _c, _d;\n        let x = 0;\n        let y = 0;\n        if (this.mode === Camera.PERSPECTIVE_CAMERA) {\n            if (this.fovMode === Camera.FOVMODE_VERTICAL_FIXED) {\n                y = this.minZ * 2 * Math.tan(this.fov / 2);\n                x = this.getEngine().getAspectRatio(this) * y;\n            }\n            else {\n                x = this.minZ * 2 * Math.tan(this.fov / 2);\n                y = x / this.getEngine().getAspectRatio(this);\n            }\n        }\n        else {\n            const halfWidth = this.getEngine().getRenderWidth() / 2.0;\n            const halfHeight = this.getEngine().getRenderHeight() / 2.0;\n            x = ((_a = this.orthoRight) !== null && _a !== void 0 ? _a : halfWidth) - ((_b = this.orthoLeft) !== null && _b !== void 0 ? _b : -halfWidth);\n            y = ((_c = this.orthoTop) !== null && _c !== void 0 ? _c : halfHeight) - ((_d = this.orthoBottom) !== null && _d !== void 0 ? _d : -halfHeight);\n        }\n        return x * y;\n    }\n    set orthoLeft(value) {\n        this._orthoLeft = value;\n        for (const rigCamera of this._rigCameras) {\n            rigCamera.orthoLeft = value;\n        }\n    }\n    get orthoLeft() {\n        return this._orthoLeft;\n    }\n    set orthoRight(value) {\n        this._orthoRight = value;\n        for (const rigCamera of this._rigCameras) {\n            rigCamera.orthoRight = value;\n        }\n    }\n    get orthoRight() {\n        return this._orthoRight;\n    }\n    set orthoBottom(value) {\n        this._orthoBottom = value;\n        for (const rigCamera of this._rigCameras) {\n            rigCamera.orthoBottom = value;\n        }\n    }\n    get orthoBottom() {\n        return this._orthoBottom;\n    }\n    set orthoTop(value) {\n        this._orthoTop = value;\n        for (const rigCamera of this._rigCameras) {\n            rigCamera.orthoTop = value;\n        }\n    }\n    get orthoTop() {\n        return this._orthoTop;\n    }\n    set mode(mode) {\n        this._mode = mode;\n        // Pass the mode down to the rig cameras\n        for (const rigCamera of this._rigCameras) {\n            rigCamera.mode = mode;\n        }\n    }\n    get mode() {\n        return this._mode;\n    }\n    /**\n     * Instantiates a new camera object.\n     * This should not be used directly but through the inherited cameras: ArcRotate, Free...\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras\n     * @param name Defines the name of the camera in the scene\n     * @param position Defines the position of the camera\n     * @param scene Defines the scene the camera belongs too\n     * @param setActiveOnSceneIfNoneActive Defines if the camera should be set as active after creation if no other camera have been defined in the scene\n     */\n    constructor(name, position, scene, setActiveOnSceneIfNoneActive = true) {\n        super(name, scene);\n        /** @internal */\n        this._position = Vector3.Zero();\n        this._upVector = Vector3.Up();\n        /**\n         * Define the current limit on the left side for an orthographic camera\n         * In scene unit\n         */\n        this._orthoLeft = null;\n        /**\n         * Define the current limit on the right side for an orthographic camera\n         * In scene unit\n         */\n        this._orthoRight = null;\n        /**\n         * Define the current limit on the bottom side for an orthographic camera\n         * In scene unit\n         */\n        this._orthoBottom = null;\n        /**\n         * Define the current limit on the top side for an orthographic camera\n         * In scene unit\n         */\n        this._orthoTop = null;\n        /**\n         * Field Of View is set in Radians. (default is 0.8)\n         */\n        this.fov = 0.8;\n        /**\n         * Projection plane tilt around the X axis (horizontal), set in Radians. (default is 0)\n         * Can be used to make vertical lines in world space actually vertical on the screen.\n         * See https://forum.babylonjs.com/t/add-vertical-shift-to-3ds-max-exporter-babylon-cameras/17480\n         */\n        this.projectionPlaneTilt = 0;\n        /**\n         * Define the minimum distance the camera can see from.\n         * This is important to note that the depth buffer are not infinite and the closer it starts\n         * the more your scene might encounter depth fighting issue.\n         */\n        this.minZ = 1;\n        /**\n         * Define the maximum distance the camera can see to.\n         * This is important to note that the depth buffer are not infinite and the further it end\n         * the more your scene might encounter depth fighting issue.\n         */\n        this.maxZ = 10000.0;\n        /**\n         * Define the default inertia of the camera.\n         * This helps giving a smooth feeling to the camera movement.\n         */\n        this.inertia = 0.9;\n        /**\n         * Define the mode of the camera (Camera.PERSPECTIVE_CAMERA or Camera.ORTHOGRAPHIC_CAMERA)\n         */\n        this._mode = Camera.PERSPECTIVE_CAMERA;\n        /**\n         * Define whether the camera is intermediate.\n         * This is useful to not present the output directly to the screen in case of rig without post process for instance\n         */\n        this.isIntermediate = false;\n        /**\n         * Define the viewport of the camera.\n         * This correspond to the portion of the screen the camera will render to in normalized 0 to 1 unit.\n         */\n        this.viewport = new Viewport(0, 0, 1.0, 1.0);\n        /**\n         * Restricts the camera to viewing objects with the same layerMask.\n         * A camera with a layerMask of 1 will render mesh.layerMask & camera.layerMask!== 0\n         */\n        this.layerMask = 0x0fffffff;\n        /**\n         * fovMode sets the camera frustum bounds to the viewport bounds. (default is FOVMODE_VERTICAL_FIXED)\n         */\n        this.fovMode = Camera.FOVMODE_VERTICAL_FIXED;\n        /**\n         * Rig mode of the camera.\n         * This is useful to create the camera with two \"eyes\" instead of one to create VR or stereoscopic scenes.\n         * This is normally controlled byt the camera themselves as internal use.\n         */\n        this.cameraRigMode = Camera.RIG_MODE_NONE;\n        /**\n         * Defines the list of custom render target which are rendered to and then used as the input to this camera's render. Eg. display another camera view on a TV in the main scene\n         * This is pretty helpful if you wish to make a camera render to a texture you could reuse somewhere\n         * else in the scene. (Eg. security camera)\n         *\n         * To change the final output target of the camera, camera.outputRenderTarget should be used instead (eg. webXR renders to a render target corresponding to an HMD)\n         */\n        this.customRenderTargets = new Array();\n        /**\n         * When set, the camera will render to this render target instead of the default canvas\n         *\n         * If the desire is to use the output of a camera as a texture in the scene consider using camera.customRenderTargets instead\n         */\n        this.outputRenderTarget = null;\n        /**\n         * Observable triggered when the camera view matrix has changed.\n         */\n        this.onViewMatrixChangedObservable = new Observable();\n        /**\n         * Observable triggered when the camera Projection matrix has changed.\n         */\n        this.onProjectionMatrixChangedObservable = new Observable();\n        /**\n         * Observable triggered when the inputs have been processed.\n         */\n        this.onAfterCheckInputsObservable = new Observable();\n        /**\n         * Observable triggered when reset has been called and applied to the camera.\n         */\n        this.onRestoreStateObservable = new Observable();\n        /**\n         * Is this camera a part of a rig system?\n         */\n        this.isRigCamera = false;\n        /** @internal */\n        this._rigCameras = new Array();\n        this._webvrViewMatrix = Matrix.Identity();\n        /** @internal */\n        this._skipRendering = false;\n        /** @internal */\n        this._projectionMatrix = new Matrix();\n        /** @internal */\n        this._postProcesses = new Array();\n        /** @internal */\n        this._activeMeshes = new SmartArray(256);\n        this._globalPosition = Vector3.Zero();\n        /** @internal */\n        this._computedViewMatrix = Matrix.Identity();\n        this._doNotComputeProjectionMatrix = false;\n        this._transformMatrix = Matrix.Zero();\n        this._refreshFrustumPlanes = true;\n        this._absoluteRotation = Quaternion.Identity();\n        /** @internal */\n        this._isCamera = true;\n        /** @internal */\n        this._isLeftCamera = false;\n        /** @internal */\n        this._isRightCamera = false;\n        this.getScene().addCamera(this);\n        if (setActiveOnSceneIfNoneActive && !this.getScene().activeCamera) {\n            this.getScene().activeCamera = this;\n        }\n        this.position = position;\n        this.renderPassId = this.getScene().getEngine().createRenderPassId(`Camera ${name}`);\n    }\n    /**\n     * Store current camera state (fov, position, etc..)\n     * @returns the camera\n     */\n    storeState() {\n        this._stateStored = true;\n        this._storedFov = this.fov;\n        return this;\n    }\n    /**\n     * Restores the camera state values if it has been stored. You must call storeState() first\n     */\n    _restoreStateValues() {\n        if (!this._stateStored) {\n            return false;\n        }\n        this.fov = this._storedFov;\n        return true;\n    }\n    /**\n     * Restored camera state. You must call storeState() first.\n     * @returns true if restored and false otherwise\n     */\n    restoreState() {\n        if (this._restoreStateValues()) {\n            this.onRestoreStateObservable.notifyObservers(this);\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Gets the class name of the camera.\n     * @returns the class name\n     */\n    getClassName() {\n        return \"Camera\";\n    }\n    /**\n     * Gets a string representation of the camera useful for debug purpose.\n     * @param fullDetails Defines that a more verbose level of logging is required\n     * @returns the string representation\n     */\n    toString(fullDetails) {\n        let ret = \"Name: \" + this.name;\n        ret += \", type: \" + this.getClassName();\n        if (this.animations) {\n            for (let i = 0; i < this.animations.length; i++) {\n                ret += \", animation[0]: \" + this.animations[i].toString(fullDetails);\n            }\n        }\n        return ret;\n    }\n    /**\n     * Automatically tilts the projection plane, using `projectionPlaneTilt`, to correct the perspective effect on vertical lines.\n     */\n    applyVerticalCorrection() {\n        const rot = this.absoluteRotation.toEulerAngles();\n        this.projectionPlaneTilt = this._scene.useRightHandedSystem ? -rot.x : rot.x;\n    }\n    /**\n     * Gets the current world space position of the camera.\n     */\n    get globalPosition() {\n        return this._globalPosition;\n    }\n    /**\n     * Gets the list of active meshes this frame (meshes no culled or excluded by lod s in the frame)\n     * @returns the active meshe list\n     */\n    getActiveMeshes() {\n        return this._activeMeshes;\n    }\n    /**\n     * Check whether a mesh is part of the current active mesh list of the camera\n     * @param mesh Defines the mesh to check\n     * @returns true if active, false otherwise\n     */\n    isActiveMesh(mesh) {\n        return this._activeMeshes.indexOf(mesh) !== -1;\n    }\n    /**\n     * Is this camera ready to be used/rendered\n     * @param completeCheck defines if a complete check (including post processes) has to be done (false by default)\n     * @returns true if the camera is ready\n     */\n    isReady(completeCheck = false) {\n        if (completeCheck) {\n            for (const pp of this._postProcesses) {\n                if (pp && !pp.isReady()) {\n                    return false;\n                }\n            }\n        }\n        return super.isReady(completeCheck);\n    }\n    /** @internal */\n    _initCache() {\n        super._initCache();\n        this._cache.position = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\n        this._cache.upVector = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\n        this._cache.mode = undefined;\n        this._cache.minZ = undefined;\n        this._cache.maxZ = undefined;\n        this._cache.fov = undefined;\n        this._cache.fovMode = undefined;\n        this._cache.aspectRatio = undefined;\n        this._cache.orthoLeft = undefined;\n        this._cache.orthoRight = undefined;\n        this._cache.orthoBottom = undefined;\n        this._cache.orthoTop = undefined;\n        this._cache.renderWidth = undefined;\n        this._cache.renderHeight = undefined;\n    }\n    /**\n     * @internal\n     */\n    _updateCache(ignoreParentClass) {\n        if (!ignoreParentClass) {\n            super._updateCache();\n        }\n        this._cache.position.copyFrom(this.position);\n        this._cache.upVector.copyFrom(this.upVector);\n    }\n    /** @internal */\n    _isSynchronized() {\n        return this._isSynchronizedViewMatrix() && this._isSynchronizedProjectionMatrix();\n    }\n    /** @internal */\n    _isSynchronizedViewMatrix() {\n        if (!super._isSynchronized()) {\n            return false;\n        }\n        return this._cache.position.equals(this.position) && this._cache.upVector.equals(this.upVector) && this.isSynchronizedWithParent();\n    }\n    /** @internal */\n    _isSynchronizedProjectionMatrix() {\n        let check = this._cache.mode === this.mode && this._cache.minZ === this.minZ && this._cache.maxZ === this.maxZ;\n        if (!check) {\n            return false;\n        }\n        const engine = this.getEngine();\n        if (this.mode === Camera.PERSPECTIVE_CAMERA) {\n            check =\n                this._cache.fov === this.fov &&\n                    this._cache.fovMode === this.fovMode &&\n                    this._cache.aspectRatio === engine.getAspectRatio(this) &&\n                    this._cache.projectionPlaneTilt === this.projectionPlaneTilt;\n        }\n        else {\n            check =\n                this._cache.orthoLeft === this.orthoLeft &&\n                    this._cache.orthoRight === this.orthoRight &&\n                    this._cache.orthoBottom === this.orthoBottom &&\n                    this._cache.orthoTop === this.orthoTop &&\n                    this._cache.renderWidth === engine.getRenderWidth() &&\n                    this._cache.renderHeight === engine.getRenderHeight();\n        }\n        return check;\n    }\n    /**\n     * Attach the input controls to a specific dom element to get the input from.\n     * This function is here because typescript removes the typing of the last function.\n     * @param _ignored defines an ignored parameter kept for backward compatibility.\n     * @param _noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\n     */\n    attachControl(_ignored, _noPreventDefault) { }\n    /**\n     * Detach the current controls from the specified dom element.\n     * This function is here because typescript removes the typing of the last function.\n     * @param _ignored defines an ignored parameter kept for backward compatibility.\n     */\n    detachControl(_ignored) { }\n    /**\n     * Update the camera state according to the different inputs gathered during the frame.\n     */\n    update() {\n        this._checkInputs();\n        if (this.cameraRigMode !== Camera.RIG_MODE_NONE) {\n            this._updateRigCameras();\n        }\n        // Attempt to update the camera's view and projection matrices.\n        // This call is being made because these matrices are no longer being updated\n        // as a part of the picking ray process (in addition to scene.render).\n        this.getViewMatrix();\n        this.getProjectionMatrix();\n    }\n    /** @internal */\n    _checkInputs() {\n        this.onAfterCheckInputsObservable.notifyObservers(this);\n    }\n    /** @internal */\n    get rigCameras() {\n        return this._rigCameras;\n    }\n    /**\n     * Gets the post process used by the rig cameras\n     */\n    get rigPostProcess() {\n        return this._rigPostProcess;\n    }\n    /**\n     * Internal, gets the first post process.\n     * @returns the first post process to be run on this camera.\n     */\n    _getFirstPostProcess() {\n        for (let ppIndex = 0; ppIndex < this._postProcesses.length; ppIndex++) {\n            if (this._postProcesses[ppIndex] !== null) {\n                return this._postProcesses[ppIndex];\n            }\n        }\n        return null;\n    }\n    _cascadePostProcessesToRigCams() {\n        // invalidate framebuffer\n        const firstPostProcess = this._getFirstPostProcess();\n        if (firstPostProcess) {\n            firstPostProcess.markTextureDirty();\n        }\n        // glue the rigPostProcess to the end of the user postprocesses & assign to each sub-camera\n        for (let i = 0, len = this._rigCameras.length; i < len; i++) {\n            const cam = this._rigCameras[i];\n            const rigPostProcess = cam._rigPostProcess;\n            // for VR rig, there does not have to be a post process\n            if (rigPostProcess) {\n                const isPass = rigPostProcess.getEffectName() === \"pass\";\n                if (isPass) {\n                    // any rig which has a PassPostProcess for rig[0], cannot be isIntermediate when there are also user postProcesses\n                    cam.isIntermediate = this._postProcesses.length === 0;\n                }\n                cam._postProcesses = this._postProcesses.slice(0).concat(rigPostProcess);\n                rigPostProcess.markTextureDirty();\n            }\n            else {\n                cam._postProcesses = this._postProcesses.slice(0);\n            }\n        }\n    }\n    /**\n     * Attach a post process to the camera.\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/postProcesses/usePostProcesses#attach-postprocess\n     * @param postProcess The post process to attach to the camera\n     * @param insertAt The position of the post process in case several of them are in use in the scene\n     * @returns the position the post process has been inserted at\n     */\n    attachPostProcess(postProcess, insertAt = null) {\n        if (!postProcess.isReusable() && this._postProcesses.indexOf(postProcess) > -1) {\n            Logger.Error(\"You're trying to reuse a post process not defined as reusable.\");\n            return 0;\n        }\n        if (insertAt == null || insertAt < 0) {\n            this._postProcesses.push(postProcess);\n        }\n        else if (this._postProcesses[insertAt] === null) {\n            this._postProcesses[insertAt] = postProcess;\n        }\n        else {\n            this._postProcesses.splice(insertAt, 0, postProcess);\n        }\n        this._cascadePostProcessesToRigCams(); // also ensures framebuffer invalidated\n        // Update prePass\n        if (this._scene.prePassRenderer) {\n            this._scene.prePassRenderer.markAsDirty();\n        }\n        return this._postProcesses.indexOf(postProcess);\n    }\n    /**\n     * Detach a post process to the camera.\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/postProcesses/usePostProcesses#attach-postprocess\n     * @param postProcess The post process to detach from the camera\n     */\n    detachPostProcess(postProcess) {\n        const idx = this._postProcesses.indexOf(postProcess);\n        if (idx !== -1) {\n            this._postProcesses[idx] = null;\n        }\n        // Update prePass\n        if (this._scene.prePassRenderer) {\n            this._scene.prePassRenderer.markAsDirty();\n        }\n        this._cascadePostProcessesToRigCams(); // also ensures framebuffer invalidated\n    }\n    /**\n     * Gets the current world matrix of the camera\n     */\n    getWorldMatrix() {\n        if (this._isSynchronizedViewMatrix()) {\n            return this._worldMatrix;\n        }\n        // Getting the the view matrix will also compute the world matrix.\n        this.getViewMatrix();\n        return this._worldMatrix;\n    }\n    /** @internal */\n    _getViewMatrix() {\n        return Matrix.Identity();\n    }\n    /**\n     * Gets the current view matrix of the camera.\n     * @param force forces the camera to recompute the matrix without looking at the cached state\n     * @returns the view matrix\n     */\n    getViewMatrix(force) {\n        if (!force && this._isSynchronizedViewMatrix()) {\n            return this._computedViewMatrix;\n        }\n        this.updateCache();\n        this._computedViewMatrix = this._getViewMatrix();\n        this._currentRenderId = this.getScene().getRenderId();\n        this._childUpdateId++;\n        this._refreshFrustumPlanes = true;\n        if (this._cameraRigParams && this._cameraRigParams.vrPreViewMatrix) {\n            this._computedViewMatrix.multiplyToRef(this._cameraRigParams.vrPreViewMatrix, this._computedViewMatrix);\n        }\n        // Notify parent camera if rig camera is changed\n        if (this.parent && this.parent.onViewMatrixChangedObservable) {\n            this.parent.onViewMatrixChangedObservable.notifyObservers(this.parent);\n        }\n        this.onViewMatrixChangedObservable.notifyObservers(this);\n        this._computedViewMatrix.invertToRef(this._worldMatrix);\n        return this._computedViewMatrix;\n    }\n    /**\n     * Freeze the projection matrix.\n     * It will prevent the cache check of the camera projection compute and can speed up perf\n     * if no parameter of the camera are meant to change\n     * @param projection Defines manually a projection if necessary\n     */\n    freezeProjectionMatrix(projection) {\n        this._doNotComputeProjectionMatrix = true;\n        if (projection !== undefined) {\n            this._projectionMatrix = projection;\n        }\n    }\n    /**\n     * Unfreeze the projection matrix if it has previously been freezed by freezeProjectionMatrix.\n     */\n    unfreezeProjectionMatrix() {\n        this._doNotComputeProjectionMatrix = false;\n    }\n    /**\n     * Gets the current projection matrix of the camera.\n     * @param force forces the camera to recompute the matrix without looking at the cached state\n     * @returns the projection matrix\n     */\n    getProjectionMatrix(force) {\n        var _a, _b, _c, _d, _e, _f, _g, _h;\n        if (this._doNotComputeProjectionMatrix || (!force && this._isSynchronizedProjectionMatrix())) {\n            return this._projectionMatrix;\n        }\n        // Cache\n        this._cache.mode = this.mode;\n        this._cache.minZ = this.minZ;\n        this._cache.maxZ = this.maxZ;\n        // Matrix\n        this._refreshFrustumPlanes = true;\n        const engine = this.getEngine();\n        const scene = this.getScene();\n        const reverseDepth = engine.useReverseDepthBuffer;\n        if (this.mode === Camera.PERSPECTIVE_CAMERA) {\n            this._cache.fov = this.fov;\n            this._cache.fovMode = this.fovMode;\n            this._cache.aspectRatio = engine.getAspectRatio(this);\n            this._cache.projectionPlaneTilt = this.projectionPlaneTilt;\n            if (this.minZ <= 0) {\n                this.minZ = 0.1;\n            }\n            let getProjectionMatrix;\n            if (scene.useRightHandedSystem) {\n                getProjectionMatrix = Matrix.PerspectiveFovRHToRef;\n            }\n            else {\n                getProjectionMatrix = Matrix.PerspectiveFovLHToRef;\n            }\n            getProjectionMatrix(this.fov, engine.getAspectRatio(this), reverseDepth ? this.maxZ : this.minZ, reverseDepth ? this.minZ : this.maxZ, this._projectionMatrix, this.fovMode === Camera.FOVMODE_VERTICAL_FIXED, engine.isNDCHalfZRange, this.projectionPlaneTilt, reverseDepth);\n        }\n        else {\n            const halfWidth = engine.getRenderWidth() / 2.0;\n            const halfHeight = engine.getRenderHeight() / 2.0;\n            if (scene.useRightHandedSystem) {\n                Matrix.OrthoOffCenterRHToRef((_a = this.orthoLeft) !== null && _a !== void 0 ? _a : -halfWidth, (_b = this.orthoRight) !== null && _b !== void 0 ? _b : halfWidth, (_c = this.orthoBottom) !== null && _c !== void 0 ? _c : -halfHeight, (_d = this.orthoTop) !== null && _d !== void 0 ? _d : halfHeight, reverseDepth ? this.maxZ : this.minZ, reverseDepth ? this.minZ : this.maxZ, this._projectionMatrix, engine.isNDCHalfZRange);\n            }\n            else {\n                Matrix.OrthoOffCenterLHToRef((_e = this.orthoLeft) !== null && _e !== void 0 ? _e : -halfWidth, (_f = this.orthoRight) !== null && _f !== void 0 ? _f : halfWidth, (_g = this.orthoBottom) !== null && _g !== void 0 ? _g : -halfHeight, (_h = this.orthoTop) !== null && _h !== void 0 ? _h : halfHeight, reverseDepth ? this.maxZ : this.minZ, reverseDepth ? this.minZ : this.maxZ, this._projectionMatrix, engine.isNDCHalfZRange);\n            }\n            this._cache.orthoLeft = this.orthoLeft;\n            this._cache.orthoRight = this.orthoRight;\n            this._cache.orthoBottom = this.orthoBottom;\n            this._cache.orthoTop = this.orthoTop;\n            this._cache.renderWidth = engine.getRenderWidth();\n            this._cache.renderHeight = engine.getRenderHeight();\n        }\n        this.onProjectionMatrixChangedObservable.notifyObservers(this);\n        return this._projectionMatrix;\n    }\n    /**\n     * Gets the transformation matrix (ie. the multiplication of view by projection matrices)\n     * @returns a Matrix\n     */\n    getTransformationMatrix() {\n        this._computedViewMatrix.multiplyToRef(this._projectionMatrix, this._transformMatrix);\n        return this._transformMatrix;\n    }\n    _updateFrustumPlanes() {\n        if (!this._refreshFrustumPlanes) {\n            return;\n        }\n        this.getTransformationMatrix();\n        if (!this._frustumPlanes) {\n            this._frustumPlanes = Frustum.GetPlanes(this._transformMatrix);\n        }\n        else {\n            Frustum.GetPlanesToRef(this._transformMatrix, this._frustumPlanes);\n        }\n        this._refreshFrustumPlanes = false;\n    }\n    /**\n     * Checks if a cullable object (mesh...) is in the camera frustum\n     * This checks the bounding box center. See isCompletelyInFrustum for a full bounding check\n     * @param target The object to check\n     * @param checkRigCameras If the rig cameras should be checked (eg. with webVR camera both eyes should be checked) (Default: false)\n     * @returns true if the object is in frustum otherwise false\n     */\n    isInFrustum(target, checkRigCameras = false) {\n        this._updateFrustumPlanes();\n        if (checkRigCameras && this.rigCameras.length > 0) {\n            let result = false;\n            this.rigCameras.forEach((cam) => {\n                cam._updateFrustumPlanes();\n                result = result || target.isInFrustum(cam._frustumPlanes);\n            });\n            return result;\n        }\n        else {\n            return target.isInFrustum(this._frustumPlanes);\n        }\n    }\n    /**\n     * Checks if a cullable object (mesh...) is in the camera frustum\n     * Unlike isInFrustum this checks the full bounding box\n     * @param target The object to check\n     * @returns true if the object is in frustum otherwise false\n     */\n    isCompletelyInFrustum(target) {\n        this._updateFrustumPlanes();\n        return target.isCompletelyInFrustum(this._frustumPlanes);\n    }\n    /**\n     * Gets a ray in the forward direction from the camera.\n     * @param length Defines the length of the ray to create\n     * @param transform Defines the transform to apply to the ray, by default the world matrix is used to create a workd space ray\n     * @param origin Defines the start point of the ray which defaults to the camera position\n     * @returns the forward ray\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    getForwardRay(length = 100, transform, origin) {\n        throw _WarnImport(\"Ray\");\n    }\n    /**\n     * Gets a ray in the forward direction from the camera.\n     * @param refRay the ray to (re)use when setting the values\n     * @param length Defines the length of the ray to create\n     * @param transform Defines the transform to apply to the ray, by default the world matrx is used to create a workd space ray\n     * @param origin Defines the start point of the ray which defaults to the camera position\n     * @returns the forward ray\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    getForwardRayToRef(refRay, length = 100, transform, origin) {\n        throw _WarnImport(\"Ray\");\n    }\n    /**\n     * Releases resources associated with this node.\n     * @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)\n     * @param disposeMaterialAndTextures Set to true to also dispose referenced materials and textures (false by default)\n     */\n    dispose(doNotRecurse, disposeMaterialAndTextures = false) {\n        // Observables\n        this.onViewMatrixChangedObservable.clear();\n        this.onProjectionMatrixChangedObservable.clear();\n        this.onAfterCheckInputsObservable.clear();\n        this.onRestoreStateObservable.clear();\n        // Inputs\n        if (this.inputs) {\n            this.inputs.clear();\n        }\n        // Animations\n        this.getScene().stopAnimation(this);\n        // Remove from scene\n        this.getScene().removeCamera(this);\n        while (this._rigCameras.length > 0) {\n            const camera = this._rigCameras.pop();\n            if (camera) {\n                camera.dispose();\n            }\n        }\n        if (this._parentContainer) {\n            const index = this._parentContainer.cameras.indexOf(this);\n            if (index > -1) {\n                this._parentContainer.cameras.splice(index, 1);\n            }\n            this._parentContainer = null;\n        }\n        // Postprocesses\n        if (this._rigPostProcess) {\n            this._rigPostProcess.dispose(this);\n            this._rigPostProcess = null;\n            this._postProcesses.length = 0;\n        }\n        else if (this.cameraRigMode !== Camera.RIG_MODE_NONE) {\n            this._rigPostProcess = null;\n            this._postProcesses.length = 0;\n        }\n        else {\n            let i = this._postProcesses.length;\n            while (--i >= 0) {\n                const postProcess = this._postProcesses[i];\n                if (postProcess) {\n                    postProcess.dispose(this);\n                }\n            }\n        }\n        // Render targets\n        let i = this.customRenderTargets.length;\n        while (--i >= 0) {\n            this.customRenderTargets[i].dispose();\n        }\n        this.customRenderTargets.length = 0;\n        // Active Meshes\n        this._activeMeshes.dispose();\n        this.getScene().getEngine().releaseRenderPassId(this.renderPassId);\n        super.dispose(doNotRecurse, disposeMaterialAndTextures);\n    }\n    /**\n     * Gets the left camera of a rig setup in case of Rigged Camera\n     */\n    get isLeftCamera() {\n        return this._isLeftCamera;\n    }\n    /**\n     * Gets the right camera of a rig setup in case of Rigged Camera\n     */\n    get isRightCamera() {\n        return this._isRightCamera;\n    }\n    /**\n     * Gets the left camera of a rig setup in case of Rigged Camera\n     */\n    get leftCamera() {\n        if (this._rigCameras.length < 1) {\n            return null;\n        }\n        return this._rigCameras[0];\n    }\n    /**\n     * Gets the right camera of a rig setup in case of Rigged Camera\n     */\n    get rightCamera() {\n        if (this._rigCameras.length < 2) {\n            return null;\n        }\n        return this._rigCameras[1];\n    }\n    /**\n     * Gets the left camera target of a rig setup in case of Rigged Camera\n     * @returns the target position\n     */\n    getLeftTarget() {\n        if (this._rigCameras.length < 1) {\n            return null;\n        }\n        return this._rigCameras[0].getTarget();\n    }\n    /**\n     * Gets the right camera target of a rig setup in case of Rigged Camera\n     * @returns the target position\n     */\n    getRightTarget() {\n        if (this._rigCameras.length < 2) {\n            return null;\n        }\n        return this._rigCameras[1].getTarget();\n    }\n    /**\n     * @internal\n     */\n    setCameraRigMode(mode, rigParams) {\n        if (this.cameraRigMode === mode) {\n            return;\n        }\n        while (this._rigCameras.length > 0) {\n            const camera = this._rigCameras.pop();\n            if (camera) {\n                camera.dispose();\n            }\n        }\n        this.cameraRigMode = mode;\n        this._cameraRigParams = {};\n        //we have to implement stereo camera calcultating left and right viewpoints from interaxialDistance and target,\n        //not from a given angle as it is now, but until that complete code rewriting provisional stereoHalfAngle value is introduced\n        this._cameraRigParams.interaxialDistance = rigParams.interaxialDistance || 0.0637;\n        this._cameraRigParams.stereoHalfAngle = Tools.ToRadians(this._cameraRigParams.interaxialDistance / 0.0637);\n        // create the rig cameras, unless none\n        if (this.cameraRigMode !== Camera.RIG_MODE_NONE) {\n            const leftCamera = this.createRigCamera(this.name + \"_L\", 0);\n            if (leftCamera) {\n                leftCamera._isLeftCamera = true;\n            }\n            const rightCamera = this.createRigCamera(this.name + \"_R\", 1);\n            if (rightCamera) {\n                rightCamera._isRightCamera = true;\n            }\n            if (leftCamera && rightCamera) {\n                this._rigCameras.push(leftCamera);\n                this._rigCameras.push(rightCamera);\n            }\n        }\n        this._setRigMode(rigParams);\n        this._cascadePostProcessesToRigCams();\n        this.update();\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _setRigMode(rigParams) {\n        // no-op\n    }\n    /** @internal */\n    _getVRProjectionMatrix() {\n        Matrix.PerspectiveFovLHToRef(this._cameraRigParams.vrMetrics.aspectRatioFov, this._cameraRigParams.vrMetrics.aspectRatio, this.minZ, this.maxZ, this._cameraRigParams.vrWorkMatrix, true, this.getEngine().isNDCHalfZRange);\n        this._cameraRigParams.vrWorkMatrix.multiplyToRef(this._cameraRigParams.vrHMatrix, this._projectionMatrix);\n        return this._projectionMatrix;\n    }\n    _updateCameraRotationMatrix() {\n        //Here for WebVR\n    }\n    _updateWebVRCameraRotationMatrix() {\n        //Here for WebVR\n    }\n    /**\n     * This function MUST be overwritten by the different WebVR cameras available.\n     * The context in which it is running is the RIG camera. So 'this' is the TargetCamera, left or right.\n     * @internal\n     */\n    _getWebVRProjectionMatrix() {\n        return Matrix.Identity();\n    }\n    /**\n     * This function MUST be overwritten by the different WebVR cameras available.\n     * The context in which it is running is the RIG camera. So 'this' is the TargetCamera, left or right.\n     * @internal\n     */\n    _getWebVRViewMatrix() {\n        return Matrix.Identity();\n    }\n    /**\n     * @internal\n     */\n    setCameraRigParameter(name, value) {\n        if (!this._cameraRigParams) {\n            this._cameraRigParams = {};\n        }\n        this._cameraRigParams[name] = value;\n        //provisionnally:\n        if (name === \"interaxialDistance\") {\n            this._cameraRigParams.stereoHalfAngle = Tools.ToRadians(value / 0.0637);\n        }\n    }\n    /**\n     * needs to be overridden by children so sub has required properties to be copied\n     * @internal\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    createRigCamera(name, cameraIndex) {\n        return null;\n    }\n    /**\n     * May need to be overridden by children\n     * @internal\n     */\n    _updateRigCameras() {\n        for (let i = 0; i < this._rigCameras.length; i++) {\n            this._rigCameras[i].minZ = this.minZ;\n            this._rigCameras[i].maxZ = this.maxZ;\n            this._rigCameras[i].fov = this.fov;\n            this._rigCameras[i].upVector.copyFrom(this.upVector);\n        }\n        // only update viewport when ANAGLYPH\n        if (this.cameraRigMode === Camera.RIG_MODE_STEREOSCOPIC_ANAGLYPH) {\n            this._rigCameras[0].viewport = this._rigCameras[1].viewport = this.viewport;\n        }\n    }\n    /** @internal */\n    _setupInputs() { }\n    /**\n     * Serialiaze the camera setup to a json representation\n     * @returns the JSON representation\n     */\n    serialize() {\n        const serializationObject = SerializationHelper.Serialize(this);\n        serializationObject.uniqueId = this.uniqueId;\n        // Type\n        serializationObject.type = this.getClassName();\n        // Parent\n        if (this.parent) {\n            this.parent._serializeAsParent(serializationObject);\n        }\n        if (this.inputs) {\n            this.inputs.serialize(serializationObject);\n        }\n        // Animations\n        SerializationHelper.AppendSerializedAnimations(this, serializationObject);\n        serializationObject.ranges = this.serializeAnimationRanges();\n        serializationObject.isEnabled = this.isEnabled();\n        return serializationObject;\n    }\n    /**\n     * Clones the current camera.\n     * @param name The cloned camera name\n     * @param newParent The cloned camera's new parent (none by default)\n     * @returns the cloned camera\n     */\n    clone(name, newParent = null) {\n        const camera = SerializationHelper.Clone(Camera.GetConstructorFromName(this.getClassName(), name, this.getScene(), this.interaxialDistance, this.isStereoscopicSideBySide), this);\n        camera.name = name;\n        camera.parent = newParent;\n        this.onClonedObservable.notifyObservers(camera);\n        return camera;\n    }\n    /**\n     * Gets the direction of the camera relative to a given local axis.\n     * @param localAxis Defines the reference axis to provide a relative direction.\n     * @returns the direction\n     */\n    getDirection(localAxis) {\n        const result = Vector3.Zero();\n        this.getDirectionToRef(localAxis, result);\n        return result;\n    }\n    /**\n     * Returns the current camera absolute rotation\n     */\n    get absoluteRotation() {\n        this.getWorldMatrix().decompose(undefined, this._absoluteRotation);\n        return this._absoluteRotation;\n    }\n    /**\n     * Gets the direction of the camera relative to a given local axis into a passed vector.\n     * @param localAxis Defines the reference axis to provide a relative direction.\n     * @param result Defines the vector to store the result in\n     */\n    getDirectionToRef(localAxis, result) {\n        Vector3.TransformNormalToRef(localAxis, this.getWorldMatrix(), result);\n    }\n    /**\n     * Gets a camera constructor for a given camera type\n     * @param type The type of the camera to construct (should be equal to one of the camera class name)\n     * @param name The name of the camera the result will be able to instantiate\n     * @param scene The scene the result will construct the camera in\n     * @param interaxial_distance In case of stereoscopic setup, the distance between both eyes\n     * @param isStereoscopicSideBySide In case of stereoscopic setup, should the sereo be side b side\n     * @returns a factory method to construct the camera\n     */\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    static GetConstructorFromName(type, name, scene, interaxial_distance = 0, isStereoscopicSideBySide = true) {\n        const constructorFunc = Node.Construct(type, name, scene, {\n            // eslint-disable-next-line @typescript-eslint/naming-convention\n            interaxial_distance: interaxial_distance,\n            isStereoscopicSideBySide: isStereoscopicSideBySide,\n        });\n        if (constructorFunc) {\n            return constructorFunc;\n        }\n        // Default to universal camera\n        return () => Camera._CreateDefaultParsedCamera(name, scene);\n    }\n    /**\n     * Compute the world  matrix of the camera.\n     * @returns the camera world matrix\n     */\n    computeWorldMatrix() {\n        return this.getWorldMatrix();\n    }\n    /**\n     * Parse a JSON and creates the camera from the parsed information\n     * @param parsedCamera The JSON to parse\n     * @param scene The scene to instantiate the camera in\n     * @returns the newly constructed camera\n     */\n    static Parse(parsedCamera, scene) {\n        const type = parsedCamera.type;\n        const construct = Camera.GetConstructorFromName(type, parsedCamera.name, scene, parsedCamera.interaxial_distance, parsedCamera.isStereoscopicSideBySide);\n        const camera = SerializationHelper.Parse(construct, parsedCamera, scene);\n        // Parent\n        if (parsedCamera.parentId !== undefined) {\n            camera._waitingParentId = parsedCamera.parentId;\n        }\n        // Parent instance index\n        if (parsedCamera.parentInstanceIndex !== undefined) {\n            camera._waitingParentInstanceIndex = parsedCamera.parentInstanceIndex;\n        }\n        //If camera has an input manager, let it parse inputs settings\n        if (camera.inputs) {\n            camera.inputs.parse(parsedCamera);\n            camera._setupInputs();\n        }\n        if (parsedCamera.upVector) {\n            camera.upVector = Vector3.FromArray(parsedCamera.upVector); // need to force the upVector\n        }\n        if (camera.setPosition) {\n            // need to force position\n            camera.position.copyFromFloats(0, 0, 0);\n            camera.setPosition(Vector3.FromArray(parsedCamera.position));\n        }\n        // Target\n        if (parsedCamera.target) {\n            if (camera.setTarget) {\n                camera.setTarget(Vector3.FromArray(parsedCamera.target));\n            }\n        }\n        // Apply 3d rig, when found\n        if (parsedCamera.cameraRigMode) {\n            const rigParams = parsedCamera.interaxial_distance ? { interaxialDistance: parsedCamera.interaxial_distance } : {};\n            camera.setCameraRigMode(parsedCamera.cameraRigMode, rigParams);\n        }\n        // Animations\n        if (parsedCamera.animations) {\n            for (let animationIndex = 0; animationIndex < parsedCamera.animations.length; animationIndex++) {\n                const parsedAnimation = parsedCamera.animations[animationIndex];\n                const internalClass = GetClass(\"BABYLON.Animation\");\n                if (internalClass) {\n                    camera.animations.push(internalClass.Parse(parsedAnimation));\n                }\n            }\n            Node.ParseAnimationRanges(camera, parsedCamera, scene);\n        }\n        if (parsedCamera.autoAnimate) {\n            scene.beginAnimation(camera, parsedCamera.autoAnimateFrom, parsedCamera.autoAnimateTo, parsedCamera.autoAnimateLoop, parsedCamera.autoAnimateSpeed || 1.0);\n        }\n        // Check if isEnabled is defined to be back compatible with prior serialized versions.\n        if (parsedCamera.isEnabled !== undefined) {\n            camera.setEnabled(parsedCamera.isEnabled);\n        }\n        return camera;\n    }\n}\n/**\n * @internal\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nCamera._CreateDefaultParsedCamera = (name, scene) => {\n    throw _WarnImport(\"UniversalCamera\");\n};\n/**\n * This is the default projection mode used by the cameras.\n * It helps recreating a feeling of perspective and better appreciate depth.\n * This is the best way to simulate real life cameras.\n */\nCamera.PERSPECTIVE_CAMERA = 0;\n/**\n * This helps creating camera with an orthographic mode.\n * Orthographic is commonly used in engineering as a means to produce object specifications that communicate dimensions unambiguously, each line of 1 unit length (cm, meter..whatever) will appear to have the same length everywhere on the drawing. This allows the drafter to dimension only a subset of lines and let the reader know that other lines of that length on the drawing are also that length in reality. Every parallel line in the drawing is also parallel in the object.\n */\nCamera.ORTHOGRAPHIC_CAMERA = 1;\n/**\n * This is the default FOV mode for perspective cameras.\n * This setting aligns the upper and lower bounds of the viewport to the upper and lower bounds of the camera frustum.\n */\nCamera.FOVMODE_VERTICAL_FIXED = 0;\n/**\n * This setting aligns the left and right bounds of the viewport to the left and right bounds of the camera frustum.\n */\nCamera.FOVMODE_HORIZONTAL_FIXED = 1;\n/**\n * This specifies there is no need for a camera rig.\n * Basically only one eye is rendered corresponding to the camera.\n */\nCamera.RIG_MODE_NONE = 0;\n/**\n * Simulates a camera Rig with one blue eye and one red eye.\n * This can be use with 3d blue and red glasses.\n */\nCamera.RIG_MODE_STEREOSCOPIC_ANAGLYPH = 10;\n/**\n * Defines that both eyes of the camera will be rendered side by side with a parallel target.\n */\nCamera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL = 11;\n/**\n * Defines that both eyes of the camera will be rendered side by side with a none parallel target.\n */\nCamera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED = 12;\n/**\n * Defines that both eyes of the camera will be rendered over under each other.\n */\nCamera.RIG_MODE_STEREOSCOPIC_OVERUNDER = 13;\n/**\n * Defines that both eyes of the camera will be rendered on successive lines interlaced for passive 3d monitors.\n */\nCamera.RIG_MODE_STEREOSCOPIC_INTERLACED = 14;\n/**\n * Defines that both eyes of the camera should be renderered in a VR mode (carbox).\n */\nCamera.RIG_MODE_VR = 20;\n/**\n * Defines that both eyes of the camera should be renderered in a VR mode (webVR).\n */\nCamera.RIG_MODE_WEBVR = 21;\n/**\n * Custom rig mode allowing rig cameras to be populated manually with any number of cameras\n */\nCamera.RIG_MODE_CUSTOM = 22;\n/**\n * Defines if by default attaching controls should prevent the default javascript event to continue.\n */\nCamera.ForceAttachControlToAlwaysPreventDefault = false;\n__decorate([\n    serializeAsVector3(\"position\")\n], Camera.prototype, \"_position\", void 0);\n__decorate([\n    serializeAsVector3(\"upVector\")\n], Camera.prototype, \"_upVector\", void 0);\n__decorate([\n    serialize()\n], Camera.prototype, \"orthoLeft\", null);\n__decorate([\n    serialize()\n], Camera.prototype, \"orthoRight\", null);\n__decorate([\n    serialize()\n], Camera.prototype, \"orthoBottom\", null);\n__decorate([\n    serialize()\n], Camera.prototype, \"orthoTop\", null);\n__decorate([\n    serialize()\n], Camera.prototype, \"fov\", void 0);\n__decorate([\n    serialize()\n], Camera.prototype, \"projectionPlaneTilt\", void 0);\n__decorate([\n    serialize()\n], Camera.prototype, \"minZ\", void 0);\n__decorate([\n    serialize()\n], Camera.prototype, \"maxZ\", void 0);\n__decorate([\n    serialize()\n], Camera.prototype, \"inertia\", void 0);\n__decorate([\n    serialize()\n], Camera.prototype, \"mode\", null);\n__decorate([\n    serialize()\n], Camera.prototype, \"layerMask\", void 0);\n__decorate([\n    serialize()\n], Camera.prototype, \"fovMode\", void 0);\n__decorate([\n    serialize()\n], Camera.prototype, \"cameraRigMode\", void 0);\n__decorate([\n    serialize()\n], Camera.prototype, \"interaxialDistance\", void 0);\n__decorate([\n    serialize()\n], Camera.prototype, \"isStereoscopicSideBySide\", void 0);\n//# sourceMappingURL=camera.js.map","import { Logger } from \"../Misc/logger.js\";\nimport { SerializationHelper } from \"../Misc/decorators.js\";\nimport { Camera } from \"./camera.js\";\n/**\n * @ignore\n * This is a list of all the different input types that are available in the application.\n * Fo instance: ArcRotateCameraGamepadInput...\n */\n// eslint-disable-next-line no-var, @typescript-eslint/naming-convention\nexport var CameraInputTypes = {};\n/**\n * This represents the input manager used within a camera.\n * It helps dealing with all the different kind of input attached to a camera.\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\n */\nexport class CameraInputsManager {\n    /**\n     * Instantiate a new Camera Input Manager.\n     * @param camera Defines the camera the input manager belongs to\n     */\n    constructor(camera) {\n        /**\n         * Defines the dom element the camera is collecting inputs from.\n         * This is null if the controls have not been attached.\n         */\n        this.attachedToElement = false;\n        this.attached = {};\n        this.camera = camera;\n        this.checkInputs = () => { };\n    }\n    /**\n     * Add an input method to a camera\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\n     * @param input Camera input method\n     */\n    add(input) {\n        const type = input.getSimpleName();\n        if (this.attached[type]) {\n            Logger.Warn(\"camera input of type \" + type + \" already exists on camera\");\n            return;\n        }\n        this.attached[type] = input;\n        input.camera = this.camera;\n        // for checkInputs, we are dynamically creating a function\n        // the goal is to avoid the performance penalty of looping for inputs in the render loop\n        if (input.checkInputs) {\n            this.checkInputs = this._addCheckInputs(input.checkInputs.bind(input));\n        }\n        if (this.attachedToElement) {\n            input.attachControl(this.noPreventDefault);\n        }\n    }\n    /**\n     * Remove a specific input method from a camera\n     * example: camera.inputs.remove(camera.inputs.attached.mouse);\n     * @param inputToRemove camera input method\n     */\n    remove(inputToRemove) {\n        for (const cam in this.attached) {\n            const input = this.attached[cam];\n            if (input === inputToRemove) {\n                input.detachControl();\n                input.camera = null;\n                delete this.attached[cam];\n                this.rebuildInputCheck();\n                return;\n            }\n        }\n    }\n    /**\n     * Remove a specific input type from a camera\n     * example: camera.inputs.remove(\"ArcRotateCameraGamepadInput\");\n     * @param inputType the type of the input to remove\n     */\n    removeByType(inputType) {\n        for (const cam in this.attached) {\n            const input = this.attached[cam];\n            if (input.getClassName() === inputType) {\n                input.detachControl();\n                input.camera = null;\n                delete this.attached[cam];\n                this.rebuildInputCheck();\n            }\n        }\n    }\n    _addCheckInputs(fn) {\n        const current = this.checkInputs;\n        return () => {\n            current();\n            fn();\n        };\n    }\n    /**\n     * Attach the input controls to the currently attached dom element to listen the events from.\n     * @param input Defines the input to attach\n     */\n    attachInput(input) {\n        if (this.attachedToElement) {\n            input.attachControl(this.noPreventDefault);\n        }\n    }\n    /**\n     * Attach the current manager inputs controls to a specific dom element to listen the events from.\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\n     */\n    attachElement(noPreventDefault = false) {\n        if (this.attachedToElement) {\n            return;\n        }\n        noPreventDefault = Camera.ForceAttachControlToAlwaysPreventDefault ? false : noPreventDefault;\n        this.attachedToElement = true;\n        this.noPreventDefault = noPreventDefault;\n        for (const cam in this.attached) {\n            this.attached[cam].attachControl(noPreventDefault);\n        }\n    }\n    /**\n     * Detach the current manager inputs controls from a specific dom element.\n     * @param disconnect Defines whether the input should be removed from the current list of attached inputs\n     */\n    detachElement(disconnect = false) {\n        for (const cam in this.attached) {\n            this.attached[cam].detachControl();\n            if (disconnect) {\n                this.attached[cam].camera = null;\n            }\n        }\n        this.attachedToElement = false;\n    }\n    /**\n     * Rebuild the dynamic inputCheck function from the current list of\n     * defined inputs in the manager.\n     */\n    rebuildInputCheck() {\n        this.checkInputs = () => { };\n        for (const cam in this.attached) {\n            const input = this.attached[cam];\n            if (input.checkInputs) {\n                this.checkInputs = this._addCheckInputs(input.checkInputs.bind(input));\n            }\n        }\n    }\n    /**\n     * Remove all attached input methods from a camera\n     */\n    clear() {\n        if (this.attachedToElement) {\n            this.detachElement(true);\n        }\n        this.attached = {};\n        this.attachedToElement = false;\n        this.checkInputs = () => { };\n    }\n    /**\n     * Serialize the current input manager attached to a camera.\n     * This ensures than once parsed,\n     * the input associated to the camera will be identical to the current ones\n     * @param serializedCamera Defines the camera serialization JSON the input serialization should write to\n     */\n    serialize(serializedCamera) {\n        const inputs = {};\n        for (const cam in this.attached) {\n            const input = this.attached[cam];\n            const res = SerializationHelper.Serialize(input);\n            inputs[input.getClassName()] = res;\n        }\n        serializedCamera.inputsmgr = inputs;\n    }\n    /**\n     * Parses an input manager serialized JSON to restore the previous list of inputs\n     * and states associated to a camera.\n     * @param parsedCamera Defines the JSON to parse\n     */\n    parse(parsedCamera) {\n        const parsedInputs = parsedCamera.inputsmgr;\n        if (parsedInputs) {\n            this.clear();\n            for (const n in parsedInputs) {\n                const construct = CameraInputTypes[n];\n                if (construct) {\n                    const parsedinput = parsedInputs[n];\n                    const input = SerializationHelper.Parse(() => {\n                        return new construct();\n                    }, parsedinput, null);\n                    this.add(input);\n                }\n            }\n        }\n        else {\n            //2016-03-08 this part is for managing backward compatibility\n            for (const n in this.attached) {\n                const construct = CameraInputTypes[this.attached[n].getClassName()];\n                if (construct) {\n                    const input = SerializationHelper.Parse(() => {\n                        return new construct();\n                    }, parsedCamera, null);\n                    this.remove(this.attached[n]);\n                    this.add(input);\n                }\n            }\n        }\n    }\n}\n//# sourceMappingURL=cameraInputsManager.js.map","import { FreeCamera } from \"./freeCamera.js\";\nimport { Quaternion, Vector3 } from \"../Maths/math.vector.js\";\nimport { Node } from \"../node.js\";\nimport \"./Inputs/freeCameraDeviceOrientationInput.js\";\nimport { Axis } from \"../Maths/math.axis.js\";\nNode.AddNodeConstructor(\"DeviceOrientationCamera\", (name, scene) => {\n    return () => new DeviceOrientationCamera(name, Vector3.Zero(), scene);\n});\n// We're mainly based on the logic defined into the FreeCamera code\n/**\n * This is a camera specifically designed to react to device orientation events such as a modern mobile device\n * being tilted forward or back and left or right.\n */\nexport class DeviceOrientationCamera extends FreeCamera {\n    /**\n     * Creates a new device orientation camera\n     * @param name The name of the camera\n     * @param position The start position camera\n     * @param scene The scene the camera belongs to\n     */\n    constructor(name, position, scene) {\n        super(name, position, scene);\n        this._tmpDragQuaternion = new Quaternion();\n        this._disablePointerInputWhenUsingDeviceOrientation = true;\n        this._dragFactor = 0;\n        this._quaternionCache = new Quaternion();\n        this.inputs.addDeviceOrientation();\n        // When the orientation sensor fires it's first event, disable mouse input\n        if (this.inputs._deviceOrientationInput) {\n            this.inputs._deviceOrientationInput._onDeviceOrientationChangedObservable.addOnce(() => {\n                if (this._disablePointerInputWhenUsingDeviceOrientation) {\n                    if (this.inputs._mouseInput) {\n                        this.inputs._mouseInput._allowCameraRotation = false;\n                        this.inputs._mouseInput.onPointerMovedObservable.add((e) => {\n                            if (this._dragFactor != 0) {\n                                if (!this._initialQuaternion) {\n                                    this._initialQuaternion = new Quaternion();\n                                }\n                                // Rotate the initial space around the y axis to allow users to \"turn around\" via touch/mouse\n                                Quaternion.FromEulerAnglesToRef(0, e.offsetX * this._dragFactor, 0, this._tmpDragQuaternion);\n                                this._initialQuaternion.multiplyToRef(this._tmpDragQuaternion, this._initialQuaternion);\n                            }\n                        });\n                    }\n                }\n            });\n        }\n    }\n    /**\n     * Gets or sets a boolean indicating that pointer input must be disabled on first orientation sensor update (Default: true)\n     */\n    get disablePointerInputWhenUsingDeviceOrientation() {\n        return this._disablePointerInputWhenUsingDeviceOrientation;\n    }\n    set disablePointerInputWhenUsingDeviceOrientation(value) {\n        this._disablePointerInputWhenUsingDeviceOrientation = value;\n    }\n    /**\n     * Enabled turning on the y axis when the orientation sensor is active\n     * @param dragFactor the factor that controls the turn speed (default: 1/300)\n     */\n    enableHorizontalDragging(dragFactor = 1 / 300) {\n        this._dragFactor = dragFactor;\n    }\n    /**\n     * Gets the current instance class name (\"DeviceOrientationCamera\").\n     * This helps avoiding instanceof at run time.\n     * @returns the class name\n     */\n    getClassName() {\n        return \"DeviceOrientationCamera\";\n    }\n    /**\n     * @internal\n     * Checks and applies the current values of the inputs to the camera. (Internal use only)\n     */\n    _checkInputs() {\n        super._checkInputs();\n        this._quaternionCache.copyFrom(this.rotationQuaternion);\n        if (this._initialQuaternion) {\n            this._initialQuaternion.multiplyToRef(this.rotationQuaternion, this.rotationQuaternion);\n        }\n    }\n    /**\n     * Reset the camera to its default orientation on the specified axis only.\n     * @param axis The axis to reset\n     */\n    resetToCurrentRotation(axis = Axis.Y) {\n        //can only work if this camera has a rotation quaternion already.\n        if (!this.rotationQuaternion) {\n            return;\n        }\n        if (!this._initialQuaternion) {\n            this._initialQuaternion = new Quaternion();\n        }\n        this._initialQuaternion.copyFrom(this._quaternionCache || this.rotationQuaternion);\n        [\"x\", \"y\", \"z\"].forEach((axisName) => {\n            if (!axis[axisName]) {\n                this._initialQuaternion[axisName] = 0;\n            }\n            else {\n                this._initialQuaternion[axisName] *= -1;\n            }\n        });\n        this._initialQuaternion.normalize();\n        //force rotation update\n        this._initialQuaternion.multiplyToRef(this.rotationQuaternion, this.rotationQuaternion);\n    }\n}\n//# sourceMappingURL=deviceOrientationCamera.js.map","import { __decorate } from \"../tslib.es6.js\";\nimport { serializeAsVector3, serialize } from \"../Misc/decorators.js\";\nimport { Vector3, Vector2 } from \"../Maths/math.vector.js\";\nimport { Engine } from \"../Engines/engine.js\";\nimport { TargetCamera } from \"./targetCamera.js\";\nimport { FreeCameraInputsManager } from \"./freeCameraInputsManager.js\";\nimport { Tools } from \"../Misc/tools.js\";\n/**\n * This represents a free type of camera. It can be useful in First Person Shooter game for instance.\n * Please consider using the new UniversalCamera instead as it adds more functionality like the gamepad.\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_introduction#universal-camera\n */\nexport class FreeCamera extends TargetCamera {\n    /**\n     * Gets the input sensibility for a mouse input. (default is 2000.0)\n     * Higher values reduce sensitivity.\n     */\n    get angularSensibility() {\n        const mouse = this.inputs.attached[\"mouse\"];\n        if (mouse) {\n            return mouse.angularSensibility;\n        }\n        return 0;\n    }\n    /**\n     * Sets the input sensibility for a mouse input. (default is 2000.0)\n     * Higher values reduce sensitivity.\n     */\n    set angularSensibility(value) {\n        const mouse = this.inputs.attached[\"mouse\"];\n        if (mouse) {\n            mouse.angularSensibility = value;\n        }\n    }\n    /**\n     * Gets or Set the list of keyboard keys used to control the forward move of the camera.\n     */\n    get keysUp() {\n        const keyboard = this.inputs.attached[\"keyboard\"];\n        if (keyboard) {\n            return keyboard.keysUp;\n        }\n        return [];\n    }\n    set keysUp(value) {\n        const keyboard = this.inputs.attached[\"keyboard\"];\n        if (keyboard) {\n            keyboard.keysUp = value;\n        }\n    }\n    /**\n     * Gets or Set the list of keyboard keys used to control the upward move of the camera.\n     */\n    get keysUpward() {\n        const keyboard = this.inputs.attached[\"keyboard\"];\n        if (keyboard) {\n            return keyboard.keysUpward;\n        }\n        return [];\n    }\n    set keysUpward(value) {\n        const keyboard = this.inputs.attached[\"keyboard\"];\n        if (keyboard) {\n            keyboard.keysUpward = value;\n        }\n    }\n    /**\n     * Gets or Set the list of keyboard keys used to control the backward move of the camera.\n     */\n    get keysDown() {\n        const keyboard = this.inputs.attached[\"keyboard\"];\n        if (keyboard) {\n            return keyboard.keysDown;\n        }\n        return [];\n    }\n    set keysDown(value) {\n        const keyboard = this.inputs.attached[\"keyboard\"];\n        if (keyboard) {\n            keyboard.keysDown = value;\n        }\n    }\n    /**\n     * Gets or Set the list of keyboard keys used to control the downward move of the camera.\n     */\n    get keysDownward() {\n        const keyboard = this.inputs.attached[\"keyboard\"];\n        if (keyboard) {\n            return keyboard.keysDownward;\n        }\n        return [];\n    }\n    set keysDownward(value) {\n        const keyboard = this.inputs.attached[\"keyboard\"];\n        if (keyboard) {\n            keyboard.keysDownward = value;\n        }\n    }\n    /**\n     * Gets or Set the list of keyboard keys used to control the left strafe move of the camera.\n     */\n    get keysLeft() {\n        const keyboard = this.inputs.attached[\"keyboard\"];\n        if (keyboard) {\n            return keyboard.keysLeft;\n        }\n        return [];\n    }\n    set keysLeft(value) {\n        const keyboard = this.inputs.attached[\"keyboard\"];\n        if (keyboard) {\n            keyboard.keysLeft = value;\n        }\n    }\n    /**\n     * Gets or Set the list of keyboard keys used to control the right strafe move of the camera.\n     */\n    get keysRight() {\n        const keyboard = this.inputs.attached[\"keyboard\"];\n        if (keyboard) {\n            return keyboard.keysRight;\n        }\n        return [];\n    }\n    set keysRight(value) {\n        const keyboard = this.inputs.attached[\"keyboard\"];\n        if (keyboard) {\n            keyboard.keysRight = value;\n        }\n    }\n    /**\n     * Gets or Set the list of keyboard keys used to control the left rotation move of the camera.\n     */\n    get keysRotateLeft() {\n        const keyboard = this.inputs.attached[\"keyboard\"];\n        if (keyboard) {\n            return keyboard.keysRotateLeft;\n        }\n        return [];\n    }\n    set keysRotateLeft(value) {\n        const keyboard = this.inputs.attached[\"keyboard\"];\n        if (keyboard) {\n            keyboard.keysRotateLeft = value;\n        }\n    }\n    /**\n     * Gets or Set the list of keyboard keys used to control the right rotation move of the camera.\n     */\n    get keysRotateRight() {\n        const keyboard = this.inputs.attached[\"keyboard\"];\n        if (keyboard) {\n            return keyboard.keysRotateRight;\n        }\n        return [];\n    }\n    set keysRotateRight(value) {\n        const keyboard = this.inputs.attached[\"keyboard\"];\n        if (keyboard) {\n            keyboard.keysRotateRight = value;\n        }\n    }\n    /**\n     * Instantiates a Free Camera.\n     * This represents a free type of camera. It can be useful in First Person Shooter game for instance.\n     * Please consider using the new UniversalCamera instead as it adds more functionality like touch to this camera.\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_introduction#universal-camera\n     * @param name Define the name of the camera in the scene\n     * @param position Define the start position of the camera in the scene\n     * @param scene Define the scene the camera belongs to\n     * @param setActiveOnSceneIfNoneActive Defines whether the camera should be marked as active if not other active cameras have been defined\n     */\n    constructor(name, position, scene, setActiveOnSceneIfNoneActive = true) {\n        super(name, position, scene, setActiveOnSceneIfNoneActive);\n        /**\n         * Define the collision ellipsoid of the camera.\n         * This is helpful to simulate a camera body like the player body around the camera\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_collisions#arcrotatecamera\n         */\n        this.ellipsoid = new Vector3(0.5, 1, 0.5);\n        /**\n         * Define an offset for the position of the ellipsoid around the camera.\n         * This can be helpful to determine the center of the body near the gravity center of the body\n         * instead of its head.\n         */\n        this.ellipsoidOffset = new Vector3(0, 0, 0);\n        /**\n         * Enable or disable collisions of the camera with the rest of the scene objects.\n         */\n        this.checkCollisions = false;\n        /**\n         * Enable or disable gravity on the camera.\n         */\n        this.applyGravity = false;\n        this._needMoveForGravity = false;\n        this._oldPosition = Vector3.Zero();\n        this._diffPosition = Vector3.Zero();\n        this._newPosition = Vector3.Zero();\n        // Collisions\n        this._collisionMask = -1;\n        this._onCollisionPositionChange = (collisionId, newPosition, collidedMesh = null) => {\n            const updatePosition = (newPos) => {\n                this._newPosition.copyFrom(newPos);\n                this._newPosition.subtractToRef(this._oldPosition, this._diffPosition);\n                if (this._diffPosition.length() > Engine.CollisionsEpsilon) {\n                    this.position.addInPlace(this._diffPosition);\n                    if (this.onCollide && collidedMesh) {\n                        this.onCollide(collidedMesh);\n                    }\n                }\n            };\n            updatePosition(newPosition);\n        };\n        this.inputs = new FreeCameraInputsManager(this);\n        this.inputs.addKeyboard().addMouse();\n    }\n    /**\n     * Attached controls to the current camera.\n     * @param ignored defines an ignored parameter kept for backward compatibility.\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\n     */\n    attachControl(ignored, noPreventDefault) {\n        // eslint-disable-next-line prefer-rest-params\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\n        this.inputs.attachElement(noPreventDefault);\n    }\n    /**\n     * Detach the current controls from the specified dom element.\n     */\n    detachControl() {\n        this.inputs.detachElement();\n        this.cameraDirection = new Vector3(0, 0, 0);\n        this.cameraRotation = new Vector2(0, 0);\n    }\n    /**\n     * Define a collision mask to limit the list of object the camera can collide with\n     */\n    get collisionMask() {\n        return this._collisionMask;\n    }\n    set collisionMask(mask) {\n        this._collisionMask = !isNaN(mask) ? mask : -1;\n    }\n    /**\n     * @internal\n     */\n    _collideWithWorld(displacement) {\n        let globalPosition;\n        if (this.parent) {\n            globalPosition = Vector3.TransformCoordinates(this.position, this.parent.getWorldMatrix());\n        }\n        else {\n            globalPosition = this.position;\n        }\n        globalPosition.subtractFromFloatsToRef(0, this.ellipsoid.y, 0, this._oldPosition);\n        this._oldPosition.addInPlace(this.ellipsoidOffset);\n        const coordinator = this.getScene().collisionCoordinator;\n        if (!this._collider) {\n            this._collider = coordinator.createCollider();\n        }\n        this._collider._radius = this.ellipsoid;\n        this._collider.collisionMask = this._collisionMask;\n        //no need for clone, as long as gravity is not on.\n        let actualDisplacement = displacement;\n        //add gravity to the direction to prevent the dual-collision checking\n        if (this.applyGravity) {\n            //this prevents mending with cameraDirection, a global variable of the free camera class.\n            actualDisplacement = displacement.add(this.getScene().gravity);\n        }\n        coordinator.getNewPosition(this._oldPosition, actualDisplacement, this._collider, 3, null, this._onCollisionPositionChange, this.uniqueId);\n    }\n    /** @internal */\n    _checkInputs() {\n        if (!this._localDirection) {\n            this._localDirection = Vector3.Zero();\n            this._transformedDirection = Vector3.Zero();\n        }\n        this.inputs.checkInputs();\n        super._checkInputs();\n    }\n    /** @internal */\n    _decideIfNeedsToMove() {\n        return this._needMoveForGravity || Math.abs(this.cameraDirection.x) > 0 || Math.abs(this.cameraDirection.y) > 0 || Math.abs(this.cameraDirection.z) > 0;\n    }\n    /** @internal */\n    _updatePosition() {\n        if (this.checkCollisions && this.getScene().collisionsEnabled) {\n            this._collideWithWorld(this.cameraDirection);\n        }\n        else {\n            super._updatePosition();\n        }\n    }\n    /**\n     * Destroy the camera and release the current resources hold by it.\n     */\n    dispose() {\n        this.inputs.clear();\n        super.dispose();\n    }\n    /**\n     * Gets the current object class name.\n     * @returns the class name\n     */\n    getClassName() {\n        return \"FreeCamera\";\n    }\n}\n__decorate([\n    serializeAsVector3()\n], FreeCamera.prototype, \"ellipsoid\", void 0);\n__decorate([\n    serializeAsVector3()\n], FreeCamera.prototype, \"ellipsoidOffset\", void 0);\n__decorate([\n    serialize()\n], FreeCamera.prototype, \"checkCollisions\", void 0);\n__decorate([\n    serialize()\n], FreeCamera.prototype, \"applyGravity\", void 0);\n//# sourceMappingURL=freeCamera.js.map","import { CameraInputsManager } from \"./cameraInputsManager.js\";\nimport { FreeCameraKeyboardMoveInput } from \"../Cameras/Inputs/freeCameraKeyboardMoveInput.js\";\nimport { FreeCameraMouseInput } from \"../Cameras/Inputs/freeCameraMouseInput.js\";\nimport { FreeCameraMouseWheelInput } from \"../Cameras/Inputs/freeCameraMouseWheelInput.js\";\nimport { FreeCameraTouchInput } from \"../Cameras/Inputs/freeCameraTouchInput.js\";\n/**\n * Default Inputs manager for the FreeCamera.\n * It groups all the default supported inputs for ease of use.\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\n */\nexport class FreeCameraInputsManager extends CameraInputsManager {\n    /**\n     * Instantiates a new FreeCameraInputsManager.\n     * @param camera Defines the camera the inputs belong to\n     */\n    constructor(camera) {\n        super(camera);\n        /**\n         * @internal\n         */\n        this._mouseInput = null;\n        /**\n         * @internal\n         */\n        this._mouseWheelInput = null;\n    }\n    /**\n     * Add keyboard input support to the input manager.\n     * @returns the current input manager\n     */\n    addKeyboard() {\n        this.add(new FreeCameraKeyboardMoveInput());\n        return this;\n    }\n    /**\n     * Add mouse input support to the input manager.\n     * @param touchEnabled if the FreeCameraMouseInput should support touch (default: true)\n     * @returns the current input manager\n     */\n    addMouse(touchEnabled = true) {\n        if (!this._mouseInput) {\n            this._mouseInput = new FreeCameraMouseInput(touchEnabled);\n            this.add(this._mouseInput);\n        }\n        return this;\n    }\n    /**\n     * Removes the mouse input support from the manager\n     * @returns the current input manager\n     */\n    removeMouse() {\n        if (this._mouseInput) {\n            this.remove(this._mouseInput);\n        }\n        return this;\n    }\n    /**\n     * Add mouse wheel input support to the input manager.\n     * @returns the current input manager\n     */\n    addMouseWheel() {\n        if (!this._mouseWheelInput) {\n            this._mouseWheelInput = new FreeCameraMouseWheelInput();\n            this.add(this._mouseWheelInput);\n        }\n        return this;\n    }\n    /**\n     * Removes the mouse wheel input support from the manager\n     * @returns the current input manager\n     */\n    removeMouseWheel() {\n        if (this._mouseWheelInput) {\n            this.remove(this._mouseWheelInput);\n        }\n        return this;\n    }\n    /**\n     * Add touch input support to the input manager.\n     * @returns the current input manager\n     */\n    addTouch() {\n        this.add(new FreeCameraTouchInput());\n        return this;\n    }\n    /**\n     * Remove all attached input methods from a camera\n     */\n    clear() {\n        super.clear();\n        this._mouseInput = null;\n    }\n}\n//# sourceMappingURL=freeCameraInputsManager.js.map","import { CameraInputTypes } from \"../../Cameras/cameraInputsManager.js\";\nimport { ArcRotateCameraInputsManager } from \"../../Cameras/arcRotateCameraInputsManager.js\";\nimport { Tools } from \"../../Misc/tools.js\";\n/**\n * Add orientation input support to the input manager.\n * @returns the current input manager\n */\nArcRotateCameraInputsManager.prototype.addVRDeviceOrientation = function () {\n    this.add(new ArcRotateCameraVRDeviceOrientationInput());\n    return this;\n};\n/**\n * Manage the device orientation inputs (gyroscope) to control an arc rotate camera.\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\n */\nexport class ArcRotateCameraVRDeviceOrientationInput {\n    /**\n     * Instantiate a new ArcRotateCameraVRDeviceOrientationInput.\n     */\n    constructor() {\n        /**\n         * Defines a correction factor applied on the alpha value retrieved from the orientation events.\n         */\n        this.alphaCorrection = 1;\n        /**\n         * Defines a correction factor applied on the gamma value retrieved from the orientation events.\n         */\n        this.gammaCorrection = 1;\n        this._alpha = 0;\n        this._gamma = 0;\n        this._dirty = false;\n        this._deviceOrientationHandler = this._onOrientationEvent.bind(this);\n    }\n    /**\n     * Attach the input controls to a specific dom element to get the input from.\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\n     */\n    attachControl(noPreventDefault) {\n        // eslint-disable-next-line prefer-rest-params\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\n        this.camera.attachControl(noPreventDefault);\n        const hostWindow = this.camera.getScene().getEngine().getHostWindow();\n        if (hostWindow) {\n            // check iOS 13+ support\n            if (typeof DeviceOrientationEvent !== \"undefined\" && typeof DeviceOrientationEvent.requestPermission === \"function\") {\n                DeviceOrientationEvent\n                    .requestPermission()\n                    .then((response) => {\n                    if (response === \"granted\") {\n                        hostWindow.addEventListener(\"deviceorientation\", this._deviceOrientationHandler);\n                    }\n                    else {\n                        Tools.Warn(\"Permission not granted.\");\n                    }\n                })\n                    .catch((error) => {\n                    Tools.Error(error);\n                });\n            }\n            else {\n                hostWindow.addEventListener(\"deviceorientation\", this._deviceOrientationHandler);\n            }\n        }\n    }\n    /**\n     * @internal\n     */\n    _onOrientationEvent(evt) {\n        if (evt.alpha !== null) {\n            this._alpha = (+evt.alpha | 0) * this.alphaCorrection;\n        }\n        if (evt.gamma !== null) {\n            this._gamma = (+evt.gamma | 0) * this.gammaCorrection;\n        }\n        this._dirty = true;\n    }\n    /**\n     * Update the current camera state depending on the inputs that have been used this frame.\n     * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.\n     */\n    checkInputs() {\n        if (this._dirty) {\n            this._dirty = false;\n            if (this._gamma < 0) {\n                this._gamma = 180 + this._gamma;\n            }\n            this.camera.alpha = (((-this._alpha / 180.0) * Math.PI) % Math.PI) * 2;\n            this.camera.beta = (this._gamma / 180.0) * Math.PI;\n        }\n    }\n    /**\n     * Detach the current controls from the specified dom element.\n     */\n    detachControl() {\n        window.removeEventListener(\"deviceorientation\", this._deviceOrientationHandler);\n    }\n    /**\n     * Gets the class name of the current input.\n     * @returns the class name\n     */\n    getClassName() {\n        return \"ArcRotateCameraVRDeviceOrientationInput\";\n    }\n    /**\n     * Get the friendly name associated with the input class.\n     * @returns the input friendly name\n     */\n    getSimpleName() {\n        return \"VRDeviceOrientation\";\n    }\n}\nCameraInputTypes[\"ArcRotateCameraVRDeviceOrientationInput\"] = ArcRotateCameraVRDeviceOrientationInput;\n//# sourceMappingURL=arcRotateCameraVRDeviceOrientationInput.js.map","import { __decorate } from \"../../tslib.es6.js\";\nimport { serialize } from \"../../Misc/decorators.js\";\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager.js\";\nimport { KeyboardEventTypes } from \"../../Events/keyboardEvents.js\";\nimport { Vector3 } from \"../../Maths/math.vector.js\";\nimport { Tools } from \"../../Misc/tools.js\";\n/**\n * Listen to keyboard events to control the camera.\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\n */\nexport class FlyCameraKeyboardInput {\n    constructor() {\n        /**\n         * The list of keyboard keys used to control the forward move of the camera.\n         */\n        this.keysForward = [87];\n        /**\n         * The list of keyboard keys used to control the backward move of the camera.\n         */\n        this.keysBackward = [83];\n        /**\n         * The list of keyboard keys used to control the forward move of the camera.\n         */\n        this.keysUp = [69];\n        /**\n         * The list of keyboard keys used to control the backward move of the camera.\n         */\n        this.keysDown = [81];\n        /**\n         * The list of keyboard keys used to control the right strafe move of the camera.\n         */\n        this.keysRight = [68];\n        /**\n         * The list of keyboard keys used to control the left strafe move of the camera.\n         */\n        this.keysLeft = [65];\n        this._keys = new Array();\n    }\n    /**\n     * Attach the input controls to a specific dom element to get the input from.\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\n     */\n    attachControl(noPreventDefault) {\n        // eslint-disable-next-line prefer-rest-params\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\n        if (this._onCanvasBlurObserver) {\n            return;\n        }\n        this._scene = this.camera.getScene();\n        this._engine = this._scene.getEngine();\n        this._onCanvasBlurObserver = this._engine.onCanvasBlurObservable.add(() => {\n            this._keys.length = 0;\n        });\n        this._onKeyboardObserver = this._scene.onKeyboardObservable.add((info) => {\n            const evt = info.event;\n            if (info.type === KeyboardEventTypes.KEYDOWN) {\n                if (this.keysForward.indexOf(evt.keyCode) !== -1 ||\n                    this.keysBackward.indexOf(evt.keyCode) !== -1 ||\n                    this.keysUp.indexOf(evt.keyCode) !== -1 ||\n                    this.keysDown.indexOf(evt.keyCode) !== -1 ||\n                    this.keysLeft.indexOf(evt.keyCode) !== -1 ||\n                    this.keysRight.indexOf(evt.keyCode) !== -1) {\n                    const index = this._keys.indexOf(evt.keyCode);\n                    if (index === -1) {\n                        this._keys.push(evt.keyCode);\n                    }\n                    if (!noPreventDefault) {\n                        evt.preventDefault();\n                    }\n                }\n            }\n            else {\n                if (this.keysForward.indexOf(evt.keyCode) !== -1 ||\n                    this.keysBackward.indexOf(evt.keyCode) !== -1 ||\n                    this.keysUp.indexOf(evt.keyCode) !== -1 ||\n                    this.keysDown.indexOf(evt.keyCode) !== -1 ||\n                    this.keysLeft.indexOf(evt.keyCode) !== -1 ||\n                    this.keysRight.indexOf(evt.keyCode) !== -1) {\n                    const index = this._keys.indexOf(evt.keyCode);\n                    if (index >= 0) {\n                        this._keys.splice(index, 1);\n                    }\n                    if (!noPreventDefault) {\n                        evt.preventDefault();\n                    }\n                }\n            }\n        });\n    }\n    /**\n     * Detach the current controls from the specified dom element.\n     */\n    detachControl() {\n        if (this._scene) {\n            if (this._onKeyboardObserver) {\n                this._scene.onKeyboardObservable.remove(this._onKeyboardObserver);\n            }\n            if (this._onCanvasBlurObserver) {\n                this._engine.onCanvasBlurObservable.remove(this._onCanvasBlurObserver);\n            }\n            this._onKeyboardObserver = null;\n            this._onCanvasBlurObserver = null;\n        }\n        this._keys.length = 0;\n    }\n    /**\n     * Gets the class name of the current input.\n     * @returns the class name\n     */\n    getClassName() {\n        return \"FlyCameraKeyboardInput\";\n    }\n    /**\n     * @internal\n     */\n    _onLostFocus() {\n        this._keys.length = 0;\n    }\n    /**\n     * Get the friendly name associated with the input class.\n     * @returns the input friendly name\n     */\n    getSimpleName() {\n        return \"keyboard\";\n    }\n    /**\n     * Update the current camera state depending on the inputs that have been used this frame.\n     * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.\n     */\n    checkInputs() {\n        if (this._onKeyboardObserver) {\n            const camera = this.camera;\n            // Keyboard\n            for (let index = 0; index < this._keys.length; index++) {\n                const keyCode = this._keys[index];\n                const speed = camera._computeLocalCameraSpeed();\n                if (this.keysForward.indexOf(keyCode) !== -1) {\n                    camera._localDirection.copyFromFloats(0, 0, speed);\n                }\n                else if (this.keysBackward.indexOf(keyCode) !== -1) {\n                    camera._localDirection.copyFromFloats(0, 0, -speed);\n                }\n                else if (this.keysUp.indexOf(keyCode) !== -1) {\n                    camera._localDirection.copyFromFloats(0, speed, 0);\n                }\n                else if (this.keysDown.indexOf(keyCode) !== -1) {\n                    camera._localDirection.copyFromFloats(0, -speed, 0);\n                }\n                else if (this.keysRight.indexOf(keyCode) !== -1) {\n                    camera._localDirection.copyFromFloats(speed, 0, 0);\n                }\n                else if (this.keysLeft.indexOf(keyCode) !== -1) {\n                    camera._localDirection.copyFromFloats(-speed, 0, 0);\n                }\n                if (camera.getScene().useRightHandedSystem) {\n                    camera._localDirection.z *= -1;\n                }\n                camera.getViewMatrix().invertToRef(camera._cameraTransformMatrix);\n                Vector3.TransformNormalToRef(camera._localDirection, camera._cameraTransformMatrix, camera._transformedDirection);\n                camera.cameraDirection.addInPlace(camera._transformedDirection);\n            }\n        }\n    }\n}\n__decorate([\n    serialize()\n], FlyCameraKeyboardInput.prototype, \"keysForward\", void 0);\n__decorate([\n    serialize()\n], FlyCameraKeyboardInput.prototype, \"keysBackward\", void 0);\n__decorate([\n    serialize()\n], FlyCameraKeyboardInput.prototype, \"keysUp\", void 0);\n__decorate([\n    serialize()\n], FlyCameraKeyboardInput.prototype, \"keysDown\", void 0);\n__decorate([\n    serialize()\n], FlyCameraKeyboardInput.prototype, \"keysRight\", void 0);\n__decorate([\n    serialize()\n], FlyCameraKeyboardInput.prototype, \"keysLeft\", void 0);\nCameraInputTypes[\"FlyCameraKeyboardInput\"] = FlyCameraKeyboardInput;\n//# sourceMappingURL=flyCameraKeyboardInput.js.map","import { __decorate } from \"../../tslib.es6.js\";\nimport { serialize } from \"../../Misc/decorators.js\";\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager.js\";\nimport { PointerEventTypes } from \"../../Events/pointerEvents.js\";\nimport { Quaternion } from \"../../Maths/math.vector.js\";\nimport { Axis } from \"../../Maths/math.axis.js\";\nimport { Tools } from \"../../Misc/tools.js\";\n/**\n * Listen to mouse events to control the camera.\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\n */\nexport class FlyCameraMouseInput {\n    /**\n     * Listen to mouse events to control the camera.\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\n     */\n    constructor() {\n        /**\n         * Defines the buttons associated with the input to handle camera rotation.\n         */\n        this.buttons = [0, 1, 2];\n        /**\n         * Assign buttons for Yaw control.\n         */\n        this.buttonsYaw = [-1, 0, 1];\n        /**\n         * Assign buttons for Pitch control.\n         */\n        this.buttonsPitch = [-1, 0, 1];\n        /**\n         * Assign buttons for Roll control.\n         */\n        this.buttonsRoll = [2];\n        /**\n         * Detect if any button is being pressed while mouse is moved.\n         * -1 = Mouse locked.\n         * 0 = Left button.\n         * 1 = Middle Button.\n         * 2 = Right Button.\n         */\n        this.activeButton = -1;\n        /**\n         * Defines the pointer's angular sensibility, to control the camera rotation speed.\n         * Higher values reduce its sensitivity.\n         */\n        this.angularSensibility = 1000.0;\n        this._previousPosition = null;\n    }\n    /**\n     * Attach the mouse control to the HTML DOM element.\n     * @param noPreventDefault Defines whether events caught by the controls should call preventdefault().\n     */\n    attachControl(noPreventDefault) {\n        // eslint-disable-next-line prefer-rest-params\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\n        this._noPreventDefault = noPreventDefault;\n        this._observer = this.camera.getScene()._inputManager._addCameraPointerObserver((p) => {\n            this._pointerInput(p);\n        }, PointerEventTypes.POINTERDOWN | PointerEventTypes.POINTERUP | PointerEventTypes.POINTERMOVE);\n        // Correct Roll by rate, if enabled.\n        this._rollObserver = this.camera.getScene().onBeforeRenderObservable.add(() => {\n            if (this.camera.rollCorrect) {\n                this.camera.restoreRoll(this.camera.rollCorrect);\n            }\n        });\n    }\n    /**\n     * Detach the current controls from the specified dom element.\n     */\n    detachControl() {\n        if (this._observer) {\n            this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer);\n            this.camera.getScene().onBeforeRenderObservable.remove(this._rollObserver);\n            this._observer = null;\n            this._rollObserver = null;\n            this._previousPosition = null;\n            this._noPreventDefault = undefined;\n        }\n    }\n    /**\n     * Gets the class name of the current input.\n     * @returns the class name.\n     */\n    getClassName() {\n        return \"FlyCameraMouseInput\";\n    }\n    /**\n     * Get the friendly name associated with the input class.\n     * @returns the input's friendly name.\n     */\n    getSimpleName() {\n        return \"mouse\";\n    }\n    // Track mouse movement, when the pointer is not locked.\n    _pointerInput(p) {\n        const e = p.event;\n        const camera = this.camera;\n        const engine = camera.getEngine();\n        if (engine.isInVRExclusivePointerMode) {\n            return;\n        }\n        if (!this.touchEnabled && e.pointerType === \"touch\") {\n            return;\n        }\n        // Mouse is moved but an unknown mouse button is pressed.\n        if (p.type !== PointerEventTypes.POINTERMOVE && this.buttons.indexOf(e.button) === -1) {\n            return;\n        }\n        const srcElement = e.target;\n        // Mouse down.\n        if (p.type === PointerEventTypes.POINTERDOWN) {\n            try {\n                srcElement === null || srcElement === void 0 ? void 0 : srcElement.setPointerCapture(e.pointerId);\n            }\n            catch (e) {\n                // Nothing to do with the error. Execution continues.\n            }\n            this._previousPosition = {\n                x: e.clientX,\n                y: e.clientY,\n            };\n            this.activeButton = e.button;\n            if (!this._noPreventDefault) {\n                e.preventDefault();\n                this._element.focus();\n            }\n            // This is required to move while pointer button is down\n            if (engine.isPointerLock) {\n                this._onMouseMove(p.event);\n            }\n        }\n        // Mouse up.\n        else if (p.type === PointerEventTypes.POINTERUP) {\n            try {\n                srcElement === null || srcElement === void 0 ? void 0 : srcElement.releasePointerCapture(e.pointerId);\n            }\n            catch (e) {\n                // Nothing to do with the error. Execution continues.\n            }\n            this.activeButton = -1;\n            this._previousPosition = null;\n            if (!this._noPreventDefault) {\n                e.preventDefault();\n            }\n        }\n        // Mouse move.\n        else if (p.type === PointerEventTypes.POINTERMOVE) {\n            if (!this._previousPosition) {\n                if (engine.isPointerLock) {\n                    this._onMouseMove(p.event);\n                }\n                return;\n            }\n            const offsetX = e.clientX - this._previousPosition.x;\n            const offsetY = e.clientY - this._previousPosition.y;\n            this._rotateCamera(offsetX, offsetY);\n            this._previousPosition = {\n                x: e.clientX,\n                y: e.clientY,\n            };\n            if (!this._noPreventDefault) {\n                e.preventDefault();\n            }\n        }\n    }\n    // Track mouse movement, when pointer is locked.\n    _onMouseMove(e) {\n        const camera = this.camera;\n        const engine = camera.getEngine();\n        if (!engine.isPointerLock || engine.isInVRExclusivePointerMode) {\n            return;\n        }\n        const offsetX = e.movementX;\n        const offsetY = e.movementY;\n        this._rotateCamera(offsetX, offsetY);\n        this._previousPosition = null;\n        if (!this._noPreventDefault) {\n            e.preventDefault();\n        }\n    }\n    /**\n     * Rotate camera by mouse offset.\n     * @param offsetX\n     * @param offsetY\n     */\n    _rotateCamera(offsetX, offsetY) {\n        const camera = this.camera;\n        const scene = this.camera.getScene();\n        if (scene.useRightHandedSystem) {\n            offsetX *= -1;\n        }\n        if (camera.parent && camera.parent._getWorldMatrixDeterminant() < 0) {\n            offsetX *= -1;\n        }\n        const x = offsetX / this.angularSensibility;\n        const y = offsetY / this.angularSensibility;\n        // Initialize to current rotation.\n        const currentRotation = Quaternion.RotationYawPitchRoll(camera.rotation.y, camera.rotation.x, camera.rotation.z);\n        let rotationChange;\n        // Pitch.\n        if (this.buttonsPitch.some((v) => {\n            return v === this.activeButton;\n        })) {\n            // Apply change in Radians to vector Angle.\n            rotationChange = Quaternion.RotationAxis(Axis.X, y);\n            // Apply Pitch to quaternion.\n            currentRotation.multiplyInPlace(rotationChange);\n        }\n        // Yaw.\n        if (this.buttonsYaw.some((v) => {\n            return v === this.activeButton;\n        })) {\n            // Apply change in Radians to vector Angle.\n            rotationChange = Quaternion.RotationAxis(Axis.Y, x);\n            // Apply Yaw to quaternion.\n            currentRotation.multiplyInPlace(rotationChange);\n            // Add Roll, if banked turning is enabled, within Roll limit.\n            const limit = camera.bankedTurnLimit + camera._trackRoll; // Defaults to 90 plus manual roll.\n            if (camera.bankedTurn && -limit < camera.rotation.z && camera.rotation.z < limit) {\n                const bankingDelta = camera.bankedTurnMultiplier * -x;\n                // Apply change in Radians to vector Angle.\n                rotationChange = Quaternion.RotationAxis(Axis.Z, bankingDelta);\n                // Apply Yaw to quaternion.\n                currentRotation.multiplyInPlace(rotationChange);\n            }\n        }\n        // Roll.\n        if (this.buttonsRoll.some((v) => {\n            return v === this.activeButton;\n        })) {\n            // Apply change in Radians to vector Angle.\n            rotationChange = Quaternion.RotationAxis(Axis.Z, -x);\n            // Track Rolling.\n            camera._trackRoll -= x;\n            // Apply Pitch to quaternion.\n            currentRotation.multiplyInPlace(rotationChange);\n        }\n        // Apply rotationQuaternion to Euler camera.rotation.\n        currentRotation.toEulerAnglesToRef(camera.rotation);\n    }\n}\n__decorate([\n    serialize()\n], FlyCameraMouseInput.prototype, \"buttons\", void 0);\n__decorate([\n    serialize()\n], FlyCameraMouseInput.prototype, \"angularSensibility\", void 0);\nCameraInputTypes[\"FlyCameraMouseInput\"] = FlyCameraMouseInput;\n//# sourceMappingURL=flyCameraMouseInput.js.map","import { __decorate } from \"../../tslib.es6.js\";\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager.js\";\nimport { serialize } from \"../../Misc/decorators.js\";\nimport { KeyboardEventTypes } from \"../../Events/keyboardEvents.js\";\nimport { Tools } from \"../../Misc/tools.js\";\n/**\n * Manage the keyboard inputs to control the movement of a follow camera.\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\n */\nexport class FollowCameraKeyboardMoveInput {\n    constructor() {\n        /**\n         * Defines the list of key codes associated with the up action (increase heightOffset)\n         */\n        this.keysHeightOffsetIncr = [38];\n        /**\n         * Defines the list of key codes associated with the down action (decrease heightOffset)\n         */\n        this.keysHeightOffsetDecr = [40];\n        /**\n         * Defines whether the Alt modifier key is required to move up/down (alter heightOffset)\n         */\n        this.keysHeightOffsetModifierAlt = false;\n        /**\n         * Defines whether the Ctrl modifier key is required to move up/down (alter heightOffset)\n         */\n        this.keysHeightOffsetModifierCtrl = false;\n        /**\n         * Defines whether the Shift modifier key is required to move up/down (alter heightOffset)\n         */\n        this.keysHeightOffsetModifierShift = false;\n        /**\n         * Defines the list of key codes associated with the left action (increase rotationOffset)\n         */\n        this.keysRotationOffsetIncr = [37];\n        /**\n         * Defines the list of key codes associated with the right action (decrease rotationOffset)\n         */\n        this.keysRotationOffsetDecr = [39];\n        /**\n         * Defines whether the Alt modifier key is required to move left/right (alter rotationOffset)\n         */\n        this.keysRotationOffsetModifierAlt = false;\n        /**\n         * Defines whether the Ctrl modifier key is required to move left/right (alter rotationOffset)\n         */\n        this.keysRotationOffsetModifierCtrl = false;\n        /**\n         * Defines whether the Shift modifier key is required to move left/right (alter rotationOffset)\n         */\n        this.keysRotationOffsetModifierShift = false;\n        /**\n         * Defines the list of key codes associated with the zoom-in action (decrease radius)\n         */\n        this.keysRadiusIncr = [40];\n        /**\n         * Defines the list of key codes associated with the zoom-out action (increase radius)\n         */\n        this.keysRadiusDecr = [38];\n        /**\n         * Defines whether the Alt modifier key is required to zoom in/out (alter radius value)\n         */\n        this.keysRadiusModifierAlt = true;\n        /**\n         * Defines whether the Ctrl modifier key is required to zoom in/out (alter radius value)\n         */\n        this.keysRadiusModifierCtrl = false;\n        /**\n         * Defines whether the Shift modifier key is required to zoom in/out (alter radius value)\n         */\n        this.keysRadiusModifierShift = false;\n        /**\n         * Defines the rate of change of heightOffset.\n         */\n        this.heightSensibility = 1;\n        /**\n         * Defines the rate of change of rotationOffset.\n         */\n        this.rotationSensibility = 1;\n        /**\n         * Defines the rate of change of radius.\n         */\n        this.radiusSensibility = 1;\n        this._keys = new Array();\n    }\n    /**\n     * Attach the input controls to a specific dom element to get the input from.\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\n     */\n    attachControl(noPreventDefault) {\n        // eslint-disable-next-line prefer-rest-params\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\n        if (this._onCanvasBlurObserver) {\n            return;\n        }\n        this._scene = this.camera.getScene();\n        this._engine = this._scene.getEngine();\n        this._onCanvasBlurObserver = this._engine.onCanvasBlurObservable.add(() => {\n            this._keys.length = 0;\n        });\n        this._onKeyboardObserver = this._scene.onKeyboardObservable.add((info) => {\n            const evt = info.event;\n            if (!evt.metaKey) {\n                if (info.type === KeyboardEventTypes.KEYDOWN) {\n                    this._ctrlPressed = evt.ctrlKey;\n                    this._altPressed = evt.altKey;\n                    this._shiftPressed = evt.shiftKey;\n                    if (this.keysHeightOffsetIncr.indexOf(evt.keyCode) !== -1 ||\n                        this.keysHeightOffsetDecr.indexOf(evt.keyCode) !== -1 ||\n                        this.keysRotationOffsetIncr.indexOf(evt.keyCode) !== -1 ||\n                        this.keysRotationOffsetDecr.indexOf(evt.keyCode) !== -1 ||\n                        this.keysRadiusIncr.indexOf(evt.keyCode) !== -1 ||\n                        this.keysRadiusDecr.indexOf(evt.keyCode) !== -1) {\n                        const index = this._keys.indexOf(evt.keyCode);\n                        if (index === -1) {\n                            this._keys.push(evt.keyCode);\n                        }\n                        if (evt.preventDefault) {\n                            if (!noPreventDefault) {\n                                evt.preventDefault();\n                            }\n                        }\n                    }\n                }\n                else {\n                    if (this.keysHeightOffsetIncr.indexOf(evt.keyCode) !== -1 ||\n                        this.keysHeightOffsetDecr.indexOf(evt.keyCode) !== -1 ||\n                        this.keysRotationOffsetIncr.indexOf(evt.keyCode) !== -1 ||\n                        this.keysRotationOffsetDecr.indexOf(evt.keyCode) !== -1 ||\n                        this.keysRadiusIncr.indexOf(evt.keyCode) !== -1 ||\n                        this.keysRadiusDecr.indexOf(evt.keyCode) !== -1) {\n                        const index = this._keys.indexOf(evt.keyCode);\n                        if (index >= 0) {\n                            this._keys.splice(index, 1);\n                        }\n                        if (evt.preventDefault) {\n                            if (!noPreventDefault) {\n                                evt.preventDefault();\n                            }\n                        }\n                    }\n                }\n            }\n        });\n    }\n    /**\n     * Detach the current controls from the specified dom element.\n     */\n    detachControl() {\n        if (this._scene) {\n            if (this._onKeyboardObserver) {\n                this._scene.onKeyboardObservable.remove(this._onKeyboardObserver);\n            }\n            if (this._onCanvasBlurObserver) {\n                this._engine.onCanvasBlurObservable.remove(this._onCanvasBlurObserver);\n            }\n            this._onKeyboardObserver = null;\n            this._onCanvasBlurObserver = null;\n        }\n        this._keys.length = 0;\n    }\n    /**\n     * Update the current camera state depending on the inputs that have been used this frame.\n     * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.\n     */\n    checkInputs() {\n        if (this._onKeyboardObserver) {\n            this._keys.forEach((keyCode) => {\n                if (this.keysHeightOffsetIncr.indexOf(keyCode) !== -1 && this._modifierHeightOffset()) {\n                    this.camera.heightOffset += this.heightSensibility;\n                }\n                else if (this.keysHeightOffsetDecr.indexOf(keyCode) !== -1 && this._modifierHeightOffset()) {\n                    this.camera.heightOffset -= this.heightSensibility;\n                }\n                else if (this.keysRotationOffsetIncr.indexOf(keyCode) !== -1 && this._modifierRotationOffset()) {\n                    this.camera.rotationOffset += this.rotationSensibility;\n                    this.camera.rotationOffset %= 360;\n                }\n                else if (this.keysRotationOffsetDecr.indexOf(keyCode) !== -1 && this._modifierRotationOffset()) {\n                    this.camera.rotationOffset -= this.rotationSensibility;\n                    this.camera.rotationOffset %= 360;\n                }\n                else if (this.keysRadiusIncr.indexOf(keyCode) !== -1 && this._modifierRadius()) {\n                    this.camera.radius += this.radiusSensibility;\n                }\n                else if (this.keysRadiusDecr.indexOf(keyCode) !== -1 && this._modifierRadius()) {\n                    this.camera.radius -= this.radiusSensibility;\n                }\n            });\n        }\n    }\n    /**\n     * Gets the class name of the current input.\n     * @returns the class name\n     */\n    getClassName() {\n        return \"FollowCameraKeyboardMoveInput\";\n    }\n    /**\n     * Get the friendly name associated with the input class.\n     * @returns the input friendly name\n     */\n    getSimpleName() {\n        return \"keyboard\";\n    }\n    /**\n     * Check if the pressed modifier keys (Alt/Ctrl/Shift) match those configured to\n     * allow modification of the heightOffset value.\n     */\n    _modifierHeightOffset() {\n        return (this.keysHeightOffsetModifierAlt === this._altPressed &&\n            this.keysHeightOffsetModifierCtrl === this._ctrlPressed &&\n            this.keysHeightOffsetModifierShift === this._shiftPressed);\n    }\n    /**\n     * Check if the pressed modifier keys (Alt/Ctrl/Shift) match those configured to\n     * allow modification of the rotationOffset value.\n     */\n    _modifierRotationOffset() {\n        return (this.keysRotationOffsetModifierAlt === this._altPressed &&\n            this.keysRotationOffsetModifierCtrl === this._ctrlPressed &&\n            this.keysRotationOffsetModifierShift === this._shiftPressed);\n    }\n    /**\n     * Check if the pressed modifier keys (Alt/Ctrl/Shift) match those configured to\n     * allow modification of the radius value.\n     */\n    _modifierRadius() {\n        return this.keysRadiusModifierAlt === this._altPressed && this.keysRadiusModifierCtrl === this._ctrlPressed && this.keysRadiusModifierShift === this._shiftPressed;\n    }\n}\n__decorate([\n    serialize()\n], FollowCameraKeyboardMoveInput.prototype, \"keysHeightOffsetIncr\", void 0);\n__decorate([\n    serialize()\n], FollowCameraKeyboardMoveInput.prototype, \"keysHeightOffsetDecr\", void 0);\n__decorate([\n    serialize()\n], FollowCameraKeyboardMoveInput.prototype, \"keysHeightOffsetModifierAlt\", void 0);\n__decorate([\n    serialize()\n], FollowCameraKeyboardMoveInput.prototype, \"keysHeightOffsetModifierCtrl\", void 0);\n__decorate([\n    serialize()\n], FollowCameraKeyboardMoveInput.prototype, \"keysHeightOffsetModifierShift\", void 0);\n__decorate([\n    serialize()\n], FollowCameraKeyboardMoveInput.prototype, \"keysRotationOffsetIncr\", void 0);\n__decorate([\n    serialize()\n], FollowCameraKeyboardMoveInput.prototype, \"keysRotationOffsetDecr\", void 0);\n__decorate([\n    serialize()\n], FollowCameraKeyboardMoveInput.prototype, \"keysRotationOffsetModifierAlt\", void 0);\n__decorate([\n    serialize()\n], FollowCameraKeyboardMoveInput.prototype, \"keysRotationOffsetModifierCtrl\", void 0);\n__decorate([\n    serialize()\n], FollowCameraKeyboardMoveInput.prototype, \"keysRotationOffsetModifierShift\", void 0);\n__decorate([\n    serialize()\n], FollowCameraKeyboardMoveInput.prototype, \"keysRadiusIncr\", void 0);\n__decorate([\n    serialize()\n], FollowCameraKeyboardMoveInput.prototype, \"keysRadiusDecr\", void 0);\n__decorate([\n    serialize()\n], FollowCameraKeyboardMoveInput.prototype, \"keysRadiusModifierAlt\", void 0);\n__decorate([\n    serialize()\n], FollowCameraKeyboardMoveInput.prototype, \"keysRadiusModifierCtrl\", void 0);\n__decorate([\n    serialize()\n], FollowCameraKeyboardMoveInput.prototype, \"keysRadiusModifierShift\", void 0);\n__decorate([\n    serialize()\n], FollowCameraKeyboardMoveInput.prototype, \"heightSensibility\", void 0);\n__decorate([\n    serialize()\n], FollowCameraKeyboardMoveInput.prototype, \"rotationSensibility\", void 0);\n__decorate([\n    serialize()\n], FollowCameraKeyboardMoveInput.prototype, \"radiusSensibility\", void 0);\nCameraInputTypes[\"FollowCameraKeyboardMoveInput\"] = FollowCameraKeyboardMoveInput;\n//# sourceMappingURL=followCameraKeyboardMoveInput.js.map","import { __decorate } from \"../../tslib.es6.js\";\nimport { serialize } from \"../../Misc/decorators.js\";\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager.js\";\nimport { PointerEventTypes } from \"../../Events/pointerEvents.js\";\nimport { Tools } from \"../../Misc/tools.js\";\n/**\n * Manage the mouse wheel inputs to control a follow camera.\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\n */\nexport class FollowCameraMouseWheelInput {\n    constructor() {\n        /**\n         * Moue wheel controls zoom. (Mouse wheel modifies camera.radius value.)\n         */\n        this.axisControlRadius = true;\n        /**\n         * Moue wheel controls height. (Mouse wheel modifies camera.heightOffset value.)\n         */\n        this.axisControlHeight = false;\n        /**\n         * Moue wheel controls angle. (Mouse wheel modifies camera.rotationOffset value.)\n         */\n        this.axisControlRotation = false;\n        /**\n         * Gets or Set the mouse wheel precision or how fast is the camera moves in\n         * relation to mouseWheel events.\n         */\n        this.wheelPrecision = 3.0;\n        /**\n         * wheelDeltaPercentage will be used instead of wheelPrecision if different from 0.\n         * It defines the percentage of current camera.radius to use as delta when wheel is used.\n         */\n        this.wheelDeltaPercentage = 0;\n    }\n    /**\n     * Attach the input controls to a specific dom element to get the input from.\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\n     */\n    attachControl(noPreventDefault) {\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\n        this._wheel = (p) => {\n            // sanity check - this should be a PointerWheel event.\n            if (p.type !== PointerEventTypes.POINTERWHEEL) {\n                return;\n            }\n            const event = p.event;\n            let delta = 0;\n            const wheelDelta = Math.max(-1, Math.min(1, event.deltaY));\n            if (this.wheelDeltaPercentage) {\n                console.assert(this.axisControlRadius + this.axisControlHeight + this.axisControlRotation <= 1, \"wheelDeltaPercentage only usable when mouse wheel \" +\n                    \"controls ONE axis. \" +\n                    \"Currently enabled: \" +\n                    \"axisControlRadius: \" +\n                    this.axisControlRadius +\n                    \", axisControlHeightOffset: \" +\n                    this.axisControlHeight +\n                    \", axisControlRotationOffset: \" +\n                    this.axisControlRotation);\n                if (this.axisControlRadius) {\n                    delta = wheelDelta * 0.01 * this.wheelDeltaPercentage * this.camera.radius;\n                }\n                else if (this.axisControlHeight) {\n                    delta = wheelDelta * 0.01 * this.wheelDeltaPercentage * this.camera.heightOffset;\n                }\n                else if (this.axisControlRotation) {\n                    delta = wheelDelta * 0.01 * this.wheelDeltaPercentage * this.camera.rotationOffset;\n                }\n            }\n            else {\n                delta = wheelDelta * this.wheelPrecision;\n            }\n            if (delta) {\n                if (this.axisControlRadius) {\n                    this.camera.radius += delta;\n                }\n                else if (this.axisControlHeight) {\n                    this.camera.heightOffset -= delta;\n                }\n                else if (this.axisControlRotation) {\n                    this.camera.rotationOffset -= delta;\n                }\n            }\n            if (event.preventDefault) {\n                if (!noPreventDefault) {\n                    event.preventDefault();\n                }\n            }\n        };\n        this._observer = this.camera.getScene()._inputManager._addCameraPointerObserver(this._wheel, PointerEventTypes.POINTERWHEEL);\n    }\n    /**\n     * Detach the current controls from the specified dom element.\n     */\n    detachControl() {\n        if (this._observer) {\n            this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer);\n            this._observer = null;\n            this._wheel = null;\n        }\n    }\n    /**\n     * Gets the class name of the current input.\n     * @returns the class name\n     */\n    getClassName() {\n        return \"ArcRotateCameraMouseWheelInput\";\n    }\n    /**\n     * Get the friendly name associated with the input class.\n     * @returns the input friendly name\n     */\n    getSimpleName() {\n        return \"mousewheel\";\n    }\n}\n__decorate([\n    serialize()\n], FollowCameraMouseWheelInput.prototype, \"axisControlRadius\", void 0);\n__decorate([\n    serialize()\n], FollowCameraMouseWheelInput.prototype, \"axisControlHeight\", void 0);\n__decorate([\n    serialize()\n], FollowCameraMouseWheelInput.prototype, \"axisControlRotation\", void 0);\n__decorate([\n    serialize()\n], FollowCameraMouseWheelInput.prototype, \"wheelPrecision\", void 0);\n__decorate([\n    serialize()\n], FollowCameraMouseWheelInput.prototype, \"wheelDeltaPercentage\", void 0);\nCameraInputTypes[\"FollowCameraMouseWheelInput\"] = FollowCameraMouseWheelInput;\n//# sourceMappingURL=followCameraMouseWheelInput.js.map","import { __decorate } from \"../../tslib.es6.js\";\nimport { serialize } from \"../../Misc/decorators.js\";\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager.js\";\nimport { BaseCameraPointersInput } from \"../../Cameras/Inputs/BaseCameraPointersInput.js\";\n/**\n * Manage the pointers inputs to control an follow camera.\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\n */\nexport class FollowCameraPointersInput extends BaseCameraPointersInput {\n    constructor() {\n        super(...arguments);\n        /**\n         * Defines the pointer angular sensibility along the X axis or how fast is\n         * the camera rotating.\n         * A negative number will reverse the axis direction.\n         */\n        this.angularSensibilityX = 1;\n        /**\n         * Defines the pointer angular sensibility along the Y axis or how fast is\n         * the camera rotating.\n         * A negative number will reverse the axis direction.\n         */\n        this.angularSensibilityY = 1;\n        /**\n         * Defines the pointer pinch precision or how fast is the camera zooming.\n         * A negative number will reverse the axis direction.\n         */\n        this.pinchPrecision = 10000.0;\n        /**\n         * pinchDeltaPercentage will be used instead of pinchPrecision if different\n         * from 0.\n         * It defines the percentage of current camera.radius to use as delta when\n         * pinch zoom is used.\n         */\n        this.pinchDeltaPercentage = 0;\n        /**\n         * Pointer X axis controls zoom. (X axis modifies camera.radius value.)\n         */\n        this.axisXControlRadius = false;\n        /**\n         * Pointer X axis controls height. (X axis modifies camera.heightOffset value.)\n         */\n        this.axisXControlHeight = false;\n        /**\n         * Pointer X axis controls angle. (X axis modifies camera.rotationOffset value.)\n         */\n        this.axisXControlRotation = true;\n        /**\n         * Pointer Y axis controls zoom. (Y axis modifies camera.radius value.)\n         */\n        this.axisYControlRadius = false;\n        /**\n         * Pointer Y axis controls height. (Y axis modifies camera.heightOffset value.)\n         */\n        this.axisYControlHeight = true;\n        /**\n         * Pointer Y axis controls angle. (Y axis modifies camera.rotationOffset value.)\n         */\n        this.axisYControlRotation = false;\n        /**\n         * Pinch controls zoom. (Pinch modifies camera.radius value.)\n         */\n        this.axisPinchControlRadius = true;\n        /**\n         * Pinch controls height. (Pinch modifies camera.heightOffset value.)\n         */\n        this.axisPinchControlHeight = false;\n        /**\n         * Pinch controls angle. (Pinch modifies camera.rotationOffset value.)\n         */\n        this.axisPinchControlRotation = false;\n        /**\n         * Log error messages if basic misconfiguration has occurred.\n         */\n        this.warningEnable = true;\n        /* Check for obvious misconfiguration. */\n        this._warningCounter = 0;\n    }\n    /**\n     * Gets the class name of the current input.\n     * @returns the class name\n     */\n    getClassName() {\n        return \"FollowCameraPointersInput\";\n    }\n    onTouch(pointA, offsetX, offsetY) {\n        this._warning();\n        if (this.axisXControlRotation) {\n            this.camera.rotationOffset += offsetX / this.angularSensibilityX;\n        }\n        else if (this.axisYControlRotation) {\n            this.camera.rotationOffset += offsetY / this.angularSensibilityX;\n        }\n        if (this.axisXControlHeight) {\n            this.camera.heightOffset += offsetX / this.angularSensibilityY;\n        }\n        else if (this.axisYControlHeight) {\n            this.camera.heightOffset += offsetY / this.angularSensibilityY;\n        }\n        if (this.axisXControlRadius) {\n            this.camera.radius -= offsetX / this.angularSensibilityY;\n        }\n        else if (this.axisYControlRadius) {\n            this.camera.radius -= offsetY / this.angularSensibilityY;\n        }\n    }\n    onMultiTouch(pointA, pointB, previousPinchSquaredDistance, pinchSquaredDistance, previousMultiTouchPanPosition, multiTouchPanPosition) {\n        if (previousPinchSquaredDistance === 0 && previousMultiTouchPanPosition === null) {\n            // First time this method is called for new pinch.\n            // Next time this is called there will be a\n            // previousPinchSquaredDistance and pinchSquaredDistance to compare.\n            return;\n        }\n        if (pinchSquaredDistance === 0 && multiTouchPanPosition === null) {\n            // Last time this method is called at the end of a pinch.\n            return;\n        }\n        let pinchDelta = (pinchSquaredDistance - previousPinchSquaredDistance) / ((this.pinchPrecision * (this.angularSensibilityX + this.angularSensibilityY)) / 2);\n        if (this.pinchDeltaPercentage) {\n            pinchDelta *= 0.01 * this.pinchDeltaPercentage;\n            if (this.axisPinchControlRotation) {\n                this.camera.rotationOffset += pinchDelta * this.camera.rotationOffset;\n            }\n            if (this.axisPinchControlHeight) {\n                this.camera.heightOffset += pinchDelta * this.camera.heightOffset;\n            }\n            if (this.axisPinchControlRadius) {\n                this.camera.radius -= pinchDelta * this.camera.radius;\n            }\n        }\n        else {\n            if (this.axisPinchControlRotation) {\n                this.camera.rotationOffset += pinchDelta;\n            }\n            if (this.axisPinchControlHeight) {\n                this.camera.heightOffset += pinchDelta;\n            }\n            if (this.axisPinchControlRadius) {\n                this.camera.radius -= pinchDelta;\n            }\n        }\n    }\n    _warning() {\n        if (!this.warningEnable || this._warningCounter++ % 100 !== 0) {\n            return;\n        }\n        const warn = \"It probably only makes sense to control ONE camera \" + \"property with each pointer axis. Set 'warningEnable = false' \" + \"if you are sure. Currently enabled: \";\n        console.assert(this.axisXControlRotation + this.axisXControlHeight + this.axisXControlRadius <= 1, warn + \"axisXControlRotation: \" + this.axisXControlRotation + \", axisXControlHeight: \" + this.axisXControlHeight + \", axisXControlRadius: \" + this.axisXControlRadius);\n        console.assert(this.axisYControlRotation + this.axisYControlHeight + this.axisYControlRadius <= 1, warn + \"axisYControlRotation: \" + this.axisYControlRotation + \", axisYControlHeight: \" + this.axisYControlHeight + \", axisYControlRadius: \" + this.axisYControlRadius);\n        console.assert(this.axisPinchControlRotation + this.axisPinchControlHeight + this.axisPinchControlRadius <= 1, warn +\n            \"axisPinchControlRotation: \" +\n            this.axisPinchControlRotation +\n            \", axisPinchControlHeight: \" +\n            this.axisPinchControlHeight +\n            \", axisPinchControlRadius: \" +\n            this.axisPinchControlRadius);\n    }\n}\n__decorate([\n    serialize()\n], FollowCameraPointersInput.prototype, \"angularSensibilityX\", void 0);\n__decorate([\n    serialize()\n], FollowCameraPointersInput.prototype, \"angularSensibilityY\", void 0);\n__decorate([\n    serialize()\n], FollowCameraPointersInput.prototype, \"pinchPrecision\", void 0);\n__decorate([\n    serialize()\n], FollowCameraPointersInput.prototype, \"pinchDeltaPercentage\", void 0);\n__decorate([\n    serialize()\n], FollowCameraPointersInput.prototype, \"axisXControlRadius\", void 0);\n__decorate([\n    serialize()\n], FollowCameraPointersInput.prototype, \"axisXControlHeight\", void 0);\n__decorate([\n    serialize()\n], FollowCameraPointersInput.prototype, \"axisXControlRotation\", void 0);\n__decorate([\n    serialize()\n], FollowCameraPointersInput.prototype, \"axisYControlRadius\", void 0);\n__decorate([\n    serialize()\n], FollowCameraPointersInput.prototype, \"axisYControlHeight\", void 0);\n__decorate([\n    serialize()\n], FollowCameraPointersInput.prototype, \"axisYControlRotation\", void 0);\n__decorate([\n    serialize()\n], FollowCameraPointersInput.prototype, \"axisPinchControlRadius\", void 0);\n__decorate([\n    serialize()\n], FollowCameraPointersInput.prototype, \"axisPinchControlHeight\", void 0);\n__decorate([\n    serialize()\n], FollowCameraPointersInput.prototype, \"axisPinchControlRotation\", void 0);\nCameraInputTypes[\"FollowCameraPointersInput\"] = FollowCameraPointersInput;\n//# sourceMappingURL=followCameraPointersInput.js.map","import { VirtualJoystick, JoystickAxis } from \"../../Misc/virtualJoystick.js\";\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager.js\";\nimport { Matrix, Vector3 } from \"../../Maths/math.vector.js\";\nimport { FreeCameraInputsManager } from \"../../Cameras/freeCameraInputsManager.js\";\n/**\n * Add virtual joystick input support to the input manager.\n * @returns the current input manager\n */\nFreeCameraInputsManager.prototype.addVirtualJoystick = function () {\n    this.add(new FreeCameraVirtualJoystickInput());\n    return this;\n};\n/**\n * Manage the Virtual Joystick inputs to control the movement of a free camera.\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\n */\nexport class FreeCameraVirtualJoystickInput {\n    /**\n     * Gets the left stick of the virtual joystick.\n     * @returns The virtual Joystick\n     */\n    getLeftJoystick() {\n        return this._leftjoystick;\n    }\n    /**\n     * Gets the right stick of the virtual joystick.\n     * @returns The virtual Joystick\n     */\n    getRightJoystick() {\n        return this._rightjoystick;\n    }\n    /**\n     * Update the current camera state depending on the inputs that have been used this frame.\n     * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.\n     */\n    checkInputs() {\n        if (this._leftjoystick) {\n            const camera = this.camera;\n            const speed = camera._computeLocalCameraSpeed() * 50;\n            const cameraTransform = Matrix.RotationYawPitchRoll(camera.rotation.y, camera.rotation.x, 0);\n            const deltaTransform = Vector3.TransformCoordinates(new Vector3(this._leftjoystick.deltaPosition.x * speed, this._leftjoystick.deltaPosition.y * speed, this._leftjoystick.deltaPosition.z * speed), cameraTransform);\n            camera.cameraDirection = camera.cameraDirection.add(deltaTransform);\n            camera.cameraRotation = camera.cameraRotation.addVector3(this._rightjoystick.deltaPosition);\n            if (!this._leftjoystick.pressed) {\n                this._leftjoystick.deltaPosition = this._leftjoystick.deltaPosition.scale(0.9);\n            }\n            if (!this._rightjoystick.pressed) {\n                this._rightjoystick.deltaPosition = this._rightjoystick.deltaPosition.scale(0.9);\n            }\n        }\n    }\n    /**\n     * Attach the input controls to a specific dom element to get the input from.\n     */\n    attachControl() {\n        this._leftjoystick = new VirtualJoystick(true);\n        this._leftjoystick.setAxisForUpDown(JoystickAxis.Z);\n        this._leftjoystick.setAxisForLeftRight(JoystickAxis.X);\n        this._leftjoystick.setJoystickSensibility(0.15);\n        this._rightjoystick = new VirtualJoystick(false);\n        this._rightjoystick.setAxisForUpDown(JoystickAxis.X);\n        this._rightjoystick.setAxisForLeftRight(JoystickAxis.Y);\n        this._rightjoystick.reverseUpDown = true;\n        this._rightjoystick.setJoystickSensibility(0.05);\n        this._rightjoystick.setJoystickColor(\"yellow\");\n    }\n    /**\n     * Detach the current controls from the specified dom element.\n     */\n    detachControl() {\n        this._leftjoystick.releaseCanvas();\n        this._rightjoystick.releaseCanvas();\n    }\n    /**\n     * Gets the class name of the current input.\n     * @returns the class name\n     */\n    getClassName() {\n        return \"FreeCameraVirtualJoystickInput\";\n    }\n    /**\n     * Get the friendly name associated with the input class.\n     * @returns the input friendly name\n     */\n    getSimpleName() {\n        return \"virtualJoystick\";\n    }\n}\nCameraInputTypes[\"FreeCameraVirtualJoystickInput\"] = FreeCameraVirtualJoystickInput;\n//# sourceMappingURL=freeCameraVirtualJoystickInput.js.map","import { CameraInputsManager } from \"./cameraInputsManager.js\";\nimport { FlyCameraMouseInput } from \"../Cameras/Inputs/flyCameraMouseInput.js\";\nimport { FlyCameraKeyboardInput } from \"../Cameras/Inputs/flyCameraKeyboardInput.js\";\n/**\n * Default Inputs manager for the FlyCamera.\n * It groups all the default supported inputs for ease of use.\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\n */\nexport class FlyCameraInputsManager extends CameraInputsManager {\n    /**\n     * Instantiates a new FlyCameraInputsManager.\n     * @param camera Defines the camera the inputs belong to.\n     */\n    constructor(camera) {\n        super(camera);\n    }\n    /**\n     * Add keyboard input support to the input manager.\n     * @returns the new FlyCameraKeyboardMoveInput().\n     */\n    addKeyboard() {\n        this.add(new FlyCameraKeyboardInput());\n        return this;\n    }\n    /**\n     * Add mouse input support to the input manager.\n     * @returns the new FlyCameraMouseInput().\n     */\n    addMouse() {\n        this.add(new FlyCameraMouseInput());\n        return this;\n    }\n}\n//# sourceMappingURL=flyCameraInputsManager.js.map","import { __decorate } from \"../tslib.es6.js\";\nimport { serialize, serializeAsVector3 } from \"../Misc/decorators.js\";\nimport { Vector3 } from \"../Maths/math.vector.js\";\nimport { Engine } from \"../Engines/engine.js\";\nimport { TargetCamera } from \"./targetCamera.js\";\nimport { FlyCameraInputsManager } from \"./flyCameraInputsManager.js\";\nimport { Tools } from \"../Misc/tools.js\";\n/**\n * This is a flying camera, designed for 3D movement and rotation in all directions,\n * such as in a 3D Space Shooter or a Flight Simulator.\n */\nexport class FlyCamera extends TargetCamera {\n    /**\n     * Gets the input sensibility for mouse input.\n     * Higher values reduce sensitivity.\n     */\n    get angularSensibility() {\n        const mouse = this.inputs.attached[\"mouse\"];\n        if (mouse) {\n            return mouse.angularSensibility;\n        }\n        return 0;\n    }\n    /**\n     * Sets the input sensibility for a mouse input.\n     * Higher values reduce sensitivity.\n     */\n    set angularSensibility(value) {\n        const mouse = this.inputs.attached[\"mouse\"];\n        if (mouse) {\n            mouse.angularSensibility = value;\n        }\n    }\n    /**\n     * Get the keys for camera movement forward.\n     */\n    get keysForward() {\n        const keyboard = this.inputs.attached[\"keyboard\"];\n        if (keyboard) {\n            return keyboard.keysForward;\n        }\n        return [];\n    }\n    /**\n     * Set the keys for camera movement forward.\n     */\n    set keysForward(value) {\n        const keyboard = this.inputs.attached[\"keyboard\"];\n        if (keyboard) {\n            keyboard.keysForward = value;\n        }\n    }\n    /**\n     * Get the keys for camera movement backward.\n     */\n    get keysBackward() {\n        const keyboard = this.inputs.attached[\"keyboard\"];\n        if (keyboard) {\n            return keyboard.keysBackward;\n        }\n        return [];\n    }\n    set keysBackward(value) {\n        const keyboard = this.inputs.attached[\"keyboard\"];\n        if (keyboard) {\n            keyboard.keysBackward = value;\n        }\n    }\n    /**\n     * Get the keys for camera movement up.\n     */\n    get keysUp() {\n        const keyboard = this.inputs.attached[\"keyboard\"];\n        if (keyboard) {\n            return keyboard.keysUp;\n        }\n        return [];\n    }\n    /**\n     * Set the keys for camera movement up.\n     */\n    set keysUp(value) {\n        const keyboard = this.inputs.attached[\"keyboard\"];\n        if (keyboard) {\n            keyboard.keysUp = value;\n        }\n    }\n    /**\n     * Get the keys for camera movement down.\n     */\n    get keysDown() {\n        const keyboard = this.inputs.attached[\"keyboard\"];\n        if (keyboard) {\n            return keyboard.keysDown;\n        }\n        return [];\n    }\n    /**\n     * Set the keys for camera movement down.\n     */\n    set keysDown(value) {\n        const keyboard = this.inputs.attached[\"keyboard\"];\n        if (keyboard) {\n            keyboard.keysDown = value;\n        }\n    }\n    /**\n     * Get the keys for camera movement left.\n     */\n    get keysLeft() {\n        const keyboard = this.inputs.attached[\"keyboard\"];\n        if (keyboard) {\n            return keyboard.keysLeft;\n        }\n        return [];\n    }\n    /**\n     * Set the keys for camera movement left.\n     */\n    set keysLeft(value) {\n        const keyboard = this.inputs.attached[\"keyboard\"];\n        if (keyboard) {\n            keyboard.keysLeft = value;\n        }\n    }\n    /**\n     * Set the keys for camera movement right.\n     */\n    get keysRight() {\n        const keyboard = this.inputs.attached[\"keyboard\"];\n        if (keyboard) {\n            return keyboard.keysRight;\n        }\n        return [];\n    }\n    /**\n     * Set the keys for camera movement right.\n     */\n    set keysRight(value) {\n        const keyboard = this.inputs.attached[\"keyboard\"];\n        if (keyboard) {\n            keyboard.keysRight = value;\n        }\n    }\n    /**\n     * Instantiates a FlyCamera.\n     * This is a flying camera, designed for 3D movement and rotation in all directions,\n     * such as in a 3D Space Shooter or a Flight Simulator.\n     * @param name Define the name of the camera in the scene.\n     * @param position Define the starting position of the camera in the scene.\n     * @param scene Define the scene the camera belongs to.\n     * @param setActiveOnSceneIfNoneActive Defines whether the camera should be marked as active, if no other camera has been defined as active.\n     */\n    constructor(name, position, scene, setActiveOnSceneIfNoneActive = true) {\n        super(name, position, scene, setActiveOnSceneIfNoneActive);\n        /**\n         * Define the collision ellipsoid of the camera.\n         * This is helpful for simulating a camera body, like a player's body.\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_collisions#arcrotatecamera\n         */\n        this.ellipsoid = new Vector3(1, 1, 1);\n        /**\n         * Define an offset for the position of the ellipsoid around the camera.\n         * This can be helpful if the camera is attached away from the player's body center,\n         * such as at its head.\n         */\n        this.ellipsoidOffset = new Vector3(0, 0, 0);\n        /**\n         * Enable or disable collisions of the camera with the rest of the scene objects.\n         */\n        this.checkCollisions = false;\n        /**\n         * Enable or disable gravity on the camera.\n         */\n        this.applyGravity = false;\n        /**\n         * Define the current direction the camera is moving to.\n         */\n        this.cameraDirection = Vector3.Zero();\n        /**\n         * Track Roll to maintain the wanted Rolling when looking around.\n         */\n        this._trackRoll = 0;\n        /**\n         * Slowly correct the Roll to its original value after a Pitch+Yaw rotation.\n         */\n        this.rollCorrect = 100;\n        /**\n         * Mimic a banked turn, Rolling the camera when Yawing.\n         * It's recommended to use rollCorrect = 10 for faster banking correction.\n         */\n        this.bankedTurn = false;\n        /**\n         * Limit in radians for how much Roll banking will add. (Default: 90)\n         */\n        this.bankedTurnLimit = Math.PI / 2;\n        /**\n         * Value of 0 disables the banked Roll.\n         * Value of 1 is equal to the Yaw angle in radians.\n         */\n        this.bankedTurnMultiplier = 1;\n        this._needMoveForGravity = false;\n        this._oldPosition = Vector3.Zero();\n        this._diffPosition = Vector3.Zero();\n        this._newPosition = Vector3.Zero();\n        // Collisions.\n        this._collisionMask = -1;\n        /**\n         * @internal\n         */\n        this._onCollisionPositionChange = (collisionId, newPosition, collidedMesh = null) => {\n            const updatePosition = (newPos) => {\n                this._newPosition.copyFrom(newPos);\n                this._newPosition.subtractToRef(this._oldPosition, this._diffPosition);\n                if (this._diffPosition.length() > Engine.CollisionsEpsilon) {\n                    this.position.addInPlace(this._diffPosition);\n                    if (this.onCollide && collidedMesh) {\n                        this.onCollide(collidedMesh);\n                    }\n                }\n            };\n            updatePosition(newPosition);\n        };\n        this.inputs = new FlyCameraInputsManager(this);\n        this.inputs.addKeyboard().addMouse();\n    }\n    /**\n     * Attached controls to the current camera.\n     * @param ignored defines an ignored parameter kept for backward compatibility.\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\n     */\n    attachControl(ignored, noPreventDefault) {\n        // eslint-disable-next-line prefer-rest-params\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\n        this.inputs.attachElement(noPreventDefault);\n    }\n    /**\n     * Detach a control from the HTML DOM element.\n     * The camera will stop reacting to that input.\n     */\n    detachControl() {\n        this.inputs.detachElement();\n        this.cameraDirection = new Vector3(0, 0, 0);\n    }\n    /**\n     * Get the mask that the camera ignores in collision events.\n     */\n    get collisionMask() {\n        return this._collisionMask;\n    }\n    /**\n     * Set the mask that the camera ignores in collision events.\n     */\n    set collisionMask(mask) {\n        this._collisionMask = !isNaN(mask) ? mask : -1;\n    }\n    /**\n     * @internal\n     */\n    _collideWithWorld(displacement) {\n        let globalPosition;\n        if (this.parent) {\n            globalPosition = Vector3.TransformCoordinates(this.position, this.parent.getWorldMatrix());\n        }\n        else {\n            globalPosition = this.position;\n        }\n        globalPosition.subtractFromFloatsToRef(0, this.ellipsoid.y, 0, this._oldPosition);\n        this._oldPosition.addInPlace(this.ellipsoidOffset);\n        const coordinator = this.getScene().collisionCoordinator;\n        if (!this._collider) {\n            this._collider = coordinator.createCollider();\n        }\n        this._collider._radius = this.ellipsoid;\n        this._collider.collisionMask = this._collisionMask;\n        // No need for clone, as long as gravity is not on.\n        let actualDisplacement = displacement;\n        // Add gravity to direction to prevent dual-collision checking.\n        if (this.applyGravity) {\n            // This prevents mending with cameraDirection, a global variable of the fly camera class.\n            actualDisplacement = displacement.add(this.getScene().gravity);\n        }\n        coordinator.getNewPosition(this._oldPosition, actualDisplacement, this._collider, 3, null, this._onCollisionPositionChange, this.uniqueId);\n    }\n    /** @internal */\n    _checkInputs() {\n        if (!this._localDirection) {\n            this._localDirection = Vector3.Zero();\n            this._transformedDirection = Vector3.Zero();\n        }\n        this.inputs.checkInputs();\n        super._checkInputs();\n    }\n    /** @internal */\n    _decideIfNeedsToMove() {\n        return this._needMoveForGravity || Math.abs(this.cameraDirection.x) > 0 || Math.abs(this.cameraDirection.y) > 0 || Math.abs(this.cameraDirection.z) > 0;\n    }\n    /** @internal */\n    _updatePosition() {\n        if (this.checkCollisions && this.getScene().collisionsEnabled) {\n            this._collideWithWorld(this.cameraDirection);\n        }\n        else {\n            super._updatePosition();\n        }\n    }\n    /**\n     * Restore the Roll to its target value at the rate specified.\n     * @param rate - Higher means slower restoring.\n     * @internal\n     */\n    restoreRoll(rate) {\n        const limit = this._trackRoll; // Target Roll.\n        const z = this.rotation.z; // Current Roll.\n        const delta = limit - z; // Difference in Roll.\n        const minRad = 0.001; // Tenth of a radian is a barely noticable difference.\n        // If the difference is noticable, restore the Roll.\n        if (Math.abs(delta) >= minRad) {\n            // Change Z rotation towards the target Roll.\n            this.rotation.z += delta / rate;\n            // Match when near enough.\n            if (Math.abs(limit - this.rotation.z) <= minRad) {\n                this.rotation.z = limit;\n            }\n        }\n    }\n    /**\n     * Destroy the camera and release the current resources held by it.\n     */\n    dispose() {\n        this.inputs.clear();\n        super.dispose();\n    }\n    /**\n     * Get the current object class name.\n     * @returns the class name.\n     */\n    getClassName() {\n        return \"FlyCamera\";\n    }\n}\n__decorate([\n    serializeAsVector3()\n], FlyCamera.prototype, \"ellipsoid\", void 0);\n__decorate([\n    serializeAsVector3()\n], FlyCamera.prototype, \"ellipsoidOffset\", void 0);\n__decorate([\n    serialize()\n], FlyCamera.prototype, \"checkCollisions\", void 0);\n__decorate([\n    serialize()\n], FlyCamera.prototype, \"applyGravity\", void 0);\n//# sourceMappingURL=flyCamera.js.map","import { CameraInputsManager } from \"./cameraInputsManager.js\";\nimport { FollowCameraKeyboardMoveInput } from \"./Inputs/followCameraKeyboardMoveInput.js\";\nimport { FollowCameraMouseWheelInput } from \"./Inputs/followCameraMouseWheelInput.js\";\nimport { FollowCameraPointersInput } from \"./Inputs/followCameraPointersInput.js\";\n/**\n * Default Inputs manager for the FollowCamera.\n * It groups all the default supported inputs for ease of use.\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\n */\nexport class FollowCameraInputsManager extends CameraInputsManager {\n    /**\n     * Instantiates a new FollowCameraInputsManager.\n     * @param camera Defines the camera the inputs belong to\n     */\n    constructor(camera) {\n        super(camera);\n    }\n    /**\n     * Add keyboard input support to the input manager.\n     * @returns the current input manager\n     */\n    addKeyboard() {\n        this.add(new FollowCameraKeyboardMoveInput());\n        return this;\n    }\n    /**\n     * Add mouse wheel input support to the input manager.\n     * @returns the current input manager\n     */\n    addMouseWheel() {\n        this.add(new FollowCameraMouseWheelInput());\n        return this;\n    }\n    /**\n     * Add pointers input support to the input manager.\n     * @returns the current input manager\n     */\n    addPointers() {\n        this.add(new FollowCameraPointersInput());\n        return this;\n    }\n    /**\n     * Add orientation input support to the input manager.\n     * @returns the current input manager\n     */\n    addVRDeviceOrientation() {\n        console.warn(\"DeviceOrientation support not yet implemented for FollowCamera.\");\n        return this;\n    }\n}\n//# sourceMappingURL=followCameraInputsManager.js.map","import { __decorate } from \"../tslib.es6.js\";\nimport { serialize, serializeAsMeshReference } from \"../Misc/decorators.js\";\nimport { Tools } from \"../Misc/tools.js\";\nimport { TargetCamera } from \"./targetCamera.js\";\nimport { TmpVectors, Vector3 } from \"../Maths/math.vector.js\";\nimport { Node } from \"../node.js\";\nimport { FollowCameraInputsManager } from \"./followCameraInputsManager.js\";\nNode.AddNodeConstructor(\"FollowCamera\", (name, scene) => {\n    return () => new FollowCamera(name, Vector3.Zero(), scene);\n});\nNode.AddNodeConstructor(\"ArcFollowCamera\", (name, scene) => {\n    return () => new ArcFollowCamera(name, 0, 0, 1.0, null, scene);\n});\n/**\n * A follow camera takes a mesh as a target and follows it as it moves. Both a free camera version followCamera and\n * an arc rotate version arcFollowCamera are available.\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_introduction#followcamera\n */\nexport class FollowCamera extends TargetCamera {\n    /**\n     * Instantiates the follow camera.\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_introduction#followcamera\n     * @param name Define the name of the camera in the scene\n     * @param position Define the position of the camera\n     * @param scene Define the scene the camera belong to\n     * @param lockedTarget Define the target of the camera\n     */\n    constructor(name, position, scene, lockedTarget = null) {\n        super(name, position, scene);\n        /**\n         * Distance the follow camera should follow an object at\n         */\n        this.radius = 12;\n        /**\n         * Minimum allowed distance of the camera to the axis of rotation\n         * (The camera can not get closer).\n         * This can help limiting how the Camera is able to move in the scene.\n         */\n        this.lowerRadiusLimit = null;\n        /**\n         * Maximum allowed distance of the camera to the axis of rotation\n         * (The camera can not get further).\n         * This can help limiting how the Camera is able to move in the scene.\n         */\n        this.upperRadiusLimit = null;\n        /**\n         * Define a rotation offset between the camera and the object it follows\n         */\n        this.rotationOffset = 0;\n        /**\n         * Minimum allowed angle to camera position relative to target object.\n         * This can help limiting how the Camera is able to move in the scene.\n         */\n        this.lowerRotationOffsetLimit = null;\n        /**\n         * Maximum allowed angle to camera position relative to target object.\n         * This can help limiting how the Camera is able to move in the scene.\n         */\n        this.upperRotationOffsetLimit = null;\n        /**\n         * Define a height offset between the camera and the object it follows.\n         * It can help following an object from the top (like a car chasing a plane)\n         */\n        this.heightOffset = 4;\n        /**\n         * Minimum allowed height of camera position relative to target object.\n         * This can help limiting how the Camera is able to move in the scene.\n         */\n        this.lowerHeightOffsetLimit = null;\n        /**\n         * Maximum allowed height of camera position relative to target object.\n         * This can help limiting how the Camera is able to move in the scene.\n         */\n        this.upperHeightOffsetLimit = null;\n        /**\n         * Define how fast the camera can accelerate to follow it s target.\n         */\n        this.cameraAcceleration = 0.05;\n        /**\n         * Define the speed limit of the camera following an object.\n         */\n        this.maxCameraSpeed = 20;\n        this.lockedTarget = lockedTarget;\n        this.inputs = new FollowCameraInputsManager(this);\n        this.inputs.addKeyboard().addMouseWheel().addPointers();\n        // Uncomment the following line when the relevant handlers have been implemented.\n        // this.inputs.addKeyboard().addMouseWheel().addPointers().addVRDeviceOrientation();\n    }\n    _follow(cameraTarget) {\n        if (!cameraTarget) {\n            return;\n        }\n        const rotMatrix = TmpVectors.Matrix[0];\n        cameraTarget.absoluteRotationQuaternion.toRotationMatrix(rotMatrix);\n        const yRotation = Math.atan2(rotMatrix.m[8], rotMatrix.m[10]);\n        const radians = Tools.ToRadians(this.rotationOffset) + yRotation;\n        const targetPosition = cameraTarget.getAbsolutePosition();\n        const targetX = targetPosition.x + Math.sin(radians) * this.radius;\n        const targetZ = targetPosition.z + Math.cos(radians) * this.radius;\n        const dx = targetX - this.position.x;\n        const dy = targetPosition.y + this.heightOffset - this.position.y;\n        const dz = targetZ - this.position.z;\n        let vx = dx * this.cameraAcceleration * 2; //this is set to .05\n        let vy = dy * this.cameraAcceleration;\n        let vz = dz * this.cameraAcceleration * 2;\n        if (vx > this.maxCameraSpeed || vx < -this.maxCameraSpeed) {\n            vx = vx < 1 ? -this.maxCameraSpeed : this.maxCameraSpeed;\n        }\n        if (vy > this.maxCameraSpeed || vy < -this.maxCameraSpeed) {\n            vy = vy < 1 ? -this.maxCameraSpeed : this.maxCameraSpeed;\n        }\n        if (vz > this.maxCameraSpeed || vz < -this.maxCameraSpeed) {\n            vz = vz < 1 ? -this.maxCameraSpeed : this.maxCameraSpeed;\n        }\n        this.position = new Vector3(this.position.x + vx, this.position.y + vy, this.position.z + vz);\n        this.setTarget(targetPosition);\n    }\n    /**\n     * Attached controls to the current camera.\n     * @param ignored defines an ignored parameter kept for backward compatibility.\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\n     */\n    attachControl(ignored, noPreventDefault) {\n        // eslint-disable-next-line prefer-rest-params\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\n        this.inputs.attachElement(noPreventDefault);\n        this._reset = () => { };\n    }\n    /**\n     * Detach the current controls from the specified dom element.\n     */\n    detachControl() {\n        this.inputs.detachElement();\n        if (this._reset) {\n            this._reset();\n        }\n    }\n    /** @internal */\n    _checkInputs() {\n        this.inputs.checkInputs();\n        this._checkLimits();\n        super._checkInputs();\n        if (this.lockedTarget) {\n            this._follow(this.lockedTarget);\n        }\n    }\n    _checkLimits() {\n        if (this.lowerRadiusLimit !== null && this.radius < this.lowerRadiusLimit) {\n            this.radius = this.lowerRadiusLimit;\n        }\n        if (this.upperRadiusLimit !== null && this.radius > this.upperRadiusLimit) {\n            this.radius = this.upperRadiusLimit;\n        }\n        if (this.lowerHeightOffsetLimit !== null && this.heightOffset < this.lowerHeightOffsetLimit) {\n            this.heightOffset = this.lowerHeightOffsetLimit;\n        }\n        if (this.upperHeightOffsetLimit !== null && this.heightOffset > this.upperHeightOffsetLimit) {\n            this.heightOffset = this.upperHeightOffsetLimit;\n        }\n        if (this.lowerRotationOffsetLimit !== null && this.rotationOffset < this.lowerRotationOffsetLimit) {\n            this.rotationOffset = this.lowerRotationOffsetLimit;\n        }\n        if (this.upperRotationOffsetLimit !== null && this.rotationOffset > this.upperRotationOffsetLimit) {\n            this.rotationOffset = this.upperRotationOffsetLimit;\n        }\n    }\n    /**\n     * Gets the camera class name.\n     * @returns the class name\n     */\n    getClassName() {\n        return \"FollowCamera\";\n    }\n}\n__decorate([\n    serialize()\n], FollowCamera.prototype, \"radius\", void 0);\n__decorate([\n    serialize()\n], FollowCamera.prototype, \"lowerRadiusLimit\", void 0);\n__decorate([\n    serialize()\n], FollowCamera.prototype, \"upperRadiusLimit\", void 0);\n__decorate([\n    serialize()\n], FollowCamera.prototype, \"rotationOffset\", void 0);\n__decorate([\n    serialize()\n], FollowCamera.prototype, \"lowerRotationOffsetLimit\", void 0);\n__decorate([\n    serialize()\n], FollowCamera.prototype, \"upperRotationOffsetLimit\", void 0);\n__decorate([\n    serialize()\n], FollowCamera.prototype, \"heightOffset\", void 0);\n__decorate([\n    serialize()\n], FollowCamera.prototype, \"lowerHeightOffsetLimit\", void 0);\n__decorate([\n    serialize()\n], FollowCamera.prototype, \"upperHeightOffsetLimit\", void 0);\n__decorate([\n    serialize()\n], FollowCamera.prototype, \"cameraAcceleration\", void 0);\n__decorate([\n    serialize()\n], FollowCamera.prototype, \"maxCameraSpeed\", void 0);\n__decorate([\n    serializeAsMeshReference(\"lockedTargetId\")\n], FollowCamera.prototype, \"lockedTarget\", void 0);\n/**\n * Arc Rotate version of the follow camera.\n * It still follows a Defined mesh but in an Arc Rotate Camera fashion.\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_introduction#followcamera\n */\nexport class ArcFollowCamera extends TargetCamera {\n    /**\n     * Instantiates a new ArcFollowCamera\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_introduction#followcamera\n     * @param name Define the name of the camera\n     * @param alpha Define the rotation angle of the camera around the longitudinal axis\n     * @param beta Define the rotation angle of the camera around the elevation axis\n     * @param radius Define the radius of the camera from its target point\n     * @param target Define the target of the camera\n     * @param scene Define the scene the camera belongs to\n     */\n    constructor(name, \n    /** The longitudinal angle of the camera */\n    alpha, \n    /** The latitudinal angle of the camera */\n    beta, \n    /** The radius of the camera from its target */\n    radius, \n    /** Define the camera target (the mesh it should follow) */\n    target, scene) {\n        super(name, Vector3.Zero(), scene);\n        this.alpha = alpha;\n        this.beta = beta;\n        this.radius = radius;\n        this._cartesianCoordinates = Vector3.Zero();\n        this.setMeshTarget(target);\n    }\n    /**\n     * Sets the mesh to follow with this camera.\n     * @param target the target to follow\n     */\n    setMeshTarget(target) {\n        this._meshTarget = target;\n        this._follow();\n    }\n    _follow() {\n        if (!this._meshTarget) {\n            return;\n        }\n        this._cartesianCoordinates.x = this.radius * Math.cos(this.alpha) * Math.cos(this.beta);\n        this._cartesianCoordinates.y = this.radius * Math.sin(this.beta);\n        this._cartesianCoordinates.z = this.radius * Math.sin(this.alpha) * Math.cos(this.beta);\n        const targetPosition = this._meshTarget.getAbsolutePosition();\n        this.position = targetPosition.add(this._cartesianCoordinates);\n        this.setTarget(targetPosition);\n    }\n    /** @internal */\n    _checkInputs() {\n        super._checkInputs();\n        this._follow();\n    }\n    /**\n     * Returns the class name of the object.\n     * It is mostly used internally for serialization purposes.\n     */\n    getClassName() {\n        return \"ArcFollowCamera\";\n    }\n}\n//# sourceMappingURL=followCamera.js.map","import { UniversalCamera } from \"./universalCamera.js\";\nimport { Vector3 } from \"../Maths/math.vector.js\";\nimport { Node } from \"../node.js\";\nNode.AddNodeConstructor(\"GamepadCamera\", (name, scene) => {\n    return () => new GamepadCamera(name, Vector3.Zero(), scene);\n});\n/**\n * This represents a FPS type of camera. This is only here for back compat purpose.\n * Please use the UniversalCamera instead as both are identical.\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_introduction#universal-camera\n */\nexport class GamepadCamera extends UniversalCamera {\n    /**\n     * Instantiates a new Gamepad Camera\n     * This represents a FPS type of camera. This is only here for back compat purpose.\n     * Please use the UniversalCamera instead as both are identical.\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_introduction#universal-camera\n     * @param name Define the name of the camera in the scene\n     * @param position Define the start position of the camera in the scene\n     * @param scene Define the scene the camera belongs to\n     */\n    constructor(name, position, scene) {\n        super(name, position, scene);\n    }\n    /**\n     * Gets the current object class name.\n     * @returns the class name\n     */\n    getClassName() {\n        return \"GamepadCamera\";\n    }\n}\n//# sourceMappingURL=gamepadCamera.js.map","import { PassPostProcess } from \"../../PostProcesses/passPostProcess.js\";\nimport { AnaglyphPostProcess } from \"../../PostProcesses/anaglyphPostProcess.js\";\n/**\n * @internal\n */\nexport function setStereoscopicAnaglyphRigMode(camera) {\n    camera._rigCameras[0]._rigPostProcess = new PassPostProcess(camera.name + \"_passthru\", 1.0, camera._rigCameras[0]);\n    camera._rigCameras[1]._rigPostProcess = new AnaglyphPostProcess(camera.name + \"_anaglyph\", 1.0, camera._rigCameras);\n}\n//# sourceMappingURL=stereoscopicAnaglyphRigMode.js.map","import { Camera } from \"../../Cameras/camera.js\";\nimport { ArcRotateCamera } from \"../../Cameras/arcRotateCamera.js\";\nimport { Vector3 } from \"../../Maths/math.vector.js\";\nimport { Node } from \"../../node.js\";\nimport { setStereoscopicAnaglyphRigMode } from \"../RigModes/stereoscopicAnaglyphRigMode.js\";\nNode.AddNodeConstructor(\"AnaglyphArcRotateCamera\", (name, scene, options) => {\n    return () => new AnaglyphArcRotateCamera(name, 0, 0, 1.0, Vector3.Zero(), options.interaxial_distance, scene);\n});\n/**\n * Camera used to simulate anaglyphic rendering (based on ArcRotateCamera)\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_introduction#anaglyph-cameras\n */\nexport class AnaglyphArcRotateCamera extends ArcRotateCamera {\n    /**\n     * Creates a new AnaglyphArcRotateCamera\n     * @param name defines camera name\n     * @param alpha defines alpha angle (in radians)\n     * @param beta defines beta angle (in radians)\n     * @param radius defines radius\n     * @param target defines camera target\n     * @param interaxialDistance defines distance between each color axis\n     * @param scene defines the hosting scene\n     */\n    constructor(name, alpha, beta, radius, target, interaxialDistance, scene) {\n        super(name, alpha, beta, radius, target, scene);\n        this._setRigMode = setStereoscopicAnaglyphRigMode.bind(null, this);\n        this.interaxialDistance = interaxialDistance;\n        this.setCameraRigMode(Camera.RIG_MODE_STEREOSCOPIC_ANAGLYPH, { interaxialDistance: interaxialDistance });\n    }\n    /**\n     * Gets camera class name\n     * @returns AnaglyphArcRotateCamera\n     */\n    getClassName() {\n        return \"AnaglyphArcRotateCamera\";\n    }\n}\n//# sourceMappingURL=anaglyphArcRotateCamera.js.map","import { Camera } from \"../../Cameras/camera.js\";\nimport { FreeCamera } from \"../../Cameras/freeCamera.js\";\nimport { Vector3 } from \"../../Maths/math.vector.js\";\nimport { Node } from \"../../node.js\";\nimport { setStereoscopicAnaglyphRigMode } from \"../RigModes/stereoscopicAnaglyphRigMode.js\";\nNode.AddNodeConstructor(\"AnaglyphFreeCamera\", (name, scene, options) => {\n    return () => new AnaglyphFreeCamera(name, Vector3.Zero(), options.interaxial_distance, scene);\n});\n/**\n * Camera used to simulate anaglyphic rendering (based on FreeCamera)\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_introduction#anaglyph-cameras\n */\nexport class AnaglyphFreeCamera extends FreeCamera {\n    /**\n     * Creates a new AnaglyphFreeCamera\n     * @param name defines camera name\n     * @param position defines initial position\n     * @param interaxialDistance defines distance between each color axis\n     * @param scene defines the hosting scene\n     */\n    constructor(name, position, interaxialDistance, scene) {\n        super(name, position, scene);\n        this._setRigMode = setStereoscopicAnaglyphRigMode.bind(null, this);\n        this.interaxialDistance = interaxialDistance;\n        this.setCameraRigMode(Camera.RIG_MODE_STEREOSCOPIC_ANAGLYPH, { interaxialDistance: interaxialDistance });\n    }\n    /**\n     * Gets camera class name\n     * @returns AnaglyphFreeCamera\n     */\n    getClassName() {\n        return \"AnaglyphFreeCamera\";\n    }\n}\n//# sourceMappingURL=anaglyphFreeCamera.js.map","import { Camera } from \"../../Cameras/camera.js\";\nimport { GamepadCamera } from \"../../Cameras/gamepadCamera.js\";\nimport { Vector3 } from \"../../Maths/math.vector.js\";\nimport { Node } from \"../../node.js\";\nimport { setStereoscopicAnaglyphRigMode } from \"../RigModes/stereoscopicAnaglyphRigMode.js\";\nNode.AddNodeConstructor(\"AnaglyphGamepadCamera\", (name, scene, options) => {\n    return () => new AnaglyphGamepadCamera(name, Vector3.Zero(), options.interaxial_distance, scene);\n});\n/**\n * Camera used to simulate anaglyphic rendering (based on GamepadCamera)\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_introduction#anaglyph-cameras\n */\nexport class AnaglyphGamepadCamera extends GamepadCamera {\n    /**\n     * Creates a new AnaglyphGamepadCamera\n     * @param name defines camera name\n     * @param position defines initial position\n     * @param interaxialDistance defines distance between each color axis\n     * @param scene defines the hosting scene\n     */\n    constructor(name, position, interaxialDistance, scene) {\n        super(name, position, scene);\n        this._setRigMode = setStereoscopicAnaglyphRigMode.bind(null, this);\n        this.interaxialDistance = interaxialDistance;\n        this.setCameraRigMode(Camera.RIG_MODE_STEREOSCOPIC_ANAGLYPH, { interaxialDistance: interaxialDistance });\n    }\n    /**\n     * Gets camera class name\n     * @returns AnaglyphGamepadCamera\n     */\n    getClassName() {\n        return \"AnaglyphGamepadCamera\";\n    }\n}\n//# sourceMappingURL=anaglyphGamepadCamera.js.map","import { Camera } from \"../../Cameras/camera.js\";\nimport { UniversalCamera } from \"../../Cameras/universalCamera.js\";\nimport { Vector3 } from \"../../Maths/math.vector.js\";\nimport { Node } from \"../../node.js\";\nimport { setStereoscopicAnaglyphRigMode } from \"../RigModes/stereoscopicAnaglyphRigMode.js\";\nNode.AddNodeConstructor(\"AnaglyphUniversalCamera\", (name, scene, options) => {\n    return () => new AnaglyphUniversalCamera(name, Vector3.Zero(), options.interaxial_distance, scene);\n});\n/**\n * Camera used to simulate anaglyphic rendering (based on UniversalCamera)\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_introduction#anaglyph-cameras\n */\nexport class AnaglyphUniversalCamera extends UniversalCamera {\n    /**\n     * Creates a new AnaglyphUniversalCamera\n     * @param name defines camera name\n     * @param position defines initial position\n     * @param interaxialDistance defines distance between each color axis\n     * @param scene defines the hosting scene\n     */\n    constructor(name, position, interaxialDistance, scene) {\n        super(name, position, scene);\n        this._setRigMode = setStereoscopicAnaglyphRigMode.bind(null, this);\n        this.interaxialDistance = interaxialDistance;\n        this.setCameraRigMode(Camera.RIG_MODE_STEREOSCOPIC_ANAGLYPH, { interaxialDistance: interaxialDistance });\n    }\n    /**\n     * Gets camera class name\n     * @returns AnaglyphUniversalCamera\n     */\n    getClassName() {\n        return \"AnaglyphUniversalCamera\";\n    }\n}\n//# sourceMappingURL=anaglyphUniversalCamera.js.map","import { Camera } from \"../camera.js\";\nimport { Viewport } from \"../../Maths/math.viewport.js\";\nimport { PassPostProcess } from \"../../PostProcesses/passPostProcess.js\";\nimport { StereoscopicInterlacePostProcessI } from \"../../PostProcesses/stereoscopicInterlacePostProcess.js\";\n/**\n * @internal\n */\nexport function setStereoscopicRigMode(camera) {\n    const isStereoscopicHoriz = camera.cameraRigMode === Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL || camera.cameraRigMode === Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED;\n    const isCrossEye = camera.cameraRigMode === Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED;\n    const isInterlaced = camera.cameraRigMode === Camera.RIG_MODE_STEREOSCOPIC_INTERLACED;\n    // Use post-processors for interlacing\n    if (isInterlaced) {\n        camera._rigCameras[0]._rigPostProcess = new PassPostProcess(camera.name + \"_passthru\", 1.0, camera._rigCameras[0]);\n        camera._rigCameras[1]._rigPostProcess = new StereoscopicInterlacePostProcessI(camera.name + \"_stereoInterlace\", camera._rigCameras, false, true);\n    }\n    // Otherwise, create appropriate viewports\n    else {\n        camera._rigCameras[isCrossEye ? 1 : 0].viewport = new Viewport(0, 0, isStereoscopicHoriz ? 0.5 : 1.0, isStereoscopicHoriz ? 1.0 : 0.5);\n        camera._rigCameras[isCrossEye ? 0 : 1].viewport = new Viewport(isStereoscopicHoriz ? 0.5 : 0, isStereoscopicHoriz ? 0 : 0.5, isStereoscopicHoriz ? 0.5 : 1.0, isStereoscopicHoriz ? 1.0 : 0.5);\n    }\n}\n//# sourceMappingURL=stereoscopicRigMode.js.map","import { Camera } from \"../../Cameras/camera.js\";\nimport { ArcRotateCamera } from \"../../Cameras/arcRotateCamera.js\";\nimport { Vector3 } from \"../../Maths/math.vector.js\";\nimport { Node } from \"../../node.js\";\nimport { setStereoscopicRigMode } from \"../RigModes/stereoscopicRigMode.js\";\nNode.AddNodeConstructor(\"StereoscopicArcRotateCamera\", (name, scene, options) => {\n    return () => new StereoscopicArcRotateCamera(name, 0, 0, 1.0, Vector3.Zero(), options.interaxial_distance, options.isStereoscopicSideBySide, scene);\n});\n/**\n * Camera used to simulate stereoscopic rendering (based on ArcRotateCamera)\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras\n */\nexport class StereoscopicArcRotateCamera extends ArcRotateCamera {\n    /**\n     * Creates a new StereoscopicArcRotateCamera\n     * @param name defines camera name\n     * @param alpha defines alpha angle (in radians)\n     * @param beta defines beta angle (in radians)\n     * @param radius defines radius\n     * @param target defines camera target\n     * @param interaxialDistance defines distance between each color axis\n     * @param isStereoscopicSideBySide defines is stereoscopic is done side by side or over under\n     * @param scene defines the hosting scene\n     */\n    constructor(name, alpha, beta, radius, target, interaxialDistance, isStereoscopicSideBySide, scene) {\n        super(name, alpha, beta, radius, target, scene);\n        this._setRigMode = setStereoscopicRigMode.bind(null, this);\n        this.interaxialDistance = interaxialDistance;\n        this.isStereoscopicSideBySide = isStereoscopicSideBySide;\n        this.setCameraRigMode(isStereoscopicSideBySide ? Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL : Camera.RIG_MODE_STEREOSCOPIC_OVERUNDER, {\n            interaxialDistance: interaxialDistance,\n        });\n    }\n    /**\n     * Gets camera class name\n     * @returns StereoscopicArcRotateCamera\n     */\n    getClassName() {\n        return \"StereoscopicArcRotateCamera\";\n    }\n}\n//# sourceMappingURL=stereoscopicArcRotateCamera.js.map","import { Camera } from \"../../Cameras/camera.js\";\nimport { FreeCamera } from \"../../Cameras/freeCamera.js\";\nimport { Vector3 } from \"../../Maths/math.vector.js\";\nimport { Node } from \"../../node.js\";\nimport { setStereoscopicRigMode } from \"../RigModes/stereoscopicRigMode.js\";\nNode.AddNodeConstructor(\"StereoscopicFreeCamera\", (name, scene, options) => {\n    return () => new StereoscopicFreeCamera(name, Vector3.Zero(), options.interaxial_distance, options.isStereoscopicSideBySide, scene);\n});\n/**\n * Camera used to simulate stereoscopic rendering (based on FreeCamera)\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras\n */\nexport class StereoscopicFreeCamera extends FreeCamera {\n    /**\n     * Creates a new StereoscopicFreeCamera\n     * @param name defines camera name\n     * @param position defines initial position\n     * @param interaxialDistance defines distance between each color axis\n     * @param isStereoscopicSideBySide defines is stereoscopic is done side by side or over under\n     * @param scene defines the hosting scene\n     */\n    constructor(name, position, interaxialDistance, isStereoscopicSideBySide, scene) {\n        super(name, position, scene);\n        this._setRigMode = setStereoscopicRigMode.bind(null, this);\n        this.interaxialDistance = interaxialDistance;\n        this.isStereoscopicSideBySide = isStereoscopicSideBySide;\n        this.setCameraRigMode(isStereoscopicSideBySide ? Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL : Camera.RIG_MODE_STEREOSCOPIC_OVERUNDER, {\n            interaxialDistance: interaxialDistance,\n        });\n    }\n    /**\n     * Gets camera class name\n     * @returns StereoscopicFreeCamera\n     */\n    getClassName() {\n        return \"StereoscopicFreeCamera\";\n    }\n}\n//# sourceMappingURL=stereoscopicFreeCamera.js.map","import { Camera } from \"../../Cameras/camera.js\";\nimport { GamepadCamera } from \"../../Cameras/gamepadCamera.js\";\nimport { Vector3 } from \"../../Maths/math.vector.js\";\nimport { Node } from \"../../node.js\";\nimport { setStereoscopicRigMode } from \"../RigModes/stereoscopicRigMode.js\";\nNode.AddNodeConstructor(\"StereoscopicGamepadCamera\", (name, scene, options) => {\n    return () => new StereoscopicGamepadCamera(name, Vector3.Zero(), options.interaxial_distance, options.isStereoscopicSideBySide, scene);\n});\n/**\n * Camera used to simulate stereoscopic rendering (based on GamepadCamera)\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras\n */\nexport class StereoscopicGamepadCamera extends GamepadCamera {\n    /**\n     * Creates a new StereoscopicGamepadCamera\n     * @param name defines camera name\n     * @param position defines initial position\n     * @param interaxialDistance defines distance between each color axis\n     * @param isStereoscopicSideBySide defines is stereoscopic is done side by side or over under\n     * @param scene defines the hosting scene\n     */\n    constructor(name, position, interaxialDistance, isStereoscopicSideBySide, scene) {\n        super(name, position, scene);\n        this._setRigMode = setStereoscopicRigMode.bind(null, this);\n        this.interaxialDistance = interaxialDistance;\n        this.isStereoscopicSideBySide = isStereoscopicSideBySide;\n        this.setCameraRigMode(isStereoscopicSideBySide ? Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL : Camera.RIG_MODE_STEREOSCOPIC_OVERUNDER, {\n            interaxialDistance: interaxialDistance,\n        });\n    }\n    /**\n     * Gets camera class name\n     * @returns StereoscopicGamepadCamera\n     */\n    getClassName() {\n        return \"StereoscopicGamepadCamera\";\n    }\n}\n//# sourceMappingURL=stereoscopicGamepadCamera.js.map","import { Camera } from \"../../Cameras/camera.js\";\nimport { UniversalCamera } from \"../../Cameras/universalCamera.js\";\nimport { Vector3 } from \"../../Maths/math.vector.js\";\nimport { Node } from \"../../node.js\";\nimport { setStereoscopicRigMode } from \"../RigModes/stereoscopicRigMode.js\";\nNode.AddNodeConstructor(\"StereoscopicFreeCamera\", (name, scene, options) => {\n    return () => new StereoscopicUniversalCamera(name, Vector3.Zero(), options.interaxial_distance, options.isStereoscopicSideBySide, scene);\n});\n/**\n * Camera used to simulate stereoscopic rendering (based on UniversalCamera)\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras\n */\nexport class StereoscopicUniversalCamera extends UniversalCamera {\n    /**\n     * Creates a new StereoscopicUniversalCamera\n     * @param name defines camera name\n     * @param position defines initial position\n     * @param interaxialDistance defines distance between each color axis\n     * @param isStereoscopicSideBySide defines is stereoscopic is done side by side or over under\n     * @param scene defines the hosting scene\n     */\n    constructor(name, position, interaxialDistance, isStereoscopicSideBySide, scene) {\n        super(name, position, scene);\n        this._setRigMode = setStereoscopicRigMode.bind(null, this);\n        this.interaxialDistance = interaxialDistance;\n        this.isStereoscopicSideBySide = isStereoscopicSideBySide;\n        this.setCameraRigMode(isStereoscopicSideBySide ? Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL : Camera.RIG_MODE_STEREOSCOPIC_OVERUNDER, {\n            interaxialDistance: interaxialDistance,\n        });\n    }\n    /**\n     * Gets camera class name\n     * @returns StereoscopicUniversalCamera\n     */\n    getClassName() {\n        return \"StereoscopicUniversalCamera\";\n    }\n}\n//# sourceMappingURL=stereoscopicUniversalCamera.js.map","import { FreeCamera } from \"./freeCamera.js\";\nimport { Vector3 } from \"../Maths/math.vector.js\";\nimport { Node } from \"../node.js\";\nimport \"./Inputs/freeCameraVirtualJoystickInput.js\";\nNode.AddNodeConstructor(\"VirtualJoysticksCamera\", (name, scene) => {\n    return () => new VirtualJoysticksCamera(name, Vector3.Zero(), scene);\n});\n/**\n * This represents a free type of camera. It can be useful in First Person Shooter game for instance.\n * It is identical to the Free Camera and simply adds by default a virtual joystick.\n * Virtual Joysticks are on-screen 2D graphics that are used to control the camera or other scene items.\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_introduction#virtual-joysticks-camera\n */\nexport class VirtualJoysticksCamera extends FreeCamera {\n    /**\n     * Instantiates a VirtualJoysticksCamera. It can be useful in First Person Shooter game for instance.\n     * It is identical to the Free Camera and simply adds by default a virtual joystick.\n     * Virtual Joysticks are on-screen 2D graphics that are used to control the camera or other scene items.\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_introduction#virtual-joysticks-camera\n     * @param name Define the name of the camera in the scene\n     * @param position Define the start position of the camera in the scene\n     * @param scene Define the scene the camera belongs to\n     */\n    constructor(name, position, scene) {\n        super(name, position, scene);\n        this.inputs.addVirtualJoystick();\n    }\n    /**\n     * Gets the current object class name.\n     * @returns the class name\n     */\n    getClassName() {\n        return \"VirtualJoysticksCamera\";\n    }\n}\n//# sourceMappingURL=virtualJoysticksCamera.js.map","import { Camera } from \"../../Cameras/camera.js\";\nimport { ArcRotateCamera } from \"../../Cameras/arcRotateCamera.js\";\nimport { VRCameraMetrics } from \"./vrCameraMetrics.js\";\nimport { Vector3 } from \"../../Maths/math.vector.js\";\nimport { Node } from \"../../node.js\";\nimport { setVRRigMode } from \"../RigModes/vrRigMode.js\";\nimport \"../Inputs/arcRotateCameraVRDeviceOrientationInput.js\";\nNode.AddNodeConstructor(\"VRDeviceOrientationArcRotateCamera\", (name, scene) => {\n    return () => new VRDeviceOrientationArcRotateCamera(name, 0, 0, 1.0, Vector3.Zero(), scene);\n});\n/**\n * Camera used to simulate VR rendering (based on ArcRotateCamera)\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_introduction#vr-device-orientation-cameras\n */\nexport class VRDeviceOrientationArcRotateCamera extends ArcRotateCamera {\n    /**\n     * Creates a new VRDeviceOrientationArcRotateCamera\n     * @param name defines camera name\n     * @param alpha defines the camera rotation along the longitudinal axis\n     * @param beta defines the camera rotation along the latitudinal axis\n     * @param radius defines the camera distance from its target\n     * @param target defines the camera target\n     * @param scene defines the scene the camera belongs to\n     * @param compensateDistortion defines if the camera needs to compensate the lens distortion\n     * @param vrCameraMetrics defines the vr metrics associated to the camera\n     */\n    constructor(name, alpha, beta, radius, target, scene, compensateDistortion = true, vrCameraMetrics = VRCameraMetrics.GetDefault()) {\n        super(name, alpha, beta, radius, target, scene);\n        this._setRigMode = setVRRigMode.bind(null, this);\n        vrCameraMetrics.compensateDistortion = compensateDistortion;\n        this.setCameraRigMode(Camera.RIG_MODE_VR, { vrCameraMetrics: vrCameraMetrics });\n        this.inputs.addVRDeviceOrientation();\n    }\n    /**\n     * Gets camera class name\n     * @returns VRDeviceOrientationArcRotateCamera\n     */\n    getClassName() {\n        return \"VRDeviceOrientationArcRotateCamera\";\n    }\n}\n//# sourceMappingURL=vrDeviceOrientationArcRotateCamera.js.map","import { VRDeviceOrientationFreeCamera } from \"./vrDeviceOrientationFreeCamera.js\";\nimport { VRCameraMetrics } from \"./vrCameraMetrics.js\";\nimport { Vector3 } from \"../../Maths/math.vector.js\";\nimport { Node } from \"../../node.js\";\nimport { setVRRigMode } from \"../RigModes/vrRigMode.js\";\nimport \"../../Gamepads/gamepadSceneComponent.js\";\nNode.AddNodeConstructor(\"VRDeviceOrientationGamepadCamera\", (name, scene) => {\n    return () => new VRDeviceOrientationGamepadCamera(name, Vector3.Zero(), scene);\n});\n/**\n * Camera used to simulate VR rendering (based on VRDeviceOrientationFreeCamera)\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_introduction#vr-device-orientation-cameras\n */\nexport class VRDeviceOrientationGamepadCamera extends VRDeviceOrientationFreeCamera {\n    /**\n     * Creates a new VRDeviceOrientationGamepadCamera\n     * @param name defines camera name\n     * @param position defines the start position of the camera\n     * @param scene defines the scene the camera belongs to\n     * @param compensateDistortion defines if the camera needs to compensate the lens distortion\n     * @param vrCameraMetrics defines the vr metrics associated to the camera\n     */\n    constructor(name, position, scene, compensateDistortion = true, vrCameraMetrics = VRCameraMetrics.GetDefault()) {\n        super(name, position, scene, compensateDistortion, vrCameraMetrics);\n        this._setRigMode = setVRRigMode.bind(null, this);\n        this.inputs.addGamepad();\n    }\n    /**\n     * Gets camera class name\n     * @returns VRDeviceOrientationGamepadCamera\n     */\n    getClassName() {\n        return \"VRDeviceOrientationGamepadCamera\";\n    }\n}\n//# sourceMappingURL=vrDeviceOrientationGamepadCamera.js.map","import { __decorate } from \"../tslib.es6.js\";\nimport { serialize, serializeAsVector3, serializeAsMeshReference } from \"../Misc/decorators.js\";\nimport { Camera } from \"./camera.js\";\nimport { Quaternion, Matrix, Vector3, Vector2, TmpVectors } from \"../Maths/math.vector.js\";\nimport { Epsilon } from \"../Maths/math.constants.js\";\nimport { Axis } from \"../Maths/math.axis.js\";\n/**\n * A target camera takes a mesh or position as a target and continues to look at it while it moves.\n * This is the base of the follow, arc rotate cameras and Free camera\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras\n */\nexport class TargetCamera extends Camera {\n    /**\n     * Instantiates a target camera that takes a mesh or position as a target and continues to look at it while it moves.\n     * This is the base of the follow, arc rotate cameras and Free camera\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras\n     * @param name Defines the name of the camera in the scene\n     * @param position Defines the start position of the camera in the scene\n     * @param scene Defines the scene the camera belongs to\n     * @param setActiveOnSceneIfNoneActive Defines whether the camera should be marked as active if not other active cameras have been defined\n     */\n    constructor(name, position, scene, setActiveOnSceneIfNoneActive = true) {\n        super(name, position, scene, setActiveOnSceneIfNoneActive);\n        this._tmpUpVector = Vector3.Zero();\n        this._tmpTargetVector = Vector3.Zero();\n        /**\n         * Define the current direction the camera is moving to\n         */\n        this.cameraDirection = new Vector3(0, 0, 0);\n        /**\n         * Define the current rotation the camera is rotating to\n         */\n        this.cameraRotation = new Vector2(0, 0);\n        /** Gets or sets a boolean indicating that the scaling of the parent hierarchy will not be taken in account by the camera */\n        this.ignoreParentScaling = false;\n        /**\n         * When set, the up vector of the camera will be updated by the rotation of the camera\n         */\n        this.updateUpVectorFromRotation = false;\n        this._tmpQuaternion = new Quaternion();\n        /**\n         * Define the current rotation of the camera\n         */\n        this.rotation = new Vector3(0, 0, 0);\n        /**\n         * Define the current speed of the camera\n         */\n        this.speed = 2.0;\n        /**\n         * Add constraint to the camera to prevent it to move freely in all directions and\n         * around all axis.\n         */\n        this.noRotationConstraint = false;\n        /**\n         * Reverses mouselook direction to 'natural' panning as opposed to traditional direct\n         * panning\n         */\n        this.invertRotation = false;\n        /**\n         * Speed multiplier for inverse camera panning\n         */\n        this.inverseRotationSpeed = 0.2;\n        /**\n         * Define the current target of the camera as an object or a position.\n         * Please note that locking a target will disable panning.\n         */\n        this.lockedTarget = null;\n        /** @internal */\n        this._currentTarget = Vector3.Zero();\n        /** @internal */\n        this._initialFocalDistance = 1;\n        /** @internal */\n        this._viewMatrix = Matrix.Zero();\n        /** @internal */\n        this._camMatrix = Matrix.Zero();\n        /** @internal */\n        this._cameraTransformMatrix = Matrix.Zero();\n        /** @internal */\n        this._cameraRotationMatrix = Matrix.Zero();\n        /** @internal */\n        this._referencePoint = new Vector3(0, 0, 1);\n        /** @internal */\n        this._transformedReferencePoint = Vector3.Zero();\n        this._defaultUp = Vector3.Up();\n        this._cachedRotationZ = 0;\n        this._cachedQuaternionRotationZ = 0;\n    }\n    /**\n     * Gets the position in front of the camera at a given distance.\n     * @param distance The distance from the camera we want the position to be\n     * @returns the position\n     */\n    getFrontPosition(distance) {\n        this.getWorldMatrix();\n        const direction = this.getTarget().subtract(this.position);\n        direction.normalize();\n        direction.scaleInPlace(distance);\n        return this.globalPosition.add(direction);\n    }\n    /** @internal */\n    _getLockedTargetPosition() {\n        if (!this.lockedTarget) {\n            return null;\n        }\n        if (this.lockedTarget.absolutePosition) {\n            this.lockedTarget.computeWorldMatrix();\n        }\n        return this.lockedTarget.absolutePosition || this.lockedTarget;\n    }\n    /**\n     * Store current camera state of the camera (fov, position, rotation, etc..)\n     * @returns the camera\n     */\n    storeState() {\n        this._storedPosition = this.position.clone();\n        this._storedRotation = this.rotation.clone();\n        if (this.rotationQuaternion) {\n            this._storedRotationQuaternion = this.rotationQuaternion.clone();\n        }\n        return super.storeState();\n    }\n    /**\n     * Restored camera state. You must call storeState() first\n     * @returns whether it was successful or not\n     * @internal\n     */\n    _restoreStateValues() {\n        if (!super._restoreStateValues()) {\n            return false;\n        }\n        this.position = this._storedPosition.clone();\n        this.rotation = this._storedRotation.clone();\n        if (this.rotationQuaternion) {\n            this.rotationQuaternion = this._storedRotationQuaternion.clone();\n        }\n        this.cameraDirection.copyFromFloats(0, 0, 0);\n        this.cameraRotation.copyFromFloats(0, 0);\n        return true;\n    }\n    /** @internal */\n    _initCache() {\n        super._initCache();\n        this._cache.lockedTarget = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\n        this._cache.rotation = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\n        this._cache.rotationQuaternion = new Quaternion(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\n    }\n    /**\n     * @internal\n     */\n    _updateCache(ignoreParentClass) {\n        if (!ignoreParentClass) {\n            super._updateCache();\n        }\n        const lockedTargetPosition = this._getLockedTargetPosition();\n        if (!lockedTargetPosition) {\n            this._cache.lockedTarget = null;\n        }\n        else {\n            if (!this._cache.lockedTarget) {\n                this._cache.lockedTarget = lockedTargetPosition.clone();\n            }\n            else {\n                this._cache.lockedTarget.copyFrom(lockedTargetPosition);\n            }\n        }\n        this._cache.rotation.copyFrom(this.rotation);\n        if (this.rotationQuaternion) {\n            this._cache.rotationQuaternion.copyFrom(this.rotationQuaternion);\n        }\n    }\n    // Synchronized\n    /** @internal */\n    _isSynchronizedViewMatrix() {\n        if (!super._isSynchronizedViewMatrix()) {\n            return false;\n        }\n        const lockedTargetPosition = this._getLockedTargetPosition();\n        return ((this._cache.lockedTarget ? this._cache.lockedTarget.equals(lockedTargetPosition) : !lockedTargetPosition) &&\n            (this.rotationQuaternion ? this.rotationQuaternion.equals(this._cache.rotationQuaternion) : this._cache.rotation.equals(this.rotation)));\n    }\n    // Methods\n    /** @internal */\n    _computeLocalCameraSpeed() {\n        const engine = this.getEngine();\n        return this.speed * Math.sqrt(engine.getDeltaTime() / (engine.getFps() * 100.0));\n    }\n    // Target\n    /**\n     * Defines the target the camera should look at.\n     * @param target Defines the new target as a Vector\n     */\n    setTarget(target) {\n        this.upVector.normalize();\n        this._initialFocalDistance = target.subtract(this.position).length();\n        if (this.position.z === target.z) {\n            this.position.z += Epsilon;\n        }\n        this._referencePoint.normalize().scaleInPlace(this._initialFocalDistance);\n        Matrix.LookAtLHToRef(this.position, target, this._defaultUp, this._camMatrix);\n        this._camMatrix.invert();\n        this.rotation.x = Math.atan(this._camMatrix.m[6] / this._camMatrix.m[10]);\n        const vDir = target.subtract(this.position);\n        if (vDir.x >= 0.0) {\n            this.rotation.y = -Math.atan(vDir.z / vDir.x) + Math.PI / 2.0;\n        }\n        else {\n            this.rotation.y = -Math.atan(vDir.z / vDir.x) - Math.PI / 2.0;\n        }\n        this.rotation.z = 0;\n        if (isNaN(this.rotation.x)) {\n            this.rotation.x = 0;\n        }\n        if (isNaN(this.rotation.y)) {\n            this.rotation.y = 0;\n        }\n        if (isNaN(this.rotation.z)) {\n            this.rotation.z = 0;\n        }\n        if (this.rotationQuaternion) {\n            Quaternion.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, this.rotationQuaternion);\n        }\n    }\n    /**\n     * Defines the target point of the camera.\n     * The camera looks towards it form the radius distance.\n     */\n    get target() {\n        return this.getTarget();\n    }\n    set target(value) {\n        this.setTarget(value);\n    }\n    /**\n     * Return the current target position of the camera. This value is expressed in local space.\n     * @returns the target position\n     */\n    getTarget() {\n        return this._currentTarget;\n    }\n    /** @internal */\n    _decideIfNeedsToMove() {\n        return Math.abs(this.cameraDirection.x) > 0 || Math.abs(this.cameraDirection.y) > 0 || Math.abs(this.cameraDirection.z) > 0;\n    }\n    /** @internal */\n    _updatePosition() {\n        if (this.parent) {\n            this.parent.getWorldMatrix().invertToRef(TmpVectors.Matrix[0]);\n            Vector3.TransformNormalToRef(this.cameraDirection, TmpVectors.Matrix[0], TmpVectors.Vector3[0]);\n            this.position.addInPlace(TmpVectors.Vector3[0]);\n            return;\n        }\n        this.position.addInPlace(this.cameraDirection);\n    }\n    /** @internal */\n    _checkInputs() {\n        const directionMultiplier = this.invertRotation ? -this.inverseRotationSpeed : 1.0;\n        const needToMove = this._decideIfNeedsToMove();\n        const needToRotate = Math.abs(this.cameraRotation.x) > 0 || Math.abs(this.cameraRotation.y) > 0;\n        // Move\n        if (needToMove) {\n            this._updatePosition();\n        }\n        // Rotate\n        if (needToRotate) {\n            //rotate, if quaternion is set and rotation was used\n            if (this.rotationQuaternion) {\n                this.rotationQuaternion.toEulerAnglesToRef(this.rotation);\n            }\n            this.rotation.x += this.cameraRotation.x * directionMultiplier;\n            this.rotation.y += this.cameraRotation.y * directionMultiplier;\n            // Apply constraints\n            if (!this.noRotationConstraint) {\n                const limit = 1.570796;\n                if (this.rotation.x > limit) {\n                    this.rotation.x = limit;\n                }\n                if (this.rotation.x < -limit) {\n                    this.rotation.x = -limit;\n                }\n            }\n            //rotate, if quaternion is set and rotation was used\n            if (this.rotationQuaternion) {\n                const len = this.rotation.lengthSquared();\n                if (len) {\n                    Quaternion.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, this.rotationQuaternion);\n                }\n            }\n        }\n        // Inertia\n        if (needToMove) {\n            if (Math.abs(this.cameraDirection.x) < this.speed * Epsilon) {\n                this.cameraDirection.x = 0;\n            }\n            if (Math.abs(this.cameraDirection.y) < this.speed * Epsilon) {\n                this.cameraDirection.y = 0;\n            }\n            if (Math.abs(this.cameraDirection.z) < this.speed * Epsilon) {\n                this.cameraDirection.z = 0;\n            }\n            this.cameraDirection.scaleInPlace(this.inertia);\n        }\n        if (needToRotate) {\n            if (Math.abs(this.cameraRotation.x) < this.speed * Epsilon) {\n                this.cameraRotation.x = 0;\n            }\n            if (Math.abs(this.cameraRotation.y) < this.speed * Epsilon) {\n                this.cameraRotation.y = 0;\n            }\n            this.cameraRotation.scaleInPlace(this.inertia);\n        }\n        super._checkInputs();\n    }\n    _updateCameraRotationMatrix() {\n        if (this.rotationQuaternion) {\n            this.rotationQuaternion.toRotationMatrix(this._cameraRotationMatrix);\n        }\n        else {\n            Matrix.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, this._cameraRotationMatrix);\n        }\n    }\n    /**\n     * Update the up vector to apply the rotation of the camera (So if you changed the camera rotation.z this will let you update the up vector as well)\n     * @returns the current camera\n     */\n    _rotateUpVectorWithCameraRotationMatrix() {\n        Vector3.TransformNormalToRef(this._defaultUp, this._cameraRotationMatrix, this.upVector);\n        return this;\n    }\n    /** @internal */\n    _getViewMatrix() {\n        if (this.lockedTarget) {\n            this.setTarget(this._getLockedTargetPosition());\n        }\n        // Compute\n        this._updateCameraRotationMatrix();\n        // Apply the changed rotation to the upVector\n        if (this.rotationQuaternion && this._cachedQuaternionRotationZ != this.rotationQuaternion.z) {\n            this._rotateUpVectorWithCameraRotationMatrix();\n            this._cachedQuaternionRotationZ = this.rotationQuaternion.z;\n        }\n        else if (this._cachedRotationZ !== this.rotation.z) {\n            this._rotateUpVectorWithCameraRotationMatrix();\n            this._cachedRotationZ = this.rotation.z;\n        }\n        Vector3.TransformCoordinatesToRef(this._referencePoint, this._cameraRotationMatrix, this._transformedReferencePoint);\n        // Computing target and final matrix\n        this.position.addToRef(this._transformedReferencePoint, this._currentTarget);\n        if (this.updateUpVectorFromRotation) {\n            if (this.rotationQuaternion) {\n                Axis.Y.rotateByQuaternionToRef(this.rotationQuaternion, this.upVector);\n            }\n            else {\n                Quaternion.FromEulerVectorToRef(this.rotation, this._tmpQuaternion);\n                Axis.Y.rotateByQuaternionToRef(this._tmpQuaternion, this.upVector);\n            }\n        }\n        this._computeViewMatrix(this.position, this._currentTarget, this.upVector);\n        return this._viewMatrix;\n    }\n    _computeViewMatrix(position, target, up) {\n        if (this.ignoreParentScaling) {\n            if (this.parent) {\n                const parentWorldMatrix = this.parent.getWorldMatrix();\n                Vector3.TransformCoordinatesToRef(position, parentWorldMatrix, this._globalPosition);\n                Vector3.TransformCoordinatesToRef(target, parentWorldMatrix, this._tmpTargetVector);\n                Vector3.TransformNormalToRef(up, parentWorldMatrix, this._tmpUpVector);\n                this._markSyncedWithParent();\n            }\n            else {\n                this._globalPosition.copyFrom(position);\n                this._tmpTargetVector.copyFrom(target);\n                this._tmpUpVector.copyFrom(up);\n            }\n            if (this.getScene().useRightHandedSystem) {\n                Matrix.LookAtRHToRef(this._globalPosition, this._tmpTargetVector, this._tmpUpVector, this._viewMatrix);\n            }\n            else {\n                Matrix.LookAtLHToRef(this._globalPosition, this._tmpTargetVector, this._tmpUpVector, this._viewMatrix);\n            }\n            return;\n        }\n        if (this.getScene().useRightHandedSystem) {\n            Matrix.LookAtRHToRef(position, target, up, this._viewMatrix);\n        }\n        else {\n            Matrix.LookAtLHToRef(position, target, up, this._viewMatrix);\n        }\n        if (this.parent) {\n            const parentWorldMatrix = this.parent.getWorldMatrix();\n            this._viewMatrix.invert();\n            this._viewMatrix.multiplyToRef(parentWorldMatrix, this._viewMatrix);\n            this._viewMatrix.getTranslationToRef(this._globalPosition);\n            this._viewMatrix.invert();\n            this._markSyncedWithParent();\n        }\n        else {\n            this._globalPosition.copyFrom(position);\n        }\n    }\n    /**\n     * @internal\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    createRigCamera(name, cameraIndex) {\n        if (this.cameraRigMode !== Camera.RIG_MODE_NONE) {\n            const rigCamera = new TargetCamera(name, this.position.clone(), this.getScene());\n            rigCamera.isRigCamera = true;\n            rigCamera.rigParent = this;\n            if (this.cameraRigMode === Camera.RIG_MODE_VR || this.cameraRigMode === Camera.RIG_MODE_WEBVR) {\n                if (!this.rotationQuaternion) {\n                    this.rotationQuaternion = new Quaternion();\n                }\n                rigCamera._cameraRigParams = {};\n                rigCamera.rotationQuaternion = new Quaternion();\n            }\n            rigCamera.mode = this.mode;\n            rigCamera.orthoLeft = this.orthoLeft;\n            rigCamera.orthoRight = this.orthoRight;\n            rigCamera.orthoTop = this.orthoTop;\n            rigCamera.orthoBottom = this.orthoBottom;\n            return rigCamera;\n        }\n        return null;\n    }\n    /**\n     * @internal\n     */\n    _updateRigCameras() {\n        const camLeft = this._rigCameras[0];\n        const camRight = this._rigCameras[1];\n        this.computeWorldMatrix();\n        switch (this.cameraRigMode) {\n            case Camera.RIG_MODE_STEREOSCOPIC_ANAGLYPH:\n            case Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL:\n            case Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED:\n            case Camera.RIG_MODE_STEREOSCOPIC_OVERUNDER:\n            case Camera.RIG_MODE_STEREOSCOPIC_INTERLACED: {\n                //provisionnaly using _cameraRigParams.stereoHalfAngle instead of calculations based on _cameraRigParams.interaxialDistance:\n                const leftSign = this.cameraRigMode === Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED ? 1 : -1;\n                const rightSign = this.cameraRigMode === Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED ? -1 : 1;\n                this._getRigCamPositionAndTarget(this._cameraRigParams.stereoHalfAngle * leftSign, camLeft);\n                this._getRigCamPositionAndTarget(this._cameraRigParams.stereoHalfAngle * rightSign, camRight);\n                break;\n            }\n            case Camera.RIG_MODE_VR:\n                if (camLeft.rotationQuaternion) {\n                    camLeft.rotationQuaternion.copyFrom(this.rotationQuaternion);\n                    camRight.rotationQuaternion.copyFrom(this.rotationQuaternion);\n                }\n                else {\n                    camLeft.rotation.copyFrom(this.rotation);\n                    camRight.rotation.copyFrom(this.rotation);\n                }\n                camLeft.position.copyFrom(this.position);\n                camRight.position.copyFrom(this.position);\n                break;\n        }\n        super._updateRigCameras();\n    }\n    _getRigCamPositionAndTarget(halfSpace, rigCamera) {\n        const target = this.getTarget();\n        target.subtractToRef(this.position, TargetCamera._TargetFocalPoint);\n        TargetCamera._TargetFocalPoint.normalize().scaleInPlace(this._initialFocalDistance);\n        const newFocalTarget = TargetCamera._TargetFocalPoint.addInPlace(this.position);\n        Matrix.TranslationToRef(-newFocalTarget.x, -newFocalTarget.y, -newFocalTarget.z, TargetCamera._TargetTransformMatrix);\n        TargetCamera._TargetTransformMatrix.multiplyToRef(Matrix.RotationAxis(rigCamera.upVector, halfSpace), TargetCamera._RigCamTransformMatrix);\n        Matrix.TranslationToRef(newFocalTarget.x, newFocalTarget.y, newFocalTarget.z, TargetCamera._TargetTransformMatrix);\n        TargetCamera._RigCamTransformMatrix.multiplyToRef(TargetCamera._TargetTransformMatrix, TargetCamera._RigCamTransformMatrix);\n        Vector3.TransformCoordinatesToRef(this.position, TargetCamera._RigCamTransformMatrix, rigCamera.position);\n        rigCamera.setTarget(newFocalTarget);\n    }\n    /**\n     * Gets the current object class name.\n     * @returns the class name\n     */\n    getClassName() {\n        return \"TargetCamera\";\n    }\n}\nTargetCamera._RigCamTransformMatrix = new Matrix();\nTargetCamera._TargetTransformMatrix = new Matrix();\nTargetCamera._TargetFocalPoint = new Vector3();\n__decorate([\n    serializeAsVector3()\n], TargetCamera.prototype, \"rotation\", void 0);\n__decorate([\n    serialize()\n], TargetCamera.prototype, \"speed\", void 0);\n__decorate([\n    serializeAsMeshReference(\"lockedTargetId\")\n], TargetCamera.prototype, \"lockedTarget\", void 0);\n//# sourceMappingURL=targetCamera.js.map","import { FreeCamera } from \"./freeCamera.js\";\nimport { Vector3 } from \"../Maths/math.vector.js\";\nimport { Node } from \"../node.js\";\nNode.AddNodeConstructor(\"TouchCamera\", (name, scene) => {\n    return () => new TouchCamera(name, Vector3.Zero(), scene);\n});\n/**\n * This represents a FPS type of camera controlled by touch.\n * This is like a universal camera minus the Gamepad controls.\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_introduction#universal-camera\n */\nexport class TouchCamera extends FreeCamera {\n    /**\n     * Defines the touch sensibility for rotation.\n     * The higher the faster.\n     */\n    get touchAngularSensibility() {\n        const touch = this.inputs.attached[\"touch\"];\n        if (touch) {\n            return touch.touchAngularSensibility;\n        }\n        return 0;\n    }\n    set touchAngularSensibility(value) {\n        const touch = this.inputs.attached[\"touch\"];\n        if (touch) {\n            touch.touchAngularSensibility = value;\n        }\n    }\n    /**\n     * Defines the touch sensibility for move.\n     * The higher the faster.\n     */\n    get touchMoveSensibility() {\n        const touch = this.inputs.attached[\"touch\"];\n        if (touch) {\n            return touch.touchMoveSensibility;\n        }\n        return 0;\n    }\n    set touchMoveSensibility(value) {\n        const touch = this.inputs.attached[\"touch\"];\n        if (touch) {\n            touch.touchMoveSensibility = value;\n        }\n    }\n    /**\n     * Instantiates a new touch camera.\n     * This represents a FPS type of camera controlled by touch.\n     * This is like a universal camera minus the Gamepad controls.\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_introduction#universal-camera\n     * @param name Define the name of the camera in the scene\n     * @param position Define the start position of the camera in the scene\n     * @param scene Define the scene the camera belongs to\n     */\n    constructor(name, position, scene) {\n        super(name, position, scene);\n        this.inputs.addTouch();\n        this._setupInputs();\n    }\n    /**\n     * Gets the current object class name.\n     * @returns the class name\n     */\n    getClassName() {\n        return \"TouchCamera\";\n    }\n    /** @internal */\n    _setupInputs() {\n        const touch = this.inputs.attached[\"touch\"];\n        const mouse = this.inputs.attached[\"mouse\"];\n        if (mouse) {\n            mouse.touchEnabled = false;\n        }\n        else {\n            touch.allowMouse = true;\n        }\n    }\n}\n//# sourceMappingURL=touchCamera.js.map","import { TouchCamera } from \"./touchCamera.js\";\nimport { Node } from \"../node.js\";\nimport { Vector3 } from \"../Maths/math.vector.js\";\nimport { Camera } from \"./camera.js\";\nimport \"../Gamepads/gamepadSceneComponent.js\";\nNode.AddNodeConstructor(\"FreeCamera\", (name, scene) => {\n    // Forcing to use the Universal camera\n    return () => new UniversalCamera(name, Vector3.Zero(), scene);\n});\n/**\n * The Universal Camera is the one to choose for first person shooter type games, and works with all the keyboard, mouse, touch and gamepads. This replaces the earlier Free Camera,\n * which still works and will still be found in many Playgrounds.\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_introduction#universal-camera\n */\nexport class UniversalCamera extends TouchCamera {\n    /**\n     * Defines the gamepad rotation sensibility.\n     * This is the threshold from when rotation starts to be accounted for to prevent jittering.\n     */\n    get gamepadAngularSensibility() {\n        const gamepad = this.inputs.attached[\"gamepad\"];\n        if (gamepad) {\n            return gamepad.gamepadAngularSensibility;\n        }\n        return 0;\n    }\n    set gamepadAngularSensibility(value) {\n        const gamepad = this.inputs.attached[\"gamepad\"];\n        if (gamepad) {\n            gamepad.gamepadAngularSensibility = value;\n        }\n    }\n    /**\n     * Defines the gamepad move sensibility.\n     * This is the threshold from when moving starts to be accounted for to prevent jittering.\n     */\n    get gamepadMoveSensibility() {\n        const gamepad = this.inputs.attached[\"gamepad\"];\n        if (gamepad) {\n            return gamepad.gamepadMoveSensibility;\n        }\n        return 0;\n    }\n    set gamepadMoveSensibility(value) {\n        const gamepad = this.inputs.attached[\"gamepad\"];\n        if (gamepad) {\n            gamepad.gamepadMoveSensibility = value;\n        }\n    }\n    /**\n     * The Universal Camera is the one to choose for first person shooter type games, and works with all the keyboard, mouse, touch and gamepads. This replaces the earlier Free Camera,\n     * which still works and will still be found in many Playgrounds.\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_introduction#universal-camera\n     * @param name Define the name of the camera in the scene\n     * @param position Define the start position of the camera in the scene\n     * @param scene Define the scene the camera belongs to\n     */\n    constructor(name, position, scene) {\n        super(name, position, scene);\n        this.inputs.addGamepad();\n    }\n    /**\n     * Gets the current object class name.\n     * @returns the class name\n     */\n    getClassName() {\n        return \"UniversalCamera\";\n    }\n}\nCamera._CreateDefaultParsedCamera = (name, scene) => {\n    return new UniversalCamera(name, Vector3.Zero(), scene);\n};\n//# sourceMappingURL=universalCamera.js.map","import { Vector3 } from \"../Maths/math.vector.js\";\nimport { Plane } from \"../Maths/math.plane.js\";\nconst intersectBoxAASphere = (boxMin, boxMax, sphereCenter, sphereRadius) => {\n    if (boxMin.x > sphereCenter.x + sphereRadius) {\n        return false;\n    }\n    if (sphereCenter.x - sphereRadius > boxMax.x) {\n        return false;\n    }\n    if (boxMin.y > sphereCenter.y + sphereRadius) {\n        return false;\n    }\n    if (sphereCenter.y - sphereRadius > boxMax.y) {\n        return false;\n    }\n    if (boxMin.z > sphereCenter.z + sphereRadius) {\n        return false;\n    }\n    if (sphereCenter.z - sphereRadius > boxMax.z) {\n        return false;\n    }\n    return true;\n};\nconst getLowestRoot = (function () {\n    const result = { root: 0, found: false };\n    return function (a, b, c, maxR) {\n        result.root = 0;\n        result.found = false;\n        const determinant = b * b - 4.0 * a * c;\n        if (determinant < 0) {\n            return result;\n        }\n        const sqrtD = Math.sqrt(determinant);\n        let r1 = (-b - sqrtD) / (2.0 * a);\n        let r2 = (-b + sqrtD) / (2.0 * a);\n        if (r1 > r2) {\n            const temp = r2;\n            r2 = r1;\n            r1 = temp;\n        }\n        if (r1 > 0 && r1 < maxR) {\n            result.root = r1;\n            result.found = true;\n            return result;\n        }\n        if (r2 > 0 && r2 < maxR) {\n            result.root = r2;\n            result.found = true;\n            return result;\n        }\n        return result;\n    };\n})();\n/** @internal */\nexport class Collider {\n    constructor() {\n        // Implementation of the \"Improved Collision detection and Response\" algorithm proposed by Kasper Fauerby\n        // https://www.peroxide.dk/papers/collision/collision.pdf\n        this._collisionPoint = Vector3.Zero();\n        this._planeIntersectionPoint = Vector3.Zero();\n        this._tempVector = Vector3.Zero();\n        this._tempVector2 = Vector3.Zero();\n        this._tempVector3 = Vector3.Zero();\n        this._tempVector4 = Vector3.Zero();\n        this._edge = Vector3.Zero();\n        this._baseToVertex = Vector3.Zero();\n        this._destinationPoint = Vector3.Zero();\n        this._slidePlaneNormal = Vector3.Zero();\n        this._displacementVector = Vector3.Zero();\n        /** @internal */\n        this._radius = Vector3.One();\n        /** @internal */\n        this._retry = 0;\n        /** @internal */\n        this._basePointWorld = Vector3.Zero();\n        this._velocityWorld = Vector3.Zero();\n        this._normalizedVelocity = Vector3.Zero();\n        this._collisionMask = -1;\n    }\n    get collisionMask() {\n        return this._collisionMask;\n    }\n    set collisionMask(mask) {\n        this._collisionMask = !isNaN(mask) ? mask : -1;\n    }\n    /**\n     * Gets the plane normal used to compute the sliding response (in local space)\n     */\n    get slidePlaneNormal() {\n        return this._slidePlaneNormal;\n    }\n    // Methods\n    /**\n     * @internal\n     */\n    _initialize(source, dir, e) {\n        this._velocity = dir;\n        this._velocitySquaredLength = this._velocity.lengthSquared();\n        const len = Math.sqrt(this._velocitySquaredLength);\n        if (len === 0 || len === 1.0) {\n            this._normalizedVelocity.copyFromFloats(dir._x, dir._y, dir._z);\n        }\n        else {\n            dir.scaleToRef(1.0 / len, this._normalizedVelocity);\n        }\n        this._basePoint = source;\n        source.multiplyToRef(this._radius, this._basePointWorld);\n        dir.multiplyToRef(this._radius, this._velocityWorld);\n        this._velocityWorldLength = this._velocityWorld.length();\n        this._epsilon = e;\n        this.collisionFound = false;\n    }\n    /**\n     * @internal\n     */\n    _checkPointInTriangle(point, pa, pb, pc, n) {\n        pa.subtractToRef(point, this._tempVector);\n        pb.subtractToRef(point, this._tempVector2);\n        Vector3.CrossToRef(this._tempVector, this._tempVector2, this._tempVector4);\n        let d = Vector3.Dot(this._tempVector4, n);\n        if (d < 0) {\n            return false;\n        }\n        pc.subtractToRef(point, this._tempVector3);\n        Vector3.CrossToRef(this._tempVector2, this._tempVector3, this._tempVector4);\n        d = Vector3.Dot(this._tempVector4, n);\n        if (d < 0) {\n            return false;\n        }\n        Vector3.CrossToRef(this._tempVector3, this._tempVector, this._tempVector4);\n        d = Vector3.Dot(this._tempVector4, n);\n        return d >= 0;\n    }\n    /**\n     * @internal\n     */\n    _canDoCollision(sphereCenter, sphereRadius, vecMin, vecMax) {\n        const distance = Vector3.Distance(this._basePointWorld, sphereCenter);\n        const max = Math.max(this._radius.x, this._radius.y, this._radius.z);\n        if (distance > this._velocityWorldLength + max + sphereRadius) {\n            return false;\n        }\n        if (!intersectBoxAASphere(vecMin, vecMax, this._basePointWorld, this._velocityWorldLength + max)) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * @internal\n     */\n    _testTriangle(faceIndex, trianglePlaneArray, p1, p2, p3, hasMaterial, hostMesh) {\n        let t0;\n        let embeddedInPlane = false;\n        //defensive programming, actually not needed.\n        if (!trianglePlaneArray) {\n            trianglePlaneArray = [];\n        }\n        if (!trianglePlaneArray[faceIndex]) {\n            trianglePlaneArray[faceIndex] = new Plane(0, 0, 0, 0);\n            trianglePlaneArray[faceIndex].copyFromPoints(p1, p2, p3);\n        }\n        const trianglePlane = trianglePlaneArray[faceIndex];\n        if (!hasMaterial && !trianglePlane.isFrontFacingTo(this._normalizedVelocity, 0)) {\n            return;\n        }\n        const signedDistToTrianglePlane = trianglePlane.signedDistanceTo(this._basePoint);\n        const normalDotVelocity = Vector3.Dot(trianglePlane.normal, this._velocity);\n        // if DoubleSidedCheck is false(default), a double sided face will be consided 2 times.\n        // if true, it discard the faces having normal not facing velocity\n        if (Collider.DoubleSidedCheck && normalDotVelocity > 0.0001) {\n            return;\n        }\n        if (normalDotVelocity == 0) {\n            if (Math.abs(signedDistToTrianglePlane) >= 1.0) {\n                return;\n            }\n            embeddedInPlane = true;\n            t0 = 0;\n        }\n        else {\n            t0 = (-1.0 - signedDistToTrianglePlane) / normalDotVelocity;\n            let t1 = (1.0 - signedDistToTrianglePlane) / normalDotVelocity;\n            if (t0 > t1) {\n                const temp = t1;\n                t1 = t0;\n                t0 = temp;\n            }\n            if (t0 > 1.0 || t1 < 0.0) {\n                return;\n            }\n            if (t0 < 0) {\n                t0 = 0;\n            }\n            if (t0 > 1.0) {\n                t0 = 1.0;\n            }\n        }\n        this._collisionPoint.copyFromFloats(0, 0, 0);\n        let found = false;\n        let t = 1.0;\n        if (!embeddedInPlane) {\n            this._basePoint.subtractToRef(trianglePlane.normal, this._planeIntersectionPoint);\n            this._velocity.scaleToRef(t0, this._tempVector);\n            this._planeIntersectionPoint.addInPlace(this._tempVector);\n            if (this._checkPointInTriangle(this._planeIntersectionPoint, p1, p2, p3, trianglePlane.normal)) {\n                found = true;\n                t = t0;\n                this._collisionPoint.copyFrom(this._planeIntersectionPoint);\n            }\n        }\n        if (!found) {\n            let a = this._velocitySquaredLength;\n            this._basePoint.subtractToRef(p1, this._tempVector);\n            let b = 2.0 * Vector3.Dot(this._velocity, this._tempVector);\n            let c = this._tempVector.lengthSquared() - 1.0;\n            let lowestRoot = getLowestRoot(a, b, c, t);\n            if (lowestRoot.found) {\n                t = lowestRoot.root;\n                found = true;\n                this._collisionPoint.copyFrom(p1);\n            }\n            this._basePoint.subtractToRef(p2, this._tempVector);\n            b = 2.0 * Vector3.Dot(this._velocity, this._tempVector);\n            c = this._tempVector.lengthSquared() - 1.0;\n            lowestRoot = getLowestRoot(a, b, c, t);\n            if (lowestRoot.found) {\n                t = lowestRoot.root;\n                found = true;\n                this._collisionPoint.copyFrom(p2);\n            }\n            this._basePoint.subtractToRef(p3, this._tempVector);\n            b = 2.0 * Vector3.Dot(this._velocity, this._tempVector);\n            c = this._tempVector.lengthSquared() - 1.0;\n            lowestRoot = getLowestRoot(a, b, c, t);\n            if (lowestRoot.found) {\n                t = lowestRoot.root;\n                found = true;\n                this._collisionPoint.copyFrom(p3);\n            }\n            p2.subtractToRef(p1, this._edge);\n            p1.subtractToRef(this._basePoint, this._baseToVertex);\n            let edgeSquaredLength = this._edge.lengthSquared();\n            let edgeDotVelocity = Vector3.Dot(this._edge, this._velocity);\n            let edgeDotBaseToVertex = Vector3.Dot(this._edge, this._baseToVertex);\n            a = edgeSquaredLength * -this._velocitySquaredLength + edgeDotVelocity * edgeDotVelocity;\n            b = 2 * (edgeSquaredLength * Vector3.Dot(this._velocity, this._baseToVertex) - edgeDotVelocity * edgeDotBaseToVertex);\n            c = edgeSquaredLength * (1.0 - this._baseToVertex.lengthSquared()) + edgeDotBaseToVertex * edgeDotBaseToVertex;\n            lowestRoot = getLowestRoot(a, b, c, t);\n            if (lowestRoot.found) {\n                const f = (edgeDotVelocity * lowestRoot.root - edgeDotBaseToVertex) / edgeSquaredLength;\n                if (f >= 0.0 && f <= 1.0) {\n                    t = lowestRoot.root;\n                    found = true;\n                    this._edge.scaleInPlace(f);\n                    p1.addToRef(this._edge, this._collisionPoint);\n                }\n            }\n            p3.subtractToRef(p2, this._edge);\n            p2.subtractToRef(this._basePoint, this._baseToVertex);\n            edgeSquaredLength = this._edge.lengthSquared();\n            edgeDotVelocity = Vector3.Dot(this._edge, this._velocity);\n            edgeDotBaseToVertex = Vector3.Dot(this._edge, this._baseToVertex);\n            a = edgeSquaredLength * -this._velocitySquaredLength + edgeDotVelocity * edgeDotVelocity;\n            b = 2 * (edgeSquaredLength * Vector3.Dot(this._velocity, this._baseToVertex) - edgeDotVelocity * edgeDotBaseToVertex);\n            c = edgeSquaredLength * (1.0 - this._baseToVertex.lengthSquared()) + edgeDotBaseToVertex * edgeDotBaseToVertex;\n            lowestRoot = getLowestRoot(a, b, c, t);\n            if (lowestRoot.found) {\n                const f = (edgeDotVelocity * lowestRoot.root - edgeDotBaseToVertex) / edgeSquaredLength;\n                if (f >= 0.0 && f <= 1.0) {\n                    t = lowestRoot.root;\n                    found = true;\n                    this._edge.scaleInPlace(f);\n                    p2.addToRef(this._edge, this._collisionPoint);\n                }\n            }\n            p1.subtractToRef(p3, this._edge);\n            p3.subtractToRef(this._basePoint, this._baseToVertex);\n            edgeSquaredLength = this._edge.lengthSquared();\n            edgeDotVelocity = Vector3.Dot(this._edge, this._velocity);\n            edgeDotBaseToVertex = Vector3.Dot(this._edge, this._baseToVertex);\n            a = edgeSquaredLength * -this._velocitySquaredLength + edgeDotVelocity * edgeDotVelocity;\n            b = 2 * (edgeSquaredLength * Vector3.Dot(this._velocity, this._baseToVertex) - edgeDotVelocity * edgeDotBaseToVertex);\n            c = edgeSquaredLength * (1.0 - this._baseToVertex.lengthSquared()) + edgeDotBaseToVertex * edgeDotBaseToVertex;\n            lowestRoot = getLowestRoot(a, b, c, t);\n            if (lowestRoot.found) {\n                const f = (edgeDotVelocity * lowestRoot.root - edgeDotBaseToVertex) / edgeSquaredLength;\n                if (f >= 0.0 && f <= 1.0) {\n                    t = lowestRoot.root;\n                    found = true;\n                    this._edge.scaleInPlace(f);\n                    p3.addToRef(this._edge, this._collisionPoint);\n                }\n            }\n        }\n        if (found) {\n            const distToCollisionSquared = t * t * this._velocitySquaredLength;\n            if (!this.collisionFound || distToCollisionSquared < this._nearestDistanceSquared) {\n                // if collisionResponse is false, collision is not found but the collidedMesh is set anyway.\n                // onCollide observable are triggered if collideMesh is set\n                // this allow trigger volumes to be created.\n                if (hostMesh.collisionResponse) {\n                    if (!this.intersectionPoint) {\n                        this.intersectionPoint = this._collisionPoint.clone();\n                    }\n                    else {\n                        this.intersectionPoint.copyFrom(this._collisionPoint);\n                    }\n                    this._nearestDistanceSquared = distToCollisionSquared;\n                    this._nearestDistance = Math.sqrt(distToCollisionSquared);\n                    this.collisionFound = true;\n                }\n                this.collidedMesh = hostMesh;\n            }\n        }\n    }\n    /**\n     * @internal\n     */\n    _collide(trianglePlaneArray, pts, indices, indexStart, indexEnd, decal, hasMaterial, hostMesh, invertTriangles, triangleStrip = false) {\n        if (triangleStrip) {\n            if (!indices || indices.length === 0) {\n                for (let i = 0; i < pts.length - 2; i += 1) {\n                    const p1 = pts[i];\n                    const p2 = pts[i + 1];\n                    const p3 = pts[i + 2];\n                    // stay defensive and don't check against undefined positions.\n                    if (!p1 || !p2 || !p3) {\n                        continue;\n                    }\n                    // Handles strip faces one on two is reversed\n                    if ((invertTriangles ? 1 : 0) ^ i % 2) {\n                        this._testTriangle(i, trianglePlaneArray, p1, p2, p3, hasMaterial, hostMesh);\n                    }\n                    else {\n                        this._testTriangle(i, trianglePlaneArray, p2, p1, p3, hasMaterial, hostMesh);\n                    }\n                }\n            }\n            else {\n                for (let i = indexStart; i < indexEnd - 2; i += 1) {\n                    const indexA = indices[i];\n                    const indexB = indices[i + 1];\n                    const indexC = indices[i + 2];\n                    if (indexC === 0xffffffff) {\n                        i += 2;\n                        continue;\n                    }\n                    const p1 = pts[indexA];\n                    const p2 = pts[indexB];\n                    const p3 = pts[indexC];\n                    // stay defensive and don't check against undefined positions.\n                    if (!p1 || !p2 || !p3) {\n                        continue;\n                    }\n                    // Handles strip faces one on two is reversed\n                    if ((invertTriangles ? 1 : 0) ^ i % 2) {\n                        this._testTriangle(i, trianglePlaneArray, p1, p2, p3, hasMaterial, hostMesh);\n                    }\n                    else {\n                        this._testTriangle(i, trianglePlaneArray, p2, p1, p3, hasMaterial, hostMesh);\n                    }\n                }\n            }\n        }\n        else if (!indices || indices.length === 0) {\n            for (let i = 0; i < pts.length; i += 3) {\n                const p1 = pts[i];\n                const p2 = pts[i + 1];\n                const p3 = pts[i + 2];\n                if (invertTriangles) {\n                    this._testTriangle(i, trianglePlaneArray, p1, p2, p3, hasMaterial, hostMesh);\n                }\n                else {\n                    this._testTriangle(i, trianglePlaneArray, p3, p2, p1, hasMaterial, hostMesh);\n                }\n            }\n        }\n        else {\n            for (let i = indexStart; i < indexEnd; i += 3) {\n                const p1 = pts[indices[i] - decal];\n                const p2 = pts[indices[i + 1] - decal];\n                const p3 = pts[indices[i + 2] - decal];\n                if (invertTriangles) {\n                    this._testTriangle(i, trianglePlaneArray, p1, p2, p3, hasMaterial, hostMesh);\n                }\n                else {\n                    this._testTriangle(i, trianglePlaneArray, p3, p2, p1, hasMaterial, hostMesh);\n                }\n            }\n        }\n    }\n    /**\n     * @internal\n     */\n    _getResponse(pos, vel) {\n        pos.addToRef(vel, this._destinationPoint);\n        vel.scaleInPlace(this._nearestDistance / vel.length());\n        this._basePoint.addToRef(vel, pos);\n        pos.subtractToRef(this.intersectionPoint, this._slidePlaneNormal);\n        this._slidePlaneNormal.normalize();\n        this._slidePlaneNormal.scaleToRef(this._epsilon, this._displacementVector);\n        pos.addInPlace(this._displacementVector);\n        this.intersectionPoint.addInPlace(this._displacementVector);\n        this._slidePlaneNormal.scaleInPlace(Plane.SignedDistanceToPlaneFromPositionAndNormal(this.intersectionPoint, this._slidePlaneNormal, this._destinationPoint));\n        this._destinationPoint.subtractInPlace(this._slidePlaneNormal);\n        this._destinationPoint.subtractToRef(this.intersectionPoint, vel);\n    }\n}\n/**\n * If true, it check for double sided faces and only returns 1 collision instead of 2\n */\nCollider.DoubleSidedCheck = false;\n//# sourceMappingURL=collider.js.map","import { Scene } from \"../scene.js\";\nimport { Vector3 } from \"../Maths/math.vector.js\";\nimport { Engine } from \"../Engines/engine.js\";\nimport { Collider } from \"./collider.js\";\n/** @internal */\nexport class DefaultCollisionCoordinator {\n    constructor() {\n        this._scaledPosition = Vector3.Zero();\n        this._scaledVelocity = Vector3.Zero();\n        this._finalPosition = Vector3.Zero();\n    }\n    getNewPosition(position, displacement, collider, maximumRetry, excludedMesh, onNewPosition, collisionIndex) {\n        position.divideToRef(collider._radius, this._scaledPosition);\n        displacement.divideToRef(collider._radius, this._scaledVelocity);\n        collider.collidedMesh = null;\n        collider._retry = 0;\n        collider._initialVelocity = this._scaledVelocity;\n        collider._initialPosition = this._scaledPosition;\n        this._collideWithWorld(this._scaledPosition, this._scaledVelocity, collider, maximumRetry, this._finalPosition, excludedMesh);\n        this._finalPosition.multiplyInPlace(collider._radius);\n        //run the callback\n        onNewPosition(collisionIndex, this._finalPosition, collider.collidedMesh);\n    }\n    createCollider() {\n        return new Collider();\n    }\n    init(scene) {\n        this._scene = scene;\n    }\n    _collideWithWorld(position, velocity, collider, maximumRetry, finalPosition, excludedMesh = null) {\n        const closeDistance = Engine.CollisionsEpsilon * 10.0;\n        if (collider._retry >= maximumRetry) {\n            finalPosition.copyFrom(position);\n            return;\n        }\n        // Check if this is a mesh else camera or -1\n        const collisionMask = excludedMesh ? excludedMesh.collisionMask : collider.collisionMask;\n        collider._initialize(position, velocity, closeDistance);\n        // Check if collision detection should happen against specified list of meshes or,\n        // if not specified, against all meshes in the scene\n        const meshes = (excludedMesh && excludedMesh.surroundingMeshes) || this._scene.meshes;\n        for (let index = 0; index < meshes.length; index++) {\n            const mesh = meshes[index];\n            if (mesh.isEnabled() && mesh.checkCollisions && mesh.subMeshes && mesh !== excludedMesh && (collisionMask & mesh.collisionGroup) !== 0) {\n                mesh._checkCollision(collider);\n            }\n        }\n        if (!collider.collisionFound) {\n            position.addToRef(velocity, finalPosition);\n            return;\n        }\n        if (velocity.x !== 0 || velocity.y !== 0 || velocity.z !== 0) {\n            collider._getResponse(position, velocity);\n        }\n        if (velocity.length() <= closeDistance) {\n            finalPosition.copyFrom(position);\n            return;\n        }\n        collider._retry++;\n        this._collideWithWorld(position, velocity, collider, maximumRetry, finalPosition, excludedMesh);\n    }\n}\nScene.CollisionCoordinatorFactory = () => {\n    return new DefaultCollisionCoordinator();\n};\n//# sourceMappingURL=collisionCoordinator.js.map","/**\n * @internal\n */\nexport class IntersectionInfo {\n    constructor(bu, bv, distance) {\n        this.bu = bu;\n        this.bv = bv;\n        this.distance = distance;\n        this.faceId = 0;\n        this.subMeshId = 0;\n    }\n}\n//# sourceMappingURL=intersectionInfo.js.map","import { Vector3 } from \"../Maths/math.vector.js\";\n/**\n * @internal\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport class _MeshCollisionData {\n    constructor() {\n        this._checkCollisions = false;\n        this._collisionMask = -1;\n        this._collisionGroup = -1;\n        this._surroundingMeshes = null;\n        this._collider = null;\n        this._oldPositionForCollisions = new Vector3(0, 0, 0);\n        this._diffPositionForCollisions = new Vector3(0, 0, 0);\n        this._collisionResponse = true;\n    }\n}\n//# sourceMappingURL=meshCollisionData.js.map","import { Vector3, Vector2, TmpVectors } from \"../Maths/math.vector.js\";\nimport { VertexBuffer } from \"../Buffers/buffer.js\";\n/**\n * Information about the result of picking within a scene\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/interactions/picking_collisions\n */\nexport class PickingInfo {\n    constructor() {\n        /**\n         * If the pick collided with an object\n         */\n        this.hit = false;\n        /**\n         * Distance away where the pick collided\n         */\n        this.distance = 0;\n        /**\n         * The location of pick collision\n         */\n        this.pickedPoint = null;\n        /**\n         * The mesh corresponding the pick collision\n         */\n        this.pickedMesh = null;\n        /** (See getTextureCoordinates) The barycentric U coordinate that is used when calculating the texture coordinates of the collision.*/\n        this.bu = 0;\n        /** (See getTextureCoordinates) The barycentric V coordinate that is used when calculating the texture coordinates of the collision.*/\n        this.bv = 0;\n        /** The index of the face on the mesh that was picked, or the index of the Line if the picked Mesh is a LinesMesh */\n        this.faceId = -1;\n        /** The index of the face on the subMesh that was picked, or the index of the Line if the picked Mesh is a LinesMesh */\n        this.subMeshFaceId = -1;\n        /** Id of the submesh that was picked */\n        this.subMeshId = 0;\n        /** If a sprite was picked, this will be the sprite the pick collided with */\n        this.pickedSprite = null;\n        /** If we are picking a mesh with thin instance, this will give you the picked thin instance */\n        this.thinInstanceIndex = -1;\n        /**\n         * The ray that was used to perform the picking.\n         */\n        this.ray = null;\n        /**\n         * If a mesh was used to do the picking (eg. 6dof controller) as a \"near interaction\", this will be populated.\n         */\n        this.originMesh = null;\n        /**\n         * The aim-space transform of the input used for picking, if it is an XR input source.\n         */\n        this.aimTransform = null;\n        /**\n         * The grip-space transform of the input used for picking, if it is an XR input source.\n         * Some XR sources, such as input coming from head mounted displays, do not have this.\n         */\n        this.gripTransform = null;\n    }\n    /**\n     * Gets the normal corresponding to the face the pick collided with\n     * @param useWorldCoordinates If the resulting normal should be relative to the world (default: false)\n     * @param useVerticesNormals If the vertices normals should be used to calculate the normal instead of the normal map (default: true)\n     * @returns The normal corresponding to the face the pick collided with\n     * @remarks Note that the returned normal will always point towards the picking ray.\n     */\n    getNormal(useWorldCoordinates = false, useVerticesNormals = true) {\n        if (!this.pickedMesh || (useVerticesNormals && !this.pickedMesh.isVerticesDataPresent(VertexBuffer.NormalKind))) {\n            return null;\n        }\n        const indices = this.pickedMesh.getIndices();\n        if (!indices) {\n            return null;\n        }\n        let result;\n        if (useVerticesNormals) {\n            const normals = this.pickedMesh.getVerticesData(VertexBuffer.NormalKind);\n            let normal0 = Vector3.FromArray(normals, indices[this.faceId * 3] * 3);\n            let normal1 = Vector3.FromArray(normals, indices[this.faceId * 3 + 1] * 3);\n            let normal2 = Vector3.FromArray(normals, indices[this.faceId * 3 + 2] * 3);\n            normal0 = normal0.scale(this.bu);\n            normal1 = normal1.scale(this.bv);\n            normal2 = normal2.scale(1.0 - this.bu - this.bv);\n            result = new Vector3(normal0.x + normal1.x + normal2.x, normal0.y + normal1.y + normal2.y, normal0.z + normal1.z + normal2.z);\n        }\n        else {\n            const positions = this.pickedMesh.getVerticesData(VertexBuffer.PositionKind);\n            const vertex1 = Vector3.FromArray(positions, indices[this.faceId * 3] * 3);\n            const vertex2 = Vector3.FromArray(positions, indices[this.faceId * 3 + 1] * 3);\n            const vertex3 = Vector3.FromArray(positions, indices[this.faceId * 3 + 2] * 3);\n            const p1p2 = vertex1.subtract(vertex2);\n            const p3p2 = vertex3.subtract(vertex2);\n            result = Vector3.Cross(p1p2, p3p2);\n        }\n        const transformNormalToWorld = (pickedMesh, n) => {\n            let wm = pickedMesh.getWorldMatrix();\n            if (pickedMesh.nonUniformScaling) {\n                TmpVectors.Matrix[0].copyFrom(wm);\n                wm = TmpVectors.Matrix[0];\n                wm.setTranslationFromFloats(0, 0, 0);\n                wm.invert();\n                wm.transposeToRef(TmpVectors.Matrix[1]);\n                wm = TmpVectors.Matrix[1];\n            }\n            Vector3.TransformNormalToRef(n, wm, n);\n        };\n        if (useWorldCoordinates) {\n            transformNormalToWorld(this.pickedMesh, result);\n        }\n        if (this.ray) {\n            const normalForDirectionChecking = TmpVectors.Vector3[0].copyFrom(result);\n            if (!useWorldCoordinates) {\n                // the normal has not been transformed to world space as part as the normal processing, so we must do it now\n                transformNormalToWorld(this.pickedMesh, normalForDirectionChecking);\n            }\n            // Flip the normal if the picking ray is in the same direction.\n            if (Vector3.Dot(normalForDirectionChecking, this.ray.direction) > 0) {\n                result.negateInPlace();\n            }\n        }\n        result.normalize();\n        return result;\n    }\n    /**\n     * Gets the texture coordinates of where the pick occurred\n     * @returns The vector containing the coordinates of the texture\n     */\n    getTextureCoordinates() {\n        if (!this.pickedMesh || !this.pickedMesh.isVerticesDataPresent(VertexBuffer.UVKind)) {\n            return null;\n        }\n        const indices = this.pickedMesh.getIndices();\n        if (!indices) {\n            return null;\n        }\n        const uvs = this.pickedMesh.getVerticesData(VertexBuffer.UVKind);\n        if (!uvs) {\n            return null;\n        }\n        let uv0 = Vector2.FromArray(uvs, indices[this.faceId * 3] * 2);\n        let uv1 = Vector2.FromArray(uvs, indices[this.faceId * 3 + 1] * 2);\n        let uv2 = Vector2.FromArray(uvs, indices[this.faceId * 3 + 2] * 2);\n        uv0 = uv0.scale(this.bu);\n        uv1 = uv1.scale(this.bv);\n        uv2 = uv2.scale(1.0 - this.bu - this.bv);\n        return new Vector2(uv0.x + uv1.x + uv2.x, uv0.y + uv1.y + uv2.y);\n    }\n}\n//# sourceMappingURL=pickingInfo.js.map","/**\n * Options used to control default behaviors regarding compatibility support\n */\nexport class CompatibilityOptions {\n}\n/**\n * Defines if the system should use OpenGL convention for UVs when creating geometry or loading .babylon files (false by default)\n */\nCompatibilityOptions.UseOpenGLOrientationForUV = false;\n//# sourceMappingURL=compatibilityOptions.js.map","import { Logger } from \"../Misc/logger.js\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { GetDOMTextContent, IsWindowObjectExist } from \"../Misc/domManagement.js\";\nimport { ShaderProcessor } from \"../Engines/Processors/shaderProcessor.js\";\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nimport { ShaderLanguage } from \"../Materials/shaderLanguage.js\";\n/**\n * Effect wrapping a compute shader and let execute (dispatch) the shader\n */\nexport class ComputeEffect {\n    /**\n     * Creates a compute effect that can be used to execute a compute shader\n     * @param baseName Name of the effect\n     * @param options Set of all options to create the effect\n     * @param engine The engine the effect is created for\n     * @param key Effect Key identifying uniquely compiled shader variants\n     */\n    constructor(baseName, options, engine, key = \"\") {\n        var _a, _b;\n        /**\n         * Name of the effect.\n         */\n        this.name = null;\n        /**\n         * String container all the define statements that should be set on the shader.\n         */\n        this.defines = \"\";\n        /**\n         * Callback that will be called when the shader is compiled.\n         */\n        this.onCompiled = null;\n        /**\n         * Callback that will be called if an error occurs during shader compilation.\n         */\n        this.onError = null;\n        /**\n         * Unique ID of the effect.\n         */\n        this.uniqueId = 0;\n        /**\n         * Observable that will be called when the shader is compiled.\n         * It is recommended to use executeWhenCompile() or to make sure that scene.isReady() is called to get this observable raised.\n         */\n        this.onCompileObservable = new Observable();\n        /**\n         * Observable that will be called if an error occurs during shader compilation.\n         */\n        this.onErrorObservable = new Observable();\n        /**\n         * Observable that will be called when effect is bound.\n         */\n        this.onBindObservable = new Observable();\n        /**\n         * @internal\n         * Specifies if the effect was previously ready\n         */\n        this._wasPreviouslyReady = false;\n        this._isReady = false;\n        this._compilationError = \"\";\n        /** @internal */\n        this._key = \"\";\n        this._computeSourceCodeOverride = \"\";\n        /** @internal */\n        this._pipelineContext = null;\n        /** @internal */\n        this._computeSourceCode = \"\";\n        this._rawComputeSourceCode = \"\";\n        this._shaderLanguage = ShaderLanguage.WGSL;\n        this.name = baseName;\n        this._key = key;\n        this._engine = engine;\n        this.uniqueId = ComputeEffect._UniqueIdSeed++;\n        this.defines = (_a = options.defines) !== null && _a !== void 0 ? _a : \"\";\n        this.onError = options.onError;\n        this.onCompiled = options.onCompiled;\n        this._entryPoint = (_b = options.entryPoint) !== null && _b !== void 0 ? _b : \"main\";\n        this._shaderStore = ShaderStore.GetShadersStore(this._shaderLanguage);\n        this._shaderRepository = ShaderStore.GetShadersRepository(this._shaderLanguage);\n        this._includeShaderStore = ShaderStore.GetIncludesShadersStore(this._shaderLanguage);\n        let computeSource;\n        const hostDocument = IsWindowObjectExist() ? this._engine.getHostDocument() : null;\n        if (baseName.computeSource) {\n            computeSource = \"source:\" + baseName.computeSource;\n        }\n        else if (baseName.computeElement) {\n            computeSource = hostDocument ? hostDocument.getElementById(baseName.computeElement) : null;\n            if (!computeSource) {\n                computeSource = baseName.computeElement;\n            }\n        }\n        else {\n            computeSource = baseName.compute || baseName;\n        }\n        const processorOptions = {\n            defines: this.defines.split(\"\\n\"),\n            indexParameters: undefined,\n            isFragment: false,\n            shouldUseHighPrecisionShader: false,\n            processor: null,\n            supportsUniformBuffers: this._engine.supportsUniformBuffers,\n            shadersRepository: this._shaderRepository,\n            includesShadersStore: this._includeShaderStore,\n            version: (this._engine.version * 100).toString(),\n            platformName: this._engine.shaderPlatformName,\n            processingContext: null,\n            isNDCHalfZRange: this._engine.isNDCHalfZRange,\n            useReverseDepthBuffer: this._engine.useReverseDepthBuffer,\n        };\n        this._loadShader(computeSource, \"Compute\", \"\", (computeCode) => {\n            ShaderProcessor.Initialize(processorOptions);\n            ShaderProcessor.PreProcess(computeCode, processorOptions, (migratedCommputeCode) => {\n                this._rawComputeSourceCode = computeCode;\n                if (options.processFinalCode) {\n                    migratedCommputeCode = options.processFinalCode(migratedCommputeCode);\n                }\n                const finalShaders = ShaderProcessor.Finalize(migratedCommputeCode, \"\", processorOptions);\n                this._useFinalCode(finalShaders.vertexCode, baseName);\n            }, this._engine);\n        });\n    }\n    _useFinalCode(migratedCommputeCode, baseName) {\n        if (baseName) {\n            const compute = baseName.computeElement || baseName.compute || baseName.spectorName || baseName;\n            this._computeSourceCode = \"//#define SHADER_NAME compute:\" + compute + \"\\n\" + migratedCommputeCode;\n        }\n        else {\n            this._computeSourceCode = migratedCommputeCode;\n        }\n        this._prepareEffect();\n    }\n    /**\n     * Unique key for this effect\n     */\n    get key() {\n        return this._key;\n    }\n    /**\n     * If the effect has been compiled and prepared.\n     * @returns if the effect is compiled and prepared.\n     */\n    isReady() {\n        try {\n            return this._isReadyInternal();\n        }\n        catch (_a) {\n            return false;\n        }\n    }\n    _isReadyInternal() {\n        if (this._isReady) {\n            return true;\n        }\n        if (this._pipelineContext) {\n            return this._pipelineContext.isReady;\n        }\n        return false;\n    }\n    /**\n     * The engine the effect was initialized with.\n     * @returns the engine.\n     */\n    getEngine() {\n        return this._engine;\n    }\n    /**\n     * The pipeline context for this effect\n     * @returns the associated pipeline context\n     */\n    getPipelineContext() {\n        return this._pipelineContext;\n    }\n    /**\n     * The error from the last compilation.\n     * @returns the error string.\n     */\n    getCompilationError() {\n        return this._compilationError;\n    }\n    /**\n     * Adds a callback to the onCompiled observable and call the callback immediately if already ready.\n     * @param func The callback to be used.\n     */\n    executeWhenCompiled(func) {\n        if (this.isReady()) {\n            func(this);\n            return;\n        }\n        this.onCompileObservable.add((effect) => {\n            func(effect);\n        });\n        if (!this._pipelineContext || this._pipelineContext.isAsync) {\n            setTimeout(() => {\n                this._checkIsReady(null);\n            }, 16);\n        }\n    }\n    _checkIsReady(previousPipelineContext) {\n        try {\n            if (this._isReadyInternal()) {\n                return;\n            }\n        }\n        catch (e) {\n            this._processCompilationErrors(e, previousPipelineContext);\n            return;\n        }\n        setTimeout(() => {\n            this._checkIsReady(previousPipelineContext);\n        }, 16);\n    }\n    _loadShader(shader, key, optionalKey, callback) {\n        if (typeof HTMLElement !== \"undefined\") {\n            // DOM element ?\n            if (shader instanceof HTMLElement) {\n                const shaderCode = GetDOMTextContent(shader);\n                callback(shaderCode);\n                return;\n            }\n        }\n        // Direct source ?\n        if (shader.substr(0, 7) === \"source:\") {\n            callback(shader.substr(7));\n            return;\n        }\n        // Base64 encoded ?\n        if (shader.substr(0, 7) === \"base64:\") {\n            const shaderBinary = window.atob(shader.substr(7));\n            callback(shaderBinary);\n            return;\n        }\n        // Is in local store ?\n        if (this._shaderStore[shader + key + \"Shader\"]) {\n            callback(this._shaderStore[shader + key + \"Shader\"]);\n            return;\n        }\n        if (optionalKey && this._shaderStore[shader + optionalKey + \"Shader\"]) {\n            callback(this._shaderStore[shader + optionalKey + \"Shader\"]);\n            return;\n        }\n        let shaderUrl;\n        if (shader[0] === \".\" || shader[0] === \"/\" || shader.indexOf(\"http\") > -1) {\n            shaderUrl = shader;\n        }\n        else {\n            shaderUrl = this._shaderRepository + shader;\n        }\n        this._engine._loadFile(shaderUrl + \".\" + key.toLowerCase() + \".fx\", callback);\n    }\n    /**\n     * Gets the compute shader source code of this effect\n     */\n    get computeSourceCode() {\n        var _a, _b;\n        return this._computeSourceCodeOverride ? this._computeSourceCodeOverride : (_b = (_a = this._pipelineContext) === null || _a === void 0 ? void 0 : _a._getComputeShaderCode()) !== null && _b !== void 0 ? _b : this._computeSourceCode;\n    }\n    /**\n     * Gets the compute shader source code before it has been processed by the preprocessor\n     */\n    get rawComputeSourceCode() {\n        return this._rawComputeSourceCode;\n    }\n    /**\n     * Prepares the effect\n     * @internal\n     */\n    _prepareEffect() {\n        const defines = this.defines;\n        const previousPipelineContext = this._pipelineContext;\n        this._isReady = false;\n        try {\n            const engine = this._engine;\n            this._pipelineContext = engine.createComputePipelineContext();\n            this._pipelineContext._name = this._key;\n            engine._prepareComputePipelineContext(this._pipelineContext, this._computeSourceCodeOverride ? this._computeSourceCodeOverride : this._computeSourceCode, this._rawComputeSourceCode, this._computeSourceCodeOverride ? null : defines, this._entryPoint);\n            engine._executeWhenComputeStateIsCompiled(this._pipelineContext, () => {\n                this._compilationError = \"\";\n                this._isReady = true;\n                if (this.onCompiled) {\n                    this.onCompiled(this);\n                }\n                this.onCompileObservable.notifyObservers(this);\n                this.onCompileObservable.clear();\n                if (previousPipelineContext) {\n                    this.getEngine()._deleteComputePipelineContext(previousPipelineContext);\n                }\n            });\n            if (this._pipelineContext.isAsync) {\n                this._checkIsReady(previousPipelineContext);\n            }\n        }\n        catch (e) {\n            this._processCompilationErrors(e, previousPipelineContext);\n        }\n    }\n    _getShaderCodeAndErrorLine(code, error) {\n        const regexp = /COMPUTE SHADER ERROR: 0:(\\d+?):/;\n        let errorLine = null;\n        if (error && code) {\n            const res = error.match(regexp);\n            if (res && res.length === 2) {\n                const lineNumber = parseInt(res[1]);\n                const lines = code.split(\"\\n\", -1);\n                if (lines.length >= lineNumber) {\n                    errorLine = `Offending line [${lineNumber}] in compute code: ${lines[lineNumber - 1]}`;\n                }\n            }\n        }\n        return [code, errorLine];\n    }\n    _processCompilationErrors(e, previousPipelineContext = null) {\n        var _a;\n        this._compilationError = e.message;\n        // Let's go through fallbacks then\n        Logger.Error(\"Unable to compile compute effect:\");\n        Logger.Error(\"Defines:\\r\\n\" + this.defines);\n        if (ComputeEffect.LogShaderCodeOnCompilationError) {\n            let lineErrorVertex = null, code = null;\n            if ((_a = this._pipelineContext) === null || _a === void 0 ? void 0 : _a._getComputeShaderCode()) {\n                [code, lineErrorVertex] = this._getShaderCodeAndErrorLine(this._pipelineContext._getComputeShaderCode(), this._compilationError);\n                if (code) {\n                    Logger.Error(\"Compute code:\");\n                    Logger.Error(code);\n                }\n            }\n            if (lineErrorVertex) {\n                Logger.Error(lineErrorVertex);\n            }\n        }\n        Logger.Error(\"Error: \" + this._compilationError);\n        if (previousPipelineContext) {\n            this._pipelineContext = previousPipelineContext;\n            this._isReady = true;\n            if (this.onError) {\n                this.onError(this, this._compilationError);\n            }\n            this.onErrorObservable.notifyObservers(this);\n        }\n    }\n    /**\n     * Release all associated resources.\n     **/\n    dispose() {\n        if (this._pipelineContext) {\n            this._pipelineContext.dispose();\n        }\n        this._engine._releaseComputeEffect(this);\n    }\n    /**\n     * This function will add a new compute shader to the shader store\n     * @param name the name of the shader\n     * @param computeShader compute shader content\n     */\n    static RegisterShader(name, computeShader) {\n        ShaderStore.GetShadersStore(ShaderLanguage.WGSL)[`${name}ComputeShader`] = computeShader;\n    }\n}\nComputeEffect._UniqueIdSeed = 0;\n/**\n * Enable logging of the shader code when a compilation error occurs\n */\nComputeEffect.LogShaderCodeOnCompilationError = true;\n//# sourceMappingURL=computeEffect.js.map","import { __decorate } from \"../tslib.es6.js\";\nimport { SerializationHelper, serialize } from \"../Misc/decorators.js\";\nimport { RegisterClass } from \"../Misc/typeStore.js\";\nimport { ComputeBindingType } from \"../Engines/Extensions/engine.computeShader.js\";\nimport { Texture } from \"../Materials/Textures/texture.js\";\nimport { UniqueIdGenerator } from \"../Misc/uniqueIdGenerator.js\";\nimport { Logger } from \"../Misc/logger.js\";\nimport { TextureSampler } from \"../Materials/Textures/textureSampler.js\";\n/**\n * The ComputeShader object lets you execute a compute shader on your GPU (if supported by the engine)\n */\nexport class ComputeShader {\n    /**\n     * The options used to create the shader\n     */\n    get options() {\n        return this._options;\n    }\n    /**\n     * The shaderPath used to create the shader\n     */\n    get shaderPath() {\n        return this._shaderPath;\n    }\n    /**\n     * Instantiates a new compute shader.\n     * @param name Defines the name of the compute shader in the scene\n     * @param engine Defines the engine the compute shader belongs to\n     * @param shaderPath Defines  the route to the shader code in one of three ways:\n     *  * object: { compute: \"custom\" }, used with ShaderStore.ShadersStoreWGSL[\"customComputeShader\"]\n     *  * object: { computeElement: \"HTMLElementId\" }, used with shader code in script tags\n     *  * object: { computeSource: \"compute shader code string\" using with string containing the shader code\n     *  * string: try first to find the code in ShaderStore.ShadersStoreWGSL[shaderPath + \"ComputeShader\"]. If not, assumes it is a file with name shaderPath.compute.fx in index.html folder.\n     * @param options Define the options used to create the shader\n     */\n    constructor(name, engine, shaderPath, options = {}) {\n        this._bindings = {};\n        this._samplers = {};\n        this._contextIsDirty = false;\n        /**\n         * Callback triggered when the shader is compiled\n         */\n        this.onCompiled = null;\n        /**\n         * Callback triggered when an error occurs\n         */\n        this.onError = null;\n        this.name = name;\n        this._engine = engine;\n        this.uniqueId = UniqueIdGenerator.UniqueId;\n        if (!this._engine.getCaps().supportComputeShaders) {\n            Logger.Error(\"This engine does not support compute shaders!\");\n            return;\n        }\n        if (!options.bindingsMapping) {\n            Logger.Error(\"You must provide the binding mappings as browsers don't support reflection for wgsl shaders yet!\");\n            return;\n        }\n        this._context = engine.createComputeContext();\n        this._shaderPath = shaderPath;\n        this._options = {\n            bindingsMapping: {},\n            defines: [],\n            ...options,\n        };\n    }\n    /**\n     * Gets the current class name of the material e.g. \"ComputeShader\"\n     * Mainly use in serialization.\n     * @returns the class name\n     */\n    getClassName() {\n        return \"ComputeShader\";\n    }\n    /**\n     * Binds a texture to the shader\n     * @param name Binding name of the texture\n     * @param texture Texture to bind\n     * @param bindSampler Bind the sampler corresponding to the texture (default: true). The sampler will be bound just before the binding index of the texture\n     */\n    setTexture(name, texture, bindSampler = true) {\n        const current = this._bindings[name];\n        this._bindings[name] = {\n            type: bindSampler ? ComputeBindingType.Texture : ComputeBindingType.TextureWithoutSampler,\n            object: texture,\n            indexInGroupEntries: current === null || current === void 0 ? void 0 : current.indexInGroupEntries,\n        };\n        this._contextIsDirty || (this._contextIsDirty = !current || current.object !== texture || current.type !== this._bindings[name].type);\n    }\n    /**\n     * Binds a storage texture to the shader\n     * @param name Binding name of the texture\n     * @param texture Texture to bind\n     */\n    setStorageTexture(name, texture) {\n        const current = this._bindings[name];\n        this._contextIsDirty || (this._contextIsDirty = !current || current.object !== texture);\n        this._bindings[name] = {\n            type: ComputeBindingType.StorageTexture,\n            object: texture,\n            indexInGroupEntries: current === null || current === void 0 ? void 0 : current.indexInGroupEntries,\n        };\n    }\n    /**\n     * Binds a uniform buffer to the shader\n     * @param name Binding name of the buffer\n     * @param buffer Buffer to bind\n     */\n    setUniformBuffer(name, buffer) {\n        const current = this._bindings[name];\n        this._contextIsDirty || (this._contextIsDirty = !current || current.object !== buffer);\n        this._bindings[name] = {\n            type: ComputeBindingType.UniformBuffer,\n            object: buffer,\n            indexInGroupEntries: current === null || current === void 0 ? void 0 : current.indexInGroupEntries,\n        };\n    }\n    /**\n     * Binds a storage buffer to the shader\n     * @param name Binding name of the buffer\n     * @param buffer Buffer to bind\n     */\n    setStorageBuffer(name, buffer) {\n        const current = this._bindings[name];\n        this._contextIsDirty || (this._contextIsDirty = !current || current.object !== buffer);\n        this._bindings[name] = {\n            type: ComputeBindingType.StorageBuffer,\n            object: buffer,\n            indexInGroupEntries: current === null || current === void 0 ? void 0 : current.indexInGroupEntries,\n        };\n    }\n    /**\n     * Binds a texture sampler to the shader\n     * @param name Binding name of the sampler\n     * @param sampler Sampler to bind\n     */\n    setTextureSampler(name, sampler) {\n        const current = this._bindings[name];\n        this._contextIsDirty || (this._contextIsDirty = !current || !sampler.compareSampler(current.object));\n        this._bindings[name] = {\n            type: ComputeBindingType.Sampler,\n            object: sampler,\n            indexInGroupEntries: current === null || current === void 0 ? void 0 : current.indexInGroupEntries,\n        };\n    }\n    /**\n     * Specifies that the compute shader is ready to be executed (the compute effect and all the resources are ready)\n     * @returns true if the compute shader is ready to be executed\n     */\n    isReady() {\n        let effect = this._effect;\n        for (const key in this._bindings) {\n            const binding = this._bindings[key], type = binding.type, object = binding.object;\n            switch (type) {\n                case ComputeBindingType.Texture:\n                case ComputeBindingType.TextureWithoutSampler:\n                case ComputeBindingType.StorageTexture: {\n                    const texture = object;\n                    if (!texture.isReady()) {\n                        return false;\n                    }\n                    break;\n                }\n            }\n        }\n        const defines = [];\n        const shaderName = this._shaderPath;\n        if (this._options.defines) {\n            for (let index = 0; index < this._options.defines.length; index++) {\n                defines.push(this._options.defines[index]);\n            }\n        }\n        const join = defines.join(\"\\n\");\n        if (this._cachedDefines !== join) {\n            this._cachedDefines = join;\n            effect = this._engine.createComputeEffect(shaderName, {\n                defines: join,\n                entryPoint: this._options.entryPoint,\n                onCompiled: this.onCompiled,\n                onError: this.onError,\n            });\n            this._effect = effect;\n        }\n        if (!effect.isReady()) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Dispatches (executes) the compute shader\n     * @param x Number of workgroups to execute on the X dimension\n     * @param y Number of workgroups to execute on the Y dimension (default: 1)\n     * @param z Number of workgroups to execute on the Z dimension (default: 1)\n     * @returns True if the dispatch could be done, else false (meaning either the compute effect or at least one of the bound resources was not ready)\n     */\n    dispatch(x, y, z) {\n        var _a;\n        if (!this.isReady()) {\n            return false;\n        }\n        // If the sampling parameters of a texture bound to the shader have changed, we must clear the compute context so that it is recreated with the updated values\n        for (const key in this._bindings) {\n            const binding = this._bindings[key];\n            // TODO: remove this when browsers support reflection for wgsl shaders\n            if (!this._options.bindingsMapping[key]) {\n                throw new Error(\"ComputeShader ('\" + this.name + \"'): No binding mapping has been provided for the property '\" + key + \"'\");\n            }\n            if (binding.type !== ComputeBindingType.Texture) {\n                continue;\n            }\n            const sampler = this._samplers[key];\n            const texture = binding.object;\n            if (!sampler || !texture._texture || !sampler.compareSampler(texture._texture)) {\n                this._samplers[key] = new TextureSampler().setParameters(texture.wrapU, texture.wrapV, texture.wrapR, texture.anisotropicFilteringLevel, texture._texture.samplingMode, (_a = texture._texture) === null || _a === void 0 ? void 0 : _a._comparisonFunction);\n                this._contextIsDirty = true;\n            }\n        }\n        if (this._contextIsDirty) {\n            this._contextIsDirty = false;\n            this._context.clear();\n        }\n        this._engine.computeDispatch(this._effect, this._context, this._bindings, x, y, z, this._options.bindingsMapping);\n        return true;\n    }\n    /**\n     * Waits for the compute shader to be ready and executes it\n     * @param x Number of workgroups to execute on the X dimension\n     * @param y Number of workgroups to execute on the Y dimension (default: 1)\n     * @param z Number of workgroups to execute on the Z dimension (default: 1)\n     * @param delay Delay between the retries while the shader is not ready (in milliseconds - 10 by default)\n     * @returns A promise that is resolved once the shader has been sent to the GPU. Note that it does not mean that the shader execution itself is finished!\n     */\n    dispatchWhenReady(x, y, z, delay = 10) {\n        return new Promise((resolve) => {\n            const check = () => {\n                if (!this.dispatch(x, y, z)) {\n                    setTimeout(check, delay);\n                }\n                else {\n                    resolve();\n                }\n            };\n            check();\n        });\n    }\n    /**\n     * Serializes this compute shader in a JSON representation\n     * @returns the serialized compute shader object\n     */\n    serialize() {\n        const serializationObject = SerializationHelper.Serialize(this);\n        serializationObject.options = this._options;\n        serializationObject.shaderPath = this._shaderPath;\n        serializationObject.bindings = {};\n        serializationObject.textures = {};\n        for (const key in this._bindings) {\n            const binding = this._bindings[key];\n            const object = binding.object;\n            switch (binding.type) {\n                case ComputeBindingType.Texture:\n                case ComputeBindingType.TextureWithoutSampler:\n                case ComputeBindingType.StorageTexture: {\n                    const serializedData = object.serialize();\n                    if (serializedData) {\n                        serializationObject.textures[key] = serializedData;\n                        serializationObject.bindings[key] = {\n                            type: binding.type,\n                        };\n                    }\n                    break;\n                }\n                case ComputeBindingType.UniformBuffer: {\n                    break;\n                }\n            }\n        }\n        return serializationObject;\n    }\n    /**\n     * Creates a compute shader from parsed compute shader data\n     * @param source defines the JSON representation of the compute shader\n     * @param scene defines the hosting scene\n     * @param rootUrl defines the root URL to use to load textures and relative dependencies\n     * @returns a new compute shader\n     */\n    static Parse(source, scene, rootUrl) {\n        const compute = SerializationHelper.Parse(() => new ComputeShader(source.name, scene.getEngine(), source.shaderPath, source.options), source, scene, rootUrl);\n        for (const key in source.textures) {\n            const binding = source.bindings[key];\n            const texture = Texture.Parse(source.textures[key], scene, rootUrl);\n            if (binding.type === ComputeBindingType.Texture) {\n                compute.setTexture(key, texture);\n            }\n            else if (binding.type === ComputeBindingType.TextureWithoutSampler) {\n                compute.setTexture(key, texture, false);\n            }\n            else {\n                compute.setStorageTexture(key, texture);\n            }\n        }\n        return compute;\n    }\n}\n__decorate([\n    serialize()\n], ComputeShader.prototype, \"name\", void 0);\nRegisterClass(\"BABYLON.ComputeShader\", ComputeShader);\n//# sourceMappingURL=computeShader.js.map","import { ArrayTools } from \"../Misc/arrayTools.js\";\nimport { Matrix, Vector3 } from \"../Maths/math.vector.js\";\nimport { Epsilon } from \"../Maths/math.constants.js\";\n/**\n * Class used to store bounding box information\n */\nexport class BoundingBox {\n    /**\n     * Creates a new bounding box\n     * @param min defines the minimum vector (in local space)\n     * @param max defines the maximum vector (in local space)\n     * @param worldMatrix defines the new world matrix\n     */\n    constructor(min, max, worldMatrix) {\n        /**\n         * Gets the 8 vectors representing the bounding box in local space\n         */\n        this.vectors = ArrayTools.BuildArray(8, Vector3.Zero);\n        /**\n         * Gets the center of the bounding box in local space\n         */\n        this.center = Vector3.Zero();\n        /**\n         * Gets the center of the bounding box in world space\n         */\n        this.centerWorld = Vector3.Zero();\n        /**\n         * Gets the extend size in local space\n         */\n        this.extendSize = Vector3.Zero();\n        /**\n         * Gets the extend size in world space\n         */\n        this.extendSizeWorld = Vector3.Zero();\n        /**\n         * Gets the OBB (object bounding box) directions\n         */\n        this.directions = ArrayTools.BuildArray(3, Vector3.Zero);\n        /**\n         * Gets the 8 vectors representing the bounding box in world space\n         */\n        this.vectorsWorld = ArrayTools.BuildArray(8, Vector3.Zero);\n        /**\n         * Gets the minimum vector in world space\n         */\n        this.minimumWorld = Vector3.Zero();\n        /**\n         * Gets the maximum vector in world space\n         */\n        this.maximumWorld = Vector3.Zero();\n        /**\n         * Gets the minimum vector in local space\n         */\n        this.minimum = Vector3.Zero();\n        /**\n         * Gets the maximum vector in local space\n         */\n        this.maximum = Vector3.Zero();\n        /** @internal */\n        this._drawWrapperFront = null;\n        /** @internal */\n        this._drawWrapperBack = null;\n        this.reConstruct(min, max, worldMatrix);\n    }\n    // Methods\n    /**\n     * Recreates the entire bounding box from scratch as if we call the constructor in place\n     * @param min defines the new minimum vector (in local space)\n     * @param max defines the new maximum vector (in local space)\n     * @param worldMatrix defines the new world matrix\n     */\n    reConstruct(min, max, worldMatrix) {\n        const minX = min.x, minY = min.y, minZ = min.z, maxX = max.x, maxY = max.y, maxZ = max.z;\n        const vectors = this.vectors;\n        this.minimum.copyFromFloats(minX, minY, minZ);\n        this.maximum.copyFromFloats(maxX, maxY, maxZ);\n        vectors[0].copyFromFloats(minX, minY, minZ);\n        vectors[1].copyFromFloats(maxX, maxY, maxZ);\n        vectors[2].copyFromFloats(maxX, minY, minZ);\n        vectors[3].copyFromFloats(minX, maxY, minZ);\n        vectors[4].copyFromFloats(minX, minY, maxZ);\n        vectors[5].copyFromFloats(maxX, maxY, minZ);\n        vectors[6].copyFromFloats(minX, maxY, maxZ);\n        vectors[7].copyFromFloats(maxX, minY, maxZ);\n        // OBB\n        max.addToRef(min, this.center).scaleInPlace(0.5);\n        max.subtractToRef(min, this.extendSize).scaleInPlace(0.5);\n        this._worldMatrix = worldMatrix || Matrix.IdentityReadOnly;\n        this._update(this._worldMatrix);\n    }\n    /**\n     * Scale the current bounding box by applying a scale factor\n     * @param factor defines the scale factor to apply\n     * @returns the current bounding box\n     */\n    scale(factor) {\n        const tmpVectors = BoundingBox._TmpVector3;\n        const diff = this.maximum.subtractToRef(this.minimum, tmpVectors[0]);\n        const len = diff.length();\n        diff.normalizeFromLength(len);\n        const distance = len * factor;\n        const newRadius = diff.scaleInPlace(distance * 0.5);\n        const min = this.center.subtractToRef(newRadius, tmpVectors[1]);\n        const max = this.center.addToRef(newRadius, tmpVectors[2]);\n        this.reConstruct(min, max, this._worldMatrix);\n        return this;\n    }\n    /**\n     * Gets the world matrix of the bounding box\n     * @returns a matrix\n     */\n    getWorldMatrix() {\n        return this._worldMatrix;\n    }\n    /**\n     * @internal\n     */\n    _update(world) {\n        const minWorld = this.minimumWorld;\n        const maxWorld = this.maximumWorld;\n        const directions = this.directions;\n        const vectorsWorld = this.vectorsWorld;\n        const vectors = this.vectors;\n        if (!world.isIdentity()) {\n            minWorld.setAll(Number.MAX_VALUE);\n            maxWorld.setAll(-Number.MAX_VALUE);\n            for (let index = 0; index < 8; ++index) {\n                const v = vectorsWorld[index];\n                Vector3.TransformCoordinatesToRef(vectors[index], world, v);\n                minWorld.minimizeInPlace(v);\n                maxWorld.maximizeInPlace(v);\n            }\n            // Extend\n            maxWorld.subtractToRef(minWorld, this.extendSizeWorld).scaleInPlace(0.5);\n            maxWorld.addToRef(minWorld, this.centerWorld).scaleInPlace(0.5);\n        }\n        else {\n            minWorld.copyFrom(this.minimum);\n            maxWorld.copyFrom(this.maximum);\n            for (let index = 0; index < 8; ++index) {\n                vectorsWorld[index].copyFrom(vectors[index]);\n            }\n            // Extend\n            this.extendSizeWorld.copyFrom(this.extendSize);\n            this.centerWorld.copyFrom(this.center);\n        }\n        Vector3.FromArrayToRef(world.m, 0, directions[0]);\n        Vector3.FromArrayToRef(world.m, 4, directions[1]);\n        Vector3.FromArrayToRef(world.m, 8, directions[2]);\n        this._worldMatrix = world;\n    }\n    /**\n     * Tests if the bounding box is intersecting the frustum planes\n     * @param frustumPlanes defines the frustum planes to test\n     * @returns true if there is an intersection\n     */\n    isInFrustum(frustumPlanes) {\n        return BoundingBox.IsInFrustum(this.vectorsWorld, frustumPlanes);\n    }\n    /**\n     * Tests if the bounding box is entirely inside the frustum planes\n     * @param frustumPlanes defines the frustum planes to test\n     * @returns true if there is an inclusion\n     */\n    isCompletelyInFrustum(frustumPlanes) {\n        return BoundingBox.IsCompletelyInFrustum(this.vectorsWorld, frustumPlanes);\n    }\n    /**\n     * Tests if a point is inside the bounding box\n     * @param point defines the point to test\n     * @returns true if the point is inside the bounding box\n     */\n    intersectsPoint(point) {\n        const min = this.minimumWorld;\n        const max = this.maximumWorld;\n        const minX = min.x, minY = min.y, minZ = min.z, maxX = max.x, maxY = max.y, maxZ = max.z;\n        const pointX = point.x, pointY = point.y, pointZ = point.z;\n        const delta = -Epsilon;\n        if (maxX - pointX < delta || delta > pointX - minX) {\n            return false;\n        }\n        if (maxY - pointY < delta || delta > pointY - minY) {\n            return false;\n        }\n        if (maxZ - pointZ < delta || delta > pointZ - minZ) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Tests if the bounding box intersects with a bounding sphere\n     * @param sphere defines the sphere to test\n     * @returns true if there is an intersection\n     */\n    intersectsSphere(sphere) {\n        return BoundingBox.IntersectsSphere(this.minimumWorld, this.maximumWorld, sphere.centerWorld, sphere.radiusWorld);\n    }\n    /**\n     * Tests if the bounding box intersects with a box defined by a min and max vectors\n     * @param min defines the min vector to use\n     * @param max defines the max vector to use\n     * @returns true if there is an intersection\n     */\n    intersectsMinMax(min, max) {\n        const myMin = this.minimumWorld;\n        const myMax = this.maximumWorld;\n        const myMinX = myMin.x, myMinY = myMin.y, myMinZ = myMin.z, myMaxX = myMax.x, myMaxY = myMax.y, myMaxZ = myMax.z;\n        const minX = min.x, minY = min.y, minZ = min.z, maxX = max.x, maxY = max.y, maxZ = max.z;\n        if (myMaxX < minX || myMinX > maxX) {\n            return false;\n        }\n        if (myMaxY < minY || myMinY > maxY) {\n            return false;\n        }\n        if (myMaxZ < minZ || myMinZ > maxZ) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Disposes the resources of the class\n     */\n    dispose() {\n        var _a, _b;\n        (_a = this._drawWrapperFront) === null || _a === void 0 ? void 0 : _a.dispose();\n        (_b = this._drawWrapperBack) === null || _b === void 0 ? void 0 : _b.dispose();\n    }\n    // Statics\n    /**\n     * Tests if two bounding boxes are intersections\n     * @param box0 defines the first box to test\n     * @param box1 defines the second box to test\n     * @returns true if there is an intersection\n     */\n    static Intersects(box0, box1) {\n        return box0.intersectsMinMax(box1.minimumWorld, box1.maximumWorld);\n    }\n    /**\n     * Tests if a bounding box defines by a min/max vectors intersects a sphere\n     * @param minPoint defines the minimum vector of the bounding box\n     * @param maxPoint defines the maximum vector of the bounding box\n     * @param sphereCenter defines the sphere center\n     * @param sphereRadius defines the sphere radius\n     * @returns true if there is an intersection\n     */\n    static IntersectsSphere(minPoint, maxPoint, sphereCenter, sphereRadius) {\n        const vector = BoundingBox._TmpVector3[0];\n        Vector3.ClampToRef(sphereCenter, minPoint, maxPoint, vector);\n        const num = Vector3.DistanceSquared(sphereCenter, vector);\n        return num <= sphereRadius * sphereRadius;\n    }\n    /**\n     * Tests if a bounding box defined with 8 vectors is entirely inside frustum planes\n     * @param boundingVectors defines an array of 8 vectors representing a bounding box\n     * @param frustumPlanes defines the frustum planes to test\n     * @returns true if there is an inclusion\n     */\n    static IsCompletelyInFrustum(boundingVectors, frustumPlanes) {\n        for (let p = 0; p < 6; ++p) {\n            const frustumPlane = frustumPlanes[p];\n            for (let i = 0; i < 8; ++i) {\n                if (frustumPlane.dotCoordinate(boundingVectors[i]) < 0) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    /**\n     * Tests if a bounding box defined with 8 vectors intersects frustum planes\n     * @param boundingVectors defines an array of 8 vectors representing a bounding box\n     * @param frustumPlanes defines the frustum planes to test\n     * @returns true if there is an intersection\n     */\n    static IsInFrustum(boundingVectors, frustumPlanes) {\n        for (let p = 0; p < 6; ++p) {\n            let canReturnFalse = true;\n            const frustumPlane = frustumPlanes[p];\n            for (let i = 0; i < 8; ++i) {\n                if (frustumPlane.dotCoordinate(boundingVectors[i]) >= 0) {\n                    canReturnFalse = false;\n                    break;\n                }\n            }\n            if (canReturnFalse) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\nBoundingBox._TmpVector3 = ArrayTools.BuildArray(3, Vector3.Zero);\n//# sourceMappingURL=boundingBox.js.map","import { ArrayTools } from \"../Misc/arrayTools.js\";\nimport { Vector3 } from \"../Maths/math.vector.js\";\n\nimport { BoundingBox } from \"./boundingBox.js\";\nimport { BoundingSphere } from \"./boundingSphere.js\";\nconst _result0 = { min: 0, max: 0 };\nconst _result1 = { min: 0, max: 0 };\nconst computeBoxExtents = (axis, box, result) => {\n    const p = Vector3.Dot(box.centerWorld, axis);\n    const r0 = Math.abs(Vector3.Dot(box.directions[0], axis)) * box.extendSize.x;\n    const r1 = Math.abs(Vector3.Dot(box.directions[1], axis)) * box.extendSize.y;\n    const r2 = Math.abs(Vector3.Dot(box.directions[2], axis)) * box.extendSize.z;\n    const r = r0 + r1 + r2;\n    result.min = p - r;\n    result.max = p + r;\n};\nconst axisOverlap = (axis, box0, box1) => {\n    computeBoxExtents(axis, box0, _result0);\n    computeBoxExtents(axis, box1, _result1);\n    return !(_result0.min > _result1.max || _result1.min > _result0.max);\n};\n/**\n * Info for a bounding data of a mesh\n */\nexport class BoundingInfo {\n    /**\n     * Constructs bounding info\n     * @param minimum min vector of the bounding box/sphere\n     * @param maximum max vector of the bounding box/sphere\n     * @param worldMatrix defines the new world matrix\n     */\n    constructor(minimum, maximum, worldMatrix) {\n        this._isLocked = false;\n        this.boundingBox = new BoundingBox(minimum, maximum, worldMatrix);\n        this.boundingSphere = new BoundingSphere(minimum, maximum, worldMatrix);\n    }\n    /**\n     * Recreates the entire bounding info from scratch as if we call the constructor in place\n     * @param min defines the new minimum vector (in local space)\n     * @param max defines the new maximum vector (in local space)\n     * @param worldMatrix defines the new world matrix\n     */\n    reConstruct(min, max, worldMatrix) {\n        this.boundingBox.reConstruct(min, max, worldMatrix);\n        this.boundingSphere.reConstruct(min, max, worldMatrix);\n    }\n    /**\n     * min vector of the bounding box/sphere\n     */\n    get minimum() {\n        return this.boundingBox.minimum;\n    }\n    /**\n     * max vector of the bounding box/sphere\n     */\n    get maximum() {\n        return this.boundingBox.maximum;\n    }\n    /**\n     * If the info is locked and won't be updated to avoid perf overhead\n     */\n    get isLocked() {\n        return this._isLocked;\n    }\n    set isLocked(value) {\n        this._isLocked = value;\n    }\n    // Methods\n    /**\n     * Updates the bounding sphere and box\n     * @param world world matrix to be used to update\n     */\n    update(world) {\n        if (this._isLocked) {\n            return;\n        }\n        this.boundingBox._update(world);\n        this.boundingSphere._update(world);\n    }\n    /**\n     * Recreate the bounding info to be centered around a specific point given a specific extend.\n     * @param center New center of the bounding info\n     * @param extend New extend of the bounding info\n     * @returns the current bounding info\n     */\n    centerOn(center, extend) {\n        const minimum = BoundingInfo._TmpVector3[0].copyFrom(center).subtractInPlace(extend);\n        const maximum = BoundingInfo._TmpVector3[1].copyFrom(center).addInPlace(extend);\n        this.boundingBox.reConstruct(minimum, maximum, this.boundingBox.getWorldMatrix());\n        this.boundingSphere.reConstruct(minimum, maximum, this.boundingBox.getWorldMatrix());\n        return this;\n    }\n    /**\n     * Grows the bounding info to include the given point.\n     * @param point The point that will be included in the current bounding info\n     * @returns the current bounding info\n     */\n    encapsulate(point) {\n        const minimum = Vector3.Minimize(this.minimum, point);\n        const maximum = Vector3.Maximize(this.maximum, point);\n        this.reConstruct(minimum, maximum, this.boundingBox.getWorldMatrix());\n        return this;\n    }\n    /**\n     * Grows the bounding info to encapsulate the given bounding info.\n     * @param toEncapsulate The bounding info that will be encapsulated in the current bounding info\n     * @returns the current bounding info\n     */\n    encapsulateBoundingInfo(toEncapsulate) {\n        this.encapsulate(toEncapsulate.boundingBox.centerWorld.subtract(toEncapsulate.boundingBox.extendSizeWorld));\n        this.encapsulate(toEncapsulate.boundingBox.centerWorld.add(toEncapsulate.boundingBox.extendSizeWorld));\n        return this;\n    }\n    /**\n     * Scale the current bounding info by applying a scale factor\n     * @param factor defines the scale factor to apply\n     * @returns the current bounding info\n     */\n    scale(factor) {\n        this.boundingBox.scale(factor);\n        this.boundingSphere.scale(factor);\n        return this;\n    }\n    /**\n     * Returns `true` if the bounding info is within the frustum defined by the passed array of planes.\n     * @param frustumPlanes defines the frustum to test\n     * @param strategy defines the strategy to use for the culling (default is BABYLON.AbstractMesh.CULLINGSTRATEGY_STANDARD)\n     * The different strategies available are:\n     * * BABYLON.AbstractMesh.CULLINGSTRATEGY_STANDARD most accurate but slower @see https://doc.babylonjs.com/typedoc/classes/BABYLON.AbstractMesh#CULLINGSTRATEGY_STANDARD\n     * * BABYLON.AbstractMesh.CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY faster but less accurate @see https://doc.babylonjs.com/typedoc/classes/BABYLON.AbstractMesh#CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY\n     * * BABYLON.AbstractMesh.CULLINGSTRATEGY_OPTIMISTIC_INCLUSION can be faster if always visible @see https://doc.babylonjs.com/typedoc/classes/BABYLON.AbstractMesh#CULLINGSTRATEGY_OPTIMISTIC_INCLUSION\n     * * BABYLON.AbstractMesh.CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY can be faster if always visible @see https://doc.babylonjs.com/typedoc/classes/BABYLON.AbstractMesh#CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY\n     * @returns true if the bounding info is in the frustum planes\n     */\n    isInFrustum(frustumPlanes, strategy = 0) {\n        const inclusionTest = strategy === 2 || strategy === 3;\n        if (inclusionTest) {\n            if (this.boundingSphere.isCenterInFrustum(frustumPlanes)) {\n                return true;\n            }\n        }\n        if (!this.boundingSphere.isInFrustum(frustumPlanes)) {\n            return false;\n        }\n        const bSphereOnlyTest = strategy === 1 || strategy === 3;\n        if (bSphereOnlyTest) {\n            return true;\n        }\n        return this.boundingBox.isInFrustum(frustumPlanes);\n    }\n    /**\n     * Gets the world distance between the min and max points of the bounding box\n     */\n    get diagonalLength() {\n        const boundingBox = this.boundingBox;\n        const diag = boundingBox.maximumWorld.subtractToRef(boundingBox.minimumWorld, BoundingInfo._TmpVector3[0]);\n        return diag.length();\n    }\n    /**\n     * Checks if a cullable object (mesh...) is in the camera frustum\n     * Unlike isInFrustum this checks the full bounding box\n     * @param frustumPlanes Camera near/planes\n     * @returns true if the object is in frustum otherwise false\n     */\n    isCompletelyInFrustum(frustumPlanes) {\n        return this.boundingBox.isCompletelyInFrustum(frustumPlanes);\n    }\n    /**\n     * @internal\n     */\n    _checkCollision(collider) {\n        return collider._canDoCollision(this.boundingSphere.centerWorld, this.boundingSphere.radiusWorld, this.boundingBox.minimumWorld, this.boundingBox.maximumWorld);\n    }\n    /**\n     * Checks if a point is inside the bounding box and bounding sphere or the mesh\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/interactions/mesh_intersect\n     * @param point the point to check intersection with\n     * @returns if the point intersects\n     */\n    intersectsPoint(point) {\n        if (!this.boundingSphere.centerWorld) {\n            return false;\n        }\n        if (!this.boundingSphere.intersectsPoint(point)) {\n            return false;\n        }\n        if (!this.boundingBox.intersectsPoint(point)) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Checks if another bounding info intersects the bounding box and bounding sphere or the mesh\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/interactions/mesh_intersect\n     * @param boundingInfo the bounding info to check intersection with\n     * @param precise if the intersection should be done using OBB\n     * @returns if the bounding info intersects\n     */\n    intersects(boundingInfo, precise) {\n        if (!BoundingSphere.Intersects(this.boundingSphere, boundingInfo.boundingSphere)) {\n            return false;\n        }\n        if (!BoundingBox.Intersects(this.boundingBox, boundingInfo.boundingBox)) {\n            return false;\n        }\n        if (!precise) {\n            return true;\n        }\n        const box0 = this.boundingBox;\n        const box1 = boundingInfo.boundingBox;\n        if (!axisOverlap(box0.directions[0], box0, box1)) {\n            return false;\n        }\n        if (!axisOverlap(box0.directions[1], box0, box1)) {\n            return false;\n        }\n        if (!axisOverlap(box0.directions[2], box0, box1)) {\n            return false;\n        }\n        if (!axisOverlap(box1.directions[0], box0, box1)) {\n            return false;\n        }\n        if (!axisOverlap(box1.directions[1], box0, box1)) {\n            return false;\n        }\n        if (!axisOverlap(box1.directions[2], box0, box1)) {\n            return false;\n        }\n        if (!axisOverlap(Vector3.Cross(box0.directions[0], box1.directions[0]), box0, box1)) {\n            return false;\n        }\n        if (!axisOverlap(Vector3.Cross(box0.directions[0], box1.directions[1]), box0, box1)) {\n            return false;\n        }\n        if (!axisOverlap(Vector3.Cross(box0.directions[0], box1.directions[2]), box0, box1)) {\n            return false;\n        }\n        if (!axisOverlap(Vector3.Cross(box0.directions[1], box1.directions[0]), box0, box1)) {\n            return false;\n        }\n        if (!axisOverlap(Vector3.Cross(box0.directions[1], box1.directions[1]), box0, box1)) {\n            return false;\n        }\n        if (!axisOverlap(Vector3.Cross(box0.directions[1], box1.directions[2]), box0, box1)) {\n            return false;\n        }\n        if (!axisOverlap(Vector3.Cross(box0.directions[2], box1.directions[0]), box0, box1)) {\n            return false;\n        }\n        if (!axisOverlap(Vector3.Cross(box0.directions[2], box1.directions[1]), box0, box1)) {\n            return false;\n        }\n        if (!axisOverlap(Vector3.Cross(box0.directions[2], box1.directions[2]), box0, box1)) {\n            return false;\n        }\n        return true;\n    }\n}\nBoundingInfo._TmpVector3 = ArrayTools.BuildArray(2, Vector3.Zero);\n//# sourceMappingURL=boundingInfo.js.map","import { ArrayTools } from \"../Misc/arrayTools.js\";\nimport { Matrix, Vector3 } from \"../Maths/math.vector.js\";\n/**\n * Class used to store bounding sphere information\n */\nexport class BoundingSphere {\n    /**\n     * Creates a new bounding sphere\n     * @param min defines the minimum vector (in local space)\n     * @param max defines the maximum vector (in local space)\n     * @param worldMatrix defines the new world matrix\n     */\n    constructor(min, max, worldMatrix) {\n        /**\n         * Gets the center of the bounding sphere in local space\n         */\n        this.center = Vector3.Zero();\n        /**\n         * Gets the center of the bounding sphere in world space\n         */\n        this.centerWorld = Vector3.Zero();\n        /**\n         * Gets the minimum vector in local space\n         */\n        this.minimum = Vector3.Zero();\n        /**\n         * Gets the maximum vector in local space\n         */\n        this.maximum = Vector3.Zero();\n        this.reConstruct(min, max, worldMatrix);\n    }\n    /**\n     * Recreates the entire bounding sphere from scratch as if we call the constructor in place\n     * @param min defines the new minimum vector (in local space)\n     * @param max defines the new maximum vector (in local space)\n     * @param worldMatrix defines the new world matrix\n     */\n    reConstruct(min, max, worldMatrix) {\n        this.minimum.copyFrom(min);\n        this.maximum.copyFrom(max);\n        const distance = Vector3.Distance(min, max);\n        max.addToRef(min, this.center).scaleInPlace(0.5);\n        this.radius = distance * 0.5;\n        this._update(worldMatrix || Matrix.IdentityReadOnly);\n    }\n    /**\n     * Scale the current bounding sphere by applying a scale factor\n     * @param factor defines the scale factor to apply\n     * @returns the current bounding box\n     */\n    scale(factor) {\n        const newRadius = this.radius * factor;\n        const tmpVectors = BoundingSphere._TmpVector3;\n        const tempRadiusVector = tmpVectors[0].setAll(newRadius);\n        const min = this.center.subtractToRef(tempRadiusVector, tmpVectors[1]);\n        const max = this.center.addToRef(tempRadiusVector, tmpVectors[2]);\n        this.reConstruct(min, max, this._worldMatrix);\n        return this;\n    }\n    /**\n     * Gets the world matrix of the bounding box\n     * @returns a matrix\n     */\n    getWorldMatrix() {\n        return this._worldMatrix;\n    }\n    // Methods\n    /**\n     * @internal\n     */\n    _update(worldMatrix) {\n        if (!worldMatrix.isIdentity()) {\n            Vector3.TransformCoordinatesToRef(this.center, worldMatrix, this.centerWorld);\n            const tempVector = BoundingSphere._TmpVector3[0];\n            Vector3.TransformNormalFromFloatsToRef(1.0, 1.0, 1.0, worldMatrix, tempVector);\n            this.radiusWorld = Math.max(Math.abs(tempVector.x), Math.abs(tempVector.y), Math.abs(tempVector.z)) * this.radius;\n        }\n        else {\n            this.centerWorld.copyFrom(this.center);\n            this.radiusWorld = this.radius;\n        }\n    }\n    /**\n     * Tests if the bounding sphere is intersecting the frustum planes\n     * @param frustumPlanes defines the frustum planes to test\n     * @returns true if there is an intersection\n     */\n    isInFrustum(frustumPlanes) {\n        const center = this.centerWorld;\n        const radius = this.radiusWorld;\n        for (let i = 0; i < 6; i++) {\n            if (frustumPlanes[i].dotCoordinate(center) <= -radius) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Tests if the bounding sphere center is in between the frustum planes.\n     * Used for optimistic fast inclusion.\n     * @param frustumPlanes defines the frustum planes to test\n     * @returns true if the sphere center is in between the frustum planes\n     */\n    isCenterInFrustum(frustumPlanes) {\n        const center = this.centerWorld;\n        for (let i = 0; i < 6; i++) {\n            if (frustumPlanes[i].dotCoordinate(center) < 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Tests if a point is inside the bounding sphere\n     * @param point defines the point to test\n     * @returns true if the point is inside the bounding sphere\n     */\n    intersectsPoint(point) {\n        const squareDistance = Vector3.DistanceSquared(this.centerWorld, point);\n        if (this.radiusWorld * this.radiusWorld < squareDistance) {\n            return false;\n        }\n        return true;\n    }\n    // Statics\n    /**\n     * Checks if two sphere intersect\n     * @param sphere0 sphere 0\n     * @param sphere1 sphere 1\n     * @returns true if the spheres intersect\n     */\n    static Intersects(sphere0, sphere1) {\n        const squareDistance = Vector3.DistanceSquared(sphere0.centerWorld, sphere1.centerWorld);\n        const radiusSum = sphere0.radiusWorld + sphere1.radiusWorld;\n        if (radiusSum * radiusSum < squareDistance) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Creates a sphere from a center and a radius\n     * @param center The center\n     * @param radius radius\n     * @param matrix Optional worldMatrix\n     * @returns The sphere\n     */\n    static CreateFromCenterAndRadius(center, radius, matrix) {\n        this._TmpVector3[0].copyFrom(center);\n        this._TmpVector3[1].copyFromFloats(0, 0, radius);\n        this._TmpVector3[2].copyFrom(center);\n        this._TmpVector3[0].addInPlace(this._TmpVector3[1]);\n        this._TmpVector3[2].subtractInPlace(this._TmpVector3[1]);\n        const sphere = new BoundingSphere(this._TmpVector3[0], this._TmpVector3[2]);\n        if (matrix) {\n            sphere._worldMatrix = matrix;\n        }\n        else {\n            sphere._worldMatrix = Matrix.Identity();\n        }\n        return sphere;\n    }\n}\nBoundingSphere._TmpVector3 = ArrayTools.BuildArray(3, Vector3.Zero);\n//# sourceMappingURL=boundingSphere.js.map","import { Vector3 } from \"../../Maths/math.vector.js\";\nimport { BoundingBox } from \"../../Culling/boundingBox.js\";\n/**\n * Class used to store a cell in an octree\n * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/optimizeOctrees\n */\nexport class OctreeBlock {\n    /**\n     * Creates a new block\n     * @param minPoint defines the minimum vector (in world space) of the block's bounding box\n     * @param maxPoint defines the maximum vector (in world space) of the block's bounding box\n     * @param capacity defines the maximum capacity of this block (if capacity is reached the block will be split into sub blocks)\n     * @param depth defines the current depth of this block in the octree\n     * @param maxDepth defines the maximal depth allowed (beyond this value, the capacity is ignored)\n     * @param creationFunc defines a callback to call when an element is added to the block\n     */\n    constructor(minPoint, maxPoint, capacity, depth, maxDepth, creationFunc) {\n        /**\n         * Gets the content of the current block\n         */\n        this.entries = new Array();\n        this._boundingVectors = new Array();\n        this._capacity = capacity;\n        this._depth = depth;\n        this._maxDepth = maxDepth;\n        this._creationFunc = creationFunc;\n        this._minPoint = minPoint;\n        this._maxPoint = maxPoint;\n        this._boundingVectors.push(minPoint.clone());\n        this._boundingVectors.push(maxPoint.clone());\n        this._boundingVectors.push(minPoint.clone());\n        this._boundingVectors[2].x = maxPoint.x;\n        this._boundingVectors.push(minPoint.clone());\n        this._boundingVectors[3].y = maxPoint.y;\n        this._boundingVectors.push(minPoint.clone());\n        this._boundingVectors[4].z = maxPoint.z;\n        this._boundingVectors.push(maxPoint.clone());\n        this._boundingVectors[5].z = minPoint.z;\n        this._boundingVectors.push(maxPoint.clone());\n        this._boundingVectors[6].x = minPoint.x;\n        this._boundingVectors.push(maxPoint.clone());\n        this._boundingVectors[7].y = minPoint.y;\n    }\n    // Property\n    /**\n     * Gets the maximum capacity of this block (if capacity is reached the block will be split into sub blocks)\n     */\n    get capacity() {\n        return this._capacity;\n    }\n    /**\n     * Gets the minimum vector (in world space) of the block's bounding box\n     */\n    get minPoint() {\n        return this._minPoint;\n    }\n    /**\n     * Gets the maximum vector (in world space) of the block's bounding box\n     */\n    get maxPoint() {\n        return this._maxPoint;\n    }\n    // Methods\n    /**\n     * Add a new element to this block\n     * @param entry defines the element to add\n     */\n    addEntry(entry) {\n        if (this.blocks) {\n            for (let index = 0; index < this.blocks.length; index++) {\n                const block = this.blocks[index];\n                block.addEntry(entry);\n            }\n            return;\n        }\n        this._creationFunc(entry, this);\n        if (this.entries.length > this.capacity && this._depth < this._maxDepth) {\n            this.createInnerBlocks();\n        }\n    }\n    /**\n     * Remove an element from this block\n     * @param entry defines the element to remove\n     */\n    removeEntry(entry) {\n        if (this.blocks) {\n            for (let index = 0; index < this.blocks.length; index++) {\n                const block = this.blocks[index];\n                block.removeEntry(entry);\n            }\n            return;\n        }\n        const entryIndex = this.entries.indexOf(entry);\n        if (entryIndex > -1) {\n            this.entries.splice(entryIndex, 1);\n        }\n    }\n    /**\n     * Add an array of elements to this block\n     * @param entries defines the array of elements to add\n     */\n    addEntries(entries) {\n        for (let index = 0; index < entries.length; index++) {\n            const mesh = entries[index];\n            this.addEntry(mesh);\n        }\n    }\n    /**\n     * Test if the current block intersects the frustum planes and if yes, then add its content to the selection array\n     * @param frustumPlanes defines the frustum planes to test\n     * @param selection defines the array to store current content if selection is positive\n     * @param allowDuplicate defines if the selection array can contains duplicated entries\n     */\n    select(frustumPlanes, selection, allowDuplicate) {\n        if (BoundingBox.IsInFrustum(this._boundingVectors, frustumPlanes)) {\n            if (this.blocks) {\n                for (let index = 0; index < this.blocks.length; index++) {\n                    const block = this.blocks[index];\n                    block.select(frustumPlanes, selection, allowDuplicate);\n                }\n                return;\n            }\n            if (allowDuplicate) {\n                selection.concat(this.entries);\n            }\n            else {\n                selection.concatWithNoDuplicate(this.entries);\n            }\n        }\n    }\n    /**\n     * Test if the current block intersect with the given bounding sphere and if yes, then add its content to the selection array\n     * @param sphereCenter defines the bounding sphere center\n     * @param sphereRadius defines the bounding sphere radius\n     * @param selection defines the array to store current content if selection is positive\n     * @param allowDuplicate defines if the selection array can contains duplicated entries\n     */\n    intersects(sphereCenter, sphereRadius, selection, allowDuplicate) {\n        if (BoundingBox.IntersectsSphere(this._minPoint, this._maxPoint, sphereCenter, sphereRadius)) {\n            if (this.blocks) {\n                for (let index = 0; index < this.blocks.length; index++) {\n                    const block = this.blocks[index];\n                    block.intersects(sphereCenter, sphereRadius, selection, allowDuplicate);\n                }\n                return;\n            }\n            if (allowDuplicate) {\n                selection.concat(this.entries);\n            }\n            else {\n                selection.concatWithNoDuplicate(this.entries);\n            }\n        }\n    }\n    /**\n     * Test if the current block intersect with the given ray and if yes, then add its content to the selection array\n     * @param ray defines the ray to test with\n     * @param selection defines the array to store current content if selection is positive\n     */\n    intersectsRay(ray, selection) {\n        if (ray.intersectsBoxMinMax(this._minPoint, this._maxPoint)) {\n            if (this.blocks) {\n                for (let index = 0; index < this.blocks.length; index++) {\n                    const block = this.blocks[index];\n                    block.intersectsRay(ray, selection);\n                }\n                return;\n            }\n            selection.concatWithNoDuplicate(this.entries);\n        }\n    }\n    /**\n     * Subdivide the content into child blocks (this block will then be empty)\n     */\n    createInnerBlocks() {\n        OctreeBlock._CreateBlocks(this._minPoint, this._maxPoint, this.entries, this._capacity, this._depth, this._maxDepth, this, this._creationFunc);\n        this.entries.splice(0);\n    }\n    /**\n     * @internal\n     */\n    static _CreateBlocks(worldMin, worldMax, entries, maxBlockCapacity, currentDepth, maxDepth, target, creationFunc) {\n        target.blocks = new Array();\n        const blockSize = new Vector3((worldMax.x - worldMin.x) / 2, (worldMax.y - worldMin.y) / 2, (worldMax.z - worldMin.z) / 2);\n        // Segmenting space\n        for (let x = 0; x < 2; x++) {\n            for (let y = 0; y < 2; y++) {\n                for (let z = 0; z < 2; z++) {\n                    const localMin = worldMin.add(blockSize.multiplyByFloats(x, y, z));\n                    const localMax = worldMin.add(blockSize.multiplyByFloats(x + 1, y + 1, z + 1));\n                    const block = new OctreeBlock(localMin, localMax, maxBlockCapacity, currentDepth + 1, maxDepth, creationFunc);\n                    block.addEntries(entries);\n                    target.blocks.push(block);\n                }\n            }\n        }\n    }\n}\n//# sourceMappingURL=octreeBlock.js.map","import { SmartArrayNoDuplicate } from \"../../Misc/smartArray.js\";\nimport { OctreeBlock } from \"./octreeBlock.js\";\n/**\n * Octrees are a really powerful data structure that can quickly select entities based on space coordinates.\n * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/optimizeOctrees\n */\nexport class Octree {\n    /**\n     * Creates a octree\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/optimizeOctrees\n     * @param creationFunc function to be used to instantiate the octree\n     * @param maxBlockCapacity defines the maximum number of meshes you want on your octree's leaves (default: 64)\n     * @param maxDepth defines the maximum depth (sub-levels) for your octree. Default value is 2, which means 8 8 8 = 512 blocks :) (This parameter takes precedence over capacity.)\n     */\n    constructor(creationFunc, maxBlockCapacity, \n    /** Defines the maximum depth (sub-levels) for your octree. Default value is 2, which means 8 8 8 = 512 blocks :) (This parameter takes precedence over capacity.) */\n    maxDepth = 2) {\n        this.maxDepth = maxDepth;\n        /**\n         * Content stored in the octree\n         */\n        this.dynamicContent = new Array();\n        this._maxBlockCapacity = maxBlockCapacity || 64;\n        this._selectionContent = new SmartArrayNoDuplicate(1024);\n        this._creationFunc = creationFunc;\n    }\n    // Methods\n    /**\n     * Updates the octree by adding blocks for the passed in meshes within the min and max world parameters\n     * @param worldMin worldMin for the octree blocks var blockSize = new Vector3((worldMax.x - worldMin.x) / 2, (worldMax.y - worldMin.y) / 2, (worldMax.z - worldMin.z) / 2);\n     * @param worldMax worldMax for the octree blocks var blockSize = new Vector3((worldMax.x - worldMin.x) / 2, (worldMax.y - worldMin.y) / 2, (worldMax.z - worldMin.z) / 2);\n     * @param entries meshes to be added to the octree blocks\n     */\n    update(worldMin, worldMax, entries) {\n        OctreeBlock._CreateBlocks(worldMin, worldMax, entries, this._maxBlockCapacity, 0, this.maxDepth, this, this._creationFunc);\n    }\n    /**\n     * Adds a mesh to the octree\n     * @param entry Mesh to add to the octree\n     */\n    addMesh(entry) {\n        for (let index = 0; index < this.blocks.length; index++) {\n            const block = this.blocks[index];\n            block.addEntry(entry);\n        }\n    }\n    /**\n     * Remove an element from the octree\n     * @param entry defines the element to remove\n     */\n    removeMesh(entry) {\n        for (let index = 0; index < this.blocks.length; index++) {\n            const block = this.blocks[index];\n            block.removeEntry(entry);\n        }\n    }\n    /**\n     * Selects an array of meshes within the frustum\n     * @param frustumPlanes The frustum planes to use which will select all meshes within it\n     * @param allowDuplicate If duplicate objects are allowed in the resulting object array\n     * @returns array of meshes within the frustum\n     */\n    select(frustumPlanes, allowDuplicate) {\n        this._selectionContent.reset();\n        for (let index = 0; index < this.blocks.length; index++) {\n            const block = this.blocks[index];\n            block.select(frustumPlanes, this._selectionContent, allowDuplicate);\n        }\n        if (allowDuplicate) {\n            this._selectionContent.concat(this.dynamicContent);\n        }\n        else {\n            this._selectionContent.concatWithNoDuplicate(this.dynamicContent);\n        }\n        return this._selectionContent;\n    }\n    /**\n     * Test if the octree intersect with the given bounding sphere and if yes, then add its content to the selection array\n     * @param sphereCenter defines the bounding sphere center\n     * @param sphereRadius defines the bounding sphere radius\n     * @param allowDuplicate defines if the selection array can contains duplicated entries\n     * @returns an array of objects that intersect the sphere\n     */\n    intersects(sphereCenter, sphereRadius, allowDuplicate) {\n        this._selectionContent.reset();\n        for (let index = 0; index < this.blocks.length; index++) {\n            const block = this.blocks[index];\n            block.intersects(sphereCenter, sphereRadius, this._selectionContent, allowDuplicate);\n        }\n        if (allowDuplicate) {\n            this._selectionContent.concat(this.dynamicContent);\n        }\n        else {\n            this._selectionContent.concatWithNoDuplicate(this.dynamicContent);\n        }\n        return this._selectionContent;\n    }\n    /**\n     * Test if the octree intersect with the given ray and if yes, then add its content to resulting array\n     * @param ray defines the ray to test with\n     * @returns array of intersected objects\n     */\n    intersectsRay(ray) {\n        this._selectionContent.reset();\n        for (let index = 0; index < this.blocks.length; index++) {\n            const block = this.blocks[index];\n            block.intersectsRay(ray, this._selectionContent);\n        }\n        this._selectionContent.concatWithNoDuplicate(this.dynamicContent);\n        return this._selectionContent;\n    }\n}\n/**\n * Adds a mesh into the octree block if it intersects the block\n * @param entry\n * @param block\n */\nOctree.CreationFuncForMeshes = (entry, block) => {\n    const boundingInfo = entry.getBoundingInfo();\n    if (!entry.isBlocked && boundingInfo.boundingBox.intersectsMinMax(block.minPoint, block.maxPoint)) {\n        block.entries.push(entry);\n    }\n};\n/**\n * Adds a submesh into the octree block if it intersects the block\n * @param entry\n * @param block\n */\nOctree.CreationFuncForSubMeshes = (entry, block) => {\n    const boundingInfo = entry.getBoundingInfo();\n    if (boundingInfo.boundingBox.intersectsMinMax(block.minPoint, block.maxPoint)) {\n        block.entries.push(entry);\n    }\n};\n//# sourceMappingURL=octree.js.map","import { Scene } from \"../../scene.js\";\nimport { Vector3 } from \"../../Maths/math.vector.js\";\nimport { AbstractMesh } from \"../../Meshes/abstractMesh.js\";\nimport { Ray } from \"../../Culling/ray.js\";\nimport { SceneComponentConstants } from \"../../sceneComponent.js\";\nimport { Octree } from \"./octree.js\";\nimport { EngineStore } from \"../../Engines/engineStore.js\";\nScene.prototype.createOrUpdateSelectionOctree = function (maxCapacity = 64, maxDepth = 2) {\n    let component = this._getComponent(SceneComponentConstants.NAME_OCTREE);\n    if (!component) {\n        component = new OctreeSceneComponent(this);\n        this._addComponent(component);\n    }\n    if (!this._selectionOctree) {\n        this._selectionOctree = new Octree(Octree.CreationFuncForMeshes, maxCapacity, maxDepth);\n    }\n    const worldExtends = this.getWorldExtends();\n    // Update octree\n    this._selectionOctree.update(worldExtends.min, worldExtends.max, this.meshes);\n    return this._selectionOctree;\n};\nObject.defineProperty(Scene.prototype, \"selectionOctree\", {\n    get: function () {\n        return this._selectionOctree;\n    },\n    enumerable: true,\n    configurable: true,\n});\n/**\n * This function will create an octree to help to select the right submeshes for rendering, picking and collision computations.\n * Please note that you must have a decent number of submeshes to get performance improvements when using an octree\n * @param maxCapacity defines the maximum size of each block (64 by default)\n * @param maxDepth defines the maximum depth to use (no more than 2 levels by default)\n * @returns the new octree\n * @see https://www.babylonjs-playground.com/#NA4OQ#12\n * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/optimizeOctrees\n */\nAbstractMesh.prototype.createOrUpdateSubmeshesOctree = function (maxCapacity = 64, maxDepth = 2) {\n    const scene = this.getScene();\n    let component = scene._getComponent(SceneComponentConstants.NAME_OCTREE);\n    if (!component) {\n        component = new OctreeSceneComponent(scene);\n        scene._addComponent(component);\n    }\n    if (!this._submeshesOctree) {\n        this._submeshesOctree = new Octree(Octree.CreationFuncForSubMeshes, maxCapacity, maxDepth);\n    }\n    this.computeWorldMatrix(true);\n    const boundingInfo = this.getBoundingInfo();\n    // Update octree\n    const bbox = boundingInfo.boundingBox;\n    this._submeshesOctree.update(bbox.minimumWorld, bbox.maximumWorld, this.subMeshes);\n    return this._submeshesOctree;\n};\n/**\n * Defines the octree scene component responsible to manage any octrees\n * in a given scene.\n */\nexport class OctreeSceneComponent {\n    /**\n     * Creates a new instance of the component for the given scene\n     * @param scene Defines the scene to register the component in\n     */\n    constructor(scene) {\n        /**\n         * The component name help to identify the component in the list of scene components.\n         */\n        this.name = SceneComponentConstants.NAME_OCTREE;\n        /**\n         * Indicates if the meshes have been checked to make sure they are isEnabled()\n         */\n        this.checksIsEnabled = true;\n        this._tempRay = new Ray(Vector3.Zero(), new Vector3(1, 1, 1));\n        scene = scene || EngineStore.LastCreatedScene;\n        if (!scene) {\n            return;\n        }\n        this.scene = scene;\n        this.scene.getActiveMeshCandidates = this.getActiveMeshCandidates.bind(this);\n        this.scene.getActiveSubMeshCandidates = this.getActiveSubMeshCandidates.bind(this);\n        this.scene.getCollidingSubMeshCandidates = this.getCollidingSubMeshCandidates.bind(this);\n        this.scene.getIntersectingSubMeshCandidates = this.getIntersectingSubMeshCandidates.bind(this);\n    }\n    /**\n     * Registers the component in a given scene\n     */\n    register() {\n        this.scene.onMeshRemovedObservable.add((mesh) => {\n            const sceneOctree = this.scene.selectionOctree;\n            if (sceneOctree !== undefined && sceneOctree !== null) {\n                const index = sceneOctree.dynamicContent.indexOf(mesh);\n                if (index !== -1) {\n                    sceneOctree.dynamicContent.splice(index, 1);\n                }\n            }\n        });\n        this.scene.onMeshImportedObservable.add((mesh) => {\n            const sceneOctree = this.scene.selectionOctree;\n            if (sceneOctree !== undefined && sceneOctree !== null) {\n                sceneOctree.addMesh(mesh);\n            }\n        });\n    }\n    /**\n     * Return the list of active meshes\n     * @returns the list of active meshes\n     */\n    getActiveMeshCandidates() {\n        var _a;\n        return ((_a = this.scene._selectionOctree) === null || _a === void 0 ? void 0 : _a.select(this.scene.frustumPlanes)) || this.scene._getDefaultMeshCandidates();\n    }\n    /**\n     * Return the list of active sub meshes\n     * @param mesh The mesh to get the candidates sub meshes from\n     * @returns the list of active sub meshes\n     */\n    getActiveSubMeshCandidates(mesh) {\n        if (mesh._submeshesOctree && mesh.useOctreeForRenderingSelection) {\n            const intersections = mesh._submeshesOctree.select(this.scene.frustumPlanes);\n            return intersections;\n        }\n        return this.scene._getDefaultSubMeshCandidates(mesh);\n    }\n    /**\n     * Return the list of sub meshes intersecting with a given local ray\n     * @param mesh defines the mesh to find the submesh for\n     * @param localRay defines the ray in local space\n     * @returns the list of intersecting sub meshes\n     */\n    getIntersectingSubMeshCandidates(mesh, localRay) {\n        if (mesh._submeshesOctree && mesh.useOctreeForPicking) {\n            Ray.TransformToRef(localRay, mesh.getWorldMatrix(), this._tempRay);\n            const intersections = mesh._submeshesOctree.intersectsRay(this._tempRay);\n            return intersections;\n        }\n        return this.scene._getDefaultSubMeshCandidates(mesh);\n    }\n    /**\n     * Return the list of sub meshes colliding with a collider\n     * @param mesh defines the mesh to find the submesh for\n     * @param collider defines the collider to evaluate the collision against\n     * @returns the list of colliding sub meshes\n     */\n    getCollidingSubMeshCandidates(mesh, collider) {\n        if (mesh._submeshesOctree && mesh.useOctreeForCollisions) {\n            const radius = collider._velocityWorldLength + Math.max(collider._radius.x, collider._radius.y, collider._radius.z);\n            const intersections = mesh._submeshesOctree.intersects(collider._basePointWorld, radius);\n            return intersections;\n        }\n        return this.scene._getDefaultSubMeshCandidates(mesh);\n    }\n    /**\n     * Rebuilds the elements related to this component in case of\n     * context lost for instance.\n     */\n    rebuild() {\n        // Nothing to do here.\n    }\n    /**\n     * Disposes the component and the associated resources.\n     */\n    dispose() {\n        // Nothing to do here.\n    }\n}\n//# sourceMappingURL=octreeSceneComponent.js.map","import { ArrayTools } from \"../Misc/arrayTools.js\";\nimport { Matrix, Vector3, TmpVectors } from \"../Maths/math.vector.js\";\nimport { PickingInfo } from \"../Collisions/pickingInfo.js\";\nimport { IntersectionInfo } from \"../Collisions/intersectionInfo.js\";\nimport { Scene } from \"../scene.js\";\nimport { Camera } from \"../Cameras/camera.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\n/**\n * Class representing a ray with position and direction\n */\nexport class Ray {\n    /**\n     * Creates a new ray\n     * @param origin origin point\n     * @param direction direction\n     * @param length length of the ray\n     */\n    constructor(\n    /** origin point */\n    origin, \n    /** direction */\n    direction, \n    /** length of the ray */\n    length = Number.MAX_VALUE) {\n        this.origin = origin;\n        this.direction = direction;\n        this.length = length;\n    }\n    // Methods\n    /**\n     * Clone the current ray\n     * @returns a new ray\n     */\n    clone() {\n        return new Ray(this.origin.clone(), this.direction.clone(), this.length);\n    }\n    /**\n     * Checks if the ray intersects a box\n     * This does not account for the ray length by design to improve perfs.\n     * @param minimum bound of the box\n     * @param maximum bound of the box\n     * @param intersectionTreshold extra extend to be added to the box in all direction\n     * @returns if the box was hit\n     */\n    intersectsBoxMinMax(minimum, maximum, intersectionTreshold = 0) {\n        const newMinimum = Ray._TmpVector3[0].copyFromFloats(minimum.x - intersectionTreshold, minimum.y - intersectionTreshold, minimum.z - intersectionTreshold);\n        const newMaximum = Ray._TmpVector3[1].copyFromFloats(maximum.x + intersectionTreshold, maximum.y + intersectionTreshold, maximum.z + intersectionTreshold);\n        let d = 0.0;\n        let maxValue = Number.MAX_VALUE;\n        let inv;\n        let min;\n        let max;\n        let temp;\n        if (Math.abs(this.direction.x) < 0.0000001) {\n            if (this.origin.x < newMinimum.x || this.origin.x > newMaximum.x) {\n                return false;\n            }\n        }\n        else {\n            inv = 1.0 / this.direction.x;\n            min = (newMinimum.x - this.origin.x) * inv;\n            max = (newMaximum.x - this.origin.x) * inv;\n            if (max === -Infinity) {\n                max = Infinity;\n            }\n            if (min > max) {\n                temp = min;\n                min = max;\n                max = temp;\n            }\n            d = Math.max(min, d);\n            maxValue = Math.min(max, maxValue);\n            if (d > maxValue) {\n                return false;\n            }\n        }\n        if (Math.abs(this.direction.y) < 0.0000001) {\n            if (this.origin.y < newMinimum.y || this.origin.y > newMaximum.y) {\n                return false;\n            }\n        }\n        else {\n            inv = 1.0 / this.direction.y;\n            min = (newMinimum.y - this.origin.y) * inv;\n            max = (newMaximum.y - this.origin.y) * inv;\n            if (max === -Infinity) {\n                max = Infinity;\n            }\n            if (min > max) {\n                temp = min;\n                min = max;\n                max = temp;\n            }\n            d = Math.max(min, d);\n            maxValue = Math.min(max, maxValue);\n            if (d > maxValue) {\n                return false;\n            }\n        }\n        if (Math.abs(this.direction.z) < 0.0000001) {\n            if (this.origin.z < newMinimum.z || this.origin.z > newMaximum.z) {\n                return false;\n            }\n        }\n        else {\n            inv = 1.0 / this.direction.z;\n            min = (newMinimum.z - this.origin.z) * inv;\n            max = (newMaximum.z - this.origin.z) * inv;\n            if (max === -Infinity) {\n                max = Infinity;\n            }\n            if (min > max) {\n                temp = min;\n                min = max;\n                max = temp;\n            }\n            d = Math.max(min, d);\n            maxValue = Math.min(max, maxValue);\n            if (d > maxValue) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Checks if the ray intersects a box\n     * This does not account for the ray lenght by design to improve perfs.\n     * @param box the bounding box to check\n     * @param intersectionTreshold extra extend to be added to the BoundingBox in all direction\n     * @returns if the box was hit\n     */\n    intersectsBox(box, intersectionTreshold = 0) {\n        return this.intersectsBoxMinMax(box.minimum, box.maximum, intersectionTreshold);\n    }\n    /**\n     * If the ray hits a sphere\n     * @param sphere the bounding sphere to check\n     * @param intersectionTreshold extra extend to be added to the BoundingSphere in all direction\n     * @returns true if it hits the sphere\n     */\n    intersectsSphere(sphere, intersectionTreshold = 0) {\n        const x = sphere.center.x - this.origin.x;\n        const y = sphere.center.y - this.origin.y;\n        const z = sphere.center.z - this.origin.z;\n        const pyth = x * x + y * y + z * z;\n        const radius = sphere.radius + intersectionTreshold;\n        const rr = radius * radius;\n        if (pyth <= rr) {\n            return true;\n        }\n        const dot = x * this.direction.x + y * this.direction.y + z * this.direction.z;\n        if (dot < 0.0) {\n            return false;\n        }\n        const temp = pyth - dot * dot;\n        return temp <= rr;\n    }\n    /**\n     * If the ray hits a triange\n     * @param vertex0 triangle vertex\n     * @param vertex1 triangle vertex\n     * @param vertex2 triangle vertex\n     * @returns intersection information if hit\n     */\n    intersectsTriangle(vertex0, vertex1, vertex2) {\n        const edge1 = Ray._TmpVector3[0];\n        const edge2 = Ray._TmpVector3[1];\n        const pvec = Ray._TmpVector3[2];\n        const tvec = Ray._TmpVector3[3];\n        const qvec = Ray._TmpVector3[4];\n        vertex1.subtractToRef(vertex0, edge1);\n        vertex2.subtractToRef(vertex0, edge2);\n        Vector3.CrossToRef(this.direction, edge2, pvec);\n        const det = Vector3.Dot(edge1, pvec);\n        if (det === 0) {\n            return null;\n        }\n        const invdet = 1 / det;\n        this.origin.subtractToRef(vertex0, tvec);\n        const bv = Vector3.Dot(tvec, pvec) * invdet;\n        if (bv < 0 || bv > 1.0) {\n            return null;\n        }\n        Vector3.CrossToRef(tvec, edge1, qvec);\n        const bw = Vector3.Dot(this.direction, qvec) * invdet;\n        if (bw < 0 || bv + bw > 1.0) {\n            return null;\n        }\n        //check if the distance is longer than the predefined length.\n        const distance = Vector3.Dot(edge2, qvec) * invdet;\n        if (distance > this.length) {\n            return null;\n        }\n        return new IntersectionInfo(1 - bv - bw, bv, distance);\n    }\n    /**\n     * Checks if ray intersects a plane\n     * @param plane the plane to check\n     * @returns the distance away it was hit\n     */\n    intersectsPlane(plane) {\n        let distance;\n        const result1 = Vector3.Dot(plane.normal, this.direction);\n        if (Math.abs(result1) < 9.99999997475243e-7) {\n            return null;\n        }\n        else {\n            const result2 = Vector3.Dot(plane.normal, this.origin);\n            distance = (-plane.d - result2) / result1;\n            if (distance < 0.0) {\n                if (distance < -9.99999997475243e-7) {\n                    return null;\n                }\n                else {\n                    return 0;\n                }\n            }\n            return distance;\n        }\n    }\n    /**\n     * Calculate the intercept of a ray on a given axis\n     * @param axis to check 'x' | 'y' | 'z'\n     * @param offset from axis interception (i.e. an offset of 1y is intercepted above ground)\n     * @returns a vector containing the coordinates where 'axis' is equal to zero (else offset), or null if there is no intercept.\n     */\n    intersectsAxis(axis, offset = 0) {\n        switch (axis) {\n            case \"y\": {\n                const t = (this.origin.y - offset) / this.direction.y;\n                if (t > 0) {\n                    return null;\n                }\n                return new Vector3(this.origin.x + this.direction.x * -t, offset, this.origin.z + this.direction.z * -t);\n            }\n            case \"x\": {\n                const t = (this.origin.x - offset) / this.direction.x;\n                if (t > 0) {\n                    return null;\n                }\n                return new Vector3(offset, this.origin.y + this.direction.y * -t, this.origin.z + this.direction.z * -t);\n            }\n            case \"z\": {\n                const t = (this.origin.z - offset) / this.direction.z;\n                if (t > 0) {\n                    return null;\n                }\n                return new Vector3(this.origin.x + this.direction.x * -t, this.origin.y + this.direction.y * -t, offset);\n            }\n            default:\n                return null;\n        }\n    }\n    /**\n     * Checks if ray intersects a mesh\n     * @param mesh the mesh to check\n     * @param fastCheck defines if the first intersection will be used (and not the closest)\n     * @returns picking info of the intersection\n     */\n    intersectsMesh(mesh, fastCheck) {\n        const tm = TmpVectors.Matrix[0];\n        mesh.getWorldMatrix().invertToRef(tm);\n        if (this._tmpRay) {\n            Ray.TransformToRef(this, tm, this._tmpRay);\n        }\n        else {\n            this._tmpRay = Ray.Transform(this, tm);\n        }\n        return mesh.intersects(this._tmpRay, fastCheck);\n    }\n    /**\n     * Checks if ray intersects a mesh\n     * @param meshes the meshes to check\n     * @param fastCheck defines if the first intersection will be used (and not the closest)\n     * @param results array to store result in\n     * @returns Array of picking infos\n     */\n    intersectsMeshes(meshes, fastCheck, results) {\n        if (results) {\n            results.length = 0;\n        }\n        else {\n            results = [];\n        }\n        for (let i = 0; i < meshes.length; i++) {\n            const pickInfo = this.intersectsMesh(meshes[i], fastCheck);\n            if (pickInfo.hit) {\n                results.push(pickInfo);\n            }\n        }\n        results.sort(this._comparePickingInfo);\n        return results;\n    }\n    _comparePickingInfo(pickingInfoA, pickingInfoB) {\n        if (pickingInfoA.distance < pickingInfoB.distance) {\n            return -1;\n        }\n        else if (pickingInfoA.distance > pickingInfoB.distance) {\n            return 1;\n        }\n        else {\n            return 0;\n        }\n    }\n    /**\n     * Intersection test between the ray and a given segment within a given tolerance (threshold)\n     * @param sega the first point of the segment to test the intersection against\n     * @param segb the second point of the segment to test the intersection against\n     * @param threshold the tolerance margin, if the ray doesn't intersect the segment but is close to the given threshold, the intersection is successful\n     * @returns the distance from the ray origin to the intersection point if there's intersection, or -1 if there's no intersection\n     */\n    intersectionSegment(sega, segb, threshold) {\n        const o = this.origin;\n        const u = TmpVectors.Vector3[0];\n        const rsegb = TmpVectors.Vector3[1];\n        const v = TmpVectors.Vector3[2];\n        const w = TmpVectors.Vector3[3];\n        segb.subtractToRef(sega, u);\n        this.direction.scaleToRef(Ray._Rayl, v);\n        o.addToRef(v, rsegb);\n        sega.subtractToRef(o, w);\n        const a = Vector3.Dot(u, u); // always >= 0\n        const b = Vector3.Dot(u, v);\n        const c = Vector3.Dot(v, v); // always >= 0\n        const d = Vector3.Dot(u, w);\n        const e = Vector3.Dot(v, w);\n        const D = a * c - b * b; // always >= 0\n        let sN, sD = D; // sc = sN / sD, default sD = D >= 0\n        let tN, tD = D; // tc = tN / tD, default tD = D >= 0\n        // compute the line parameters of the two closest points\n        if (D < Ray._Smallnum) {\n            // the lines are almost parallel\n            sN = 0.0; // force using point P0 on segment S1\n            sD = 1.0; // to prevent possible division by 0.0 later\n            tN = e;\n            tD = c;\n        }\n        else {\n            // get the closest points on the infinite lines\n            sN = b * e - c * d;\n            tN = a * e - b * d;\n            if (sN < 0.0) {\n                // sc < 0 => the s=0 edge is visible\n                sN = 0.0;\n                tN = e;\n                tD = c;\n            }\n            else if (sN > sD) {\n                // sc > 1 => the s=1 edge is visible\n                sN = sD;\n                tN = e + b;\n                tD = c;\n            }\n        }\n        if (tN < 0.0) {\n            // tc < 0 => the t=0 edge is visible\n            tN = 0.0;\n            // recompute sc for this edge\n            if (-d < 0.0) {\n                sN = 0.0;\n            }\n            else if (-d > a) {\n                sN = sD;\n            }\n            else {\n                sN = -d;\n                sD = a;\n            }\n        }\n        else if (tN > tD) {\n            // tc > 1 => the t=1 edge is visible\n            tN = tD;\n            // recompute sc for this edge\n            if (-d + b < 0.0) {\n                sN = 0;\n            }\n            else if (-d + b > a) {\n                sN = sD;\n            }\n            else {\n                sN = -d + b;\n                sD = a;\n            }\n        }\n        // finally do the division to get sc and tc\n        const sc = Math.abs(sN) < Ray._Smallnum ? 0.0 : sN / sD;\n        const tc = Math.abs(tN) < Ray._Smallnum ? 0.0 : tN / tD;\n        // get the difference of the two closest points\n        const qtc = TmpVectors.Vector3[4];\n        v.scaleToRef(tc, qtc);\n        const qsc = TmpVectors.Vector3[5];\n        u.scaleToRef(sc, qsc);\n        qsc.addInPlace(w);\n        const dP = TmpVectors.Vector3[6];\n        qsc.subtractToRef(qtc, dP); // = S1(sc) - S2(tc)\n        const isIntersected = tc > 0 && tc <= this.length && dP.lengthSquared() < threshold * threshold; // return intersection result\n        if (isIntersected) {\n            return qsc.length();\n        }\n        return -1;\n    }\n    /**\n     * Update the ray from viewport position\n     * @param x position\n     * @param y y position\n     * @param viewportWidth viewport width\n     * @param viewportHeight viewport height\n     * @param world world matrix\n     * @param view view matrix\n     * @param projection projection matrix\n     * @param enableDistantPicking defines if picking should handle large values for mesh position/scaling (false by default)\n     * @returns this ray updated\n     */\n    update(x, y, viewportWidth, viewportHeight, world, view, projection, enableDistantPicking = false) {\n        if (enableDistantPicking) {\n            // With world matrices having great values (like 8000000000 on 1 or more scaling or position axis),\n            // multiplying view/projection/world and doing invert will result in loss of float precision in the matrix.\n            // One way to fix it is to compute the ray with world at identity then transform the ray in object space.\n            // This is slower (2 matrix inverts instead of 1) but precision is preserved.\n            // This is hidden behind `EnableDistantPicking` flag (default is false)\n            if (!Ray._RayDistant) {\n                Ray._RayDistant = Ray.Zero();\n            }\n            Ray._RayDistant.unprojectRayToRef(x, y, viewportWidth, viewportHeight, Matrix.IdentityReadOnly, view, projection);\n            const tm = TmpVectors.Matrix[0];\n            world.invertToRef(tm);\n            Ray.TransformToRef(Ray._RayDistant, tm, this);\n        }\n        else {\n            this.unprojectRayToRef(x, y, viewportWidth, viewportHeight, world, view, projection);\n        }\n        return this;\n    }\n    // Statics\n    /**\n     * Creates a ray with origin and direction of 0,0,0\n     * @returns the new ray\n     */\n    static Zero() {\n        return new Ray(Vector3.Zero(), Vector3.Zero());\n    }\n    /**\n     * Creates a new ray from screen space and viewport\n     * @param x position\n     * @param y y position\n     * @param viewportWidth viewport width\n     * @param viewportHeight viewport height\n     * @param world world matrix\n     * @param view view matrix\n     * @param projection projection matrix\n     * @returns new ray\n     */\n    static CreateNew(x, y, viewportWidth, viewportHeight, world, view, projection) {\n        const result = Ray.Zero();\n        return result.update(x, y, viewportWidth, viewportHeight, world, view, projection);\n    }\n    /**\n     * Function will create a new transformed ray starting from origin and ending at the end point. Ray's length will be set, and ray will be\n     * transformed to the given world matrix.\n     * @param origin The origin point\n     * @param end The end point\n     * @param world a matrix to transform the ray to. Default is the identity matrix.\n     * @returns the new ray\n     */\n    static CreateNewFromTo(origin, end, world = Matrix.IdentityReadOnly) {\n        const direction = end.subtract(origin);\n        const length = Math.sqrt(direction.x * direction.x + direction.y * direction.y + direction.z * direction.z);\n        direction.normalize();\n        return Ray.Transform(new Ray(origin, direction, length), world);\n    }\n    /**\n     * Transforms a ray by a matrix\n     * @param ray ray to transform\n     * @param matrix matrix to apply\n     * @returns the resulting new ray\n     */\n    static Transform(ray, matrix) {\n        const result = new Ray(new Vector3(0, 0, 0), new Vector3(0, 0, 0));\n        Ray.TransformToRef(ray, matrix, result);\n        return result;\n    }\n    /**\n     * Transforms a ray by a matrix\n     * @param ray ray to transform\n     * @param matrix matrix to apply\n     * @param result ray to store result in\n     */\n    static TransformToRef(ray, matrix, result) {\n        Vector3.TransformCoordinatesToRef(ray.origin, matrix, result.origin);\n        Vector3.TransformNormalToRef(ray.direction, matrix, result.direction);\n        result.length = ray.length;\n        const dir = result.direction;\n        const len = dir.length();\n        if (!(len === 0 || len === 1)) {\n            const num = 1.0 / len;\n            dir.x *= num;\n            dir.y *= num;\n            dir.z *= num;\n            result.length *= len;\n        }\n    }\n    /**\n     * Unproject a ray from screen space to object space\n     * @param sourceX defines the screen space x coordinate to use\n     * @param sourceY defines the screen space y coordinate to use\n     * @param viewportWidth defines the current width of the viewport\n     * @param viewportHeight defines the current height of the viewport\n     * @param world defines the world matrix to use (can be set to Identity to go to world space)\n     * @param view defines the view matrix to use\n     * @param projection defines the projection matrix to use\n     */\n    unprojectRayToRef(sourceX, sourceY, viewportWidth, viewportHeight, world, view, projection) {\n        var _a;\n        const matrix = TmpVectors.Matrix[0];\n        world.multiplyToRef(view, matrix);\n        matrix.multiplyToRef(projection, matrix);\n        matrix.invert();\n        const nearScreenSource = TmpVectors.Vector3[0];\n        nearScreenSource.x = (sourceX / viewportWidth) * 2 - 1;\n        nearScreenSource.y = -((sourceY / viewportHeight) * 2 - 1);\n        nearScreenSource.z = ((_a = EngineStore.LastCreatedEngine) === null || _a === void 0 ? void 0 : _a.isNDCHalfZRange) ? 0 : -1;\n        // far Z need to be close but < to 1 or camera projection matrix with maxZ = 0 will NaN\n        const farScreenSource = TmpVectors.Vector3[1].copyFromFloats(nearScreenSource.x, nearScreenSource.y, 1.0 - 1e-8);\n        const nearVec3 = TmpVectors.Vector3[2];\n        const farVec3 = TmpVectors.Vector3[3];\n        Vector3._UnprojectFromInvertedMatrixToRef(nearScreenSource, matrix, nearVec3);\n        Vector3._UnprojectFromInvertedMatrixToRef(farScreenSource, matrix, farVec3);\n        this.origin.copyFrom(nearVec3);\n        farVec3.subtractToRef(nearVec3, this.direction);\n        this.direction.normalize();\n    }\n}\nRay._TmpVector3 = ArrayTools.BuildArray(6, Vector3.Zero);\nRay._RayDistant = Ray.Zero();\nRay._Smallnum = 0.00000001;\nRay._Rayl = 10e8;\nScene.prototype.createPickingRay = function (x, y, world, camera, cameraViewSpace = false) {\n    const result = Ray.Zero();\n    this.createPickingRayToRef(x, y, world, result, camera, cameraViewSpace);\n    return result;\n};\nScene.prototype.createPickingRayToRef = function (x, y, world, result, camera, cameraViewSpace = false, enableDistantPicking = false) {\n    const engine = this.getEngine();\n    if (!camera) {\n        if (!this.activeCamera) {\n            return this;\n        }\n        camera = this.activeCamera;\n    }\n    const cameraViewport = camera.viewport;\n    const viewport = cameraViewport.toGlobal(engine.getRenderWidth(), engine.getRenderHeight());\n    // Moving coordinates to local viewport world\n    x = x / engine.getHardwareScalingLevel() - viewport.x;\n    y = y / engine.getHardwareScalingLevel() - (engine.getRenderHeight() - viewport.y - viewport.height);\n    result.update(x, y, viewport.width, viewport.height, world ? world : Matrix.IdentityReadOnly, cameraViewSpace ? Matrix.IdentityReadOnly : camera.getViewMatrix(), camera.getProjectionMatrix(), enableDistantPicking);\n    return this;\n};\nScene.prototype.createPickingRayInCameraSpace = function (x, y, camera) {\n    const result = Ray.Zero();\n    this.createPickingRayInCameraSpaceToRef(x, y, result, camera);\n    return result;\n};\nScene.prototype.createPickingRayInCameraSpaceToRef = function (x, y, result, camera) {\n    if (!PickingInfo) {\n        return this;\n    }\n    const engine = this.getEngine();\n    if (!camera) {\n        if (!this.activeCamera) {\n            throw new Error(\"Active camera not set\");\n        }\n        camera = this.activeCamera;\n    }\n    const cameraViewport = camera.viewport;\n    const viewport = cameraViewport.toGlobal(engine.getRenderWidth(), engine.getRenderHeight());\n    const identity = Matrix.Identity();\n    // Moving coordinates to local viewport world\n    x = x / engine.getHardwareScalingLevel() - viewport.x;\n    y = y / engine.getHardwareScalingLevel() - (engine.getRenderHeight() - viewport.y - viewport.height);\n    result.update(x, y, viewport.width, viewport.height, identity, identity, camera.getProjectionMatrix());\n    return this;\n};\nScene.prototype._internalPickForMesh = function (pickingInfo, rayFunction, mesh, world, fastCheck, onlyBoundingInfo, trianglePredicate, skipBoundingInfo) {\n    const ray = rayFunction(world, mesh.enableDistantPicking);\n    const result = mesh.intersects(ray, fastCheck, trianglePredicate, onlyBoundingInfo, world, skipBoundingInfo);\n    if (!result || !result.hit) {\n        return null;\n    }\n    if (!fastCheck && pickingInfo != null && result.distance >= pickingInfo.distance) {\n        return null;\n    }\n    return result;\n};\nScene.prototype._internalPick = function (rayFunction, predicate, fastCheck, onlyBoundingInfo, trianglePredicate) {\n    let pickingInfo = null;\n    const computeWorldMatrixForCamera = !!(this.activeCameras && this.activeCameras.length > 1 && this.cameraToUseForPointers !== this.activeCamera);\n    const currentCamera = this.cameraToUseForPointers || this.activeCamera;\n    for (let meshIndex = 0; meshIndex < this.meshes.length; meshIndex++) {\n        const mesh = this.meshes[meshIndex];\n        if (predicate) {\n            if (!predicate(mesh)) {\n                continue;\n            }\n        }\n        else if (!mesh.isEnabled() || !mesh.isVisible || !mesh.isPickable) {\n            continue;\n        }\n        const forceCompute = computeWorldMatrixForCamera && mesh.isWorldMatrixCameraDependent();\n        const world = mesh.computeWorldMatrix(forceCompute, currentCamera);\n        if (mesh.hasThinInstances && mesh.thinInstanceEnablePicking) {\n            // first check if the ray intersects the whole bounding box/sphere of the mesh\n            const result = this._internalPickForMesh(pickingInfo, rayFunction, mesh, world, true, true, trianglePredicate);\n            if (result) {\n                if (onlyBoundingInfo) {\n                    // the user only asked for a bounding info check so we can return\n                    return result;\n                }\n                const tmpMatrix = TmpVectors.Matrix[1];\n                const thinMatrices = mesh.thinInstanceGetWorldMatrices();\n                for (let index = 0; index < thinMatrices.length; index++) {\n                    const thinMatrix = thinMatrices[index];\n                    thinMatrix.multiplyToRef(world, tmpMatrix);\n                    const result = this._internalPickForMesh(pickingInfo, rayFunction, mesh, tmpMatrix, fastCheck, onlyBoundingInfo, trianglePredicate, true);\n                    if (result) {\n                        pickingInfo = result;\n                        pickingInfo.thinInstanceIndex = index;\n                        if (fastCheck) {\n                            return pickingInfo;\n                        }\n                    }\n                }\n            }\n        }\n        else {\n            const result = this._internalPickForMesh(pickingInfo, rayFunction, mesh, world, fastCheck, onlyBoundingInfo, trianglePredicate);\n            if (result) {\n                pickingInfo = result;\n                if (fastCheck) {\n                    return pickingInfo;\n                }\n            }\n        }\n    }\n    return pickingInfo || new PickingInfo();\n};\nScene.prototype._internalMultiPick = function (rayFunction, predicate, trianglePredicate) {\n    if (!PickingInfo) {\n        return null;\n    }\n    const pickingInfos = new Array();\n    const computeWorldMatrixForCamera = !!(this.activeCameras && this.activeCameras.length > 1 && this.cameraToUseForPointers !== this.activeCamera);\n    const currentCamera = this.cameraToUseForPointers || this.activeCamera;\n    for (let meshIndex = 0; meshIndex < this.meshes.length; meshIndex++) {\n        const mesh = this.meshes[meshIndex];\n        if (predicate) {\n            if (!predicate(mesh)) {\n                continue;\n            }\n        }\n        else if (!mesh.isEnabled() || !mesh.isVisible || !mesh.isPickable) {\n            continue;\n        }\n        const forceCompute = computeWorldMatrixForCamera && mesh.isWorldMatrixCameraDependent();\n        const world = mesh.computeWorldMatrix(forceCompute, currentCamera);\n        if (mesh.hasThinInstances && mesh.thinInstanceEnablePicking) {\n            const result = this._internalPickForMesh(null, rayFunction, mesh, world, true, true, trianglePredicate);\n            if (result) {\n                const tmpMatrix = TmpVectors.Matrix[1];\n                const thinMatrices = mesh.thinInstanceGetWorldMatrices();\n                for (let index = 0; index < thinMatrices.length; index++) {\n                    const thinMatrix = thinMatrices[index];\n                    thinMatrix.multiplyToRef(world, tmpMatrix);\n                    const result = this._internalPickForMesh(null, rayFunction, mesh, tmpMatrix, false, false, trianglePredicate, true);\n                    if (result) {\n                        result.thinInstanceIndex = index;\n                        pickingInfos.push(result);\n                    }\n                }\n            }\n        }\n        else {\n            const result = this._internalPickForMesh(null, rayFunction, mesh, world, false, false, trianglePredicate);\n            if (result) {\n                pickingInfos.push(result);\n            }\n        }\n    }\n    return pickingInfos;\n};\nScene.prototype.pickWithBoundingInfo = function (x, y, predicate, fastCheck, camera) {\n    if (!PickingInfo) {\n        return null;\n    }\n    const result = this._internalPick((world) => {\n        if (!this._tempPickingRay) {\n            this._tempPickingRay = Ray.Zero();\n        }\n        this.createPickingRayToRef(x, y, world, this._tempPickingRay, camera || null);\n        return this._tempPickingRay;\n    }, predicate, fastCheck, true);\n    if (result) {\n        result.ray = this.createPickingRay(x, y, Matrix.Identity(), camera || null);\n    }\n    return result;\n};\nObject.defineProperty(Scene.prototype, \"_pickingAvailable\", {\n    get: () => true,\n    enumerable: false,\n    configurable: false,\n});\nScene.prototype.pick = function (x, y, predicate, fastCheck, camera, trianglePredicate, _enableDistantPicking = false) {\n    const result = this._internalPick((world, enableDistantPicking) => {\n        if (!this._tempPickingRay) {\n            this._tempPickingRay = Ray.Zero();\n        }\n        this.createPickingRayToRef(x, y, world, this._tempPickingRay, camera || null, false, enableDistantPicking);\n        return this._tempPickingRay;\n    }, predicate, fastCheck, false, trianglePredicate);\n    if (result) {\n        result.ray = this.createPickingRay(x, y, Matrix.Identity(), camera || null);\n    }\n    return result;\n};\nScene.prototype.pickWithRay = function (ray, predicate, fastCheck, trianglePredicate) {\n    const result = this._internalPick((world) => {\n        if (!this._pickWithRayInverseMatrix) {\n            this._pickWithRayInverseMatrix = Matrix.Identity();\n        }\n        world.invertToRef(this._pickWithRayInverseMatrix);\n        if (!this._cachedRayForTransform) {\n            this._cachedRayForTransform = Ray.Zero();\n        }\n        Ray.TransformToRef(ray, this._pickWithRayInverseMatrix, this._cachedRayForTransform);\n        return this._cachedRayForTransform;\n    }, predicate, fastCheck, false, trianglePredicate);\n    if (result) {\n        result.ray = ray;\n    }\n    return result;\n};\nScene.prototype.multiPick = function (x, y, predicate, camera, trianglePredicate) {\n    return this._internalMultiPick((world) => this.createPickingRay(x, y, world, camera || null), predicate, trianglePredicate);\n};\nScene.prototype.multiPickWithRay = function (ray, predicate, trianglePredicate) {\n    return this._internalMultiPick((world) => {\n        if (!this._pickWithRayInverseMatrix) {\n            this._pickWithRayInverseMatrix = Matrix.Identity();\n        }\n        world.invertToRef(this._pickWithRayInverseMatrix);\n        if (!this._cachedRayForTransform) {\n            this._cachedRayForTransform = Ray.Zero();\n        }\n        Ray.TransformToRef(ray, this._pickWithRayInverseMatrix, this._cachedRayForTransform);\n        return this._cachedRayForTransform;\n    }, predicate, trianglePredicate);\n};\nCamera.prototype.getForwardRay = function (length = 100, transform, origin) {\n    return this.getForwardRayToRef(new Ray(Vector3.Zero(), Vector3.Zero(), length), length, transform, origin);\n};\nCamera.prototype.getForwardRayToRef = function (refRay, length = 100, transform, origin) {\n    if (!transform) {\n        transform = this.getWorldMatrix();\n    }\n    refRay.length = length;\n    if (!origin) {\n        refRay.origin.copyFrom(this.position);\n    }\n    else {\n        refRay.origin.copyFrom(origin);\n    }\n    TmpVectors.Vector3[2].set(0, 0, this._scene.useRightHandedSystem ? -1 : 1);\n    Vector3.TransformNormalToRef(TmpVectors.Vector3[2], transform, TmpVectors.Vector3[3]);\n    Vector3.NormalizeToRef(TmpVectors.Vector3[3], refRay.direction);\n    return refRay;\n};\n//# sourceMappingURL=ray.js.map"],"names":["Bone","N","_matrix","this","_compose","_localMatrix","value","_needToCompose","updateFlag","copyFrom","_markAsDirtyAndDecompose","constructor","name","skeleton","parentBone","localMatrix","restPose","baseMatrix","index","super","getScene","children","Array","animations","_index","_absoluteTransform","_invertedAbsoluteTransform","_scalingDeterminant","_worldTransform","_needToDecompose","_linkedTransformNode","_waitingTransformNodeId","_skeleton","clone","_restPose","_baseMatrix","bones","push","setParent","_updateDifferenceMatrix","getClassName","getSkeleton","parent","_parentNode","getParent","getChildren","getIndex","indexOf","newParent","updateDifferenceMatrix","splice","markAsDirty","getLocalMatrix","getBaseMatrix","getRestPose","setRestPose","matrix","getBindPose","setBindPose","updateMatrix","getWorldMatrix","returnToRest","_a","localScaling","localRotation","localPosition","decompose","position","rotationQuaternion","scaling","getInvertedAbsoluteTransform","getAbsoluteTransform","linkTransformNode","transformNode","_numBonesWithLinkedTransformNode","getTransformNode","_decompose","_localPosition","newPosition","_markAsDirtyAndCompose","rotation","getRotation","newRotation","setRotation","_localRotation","setRotationQuaternion","getScale","newScaling","setScale","animationPropertiesOverride","_localScaling","updateLocalMatrix","rootMatrix","updateChildren","multiplyToRef","invertToRef","length","determinant","_currentRenderId","_childUpdateId","_markAsDirty","translate","vec","space","tNode","lm","addAtIndex","x","y","z","wm","computeAbsoluteTransforms","tmat","_TmpMats","tvec","_TmpVecs","setTranslationFromFloats","invert","setPosition","setAbsolutePosition","scale","scaleChildren","locMat","scaleMat","child","cm","multiplyAtIndex","getScaleToRef","result","setYawPitchRoll","yaw","pitch","roll","quat","_TmpQuat","rotMatInv","_getNegativeRotationToRef","rotMat","_rotateWithMatrix","rotate","axis","amount","rmat","setAxisAngle","angle","setRotationMatrix","rotMat2","lmat","lx","m","ly","lz","parentScale","parentScaleInv","scaleMatrix","isNaN","getPosition","pos","getPositionToRef","getAbsolutePosition","getAbsolutePositionToRef","poseMatrix","getPoseMatrix","len","i","getDirection","localAxis","getDirectionToRef","mat","normalize","getRotationToRef","getRotationQuaternionToRef","toEulerAnglesToRef","getRotationQuaternion","amat","undefined","getRotationMatrix","getRotationMatrixToRef","getAbsolutePositionFromLocal","getAbsolutePositionFromLocalToRef","getLocalPositionFromAbsolute","getLocalPositionFromAbsoluteToRef","setCurrentPoseAsRest","BoneIKController","maxAngle","_maxAngle","_setMaxAngle","mesh","bone","options","targetPosition","poleTargetPosition","poleTargetLocalOffset","poleAngle","slerpAmount","_bone1Quat","_bone1Mat","_bone2Ang","Math","PI","_rightHandedSystem","_bendAxis","_slerping","_adjustRoll","_notEnoughInformation","_bone2","bone1","_bone1","bonePos","boneScale1","boneScale2","_bone1Length","_bone2Length","computeWorldMatrix","pos1","pos2","pos3","targetMesh","poleTargetMesh","poleTargetBone","bendAxis","ang","a","b","_maxReach","sqrt","cos","update","target","poleTarget","mat1","mat2","zaxis","xaxis","yaxis","upAxis","tmpQuat","subtractToRef","c","min","acosa","acosb","angA","acos","angB","angC","_tmpVec","_updateLinkedTransformRotation","BoneLookController","minYaw","_minYaw","_minYawSin","sin","_minYawCos","_maxYaw","_midYawConstraint","_getAngleDiff","_yawRange","maxYaw","_maxYawSin","_maxYawCos","minPitch","_minPitch","_minPitchTan","tan","maxPitch","_maxPitch","_maxPitchTan","upAxisSpace","adjustYaw","adjustPitch","adjustRoll","_boneQuat","_firstFrameSkipped","_fowardAxis","yawAxis","pitchAxis","newYawAxis","newPitchAxis","newRollAxis","_transformYawPitch","_transformYawPitchInv","_tmpMat1","_tmpMat2","checkYaw","checkPitch","spaceMat","spaceMatInv","forwardAxis","rightAxis","xzlen","localTarget","atan2","newPitch","addInPlace","newYaw","_isAngleBetween","boneFwd","boneRotMat","toRotationMatrix","boneYaw","_getAngleBetween","angBtwMax","ang1","ang2","angDiff","ab","Skeleton","useTextureToStoreBoneMatrices","_useTextureToStoreBoneMatrices","_animationPropertiesOverride","_scene","isUsingTextureForMatrices","_canUseTextureForBones","uniqueId","_uniqueId","id","scene","needInitialSkinMatrix","_isDirty","_meshesWithPoseMatrix","_identity","_ranges","_absoluteTransformIsDirty","_hasWaitingData","_parentContainer","doNotSerialize","onBeforeComputeObservable","getUniqueId","addSkeleton","engineCaps","getEngine","getCaps","textureFloat","maxVertexTextureImageUnits","filter","getTransformMatrices","_bonesTransformMatrices","prepare","_transformMatrices","getTransformMatrixTexture","_transformMatrixTexture","toString","fullDetails","ret","Object","keys","first","getBoneIndexByName","boneIndex","cache","createAnimationRange","from","to","nBones","createRange","deleteAnimationRange","deleteFrames","deleteRange","getAnimationRange","getAnimationRanges","animationRanges","copyAnimationRange","source","rescaleAsRequired","frameOffset","_getHighestAnimationFrame","boneDict","sourceBones","skelDimensionsRatio","dimensionsAtRest","divide","boneName","sourceBone","range","highest","getHighestFrame","beginAnimation","loop","speedRatio","onAnimationEnd","static","referenceFrame","rangeValue","sceneAnimatables","getAllAnimatablesByTarget","rangeAnimatable","sceneAnimatable","fromFrame","toFrame","animatables","getAnimatables","animIndex","isAdditive","_registerMeshWithPoseMatrix","_unregisterMeshWithPoseMatrix","_computeTransformMatrices","targetMatrix","initialSkinMatrix","notifyObservers","mappedIndex","multiplyToArray","copyToArray","node","needsUpdate","Float32Array","_synchronizedWithMesh","textureWidth","getSize","width","dispose","_animatables","parentIndex","rangeName","enableBlending","blendingSpeed","forEach","animation","stopAnimation","removeSkeleton","skeletons","serialize","serializationObject","asArray","serializedBone","parentBoneIndex","toArray","rest","linkedTransformNodeId","metadata","ranges","parsedSkeleton","parsedBone","parsedBoneIndex","data","forceUpdate","sortBones","visited","_sortBones","Buffer","engine","updatable","stride","postponeInternalCreation","instanced","useBytes","divisor","_isAlreadyOwned","_engine","_updatable","_instanced","_divisor","_data","_buffer","byteStride","BYTES_PER_ELEMENT","create","createVertexBuffer","kind","offset","size","byteOffset","VertexBuffer","isUpdatable","getData","getBuffer","getStrideSize","updateDynamicVertexBuffer","createDynamicVertexBuffer","_rebuild","updateDirectly","vertexCount","_increaseReferences","references","_releaseBuffer","instanceDivisor","_instanceDivisor","isInstanced","_computeHashCode","type","normalized","takeBufferOwnership","_ownsBuffer","_Counter","_kind","vertexData","FLOAT","Int8Array","BYTE","Uint8Array","UNSIGNED_BYTE","Int16Array","SHORT","Uint16Array","UNSIGNED_SHORT","Int32Array","INT","Uint32Array","UNSIGNED_INT","typeByteLength","GetTypeByteLength","_size","DeduceStride","hashCode","getKind","getFloatData","totalVertices","forceCopy","tightlyPackedByteStride","count","copy","slice","ArrayBuffer","buffer","set","remainder","max","getOffset","sizeInBytes","getIsInstanced","getInstanceDivisor","callback","ForEach","UVKind","UV2Kind","UV3Kind","UV4Kind","UV5Kind","UV6Kind","NormalKind","PositionKind","ColorKind","MatricesIndicesKind","MatricesIndicesExtraKind","MatricesWeightsKind","MatricesWeightsExtraKind","TangentKind","Error","componentCount","componentType","componentIndex","dataView","DataView","byteLength","componentByteLength","componentByteOffset","_GetFloatValue","getInt8","getUint8","getInt16","getUint16","getInt32","getUint32","getFloat32","ColorInstanceKind","DataBuffer","underlyingResource","capacity","is32Bits","StorageBuffer","creationFlags","_storageBuffers","_create","_bufferSize","_creationFlags","createStorageBuffer","updateStorageBuffer","read","readFromStorageBuffer","storageBuffers","pop","BaseCameraMouseWheelInput","wheelPrecisionX","wheelPrecisionY","wheelPrecisionZ","onChangedObservable","_wheelDeltaX","_wheelDeltaY","_wheelDeltaZ","_ffMultiplier","_normalize","attachControl","noPreventDefault","arguments","_wheel","pointer","event","platformScale","deltaMode","deltaX","deltaY","deltaZ","preventDefault","_observer","camera","_inputManager","_addCameraPointerObserver","detachControl","_removeCameraPointerObserver","clear","checkInputs","wheelDeltaX","wheelDeltaY","wheelDeltaZ","getSimpleName","prototype","BaseCameraPointersInput","_currentActiveButton","buttons","element","getInputElement","previousPinchSquaredDistance","previousMultiTouchPanPosition","_pointA","_pointB","_altKey","_ctrlKey","_metaKey","_shiftKey","_buttonsPressed","_pointerInput","p","_b","evt","isTouch","pointerType","isInVRExclusivePointerMode","button","srcElement","altKey","ctrlKey","metaKey","shiftKey","isPointerLock","offsetX","movementX","offsetY","movementY","onTouch","pointerId","onDoubleTap","clientX","clientY","ed","distX","distY","pinchSquaredDistance","multiTouchPanPosition","onMultiTouch","releasePointerCapture","e","_badOS","onButtonUp","setPointerCapture","onButtonDown","focus","_onLostFocus","onLostFocus","_contextMenuBind","onContextMenu","bind","addEventListener","hostWindow","getHostWindow","handler","inputElement","removeEventListener","point","ArcRotateCameraGamepadInput","gamepadRotationSensibility","gamepadMoveSensibility","_yAxisScale","invertYAxis","manager","gamepadManager","_onGamepadConnectedObserver","onGamepadConnectedObservable","add","gamepad","_onGamepadDisconnectedObserver","onGamepadDisconnectedObservable","getGamepadByType","remove","rsValues","rightStick","normalizedRX","abs","inertialAlphaOffset","normalizedRY","inertialBetaOffset","lsValues","leftStick","normalizedLY","inertialRadiusOffset","ArcRotateCameraKeyboardMoveInput","keysUp","keysDown","keysLeft","keysRight","keysReset","panningSensibility","zoomingSensibility","useAltToZoom","angularSpeed","_keys","_onCanvasBlurObserver","onCanvasBlurObservable","_onKeyboardObserver","onKeyboardObservable","info","_ctrlPressed","_altPressed","keyCode","_useCtrlForPanning","inertialPanningX","inertialPanningY","useInputToRestoreState","restoreState","ArcRotateCameraMouseWheelInput","wheelPrecision","zoomToMouseLocation","wheelDeltaPercentage","customComputeDeltaFromMouseWheel","_inertialPanning","_computeDeltaFromMouseWheelLegacyEvent","mouseWheelDelta","radius","delta","wheelDelta","estimatedTargetRadius","targetInertia","inertia","Number","MAX_VALUE","_hitPlane","_zoomToMouse","setAll","_updateHitPlane","scaleInPlace","_zeroIfClose","direction","subtract","_getPosition","ray","createPickingRay","pointerX","pointerY","distance","intersectsPlane","origin","inertiaComp","lowerRadiusLimit","lowerLimit","upperRadiusLimit","upperLimit","ratio","directionToZoomLocation","ArcRotateCameraPointersInput","angularSensibilityX","angularSensibilityY","pinchPrecision","pinchDeltaPercentage","useNaturalPinchZoom","pinchZoom","multiTouchPanning","multiTouchPanAndZoom","pinchInwards","_isPanClick","_twoFingerActivityCount","_isPinching","_computeMultiTouchPanning","moveDeltaX","moveDeltaY","_computePinchZoom","MinimumRadiusForPinch","pointA","pointB","pinchToPanMaxDistance","_panningMouseButton","smoothFactor","_deviceOrientationInput","FreeCameraDeviceOrientationInput","timeout","Promise","res","rej","gotValue","eventHandler","window","setTimeout","DeviceOrientationEvent","requestPermission","then","response","catch","error","_screenOrientationAngle","_screenQuaternion","_alpha","_beta","_gamma","_onDeviceOrientationChangedObservable","_orientationChanged","orientation","screen","copyFromFloats","_deviceOrientation","alpha","beta","gamma","_constantTranform","_camera","onDisposeObservable","multiplyInPlace","w","FreeCameraGamepadInput","gamepadAngularSensibility","deadzoneDelta","_cameraTransform","_deltaTransform","_vector3","_vector2","gamepads","speed","_computeLocalCameraSpeed","cameraDirection","cameraRotation","FreeCameraKeyboardMoveInput","keysUpward","keysDownward","rotationSpeed","keysRotateLeft","keysRotateRight","_localDirection","_getLocalRotation","useRightHandedSystem","getViewMatrix","_cameraTransformMatrix","_transformedDirection","getDeltaTime","_getWorldMatrixDeterminant","FreeCameraMouseInput","touchEnabled","angularSensibility","_previousPosition","onPointerMovedObservable","_allowCameraRotation","_activePointerId","_onMouseMove","_CameraProperty","FreeCameraMouseWheelInput","_moveRelative","_rotateRelative","_moveScene","_wheelXAction","MoveRelative","_wheelXActionCoordinate","_wheelYAction","_wheelYActionCoordinate","_wheelZAction","_wheelZActionCoordinate","wheelXMoveRelative","wheelYMoveRelative","wheelZMoveRelative","wheelXRotateRelative","RotateRelative","wheelYRotateRelative","wheelZRotateRelative","wheelXMoveScene","MoveScene","wheelYMoveScene","wheelZMoveScene","_updateCamera","cameraTransformMatrix","transformedDirection","_updateCameraProperty","cameraProperty","coordinate","action","FreeCameraTouchInput","allowMouse","touchAngularSensibility","touchMoveSensibility","singleFingerRotate","_offsetX","_offsetY","_pointerPressed","_isSafari","previousPosition","isMouseEvent","_cameraRotationMatrix","setVRRigMode","rigParams","metrics","vrCameraMetrics","_rigCameras","_cameraRigParams","vrMetrics","viewport","vrWorkMatrix","vrHMatrix","leftHMatrix","vrPreViewMatrix","leftPreViewMatrix","getProjectionMatrix","_getVRProjectionMatrix","rightHMatrix","rightPreViewMatrix","multiviewEnabled","multiview","_useMultiviewToSingleView","_rigPostProcess","postProcessScaleFactor","compensateDistortion","setWebVRRigMode","vrDisplay","leftEye","getEyeParameters","rightEye","setCameraRigParameter","specs","frameData","parentCamera","_getWebVRProjectionMatrix","_getViewMatrix","_getWebVRViewMatrix","VRCameraMetrics","aspectRatio","hResolution","vResolution","aspectRatioFov","atan","vScreenSize","eyeToScreenDistance","h","hScreenSize","lensSeparationDistance","interpupillaryDistance","vScreenCenter","distortionK","chromaAbCorrection","lensCenterOffset","VRDeviceOrientationFreeCamera","_setRigMode","setCameraRigMode","VRExperienceHelperGazer","gazeTrackerToClone","_pointerDownOnMeshAsked","_isActionableMesh","_teleportationRequestInitiated","_teleportationBackRequestInitiated","_rotationRightAsked","_rotationLeftAsked","_dpadPressed","_activePointer","_id","_IdCounter","_gazeTracker","diameter","thickness","tessellation","bakeCurrentTransformIntoVertices","isPickable","isVisible","targetMat","specularColor","emissiveColor","backFaceCulling","material","_getForwardRay","_selectionPointerDown","_currentHit","simulatePointerDown","_selectionPointerUp","simulatePointerUp","_activatePointer","_deactivatePointer","_updatePointerDistance","_interactionsEnabled","_teleportationEnabled","VRExperienceHelperControllerGazer","webVRController","_laserPointer","height","diameterTop","diameterBottom","subdivisions","laserPointerMaterial","preloadMesh","preloadPointerPose","addChild","attachToMesh","_setLaserPointerParent","_meshAttachedObserver","_meshAttachedObservable","getForwardRay","_setLaserPointerColor","color","_setLaserPointerLightingDisabled","disabled","disableLighting","makeNotPick","root","getChildMeshes","meshChildren","laserParent","_pointingPoseNode","VRExperienceHelperCameraGazer","_getCamera","VRExperienceHelper","onEnteringVR","onEnteringVRObservable","onExitingVR","onExitingVRObservable","onControllerMeshLoaded","onControllerMeshLoadedObservable","teleportationTarget","_teleportationTarget","_isDefaultTeleportationTarget","gazeTrackerMesh","_cameraGazer","_leftController","_rightController","leftControllerGazeTrackerMesh","rightControllerGazeTrackerMesh","displayGaze","_displayGaze","displayLaserPointer","_displayLaserPointer","deviceOrientationCamera","_deviceOrientationCamera","currentVRCamera","_webVRready","_webVRCamera","activeCamera","webVRCamera","vrDeviceOrientationCamera","_vrDeviceOrientationCamera","vrButton","_btnVR","webVROptions","_webVRsupported","_webVRrequesting","_webVRpresenting","_fullscreenVRpresenting","enableGazeEvenWhenNoPointerLock","exitVROnDoubleTap","onAfterEnteringVRObservable","_useCustomVRButton","_teleportationRequested","_teleportActive","_floorMeshesCollection","_teleportationMode","TELEPORTATIONMODE_CONSTANTTIME","_teleportationTime","_teleportationSpeed","_rotationAllowed","_teleportBackwardsVector","_teleportationFillColor","_teleportationBorderColor","_rotationAngle","_haloCenter","_padSensibilityUp","_padSensibilityDown","_gazeColor","_laserColor","_pickedLaserColor","_pickedGazeColor","onNewMeshSelected","onMeshSelectedWithController","onNewMeshPicked","onBeforeCameraTeleport","onAfterCameraTeleport","onSelectedMeshUnselected","teleportationEnabled","_teleportationInitialized","_interactionsRequested","updateGazeTrackerScale","updateGazeTrackerColor","updateControllerLaserColor","requestPointerLockOnFullScreen","xrTestDone","_onResize","_moveButtonToBottomRight","exitVR","_onFullscreenChange","document","fullscreenElement","_inputElement","style","top","offsetTop","offsetHeight","left","offsetLeft","offsetWidth","_updateButtonVisibility","_cachedAngularSensibility","_beforeRender","_castRayAndSelectObject","_noControllerIsActive","_onNewGamepadConnected","onleftstickchanged","stickValues","_checkTeleportWithRay","_checkTeleportBackwards","onrightstickchanged","_checkRotate","onbuttondown","buttonPressed","onbuttonup","controller","hand","_tryEnableInteractionOnController","_enableInteractionOnController","_enableTeleportationOnController","_onNewGamepadDisconnected","_workingVector","_workingQuaternion","_workingMatrix","navigator","useXR","createFallbackVRDeviceOrientationFreeCamera","createDeviceOrientationCamera","laserToggle","defaultHeight","useCustomVRButton","customVRButton","rayLength","_rayLength","_defaultHeight","positionScale","_hasEnteredVR","_position","minZ","maxZ","targetCamera","_existingCamera","xr","supported","Log","createDefaultXRExperienceAsync","floorMeshes","baseExperience","onStateChangedObservable","state","pointerSelection","detach","resize","_completeVRInit","useMultiview","vrDeviceOrientationCameraMetrics","useStandingMatrix","createElement","className","title","css","SVGSVGElement","appendChild","createTextNode","getElementsByTagName","isInVRMode","disableVR","enterVR","_displayVRButton","onVRDisplayChangedObservable","_onKeyDown","onPrePointerObservable","exitFullscreen","_onVRDisplayChangedBind","eventArgs","_onVRDisplayChanged","_onVrDisplayPresentChangeBind","_onVrDisplayPresentChange","_onVRRequestPresentStart","_onVRRequestPresentComplete","onVRRequestPresentStart","onVRRequestPresentComplete","_onDefaultMeshLoaded","_circleEase","setEasingMode","_teleportationEasing","onPointerObservable","enableTeleportation","err","getVRDevice","wasPresenting","isPresenting","vrSupported","rect","getBoundingClientRect","_btnVRDisplayed","body","enterXRAsync","renderTarget","toEulerAngles","currentYRotation","deviceRotationQuaternion","currentGlobalRotation","addOnce","success","enterFullscreen","onViewMatrixChangedObservable","registerBeforeRender","exitXRAsync","unregisterBeforeRender","enableInteractions","attach","raySelectionPredicate","_floorMeshName","meshSelectionPredicate","_raySelectionPredicate","_isTeleportationFloor","addFloorMesh","floorMesh","removeFloorMesh","meshIndex","vrTeleportationOptions","floorMeshName","getMeshByName","teleportation","attached","waitForXr","teleportationMode","teleportationTime","teleportationSpeed","easingFunction","imageProcessingConfiguration","vignetteColor","vignetteEnabled","_postProcessMove","detachPostProcess","_createTeleportationCircles","deviceScaleFactor","onMainButtonStateChangedObservable","stateObject","onTriggerStateChangedObservable","gazer","teleportCamera","_rotateCamera","devicePosition","hit","pickWithRay","pickedPoint","pickedMesh","controllerType","onPadStateChangedObservable","pressed","onPadValuesChangedObservable","dynamicTexture","hasAlpha","context","getContext","beginPath","arc","fillStyle","fill","lineWidth","strokeStyle","stroke","closePath","teleportationCircleMaterial","diffuseTexture","torus","animationInnerCircle","frame","setKeys","setEasingFunction","_hideTeleportationTarget","_displayTeleportationTarget","right","animationRotation","animationRotationKeys","animationPP","vignetteWeightKeys","animationPP2","vignetteStretchKeys","vignetteWeight","vignetteStretch","samples","attachPostProcess","_moveTeleportationSelectorTo","pickNormal","_convertNormalToDirectionOfRay","getNormal","axis1","axis2","location","leftCamera","globalPosition","subtractInPlace","deviceDistanceToRoomGround","lastFrame","TELEPORTATIONMODE_CONSTANTSPEED","dist","round","animationCameraTeleportation","animationCameraTeleportationKeys","midFrame","normal","simulatePointerMove","multiplier","deltaFighting","_currentMeshSelected","_notifySelectedMeshUnselected","actionManager","changeGazeColor","changeLaserColor","gazerAsControllerGazer","setLaserColor","pickedColor","setLaserLightingState","enabled","setGazeColor","parentNode","removeChild","removeCallback","WebVRFreeCamera","_webVROptions","_vrDevice","rawPose","_specsVersion","_attached","_descendants","_deviceRoomPosition","_deviceRoomRotationQuaternion","_standingMatrix","_deviceToWorld","_worldToDevice","controllers","onControllersAttachedObservable","onPoseUpdatedFromDeviceObservable","_poseSet","rigParenting","_detachIfAttached","_oneVector","_tmpMatrix","_cache","trackPosition","controllerMeshes","defaultLightingOnControllers","_onVREnabled","initControllers","initWebVR","_frameData","enableVR","VRFrameData","onBeforeCameraRenderObservable","getDescendants","n","isController","some","_mesh","isRigCamera","onAfterCameraRenderObservable","getTranslationToRef","bool","initWebVRAsync","stageParameters","sittingToStandingTransform","toggleModelMatrixHandInPlace","useStandingMatrixAsync","_updateCacheWhenTrackingDisabledObserver","onBeforeRenderObservable","getControllerByName","gp","leftController","rightController","_checkInputs","getFrameData","updateFromDevice","pose","poseData","resetToCurrentRotation","resetPose","_updateRigCameras","camLeft","camRight","_correctPositionIfNotTrackPosition","isViewMatrix","_updateCache","ignoreParentClass","equals","_updateCacheCalled","setTranslation","_computeDevicePosition","viewArray","leftViewMatrix","rightViewMatrix","_webvrViewMatrix","_referencePoint","_transformedReferencePoint","addToRef","_currentTarget","_globalPosition","_markSyncedWithParent","depthNear","depthFar","projectionArray","leftProjectionMatrix","rightProjectionMatrix","_projectionMatrix","toggleProjectionMatrixHandInPlace","webVrController","defaultModel","setEnabled","controllerIndex","_disableTrackPosition","initControllerMesh","loadedMesh","_lightOnControllers","activateLightOnSubMeshes","light","includedOnlyMeshes","attachToPoseControlledCamera","firstViveWandDetected","ArcRotateCamera","_target","setTarget","targetHost","_targetHost","getTarget","upVector","_upToYMatrix","_yToUpMatrix","_upVector","setMatUp","pointers","inputs","keyboard","mousewheel","bouncingBehavior","_bouncingBehavior","useBouncingBehavior","addBehavior","removeBehavior","framingBehavior","_framingBehavior","useFramingBehavior","autoRotationBehavior","_autoRotationBehavior","useAutoRotationBehavior","setActiveOnSceneIfNoneActive","lowerAlphaLimit","upperAlphaLimit","lowerBetaLimit","upperBetaLimit","panningDistanceLimit","panningOriginTarget","panningInertia","zoomOnFactor","targetScreenOffset","allowUpsideDown","_viewMatrix","panningAxis","mapPanning","onMeshTargetChangedObservable","checkCollisions","collisionRadius","_collisionVelocity","_newPosition","_computationVector","_onCollisionPositionChange","collisionId","collidedMesh","onCollide","cosa","sina","cosb","sinb","_getTargetPosition","up","negate","_computeViewMatrix","_collisionTriggered","addKeyboard","addMouseWheel","addPointers","_initCache","_targetBoundingCenter","lockedTargetPosition","_getLockedTargetPosition","storeState","_storedAlpha","_storedBeta","_storedRadius","_storedTarget","_storedTargetScreenOffset","_restoreStateValues","_isSynchronizedViewMatrix","ignored","useCtrlForPanning","panningMouseButton","args","attachElement","_reset","detachElement","directionModifier","invertRotation","localDirection","_checkLimits","rebuildAnglesAndRadius","previousAlpha","pow","alphaCorrectionTurns","toBoundingCenter","allowSamePosition","cloneAlphaBetaRadius","overrideCloneAlphaBetaRadius","getBoundingInfo","boundingBox","centerWorld","newTarget","currentTarget","collisionsEnabled","coordinator","collisionCoordinator","_collider","createCollider","_radius","getNewPosition","zoomOn","meshes","doNotUpdateMaxZ","minMaxVector","focusOn","meshesOrMinMaxVectorAndDistance","meshesOrMinMaxVector","createRigCamera","cameraIndex","alphaShift","cameraRigMode","stereoHalfAngle","rigCam","rigParent","mode","orthoLeft","orthoRight","orthoBottom","orthoTop","ArcRotateCameraInputsManager","Camera","screenArea","_c","_d","PERSPECTIVE_CAMERA","fovMode","FOVMODE_VERTICAL_FIXED","fov","getAspectRatio","halfWidth","getRenderWidth","halfHeight","getRenderHeight","_orthoLeft","rigCamera","_orthoRight","_orthoBottom","_orthoTop","_mode","projectionPlaneTilt","isIntermediate","layerMask","RIG_MODE_NONE","customRenderTargets","outputRenderTarget","onProjectionMatrixChangedObservable","onAfterCheckInputsObservable","onRestoreStateObservable","_skipRendering","_postProcesses","_activeMeshes","_computedViewMatrix","_doNotComputeProjectionMatrix","_transformMatrix","_refreshFrustumPlanes","_absoluteRotation","_isCamera","_isLeftCamera","_isRightCamera","addCamera","renderPassId","createRenderPassId","_stateStored","_storedFov","applyVerticalCorrection","rot","absoluteRotation","getActiveMeshes","isActiveMesh","isReady","completeCheck","pp","renderWidth","renderHeight","_isSynchronized","_isSynchronizedProjectionMatrix","isSynchronizedWithParent","check","_ignored","_noPreventDefault","rigCameras","rigPostProcess","_getFirstPostProcess","ppIndex","_cascadePostProcessesToRigCams","firstPostProcess","markTextureDirty","cam","getEffectName","concat","postProcess","insertAt","isReusable","prePassRenderer","idx","_worldMatrix","force","updateCache","getRenderId","freezeProjectionMatrix","projection","unfreezeProjectionMatrix","_e","_f","_g","_h","reverseDepth","useReverseDepthBuffer","isNDCHalfZRange","getTransformationMatrix","_updateFrustumPlanes","_frustumPlanes","isInFrustum","checkRigCameras","isCompletelyInFrustum","transform","getForwardRayToRef","refRay","doNotRecurse","disposeMaterialAndTextures","removeCamera","cameras","releaseRenderPassId","isLeftCamera","isRightCamera","rightCamera","getLeftTarget","getRightTarget","interaxialDistance","_updateCameraRotationMatrix","_updateWebVRCameraRotationMatrix","RIG_MODE_STEREOSCOPIC_ANAGLYPH","_setupInputs","_serializeAsParent","serializeAnimationRanges","isEnabled","GetConstructorFromName","isStereoscopicSideBySide","onClonedObservable","interaxial_distance","constructorFunc","_CreateDefaultParsedCamera","parsedCamera","construct","parentId","_waitingParentId","parentInstanceIndex","_waitingParentInstanceIndex","parse","animationIndex","parsedAnimation","internalClass","Parse","autoAnimate","autoAnimateFrom","autoAnimateTo","autoAnimateLoop","autoAnimateSpeed","ORTHOGRAPHIC_CAMERA","FOVMODE_HORIZONTAL_FIXED","RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL","RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED","RIG_MODE_STEREOSCOPIC_OVERUNDER","RIG_MODE_STEREOSCOPIC_INTERLACED","RIG_MODE_VR","RIG_MODE_WEBVR","RIG_MODE_CUSTOM","ForceAttachControlToAlwaysPreventDefault","CameraInputTypes","CameraInputsManager","attachedToElement","input","_addCheckInputs","inputToRemove","rebuildInputCheck","removeByType","inputType","fn","current","attachInput","disconnect","serializedCamera","inputsmgr","parsedInputs","parsedinput","DeviceOrientationCamera","_tmpDragQuaternion","_disablePointerInputWhenUsingDeviceOrientation","_dragFactor","_quaternionCache","addDeviceOrientation","_mouseInput","_initialQuaternion","disablePointerInputWhenUsingDeviceOrientation","enableHorizontalDragging","dragFactor","axisName","FreeCamera","mouse","ellipsoid","ellipsoidOffset","applyGravity","_needMoveForGravity","_oldPosition","_diffPosition","_collisionMask","newPos","updatePosition","addMouse","collisionMask","mask","_collideWithWorld","displacement","subtractFromFloatsToRef","actualDisplacement","gravity","_decideIfNeedsToMove","_updatePosition","FreeCameraInputsManager","_mouseWheelInput","removeMouse","removeMouseWheel","addTouch","ArcRotateCameraVRDeviceOrientationInput","alphaCorrection","gammaCorrection","_dirty","_deviceOrientationHandler","_onOrientationEvent","FlyCameraKeyboardInput","keysForward","keysBackward","FlyCameraMouseInput","buttonsYaw","buttonsPitch","buttonsRoll","activeButton","_rollObserver","rollCorrect","restoreRoll","_element","currentRotation","rotationChange","v","limit","bankedTurnLimit","_trackRoll","bankedTurn","bankingDelta","bankedTurnMultiplier","FollowCameraKeyboardMoveInput","keysHeightOffsetIncr","keysHeightOffsetDecr","keysHeightOffsetModifierAlt","keysHeightOffsetModifierCtrl","keysHeightOffsetModifierShift","keysRotationOffsetIncr","keysRotationOffsetDecr","keysRotationOffsetModifierAlt","keysRotationOffsetModifierCtrl","keysRotationOffsetModifierShift","keysRadiusIncr","keysRadiusDecr","keysRadiusModifierAlt","keysRadiusModifierCtrl","keysRadiusModifierShift","heightSensibility","rotationSensibility","radiusSensibility","_shiftPressed","_modifierHeightOffset","heightOffset","_modifierRotationOffset","rotationOffset","_modifierRadius","FollowCameraMouseWheelInput","axisControlRadius","axisControlHeight","axisControlRotation","console","assert","FollowCameraPointersInput","axisXControlRadius","axisXControlHeight","axisXControlRotation","axisYControlRadius","axisYControlHeight","axisYControlRotation","axisPinchControlRadius","axisPinchControlHeight","axisPinchControlRotation","warningEnable","_warningCounter","_warning","pinchDelta","warn","FreeCameraVirtualJoystickInput","getLeftJoystick","_leftjoystick","getRightJoystick","_rightjoystick","cameraTransform","deltaTransform","deltaPosition","addVector3","setAxisForUpDown","setAxisForLeftRight","setJoystickSensibility","reverseUpDown","setJoystickColor","releaseCanvas","FlyCameraInputsManager","FlyCamera","rate","FollowCameraInputsManager","addVRDeviceOrientation","FollowCamera","ArcFollowCamera","lockedTarget","lowerRotationOffsetLimit","upperRotationOffsetLimit","lowerHeightOffsetLimit","upperHeightOffsetLimit","cameraAcceleration","maxCameraSpeed","_follow","cameraTarget","rotMatrix","absoluteRotationQuaternion","yRotation","radians","targetX","targetZ","dx","dy","dz","vx","vy","vz","_cartesianCoordinates","setMeshTarget","_meshTarget","GamepadCamera","setStereoscopicAnaglyphRigMode","AnaglyphArcRotateCamera","AnaglyphFreeCamera","AnaglyphGamepadCamera","AnaglyphUniversalCamera","setStereoscopicRigMode","isStereoscopicHoriz","isCrossEye","StereoscopicArcRotateCamera","StereoscopicFreeCamera","StereoscopicGamepadCamera","StereoscopicUniversalCamera","VirtualJoysticksCamera","addVirtualJoystick","VRDeviceOrientationArcRotateCamera","VRDeviceOrientationGamepadCamera","addGamepad","TargetCamera","_tmpUpVector","_tmpTargetVector","ignoreParentScaling","updateUpVectorFromRotation","_tmpQuaternion","noRotationConstraint","inverseRotationSpeed","_initialFocalDistance","_camMatrix","_defaultUp","_cachedRotationZ","_cachedQuaternionRotationZ","getFrontPosition","absolutePosition","_storedPosition","_storedRotation","_storedRotationQuaternion","getFps","vDir","directionMultiplier","needToMove","needToRotate","lengthSquared","_rotateUpVectorWithCameraRotationMatrix","parentWorldMatrix","leftSign","rightSign","_getRigCamPositionAndTarget","halfSpace","_TargetFocalPoint","newFocalTarget","_TargetTransformMatrix","_RigCamTransformMatrix","TouchCamera","touch","UniversalCamera","getLowestRoot","found","maxR","sqrtD","r1","r2","temp","Collider","_collisionPoint","_planeIntersectionPoint","_tempVector","_tempVector2","_tempVector3","_tempVector4","_edge","_baseToVertex","_destinationPoint","_slidePlaneNormal","_displacementVector","_retry","_basePointWorld","_velocityWorld","_normalizedVelocity","slidePlaneNormal","_initialize","dir","_velocity","_velocitySquaredLength","_x","_y","_z","scaleToRef","_basePoint","_velocityWorldLength","_epsilon","collisionFound","_checkPointInTriangle","pa","pb","pc","d","_canDoCollision","sphereCenter","sphereRadius","vecMin","vecMax","boxMin","boxMax","intersectBoxAASphere","_testTriangle","faceIndex","trianglePlaneArray","p1","p2","p3","hasMaterial","hostMesh","t0","embeddedInPlane","copyFromPoints","trianglePlane","isFrontFacingTo","signedDistToTrianglePlane","signedDistanceTo","normalDotVelocity","DoubleSidedCheck","t1","t","lowestRoot","edgeSquaredLength","edgeDotVelocity","edgeDotBaseToVertex","f","distToCollisionSquared","_nearestDistanceSquared","collisionResponse","intersectionPoint","_nearestDistance","_collide","pts","indices","indexStart","indexEnd","decal","invertTriangles","triangleStrip","indexA","indexB","indexC","_getResponse","vel","DefaultCollisionCoordinator","_scaledPosition","_scaledVelocity","_finalPosition","collider","maximumRetry","excludedMesh","onNewPosition","collisionIndex","divideToRef","_initialVelocity","_initialPosition","init","velocity","finalPosition","closeDistance","surroundingMeshes","subMeshes","collisionGroup","_checkCollision","IntersectionInfo","bu","bv","faceId","subMeshId","_MeshCollisionData","_checkCollisions","_collisionGroup","_surroundingMeshes","_oldPositionForCollisions","_diffPositionForCollisions","_collisionResponse","PickingInfo","subMeshFaceId","pickedSprite","thinInstanceIndex","originMesh","aimTransform","gripTransform","useWorldCoordinates","useVerticesNormals","isVerticesDataPresent","getIndices","normals","getVerticesData","normal0","normal1","normal2","positions","vertex1","vertex2","vertex3","p1p2","p3p2","transformNormalToWorld","nonUniformScaling","transposeToRef","normalForDirectionChecking","negateInPlace","getTextureCoordinates","uvs","uv0","uv1","uv2","CompatibilityOptions","UseOpenGLOrientationForUV","ComputeEffect","baseName","key","computeSource","defines","onCompiled","onError","onCompileObservable","onErrorObservable","onBindObservable","_wasPreviouslyReady","_isReady","_compilationError","_key","_computeSourceCodeOverride","_pipelineContext","_computeSourceCode","_rawComputeSourceCode","_shaderLanguage","_UniqueIdSeed","_entryPoint","entryPoint","_shaderStore","_shaderRepository","_includeShaderStore","hostDocument","getHostDocument","computeElement","getElementById","compute","processorOptions","split","indexParameters","isFragment","shouldUseHighPrecisionShader","processor","supportsUniformBuffers","shadersRepository","includesShadersStore","version","platformName","shaderPlatformName","processingContext","_loadShader","computeCode","migratedCommputeCode","processFinalCode","finalShaders","_useFinalCode","vertexCode","spectorName","_prepareEffect","_isReadyInternal","getPipelineContext","getCompilationError","executeWhenCompiled","func","effect","isAsync","_checkIsReady","previousPipelineContext","_processCompilationErrors","shader","optionalKey","HTMLElement","substr","atob","shaderUrl","_loadFile","toLowerCase","computeSourceCode","_getComputeShaderCode","rawComputeSourceCode","createComputePipelineContext","_name","_prepareComputePipelineContext","_executeWhenComputeStateIsCompiled","_deleteComputePipelineContext","_getShaderCodeAndErrorLine","code","regexp","errorLine","match","lineNumber","parseInt","lines","message","LogShaderCodeOnCompilationError","lineErrorVertex","_releaseComputeEffect","computeShader","ComputeShader","_options","shaderPath","_shaderPath","_bindings","_samplers","_contextIsDirty","UniqueId","supportComputeShaders","bindingsMapping","_context","createComputeContext","setTexture","texture","bindSampler","object","indexInGroupEntries","setStorageTexture","setUniformBuffer","setStorageBuffer","setTextureSampler","sampler","compareSampler","_effect","binding","shaderName","join","_cachedDefines","createComputeEffect","dispatch","_texture","setParameters","wrapU","wrapV","wrapR","anisotropicFilteringLevel","samplingMode","_comparisonFunction","computeDispatch","dispatchWhenReady","delay","resolve","bindings","textures","serializedData","rootUrl","BoundingBox","worldMatrix","vectors","center","extendSize","extendSizeWorld","directions","vectorsWorld","minimumWorld","maximumWorld","minimum","maximum","_drawWrapperFront","_drawWrapperBack","reConstruct","minX","minY","maxX","maxY","_update","factor","tmpVectors","_TmpVector3","diff","normalizeFromLength","newRadius","world","minWorld","maxWorld","isIdentity","minimizeInPlace","maximizeInPlace","frustumPlanes","IsInFrustum","IsCompletelyInFrustum","intersectsPoint","pointX","pointY","pointZ","intersectsSphere","sphere","IntersectsSphere","radiusWorld","intersectsMinMax","myMin","myMax","myMinX","myMinY","myMinZ","myMaxX","myMaxY","myMaxZ","box0","box1","minPoint","maxPoint","vector","boundingVectors","frustumPlane","dotCoordinate","canReturnFalse","_result0","_result1","computeBoxExtents","box","r","axisOverlap","BoundingInfo","_isLocked","boundingSphere","isLocked","centerOn","extend","encapsulate","encapsulateBoundingInfo","toEncapsulate","strategy","isCenterInFrustum","diagonalLength","intersects","boundingInfo","precise","BoundingSphere","tempRadiusVector","tempVector","squareDistance","sphere0","sphere1","radiusSum","OctreeBlock","depth","maxDepth","creationFunc","entries","_boundingVectors","_capacity","_depth","_maxDepth","_creationFunc","_minPoint","_maxPoint","addEntry","entry","blocks","createInnerBlocks","removeEntry","entryIndex","addEntries","select","selection","allowDuplicate","concatWithNoDuplicate","intersectsRay","intersectsBoxMinMax","_CreateBlocks","worldMin","worldMax","maxBlockCapacity","currentDepth","blockSize","localMin","multiplyByFloats","localMax","block","Octree","dynamicContent","_maxBlockCapacity","_selectionContent","addMesh","removeMesh","reset","CreationFuncForMeshes","isBlocked","CreationFuncForSubMeshes","maxCapacity","component","_getComponent","OctreeSceneComponent","_addComponent","_selectionOctree","worldExtends","getWorldExtends","defineProperty","get","enumerable","configurable","_submeshesOctree","bbox","checksIsEnabled","_tempRay","getActiveMeshCandidates","getActiveSubMeshCandidates","getCollidingSubMeshCandidates","getIntersectingSubMeshCandidates","register","onMeshRemovedObservable","sceneOctree","selectionOctree","onMeshImportedObservable","_getDefaultMeshCandidates","useOctreeForRenderingSelection","_getDefaultSubMeshCandidates","localRay","useOctreeForPicking","useOctreeForCollisions","rebuild","Ray","intersectionTreshold","newMinimum","newMaximum","inv","maxValue","Infinity","intersectsBox","pyth","rr","dot","intersectsTriangle","vertex0","edge1","edge2","pvec","qvec","det","invdet","bw","plane","result1","result2","intersectsAxis","intersectsMesh","fastCheck","tm","_tmpRay","TransformToRef","Transform","intersectsMeshes","results","pickInfo","sort","_comparePickingInfo","pickingInfoA","pickingInfoB","intersectionSegment","sega","segb","threshold","o","u","rsegb","_Rayl","D","sN","tN","sD","tD","_Smallnum","sc","tc","qtc","qsc","dP","viewportWidth","viewportHeight","view","enableDistantPicking","_RayDistant","Zero","unprojectRayToRef","end","num","sourceX","sourceY","nearScreenSource","farScreenSource","nearVec3","farVec3","cameraViewSpace","createPickingRayToRef","toGlobal","getHardwareScalingLevel","createPickingRayInCameraSpaceToRef","identity","pickingInfo","rayFunction","onlyBoundingInfo","trianglePredicate","skipBoundingInfo","predicate","computeWorldMatrixForCamera","activeCameras","cameraToUseForPointers","currentCamera","forceCompute","isWorldMatrixCameraDependent","hasThinInstances","thinInstanceEnablePicking","_internalPickForMesh","tmpMatrix","thinMatrices","thinInstanceGetWorldMatrices","pickingInfos","_internalPick","_tempPickingRay","_enableDistantPicking","_pickWithRayInverseMatrix","_cachedRayForTransform","_internalMultiPick"],"sourceRoot":""}