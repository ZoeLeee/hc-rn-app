{"version":3,"file":"js/vender~35a07c18.df265821.js","mappings":"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","sources":["webpack:///../../../node_modules/@babylonjs/core/Particles/EmitterTypes/boxParticleEmitter.js","webpack:///../../../node_modules/@babylonjs/core/Particles/EmitterTypes/coneParticleEmitter.js","webpack:///../../../node_modules/@babylonjs/core/Particles/EmitterTypes/customParticleEmitter.js","webpack:///../../../node_modules/@babylonjs/core/Particles/EmitterTypes/cylinderParticleEmitter.js","webpack:///../../../node_modules/@babylonjs/core/Particles/EmitterTypes/hemisphericParticleEmitter.js","webpack:///../../../node_modules/@babylonjs/core/Particles/EmitterTypes/pointParticleEmitter.js","webpack:///../../../node_modules/@babylonjs/core/Particles/EmitterTypes/meshParticleEmitter.js","webpack:///../../../node_modules/@babylonjs/core/Particles/EmitterTypes/sphereParticleEmitter.js","webpack:///../../../node_modules/@babylonjs/core/Particles/baseParticleSystem.js","webpack:///../../../node_modules/@babylonjs/core/Particles/cloudPoint.js","webpack:///../../../node_modules/@babylonjs/core/Particles/gpuParticleSystem.js","webpack:///../../../node_modules/@babylonjs/core/Particles/webgl2ParticleSystem.js","webpack:///../../../node_modules/@babylonjs/core/Particles/computeShaderParticleSystem.js","webpack:///../../../node_modules/@babylonjs/core/Particles/particleHelper.js","webpack:///../../../node_modules/@babylonjs/core/Particles/particleSystemComponent.js","webpack:///../../../node_modules/@babylonjs/core/Particles/particle.js","webpack:///../../../node_modules/@babylonjs/core/Particles/particleSystem.js","webpack:///../../../node_modules/@babylonjs/core/Particles/particleSystemSet.js","webpack:///../../../node_modules/@babylonjs/core/Particles/pointsCloudSystem.js","webpack:///../../../node_modules/@babylonjs/core/Particles/subEmitter.js","webpack:///../../../node_modules/@babylonjs/core/Physics/joinedPhysicsEngineComponent.js","webpack:///../../../node_modules/@babylonjs/core/Physics/physicsHelper.js","webpack:///../../../node_modules/@babylonjs/core/Physics/physicsRaycastResult.js","webpack:///../../../node_modules/@babylonjs/core/Physics/v1/Plugins/ammoJSPlugin.js"],"sourcesContent":["import { DeepCopier } from \"../../Misc/deepCopier.js\";\nimport { Vector3 } from \"../../Maths/math.vector.js\";\nimport { Scalar } from \"../../Maths/math.scalar.js\";\n/**\n * Particle emitter emitting particles from the inside of a box.\n * It emits the particles randomly between 2 given directions.\n */\nexport class BoxParticleEmitter {\n    /**\n     * Creates a new instance BoxParticleEmitter\n     */\n    constructor() {\n        /**\n         * Random direction of each particle after it has been emitted, between direction1 and direction2 vectors.\n         */\n        this.direction1 = new Vector3(0, 1.0, 0);\n        /**\n         * Random direction of each particle after it has been emitted, between direction1 and direction2 vectors.\n         */\n        this.direction2 = new Vector3(0, 1.0, 0);\n        /**\n         * Minimum box point around our emitter. Our emitter is the center of particles source, but if you want your particles to emit from more than one point, then you can tell it to do so.\n         */\n        this.minEmitBox = new Vector3(-0.5, -0.5, -0.5);\n        /**\n         * Maximum box point around our emitter. Our emitter is the center of particles source, but if you want your particles to emit from more than one point, then you can tell it to do so.\n         */\n        this.maxEmitBox = new Vector3(0.5, 0.5, 0.5);\n    }\n    /**\n     * Called by the particle System when the direction is computed for the created particle.\n     * @param worldMatrix is the world matrix of the particle system\n     * @param directionToUpdate is the direction vector to update with the result\n     * @param particle is the particle we are computed the direction for\n     * @param isLocal defines if the direction should be set in local space\n     */\n    startDirectionFunction(worldMatrix, directionToUpdate, particle, isLocal) {\n        const randX = Scalar.RandomRange(this.direction1.x, this.direction2.x);\n        const randY = Scalar.RandomRange(this.direction1.y, this.direction2.y);\n        const randZ = Scalar.RandomRange(this.direction1.z, this.direction2.z);\n        if (isLocal) {\n            directionToUpdate.x = randX;\n            directionToUpdate.y = randY;\n            directionToUpdate.z = randZ;\n            return;\n        }\n        Vector3.TransformNormalFromFloatsToRef(randX, randY, randZ, worldMatrix, directionToUpdate);\n    }\n    /**\n     * Called by the particle System when the position is computed for the created particle.\n     * @param worldMatrix is the world matrix of the particle system\n     * @param positionToUpdate is the position vector to update with the result\n     * @param particle is the particle we are computed the position for\n     * @param isLocal defines if the position should be set in local space\n     */\n    startPositionFunction(worldMatrix, positionToUpdate, particle, isLocal) {\n        const randX = Scalar.RandomRange(this.minEmitBox.x, this.maxEmitBox.x);\n        const randY = Scalar.RandomRange(this.minEmitBox.y, this.maxEmitBox.y);\n        const randZ = Scalar.RandomRange(this.minEmitBox.z, this.maxEmitBox.z);\n        if (isLocal) {\n            positionToUpdate.x = randX;\n            positionToUpdate.y = randY;\n            positionToUpdate.z = randZ;\n            return;\n        }\n        Vector3.TransformCoordinatesFromFloatsToRef(randX, randY, randZ, worldMatrix, positionToUpdate);\n    }\n    /**\n     * Clones the current emitter and returns a copy of it\n     * @returns the new emitter\n     */\n    clone() {\n        const newOne = new BoxParticleEmitter();\n        DeepCopier.DeepCopy(this, newOne);\n        return newOne;\n    }\n    /**\n     * Called by the GPUParticleSystem to setup the update shader\n     * @param uboOrEffect defines the update shader\n     */\n    applyToShader(uboOrEffect) {\n        uboOrEffect.setVector3(\"direction1\", this.direction1);\n        uboOrEffect.setVector3(\"direction2\", this.direction2);\n        uboOrEffect.setVector3(\"minEmitBox\", this.minEmitBox);\n        uboOrEffect.setVector3(\"maxEmitBox\", this.maxEmitBox);\n    }\n    /**\n     * Creates the structure of the ubo for this particle emitter\n     * @param ubo ubo to create the structure for\n     */\n    buildUniformLayout(ubo) {\n        ubo.addUniform(\"direction1\", 3);\n        ubo.addUniform(\"direction2\", 3);\n        ubo.addUniform(\"minEmitBox\", 3);\n        ubo.addUniform(\"maxEmitBox\", 3);\n    }\n    /**\n     * Returns a string to use to update the GPU particles update shader\n     * @returns a string containing the defines string\n     */\n    getEffectDefines() {\n        return \"#define BOXEMITTER\";\n    }\n    /**\n     * Returns the string \"BoxParticleEmitter\"\n     * @returns a string containing the class name\n     */\n    getClassName() {\n        return \"BoxParticleEmitter\";\n    }\n    /**\n     * Serializes the particle system to a JSON object.\n     * @returns the JSON object\n     */\n    serialize() {\n        const serializationObject = {};\n        serializationObject.type = this.getClassName();\n        serializationObject.direction1 = this.direction1.asArray();\n        serializationObject.direction2 = this.direction2.asArray();\n        serializationObject.minEmitBox = this.minEmitBox.asArray();\n        serializationObject.maxEmitBox = this.maxEmitBox.asArray();\n        return serializationObject;\n    }\n    /**\n     * Parse properties from a JSON object\n     * @param serializationObject defines the JSON object\n     */\n    parse(serializationObject) {\n        Vector3.FromArrayToRef(serializationObject.direction1, 0, this.direction1);\n        Vector3.FromArrayToRef(serializationObject.direction2, 0, this.direction2);\n        Vector3.FromArrayToRef(serializationObject.minEmitBox, 0, this.minEmitBox);\n        Vector3.FromArrayToRef(serializationObject.maxEmitBox, 0, this.maxEmitBox);\n    }\n}\n//# sourceMappingURL=boxParticleEmitter.js.map","import { DeepCopier } from \"../../Misc/deepCopier.js\";\nimport { Vector3, TmpVectors } from \"../../Maths/math.vector.js\";\nimport { Scalar } from \"../../Maths/math.scalar.js\";\n/**\n * Particle emitter emitting particles from the inside of a cone.\n * It emits the particles alongside the cone volume from the base to the particle.\n * The emission direction might be randomized.\n */\nexport class ConeParticleEmitter {\n    /**\n     * Gets or sets the radius of the emission cone\n     */\n    get radius() {\n        return this._radius;\n    }\n    set radius(value) {\n        this._radius = value;\n        this._buildHeight();\n    }\n    /**\n     * Gets or sets the angle of the emission cone\n     */\n    get angle() {\n        return this._angle;\n    }\n    set angle(value) {\n        this._angle = value;\n        this._buildHeight();\n    }\n    _buildHeight() {\n        if (this._angle !== 0) {\n            this._height = this._radius / Math.tan(this._angle / 2);\n        }\n        else {\n            this._height = 1;\n        }\n    }\n    /**\n     * Creates a new instance ConeParticleEmitter\n     * @param radius the radius of the emission cone (1 by default)\n     * @param angle the cone base angle (PI by default)\n     * @param directionRandomizer defines how much to randomize the particle direction [0-1] (default is 0)\n     */\n    constructor(radius = 1, angle = Math.PI, \n    /** defines how much to randomize the particle direction [0-1] (default is 0) */\n    directionRandomizer = 0) {\n        this.directionRandomizer = directionRandomizer;\n        /**\n         * Gets or sets a value indicating where on the radius the start position should be picked (1 = everywhere, 0 = only surface)\n         */\n        this.radiusRange = 1;\n        /**\n         * Gets or sets a value indicating where on the height the start position should be picked (1 = everywhere, 0 = only surface)\n         */\n        this.heightRange = 1;\n        /**\n         * Gets or sets a value indicating if all the particles should be emitted from the spawn point only (the base of the cone)\n         */\n        this.emitFromSpawnPointOnly = false;\n        this.angle = angle;\n        this.radius = radius;\n    }\n    /**\n     * Called by the particle System when the direction is computed for the created particle.\n     * @param worldMatrix is the world matrix of the particle system\n     * @param directionToUpdate is the direction vector to update with the result\n     * @param particle is the particle we are computed the direction for\n     * @param isLocal defines if the direction should be set in local space\n     */\n    startDirectionFunction(worldMatrix, directionToUpdate, particle, isLocal) {\n        if (isLocal) {\n            TmpVectors.Vector3[0].copyFrom(particle._localPosition).normalize();\n        }\n        else {\n            particle.position.subtractToRef(worldMatrix.getTranslation(), TmpVectors.Vector3[0]).normalize();\n        }\n        const randX = Scalar.RandomRange(0, this.directionRandomizer);\n        const randY = Scalar.RandomRange(0, this.directionRandomizer);\n        const randZ = Scalar.RandomRange(0, this.directionRandomizer);\n        directionToUpdate.x = TmpVectors.Vector3[0].x + randX;\n        directionToUpdate.y = TmpVectors.Vector3[0].y + randY;\n        directionToUpdate.z = TmpVectors.Vector3[0].z + randZ;\n        directionToUpdate.normalize();\n    }\n    /**\n     * Called by the particle System when the position is computed for the created particle.\n     * @param worldMatrix is the world matrix of the particle system\n     * @param positionToUpdate is the position vector to update with the result\n     * @param particle is the particle we are computed the position for\n     * @param isLocal defines if the position should be set in local space\n     */\n    startPositionFunction(worldMatrix, positionToUpdate, particle, isLocal) {\n        const s = Scalar.RandomRange(0, Math.PI * 2);\n        let h;\n        if (!this.emitFromSpawnPointOnly) {\n            h = Scalar.RandomRange(0, this.heightRange);\n            // Better distribution in a cone at normal angles.\n            h = 1 - h * h;\n        }\n        else {\n            h = 0.0001;\n        }\n        let radius = this._radius - Scalar.RandomRange(0, this._radius * this.radiusRange);\n        radius = radius * h;\n        const randX = radius * Math.sin(s);\n        const randZ = radius * Math.cos(s);\n        const randY = h * this._height;\n        if (isLocal) {\n            positionToUpdate.x = randX;\n            positionToUpdate.y = randY;\n            positionToUpdate.z = randZ;\n            return;\n        }\n        Vector3.TransformCoordinatesFromFloatsToRef(randX, randY, randZ, worldMatrix, positionToUpdate);\n    }\n    /**\n     * Clones the current emitter and returns a copy of it\n     * @returns the new emitter\n     */\n    clone() {\n        const newOne = new ConeParticleEmitter(this._radius, this._angle, this.directionRandomizer);\n        DeepCopier.DeepCopy(this, newOne);\n        return newOne;\n    }\n    /**\n     * Called by the GPUParticleSystem to setup the update shader\n     * @param uboOrEffect defines the update shader\n     */\n    applyToShader(uboOrEffect) {\n        uboOrEffect.setFloat2(\"radius\", this._radius, this.radiusRange);\n        uboOrEffect.setFloat(\"coneAngle\", this._angle);\n        uboOrEffect.setFloat2(\"height\", this._height, this.heightRange);\n        uboOrEffect.setFloat(\"directionRandomizer\", this.directionRandomizer);\n    }\n    /**\n     * Creates the structure of the ubo for this particle emitter\n     * @param ubo ubo to create the structure for\n     */\n    buildUniformLayout(ubo) {\n        ubo.addUniform(\"radius\", 2);\n        ubo.addUniform(\"coneAngle\", 1);\n        ubo.addUniform(\"height\", 2);\n        ubo.addUniform(\"directionRandomizer\", 1);\n    }\n    /**\n     * Returns a string to use to update the GPU particles update shader\n     * @returns a string containing the defines string\n     */\n    getEffectDefines() {\n        let defines = \"#define CONEEMITTER\";\n        if (this.emitFromSpawnPointOnly) {\n            defines += \"\\n#define CONEEMITTERSPAWNPOINT\";\n        }\n        return defines;\n    }\n    /**\n     * Returns the string \"ConeParticleEmitter\"\n     * @returns a string containing the class name\n     */\n    getClassName() {\n        return \"ConeParticleEmitter\";\n    }\n    /**\n     * Serializes the particle system to a JSON object.\n     * @returns the JSON object\n     */\n    serialize() {\n        const serializationObject = {};\n        serializationObject.type = this.getClassName();\n        serializationObject.radius = this._radius;\n        serializationObject.angle = this._angle;\n        serializationObject.directionRandomizer = this.directionRandomizer;\n        serializationObject.radiusRange = this.radiusRange;\n        serializationObject.heightRange = this.heightRange;\n        serializationObject.emitFromSpawnPointOnly = this.emitFromSpawnPointOnly;\n        return serializationObject;\n    }\n    /**\n     * Parse properties from a JSON object\n     * @param serializationObject defines the JSON object\n     */\n    parse(serializationObject) {\n        this.radius = serializationObject.radius;\n        this.angle = serializationObject.angle;\n        this.directionRandomizer = serializationObject.directionRandomizer;\n        this.radiusRange = serializationObject.radiusRange !== undefined ? serializationObject.radiusRange : 1;\n        this.heightRange = serializationObject.radiusRange !== undefined ? serializationObject.heightRange : 1;\n        this.emitFromSpawnPointOnly = serializationObject.emitFromSpawnPointOnly !== undefined ? serializationObject.emitFromSpawnPointOnly : false;\n    }\n}\n//# sourceMappingURL=coneParticleEmitter.js.map","import { DeepCopier } from \"../../Misc/deepCopier.js\";\nimport { Vector3, TmpVectors } from \"../../Maths/math.vector.js\";\n/**\n * Particle emitter emitting particles from a custom list of positions.\n */\nexport class CustomParticleEmitter {\n    /**\n     * Creates a new instance CustomParticleEmitter\n     */\n    constructor() {\n        /**\n         * Gets or sets the position generator that will create the initial position of each particle.\n         * Index will be provided when used with GPU particle. Particle will be provided when used with CPU particles\n         */\n        this.particlePositionGenerator = () => { };\n        /**\n         * Gets or sets the destination generator that will create the final destination of each particle.\n         *  * Index will be provided when used with GPU particle. Particle will be provided when used with CPU particles\n         */\n        this.particleDestinationGenerator = () => { };\n    }\n    /**\n     * Called by the particle System when the direction is computed for the created particle.\n     * @param worldMatrix is the world matrix of the particle system\n     * @param directionToUpdate is the direction vector to update with the result\n     * @param particle is the particle we are computed the direction for\n     * @param isLocal defines if the direction should be set in local space\n     */\n    startDirectionFunction(worldMatrix, directionToUpdate, particle, isLocal) {\n        const tmpVector = TmpVectors.Vector3[0];\n        if (this.particleDestinationGenerator) {\n            this.particleDestinationGenerator(-1, particle, tmpVector);\n            // Get direction\n            const diffVector = TmpVectors.Vector3[1];\n            tmpVector.subtractToRef(particle.position, diffVector);\n            diffVector.scaleToRef(1 / particle.lifeTime, tmpVector);\n        }\n        else {\n            tmpVector.set(0, 0, 0);\n        }\n        if (isLocal) {\n            directionToUpdate.copyFrom(tmpVector);\n            return;\n        }\n        Vector3.TransformNormalToRef(tmpVector, worldMatrix, directionToUpdate);\n    }\n    /**\n     * Called by the particle System when the position is computed for the created particle.\n     * @param worldMatrix is the world matrix of the particle system\n     * @param positionToUpdate is the position vector to update with the result\n     * @param particle is the particle we are computed the position for\n     * @param isLocal defines if the position should be set in local space\n     */\n    startPositionFunction(worldMatrix, positionToUpdate, particle, isLocal) {\n        const tmpVector = TmpVectors.Vector3[0];\n        if (this.particlePositionGenerator) {\n            this.particlePositionGenerator(-1, particle, tmpVector);\n        }\n        else {\n            tmpVector.set(0, 0, 0);\n        }\n        if (isLocal) {\n            positionToUpdate.copyFrom(tmpVector);\n            return;\n        }\n        Vector3.TransformCoordinatesToRef(tmpVector, worldMatrix, positionToUpdate);\n    }\n    /**\n     * Clones the current emitter and returns a copy of it\n     * @returns the new emitter\n     */\n    clone() {\n        const newOne = new CustomParticleEmitter();\n        DeepCopier.DeepCopy(this, newOne);\n        return newOne;\n    }\n    /**\n     * Called by the GPUParticleSystem to setup the update shader\n     * @param uboOrEffect defines the update shader\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    applyToShader(uboOrEffect) { }\n    /**\n     * Creates the structure of the ubo for this particle emitter\n     * @param ubo ubo to create the structure for\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    buildUniformLayout(ubo) { }\n    /**\n     * Returns a string to use to update the GPU particles update shader\n     * @returns a string containing the defines string\n     */\n    getEffectDefines() {\n        return \"#define CUSTOMEMITTER\";\n    }\n    /**\n     * Returns the string \"PointParticleEmitter\"\n     * @returns a string containing the class name\n     */\n    getClassName() {\n        return \"CustomParticleEmitter\";\n    }\n    /**\n     * Serializes the particle system to a JSON object.\n     * @returns the JSON object\n     */\n    serialize() {\n        const serializationObject = {};\n        serializationObject.type = this.getClassName();\n        return serializationObject;\n    }\n    /**\n     * Parse properties from a JSON object\n     * @param serializationObject defines the JSON object\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    parse(serializationObject) { }\n}\n//# sourceMappingURL=customParticleEmitter.js.map","import { Vector3 } from \"../../Maths/math.vector.js\";\nimport { Scalar } from \"../../Maths/math.scalar.js\";\nimport { DeepCopier } from \"../../Misc/deepCopier.js\";\n/**\n * Particle emitter emitting particles from the inside of a cylinder.\n * It emits the particles alongside the cylinder radius. The emission direction might be randomized.\n */\nexport class CylinderParticleEmitter {\n    /**\n     * Creates a new instance CylinderParticleEmitter\n     * @param radius the radius of the emission cylinder (1 by default)\n     * @param height the height of the emission cylinder (1 by default)\n     * @param radiusRange the range of the emission cylinder [0-1] 0 Surface only, 1 Entire Radius (1 by default)\n     * @param directionRandomizer defines how much to randomize the particle direction [0-1]\n     */\n    constructor(\n    /**\n     * The radius of the emission cylinder.\n     */\n    radius = 1, \n    /**\n     * The height of the emission cylinder.\n     */\n    height = 1, \n    /**\n     * The range of emission [0-1] 0 Surface only, 1 Entire Radius.\n     */\n    radiusRange = 1, \n    /**\n     * How much to randomize the particle direction [0-1].\n     */\n    directionRandomizer = 0) {\n        this.radius = radius;\n        this.height = height;\n        this.radiusRange = radiusRange;\n        this.directionRandomizer = directionRandomizer;\n        this._tempVector = Vector3.Zero();\n    }\n    /**\n     * Called by the particle System when the direction is computed for the created particle.\n     * @param worldMatrix is the world matrix of the particle system\n     * @param directionToUpdate is the direction vector to update with the result\n     * @param particle is the particle we are computed the direction for\n     * @param isLocal defines if the direction should be set in local space\n     * @param inverseWorldMatrix defines the inverted world matrix to use if isLocal is false\n     */\n    startDirectionFunction(worldMatrix, directionToUpdate, particle, isLocal, inverseWorldMatrix) {\n        particle.position.subtractToRef(worldMatrix.getTranslation(), this._tempVector);\n        this._tempVector.normalize();\n        Vector3.TransformNormalToRef(this._tempVector, inverseWorldMatrix, this._tempVector);\n        const randY = Scalar.RandomRange(-this.directionRandomizer / 2, this.directionRandomizer / 2);\n        let angle = Math.atan2(this._tempVector.x, this._tempVector.z);\n        angle += Scalar.RandomRange(-Math.PI / 2, Math.PI / 2) * this.directionRandomizer;\n        this._tempVector.y = randY; // set direction y to rand y to mirror normal of cylinder surface\n        this._tempVector.x = Math.sin(angle);\n        this._tempVector.z = Math.cos(angle);\n        this._tempVector.normalize();\n        if (isLocal) {\n            directionToUpdate.copyFrom(this._tempVector);\n            return;\n        }\n        Vector3.TransformNormalFromFloatsToRef(this._tempVector.x, this._tempVector.y, this._tempVector.z, worldMatrix, directionToUpdate);\n    }\n    /**\n     * Called by the particle System when the position is computed for the created particle.\n     * @param worldMatrix is the world matrix of the particle system\n     * @param positionToUpdate is the position vector to update with the result\n     * @param particle is the particle we are computed the position for\n     * @param isLocal defines if the position should be set in local space\n     */\n    startPositionFunction(worldMatrix, positionToUpdate, particle, isLocal) {\n        const yPos = Scalar.RandomRange(-this.height / 2, this.height / 2);\n        const angle = Scalar.RandomRange(0, 2 * Math.PI);\n        // Pick a properly distributed point within the circle https://programming.guide/random-point-within-circle.html\n        const radiusDistribution = Scalar.RandomRange((1 - this.radiusRange) * (1 - this.radiusRange), 1);\n        const positionRadius = Math.sqrt(radiusDistribution) * this.radius;\n        const xPos = positionRadius * Math.cos(angle);\n        const zPos = positionRadius * Math.sin(angle);\n        if (isLocal) {\n            positionToUpdate.copyFromFloats(xPos, yPos, zPos);\n            return;\n        }\n        Vector3.TransformCoordinatesFromFloatsToRef(xPos, yPos, zPos, worldMatrix, positionToUpdate);\n    }\n    /**\n     * Clones the current emitter and returns a copy of it\n     * @returns the new emitter\n     */\n    clone() {\n        const newOne = new CylinderParticleEmitter(this.radius, this.directionRandomizer);\n        DeepCopier.DeepCopy(this, newOne);\n        return newOne;\n    }\n    /**\n     * Called by the GPUParticleSystem to setup the update shader\n     * @param uboOrEffect defines the update shader\n     */\n    applyToShader(uboOrEffect) {\n        uboOrEffect.setFloat(\"radius\", this.radius);\n        uboOrEffect.setFloat(\"height\", this.height);\n        uboOrEffect.setFloat(\"radiusRange\", this.radiusRange);\n        uboOrEffect.setFloat(\"directionRandomizer\", this.directionRandomizer);\n    }\n    /**\n     * Creates the structure of the ubo for this particle emitter\n     * @param ubo ubo to create the structure for\n     */\n    buildUniformLayout(ubo) {\n        ubo.addUniform(\"radius\", 1);\n        ubo.addUniform(\"height\", 1);\n        ubo.addUniform(\"radiusRange\", 1);\n        ubo.addUniform(\"directionRandomizer\", 1);\n    }\n    /**\n     * Returns a string to use to update the GPU particles update shader\n     * @returns a string containing the defines string\n     */\n    getEffectDefines() {\n        return \"#define CYLINDEREMITTER\";\n    }\n    /**\n     * Returns the string \"CylinderParticleEmitter\"\n     * @returns a string containing the class name\n     */\n    getClassName() {\n        return \"CylinderParticleEmitter\";\n    }\n    /**\n     * Serializes the particle system to a JSON object.\n     * @returns the JSON object\n     */\n    serialize() {\n        const serializationObject = {};\n        serializationObject.type = this.getClassName();\n        serializationObject.radius = this.radius;\n        serializationObject.height = this.height;\n        serializationObject.radiusRange = this.radiusRange;\n        serializationObject.directionRandomizer = this.directionRandomizer;\n        return serializationObject;\n    }\n    /**\n     * Parse properties from a JSON object\n     * @param serializationObject defines the JSON object\n     */\n    parse(serializationObject) {\n        this.radius = serializationObject.radius;\n        this.height = serializationObject.height;\n        this.radiusRange = serializationObject.radiusRange;\n        this.directionRandomizer = serializationObject.directionRandomizer;\n    }\n}\n/**\n * Particle emitter emitting particles from the inside of a cylinder.\n * It emits the particles randomly between two vectors.\n */\nexport class CylinderDirectedParticleEmitter extends CylinderParticleEmitter {\n    /**\n     * Creates a new instance CylinderDirectedParticleEmitter\n     * @param radius the radius of the emission cylinder (1 by default)\n     * @param height the height of the emission cylinder (1 by default)\n     * @param radiusRange the range of the emission cylinder [0-1] 0 Surface only, 1 Entire Radius (1 by default)\n     * @param direction1 the min limit of the emission direction (up vector by default)\n     * @param direction2 the max limit of the emission direction (up vector by default)\n     */\n    constructor(radius = 1, height = 1, radiusRange = 1, \n    /**\n     * The min limit of the emission direction.\n     */\n    direction1 = new Vector3(0, 1, 0), \n    /**\n     * The max limit of the emission direction.\n     */\n    direction2 = new Vector3(0, 1, 0)) {\n        super(radius, height, radiusRange);\n        this.direction1 = direction1;\n        this.direction2 = direction2;\n    }\n    /**\n     * Called by the particle System when the direction is computed for the created particle.\n     * @param worldMatrix is the world matrix of the particle system\n     * @param directionToUpdate is the direction vector to update with the result\n     */\n    startDirectionFunction(worldMatrix, directionToUpdate) {\n        const randX = Scalar.RandomRange(this.direction1.x, this.direction2.x);\n        const randY = Scalar.RandomRange(this.direction1.y, this.direction2.y);\n        const randZ = Scalar.RandomRange(this.direction1.z, this.direction2.z);\n        Vector3.TransformNormalFromFloatsToRef(randX, randY, randZ, worldMatrix, directionToUpdate);\n    }\n    /**\n     * Clones the current emitter and returns a copy of it\n     * @returns the new emitter\n     */\n    clone() {\n        const newOne = new CylinderDirectedParticleEmitter(this.radius, this.height, this.radiusRange, this.direction1, this.direction2);\n        DeepCopier.DeepCopy(this, newOne);\n        return newOne;\n    }\n    /**\n     * Called by the GPUParticleSystem to setup the update shader\n     * @param uboOrEffect defines the update shader\n     */\n    applyToShader(uboOrEffect) {\n        uboOrEffect.setFloat(\"radius\", this.radius);\n        uboOrEffect.setFloat(\"height\", this.height);\n        uboOrEffect.setFloat(\"radiusRange\", this.radiusRange);\n        uboOrEffect.setVector3(\"direction1\", this.direction1);\n        uboOrEffect.setVector3(\"direction2\", this.direction2);\n    }\n    /**\n     * Creates the structure of the ubo for this particle emitter\n     * @param ubo ubo to create the structure for\n     */\n    buildUniformLayout(ubo) {\n        ubo.addUniform(\"radius\", 1);\n        ubo.addUniform(\"height\", 1);\n        ubo.addUniform(\"radiusRange\", 1);\n        ubo.addUniform(\"direction1\", 3);\n        ubo.addUniform(\"direction2\", 3);\n    }\n    /**\n     * Returns a string to use to update the GPU particles update shader\n     * @returns a string containing the defines string\n     */\n    getEffectDefines() {\n        return \"#define CYLINDEREMITTER\\n#define DIRECTEDCYLINDEREMITTER\";\n    }\n    /**\n     * Returns the string \"CylinderDirectedParticleEmitter\"\n     * @returns a string containing the class name\n     */\n    getClassName() {\n        return \"CylinderDirectedParticleEmitter\";\n    }\n    /**\n     * Serializes the particle system to a JSON object.\n     * @returns the JSON object\n     */\n    serialize() {\n        const serializationObject = super.serialize();\n        serializationObject.direction1 = this.direction1.asArray();\n        serializationObject.direction2 = this.direction2.asArray();\n        return serializationObject;\n    }\n    /**\n     * Parse properties from a JSON object\n     * @param serializationObject defines the JSON object\n     */\n    parse(serializationObject) {\n        super.parse(serializationObject);\n        this.direction1.copyFrom(serializationObject.direction1);\n        this.direction2.copyFrom(serializationObject.direction2);\n    }\n}\n//# sourceMappingURL=cylinderParticleEmitter.js.map","import { DeepCopier } from \"../../Misc/deepCopier.js\";\nimport { Vector3 } from \"../../Maths/math.vector.js\";\nimport { Scalar } from \"../../Maths/math.scalar.js\";\n/**\n * Particle emitter emitting particles from the inside of a hemisphere.\n * It emits the particles alongside the hemisphere radius. The emission direction might be randomized.\n */\nexport class HemisphericParticleEmitter {\n    /**\n     * Creates a new instance HemisphericParticleEmitter\n     * @param radius the radius of the emission hemisphere (1 by default)\n     * @param radiusRange the range of the emission hemisphere [0-1] 0 Surface only, 1 Entire Radius (1 by default)\n     * @param directionRandomizer defines how much to randomize the particle direction [0-1]\n     */\n    constructor(\n    /**\n     * The radius of the emission hemisphere.\n     */\n    radius = 1, \n    /**\n     * The range of emission [0-1] 0 Surface only, 1 Entire Radius.\n     */\n    radiusRange = 1, \n    /**\n     * How much to randomize the particle direction [0-1].\n     */\n    directionRandomizer = 0) {\n        this.radius = radius;\n        this.radiusRange = radiusRange;\n        this.directionRandomizer = directionRandomizer;\n    }\n    /**\n     * Called by the particle System when the direction is computed for the created particle.\n     * @param worldMatrix is the world matrix of the particle system\n     * @param directionToUpdate is the direction vector to update with the result\n     * @param particle is the particle we are computed the direction for\n     * @param isLocal defines if the direction should be set in local space\n     */\n    startDirectionFunction(worldMatrix, directionToUpdate, particle, isLocal) {\n        const direction = particle.position.subtract(worldMatrix.getTranslation()).normalize();\n        const randX = Scalar.RandomRange(0, this.directionRandomizer);\n        const randY = Scalar.RandomRange(0, this.directionRandomizer);\n        const randZ = Scalar.RandomRange(0, this.directionRandomizer);\n        direction.x += randX;\n        direction.y += randY;\n        direction.z += randZ;\n        direction.normalize();\n        if (isLocal) {\n            directionToUpdate.copyFrom(direction);\n            return;\n        }\n        Vector3.TransformNormalFromFloatsToRef(direction.x, direction.y, direction.z, worldMatrix, directionToUpdate);\n    }\n    /**\n     * Called by the particle System when the position is computed for the created particle.\n     * @param worldMatrix is the world matrix of the particle system\n     * @param positionToUpdate is the position vector to update with the result\n     * @param particle is the particle we are computed the position for\n     * @param isLocal defines if the position should be set in local space\n     */\n    startPositionFunction(worldMatrix, positionToUpdate, particle, isLocal) {\n        const randRadius = this.radius - Scalar.RandomRange(0, this.radius * this.radiusRange);\n        const v = Scalar.RandomRange(0, 1.0);\n        const phi = Scalar.RandomRange(0, 2 * Math.PI);\n        const theta = Math.acos(2 * v - 1);\n        const randX = randRadius * Math.cos(phi) * Math.sin(theta);\n        const randY = randRadius * Math.cos(theta);\n        const randZ = randRadius * Math.sin(phi) * Math.sin(theta);\n        if (isLocal) {\n            positionToUpdate.copyFromFloats(randX, Math.abs(randY), randZ);\n            return;\n        }\n        Vector3.TransformCoordinatesFromFloatsToRef(randX, Math.abs(randY), randZ, worldMatrix, positionToUpdate);\n    }\n    /**\n     * Clones the current emitter and returns a copy of it\n     * @returns the new emitter\n     */\n    clone() {\n        const newOne = new HemisphericParticleEmitter(this.radius, this.directionRandomizer);\n        DeepCopier.DeepCopy(this, newOne);\n        return newOne;\n    }\n    /**\n     * Called by the GPUParticleSystem to setup the update shader\n     * @param uboOrEffect defines the update shader\n     */\n    applyToShader(uboOrEffect) {\n        uboOrEffect.setFloat(\"radius\", this.radius);\n        uboOrEffect.setFloat(\"radiusRange\", this.radiusRange);\n        uboOrEffect.setFloat(\"directionRandomizer\", this.directionRandomizer);\n    }\n    /**\n     * Creates the structure of the ubo for this particle emitter\n     * @param ubo ubo to create the structure for\n     */\n    buildUniformLayout(ubo) {\n        ubo.addUniform(\"radius\", 1);\n        ubo.addUniform(\"radiusRange\", 1);\n        ubo.addUniform(\"directionRandomizer\", 1);\n    }\n    /**\n     * Returns a string to use to update the GPU particles update shader\n     * @returns a string containing the defines string\n     */\n    getEffectDefines() {\n        return \"#define HEMISPHERICEMITTER\";\n    }\n    /**\n     * Returns the string \"HemisphericParticleEmitter\"\n     * @returns a string containing the class name\n     */\n    getClassName() {\n        return \"HemisphericParticleEmitter\";\n    }\n    /**\n     * Serializes the particle system to a JSON object.\n     * @returns the JSON object\n     */\n    serialize() {\n        const serializationObject = {};\n        serializationObject.type = this.getClassName();\n        serializationObject.radius = this.radius;\n        serializationObject.radiusRange = this.radiusRange;\n        serializationObject.directionRandomizer = this.directionRandomizer;\n        return serializationObject;\n    }\n    /**\n     * Parse properties from a JSON object\n     * @param serializationObject defines the JSON object\n     */\n    parse(serializationObject) {\n        this.radius = serializationObject.radius;\n        this.radiusRange = serializationObject.radiusRange;\n        this.directionRandomizer = serializationObject.directionRandomizer;\n    }\n}\n//# sourceMappingURL=hemisphericParticleEmitter.js.map","import { DeepCopier } from \"../../Misc/deepCopier.js\";\nimport { Vector3 } from \"../../Maths/math.vector.js\";\nimport { Scalar } from \"../../Maths/math.scalar.js\";\n/**\n * Particle emitter emitting particles from a point.\n * It emits the particles randomly between 2 given directions.\n */\nexport class PointParticleEmitter {\n    /**\n     * Creates a new instance PointParticleEmitter\n     */\n    constructor() {\n        /**\n         * Random direction of each particle after it has been emitted, between direction1 and direction2 vectors.\n         */\n        this.direction1 = new Vector3(0, 1.0, 0);\n        /**\n         * Random direction of each particle after it has been emitted, between direction1 and direction2 vectors.\n         */\n        this.direction2 = new Vector3(0, 1.0, 0);\n    }\n    /**\n     * Called by the particle System when the direction is computed for the created particle.\n     * @param worldMatrix is the world matrix of the particle system\n     * @param directionToUpdate is the direction vector to update with the result\n     * @param particle is the particle we are computed the direction for\n     * @param isLocal defines if the direction should be set in local space\n     */\n    startDirectionFunction(worldMatrix, directionToUpdate, particle, isLocal) {\n        const randX = Scalar.RandomRange(this.direction1.x, this.direction2.x);\n        const randY = Scalar.RandomRange(this.direction1.y, this.direction2.y);\n        const randZ = Scalar.RandomRange(this.direction1.z, this.direction2.z);\n        if (isLocal) {\n            directionToUpdate.copyFromFloats(randX, randY, randZ);\n            return;\n        }\n        Vector3.TransformNormalFromFloatsToRef(randX, randY, randZ, worldMatrix, directionToUpdate);\n    }\n    /**\n     * Called by the particle System when the position is computed for the created particle.\n     * @param worldMatrix is the world matrix of the particle system\n     * @param positionToUpdate is the position vector to update with the result\n     * @param particle is the particle we are computed the position for\n     * @param isLocal defines if the position should be set in local space\n     */\n    startPositionFunction(worldMatrix, positionToUpdate, particle, isLocal) {\n        if (isLocal) {\n            positionToUpdate.copyFromFloats(0, 0, 0);\n            return;\n        }\n        Vector3.TransformCoordinatesFromFloatsToRef(0, 0, 0, worldMatrix, positionToUpdate);\n    }\n    /**\n     * Clones the current emitter and returns a copy of it\n     * @returns the new emitter\n     */\n    clone() {\n        const newOne = new PointParticleEmitter();\n        DeepCopier.DeepCopy(this, newOne);\n        return newOne;\n    }\n    /**\n     * Called by the GPUParticleSystem to setup the update shader\n     * @param uboOrEffect defines the update shader\n     */\n    applyToShader(uboOrEffect) {\n        uboOrEffect.setVector3(\"direction1\", this.direction1);\n        uboOrEffect.setVector3(\"direction2\", this.direction2);\n    }\n    /**\n     * Creates the structure of the ubo for this particle emitter\n     * @param ubo ubo to create the structure for\n     */\n    buildUniformLayout(ubo) {\n        ubo.addUniform(\"direction1\", 3);\n        ubo.addUniform(\"direction2\", 3);\n    }\n    /**\n     * Returns a string to use to update the GPU particles update shader\n     * @returns a string containing the defines string\n     */\n    getEffectDefines() {\n        return \"#define POINTEMITTER\";\n    }\n    /**\n     * Returns the string \"PointParticleEmitter\"\n     * @returns a string containing the class name\n     */\n    getClassName() {\n        return \"PointParticleEmitter\";\n    }\n    /**\n     * Serializes the particle system to a JSON object.\n     * @returns the JSON object\n     */\n    serialize() {\n        const serializationObject = {};\n        serializationObject.type = this.getClassName();\n        serializationObject.direction1 = this.direction1.asArray();\n        serializationObject.direction2 = this.direction2.asArray();\n        return serializationObject;\n    }\n    /**\n     * Parse properties from a JSON object\n     * @param serializationObject defines the JSON object\n     */\n    parse(serializationObject) {\n        Vector3.FromArrayToRef(serializationObject.direction1, 0, this.direction1);\n        Vector3.FromArrayToRef(serializationObject.direction2, 0, this.direction2);\n    }\n}\n//# sourceMappingURL=pointParticleEmitter.js.map","import { DeepCopier } from \"../../Misc/deepCopier.js\";\nimport { Vector3, TmpVectors } from \"../../Maths/math.vector.js\";\nimport { Scalar } from \"../../Maths/math.scalar.js\";\nimport { VertexBuffer } from \"../../Buffers/buffer.js\";\n/**\n * Particle emitter emitting particles from the inside of a box.\n * It emits the particles randomly between 2 given directions.\n */\nexport class MeshParticleEmitter {\n    /** Defines the mesh to use as source */\n    get mesh() {\n        return this._mesh;\n    }\n    set mesh(value) {\n        if (this._mesh === value) {\n            return;\n        }\n        this._mesh = value;\n        if (value) {\n            this._indices = value.getIndices();\n            this._positions = value.getVerticesData(VertexBuffer.PositionKind);\n            this._normals = value.getVerticesData(VertexBuffer.NormalKind);\n        }\n        else {\n            this._indices = null;\n            this._positions = null;\n            this._normals = null;\n        }\n    }\n    /**\n     * Creates a new instance MeshParticleEmitter\n     * @param mesh defines the mesh to use as source\n     */\n    constructor(mesh = null) {\n        this._indices = null;\n        this._positions = null;\n        this._normals = null;\n        this._storedNormal = Vector3.Zero();\n        this._mesh = null;\n        /**\n         * Random direction of each particle after it has been emitted, between direction1 and direction2 vectors.\n         */\n        this.direction1 = new Vector3(0, 1.0, 0);\n        /**\n         * Random direction of each particle after it has been emitted, between direction1 and direction2 vectors.\n         */\n        this.direction2 = new Vector3(0, 1.0, 0);\n        /**\n         * Gets or sets a boolean indicating that particle directions must be built from mesh face normals\n         */\n        this.useMeshNormalsForDirection = true;\n        this.mesh = mesh;\n    }\n    /**\n     * Called by the particle System when the direction is computed for the created particle.\n     * @param worldMatrix is the world matrix of the particle system\n     * @param directionToUpdate is the direction vector to update with the result\n     * @param particle is the particle we are computed the direction for\n     * @param isLocal defines if the direction should be set in local space\n     */\n    startDirectionFunction(worldMatrix, directionToUpdate, particle, isLocal) {\n        if (this.useMeshNormalsForDirection && this._normals) {\n            Vector3.TransformNormalToRef(this._storedNormal, worldMatrix, directionToUpdate);\n            return;\n        }\n        const randX = Scalar.RandomRange(this.direction1.x, this.direction2.x);\n        const randY = Scalar.RandomRange(this.direction1.y, this.direction2.y);\n        const randZ = Scalar.RandomRange(this.direction1.z, this.direction2.z);\n        if (isLocal) {\n            directionToUpdate.copyFromFloats(randX, randY, randZ);\n            return;\n        }\n        Vector3.TransformNormalFromFloatsToRef(randX, randY, randZ, worldMatrix, directionToUpdate);\n    }\n    /**\n     * Called by the particle System when the position is computed for the created particle.\n     * @param worldMatrix is the world matrix of the particle system\n     * @param positionToUpdate is the position vector to update with the result\n     * @param particle is the particle we are computed the position for\n     * @param isLocal defines if the position should be set in local space\n     */\n    startPositionFunction(worldMatrix, positionToUpdate, particle, isLocal) {\n        if (!this._indices || !this._positions) {\n            return;\n        }\n        const randomFaceIndex = (3 * Math.random() * (this._indices.length / 3)) | 0;\n        const bu = Math.random();\n        const bv = Math.random() * (1.0 - bu);\n        const bw = 1.0 - bu - bv;\n        const faceIndexA = this._indices[randomFaceIndex];\n        const faceIndexB = this._indices[randomFaceIndex + 1];\n        const faceIndexC = this._indices[randomFaceIndex + 2];\n        const vertexA = TmpVectors.Vector3[0];\n        const vertexB = TmpVectors.Vector3[1];\n        const vertexC = TmpVectors.Vector3[2];\n        const randomVertex = TmpVectors.Vector3[3];\n        Vector3.FromArrayToRef(this._positions, faceIndexA * 3, vertexA);\n        Vector3.FromArrayToRef(this._positions, faceIndexB * 3, vertexB);\n        Vector3.FromArrayToRef(this._positions, faceIndexC * 3, vertexC);\n        randomVertex.x = bu * vertexA.x + bv * vertexB.x + bw * vertexC.x;\n        randomVertex.y = bu * vertexA.y + bv * vertexB.y + bw * vertexC.y;\n        randomVertex.z = bu * vertexA.z + bv * vertexB.z + bw * vertexC.z;\n        if (isLocal) {\n            positionToUpdate.copyFromFloats(randomVertex.x, randomVertex.y, randomVertex.z);\n        }\n        else {\n            Vector3.TransformCoordinatesFromFloatsToRef(randomVertex.x, randomVertex.y, randomVertex.z, worldMatrix, positionToUpdate);\n        }\n        if (this.useMeshNormalsForDirection && this._normals) {\n            Vector3.FromArrayToRef(this._normals, faceIndexA * 3, vertexA);\n            Vector3.FromArrayToRef(this._normals, faceIndexB * 3, vertexB);\n            Vector3.FromArrayToRef(this._normals, faceIndexC * 3, vertexC);\n            this._storedNormal.x = bu * vertexA.x + bv * vertexB.x + bw * vertexC.x;\n            this._storedNormal.y = bu * vertexA.y + bv * vertexB.y + bw * vertexC.y;\n            this._storedNormal.z = bu * vertexA.z + bv * vertexB.z + bw * vertexC.z;\n        }\n    }\n    /**\n     * Clones the current emitter and returns a copy of it\n     * @returns the new emitter\n     */\n    clone() {\n        const newOne = new MeshParticleEmitter(this.mesh);\n        DeepCopier.DeepCopy(this, newOne);\n        return newOne;\n    }\n    /**\n     * Called by the GPUParticleSystem to setup the update shader\n     * @param uboOrEffect defines the update shader\n     */\n    applyToShader(uboOrEffect) {\n        uboOrEffect.setVector3(\"direction1\", this.direction1);\n        uboOrEffect.setVector3(\"direction2\", this.direction2);\n    }\n    /**\n     * Creates the structure of the ubo for this particle emitter\n     * @param ubo ubo to create the structure for\n     */\n    buildUniformLayout(ubo) {\n        ubo.addUniform(\"direction1\", 3);\n        ubo.addUniform(\"direction2\", 3);\n    }\n    /**\n     * Returns a string to use to update the GPU particles update shader\n     * @returns a string containing the defines string\n     */\n    getEffectDefines() {\n        return \"\";\n    }\n    /**\n     * Returns the string \"BoxParticleEmitter\"\n     * @returns a string containing the class name\n     */\n    getClassName() {\n        return \"MeshParticleEmitter\";\n    }\n    /**\n     * Serializes the particle system to a JSON object.\n     * @returns the JSON object\n     */\n    serialize() {\n        var _a;\n        const serializationObject = {};\n        serializationObject.type = this.getClassName();\n        serializationObject.direction1 = this.direction1.asArray();\n        serializationObject.direction2 = this.direction2.asArray();\n        serializationObject.meshId = (_a = this.mesh) === null || _a === void 0 ? void 0 : _a.id;\n        serializationObject.useMeshNormalsForDirection = this.useMeshNormalsForDirection;\n        return serializationObject;\n    }\n    /**\n     * Parse properties from a JSON object\n     * @param serializationObject defines the JSON object\n     * @param scene defines the hosting scene\n     */\n    parse(serializationObject, scene) {\n        Vector3.FromArrayToRef(serializationObject.direction1, 0, this.direction1);\n        Vector3.FromArrayToRef(serializationObject.direction2, 0, this.direction2);\n        if (serializationObject.meshId && scene) {\n            this.mesh = scene.getLastMeshById(serializationObject.meshId);\n        }\n        this.useMeshNormalsForDirection = serializationObject.useMeshNormalsForDirection;\n    }\n}\n//# sourceMappingURL=meshParticleEmitter.js.map","import { Vector3 } from \"../../Maths/math.vector.js\";\nimport { Scalar } from \"../../Maths/math.scalar.js\";\nimport { DeepCopier } from \"../../Misc/deepCopier.js\";\n/**\n * Particle emitter emitting particles from the inside of a sphere.\n * It emits the particles alongside the sphere radius. The emission direction might be randomized.\n */\nexport class SphereParticleEmitter {\n    /**\n     * Creates a new instance SphereParticleEmitter\n     * @param radius the radius of the emission sphere (1 by default)\n     * @param radiusRange the range of the emission sphere [0-1] 0 Surface only, 1 Entire Radius (1 by default)\n     * @param directionRandomizer defines how much to randomize the particle direction [0-1]\n     */\n    constructor(\n    /**\n     * The radius of the emission sphere.\n     */\n    radius = 1, \n    /**\n     * The range of emission [0-1] 0 Surface only, 1 Entire Radius.\n     */\n    radiusRange = 1, \n    /**\n     * How much to randomize the particle direction [0-1].\n     */\n    directionRandomizer = 0) {\n        this.radius = radius;\n        this.radiusRange = radiusRange;\n        this.directionRandomizer = directionRandomizer;\n    }\n    /**\n     * Called by the particle System when the direction is computed for the created particle.\n     * @param worldMatrix is the world matrix of the particle system\n     * @param directionToUpdate is the direction vector to update with the result\n     * @param particle is the particle we are computed the direction for\n     * @param isLocal defines if the direction should be set in local space\n     */\n    startDirectionFunction(worldMatrix, directionToUpdate, particle, isLocal) {\n        const direction = particle.position.subtract(worldMatrix.getTranslation()).normalize();\n        const randX = Scalar.RandomRange(0, this.directionRandomizer);\n        const randY = Scalar.RandomRange(0, this.directionRandomizer);\n        const randZ = Scalar.RandomRange(0, this.directionRandomizer);\n        direction.x += randX;\n        direction.y += randY;\n        direction.z += randZ;\n        direction.normalize();\n        if (isLocal) {\n            directionToUpdate.copyFrom(direction);\n            return;\n        }\n        Vector3.TransformNormalFromFloatsToRef(direction.x, direction.y, direction.z, worldMatrix, directionToUpdate);\n    }\n    /**\n     * Called by the particle System when the position is computed for the created particle.\n     * @param worldMatrix is the world matrix of the particle system\n     * @param positionToUpdate is the position vector to update with the result\n     * @param particle is the particle we are computed the position for\n     * @param isLocal defines if the position should be set in local space\n     */\n    startPositionFunction(worldMatrix, positionToUpdate, particle, isLocal) {\n        const randRadius = this.radius - Scalar.RandomRange(0, this.radius * this.radiusRange);\n        const v = Scalar.RandomRange(0, 1.0);\n        const phi = Scalar.RandomRange(0, 2 * Math.PI);\n        const theta = Math.acos(2 * v - 1);\n        const randX = randRadius * Math.cos(phi) * Math.sin(theta);\n        const randY = randRadius * Math.cos(theta);\n        const randZ = randRadius * Math.sin(phi) * Math.sin(theta);\n        if (isLocal) {\n            positionToUpdate.copyFromFloats(randX, randY, randZ);\n            return;\n        }\n        Vector3.TransformCoordinatesFromFloatsToRef(randX, randY, randZ, worldMatrix, positionToUpdate);\n    }\n    /**\n     * Clones the current emitter and returns a copy of it\n     * @returns the new emitter\n     */\n    clone() {\n        const newOne = new SphereParticleEmitter(this.radius, this.directionRandomizer);\n        DeepCopier.DeepCopy(this, newOne);\n        return newOne;\n    }\n    /**\n     * Called by the GPUParticleSystem to setup the update shader\n     * @param uboOrEffect defines the update shader\n     */\n    applyToShader(uboOrEffect) {\n        uboOrEffect.setFloat(\"radius\", this.radius);\n        uboOrEffect.setFloat(\"radiusRange\", this.radiusRange);\n        uboOrEffect.setFloat(\"directionRandomizer\", this.directionRandomizer);\n    }\n    /**\n     * Creates the structure of the ubo for this particle emitter\n     * @param ubo ubo to create the structure for\n     */\n    buildUniformLayout(ubo) {\n        ubo.addUniform(\"radius\", 1);\n        ubo.addUniform(\"radiusRange\", 1);\n        ubo.addUniform(\"directionRandomizer\", 1);\n    }\n    /**\n     * Returns a string to use to update the GPU particles update shader\n     * @returns a string containing the defines string\n     */\n    getEffectDefines() {\n        return \"#define SPHEREEMITTER\";\n    }\n    /**\n     * Returns the string \"SphereParticleEmitter\"\n     * @returns a string containing the class name\n     */\n    getClassName() {\n        return \"SphereParticleEmitter\";\n    }\n    /**\n     * Serializes the particle system to a JSON object.\n     * @returns the JSON object\n     */\n    serialize() {\n        const serializationObject = {};\n        serializationObject.type = this.getClassName();\n        serializationObject.radius = this.radius;\n        serializationObject.radiusRange = this.radiusRange;\n        serializationObject.directionRandomizer = this.directionRandomizer;\n        return serializationObject;\n    }\n    /**\n     * Parse properties from a JSON object\n     * @param serializationObject defines the JSON object\n     */\n    parse(serializationObject) {\n        this.radius = serializationObject.radius;\n        this.radiusRange = serializationObject.radiusRange;\n        this.directionRandomizer = serializationObject.directionRandomizer;\n    }\n}\n/**\n * Particle emitter emitting particles from the inside of a sphere.\n * It emits the particles randomly between two vectors.\n */\nexport class SphereDirectedParticleEmitter extends SphereParticleEmitter {\n    /**\n     * Creates a new instance SphereDirectedParticleEmitter\n     * @param radius the radius of the emission sphere (1 by default)\n     * @param direction1 the min limit of the emission direction (up vector by default)\n     * @param direction2 the max limit of the emission direction (up vector by default)\n     */\n    constructor(radius = 1, \n    /**\n     * The min limit of the emission direction.\n     */\n    direction1 = new Vector3(0, 1, 0), \n    /**\n     * The max limit of the emission direction.\n     */\n    direction2 = new Vector3(0, 1, 0)) {\n        super(radius);\n        this.direction1 = direction1;\n        this.direction2 = direction2;\n    }\n    /**\n     * Called by the particle System when the direction is computed for the created particle.\n     * @param worldMatrix is the world matrix of the particle system\n     * @param directionToUpdate is the direction vector to update with the result\n     */\n    startDirectionFunction(worldMatrix, directionToUpdate) {\n        const randX = Scalar.RandomRange(this.direction1.x, this.direction2.x);\n        const randY = Scalar.RandomRange(this.direction1.y, this.direction2.y);\n        const randZ = Scalar.RandomRange(this.direction1.z, this.direction2.z);\n        Vector3.TransformNormalFromFloatsToRef(randX, randY, randZ, worldMatrix, directionToUpdate);\n    }\n    /**\n     * Clones the current emitter and returns a copy of it\n     * @returns the new emitter\n     */\n    clone() {\n        const newOne = new SphereDirectedParticleEmitter(this.radius, this.direction1, this.direction2);\n        DeepCopier.DeepCopy(this, newOne);\n        return newOne;\n    }\n    /**\n     * Called by the GPUParticleSystem to setup the update shader\n     * @param uboOrEffect defines the update shader\n     */\n    applyToShader(uboOrEffect) {\n        uboOrEffect.setFloat(\"radius\", this.radius);\n        uboOrEffect.setFloat(\"radiusRange\", this.radiusRange);\n        uboOrEffect.setVector3(\"direction1\", this.direction1);\n        uboOrEffect.setVector3(\"direction2\", this.direction2);\n    }\n    /**\n     * Creates the structure of the ubo for this particle emitter\n     * @param ubo ubo to create the structure for\n     */\n    buildUniformLayout(ubo) {\n        ubo.addUniform(\"radius\", 1);\n        ubo.addUniform(\"radiusRange\", 1);\n        ubo.addUniform(\"direction1\", 3);\n        ubo.addUniform(\"direction2\", 3);\n    }\n    /**\n     * Returns a string to use to update the GPU particles update shader\n     * @returns a string containing the defines string\n     */\n    getEffectDefines() {\n        return \"#define SPHEREEMITTER\\n#define DIRECTEDSPHEREEMITTER\";\n    }\n    /**\n     * Returns the string \"SphereDirectedParticleEmitter\"\n     * @returns a string containing the class name\n     */\n    getClassName() {\n        return \"SphereDirectedParticleEmitter\";\n    }\n    /**\n     * Serializes the particle system to a JSON object.\n     * @returns the JSON object\n     */\n    serialize() {\n        const serializationObject = super.serialize();\n        serializationObject.direction1 = this.direction1.asArray();\n        serializationObject.direction2 = this.direction2.asArray();\n        return serializationObject;\n    }\n    /**\n     * Parse properties from a JSON object\n     * @param serializationObject defines the JSON object\n     */\n    parse(serializationObject) {\n        super.parse(serializationObject);\n        this.direction1.copyFrom(serializationObject.direction1);\n        this.direction2.copyFrom(serializationObject.direction2);\n    }\n}\n//# sourceMappingURL=sphereParticleEmitter.js.map","import { Vector2, Vector3 } from \"../Maths/math.vector.js\";\nimport { ImageProcessingConfigurationDefines } from \"../Materials/imageProcessingConfiguration.js\";\nimport { BoxParticleEmitter, PointParticleEmitter, HemisphericParticleEmitter, SphereParticleEmitter, SphereDirectedParticleEmitter, CylinderParticleEmitter, CylinderDirectedParticleEmitter, ConeParticleEmitter, } from \"../Particles/EmitterTypes/index.js\";\n\nimport { Color4 } from \"../Maths/math.color.js\";\nimport \"../Engines/Extensions/engine.dynamicBuffer.js\";\n/**\n * This represents the base class for particle system in Babylon.\n * Particles are often small sprites used to simulate hard-to-reproduce phenomena like fire, smoke, water, or abstract visual effects like magic glitter and faery dust.\n * Particles can take different shapes while emitted like box, sphere, cone or you can write your custom function.\n * @example https://doc.babylonjs.com/features/featuresDeepDive/particles/particle_system/particle_system_intro\n */\nexport class BaseParticleSystem {\n    /**\n     * Gets or sets a texture used to add random noise to particle positions\n     */\n    get noiseTexture() {\n        return this._noiseTexture;\n    }\n    set noiseTexture(value) {\n        if (this._noiseTexture === value) {\n            return;\n        }\n        this._noiseTexture = value;\n        this._reset();\n    }\n    /**\n     * Gets or sets whether an animation sprite sheet is enabled or not on the particle system\n     */\n    get isAnimationSheetEnabled() {\n        return this._isAnimationSheetEnabled;\n    }\n    set isAnimationSheetEnabled(value) {\n        if (this._isAnimationSheetEnabled == value) {\n            return;\n        }\n        this._isAnimationSheetEnabled = value;\n        this._reset();\n    }\n    /**\n     * Gets or sets a boolean enabling the use of logarithmic depth buffers, which is good for wide depth buffers.\n     */\n    get useLogarithmicDepth() {\n        return this._useLogarithmicDepth;\n    }\n    set useLogarithmicDepth(value) {\n        this._useLogarithmicDepth = value && this.getScene().getEngine().getCaps().fragmentDepthSupported;\n    }\n    /**\n     * Get hosting scene\n     * @returns the scene\n     */\n    getScene() {\n        return this._scene;\n    }\n    _hasTargetStopDurationDependantGradient() {\n        return ((this._startSizeGradients && this._startSizeGradients.length > 0) ||\n            (this._emitRateGradients && this._emitRateGradients.length > 0) ||\n            (this._lifeTimeGradients && this._lifeTimeGradients.length > 0));\n    }\n    /**\n     * Gets the current list of drag gradients.\n     * You must use addDragGradient and removeDragGradient to update this list\n     * @returns the list of drag gradients\n     */\n    getDragGradients() {\n        return this._dragGradients;\n    }\n    /**\n     * Gets the current list of limit velocity gradients.\n     * You must use addLimitVelocityGradient and removeLimitVelocityGradient to update this list\n     * @returns the list of limit velocity gradients\n     */\n    getLimitVelocityGradients() {\n        return this._limitVelocityGradients;\n    }\n    /**\n     * Gets the current list of color gradients.\n     * You must use addColorGradient and removeColorGradient to update this list\n     * @returns the list of color gradients\n     */\n    getColorGradients() {\n        return this._colorGradients;\n    }\n    /**\n     * Gets the current list of size gradients.\n     * You must use addSizeGradient and removeSizeGradient to update this list\n     * @returns the list of size gradients\n     */\n    getSizeGradients() {\n        return this._sizeGradients;\n    }\n    /**\n     * Gets the current list of color remap gradients.\n     * You must use addColorRemapGradient and removeColorRemapGradient to update this list\n     * @returns the list of color remap gradients\n     */\n    getColorRemapGradients() {\n        return this._colorRemapGradients;\n    }\n    /**\n     * Gets the current list of alpha remap gradients.\n     * You must use addAlphaRemapGradient and removeAlphaRemapGradient to update this list\n     * @returns the list of alpha remap gradients\n     */\n    getAlphaRemapGradients() {\n        return this._alphaRemapGradients;\n    }\n    /**\n     * Gets the current list of life time gradients.\n     * You must use addLifeTimeGradient and removeLifeTimeGradient to update this list\n     * @returns the list of life time gradients\n     */\n    getLifeTimeGradients() {\n        return this._lifeTimeGradients;\n    }\n    /**\n     * Gets the current list of angular speed gradients.\n     * You must use addAngularSpeedGradient and removeAngularSpeedGradient to update this list\n     * @returns the list of angular speed gradients\n     */\n    getAngularSpeedGradients() {\n        return this._angularSpeedGradients;\n    }\n    /**\n     * Gets the current list of velocity gradients.\n     * You must use addVelocityGradient and removeVelocityGradient to update this list\n     * @returns the list of velocity gradients\n     */\n    getVelocityGradients() {\n        return this._velocityGradients;\n    }\n    /**\n     * Gets the current list of start size gradients.\n     * You must use addStartSizeGradient and removeStartSizeGradient to update this list\n     * @returns the list of start size gradients\n     */\n    getStartSizeGradients() {\n        return this._startSizeGradients;\n    }\n    /**\n     * Gets the current list of emit rate gradients.\n     * You must use addEmitRateGradient and removeEmitRateGradient to update this list\n     * @returns the list of emit rate gradients\n     */\n    getEmitRateGradients() {\n        return this._emitRateGradients;\n    }\n    /**\n     * Random direction of each particle after it has been emitted, between direction1 and direction2 vectors.\n     * This only works when particleEmitterTyps is a BoxParticleEmitter\n     */\n    get direction1() {\n        if (this.particleEmitterType.direction1) {\n            return this.particleEmitterType.direction1;\n        }\n        return Vector3.Zero();\n    }\n    set direction1(value) {\n        if (this.particleEmitterType.direction1) {\n            this.particleEmitterType.direction1 = value;\n        }\n    }\n    /**\n     * Random direction of each particle after it has been emitted, between direction1 and direction2 vectors.\n     * This only works when particleEmitterTyps is a BoxParticleEmitter\n     */\n    get direction2() {\n        if (this.particleEmitterType.direction2) {\n            return this.particleEmitterType.direction2;\n        }\n        return Vector3.Zero();\n    }\n    set direction2(value) {\n        if (this.particleEmitterType.direction2) {\n            this.particleEmitterType.direction2 = value;\n        }\n    }\n    /**\n     * Minimum box point around our emitter. Our emitter is the center of particles source, but if you want your particles to emit from more than one point, then you can tell it to do so.\n     * This only works when particleEmitterTyps is a BoxParticleEmitter\n     */\n    get minEmitBox() {\n        if (this.particleEmitterType.minEmitBox) {\n            return this.particleEmitterType.minEmitBox;\n        }\n        return Vector3.Zero();\n    }\n    set minEmitBox(value) {\n        if (this.particleEmitterType.minEmitBox) {\n            this.particleEmitterType.minEmitBox = value;\n        }\n    }\n    /**\n     * Maximum box point around our emitter. Our emitter is the center of particles source, but if you want your particles to emit from more than one point, then you can tell it to do so.\n     * This only works when particleEmitterTyps is a BoxParticleEmitter\n     */\n    get maxEmitBox() {\n        if (this.particleEmitterType.maxEmitBox) {\n            return this.particleEmitterType.maxEmitBox;\n        }\n        return Vector3.Zero();\n    }\n    set maxEmitBox(value) {\n        if (this.particleEmitterType.maxEmitBox) {\n            this.particleEmitterType.maxEmitBox = value;\n        }\n    }\n    /**\n     * Gets or sets the billboard mode to use when isBillboardBased = true.\n     * Value can be: ParticleSystem.BILLBOARDMODE_ALL, ParticleSystem.BILLBOARDMODE_Y, ParticleSystem.BILLBOARDMODE_STRETCHED\n     */\n    get billboardMode() {\n        return this._billboardMode;\n    }\n    set billboardMode(value) {\n        if (this._billboardMode === value) {\n            return;\n        }\n        this._billboardMode = value;\n        this._reset();\n    }\n    /**\n     * Gets or sets a boolean indicating if the particles must be rendered as billboard or aligned with the direction\n     */\n    get isBillboardBased() {\n        return this._isBillboardBased;\n    }\n    set isBillboardBased(value) {\n        if (this._isBillboardBased === value) {\n            return;\n        }\n        this._isBillboardBased = value;\n        this._reset();\n    }\n    /**\n     * Gets the image processing configuration used either in this material.\n     */\n    get imageProcessingConfiguration() {\n        return this._imageProcessingConfiguration;\n    }\n    /**\n     * Sets the Default image processing configuration used either in the this material.\n     *\n     * If sets to null, the scene one is in use.\n     */\n    set imageProcessingConfiguration(value) {\n        this._attachImageProcessingConfiguration(value);\n    }\n    /**\n     * Attaches a new image processing configuration to the Standard Material.\n     * @param configuration\n     */\n    _attachImageProcessingConfiguration(configuration) {\n        if (configuration === this._imageProcessingConfiguration) {\n            return;\n        }\n        // Pick the scene configuration if needed.\n        if (!configuration && this._scene) {\n            this._imageProcessingConfiguration = this._scene.imageProcessingConfiguration;\n        }\n        else {\n            this._imageProcessingConfiguration = configuration;\n        }\n    }\n    /** @internal */\n    _reset() { }\n    /**\n     * @internal\n     */\n    _removeGradientAndTexture(gradient, gradients, texture) {\n        if (!gradients) {\n            return this;\n        }\n        let index = 0;\n        for (const valueGradient of gradients) {\n            if (valueGradient.gradient === gradient) {\n                gradients.splice(index, 1);\n                break;\n            }\n            index++;\n        }\n        if (texture) {\n            texture.dispose();\n        }\n        return this;\n    }\n    /**\n     * Instantiates a particle system.\n     * Particles are often small sprites used to simulate hard-to-reproduce phenomena like fire, smoke, water, or abstract visual effects like magic glitter and faery dust.\n     * @param name The name of the particle system\n     */\n    constructor(name) {\n        /**\n         * List of animations used by the particle system.\n         */\n        this.animations = [];\n        /**\n         * The rendering group used by the Particle system to chose when to render.\n         */\n        this.renderingGroupId = 0;\n        /**\n         * The emitter represents the Mesh or position we are attaching the particle system to.\n         */\n        this.emitter = Vector3.Zero();\n        /**\n         * The maximum number of particles to emit per frame\n         */\n        this.emitRate = 10;\n        /**\n         * If you want to launch only a few particles at once, that can be done, as well.\n         */\n        this.manualEmitCount = -1;\n        /**\n         * The overall motion speed (0.01 is default update speed, faster updates = faster animation)\n         */\n        this.updateSpeed = 0.01;\n        /**\n         * The amount of time the particle system is running (depends of the overall update speed).\n         */\n        this.targetStopDuration = 0;\n        /**\n         * Specifies whether the particle system will be disposed once it reaches the end of the animation.\n         */\n        this.disposeOnStop = false;\n        /**\n         * Minimum power of emitting particles.\n         */\n        this.minEmitPower = 1;\n        /**\n         * Maximum power of emitting particles.\n         */\n        this.maxEmitPower = 1;\n        /**\n         * Minimum life time of emitting particles.\n         */\n        this.minLifeTime = 1;\n        /**\n         * Maximum life time of emitting particles.\n         */\n        this.maxLifeTime = 1;\n        /**\n         * Minimum Size of emitting particles.\n         */\n        this.minSize = 1;\n        /**\n         * Maximum Size of emitting particles.\n         */\n        this.maxSize = 1;\n        /**\n         * Minimum scale of emitting particles on X axis.\n         */\n        this.minScaleX = 1;\n        /**\n         * Maximum scale of emitting particles on X axis.\n         */\n        this.maxScaleX = 1;\n        /**\n         * Minimum scale of emitting particles on Y axis.\n         */\n        this.minScaleY = 1;\n        /**\n         * Maximum scale of emitting particles on Y axis.\n         */\n        this.maxScaleY = 1;\n        /**\n         * Gets or sets the minimal initial rotation in radians.\n         */\n        this.minInitialRotation = 0;\n        /**\n         * Gets or sets the maximal initial rotation in radians.\n         */\n        this.maxInitialRotation = 0;\n        /**\n         * Minimum angular speed of emitting particles (Z-axis rotation for each particle).\n         */\n        this.minAngularSpeed = 0;\n        /**\n         * Maximum angular speed of emitting particles (Z-axis rotation for each particle).\n         */\n        this.maxAngularSpeed = 0;\n        /**\n         * The layer mask we are rendering the particles through.\n         */\n        this.layerMask = 0x0fffffff;\n        /**\n         * This can help using your own shader to render the particle system.\n         * The according effect will be created\n         */\n        this.customShader = null;\n        /**\n         * By default particle system starts as soon as they are created. This prevents the\n         * automatic start to happen and let you decide when to start emitting particles.\n         */\n        this.preventAutoStart = false;\n        /** @internal */\n        this._wasDispatched = false;\n        this._rootUrl = \"\";\n        /** Gets or sets the strength to apply to the noise value (default is (10, 10, 10)) */\n        this.noiseStrength = new Vector3(10, 10, 10);\n        /**\n         * Callback triggered when the particle animation is ending.\n         */\n        this.onAnimationEnd = null;\n        /**\n         * Blend mode use to render the particle, it can be either ParticleSystem.BLENDMODE_ONEONE or ParticleSystem.BLENDMODE_STANDARD.\n         */\n        this.blendMode = BaseParticleSystem.BLENDMODE_ONEONE;\n        /**\n         * Forces the particle to write their depth information to the depth buffer. This can help preventing other draw calls\n         * to override the particles.\n         */\n        this.forceDepthWrite = false;\n        /** Gets or sets a value indicating how many cycles (or frames) must be executed before first rendering (this value has to be set before starting the system). Default is 0 */\n        this.preWarmCycles = 0;\n        /** Gets or sets a value indicating the time step multiplier to use in pre-warm mode (default is 1) */\n        this.preWarmStepOffset = 1;\n        /**\n         * If using a spritesheet (isAnimationSheetEnabled) defines the speed of the sprite loop (default is 1 meaning the animation will play once during the entire particle lifetime)\n         */\n        this.spriteCellChangeSpeed = 1;\n        /**\n         * If using a spritesheet (isAnimationSheetEnabled) defines the first sprite cell to display\n         */\n        this.startSpriteCellID = 0;\n        /**\n         * If using a spritesheet (isAnimationSheetEnabled) defines the last sprite cell to display\n         */\n        this.endSpriteCellID = 0;\n        /**\n         * If using a spritesheet (isAnimationSheetEnabled), defines the sprite cell width to use\n         */\n        this.spriteCellWidth = 0;\n        /**\n         * If using a spritesheet (isAnimationSheetEnabled), defines the sprite cell height to use\n         */\n        this.spriteCellHeight = 0;\n        /**\n         * If using a spritesheet (isAnimationSheetEnabled), defines wether the sprite animation is looping\n         */\n        this.spriteCellLoop = true;\n        /**\n         * This allows the system to random pick the start cell ID between startSpriteCellID and endSpriteCellID\n         */\n        this.spriteRandomStartCell = false;\n        /** Gets or sets a Vector2 used to move the pivot (by default (0,0)) */\n        this.translationPivot = new Vector2(0, 0);\n        /**\n         * Gets or sets a boolean indicating that hosted animations (in the system.animations array) must be started when system.start() is called\n         */\n        this.beginAnimationOnStart = false;\n        /**\n         * Gets or sets the frame to start the animation from when beginAnimationOnStart is true\n         */\n        this.beginAnimationFrom = 0;\n        /**\n         * Gets or sets the frame to end the animation on when beginAnimationOnStart is true\n         */\n        this.beginAnimationTo = 60;\n        /**\n         * Gets or sets a boolean indicating if animations must loop when beginAnimationOnStart is true\n         */\n        this.beginAnimationLoop = false;\n        /**\n         * Gets or sets a world offset applied to all particles\n         */\n        this.worldOffset = new Vector3(0, 0, 0);\n        this._useLogarithmicDepth = false;\n        /**\n         * You can use gravity if you want to give an orientation to your particles.\n         */\n        this.gravity = Vector3.Zero();\n        this._colorGradients = null;\n        this._sizeGradients = null;\n        this._lifeTimeGradients = null;\n        this._angularSpeedGradients = null;\n        this._velocityGradients = null;\n        this._limitVelocityGradients = null;\n        this._dragGradients = null;\n        this._emitRateGradients = null;\n        this._startSizeGradients = null;\n        this._rampGradients = null;\n        this._colorRemapGradients = null;\n        this._alphaRemapGradients = null;\n        /**\n         * Defines the delay in milliseconds before starting the system (0 by default)\n         */\n        this.startDelay = 0;\n        /** Gets or sets a value indicating the damping to apply if the limit velocity factor is reached */\n        this.limitVelocityDamping = 0.4;\n        /**\n         * Random color of each particle after it has been emitted, between color1 and color2 vectors\n         */\n        this.color1 = new Color4(1.0, 1.0, 1.0, 1.0);\n        /**\n         * Random color of each particle after it has been emitted, between color1 and color2 vectors\n         */\n        this.color2 = new Color4(1.0, 1.0, 1.0, 1.0);\n        /**\n         * Color the particle will have at the end of its lifetime\n         */\n        this.colorDead = new Color4(0, 0, 0, 1.0);\n        /**\n         * An optional mask to filter some colors out of the texture, or filter a part of the alpha channel\n         */\n        this.textureMask = new Color4(1.0, 1.0, 1.0, 1.0);\n        /** @internal */\n        this._isSubEmitter = false;\n        /** @internal */\n        this._billboardMode = 7;\n        /** @internal */\n        this._isBillboardBased = true;\n        /**\n         * Local cache of defines for image processing.\n         */\n        this._imageProcessingConfigurationDefines = new ImageProcessingConfigurationDefines();\n        this.id = name;\n        this.name = name;\n    }\n    /**\n     * Creates a Point Emitter for the particle system (emits directly from the emitter position)\n     * @param direction1 Particles are emitted between the direction1 and direction2 from within the box\n     * @param direction2 Particles are emitted between the direction1 and direction2 from within the box\n     * @returns the emitter\n     */\n    createPointEmitter(direction1, direction2) {\n        const particleEmitter = new PointParticleEmitter();\n        particleEmitter.direction1 = direction1;\n        particleEmitter.direction2 = direction2;\n        this.particleEmitterType = particleEmitter;\n        return particleEmitter;\n    }\n    /**\n     * Creates a Hemisphere Emitter for the particle system (emits along the hemisphere radius)\n     * @param radius The radius of the hemisphere to emit from\n     * @param radiusRange The range of the hemisphere to emit from [0-1] 0 Surface Only, 1 Entire Radius\n     * @returns the emitter\n     */\n    createHemisphericEmitter(radius = 1, radiusRange = 1) {\n        const particleEmitter = new HemisphericParticleEmitter(radius, radiusRange);\n        this.particleEmitterType = particleEmitter;\n        return particleEmitter;\n    }\n    /**\n     * Creates a Sphere Emitter for the particle system (emits along the sphere radius)\n     * @param radius The radius of the sphere to emit from\n     * @param radiusRange The range of the sphere to emit from [0-1] 0 Surface Only, 1 Entire Radius\n     * @returns the emitter\n     */\n    createSphereEmitter(radius = 1, radiusRange = 1) {\n        const particleEmitter = new SphereParticleEmitter(radius, radiusRange);\n        this.particleEmitterType = particleEmitter;\n        return particleEmitter;\n    }\n    /**\n     * Creates a Directed Sphere Emitter for the particle system (emits between direction1 and direction2)\n     * @param radius The radius of the sphere to emit from\n     * @param direction1 Particles are emitted between the direction1 and direction2 from within the sphere\n     * @param direction2 Particles are emitted between the direction1 and direction2 from within the sphere\n     * @returns the emitter\n     */\n    createDirectedSphereEmitter(radius = 1, direction1 = new Vector3(0, 1.0, 0), direction2 = new Vector3(0, 1.0, 0)) {\n        const particleEmitter = new SphereDirectedParticleEmitter(radius, direction1, direction2);\n        this.particleEmitterType = particleEmitter;\n        return particleEmitter;\n    }\n    /**\n     * Creates a Cylinder Emitter for the particle system (emits from the cylinder to the particle position)\n     * @param radius The radius of the emission cylinder\n     * @param height The height of the emission cylinder\n     * @param radiusRange The range of emission [0-1] 0 Surface only, 1 Entire Radius\n     * @param directionRandomizer How much to randomize the particle direction [0-1]\n     * @returns the emitter\n     */\n    createCylinderEmitter(radius = 1, height = 1, radiusRange = 1, directionRandomizer = 0) {\n        const particleEmitter = new CylinderParticleEmitter(radius, height, radiusRange, directionRandomizer);\n        this.particleEmitterType = particleEmitter;\n        return particleEmitter;\n    }\n    /**\n     * Creates a Directed Cylinder Emitter for the particle system (emits between direction1 and direction2)\n     * @param radius The radius of the cylinder to emit from\n     * @param height The height of the emission cylinder\n     * @param radiusRange the range of the emission cylinder [0-1] 0 Surface only, 1 Entire Radius (1 by default)\n     * @param direction1 Particles are emitted between the direction1 and direction2 from within the cylinder\n     * @param direction2 Particles are emitted between the direction1 and direction2 from within the cylinder\n     * @returns the emitter\n     */\n    createDirectedCylinderEmitter(radius = 1, height = 1, radiusRange = 1, direction1 = new Vector3(0, 1.0, 0), direction2 = new Vector3(0, 1.0, 0)) {\n        const particleEmitter = new CylinderDirectedParticleEmitter(radius, height, radiusRange, direction1, direction2);\n        this.particleEmitterType = particleEmitter;\n        return particleEmitter;\n    }\n    /**\n     * Creates a Cone Emitter for the particle system (emits from the cone to the particle position)\n     * @param radius The radius of the cone to emit from\n     * @param angle The base angle of the cone\n     * @returns the emitter\n     */\n    createConeEmitter(radius = 1, angle = Math.PI / 4) {\n        const particleEmitter = new ConeParticleEmitter(radius, angle);\n        this.particleEmitterType = particleEmitter;\n        return particleEmitter;\n    }\n    /**\n     * Creates a Box Emitter for the particle system. (emits between direction1 and direction2 from withing the box defined by minEmitBox and maxEmitBox)\n     * @param direction1 Particles are emitted between the direction1 and direction2 from within the box\n     * @param direction2 Particles are emitted between the direction1 and direction2 from within the box\n     * @param minEmitBox Particles are emitted from the box between minEmitBox and maxEmitBox\n     * @param maxEmitBox  Particles are emitted from the box between minEmitBox and maxEmitBox\n     * @returns the emitter\n     */\n    createBoxEmitter(direction1, direction2, minEmitBox, maxEmitBox) {\n        const particleEmitter = new BoxParticleEmitter();\n        this.particleEmitterType = particleEmitter;\n        this.direction1 = direction1;\n        this.direction2 = direction2;\n        this.minEmitBox = minEmitBox;\n        this.maxEmitBox = maxEmitBox;\n        return particleEmitter;\n    }\n}\n/**\n * Source color is added to the destination color without alpha affecting the result\n */\nBaseParticleSystem.BLENDMODE_ONEONE = 0;\n/**\n * Blend current color and particle color using particles alpha\n */\nBaseParticleSystem.BLENDMODE_STANDARD = 1;\n/**\n * Add current color and particle color multiplied by particles alpha\n */\nBaseParticleSystem.BLENDMODE_ADD = 2;\n/**\n * Multiply current color with particle color\n */\nBaseParticleSystem.BLENDMODE_MULTIPLY = 3;\n/**\n * Multiply current color with particle color then add current color and particle color multiplied by particles alpha\n */\nBaseParticleSystem.BLENDMODE_MULTIPLYADD = 4;\n//# sourceMappingURL=baseParticleSystem.js.map","import { Color4, Vector2, Vector3, TmpVectors, Quaternion } from \"../Maths/math.js\";\n/**\n * Represents one particle of a points cloud system.\n */\nexport class CloudPoint {\n    /**\n     * Creates a Point Cloud object.\n     * Don't create particles manually, use instead the PCS internal tools like _addParticle()\n     * @param particleIndex (integer) is the particle index in the PCS pool. It's also the particle identifier.\n     * @param group (PointsGroup) is the group the particle belongs to\n     * @param groupId (integer) is the group identifier in the PCS.\n     * @param idxInGroup (integer) is the index of the particle in the current point group (ex: the 10th point of addPoints(30))\n     * @param pcs defines the PCS it is associated to\n     */\n    constructor(particleIndex, group, groupId, idxInGroup, pcs) {\n        /**\n         * particle global index\n         */\n        this.idx = 0;\n        /**\n         * The color of the particle\n         */\n        this.color = new Color4(1.0, 1.0, 1.0, 1.0);\n        /**\n         * The world space position of the particle.\n         */\n        this.position = Vector3.Zero();\n        /**\n         * The world space rotation of the particle. (Not use if rotationQuaternion is set)\n         */\n        this.rotation = Vector3.Zero();\n        /**\n         * The uv of the particle.\n         */\n        this.uv = new Vector2(0.0, 0.0);\n        /**\n         * The current speed of the particle.\n         */\n        this.velocity = Vector3.Zero();\n        /**\n         * The pivot point in the particle local space.\n         */\n        this.pivot = Vector3.Zero();\n        /**\n         * Must the particle be translated from its pivot point in its local space ?\n         * In this case, the pivot point is set at the origin of the particle local space and the particle is translated.\n         * Default : false\n         */\n        this.translateFromPivot = false;\n        /**\n         * Index of this particle in the global \"positions\" array (Internal use)\n         * @internal\n         */\n        this._pos = 0;\n        /**\n         * @internal Index of this particle in the global \"indices\" array (Internal use)\n         */\n        this._ind = 0;\n        /**\n         * Group id of this particle\n         */\n        this.groupId = 0;\n        /**\n         * Index of the particle in its group id (Internal use)\n         */\n        this.idxInGroup = 0;\n        /**\n         * @internal Still set as invisible in order to skip useless computations (Internal use)\n         */\n        this._stillInvisible = false;\n        /**\n         * @internal Last computed particle rotation matrix\n         */\n        this._rotationMatrix = [1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0];\n        /**\n         * Parent particle Id, if any.\n         * Default null.\n         */\n        this.parentId = null;\n        /**\n         * @internal Internal global position in the PCS.\n         */\n        this._globalPosition = Vector3.Zero();\n        this.idx = particleIndex;\n        this._group = group;\n        this.groupId = groupId;\n        this.idxInGroup = idxInGroup;\n        this._pcs = pcs;\n    }\n    /**\n     * get point size\n     */\n    get size() {\n        return this.size;\n    }\n    /**\n     * Set point size\n     */\n    set size(scale) {\n        this.size = scale;\n    }\n    /**\n     * Legacy support, changed quaternion to rotationQuaternion\n     */\n    get quaternion() {\n        return this.rotationQuaternion;\n    }\n    /**\n     * Legacy support, changed quaternion to rotationQuaternion\n     */\n    set quaternion(q) {\n        this.rotationQuaternion = q;\n    }\n    /**\n     * Returns a boolean. True if the particle intersects a mesh, else false\n     * The intersection is computed on the particle position and Axis Aligned Bounding Box (AABB) or Sphere\n     * @param target is the object (point or mesh) what the intersection is computed against\n     * @param isSphere is boolean flag when false (default) bounding box of mesh is used, when true the bounding sphere is used\n     * @returns true if it intersects\n     */\n    intersectsMesh(target, isSphere) {\n        if (!target.hasBoundingInfo) {\n            return false;\n        }\n        if (!this._pcs.mesh) {\n            throw new Error(\"Point Cloud System doesnt contain the Mesh\");\n        }\n        if (isSphere) {\n            return target.getBoundingInfo().boundingSphere.intersectsPoint(this.position.add(this._pcs.mesh.position));\n        }\n        const bbox = target.getBoundingInfo().boundingBox;\n        const maxX = bbox.maximumWorld.x;\n        const minX = bbox.minimumWorld.x;\n        const maxY = bbox.maximumWorld.y;\n        const minY = bbox.minimumWorld.y;\n        const maxZ = bbox.maximumWorld.z;\n        const minZ = bbox.minimumWorld.z;\n        const x = this.position.x + this._pcs.mesh.position.x;\n        const y = this.position.y + this._pcs.mesh.position.y;\n        const z = this.position.z + this._pcs.mesh.position.z;\n        return minX <= x && x <= maxX && minY <= y && y <= maxY && minZ <= z && z <= maxZ;\n    }\n    /**\n     * get the rotation matrix of the particle\n     * @internal\n     */\n    getRotationMatrix(m) {\n        let quaternion;\n        if (this.rotationQuaternion) {\n            quaternion = this.rotationQuaternion;\n        }\n        else {\n            quaternion = TmpVectors.Quaternion[0];\n            const rotation = this.rotation;\n            Quaternion.RotationYawPitchRollToRef(rotation.y, rotation.x, rotation.z, quaternion);\n        }\n        quaternion.toRotationMatrix(m);\n    }\n}\n/**\n * Represents a group of points in a points cloud system\n *  * PCS internal tool, don't use it manually.\n */\nexport class PointsGroup {\n    /**\n     * Get or set the groupId\n     * @deprecated Please use groupId instead\n     */\n    get groupID() {\n        return this.groupId;\n    }\n    set groupID(groupID) {\n        this.groupId = groupID;\n    }\n    /**\n     * Creates a points group object. This is an internal reference to produce particles for the PCS.\n     * PCS internal tool, don't use it manually.\n     * @internal\n     */\n    constructor(id, posFunction) {\n        this.groupId = id;\n        this._positionFunction = posFunction;\n    }\n}\n//# sourceMappingURL=cloudPoint.js.map","import { FactorGradient, ColorGradient, GradientHelper } from \"../Misc/gradients.js\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { Matrix, TmpVectors } from \"../Maths/math.vector.js\";\nimport { Color4, TmpColors } from \"../Maths/math.color.js\";\nimport { Scalar } from \"../Maths/math.scalar.js\";\nimport { VertexBuffer, Buffer } from \"../Buffers/buffer.js\";\nimport { BaseParticleSystem } from \"./baseParticleSystem.js\";\nimport { ParticleSystem } from \"./particleSystem.js\";\nimport { BoxParticleEmitter } from \"../Particles/EmitterTypes/boxParticleEmitter.js\";\nimport { MaterialHelper } from \"../Materials/materialHelper.js\";\nimport { ImageProcessingConfiguration } from \"../Materials/imageProcessingConfiguration.js\";\nimport { RawTexture } from \"../Materials/Textures/rawTexture.js\";\n\nimport { EngineStore } from \"../Engines/engineStore.js\";\nimport { CustomParticleEmitter } from \"./EmitterTypes/customParticleEmitter.js\";\nimport { ThinEngine } from \"../Engines/thinEngine.js\";\nimport { DrawWrapper } from \"../Materials/drawWrapper.js\";\nimport \"../Shaders/gpuRenderParticles.fragment.js\";\nimport \"../Shaders/gpuRenderParticles.vertex.js\";\nimport { GetClass } from \"../Misc/typeStore.js\";\nimport { addClipPlaneUniforms, bindClipPlane, prepareDefinesForClipPlanes } from \"../Materials/clipPlaneMaterialHelper.js\";\n/**\n * This represents a GPU particle system in Babylon\n * This is the fastest particle system in Babylon as it uses the GPU to update the individual particle data\n * @see https://www.babylonjs-playground.com/#PU4WYI#4\n */\nexport class GPUParticleSystem extends BaseParticleSystem {\n    /**\n     * Gets a boolean indicating if the GPU particles can be rendered on current browser\n     */\n    static get IsSupported() {\n        if (!EngineStore.LastCreatedEngine) {\n            return false;\n        }\n        const caps = EngineStore.LastCreatedEngine.getCaps();\n        return caps.supportTransformFeedbacks || caps.supportComputeShaders;\n    }\n    /**\n     * Gets the maximum number of particles active at the same time.\n     * @returns The max number of active particles.\n     */\n    getCapacity() {\n        return this._capacity;\n    }\n    /**\n     * Gets or set the number of active particles\n     */\n    get activeParticleCount() {\n        return this._activeCount;\n    }\n    set activeParticleCount(value) {\n        this._activeCount = Math.min(value, this._capacity);\n    }\n    /**\n     * Is this system ready to be used/rendered\n     * @returns true if the system is ready\n     */\n    isReady() {\n        if (!this.emitter || (this._imageProcessingConfiguration && !this._imageProcessingConfiguration.isReady()) || !this.particleTexture || !this.particleTexture.isReady()) {\n            return false;\n        }\n        if (this.blendMode !== ParticleSystem.BLENDMODE_MULTIPLYADD) {\n            if (!this._getWrapper(this.blendMode).effect.isReady()) {\n                return false;\n            }\n        }\n        else {\n            if (!this._getWrapper(ParticleSystem.BLENDMODE_MULTIPLY).effect.isReady()) {\n                return false;\n            }\n            if (!this._getWrapper(ParticleSystem.BLENDMODE_ADD).effect.isReady()) {\n                return false;\n            }\n        }\n        if (!this._platform.isUpdateBufferCreated()) {\n            this._recreateUpdateEffect();\n            return false;\n        }\n        return this._platform.isUpdateBufferReady();\n    }\n    /**\n     * Gets if the system has been started. (Note: this will still be true after stop is called)\n     * @returns True if it has been started, otherwise false.\n     */\n    isStarted() {\n        return this._started;\n    }\n    /**\n     * Gets if the system has been stopped. (Note: rendering is still happening but the system is frozen)\n     * @returns True if it has been stopped, otherwise false.\n     */\n    isStopped() {\n        return this._stopped;\n    }\n    /**\n     * Gets a boolean indicating that the system is stopping\n     * @returns true if the system is currently stopping\n     */\n    isStopping() {\n        return false; // Stop is immediate on GPU\n    }\n    /**\n     * Gets the number of particles active at the same time.\n     * @returns The number of active particles.\n     */\n    getActiveCount() {\n        return this._currentActiveCount;\n    }\n    /**\n     * Starts the particle system and begins to emit\n     * @param delay defines the delay in milliseconds before starting the system (this.startDelay by default)\n     */\n    start(delay = this.startDelay) {\n        if (!this.targetStopDuration && this._hasTargetStopDurationDependantGradient()) {\n            throw \"Particle system started with a targetStopDuration dependant gradient (eg. startSizeGradients) but no targetStopDuration set\";\n        }\n        if (delay) {\n            setTimeout(() => {\n                this.start(0);\n            }, delay);\n            return;\n        }\n        this._started = true;\n        this._stopped = false;\n        this._preWarmDone = false;\n        // Animations\n        if (this.beginAnimationOnStart && this.animations && this.animations.length > 0 && this._scene) {\n            this._scene.beginAnimation(this, this.beginAnimationFrom, this.beginAnimationTo, this.beginAnimationLoop);\n        }\n    }\n    /**\n     * Stops the particle system.\n     */\n    stop() {\n        if (this._stopped) {\n            return;\n        }\n        this._stopped = true;\n    }\n    /**\n     * Remove all active particles\n     */\n    reset() {\n        this._releaseBuffers();\n        this._platform.releaseVertexBuffers();\n        this._currentActiveCount = 0;\n        this._targetIndex = 0;\n    }\n    /**\n     * Returns the string \"GPUParticleSystem\"\n     * @returns a string containing the class name\n     */\n    getClassName() {\n        return \"GPUParticleSystem\";\n    }\n    /**\n     * Gets the custom effect used to render the particles\n     * @param blendMode Blend mode for which the effect should be retrieved\n     * @returns The effect\n     */\n    getCustomEffect(blendMode = 0) {\n        var _a, _b;\n        return (_b = (_a = this._customWrappers[blendMode]) === null || _a === void 0 ? void 0 : _a.effect) !== null && _b !== void 0 ? _b : this._customWrappers[0].effect;\n    }\n    _getCustomDrawWrapper(blendMode = 0) {\n        var _a;\n        return (_a = this._customWrappers[blendMode]) !== null && _a !== void 0 ? _a : this._customWrappers[0];\n    }\n    /**\n     * Sets the custom effect used to render the particles\n     * @param effect The effect to set\n     * @param blendMode Blend mode for which the effect should be set\n     */\n    setCustomEffect(effect, blendMode = 0) {\n        this._customWrappers[blendMode] = new DrawWrapper(this._engine);\n        this._customWrappers[blendMode].effect = effect;\n    }\n    /**\n     * Observable that will be called just before the particles are drawn\n     */\n    get onBeforeDrawParticlesObservable() {\n        if (!this._onBeforeDrawParticlesObservable) {\n            this._onBeforeDrawParticlesObservable = new Observable();\n        }\n        return this._onBeforeDrawParticlesObservable;\n    }\n    /**\n     * Gets the name of the particle vertex shader\n     */\n    get vertexShaderName() {\n        return \"gpuRenderParticles\";\n    }\n    /**\n     * Gets the vertex buffers used by the particle system\n     * Should be called after render() has been called for the current frame so that the buffers returned are the ones that have been updated\n     * in the current frame (there's a ping-pong between two sets of buffers - for a given frame, one set is used as the source and the other as the destination)\n     */\n    get vertexBuffers() {\n        // We return the other buffers than those corresponding to this._targetIndex because it is assumed vertexBuffers will be called in the current frame\n        // after render() has been called, meaning that the buffers have already been swapped and this._targetIndex points to the buffers that will be updated\n        // in the next frame (and which are the sources in this frame) and (this._targetIndex ^ 1) points to the buffers that have been updated this frame\n        // (and that will be the source buffers in the next frame)\n        return this._renderVertexBuffers[this._targetIndex ^ 1];\n    }\n    /**\n     * Gets the index buffer used by the particle system (null for GPU particle systems)\n     */\n    get indexBuffer() {\n        return null;\n    }\n    _removeGradientAndTexture(gradient, gradients, texture) {\n        super._removeGradientAndTexture(gradient, gradients, texture);\n        this._releaseBuffers();\n        return this;\n    }\n    /**\n     * Adds a new color gradient\n     * @param gradient defines the gradient to use (between 0 and 1)\n     * @param color1 defines the color to affect to the specified gradient\n     * @returns the current particle system\n     */\n    addColorGradient(gradient, color1) {\n        if (!this._colorGradients) {\n            this._colorGradients = [];\n        }\n        const colorGradient = new ColorGradient(gradient, color1);\n        this._colorGradients.push(colorGradient);\n        this._refreshColorGradient(true);\n        this._releaseBuffers();\n        return this;\n    }\n    _refreshColorGradient(reorder = false) {\n        if (this._colorGradients) {\n            if (reorder) {\n                this._colorGradients.sort((a, b) => {\n                    if (a.gradient < b.gradient) {\n                        return -1;\n                    }\n                    else if (a.gradient > b.gradient) {\n                        return 1;\n                    }\n                    return 0;\n                });\n            }\n            if (this._colorGradientsTexture) {\n                this._colorGradientsTexture.dispose();\n                this._colorGradientsTexture = null;\n            }\n        }\n    }\n    /** Force the system to rebuild all gradients that need to be resync */\n    forceRefreshGradients() {\n        this._refreshColorGradient();\n        this._refreshFactorGradient(this._sizeGradients, \"_sizeGradientsTexture\");\n        this._refreshFactorGradient(this._angularSpeedGradients, \"_angularSpeedGradientsTexture\");\n        this._refreshFactorGradient(this._velocityGradients, \"_velocityGradientsTexture\");\n        this._refreshFactorGradient(this._limitVelocityGradients, \"_limitVelocityGradientsTexture\");\n        this._refreshFactorGradient(this._dragGradients, \"_dragGradientsTexture\");\n        this.reset();\n    }\n    /**\n     * Remove a specific color gradient\n     * @param gradient defines the gradient to remove\n     * @returns the current particle system\n     */\n    removeColorGradient(gradient) {\n        this._removeGradientAndTexture(gradient, this._colorGradients, this._colorGradientsTexture);\n        this._colorGradientsTexture = null;\n        return this;\n    }\n    /**\n     * Resets the draw wrappers cache\n     */\n    resetDrawCache() {\n        var _a;\n        for (const blendMode in this._drawWrappers) {\n            const drawWrapper = this._drawWrappers[blendMode];\n            (_a = drawWrapper.drawContext) === null || _a === void 0 ? void 0 : _a.reset();\n        }\n    }\n    _addFactorGradient(factorGradients, gradient, factor) {\n        const valueGradient = new FactorGradient(gradient, factor);\n        factorGradients.push(valueGradient);\n        this._releaseBuffers();\n    }\n    /**\n     * Adds a new size gradient\n     * @param gradient defines the gradient to use (between 0 and 1)\n     * @param factor defines the size factor to affect to the specified gradient\n     * @returns the current particle system\n     */\n    addSizeGradient(gradient, factor) {\n        if (!this._sizeGradients) {\n            this._sizeGradients = [];\n        }\n        this._addFactorGradient(this._sizeGradients, gradient, factor);\n        this._refreshFactorGradient(this._sizeGradients, \"_sizeGradientsTexture\", true);\n        this._releaseBuffers();\n        return this;\n    }\n    /**\n     * Remove a specific size gradient\n     * @param gradient defines the gradient to remove\n     * @returns the current particle system\n     */\n    removeSizeGradient(gradient) {\n        this._removeGradientAndTexture(gradient, this._sizeGradients, this._sizeGradientsTexture);\n        this._sizeGradientsTexture = null;\n        return this;\n    }\n    _refreshFactorGradient(factorGradients, textureName, reorder = false) {\n        if (!factorGradients) {\n            return;\n        }\n        if (reorder) {\n            factorGradients.sort((a, b) => {\n                if (a.gradient < b.gradient) {\n                    return -1;\n                }\n                else if (a.gradient > b.gradient) {\n                    return 1;\n                }\n                return 0;\n            });\n        }\n        const that = this;\n        if (that[textureName]) {\n            that[textureName].dispose();\n            that[textureName] = null;\n        }\n    }\n    /**\n     * Adds a new angular speed gradient\n     * @param gradient defines the gradient to use (between 0 and 1)\n     * @param factor defines the angular speed to affect to the specified gradient\n     * @returns the current particle system\n     */\n    addAngularSpeedGradient(gradient, factor) {\n        if (!this._angularSpeedGradients) {\n            this._angularSpeedGradients = [];\n        }\n        this._addFactorGradient(this._angularSpeedGradients, gradient, factor);\n        this._refreshFactorGradient(this._angularSpeedGradients, \"_angularSpeedGradientsTexture\", true);\n        this._releaseBuffers();\n        return this;\n    }\n    /**\n     * Remove a specific angular speed gradient\n     * @param gradient defines the gradient to remove\n     * @returns the current particle system\n     */\n    removeAngularSpeedGradient(gradient) {\n        this._removeGradientAndTexture(gradient, this._angularSpeedGradients, this._angularSpeedGradientsTexture);\n        this._angularSpeedGradientsTexture = null;\n        return this;\n    }\n    /**\n     * Adds a new velocity gradient\n     * @param gradient defines the gradient to use (between 0 and 1)\n     * @param factor defines the velocity to affect to the specified gradient\n     * @returns the current particle system\n     */\n    addVelocityGradient(gradient, factor) {\n        if (!this._velocityGradients) {\n            this._velocityGradients = [];\n        }\n        this._addFactorGradient(this._velocityGradients, gradient, factor);\n        this._refreshFactorGradient(this._velocityGradients, \"_velocityGradientsTexture\", true);\n        this._releaseBuffers();\n        return this;\n    }\n    /**\n     * Remove a specific velocity gradient\n     * @param gradient defines the gradient to remove\n     * @returns the current particle system\n     */\n    removeVelocityGradient(gradient) {\n        this._removeGradientAndTexture(gradient, this._velocityGradients, this._velocityGradientsTexture);\n        this._velocityGradientsTexture = null;\n        return this;\n    }\n    /**\n     * Adds a new limit velocity gradient\n     * @param gradient defines the gradient to use (between 0 and 1)\n     * @param factor defines the limit velocity value to affect to the specified gradient\n     * @returns the current particle system\n     */\n    addLimitVelocityGradient(gradient, factor) {\n        if (!this._limitVelocityGradients) {\n            this._limitVelocityGradients = [];\n        }\n        this._addFactorGradient(this._limitVelocityGradients, gradient, factor);\n        this._refreshFactorGradient(this._limitVelocityGradients, \"_limitVelocityGradientsTexture\", true);\n        this._releaseBuffers();\n        return this;\n    }\n    /**\n     * Remove a specific limit velocity gradient\n     * @param gradient defines the gradient to remove\n     * @returns the current particle system\n     */\n    removeLimitVelocityGradient(gradient) {\n        this._removeGradientAndTexture(gradient, this._limitVelocityGradients, this._limitVelocityGradientsTexture);\n        this._limitVelocityGradientsTexture = null;\n        return this;\n    }\n    /**\n     * Adds a new drag gradient\n     * @param gradient defines the gradient to use (between 0 and 1)\n     * @param factor defines the drag value to affect to the specified gradient\n     * @returns the current particle system\n     */\n    addDragGradient(gradient, factor) {\n        if (!this._dragGradients) {\n            this._dragGradients = [];\n        }\n        this._addFactorGradient(this._dragGradients, gradient, factor);\n        this._refreshFactorGradient(this._dragGradients, \"_dragGradientsTexture\", true);\n        this._releaseBuffers();\n        return this;\n    }\n    /**\n     * Remove a specific drag gradient\n     * @param gradient defines the gradient to remove\n     * @returns the current particle system\n     */\n    removeDragGradient(gradient) {\n        this._removeGradientAndTexture(gradient, this._dragGradients, this._dragGradientsTexture);\n        this._dragGradientsTexture = null;\n        return this;\n    }\n    /**\n     * Not supported by GPUParticleSystem\n     * @returns the current particle system\n     */\n    addEmitRateGradient() {\n        // Do nothing as emit rate is not supported by GPUParticleSystem\n        return this;\n    }\n    /**\n     * Not supported by GPUParticleSystem\n     * @returns the current particle system\n     */\n    removeEmitRateGradient() {\n        // Do nothing as emit rate is not supported by GPUParticleSystem\n        return this;\n    }\n    /**\n     * Not supported by GPUParticleSystem\n     * @returns the current particle system\n     */\n    addStartSizeGradient() {\n        // Do nothing as start size is not supported by GPUParticleSystem\n        return this;\n    }\n    /**\n     * Not supported by GPUParticleSystem\n     * @returns the current particle system\n     */\n    removeStartSizeGradient() {\n        // Do nothing as start size is not supported by GPUParticleSystem\n        return this;\n    }\n    /**\n     * Not supported by GPUParticleSystem\n     * @returns the current particle system\n     */\n    addColorRemapGradient() {\n        // Do nothing as start size is not supported by GPUParticleSystem\n        return this;\n    }\n    /**\n     * Not supported by GPUParticleSystem\n     * @returns the current particle system\n     */\n    removeColorRemapGradient() {\n        // Do nothing as start size is not supported by GPUParticleSystem\n        return this;\n    }\n    /**\n     * Not supported by GPUParticleSystem\n     * @returns the current particle system\n     */\n    addAlphaRemapGradient() {\n        // Do nothing as start size is not supported by GPUParticleSystem\n        return this;\n    }\n    /**\n     * Not supported by GPUParticleSystem\n     * @returns the current particle system\n     */\n    removeAlphaRemapGradient() {\n        // Do nothing as start size is not supported by GPUParticleSystem\n        return this;\n    }\n    /**\n     * Not supported by GPUParticleSystem\n     * @returns the current particle system\n     */\n    addRampGradient() {\n        //Not supported by GPUParticleSystem\n        return this;\n    }\n    /**\n     * Not supported by GPUParticleSystem\n     * @returns the current particle system\n     */\n    removeRampGradient() {\n        //Not supported by GPUParticleSystem\n        return this;\n    }\n    /**\n     * Not supported by GPUParticleSystem\n     * @returns the list of ramp gradients\n     */\n    getRampGradients() {\n        return null;\n    }\n    /**\n     * Not supported by GPUParticleSystem\n     * Gets or sets a boolean indicating that ramp gradients must be used\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/particles/particle_system/particle_system_intro#ramp-gradients\n     */\n    get useRampGradients() {\n        //Not supported by GPUParticleSystem\n        return false;\n    }\n    set useRampGradients(value) {\n        //Not supported by GPUParticleSystem\n    }\n    /**\n     * Not supported by GPUParticleSystem\n     * @returns the current particle system\n     */\n    addLifeTimeGradient() {\n        //Not supported by GPUParticleSystem\n        return this;\n    }\n    /**\n     * Not supported by GPUParticleSystem\n     * @returns the current particle system\n     */\n    removeLifeTimeGradient() {\n        //Not supported by GPUParticleSystem\n        return this;\n    }\n    /**\n     * Instantiates a GPU particle system.\n     * Particles are often small sprites used to simulate hard-to-reproduce phenomena like fire, smoke, water, or abstract visual effects like magic glitter and faery dust.\n     * @param name The name of the particle system\n     * @param options The options used to create the system\n     * @param sceneOrEngine The scene the particle system belongs to or the engine to use if no scene\n     * @param customEffect a custom effect used to change the way particles are rendered by default\n     * @param isAnimationSheetEnabled Must be true if using a spritesheet to animate the particles texture\n     */\n    constructor(name, options, sceneOrEngine, customEffect = null, isAnimationSheetEnabled = false) {\n        super(name);\n        /**\n         * The layer mask we are rendering the particles through.\n         */\n        this.layerMask = 0x0fffffff;\n        this._accumulatedCount = 0;\n        this._renderVertexBuffers = [];\n        this._targetIndex = 0;\n        this._currentRenderId = -1;\n        this._currentRenderingCameraUniqueId = -1;\n        this._started = false;\n        this._stopped = false;\n        this._timeDelta = 0;\n        /** Indicates that the update of particles is done in the animate function (and not in render). Default: false */\n        this.updateInAnimate = false;\n        this._actualFrame = 0;\n        this._rawTextureWidth = 256;\n        /**\n         * An event triggered when the system is disposed.\n         */\n        this.onDisposeObservable = new Observable();\n        /**\n         * An event triggered when the system is stopped\n         */\n        this.onStoppedObservable = new Observable();\n        /**\n         * Forces the particle to write their depth information to the depth buffer. This can help preventing other draw calls\n         * to override the particles.\n         */\n        this.forceDepthWrite = false;\n        this._preWarmDone = false;\n        /**\n         * Specifies if the particles are updated in emitter local space or world space.\n         */\n        this.isLocal = false;\n        /** Indicates that the particle system is GPU based */\n        this.isGPU = true;\n        /** @internal */\n        this._onBeforeDrawParticlesObservable = null;\n        if (!sceneOrEngine || sceneOrEngine.getClassName() === \"Scene\") {\n            this._scene = sceneOrEngine || EngineStore.LastCreatedScene;\n            this._engine = this._scene.getEngine();\n            this.uniqueId = this._scene.getUniqueId();\n            this._scene.particleSystems.push(this);\n        }\n        else {\n            this._engine = sceneOrEngine;\n            this.defaultProjectionMatrix = Matrix.PerspectiveFovLH(0.8, 1, 0.1, 100, this._engine.isNDCHalfZRange);\n        }\n        if (this._engine.getCaps().supportComputeShaders) {\n            if (!GetClass(\"BABYLON.ComputeShaderParticleSystem\")) {\n                throw new Error(\"The ComputeShaderParticleSystem class is not available! Make sure you have imported it.\");\n            }\n            this._platform = new (GetClass(\"BABYLON.ComputeShaderParticleSystem\"))(this, this._engine);\n        }\n        else {\n            if (!GetClass(\"BABYLON.WebGL2ParticleSystem\")) {\n                throw new Error(\"The WebGL2ParticleSystem class is not available! Make sure you have imported it.\");\n            }\n            this._platform = new (GetClass(\"BABYLON.WebGL2ParticleSystem\"))(this, this._engine);\n        }\n        this._customWrappers = { 0: new DrawWrapper(this._engine) };\n        this._customWrappers[0].effect = customEffect;\n        this._drawWrappers = { 0: new DrawWrapper(this._engine) };\n        if (this._drawWrappers[0].drawContext) {\n            this._drawWrappers[0].drawContext.useInstancing = true;\n        }\n        // Setup the default processing configuration to the scene.\n        this._attachImageProcessingConfiguration(null);\n        options = options !== null && options !== void 0 ? options : {};\n        if (!options.randomTextureSize) {\n            delete options.randomTextureSize;\n        }\n        const fullOptions = {\n            capacity: 50000,\n            randomTextureSize: this._engine.getCaps().maxTextureSize,\n            ...options,\n        };\n        const optionsAsNumber = options;\n        if (isFinite(optionsAsNumber)) {\n            fullOptions.capacity = optionsAsNumber;\n        }\n        this._capacity = fullOptions.capacity;\n        this._activeCount = fullOptions.capacity;\n        this._currentActiveCount = 0;\n        this._isAnimationSheetEnabled = isAnimationSheetEnabled;\n        this.particleEmitterType = new BoxParticleEmitter();\n        // Random data\n        const maxTextureSize = Math.min(this._engine.getCaps().maxTextureSize, fullOptions.randomTextureSize);\n        let d = [];\n        for (let i = 0; i < maxTextureSize; ++i) {\n            d.push(Math.random());\n            d.push(Math.random());\n            d.push(Math.random());\n            d.push(Math.random());\n        }\n        this._randomTexture = new RawTexture(new Float32Array(d), maxTextureSize, 1, 5, sceneOrEngine, false, false, 1, 1);\n        this._randomTexture.name = \"GPUParticleSystem_random1\";\n        this._randomTexture.wrapU = 1;\n        this._randomTexture.wrapV = 1;\n        d = [];\n        for (let i = 0; i < maxTextureSize; ++i) {\n            d.push(Math.random());\n            d.push(Math.random());\n            d.push(Math.random());\n            d.push(Math.random());\n        }\n        this._randomTexture2 = new RawTexture(new Float32Array(d), maxTextureSize, 1, 5, sceneOrEngine, false, false, 1, 1);\n        this._randomTexture2.name = \"GPUParticleSystem_random2\";\n        this._randomTexture2.wrapU = 1;\n        this._randomTexture2.wrapV = 1;\n        this._randomTextureSize = maxTextureSize;\n    }\n    _reset() {\n        this._releaseBuffers();\n    }\n    _createVertexBuffers(updateBuffer, renderBuffer, spriteSource) {\n        const renderVertexBuffers = {};\n        renderVertexBuffers[\"position\"] = renderBuffer.createVertexBuffer(\"position\", 0, 3, this._attributesStrideSize, true);\n        let offset = 3;\n        renderVertexBuffers[\"age\"] = renderBuffer.createVertexBuffer(\"age\", offset, 1, this._attributesStrideSize, true);\n        offset += 1;\n        renderVertexBuffers[\"size\"] = renderBuffer.createVertexBuffer(\"size\", offset, 3, this._attributesStrideSize, true);\n        offset += 3;\n        renderVertexBuffers[\"life\"] = renderBuffer.createVertexBuffer(\"life\", offset, 1, this._attributesStrideSize, true);\n        offset += 1;\n        offset += 4; // seed\n        if (this.billboardMode === ParticleSystem.BILLBOARDMODE_STRETCHED) {\n            renderVertexBuffers[\"direction\"] = renderBuffer.createVertexBuffer(\"direction\", offset, 3, this._attributesStrideSize, true);\n        }\n        offset += 3; // direction\n        if (this._platform.alignDataInBuffer) {\n            offset += 1;\n        }\n        if (this.particleEmitterType instanceof CustomParticleEmitter) {\n            offset += 3;\n            if (this._platform.alignDataInBuffer) {\n                offset += 1;\n            }\n        }\n        if (!this._colorGradientsTexture) {\n            renderVertexBuffers[\"color\"] = renderBuffer.createVertexBuffer(\"color\", offset, 4, this._attributesStrideSize, true);\n            offset += 4;\n        }\n        if (!this._isBillboardBased) {\n            renderVertexBuffers[\"initialDirection\"] = renderBuffer.createVertexBuffer(\"initialDirection\", offset, 3, this._attributesStrideSize, true);\n            offset += 3;\n            if (this._platform.alignDataInBuffer) {\n                offset += 1;\n            }\n        }\n        if (this.noiseTexture) {\n            renderVertexBuffers[\"noiseCoordinates1\"] = renderBuffer.createVertexBuffer(\"noiseCoordinates1\", offset, 3, this._attributesStrideSize, true);\n            offset += 3;\n            if (this._platform.alignDataInBuffer) {\n                offset += 1;\n            }\n            renderVertexBuffers[\"noiseCoordinates2\"] = renderBuffer.createVertexBuffer(\"noiseCoordinates2\", offset, 3, this._attributesStrideSize, true);\n            offset += 3;\n            if (this._platform.alignDataInBuffer) {\n                offset += 1;\n            }\n        }\n        renderVertexBuffers[\"angle\"] = renderBuffer.createVertexBuffer(\"angle\", offset, 1, this._attributesStrideSize, true);\n        if (this._angularSpeedGradientsTexture) {\n            offset++;\n        }\n        else {\n            offset += 2;\n        }\n        if (this._isAnimationSheetEnabled) {\n            renderVertexBuffers[\"cellIndex\"] = renderBuffer.createVertexBuffer(\"cellIndex\", offset, 1, this._attributesStrideSize, true);\n            offset += 1;\n            if (this.spriteRandomStartCell) {\n                renderVertexBuffers[\"cellStartOffset\"] = renderBuffer.createVertexBuffer(\"cellStartOffset\", offset, 1, this._attributesStrideSize, true);\n                offset += 1;\n            }\n        }\n        renderVertexBuffers[\"offset\"] = spriteSource.createVertexBuffer(\"offset\", 0, 2);\n        renderVertexBuffers[\"uv\"] = spriteSource.createVertexBuffer(\"uv\", 2, 2);\n        this._renderVertexBuffers.push(renderVertexBuffers);\n        this._platform.createVertexBuffers(updateBuffer, renderVertexBuffers);\n        this.resetDrawCache();\n    }\n    _initialize(force = false) {\n        if (this._buffer0 && !force) {\n            return;\n        }\n        const engine = this._engine;\n        const data = new Array();\n        this._attributesStrideSize = 21;\n        this._targetIndex = 0;\n        if (this._platform.alignDataInBuffer) {\n            this._attributesStrideSize += 1;\n        }\n        if (this.particleEmitterType instanceof CustomParticleEmitter) {\n            this._attributesStrideSize += 3;\n            if (this._platform.alignDataInBuffer) {\n                this._attributesStrideSize += 1;\n            }\n        }\n        if (!this.isBillboardBased) {\n            this._attributesStrideSize += 3;\n            if (this._platform.alignDataInBuffer) {\n                this._attributesStrideSize += 1;\n            }\n        }\n        if (this._colorGradientsTexture) {\n            this._attributesStrideSize -= 4;\n        }\n        if (this._angularSpeedGradientsTexture) {\n            this._attributesStrideSize -= 1;\n        }\n        if (this._isAnimationSheetEnabled) {\n            this._attributesStrideSize += 1;\n            if (this.spriteRandomStartCell) {\n                this._attributesStrideSize += 1;\n            }\n        }\n        if (this.noiseTexture) {\n            this._attributesStrideSize += 6;\n            if (this._platform.alignDataInBuffer) {\n                this._attributesStrideSize += 2;\n            }\n        }\n        if (this._platform.alignDataInBuffer) {\n            this._attributesStrideSize += 3 - ((this._attributesStrideSize + 3) & 3); // round to multiple of 4\n        }\n        const usingCustomEmitter = this.particleEmitterType instanceof CustomParticleEmitter;\n        const tmpVector = TmpVectors.Vector3[0];\n        let offset = 0;\n        for (let particleIndex = 0; particleIndex < this._capacity; particleIndex++) {\n            // position\n            data.push(0.0);\n            data.push(0.0);\n            data.push(0.0);\n            // Age\n            data.push(0.0); // create the particle as a dead one to create a new one at start\n            // Size\n            data.push(0.0);\n            data.push(0.0);\n            data.push(0.0);\n            // life\n            data.push(0.0);\n            // Seed\n            data.push(Math.random());\n            data.push(Math.random());\n            data.push(Math.random());\n            data.push(Math.random());\n            // direction\n            if (usingCustomEmitter) {\n                this.particleEmitterType.particleDestinationGenerator(particleIndex, null, tmpVector);\n                data.push(tmpVector.x);\n                data.push(tmpVector.y);\n                data.push(tmpVector.z);\n            }\n            else {\n                data.push(0.0);\n                data.push(0.0);\n                data.push(0.0);\n            }\n            if (this._platform.alignDataInBuffer) {\n                data.push(0.0); // dummy0\n            }\n            offset += 16; // position, age, size, life, seed, direction, dummy0\n            if (usingCustomEmitter) {\n                this.particleEmitterType.particlePositionGenerator(particleIndex, null, tmpVector);\n                data.push(tmpVector.x);\n                data.push(tmpVector.y);\n                data.push(tmpVector.z);\n                if (this._platform.alignDataInBuffer) {\n                    data.push(0.0); // dummy1\n                }\n                offset += 4;\n            }\n            if (!this._colorGradientsTexture) {\n                // color\n                data.push(0.0);\n                data.push(0.0);\n                data.push(0.0);\n                data.push(0.0);\n                offset += 4;\n            }\n            if (!this.isBillboardBased) {\n                // initialDirection\n                data.push(0.0);\n                data.push(0.0);\n                data.push(0.0);\n                if (this._platform.alignDataInBuffer) {\n                    data.push(0.0); // dummy2\n                }\n                offset += 4;\n            }\n            if (this.noiseTexture) {\n                // Random coordinates for reading into noise texture\n                data.push(Math.random());\n                data.push(Math.random());\n                data.push(Math.random());\n                if (this._platform.alignDataInBuffer) {\n                    data.push(0.0); // dummy3\n                }\n                data.push(Math.random());\n                data.push(Math.random());\n                data.push(Math.random());\n                if (this._platform.alignDataInBuffer) {\n                    data.push(0.0); // dummy4\n                }\n                offset += 8;\n            }\n            // angle\n            data.push(0.0);\n            offset += 1;\n            if (!this._angularSpeedGradientsTexture) {\n                data.push(0.0);\n                offset += 1;\n            }\n            if (this._isAnimationSheetEnabled) {\n                data.push(0.0);\n                offset += 1;\n                if (this.spriteRandomStartCell) {\n                    data.push(0.0);\n                    offset += 1;\n                }\n            }\n            if (this._platform.alignDataInBuffer) {\n                let numDummies = 3 - ((offset + 3) & 3);\n                offset += numDummies;\n                while (numDummies-- > 0) {\n                    data.push(0.0);\n                }\n            }\n        }\n        // Sprite data\n        const spriteData = new Float32Array([0.5, 0.5, 1, 1, -0.5, 0.5, 0, 1, 0.5, -0.5, 1, 0, -0.5, -0.5, 0, 0]);\n        const bufferData1 = this._platform.createParticleBuffer(data);\n        const bufferData2 = this._platform.createParticleBuffer(data);\n        // Buffers\n        this._buffer0 = new Buffer(engine, bufferData1, false, this._attributesStrideSize);\n        this._buffer1 = new Buffer(engine, bufferData2, false, this._attributesStrideSize);\n        this._spriteBuffer = new Buffer(engine, spriteData, false, 4);\n        // Update & Render vertex buffers\n        this._renderVertexBuffers = [];\n        this._createVertexBuffers(this._buffer0, this._buffer1, this._spriteBuffer);\n        this._createVertexBuffers(this._buffer1, this._buffer0, this._spriteBuffer);\n        // Links\n        this._sourceBuffer = this._buffer0;\n        this._targetBuffer = this._buffer1;\n    }\n    /** @internal */\n    _recreateUpdateEffect() {\n        let defines = this.particleEmitterType ? this.particleEmitterType.getEffectDefines() : \"\";\n        if (this._isBillboardBased) {\n            defines += \"\\n#define BILLBOARD\";\n        }\n        if (this._colorGradientsTexture) {\n            defines += \"\\n#define COLORGRADIENTS\";\n        }\n        if (this._sizeGradientsTexture) {\n            defines += \"\\n#define SIZEGRADIENTS\";\n        }\n        if (this._angularSpeedGradientsTexture) {\n            defines += \"\\n#define ANGULARSPEEDGRADIENTS\";\n        }\n        if (this._velocityGradientsTexture) {\n            defines += \"\\n#define VELOCITYGRADIENTS\";\n        }\n        if (this._limitVelocityGradientsTexture) {\n            defines += \"\\n#define LIMITVELOCITYGRADIENTS\";\n        }\n        if (this._dragGradientsTexture) {\n            defines += \"\\n#define DRAGGRADIENTS\";\n        }\n        if (this.isAnimationSheetEnabled) {\n            defines += \"\\n#define ANIMATESHEET\";\n            if (this.spriteRandomStartCell) {\n                defines += \"\\n#define ANIMATESHEETRANDOMSTART\";\n            }\n        }\n        if (this.noiseTexture) {\n            defines += \"\\n#define NOISE\";\n        }\n        if (this.isLocal) {\n            defines += \"\\n#define LOCAL\";\n        }\n        if (this._platform.isUpdateBufferCreated() && this._cachedUpdateDefines === defines) {\n            return true;\n        }\n        this._cachedUpdateDefines = defines;\n        this._updateBuffer = this._platform.createUpdateBuffer(defines);\n        return this._platform.isUpdateBufferReady();\n    }\n    /**\n     * @internal\n     */\n    _getWrapper(blendMode) {\n        const customWrapper = this._getCustomDrawWrapper(blendMode);\n        if (customWrapper === null || customWrapper === void 0 ? void 0 : customWrapper.effect) {\n            return customWrapper;\n        }\n        const defines = [];\n        this.fillDefines(defines, blendMode);\n        // Effect\n        let drawWrapper = this._drawWrappers[blendMode];\n        if (!drawWrapper) {\n            drawWrapper = new DrawWrapper(this._engine);\n            if (drawWrapper.drawContext) {\n                drawWrapper.drawContext.useInstancing = true;\n            }\n            this._drawWrappers[blendMode] = drawWrapper;\n        }\n        const join = defines.join(\"\\n\");\n        if (drawWrapper.defines !== join) {\n            const attributes = [];\n            const uniforms = [];\n            const samplers = [];\n            this.fillUniformsAttributesAndSamplerNames(uniforms, attributes, samplers);\n            drawWrapper.setEffect(this._engine.createEffect(\"gpuRenderParticles\", attributes, uniforms, samplers, join), join);\n        }\n        return drawWrapper;\n    }\n    /**\n     * @internal\n     */\n    static _GetAttributeNamesOrOptions(hasColorGradients = false, isAnimationSheetEnabled = false, isBillboardBased = false, isBillboardStretched = false) {\n        const attributeNamesOrOptions = [VertexBuffer.PositionKind, \"age\", \"life\", \"size\", \"angle\"];\n        if (!hasColorGradients) {\n            attributeNamesOrOptions.push(VertexBuffer.ColorKind);\n        }\n        if (isAnimationSheetEnabled) {\n            attributeNamesOrOptions.push(\"cellIndex\");\n        }\n        if (!isBillboardBased) {\n            attributeNamesOrOptions.push(\"initialDirection\");\n        }\n        if (!isBillboardStretched) {\n            attributeNamesOrOptions.push(\"direction\");\n        }\n        attributeNamesOrOptions.push(\"offset\", VertexBuffer.UVKind);\n        return attributeNamesOrOptions;\n    }\n    /**\n     * @internal\n     */\n    static _GetEffectCreationOptions(isAnimationSheetEnabled = false, useLogarithmicDepth = false) {\n        const effectCreationOption = [\"emitterWM\", \"worldOffset\", \"view\", \"projection\", \"colorDead\", \"invView\", \"translationPivot\", \"eyePosition\"];\n        addClipPlaneUniforms(effectCreationOption);\n        if (isAnimationSheetEnabled) {\n            effectCreationOption.push(\"sheetInfos\");\n        }\n        if (useLogarithmicDepth) {\n            effectCreationOption.push(\"logarithmicDepthConstant\");\n        }\n        return effectCreationOption;\n    }\n    /**\n     * Fill the defines array according to the current settings of the particle system\n     * @param defines Array to be updated\n     * @param blendMode blend mode to take into account when updating the array\n     */\n    fillDefines(defines, blendMode = 0) {\n        if (this._scene) {\n            prepareDefinesForClipPlanes(this, this._scene, defines);\n        }\n        if (blendMode === ParticleSystem.BLENDMODE_MULTIPLY) {\n            defines.push(\"#define BLENDMULTIPLYMODE\");\n        }\n        if (this.isLocal) {\n            defines.push(\"#define LOCAL\");\n        }\n        if (this.useLogarithmicDepth) {\n            defines.push(\"#define LOGARITHMICDEPTH\");\n        }\n        if (this._isBillboardBased) {\n            defines.push(\"#define BILLBOARD\");\n            switch (this.billboardMode) {\n                case ParticleSystem.BILLBOARDMODE_Y:\n                    defines.push(\"#define BILLBOARDY\");\n                    break;\n                case ParticleSystem.BILLBOARDMODE_STRETCHED:\n                    defines.push(\"#define BILLBOARDSTRETCHED\");\n                    break;\n                case ParticleSystem.BILLBOARDMODE_ALL:\n                    defines.push(\"#define BILLBOARDMODE_ALL\");\n                    break;\n                default:\n                    break;\n            }\n        }\n        if (this._colorGradientsTexture) {\n            defines.push(\"#define COLORGRADIENTS\");\n        }\n        if (this.isAnimationSheetEnabled) {\n            defines.push(\"#define ANIMATESHEET\");\n        }\n        if (this._imageProcessingConfiguration) {\n            this._imageProcessingConfiguration.prepareDefines(this._imageProcessingConfigurationDefines);\n            defines.push(\"\" + this._imageProcessingConfigurationDefines.toString());\n        }\n    }\n    /**\n     * Fill the uniforms, attributes and samplers arrays according to the current settings of the particle system\n     * @param uniforms Uniforms array to fill\n     * @param attributes Attributes array to fill\n     * @param samplers Samplers array to fill\n     */\n    fillUniformsAttributesAndSamplerNames(uniforms, attributes, samplers) {\n        attributes.push(...GPUParticleSystem._GetAttributeNamesOrOptions(!!this._colorGradientsTexture, this._isAnimationSheetEnabled, this._isBillboardBased, this._isBillboardBased && this.billboardMode === ParticleSystem.BILLBOARDMODE_STRETCHED));\n        uniforms.push(...GPUParticleSystem._GetEffectCreationOptions(this._isAnimationSheetEnabled, this.useLogarithmicDepth));\n        samplers.push(\"diffuseSampler\", \"colorGradientSampler\");\n        if (this._imageProcessingConfiguration) {\n            ImageProcessingConfiguration.PrepareUniforms(uniforms, this._imageProcessingConfigurationDefines);\n            ImageProcessingConfiguration.PrepareSamplers(samplers, this._imageProcessingConfigurationDefines);\n        }\n    }\n    /**\n     * Animates the particle system for the current frame by emitting new particles and or animating the living ones.\n     * @param preWarm defines if we are in the pre-warmimg phase\n     */\n    animate(preWarm = false) {\n        var _a;\n        this._timeDelta = this.updateSpeed * (preWarm ? this.preWarmStepOffset : ((_a = this._scene) === null || _a === void 0 ? void 0 : _a.getAnimationRatio()) || 1);\n        this._actualFrame += this._timeDelta;\n        if (!this._stopped) {\n            if (this.targetStopDuration && this._actualFrame >= this.targetStopDuration) {\n                this.stop();\n            }\n        }\n        if (this.updateInAnimate) {\n            this._update();\n        }\n    }\n    _createFactorGradientTexture(factorGradients, textureName) {\n        const texture = this[textureName];\n        if (!factorGradients || !factorGradients.length || texture) {\n            return;\n        }\n        const data = new Float32Array(this._rawTextureWidth);\n        for (let x = 0; x < this._rawTextureWidth; x++) {\n            const ratio = x / this._rawTextureWidth;\n            GradientHelper.GetCurrentGradient(ratio, factorGradients, (currentGradient, nextGradient, scale) => {\n                data[x] = Scalar.Lerp(currentGradient.factor1, nextGradient.factor1, scale);\n            });\n        }\n        this[textureName] = RawTexture.CreateRTexture(data, this._rawTextureWidth, 1, this._scene || this._engine, false, false, 1);\n    }\n    _createSizeGradientTexture() {\n        this._createFactorGradientTexture(this._sizeGradients, \"_sizeGradientsTexture\");\n    }\n    _createAngularSpeedGradientTexture() {\n        this._createFactorGradientTexture(this._angularSpeedGradients, \"_angularSpeedGradientsTexture\");\n    }\n    _createVelocityGradientTexture() {\n        this._createFactorGradientTexture(this._velocityGradients, \"_velocityGradientsTexture\");\n    }\n    _createLimitVelocityGradientTexture() {\n        this._createFactorGradientTexture(this._limitVelocityGradients, \"_limitVelocityGradientsTexture\");\n    }\n    _createDragGradientTexture() {\n        this._createFactorGradientTexture(this._dragGradients, \"_dragGradientsTexture\");\n    }\n    _createColorGradientTexture() {\n        if (!this._colorGradients || !this._colorGradients.length || this._colorGradientsTexture) {\n            return;\n        }\n        const data = new Uint8Array(this._rawTextureWidth * 4);\n        const tmpColor = TmpColors.Color4[0];\n        for (let x = 0; x < this._rawTextureWidth; x++) {\n            const ratio = x / this._rawTextureWidth;\n            GradientHelper.GetCurrentGradient(ratio, this._colorGradients, (currentGradient, nextGradient, scale) => {\n                Color4.LerpToRef(currentGradient.color1, nextGradient.color1, scale, tmpColor);\n                data[x * 4] = tmpColor.r * 255;\n                data[x * 4 + 1] = tmpColor.g * 255;\n                data[x * 4 + 2] = tmpColor.b * 255;\n                data[x * 4 + 3] = tmpColor.a * 255;\n            });\n        }\n        this._colorGradientsTexture = RawTexture.CreateRGBATexture(data, this._rawTextureWidth, 1, this._scene, false, false, 1);\n    }\n    _render(blendMode, emitterWM) {\n        var _a, _b;\n        // Enable render effect\n        const drawWrapper = this._getWrapper(blendMode);\n        const effect = drawWrapper.effect;\n        this._engine.enableEffect(drawWrapper);\n        const viewMatrix = ((_a = this._scene) === null || _a === void 0 ? void 0 : _a.getViewMatrix()) || Matrix.IdentityReadOnly;\n        effect.setMatrix(\"view\", viewMatrix);\n        effect.setMatrix(\"projection\", (_b = this.defaultProjectionMatrix) !== null && _b !== void 0 ? _b : this._scene.getProjectionMatrix());\n        effect.setTexture(\"diffuseSampler\", this.particleTexture);\n        effect.setVector2(\"translationPivot\", this.translationPivot);\n        effect.setVector3(\"worldOffset\", this.worldOffset);\n        if (this.isLocal) {\n            effect.setMatrix(\"emitterWM\", emitterWM);\n        }\n        if (this._colorGradientsTexture) {\n            effect.setTexture(\"colorGradientSampler\", this._colorGradientsTexture);\n        }\n        else {\n            effect.setDirectColor4(\"colorDead\", this.colorDead);\n        }\n        if (this._isAnimationSheetEnabled && this.particleTexture) {\n            const baseSize = this.particleTexture.getBaseSize();\n            effect.setFloat3(\"sheetInfos\", this.spriteCellWidth / baseSize.width, this.spriteCellHeight / baseSize.height, baseSize.width / this.spriteCellWidth);\n        }\n        if (this._isBillboardBased && this._scene) {\n            const camera = this._scene.activeCamera;\n            effect.setVector3(\"eyePosition\", camera.globalPosition);\n        }\n        const defines = effect.defines;\n        if (this._scene) {\n            bindClipPlane(effect, this, this._scene);\n        }\n        if (defines.indexOf(\"#define BILLBOARDMODE_ALL\") >= 0) {\n            const invView = viewMatrix.clone();\n            invView.invert();\n            effect.setMatrix(\"invView\", invView);\n        }\n        // Log. depth\n        if (this.useLogarithmicDepth && this._scene) {\n            MaterialHelper.BindLogDepth(defines, effect, this._scene);\n        }\n        // image processing\n        if (this._imageProcessingConfiguration && !this._imageProcessingConfiguration.applyByPostProcess) {\n            this._imageProcessingConfiguration.bind(effect);\n        }\n        // Draw order\n        switch (blendMode) {\n            case ParticleSystem.BLENDMODE_ADD:\n                this._engine.setAlphaMode(1);\n                break;\n            case ParticleSystem.BLENDMODE_ONEONE:\n                this._engine.setAlphaMode(6);\n                break;\n            case ParticleSystem.BLENDMODE_STANDARD:\n                this._engine.setAlphaMode(2);\n                break;\n            case ParticleSystem.BLENDMODE_MULTIPLY:\n                this._engine.setAlphaMode(4);\n                break;\n        }\n        // Bind source VAO\n        this._platform.bindDrawBuffers(this._targetIndex, effect);\n        if (this._onBeforeDrawParticlesObservable) {\n            this._onBeforeDrawParticlesObservable.notifyObservers(effect);\n        }\n        // Render\n        this._engine.drawArraysType(7, 0, 4, this._currentActiveCount);\n        this._engine.setAlphaMode(0);\n        return this._currentActiveCount;\n    }\n    /** @internal */\n    _update(emitterWM) {\n        if (!this.emitter) {\n            return;\n        }\n        if (!this._recreateUpdateEffect()) {\n            return;\n        }\n        if (this.emitter.position) {\n            const emitterMesh = this.emitter;\n            emitterWM = emitterMesh.getWorldMatrix();\n        }\n        else {\n            const emitterPosition = this.emitter;\n            emitterWM = TmpVectors.Matrix[0];\n            Matrix.TranslationToRef(emitterPosition.x, emitterPosition.y, emitterPosition.z, emitterWM);\n        }\n        this._platform.preUpdateParticleBuffer();\n        this._updateBuffer.setFloat(\"currentCount\", this._currentActiveCount);\n        this._updateBuffer.setFloat(\"timeDelta\", this._timeDelta);\n        this._updateBuffer.setFloat(\"stopFactor\", this._stopped ? 0 : 1);\n        this._updateBuffer.setInt(\"randomTextureSize\", this._randomTextureSize);\n        this._updateBuffer.setFloat2(\"lifeTime\", this.minLifeTime, this.maxLifeTime);\n        this._updateBuffer.setFloat2(\"emitPower\", this.minEmitPower, this.maxEmitPower);\n        if (!this._colorGradientsTexture) {\n            this._updateBuffer.setDirectColor4(\"color1\", this.color1);\n            this._updateBuffer.setDirectColor4(\"color2\", this.color2);\n        }\n        this._updateBuffer.setFloat2(\"sizeRange\", this.minSize, this.maxSize);\n        this._updateBuffer.setFloat4(\"scaleRange\", this.minScaleX, this.maxScaleX, this.minScaleY, this.maxScaleY);\n        this._updateBuffer.setFloat4(\"angleRange\", this.minAngularSpeed, this.maxAngularSpeed, this.minInitialRotation, this.maxInitialRotation);\n        this._updateBuffer.setVector3(\"gravity\", this.gravity);\n        if (this._limitVelocityGradientsTexture) {\n            this._updateBuffer.setFloat(\"limitVelocityDamping\", this.limitVelocityDamping);\n        }\n        if (this.particleEmitterType) {\n            this.particleEmitterType.applyToShader(this._updateBuffer);\n        }\n        if (this._isAnimationSheetEnabled) {\n            this._updateBuffer.setFloat4(\"cellInfos\", this.startSpriteCellID, this.endSpriteCellID, this.spriteCellChangeSpeed, this.spriteCellLoop ? 1 : 0);\n        }\n        if (this.noiseTexture) {\n            this._updateBuffer.setVector3(\"noiseStrength\", this.noiseStrength);\n        }\n        if (!this.isLocal) {\n            this._updateBuffer.setMatrix(\"emitterWM\", emitterWM);\n        }\n        this._platform.updateParticleBuffer(this._targetIndex, this._targetBuffer, this._currentActiveCount);\n        // Switch VAOs\n        this._targetIndex++;\n        if (this._targetIndex === 2) {\n            this._targetIndex = 0;\n        }\n        // Switch buffers\n        const tmpBuffer = this._sourceBuffer;\n        this._sourceBuffer = this._targetBuffer;\n        this._targetBuffer = tmpBuffer;\n    }\n    /**\n     * Renders the particle system in its current state\n     * @param preWarm defines if the system should only update the particles but not render them\n     * @param forceUpdateOnly if true, force to only update the particles and never display them (meaning, even if preWarm=false, when forceUpdateOnly=true the particles won't be displayed)\n     * @returns the current number of particles\n     */\n    render(preWarm = false, forceUpdateOnly = false) {\n        if (!this._started) {\n            return 0;\n        }\n        this._createColorGradientTexture();\n        this._createSizeGradientTexture();\n        this._createAngularSpeedGradientTexture();\n        this._createVelocityGradientTexture();\n        this._createLimitVelocityGradientTexture();\n        this._createDragGradientTexture();\n        if (!this.isReady()) {\n            return 0;\n        }\n        if (!preWarm && this._scene) {\n            if (!this._preWarmDone && this.preWarmCycles) {\n                for (let index = 0; index < this.preWarmCycles; index++) {\n                    this.animate(true);\n                    this.render(true, true);\n                }\n                this._preWarmDone = true;\n            }\n            if (this._currentRenderId === this._scene.getFrameId() &&\n                (!this._scene.activeCamera || (this._scene.activeCamera && this._currentRenderingCameraUniqueId === this._scene.activeCamera.uniqueId))) {\n                return 0;\n            }\n            this._currentRenderId = this._scene.getFrameId();\n            if (this._scene.activeCamera) {\n                this._currentRenderingCameraUniqueId = this._scene.activeCamera.uniqueId;\n            }\n        }\n        // Get everything ready to render\n        this._initialize();\n        this._accumulatedCount += this.emitRate * this._timeDelta;\n        if (this._accumulatedCount > 1) {\n            const intPart = this._accumulatedCount | 0;\n            this._accumulatedCount -= intPart;\n            this._currentActiveCount = Math.min(this._activeCount, this._currentActiveCount + intPart);\n        }\n        if (!this._currentActiveCount) {\n            return 0;\n        }\n        // Enable update effect\n        let emitterWM;\n        if (this.emitter.position) {\n            const emitterMesh = this.emitter;\n            emitterWM = emitterMesh.getWorldMatrix();\n        }\n        else {\n            const emitterPosition = this.emitter;\n            emitterWM = TmpVectors.Matrix[0];\n            Matrix.TranslationToRef(emitterPosition.x, emitterPosition.y, emitterPosition.z, emitterWM);\n        }\n        const engine = this._engine;\n        if (!this.updateInAnimate) {\n            this._update(emitterWM);\n        }\n        let outparticles = 0;\n        if (!preWarm && !forceUpdateOnly) {\n            engine.setState(false);\n            if (this.forceDepthWrite) {\n                engine.setDepthWrite(true);\n            }\n            if (this.blendMode === ParticleSystem.BLENDMODE_MULTIPLYADD) {\n                outparticles = this._render(ParticleSystem.BLENDMODE_MULTIPLY, emitterWM) + this._render(ParticleSystem.BLENDMODE_ADD, emitterWM);\n            }\n            else {\n                outparticles = this._render(this.blendMode, emitterWM);\n            }\n            this._engine.setAlphaMode(0);\n        }\n        return outparticles;\n    }\n    /**\n     * Rebuilds the particle system\n     */\n    rebuild() {\n        this._initialize(true);\n    }\n    _releaseBuffers() {\n        if (this._buffer0) {\n            this._buffer0.dispose();\n            this._buffer0 = null;\n        }\n        if (this._buffer1) {\n            this._buffer1.dispose();\n            this._buffer1 = null;\n        }\n        if (this._spriteBuffer) {\n            this._spriteBuffer.dispose();\n            this._spriteBuffer = null;\n        }\n        this._platform.releaseBuffers();\n    }\n    /**\n     * Disposes the particle system and free the associated resources\n     * @param disposeTexture defines if the particule texture must be disposed as well (true by default)\n     */\n    dispose(disposeTexture = true) {\n        for (const blendMode in this._drawWrappers) {\n            const drawWrapper = this._drawWrappers[blendMode];\n            drawWrapper.dispose();\n        }\n        this._drawWrappers = {};\n        if (this._scene) {\n            const index = this._scene.particleSystems.indexOf(this);\n            if (index > -1) {\n                this._scene.particleSystems.splice(index, 1);\n            }\n        }\n        this._releaseBuffers();\n        this._platform.releaseVertexBuffers();\n        for (let i = 0; i < this._renderVertexBuffers.length; ++i) {\n            const rvb = this._renderVertexBuffers[i];\n            for (const key in rvb) {\n                rvb[key].dispose();\n            }\n        }\n        this._renderVertexBuffers = [];\n        if (this._colorGradientsTexture) {\n            this._colorGradientsTexture.dispose();\n            this._colorGradientsTexture = null;\n        }\n        if (this._sizeGradientsTexture) {\n            this._sizeGradientsTexture.dispose();\n            this._sizeGradientsTexture = null;\n        }\n        if (this._angularSpeedGradientsTexture) {\n            this._angularSpeedGradientsTexture.dispose();\n            this._angularSpeedGradientsTexture = null;\n        }\n        if (this._velocityGradientsTexture) {\n            this._velocityGradientsTexture.dispose();\n            this._velocityGradientsTexture = null;\n        }\n        if (this._limitVelocityGradientsTexture) {\n            this._limitVelocityGradientsTexture.dispose();\n            this._limitVelocityGradientsTexture = null;\n        }\n        if (this._dragGradientsTexture) {\n            this._dragGradientsTexture.dispose();\n            this._dragGradientsTexture = null;\n        }\n        if (this._randomTexture) {\n            this._randomTexture.dispose();\n            this._randomTexture = null;\n        }\n        if (this._randomTexture2) {\n            this._randomTexture2.dispose();\n            this._randomTexture2 = null;\n        }\n        if (disposeTexture && this.particleTexture) {\n            this.particleTexture.dispose();\n            this.particleTexture = null;\n        }\n        if (disposeTexture && this.noiseTexture) {\n            this.noiseTexture.dispose();\n            this.noiseTexture = null;\n        }\n        // Callback\n        this.onStoppedObservable.clear();\n        this.onDisposeObservable.notifyObservers(this);\n        this.onDisposeObservable.clear();\n    }\n    /**\n     * Clones the particle system.\n     * @param name The name of the cloned object\n     * @param newEmitter The new emitter to use\n     * @param cloneTexture Also clone the textures if true\n     * @returns the cloned particle system\n     */\n    clone(name, newEmitter, cloneTexture = false) {\n        const custom = { ...this._customWrappers };\n        let program = null;\n        const engine = this._engine;\n        if (engine.createEffectForParticles) {\n            if (this.customShader != null) {\n                program = this.customShader;\n                const defines = program.shaderOptions.defines.length > 0 ? program.shaderOptions.defines.join(\"\\n\") : \"\";\n                custom[0] = engine.createEffectForParticles(program.shaderPath.fragmentElement, program.shaderOptions.uniforms, program.shaderOptions.samplers, defines, undefined, undefined, undefined, this);\n            }\n        }\n        const serialization = this.serialize(cloneTexture);\n        const result = GPUParticleSystem.Parse(serialization, this._scene || this._engine, this._rootUrl);\n        result.name = name;\n        result.customShader = program;\n        result._customWrappers = custom;\n        if (newEmitter === undefined) {\n            newEmitter = this.emitter;\n        }\n        if (this.noiseTexture) {\n            result.noiseTexture = this.noiseTexture.clone();\n        }\n        result.emitter = newEmitter;\n        return result;\n    }\n    /**\n     * Serializes the particle system to a JSON object\n     * @param serializeTexture defines if the texture must be serialized as well\n     * @returns the JSON object\n     */\n    serialize(serializeTexture = false) {\n        const serializationObject = {};\n        ParticleSystem._Serialize(serializationObject, this, serializeTexture);\n        serializationObject.activeParticleCount = this.activeParticleCount;\n        serializationObject.randomTextureSize = this._randomTextureSize;\n        serializationObject.customShader = this.customShader;\n        return serializationObject;\n    }\n    /**\n     * Parses a JSON object to create a GPU particle system.\n     * @param parsedParticleSystem The JSON object to parse\n     * @param sceneOrEngine The scene or the engine to create the particle system in\n     * @param rootUrl The root url to use to load external dependencies like texture\n     * @param doNotStart Ignore the preventAutoStart attribute and does not start\n     * @param capacity defines the system capacity (if null or undefined the sotred capacity will be used)\n     * @returns the parsed GPU particle system\n     */\n    static Parse(parsedParticleSystem, sceneOrEngine, rootUrl, doNotStart = false, capacity) {\n        const name = parsedParticleSystem.name;\n        let engine;\n        let scene;\n        if (sceneOrEngine instanceof ThinEngine) {\n            engine = sceneOrEngine;\n        }\n        else {\n            scene = sceneOrEngine;\n            engine = scene.getEngine();\n        }\n        const particleSystem = new GPUParticleSystem(name, { capacity: capacity || parsedParticleSystem.capacity, randomTextureSize: parsedParticleSystem.randomTextureSize }, sceneOrEngine, null, parsedParticleSystem.isAnimationSheetEnabled);\n        particleSystem._rootUrl = rootUrl;\n        if (parsedParticleSystem.customShader && engine.createEffectForParticles) {\n            const program = parsedParticleSystem.customShader;\n            const defines = program.shaderOptions.defines.length > 0 ? program.shaderOptions.defines.join(\"\\n\") : \"\";\n            const custom = engine.createEffectForParticles(program.shaderPath.fragmentElement, program.shaderOptions.uniforms, program.shaderOptions.samplers, defines, undefined, undefined, undefined, particleSystem);\n            particleSystem.setCustomEffect(custom, 0);\n            particleSystem.customShader = program;\n        }\n        if (parsedParticleSystem.id) {\n            particleSystem.id = parsedParticleSystem.id;\n        }\n        if (parsedParticleSystem.activeParticleCount) {\n            particleSystem.activeParticleCount = parsedParticleSystem.activeParticleCount;\n        }\n        ParticleSystem._Parse(parsedParticleSystem, particleSystem, sceneOrEngine, rootUrl);\n        // Auto start\n        if (parsedParticleSystem.preventAutoStart) {\n            particleSystem.preventAutoStart = parsedParticleSystem.preventAutoStart;\n        }\n        if (!doNotStart && !particleSystem.preventAutoStart) {\n            particleSystem.start();\n        }\n        return particleSystem;\n    }\n}\n//# sourceMappingURL=gpuParticleSystem.js.map","import { Effect } from \"../Materials/effect.js\";\nimport { CustomParticleEmitter } from \"./EmitterTypes/customParticleEmitter.js\";\nimport { UniformBufferEffectCommonAccessor } from \"../Materials/uniformBufferEffectCommonAccessor.js\";\n\nimport { RegisterClass } from \"../Misc/typeStore.js\";\nimport \"../Shaders/gpuUpdateParticles.fragment.js\";\nimport \"../Shaders/gpuUpdateParticles.vertex.js\";\n/** @internal */\nexport class WebGL2ParticleSystem {\n    constructor(parent, engine) {\n        this._renderVAO = [];\n        this._updateVAO = [];\n        this.alignDataInBuffer = false;\n        this._parent = parent;\n        this._engine = engine;\n        this._updateEffectOptions = {\n            attributes: [\n                \"position\",\n                \"initialPosition\",\n                \"age\",\n                \"life\",\n                \"seed\",\n                \"size\",\n                \"color\",\n                \"direction\",\n                \"initialDirection\",\n                \"angle\",\n                \"cellIndex\",\n                \"cellStartOffset\",\n                \"noiseCoordinates1\",\n                \"noiseCoordinates2\",\n            ],\n            uniformsNames: [\n                \"currentCount\",\n                \"timeDelta\",\n                \"emitterWM\",\n                \"lifeTime\",\n                \"color1\",\n                \"color2\",\n                \"sizeRange\",\n                \"scaleRange\",\n                \"gravity\",\n                \"emitPower\",\n                \"direction1\",\n                \"direction2\",\n                \"minEmitBox\",\n                \"maxEmitBox\",\n                \"radius\",\n                \"directionRandomizer\",\n                \"height\",\n                \"coneAngle\",\n                \"stopFactor\",\n                \"angleRange\",\n                \"radiusRange\",\n                \"cellInfos\",\n                \"noiseStrength\",\n                \"limitVelocityDamping\",\n            ],\n            uniformBuffersNames: [],\n            samplers: [\n                \"randomSampler\",\n                \"randomSampler2\",\n                \"sizeGradientSampler\",\n                \"angularSpeedGradientSampler\",\n                \"velocityGradientSampler\",\n                \"limitVelocityGradientSampler\",\n                \"noiseSampler\",\n                \"dragGradientSampler\",\n            ],\n            defines: \"\",\n            fallbacks: null,\n            onCompiled: null,\n            onError: null,\n            indexParameters: null,\n            maxSimultaneousLights: 0,\n            transformFeedbackVaryings: [],\n        };\n    }\n    isUpdateBufferCreated() {\n        return !!this._updateEffect;\n    }\n    isUpdateBufferReady() {\n        var _a, _b;\n        return (_b = (_a = this._updateEffect) === null || _a === void 0 ? void 0 : _a.isReady()) !== null && _b !== void 0 ? _b : false;\n    }\n    createUpdateBuffer(defines) {\n        this._updateEffectOptions.transformFeedbackVaryings = [\"outPosition\"];\n        this._updateEffectOptions.transformFeedbackVaryings.push(\"outAge\");\n        this._updateEffectOptions.transformFeedbackVaryings.push(\"outSize\");\n        this._updateEffectOptions.transformFeedbackVaryings.push(\"outLife\");\n        this._updateEffectOptions.transformFeedbackVaryings.push(\"outSeed\");\n        this._updateEffectOptions.transformFeedbackVaryings.push(\"outDirection\");\n        if (this._parent.particleEmitterType instanceof CustomParticleEmitter) {\n            this._updateEffectOptions.transformFeedbackVaryings.push(\"outInitialPosition\");\n        }\n        if (!this._parent._colorGradientsTexture) {\n            this._updateEffectOptions.transformFeedbackVaryings.push(\"outColor\");\n        }\n        if (!this._parent._isBillboardBased) {\n            this._updateEffectOptions.transformFeedbackVaryings.push(\"outInitialDirection\");\n        }\n        if (this._parent.noiseTexture) {\n            this._updateEffectOptions.transformFeedbackVaryings.push(\"outNoiseCoordinates1\");\n            this._updateEffectOptions.transformFeedbackVaryings.push(\"outNoiseCoordinates2\");\n        }\n        this._updateEffectOptions.transformFeedbackVaryings.push(\"outAngle\");\n        if (this._parent.isAnimationSheetEnabled) {\n            this._updateEffectOptions.transformFeedbackVaryings.push(\"outCellIndex\");\n            if (this._parent.spriteRandomStartCell) {\n                this._updateEffectOptions.transformFeedbackVaryings.push(\"outCellStartOffset\");\n            }\n        }\n        this._updateEffectOptions.defines = defines;\n        this._updateEffect = new Effect(\"gpuUpdateParticles\", this._updateEffectOptions, this._engine);\n        return new UniformBufferEffectCommonAccessor(this._updateEffect);\n    }\n    createVertexBuffers(updateBuffer, renderVertexBuffers) {\n        this._updateVAO.push(this._createUpdateVAO(updateBuffer));\n        this._renderVAO.push(this._engine.recordVertexArrayObject(renderVertexBuffers, null, this._parent._getWrapper(this._parent.blendMode).effect));\n        this._engine.bindArrayBuffer(null);\n    }\n    createParticleBuffer(data) {\n        return data;\n    }\n    bindDrawBuffers(index) {\n        this._engine.bindVertexArrayObject(this._renderVAO[index], null);\n    }\n    preUpdateParticleBuffer() {\n        const engine = this._engine;\n        this._engine.enableEffect(this._updateEffect);\n        if (!engine.setState) {\n            throw new Error(\"GPU particles cannot work without a full Engine. ThinEngine is not supported\");\n        }\n    }\n    updateParticleBuffer(index, targetBuffer, currentActiveCount) {\n        this._updateEffect.setTexture(\"randomSampler\", this._parent._randomTexture);\n        this._updateEffect.setTexture(\"randomSampler2\", this._parent._randomTexture2);\n        if (this._parent._sizeGradientsTexture) {\n            this._updateEffect.setTexture(\"sizeGradientSampler\", this._parent._sizeGradientsTexture);\n        }\n        if (this._parent._angularSpeedGradientsTexture) {\n            this._updateEffect.setTexture(\"angularSpeedGradientSampler\", this._parent._angularSpeedGradientsTexture);\n        }\n        if (this._parent._velocityGradientsTexture) {\n            this._updateEffect.setTexture(\"velocityGradientSampler\", this._parent._velocityGradientsTexture);\n        }\n        if (this._parent._limitVelocityGradientsTexture) {\n            this._updateEffect.setTexture(\"limitVelocityGradientSampler\", this._parent._limitVelocityGradientsTexture);\n        }\n        if (this._parent._dragGradientsTexture) {\n            this._updateEffect.setTexture(\"dragGradientSampler\", this._parent._dragGradientsTexture);\n        }\n        if (this._parent.noiseTexture) {\n            this._updateEffect.setTexture(\"noiseSampler\", this._parent.noiseTexture);\n        }\n        // Bind source VAO\n        this._engine.bindVertexArrayObject(this._updateVAO[index], null);\n        // Update\n        const engine = this._engine;\n        engine.bindTransformFeedbackBuffer(targetBuffer.getBuffer());\n        engine.setRasterizerState(false);\n        engine.beginTransformFeedback(true);\n        engine.drawArraysType(3, 0, currentActiveCount);\n        engine.endTransformFeedback();\n        engine.setRasterizerState(true);\n        engine.bindTransformFeedbackBuffer(null);\n    }\n    releaseBuffers() { }\n    releaseVertexBuffers() {\n        for (let index = 0; index < this._updateVAO.length; index++) {\n            this._engine.releaseVertexArrayObject(this._updateVAO[index]);\n        }\n        this._updateVAO.length = 0;\n        for (let index = 0; index < this._renderVAO.length; index++) {\n            this._engine.releaseVertexArrayObject(this._renderVAO[index]);\n        }\n        this._renderVAO.length = 0;\n    }\n    _createUpdateVAO(source) {\n        const updateVertexBuffers = {};\n        updateVertexBuffers[\"position\"] = source.createVertexBuffer(\"position\", 0, 3);\n        let offset = 3;\n        updateVertexBuffers[\"age\"] = source.createVertexBuffer(\"age\", offset, 1);\n        offset += 1;\n        updateVertexBuffers[\"size\"] = source.createVertexBuffer(\"size\", offset, 3);\n        offset += 3;\n        updateVertexBuffers[\"life\"] = source.createVertexBuffer(\"life\", offset, 1);\n        offset += 1;\n        updateVertexBuffers[\"seed\"] = source.createVertexBuffer(\"seed\", offset, 4);\n        offset += 4;\n        updateVertexBuffers[\"direction\"] = source.createVertexBuffer(\"direction\", offset, 3);\n        offset += 3;\n        if (this._parent.particleEmitterType instanceof CustomParticleEmitter) {\n            updateVertexBuffers[\"initialPosition\"] = source.createVertexBuffer(\"initialPosition\", offset, 3);\n            offset += 3;\n        }\n        if (!this._parent._colorGradientsTexture) {\n            updateVertexBuffers[\"color\"] = source.createVertexBuffer(\"color\", offset, 4);\n            offset += 4;\n        }\n        if (!this._parent._isBillboardBased) {\n            updateVertexBuffers[\"initialDirection\"] = source.createVertexBuffer(\"initialDirection\", offset, 3);\n            offset += 3;\n        }\n        if (this._parent.noiseTexture) {\n            updateVertexBuffers[\"noiseCoordinates1\"] = source.createVertexBuffer(\"noiseCoordinates1\", offset, 3);\n            offset += 3;\n            updateVertexBuffers[\"noiseCoordinates2\"] = source.createVertexBuffer(\"noiseCoordinates2\", offset, 3);\n            offset += 3;\n        }\n        if (this._parent._angularSpeedGradientsTexture) {\n            updateVertexBuffers[\"angle\"] = source.createVertexBuffer(\"angle\", offset, 1);\n            offset += 1;\n        }\n        else {\n            updateVertexBuffers[\"angle\"] = source.createVertexBuffer(\"angle\", offset, 2);\n            offset += 2;\n        }\n        if (this._parent._isAnimationSheetEnabled) {\n            updateVertexBuffers[\"cellIndex\"] = source.createVertexBuffer(\"cellIndex\", offset, 1);\n            offset += 1;\n            if (this._parent.spriteRandomStartCell) {\n                updateVertexBuffers[\"cellStartOffset\"] = source.createVertexBuffer(\"cellStartOffset\", offset, 1);\n                offset += 1;\n            }\n        }\n        const vao = this._engine.recordVertexArrayObject(updateVertexBuffers, null, this._updateEffect);\n        this._engine.bindArrayBuffer(null);\n        return vao;\n    }\n}\nRegisterClass(\"BABYLON.WebGL2ParticleSystem\", WebGL2ParticleSystem);\n//# sourceMappingURL=webgl2ParticleSystem.js.map","import { StorageBuffer } from \"../Buffers/storageBuffer.js\";\nimport { ComputeShader } from \"../Compute/computeShader.js\";\nimport { UniformBuffer } from \"../Materials/uniformBuffer.js\";\n\nimport { UniformBufferEffectCommonAccessor } from \"../Materials/uniformBufferEffectCommonAccessor.js\";\nimport { RegisterClass } from \"../Misc/typeStore.js\";\nimport \"../ShadersWGSL/gpuUpdateParticles.compute.js\";\n/** @internal */\nexport class ComputeShaderParticleSystem {\n    constructor(parent, engine) {\n        this._bufferComputeShader = [];\n        this._renderVertexBuffers = [];\n        this.alignDataInBuffer = true;\n        this._parent = parent;\n        this._engine = engine;\n    }\n    isUpdateBufferCreated() {\n        return !!this._updateComputeShader;\n    }\n    isUpdateBufferReady() {\n        var _a, _b;\n        return (_b = (_a = this._updateComputeShader) === null || _a === void 0 ? void 0 : _a.isReady()) !== null && _b !== void 0 ? _b : false;\n    }\n    createUpdateBuffer(defines) {\n        var _a;\n        const bindingsMapping = {\n            params: { group: 0, binding: 0 },\n            particlesIn: { group: 0, binding: 1 },\n            particlesOut: { group: 0, binding: 2 },\n            randomTexture: { group: 0, binding: 3 },\n            randomTexture2: { group: 0, binding: 4 },\n        };\n        if (this._parent._sizeGradientsTexture) {\n            bindingsMapping[\"sizeGradientTexture\"] = { group: 1, binding: 1 };\n        }\n        if (this._parent._angularSpeedGradientsTexture) {\n            bindingsMapping[\"angularSpeedGradientTexture\"] = { group: 1, binding: 3 };\n        }\n        if (this._parent._velocityGradientsTexture) {\n            bindingsMapping[\"velocityGradientTexture\"] = { group: 1, binding: 5 };\n        }\n        if (this._parent._limitVelocityGradientsTexture) {\n            bindingsMapping[\"limitVelocityGradientTexture\"] = { group: 1, binding: 7 };\n        }\n        if (this._parent._dragGradientsTexture) {\n            bindingsMapping[\"dragGradientTexture\"] = { group: 1, binding: 9 };\n        }\n        if (this._parent.noiseTexture) {\n            bindingsMapping[\"noiseTexture\"] = { group: 1, binding: 11 };\n        }\n        this._updateComputeShader = new ComputeShader(\"updateParticles\", this._engine, \"gpuUpdateParticles\", { bindingsMapping, defines: defines.split(\"\\n\") });\n        (_a = this._simParamsComputeShader) === null || _a === void 0 ? void 0 : _a.dispose();\n        this._simParamsComputeShader = new UniformBuffer(this._engine);\n        this._simParamsComputeShader.addUniform(\"currentCount\", 1);\n        this._simParamsComputeShader.addUniform(\"timeDelta\", 1);\n        this._simParamsComputeShader.addUniform(\"stopFactor\", 1);\n        this._simParamsComputeShader.addUniform(\"randomTextureSize\", 1);\n        this._simParamsComputeShader.addUniform(\"lifeTime\", 2);\n        this._simParamsComputeShader.addUniform(\"emitPower\", 2);\n        if (!this._parent._colorGradientsTexture) {\n            this._simParamsComputeShader.addUniform(\"color1\", 4);\n            this._simParamsComputeShader.addUniform(\"color2\", 4);\n        }\n        this._simParamsComputeShader.addUniform(\"sizeRange\", 2);\n        this._simParamsComputeShader.addUniform(\"scaleRange\", 4);\n        this._simParamsComputeShader.addUniform(\"angleRange\", 4);\n        this._simParamsComputeShader.addUniform(\"gravity\", 3);\n        if (this._parent._limitVelocityGradientsTexture) {\n            this._simParamsComputeShader.addUniform(\"limitVelocityDamping\", 1);\n        }\n        if (this._parent.isAnimationSheetEnabled) {\n            this._simParamsComputeShader.addUniform(\"cellInfos\", 4);\n        }\n        if (this._parent.noiseTexture) {\n            this._simParamsComputeShader.addUniform(\"noiseStrength\", 3);\n        }\n        if (!this._parent.isLocal) {\n            this._simParamsComputeShader.addUniform(\"emitterWM\", 16);\n        }\n        if (this._parent.particleEmitterType) {\n            this._parent.particleEmitterType.buildUniformLayout(this._simParamsComputeShader);\n        }\n        this._updateComputeShader.setUniformBuffer(\"params\", this._simParamsComputeShader);\n        return new UniformBufferEffectCommonAccessor(this._simParamsComputeShader);\n    }\n    createVertexBuffers(updateBuffer, renderVertexBuffers) {\n        this._renderVertexBuffers.push(renderVertexBuffers);\n    }\n    createParticleBuffer(data) {\n        const buffer = new StorageBuffer(this._engine, data.length * 4, 3 | 8);\n        buffer.update(data);\n        this._bufferComputeShader.push(buffer);\n        return buffer.getBuffer();\n    }\n    bindDrawBuffers(index, effect) {\n        this._engine.bindBuffers(this._renderVertexBuffers[index], null, effect);\n    }\n    preUpdateParticleBuffer() { }\n    updateParticleBuffer(index, targetBuffer, currentActiveCount) {\n        this._simParamsComputeShader.update();\n        this._updateComputeShader.setTexture(\"randomTexture\", this._parent._randomTexture, false);\n        this._updateComputeShader.setTexture(\"randomTexture2\", this._parent._randomTexture2, false);\n        if (this._parent._sizeGradientsTexture) {\n            this._updateComputeShader.setTexture(\"sizeGradientTexture\", this._parent._sizeGradientsTexture);\n        }\n        if (this._parent._angularSpeedGradientsTexture) {\n            this._updateComputeShader.setTexture(\"angularSpeedGradientTexture\", this._parent._angularSpeedGradientsTexture);\n        }\n        if (this._parent._velocityGradientsTexture) {\n            this._updateComputeShader.setTexture(\"velocityGradientTexture\", this._parent._velocityGradientsTexture);\n        }\n        if (this._parent._limitVelocityGradientsTexture) {\n            this._updateComputeShader.setTexture(\"limitVelocityGradientTexture\", this._parent._limitVelocityGradientsTexture);\n        }\n        if (this._parent._dragGradientsTexture) {\n            this._updateComputeShader.setTexture(\"dragGradientTexture\", this._parent._dragGradientsTexture);\n        }\n        if (this._parent.noiseTexture) {\n            this._updateComputeShader.setTexture(\"noiseTexture\", this._parent.noiseTexture);\n        }\n        this._updateComputeShader.setStorageBuffer(\"particlesIn\", this._bufferComputeShader[index]);\n        this._updateComputeShader.setStorageBuffer(\"particlesOut\", this._bufferComputeShader[index ^ 1]);\n        this._updateComputeShader.dispatch(Math.ceil(currentActiveCount / 64));\n    }\n    releaseBuffers() {\n        var _a;\n        for (let i = 0; i < this._bufferComputeShader.length; ++i) {\n            this._bufferComputeShader[i].dispose();\n        }\n        this._bufferComputeShader.length = 0;\n        (_a = this._simParamsComputeShader) === null || _a === void 0 ? void 0 : _a.dispose();\n        this._simParamsComputeShader = null;\n        this._updateComputeShader = null;\n    }\n    releaseVertexBuffers() {\n        this._renderVertexBuffers.length = 0;\n    }\n}\nRegisterClass(\"BABYLON.ComputeShaderParticleSystem\", ComputeShaderParticleSystem);\n//# sourceMappingURL=computeShaderParticleSystem.js.map","import { Tools } from \"../Misc/tools.js\";\nimport { Color4 } from \"../Maths/math.color.js\";\nimport { Texture } from \"../Materials/Textures/texture.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\nimport { GPUParticleSystem } from \"./gpuParticleSystem.js\";\nimport { ParticleSystemSet } from \"./particleSystemSet.js\";\nimport { ParticleSystem } from \"./particleSystem.js\";\nimport { WebRequest } from \"../Misc/webRequest.js\";\n\n/**\n * This class is made for on one-liner static method to help creating particle system set.\n */\nexport class ParticleHelper {\n    /**\n     * Create a default particle system that you can tweak\n     * @param emitter defines the emitter to use\n     * @param capacity defines the system capacity (default is 500 particles)\n     * @param scene defines the hosting scene\n     * @param useGPU defines if a GPUParticleSystem must be created (default is false)\n     * @returns the new Particle system\n     */\n    static CreateDefault(emitter, capacity = 500, scene, useGPU = false) {\n        let system;\n        if (useGPU) {\n            system = new GPUParticleSystem(\"default system\", { capacity: capacity }, scene);\n        }\n        else {\n            system = new ParticleSystem(\"default system\", capacity, scene);\n        }\n        system.emitter = emitter;\n        system.particleTexture = new Texture(\"https://assets.babylonjs.com/textures/flare.png\", system.getScene());\n        system.createConeEmitter(0.1, Math.PI / 4);\n        // Particle color\n        system.color1 = new Color4(1.0, 1.0, 1.0, 1.0);\n        system.color2 = new Color4(1.0, 1.0, 1.0, 1.0);\n        system.colorDead = new Color4(1.0, 1.0, 1.0, 0.0);\n        // Particle Size\n        system.minSize = 0.1;\n        system.maxSize = 0.1;\n        // Emission speed\n        system.minEmitPower = 2;\n        system.maxEmitPower = 2;\n        // Update speed\n        system.updateSpeed = 1 / 60;\n        system.emitRate = 30;\n        return system;\n    }\n    /**\n     * This is the main static method (one-liner) of this helper to create different particle systems\n     * @param type This string represents the type to the particle system to create\n     * @param scene The scene where the particle system should live\n     * @param gpu If the system will use gpu\n     * @param capacity defines the system capacity (if null or undefined the sotred capacity will be used)\n     * @returns the ParticleSystemSet created\n     */\n    static CreateAsync(type, scene, gpu = false, capacity) {\n        if (!scene) {\n            scene = EngineStore.LastCreatedScene;\n        }\n        const token = {};\n        scene.addPendingData(token);\n        return new Promise((resolve, reject) => {\n            if (gpu && !GPUParticleSystem.IsSupported) {\n                scene.removePendingData(token);\n                return reject(\"Particle system with GPU is not supported.\");\n            }\n            Tools.LoadFile(`${ParticleHelper.BaseAssetsUrl}/systems/${type}.json`, (data) => {\n                scene.removePendingData(token);\n                const newData = JSON.parse(data.toString());\n                return resolve(ParticleSystemSet.Parse(newData, scene, gpu, capacity));\n            }, undefined, undefined, undefined, () => {\n                scene.removePendingData(token);\n                return reject(`An error occurred with the creation of your particle system. Check if your type '${type}' exists.`);\n            });\n        });\n    }\n    /**\n     * Static function used to export a particle system to a ParticleSystemSet variable.\n     * Please note that the emitter shape is not exported\n     * @param systems defines the particle systems to export\n     * @returns the created particle system set\n     */\n    static ExportSet(systems) {\n        const set = new ParticleSystemSet();\n        for (const system of systems) {\n            set.systems.push(system);\n        }\n        return set;\n    }\n    /**\n     * Creates a particle system from a snippet saved in a remote file\n     * @param name defines the name of the particle system to create (can be null or empty to use the one from the json data)\n     * @param url defines the url to load from\n     * @param scene defines the hosting scene\n     * @param gpu If the system will use gpu\n     * @param rootUrl defines the root URL to use to load textures and relative dependencies\n     * @param capacity defines the system capacity (if null or undefined the sotred capacity will be used)\n     * @returns a promise that will resolve to the new particle system\n     */\n    static ParseFromFileAsync(name, url, scene, gpu = false, rootUrl = \"\", capacity) {\n        return new Promise((resolve, reject) => {\n            const request = new WebRequest();\n            request.addEventListener(\"readystatechange\", () => {\n                if (request.readyState == 4) {\n                    if (request.status == 200) {\n                        const serializationObject = JSON.parse(request.responseText);\n                        let output;\n                        if (gpu) {\n                            output = GPUParticleSystem.Parse(serializationObject, scene, rootUrl, false, capacity);\n                        }\n                        else {\n                            output = ParticleSystem.Parse(serializationObject, scene, rootUrl, false, capacity);\n                        }\n                        if (name) {\n                            output.name = name;\n                        }\n                        resolve(output);\n                    }\n                    else {\n                        reject(\"Unable to load the particle system\");\n                    }\n                }\n            });\n            request.open(\"GET\", url);\n            request.send();\n        });\n    }\n    /**\n     * Creates a particle system from a snippet saved by the particle system editor\n     * @param snippetId defines the snippet to load (can be set to _BLANK to create a default one)\n     * @param scene defines the hosting scene\n     * @param gpu If the system will use gpu\n     * @param rootUrl defines the root URL to use to load textures and relative dependencies\n     * @param capacity defines the system capacity (if null or undefined the sotred capacity will be used)\n     * @returns a promise that will resolve to the new particle system\n     */\n    static ParseFromSnippetAsync(snippetId, scene, gpu = false, rootUrl = \"\", capacity) {\n        if (snippetId === \"_BLANK\") {\n            const system = this.CreateDefault(null);\n            system.start();\n            return Promise.resolve(system);\n        }\n        return new Promise((resolve, reject) => {\n            const request = new WebRequest();\n            request.addEventListener(\"readystatechange\", () => {\n                if (request.readyState == 4) {\n                    if (request.status == 200) {\n                        const snippet = JSON.parse(JSON.parse(request.responseText).jsonPayload);\n                        const serializationObject = JSON.parse(snippet.particleSystem);\n                        let output;\n                        if (gpu) {\n                            output = GPUParticleSystem.Parse(serializationObject, scene, rootUrl, false, capacity);\n                        }\n                        else {\n                            output = ParticleSystem.Parse(serializationObject, scene, rootUrl, false, capacity);\n                        }\n                        output.snippetId = snippetId;\n                        resolve(output);\n                    }\n                    else {\n                        reject(\"Unable to load the snippet \" + snippetId);\n                    }\n                }\n            });\n            request.open(\"GET\", this.SnippetUrl + \"/\" + snippetId.replace(/#/g, \"/\"));\n            request.send();\n        });\n    }\n}\n/**\n * Gets or sets base Assets URL\n */\nParticleHelper.BaseAssetsUrl = ParticleSystemSet.BaseAssetsUrl;\n/** Define the Url to load snippets */\nParticleHelper.SnippetUrl = `https://snippet.babylonjs.com`;\n/**\n * Creates a particle system from a snippet saved by the particle system editor\n * @deprecated Please use ParseFromSnippetAsync instead\n * @param snippetId defines the snippet to load (can be set to _BLANK to create a default one)\n * @param scene defines the hosting scene\n * @param gpu If the system will use gpu\n * @param rootUrl defines the root URL to use to load textures and relative dependencies\n * @param capacity defines the system capacity (if null or undefined the sotred capacity will be used)\n * @returns a promise that will resolve to the new particle system\n */\nParticleHelper.CreateFromSnippetAsync = ParticleHelper.ParseFromSnippetAsync;\n//# sourceMappingURL=particleHelper.js.map","import { Mesh } from \"../Meshes/mesh.js\";\nimport { GPUParticleSystem } from \"./gpuParticleSystem.js\";\nimport { AbstractScene } from \"../abstractScene.js\";\nimport { Engine } from \"../Engines/engine.js\";\nimport { ParticleSystem } from \"./particleSystem.js\";\nimport { SceneComponentConstants } from \"../sceneComponent.js\";\nimport \"../Shaders/particles.vertex.js\";\n// Adds the parsers to the scene parsers.\nAbstractScene.AddParser(SceneComponentConstants.NAME_PARTICLESYSTEM, (parsedData, scene, container, rootUrl) => {\n    const individualParser = AbstractScene.GetIndividualParser(SceneComponentConstants.NAME_PARTICLESYSTEM);\n    if (!individualParser) {\n        return;\n    }\n    // Particles Systems\n    if (parsedData.particleSystems !== undefined && parsedData.particleSystems !== null) {\n        for (let index = 0, cache = parsedData.particleSystems.length; index < cache; index++) {\n            const parsedParticleSystem = parsedData.particleSystems[index];\n            container.particleSystems.push(individualParser(parsedParticleSystem, scene, rootUrl));\n        }\n    }\n});\nAbstractScene.AddIndividualParser(SceneComponentConstants.NAME_PARTICLESYSTEM, (parsedParticleSystem, scene, rootUrl) => {\n    if (parsedParticleSystem.activeParticleCount) {\n        const ps = GPUParticleSystem.Parse(parsedParticleSystem, scene, rootUrl);\n        return ps;\n    }\n    else {\n        const ps = ParticleSystem.Parse(parsedParticleSystem, scene, rootUrl);\n        return ps;\n    }\n});\nEngine.prototype.createEffectForParticles = function (fragmentName, uniformsNames = [], samplers = [], defines = \"\", fallbacks, onCompiled, onError, particleSystem) {\n    var _a;\n    let attributesNamesOrOptions = [];\n    let effectCreationOption = [];\n    const allSamplers = [];\n    if (particleSystem) {\n        particleSystem.fillUniformsAttributesAndSamplerNames(effectCreationOption, attributesNamesOrOptions, allSamplers);\n    }\n    else {\n        attributesNamesOrOptions = ParticleSystem._GetAttributeNamesOrOptions();\n        effectCreationOption = ParticleSystem._GetEffectCreationOptions();\n    }\n    if (defines.indexOf(\" BILLBOARD\") === -1) {\n        defines += \"\\n#define BILLBOARD\\n\";\n    }\n    if (particleSystem === null || particleSystem === void 0 ? void 0 : particleSystem.isAnimationSheetEnabled) {\n        if (defines.indexOf(\" ANIMATESHEET\") === -1) {\n            defines += \"\\n#define ANIMATESHEET\\n\";\n        }\n    }\n    if (samplers.indexOf(\"diffuseSampler\") === -1) {\n        samplers.push(\"diffuseSampler\");\n    }\n    return this.createEffect({\n        vertex: (_a = particleSystem === null || particleSystem === void 0 ? void 0 : particleSystem.vertexShaderName) !== null && _a !== void 0 ? _a : \"particles\",\n        fragmentElement: fragmentName,\n    }, attributesNamesOrOptions, effectCreationOption.concat(uniformsNames), allSamplers.concat(samplers), defines, fallbacks, onCompiled, onError);\n};\nMesh.prototype.getEmittedParticleSystems = function () {\n    const results = new Array();\n    for (let index = 0; index < this.getScene().particleSystems.length; index++) {\n        const particleSystem = this.getScene().particleSystems[index];\n        if (particleSystem.emitter === this) {\n            results.push(particleSystem);\n        }\n    }\n    return results;\n};\nMesh.prototype.getHierarchyEmittedParticleSystems = function () {\n    const results = new Array();\n    const descendants = this.getDescendants();\n    descendants.push(this);\n    for (let index = 0; index < this.getScene().particleSystems.length; index++) {\n        const particleSystem = this.getScene().particleSystems[index];\n        const emitter = particleSystem.emitter;\n        if (emitter.position && descendants.indexOf(emitter) !== -1) {\n            results.push(particleSystem);\n        }\n    }\n    return results;\n};\n//# sourceMappingURL=particleSystemComponent.js.map","import { Vector2, Vector3, TmpVectors, Vector4 } from \"../Maths/math.vector.js\";\nimport { Color4 } from \"../Maths/math.color.js\";\nimport { Scalar } from \"../Maths/math.scalar.js\";\n/**\n * A particle represents one of the element emitted by a particle system.\n * This is mainly define by its coordinates, direction, velocity and age.\n */\nexport class Particle {\n    /**\n     * Creates a new instance Particle\n     * @param particleSystem the particle system the particle belongs to\n     */\n    constructor(\n    /**\n     * The particle system the particle belongs to.\n     */\n    particleSystem) {\n        this.particleSystem = particleSystem;\n        /**\n         * The world position of the particle in the scene.\n         */\n        this.position = Vector3.Zero();\n        /**\n         * The world direction of the particle in the scene.\n         */\n        this.direction = Vector3.Zero();\n        /**\n         * The color of the particle.\n         */\n        this.color = new Color4(0, 0, 0, 0);\n        /**\n         * The color change of the particle per step.\n         */\n        this.colorStep = new Color4(0, 0, 0, 0);\n        /**\n         * Defines how long will the life of the particle be.\n         */\n        this.lifeTime = 1.0;\n        /**\n         * The current age of the particle.\n         */\n        this.age = 0;\n        /**\n         * The current size of the particle.\n         */\n        this.size = 0;\n        /**\n         * The current scale of the particle.\n         */\n        this.scale = new Vector2(1, 1);\n        /**\n         * The current angle of the particle.\n         */\n        this.angle = 0;\n        /**\n         * Defines how fast is the angle changing.\n         */\n        this.angularSpeed = 0;\n        /**\n         * Defines the cell index used by the particle to be rendered from a sprite.\n         */\n        this.cellIndex = 0;\n        /** @internal */\n        this._attachedSubEmitters = null;\n        /** @internal */\n        this._currentColor1 = new Color4(0, 0, 0, 0);\n        /** @internal */\n        this._currentColor2 = new Color4(0, 0, 0, 0);\n        /** @internal */\n        this._currentSize1 = 0;\n        /** @internal */\n        this._currentSize2 = 0;\n        /** @internal */\n        this._currentAngularSpeed1 = 0;\n        /** @internal */\n        this._currentAngularSpeed2 = 0;\n        /** @internal */\n        this._currentVelocity1 = 0;\n        /** @internal */\n        this._currentVelocity2 = 0;\n        /** @internal */\n        this._currentLimitVelocity1 = 0;\n        /** @internal */\n        this._currentLimitVelocity2 = 0;\n        /** @internal */\n        this._currentDrag1 = 0;\n        /** @internal */\n        this._currentDrag2 = 0;\n        this.id = Particle._Count++;\n        if (!this.particleSystem.isAnimationSheetEnabled) {\n            return;\n        }\n        this._updateCellInfoFromSystem();\n    }\n    _updateCellInfoFromSystem() {\n        this.cellIndex = this.particleSystem.startSpriteCellID;\n    }\n    /**\n     * Defines how the sprite cell index is updated for the particle\n     */\n    updateCellIndex() {\n        let offsetAge = this.age;\n        let changeSpeed = this.particleSystem.spriteCellChangeSpeed;\n        if (this.particleSystem.spriteRandomStartCell) {\n            if (this._randomCellOffset === undefined) {\n                this._randomCellOffset = Math.random() * this.lifeTime;\n            }\n            if (changeSpeed === 0) {\n                // Special case when speed = 0 meaning we want to stay on initial cell\n                changeSpeed = 1;\n                offsetAge = this._randomCellOffset;\n            }\n            else {\n                offsetAge += this._randomCellOffset;\n            }\n        }\n        const dist = this._initialEndSpriteCellID - this._initialStartSpriteCellID;\n        let ratio;\n        if (this._initialSpriteCellLoop) {\n            ratio = Scalar.Clamp(((offsetAge * changeSpeed) % this.lifeTime) / this.lifeTime);\n        }\n        else {\n            ratio = Scalar.Clamp((offsetAge * changeSpeed) / this.lifeTime);\n        }\n        this.cellIndex = (this._initialStartSpriteCellID + ratio * dist) | 0;\n    }\n    /**\n     * @internal\n     */\n    _inheritParticleInfoToSubEmitter(subEmitter) {\n        if (subEmitter.particleSystem.emitter.position) {\n            const emitterMesh = subEmitter.particleSystem.emitter;\n            emitterMesh.position.copyFrom(this.position);\n            if (subEmitter.inheritDirection) {\n                const temp = TmpVectors.Vector3[0];\n                this.direction.normalizeToRef(temp);\n                emitterMesh.setDirection(temp, 0, Math.PI / 2);\n            }\n        }\n        else {\n            const emitterPosition = subEmitter.particleSystem.emitter;\n            emitterPosition.copyFrom(this.position);\n        }\n        // Set inheritedVelocityOffset to be used when new particles are created\n        this.direction.scaleToRef(subEmitter.inheritedVelocityAmount / 2, TmpVectors.Vector3[0]);\n        subEmitter.particleSystem._inheritedVelocityOffset.copyFrom(TmpVectors.Vector3[0]);\n    }\n    /** @internal */\n    _inheritParticleInfoToSubEmitters() {\n        if (this._attachedSubEmitters && this._attachedSubEmitters.length > 0) {\n            this._attachedSubEmitters.forEach((subEmitter) => {\n                this._inheritParticleInfoToSubEmitter(subEmitter);\n            });\n        }\n    }\n    /** @internal */\n    _reset() {\n        this.age = 0;\n        this.id = Particle._Count++;\n        this._currentColorGradient = null;\n        this._currentSizeGradient = null;\n        this._currentAngularSpeedGradient = null;\n        this._currentVelocityGradient = null;\n        this._currentLimitVelocityGradient = null;\n        this._currentDragGradient = null;\n        this.cellIndex = this.particleSystem.startSpriteCellID;\n        this._randomCellOffset = undefined;\n    }\n    /**\n     * Copy the properties of particle to another one.\n     * @param other the particle to copy the information to.\n     */\n    copyTo(other) {\n        other.position.copyFrom(this.position);\n        if (this._initialDirection) {\n            if (other._initialDirection) {\n                other._initialDirection.copyFrom(this._initialDirection);\n            }\n            else {\n                other._initialDirection = this._initialDirection.clone();\n            }\n        }\n        else {\n            other._initialDirection = null;\n        }\n        other.direction.copyFrom(this.direction);\n        if (this._localPosition) {\n            if (other._localPosition) {\n                other._localPosition.copyFrom(this._localPosition);\n            }\n            else {\n                other._localPosition = this._localPosition.clone();\n            }\n        }\n        other.color.copyFrom(this.color);\n        other.colorStep.copyFrom(this.colorStep);\n        other.lifeTime = this.lifeTime;\n        other.age = this.age;\n        other._randomCellOffset = this._randomCellOffset;\n        other.size = this.size;\n        other.scale.copyFrom(this.scale);\n        other.angle = this.angle;\n        other.angularSpeed = this.angularSpeed;\n        other.particleSystem = this.particleSystem;\n        other.cellIndex = this.cellIndex;\n        other.id = this.id;\n        other._attachedSubEmitters = this._attachedSubEmitters;\n        if (this._currentColorGradient) {\n            other._currentColorGradient = this._currentColorGradient;\n            other._currentColor1.copyFrom(this._currentColor1);\n            other._currentColor2.copyFrom(this._currentColor2);\n        }\n        if (this._currentSizeGradient) {\n            other._currentSizeGradient = this._currentSizeGradient;\n            other._currentSize1 = this._currentSize1;\n            other._currentSize2 = this._currentSize2;\n        }\n        if (this._currentAngularSpeedGradient) {\n            other._currentAngularSpeedGradient = this._currentAngularSpeedGradient;\n            other._currentAngularSpeed1 = this._currentAngularSpeed1;\n            other._currentAngularSpeed2 = this._currentAngularSpeed2;\n        }\n        if (this._currentVelocityGradient) {\n            other._currentVelocityGradient = this._currentVelocityGradient;\n            other._currentVelocity1 = this._currentVelocity1;\n            other._currentVelocity2 = this._currentVelocity2;\n        }\n        if (this._currentLimitVelocityGradient) {\n            other._currentLimitVelocityGradient = this._currentLimitVelocityGradient;\n            other._currentLimitVelocity1 = this._currentLimitVelocity1;\n            other._currentLimitVelocity2 = this._currentLimitVelocity2;\n        }\n        if (this._currentDragGradient) {\n            other._currentDragGradient = this._currentDragGradient;\n            other._currentDrag1 = this._currentDrag1;\n            other._currentDrag2 = this._currentDrag2;\n        }\n        if (this.particleSystem.isAnimationSheetEnabled) {\n            other._initialStartSpriteCellID = this._initialStartSpriteCellID;\n            other._initialEndSpriteCellID = this._initialEndSpriteCellID;\n            other._initialSpriteCellLoop = this._initialSpriteCellLoop;\n        }\n        if (this.particleSystem.useRampGradients) {\n            if (other.remapData && this.remapData) {\n                other.remapData.copyFrom(this.remapData);\n            }\n            else {\n                other.remapData = new Vector4(0, 0, 0, 0);\n            }\n        }\n        if (this._randomNoiseCoordinates1) {\n            if (other._randomNoiseCoordinates1) {\n                other._randomNoiseCoordinates1.copyFrom(this._randomNoiseCoordinates1);\n                other._randomNoiseCoordinates2.copyFrom(this._randomNoiseCoordinates2);\n            }\n            else {\n                other._randomNoiseCoordinates1 = this._randomNoiseCoordinates1.clone();\n                other._randomNoiseCoordinates2 = this._randomNoiseCoordinates2.clone();\n            }\n        }\n    }\n}\nParticle._Count = 0;\n//# sourceMappingURL=particle.js.map","import { FactorGradient, ColorGradient, Color3Gradient, GradientHelper } from \"../Misc/gradients.js\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { Vector3, Matrix, TmpVectors, Vector4 } from \"../Maths/math.vector.js\";\nimport { Scalar } from \"../Maths/math.scalar.js\";\nimport { VertexBuffer, Buffer } from \"../Buffers/buffer.js\";\nimport { ImageProcessingConfiguration } from \"../Materials/imageProcessingConfiguration.js\";\nimport { RawTexture } from \"../Materials/Textures/rawTexture.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\nimport { BoxParticleEmitter, HemisphericParticleEmitter, SphereParticleEmitter, SphereDirectedParticleEmitter, CylinderParticleEmitter, ConeParticleEmitter, PointParticleEmitter, MeshParticleEmitter, CylinderDirectedParticleEmitter, } from \"../Particles/EmitterTypes/index.js\";\nimport { BaseParticleSystem } from \"./baseParticleSystem.js\";\nimport { Particle } from \"./particle.js\";\nimport { SubEmitter, SubEmitterType } from \"./subEmitter.js\";\n\nimport { SerializationHelper } from \"../Misc/decorators.js\";\nimport { GetClass } from \"../Misc/typeStore.js\";\nimport { DrawWrapper } from \"../Materials/drawWrapper.js\";\nimport \"../Shaders/particles.fragment.js\";\nimport \"../Shaders/particles.vertex.js\";\nimport { Color4, Color3, TmpColors } from \"../Maths/math.color.js\";\nimport { ThinEngine } from \"../Engines/thinEngine.js\";\nimport { MaterialHelper } from \"../Materials/materialHelper.js\";\nimport \"../Engines/Extensions/engine.alpha.js\";\nimport { addClipPlaneUniforms, prepareDefinesForClipPlanes, bindClipPlane } from \"../Materials/clipPlaneMaterialHelper.js\";\n/**\n * This represents a particle system in Babylon.\n * Particles are often small sprites used to simulate hard-to-reproduce phenomena like fire, smoke, water, or abstract visual effects like magic glitter and faery dust.\n * Particles can take different shapes while emitted like box, sphere, cone or you can write your custom function.\n * @example https://doc.babylonjs.com/features/featuresDeepDive/particles/particle_system/particle_system_intro\n */\nexport class ParticleSystem extends BaseParticleSystem {\n    /**\n     * Sets a callback that will be triggered when the system is disposed\n     */\n    set onDispose(callback) {\n        if (this._onDisposeObserver) {\n            this.onDisposeObservable.remove(this._onDisposeObserver);\n        }\n        this._onDisposeObserver = this.onDisposeObservable.add(callback);\n    }\n    /** Gets or sets a boolean indicating that ramp gradients must be used\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/particles/particle_system/particle_system_intro#ramp-gradients\n     */\n    get useRampGradients() {\n        return this._useRampGradients;\n    }\n    set useRampGradients(value) {\n        if (this._useRampGradients === value) {\n            return;\n        }\n        this._useRampGradients = value;\n        this._resetEffect();\n    }\n    //end of Sub-emitter\n    /**\n     * Gets the current list of active particles\n     */\n    get particles() {\n        return this._particles;\n    }\n    /**\n     * Gets the number of particles active at the same time.\n     * @returns The number of active particles.\n     */\n    getActiveCount() {\n        return this._particles.length;\n    }\n    /**\n     * Returns the string \"ParticleSystem\"\n     * @returns a string containing the class name\n     */\n    getClassName() {\n        return \"ParticleSystem\";\n    }\n    /**\n     * Gets a boolean indicating that the system is stopping\n     * @returns true if the system is currently stopping\n     */\n    isStopping() {\n        return this._stopped && this.isAlive();\n    }\n    /**\n     * Gets the custom effect used to render the particles\n     * @param blendMode Blend mode for which the effect should be retrieved\n     * @returns The effect\n     */\n    getCustomEffect(blendMode = 0) {\n        var _a, _b;\n        return (_b = (_a = this._customWrappers[blendMode]) === null || _a === void 0 ? void 0 : _a.effect) !== null && _b !== void 0 ? _b : this._customWrappers[0].effect;\n    }\n    _getCustomDrawWrapper(blendMode = 0) {\n        var _a;\n        return (_a = this._customWrappers[blendMode]) !== null && _a !== void 0 ? _a : this._customWrappers[0];\n    }\n    /**\n     * Sets the custom effect used to render the particles\n     * @param effect The effect to set\n     * @param blendMode Blend mode for which the effect should be set\n     */\n    setCustomEffect(effect, blendMode = 0) {\n        this._customWrappers[blendMode] = new DrawWrapper(this._engine);\n        this._customWrappers[blendMode].effect = effect;\n        if (this._customWrappers[blendMode].drawContext) {\n            this._customWrappers[blendMode].drawContext.useInstancing = this._useInstancing;\n        }\n    }\n    /**\n     * Observable that will be called just before the particles are drawn\n     */\n    get onBeforeDrawParticlesObservable() {\n        if (!this._onBeforeDrawParticlesObservable) {\n            this._onBeforeDrawParticlesObservable = new Observable();\n        }\n        return this._onBeforeDrawParticlesObservable;\n    }\n    /**\n     * Gets the name of the particle vertex shader\n     */\n    get vertexShaderName() {\n        return \"particles\";\n    }\n    /**\n     * Gets the vertex buffers used by the particle system\n     */\n    get vertexBuffers() {\n        return this._vertexBuffers;\n    }\n    /**\n     * Gets the index buffer used by the particle system (or null if no index buffer is used (if _useInstancing=true))\n     */\n    get indexBuffer() {\n        return this._indexBuffer;\n    }\n    /**\n     * Instantiates a particle system.\n     * Particles are often small sprites used to simulate hard-to-reproduce phenomena like fire, smoke, water, or abstract visual effects like magic glitter and faery dust.\n     * @param name The name of the particle system\n     * @param capacity The max number of particles alive at the same time\n     * @param sceneOrEngine The scene the particle system belongs to or the engine to use if no scene\n     * @param customEffect a custom effect used to change the way particles are rendered by default\n     * @param isAnimationSheetEnabled Must be true if using a spritesheet to animate the particles texture\n     * @param epsilon Offset used to render the particles\n     */\n    constructor(name, capacity, sceneOrEngine, customEffect = null, isAnimationSheetEnabled = false, epsilon = 0.01) {\n        super(name);\n        this._emitterInverseWorldMatrix = Matrix.Identity();\n        /**\n         * @internal\n         */\n        this._inheritedVelocityOffset = new Vector3();\n        /**\n         * An event triggered when the system is disposed\n         */\n        this.onDisposeObservable = new Observable();\n        /**\n         * An event triggered when the system is stopped\n         */\n        this.onStoppedObservable = new Observable();\n        this._particles = new Array();\n        this._stockParticles = new Array();\n        this._newPartsExcess = 0;\n        this._vertexBuffers = {};\n        this._scaledColorStep = new Color4(0, 0, 0, 0);\n        this._colorDiff = new Color4(0, 0, 0, 0);\n        this._scaledDirection = Vector3.Zero();\n        this._scaledGravity = Vector3.Zero();\n        this._currentRenderId = -1;\n        this._useInstancing = false;\n        this._started = false;\n        this._stopped = false;\n        this._actualFrame = 0;\n        /** @internal */\n        this._currentEmitRate1 = 0;\n        /** @internal */\n        this._currentEmitRate2 = 0;\n        /** @internal */\n        this._currentStartSize1 = 0;\n        /** @internal */\n        this._currentStartSize2 = 0;\n        /** Indicates that the update of particles is done in the animate function */\n        this.updateInAnimate = true;\n        this._rawTextureWidth = 256;\n        this._useRampGradients = false;\n        /**\n         * @internal\n         * If the particle systems emitter should be disposed when the particle system is disposed\n         */\n        this._disposeEmitterOnDispose = false;\n        /**\n         * Specifies if the particles are updated in emitter local space or world space\n         */\n        this.isLocal = false;\n        /** Indicates that the particle system is CPU based */\n        this.isGPU = false;\n        /** @internal */\n        this._onBeforeDrawParticlesObservable = null;\n        // start of sub system methods\n        /**\n         * \"Recycles\" one of the particle by copying it back to the \"stock\" of particles and removing it from the active list.\n         * Its lifetime will start back at 0.\n         * @param particle\n         */\n        this.recycleParticle = (particle) => {\n            // move particle from activeParticle list to stock particles\n            const lastParticle = this._particles.pop();\n            if (lastParticle !== particle) {\n                lastParticle.copyTo(particle);\n            }\n            this._stockParticles.push(lastParticle);\n        };\n        this._createParticle = () => {\n            let particle;\n            if (this._stockParticles.length !== 0) {\n                particle = this._stockParticles.pop();\n                particle._reset();\n            }\n            else {\n                particle = new Particle(this);\n            }\n            // Attach emitters\n            if (this._subEmitters && this._subEmitters.length > 0) {\n                const subEmitters = this._subEmitters[Math.floor(Math.random() * this._subEmitters.length)];\n                particle._attachedSubEmitters = [];\n                subEmitters.forEach((subEmitter) => {\n                    if (subEmitter.type === SubEmitterType.ATTACHED) {\n                        const newEmitter = subEmitter.clone();\n                        particle._attachedSubEmitters.push(newEmitter);\n                        newEmitter.particleSystem.start();\n                    }\n                });\n            }\n            return particle;\n        };\n        this._emitFromParticle = (particle) => {\n            if (!this._subEmitters || this._subEmitters.length === 0) {\n                return;\n            }\n            const templateIndex = Math.floor(Math.random() * this._subEmitters.length);\n            this._subEmitters[templateIndex].forEach((subEmitter) => {\n                if (subEmitter.type === SubEmitterType.END) {\n                    const subSystem = subEmitter.clone();\n                    particle._inheritParticleInfoToSubEmitter(subSystem);\n                    subSystem.particleSystem._rootParticleSystem = this;\n                    this.activeSubSystems.push(subSystem.particleSystem);\n                    subSystem.particleSystem.start();\n                }\n            });\n        };\n        this._capacity = capacity;\n        this._epsilon = epsilon;\n        this._isAnimationSheetEnabled = isAnimationSheetEnabled;\n        if (!sceneOrEngine || sceneOrEngine.getClassName() === \"Scene\") {\n            this._scene = sceneOrEngine || EngineStore.LastCreatedScene;\n            this._engine = this._scene.getEngine();\n            this.uniqueId = this._scene.getUniqueId();\n            this._scene.particleSystems.push(this);\n        }\n        else {\n            this._engine = sceneOrEngine;\n            this.defaultProjectionMatrix = Matrix.PerspectiveFovLH(0.8, 1, 0.1, 100, this._engine.isNDCHalfZRange);\n        }\n        if (this._engine.getCaps().vertexArrayObject) {\n            this._vertexArrayObject = null;\n        }\n        // Setup the default processing configuration to the scene.\n        this._attachImageProcessingConfiguration(null);\n        // eslint-disable-next-line @typescript-eslint/naming-convention\n        this._customWrappers = { 0: new DrawWrapper(this._engine) };\n        this._customWrappers[0].effect = customEffect;\n        this._drawWrappers = [];\n        this._useInstancing = this._engine.getCaps().instancedArrays;\n        this._createIndexBuffer();\n        this._createVertexBuffers();\n        // Default emitter type\n        this.particleEmitterType = new BoxParticleEmitter();\n        let noiseTextureData = null;\n        // Update\n        this.updateFunction = (particles) => {\n            var _a;\n            let noiseTextureSize = null;\n            if (this.noiseTexture) {\n                // We need to get texture data back to CPU\n                noiseTextureSize = this.noiseTexture.getSize();\n                (_a = this.noiseTexture.getContent()) === null || _a === void 0 ? void 0 : _a.then((data) => {\n                    noiseTextureData = data;\n                });\n            }\n            for (let index = 0; index < particles.length; index++) {\n                const particle = particles[index];\n                let scaledUpdateSpeed = this._scaledUpdateSpeed;\n                const previousAge = particle.age;\n                particle.age += scaledUpdateSpeed;\n                // Evaluate step to death\n                if (particle.age > particle.lifeTime) {\n                    const diff = particle.age - previousAge;\n                    const oldDiff = particle.lifeTime - previousAge;\n                    scaledUpdateSpeed = (oldDiff * scaledUpdateSpeed) / diff;\n                    particle.age = particle.lifeTime;\n                }\n                const ratio = particle.age / particle.lifeTime;\n                // Color\n                if (this._colorGradients && this._colorGradients.length > 0) {\n                    GradientHelper.GetCurrentGradient(ratio, this._colorGradients, (currentGradient, nextGradient, scale) => {\n                        if (currentGradient !== particle._currentColorGradient) {\n                            particle._currentColor1.copyFrom(particle._currentColor2);\n                            nextGradient.getColorToRef(particle._currentColor2);\n                            particle._currentColorGradient = currentGradient;\n                        }\n                        Color4.LerpToRef(particle._currentColor1, particle._currentColor2, scale, particle.color);\n                    });\n                }\n                else {\n                    particle.colorStep.scaleToRef(scaledUpdateSpeed, this._scaledColorStep);\n                    particle.color.addInPlace(this._scaledColorStep);\n                    if (particle.color.a < 0) {\n                        particle.color.a = 0;\n                    }\n                }\n                // Angular speed\n                if (this._angularSpeedGradients && this._angularSpeedGradients.length > 0) {\n                    GradientHelper.GetCurrentGradient(ratio, this._angularSpeedGradients, (currentGradient, nextGradient, scale) => {\n                        if (currentGradient !== particle._currentAngularSpeedGradient) {\n                            particle._currentAngularSpeed1 = particle._currentAngularSpeed2;\n                            particle._currentAngularSpeed2 = nextGradient.getFactor();\n                            particle._currentAngularSpeedGradient = currentGradient;\n                        }\n                        particle.angularSpeed = Scalar.Lerp(particle._currentAngularSpeed1, particle._currentAngularSpeed2, scale);\n                    });\n                }\n                particle.angle += particle.angularSpeed * scaledUpdateSpeed;\n                // Direction\n                let directionScale = scaledUpdateSpeed;\n                /// Velocity\n                if (this._velocityGradients && this._velocityGradients.length > 0) {\n                    GradientHelper.GetCurrentGradient(ratio, this._velocityGradients, (currentGradient, nextGradient, scale) => {\n                        if (currentGradient !== particle._currentVelocityGradient) {\n                            particle._currentVelocity1 = particle._currentVelocity2;\n                            particle._currentVelocity2 = nextGradient.getFactor();\n                            particle._currentVelocityGradient = currentGradient;\n                        }\n                        directionScale *= Scalar.Lerp(particle._currentVelocity1, particle._currentVelocity2, scale);\n                    });\n                }\n                particle.direction.scaleToRef(directionScale, this._scaledDirection);\n                /// Limit velocity\n                if (this._limitVelocityGradients && this._limitVelocityGradients.length > 0) {\n                    GradientHelper.GetCurrentGradient(ratio, this._limitVelocityGradients, (currentGradient, nextGradient, scale) => {\n                        if (currentGradient !== particle._currentLimitVelocityGradient) {\n                            particle._currentLimitVelocity1 = particle._currentLimitVelocity2;\n                            particle._currentLimitVelocity2 = nextGradient.getFactor();\n                            particle._currentLimitVelocityGradient = currentGradient;\n                        }\n                        const limitVelocity = Scalar.Lerp(particle._currentLimitVelocity1, particle._currentLimitVelocity2, scale);\n                        const currentVelocity = particle.direction.length();\n                        if (currentVelocity > limitVelocity) {\n                            particle.direction.scaleInPlace(this.limitVelocityDamping);\n                        }\n                    });\n                }\n                /// Drag\n                if (this._dragGradients && this._dragGradients.length > 0) {\n                    GradientHelper.GetCurrentGradient(ratio, this._dragGradients, (currentGradient, nextGradient, scale) => {\n                        if (currentGradient !== particle._currentDragGradient) {\n                            particle._currentDrag1 = particle._currentDrag2;\n                            particle._currentDrag2 = nextGradient.getFactor();\n                            particle._currentDragGradient = currentGradient;\n                        }\n                        const drag = Scalar.Lerp(particle._currentDrag1, particle._currentDrag2, scale);\n                        this._scaledDirection.scaleInPlace(1.0 - drag);\n                    });\n                }\n                if (this.isLocal && particle._localPosition) {\n                    particle._localPosition.addInPlace(this._scaledDirection);\n                    Vector3.TransformCoordinatesToRef(particle._localPosition, this._emitterWorldMatrix, particle.position);\n                }\n                else {\n                    particle.position.addInPlace(this._scaledDirection);\n                }\n                // Noise\n                if (noiseTextureData && noiseTextureSize && particle._randomNoiseCoordinates1) {\n                    const fetchedColorR = this._fetchR(particle._randomNoiseCoordinates1.x, particle._randomNoiseCoordinates1.y, noiseTextureSize.width, noiseTextureSize.height, noiseTextureData);\n                    const fetchedColorG = this._fetchR(particle._randomNoiseCoordinates1.z, particle._randomNoiseCoordinates2.x, noiseTextureSize.width, noiseTextureSize.height, noiseTextureData);\n                    const fetchedColorB = this._fetchR(particle._randomNoiseCoordinates2.y, particle._randomNoiseCoordinates2.z, noiseTextureSize.width, noiseTextureSize.height, noiseTextureData);\n                    const force = TmpVectors.Vector3[0];\n                    const scaledForce = TmpVectors.Vector3[1];\n                    force.copyFromFloats((2 * fetchedColorR - 1) * this.noiseStrength.x, (2 * fetchedColorG - 1) * this.noiseStrength.y, (2 * fetchedColorB - 1) * this.noiseStrength.z);\n                    force.scaleToRef(scaledUpdateSpeed, scaledForce);\n                    particle.direction.addInPlace(scaledForce);\n                }\n                // Gravity\n                this.gravity.scaleToRef(scaledUpdateSpeed, this._scaledGravity);\n                particle.direction.addInPlace(this._scaledGravity);\n                // Size\n                if (this._sizeGradients && this._sizeGradients.length > 0) {\n                    GradientHelper.GetCurrentGradient(ratio, this._sizeGradients, (currentGradient, nextGradient, scale) => {\n                        if (currentGradient !== particle._currentSizeGradient) {\n                            particle._currentSize1 = particle._currentSize2;\n                            particle._currentSize2 = nextGradient.getFactor();\n                            particle._currentSizeGradient = currentGradient;\n                        }\n                        particle.size = Scalar.Lerp(particle._currentSize1, particle._currentSize2, scale);\n                    });\n                }\n                // Remap data\n                if (this._useRampGradients) {\n                    if (this._colorRemapGradients && this._colorRemapGradients.length > 0) {\n                        GradientHelper.GetCurrentGradient(ratio, this._colorRemapGradients, (currentGradient, nextGradient, scale) => {\n                            const min = Scalar.Lerp(currentGradient.factor1, nextGradient.factor1, scale);\n                            const max = Scalar.Lerp(currentGradient.factor2, nextGradient.factor2, scale);\n                            particle.remapData.x = min;\n                            particle.remapData.y = max - min;\n                        });\n                    }\n                    if (this._alphaRemapGradients && this._alphaRemapGradients.length > 0) {\n                        GradientHelper.GetCurrentGradient(ratio, this._alphaRemapGradients, (currentGradient, nextGradient, scale) => {\n                            const min = Scalar.Lerp(currentGradient.factor1, nextGradient.factor1, scale);\n                            const max = Scalar.Lerp(currentGradient.factor2, nextGradient.factor2, scale);\n                            particle.remapData.z = min;\n                            particle.remapData.w = max - min;\n                        });\n                    }\n                }\n                if (this._isAnimationSheetEnabled) {\n                    particle.updateCellIndex();\n                }\n                // Update the position of the attached sub-emitters to match their attached particle\n                particle._inheritParticleInfoToSubEmitters();\n                if (particle.age >= particle.lifeTime) {\n                    // Recycle by swapping with last particle\n                    this._emitFromParticle(particle);\n                    if (particle._attachedSubEmitters) {\n                        particle._attachedSubEmitters.forEach((subEmitter) => {\n                            subEmitter.particleSystem.disposeOnStop = true;\n                            subEmitter.particleSystem.stop();\n                        });\n                        particle._attachedSubEmitters = null;\n                    }\n                    this.recycleParticle(particle);\n                    index--;\n                    continue;\n                }\n            }\n        };\n    }\n    _addFactorGradient(factorGradients, gradient, factor, factor2) {\n        const newGradient = new FactorGradient(gradient, factor, factor2);\n        factorGradients.push(newGradient);\n        factorGradients.sort((a, b) => {\n            if (a.gradient < b.gradient) {\n                return -1;\n            }\n            else if (a.gradient > b.gradient) {\n                return 1;\n            }\n            return 0;\n        });\n    }\n    _removeFactorGradient(factorGradients, gradient) {\n        if (!factorGradients) {\n            return;\n        }\n        let index = 0;\n        for (const factorGradient of factorGradients) {\n            if (factorGradient.gradient === gradient) {\n                factorGradients.splice(index, 1);\n                break;\n            }\n            index++;\n        }\n    }\n    /**\n     * Adds a new life time gradient\n     * @param gradient defines the gradient to use (between 0 and 1)\n     * @param factor defines the life time factor to affect to the specified gradient\n     * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from\n     * @returns the current particle system\n     */\n    addLifeTimeGradient(gradient, factor, factor2) {\n        if (!this._lifeTimeGradients) {\n            this._lifeTimeGradients = [];\n        }\n        this._addFactorGradient(this._lifeTimeGradients, gradient, factor, factor2);\n        return this;\n    }\n    /**\n     * Remove a specific life time gradient\n     * @param gradient defines the gradient to remove\n     * @returns the current particle system\n     */\n    removeLifeTimeGradient(gradient) {\n        this._removeFactorGradient(this._lifeTimeGradients, gradient);\n        return this;\n    }\n    /**\n     * Adds a new size gradient\n     * @param gradient defines the gradient to use (between 0 and 1)\n     * @param factor defines the size factor to affect to the specified gradient\n     * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from\n     * @returns the current particle system\n     */\n    addSizeGradient(gradient, factor, factor2) {\n        if (!this._sizeGradients) {\n            this._sizeGradients = [];\n        }\n        this._addFactorGradient(this._sizeGradients, gradient, factor, factor2);\n        return this;\n    }\n    /**\n     * Remove a specific size gradient\n     * @param gradient defines the gradient to remove\n     * @returns the current particle system\n     */\n    removeSizeGradient(gradient) {\n        this._removeFactorGradient(this._sizeGradients, gradient);\n        return this;\n    }\n    /**\n     * Adds a new color remap gradient\n     * @param gradient defines the gradient to use (between 0 and 1)\n     * @param min defines the color remap minimal range\n     * @param max defines the color remap maximal range\n     * @returns the current particle system\n     */\n    addColorRemapGradient(gradient, min, max) {\n        if (!this._colorRemapGradients) {\n            this._colorRemapGradients = [];\n        }\n        this._addFactorGradient(this._colorRemapGradients, gradient, min, max);\n        return this;\n    }\n    /**\n     * Remove a specific color remap gradient\n     * @param gradient defines the gradient to remove\n     * @returns the current particle system\n     */\n    removeColorRemapGradient(gradient) {\n        this._removeFactorGradient(this._colorRemapGradients, gradient);\n        return this;\n    }\n    /**\n     * Adds a new alpha remap gradient\n     * @param gradient defines the gradient to use (between 0 and 1)\n     * @param min defines the alpha remap minimal range\n     * @param max defines the alpha remap maximal range\n     * @returns the current particle system\n     */\n    addAlphaRemapGradient(gradient, min, max) {\n        if (!this._alphaRemapGradients) {\n            this._alphaRemapGradients = [];\n        }\n        this._addFactorGradient(this._alphaRemapGradients, gradient, min, max);\n        return this;\n    }\n    /**\n     * Remove a specific alpha remap gradient\n     * @param gradient defines the gradient to remove\n     * @returns the current particle system\n     */\n    removeAlphaRemapGradient(gradient) {\n        this._removeFactorGradient(this._alphaRemapGradients, gradient);\n        return this;\n    }\n    /**\n     * Adds a new angular speed gradient\n     * @param gradient defines the gradient to use (between 0 and 1)\n     * @param factor defines the angular speed  to affect to the specified gradient\n     * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from\n     * @returns the current particle system\n     */\n    addAngularSpeedGradient(gradient, factor, factor2) {\n        if (!this._angularSpeedGradients) {\n            this._angularSpeedGradients = [];\n        }\n        this._addFactorGradient(this._angularSpeedGradients, gradient, factor, factor2);\n        return this;\n    }\n    /**\n     * Remove a specific angular speed gradient\n     * @param gradient defines the gradient to remove\n     * @returns the current particle system\n     */\n    removeAngularSpeedGradient(gradient) {\n        this._removeFactorGradient(this._angularSpeedGradients, gradient);\n        return this;\n    }\n    /**\n     * Adds a new velocity gradient\n     * @param gradient defines the gradient to use (between 0 and 1)\n     * @param factor defines the velocity to affect to the specified gradient\n     * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from\n     * @returns the current particle system\n     */\n    addVelocityGradient(gradient, factor, factor2) {\n        if (!this._velocityGradients) {\n            this._velocityGradients = [];\n        }\n        this._addFactorGradient(this._velocityGradients, gradient, factor, factor2);\n        return this;\n    }\n    /**\n     * Remove a specific velocity gradient\n     * @param gradient defines the gradient to remove\n     * @returns the current particle system\n     */\n    removeVelocityGradient(gradient) {\n        this._removeFactorGradient(this._velocityGradients, gradient);\n        return this;\n    }\n    /**\n     * Adds a new limit velocity gradient\n     * @param gradient defines the gradient to use (between 0 and 1)\n     * @param factor defines the limit velocity value to affect to the specified gradient\n     * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from\n     * @returns the current particle system\n     */\n    addLimitVelocityGradient(gradient, factor, factor2) {\n        if (!this._limitVelocityGradients) {\n            this._limitVelocityGradients = [];\n        }\n        this._addFactorGradient(this._limitVelocityGradients, gradient, factor, factor2);\n        return this;\n    }\n    /**\n     * Remove a specific limit velocity gradient\n     * @param gradient defines the gradient to remove\n     * @returns the current particle system\n     */\n    removeLimitVelocityGradient(gradient) {\n        this._removeFactorGradient(this._limitVelocityGradients, gradient);\n        return this;\n    }\n    /**\n     * Adds a new drag gradient\n     * @param gradient defines the gradient to use (between 0 and 1)\n     * @param factor defines the drag value to affect to the specified gradient\n     * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from\n     * @returns the current particle system\n     */\n    addDragGradient(gradient, factor, factor2) {\n        if (!this._dragGradients) {\n            this._dragGradients = [];\n        }\n        this._addFactorGradient(this._dragGradients, gradient, factor, factor2);\n        return this;\n    }\n    /**\n     * Remove a specific drag gradient\n     * @param gradient defines the gradient to remove\n     * @returns the current particle system\n     */\n    removeDragGradient(gradient) {\n        this._removeFactorGradient(this._dragGradients, gradient);\n        return this;\n    }\n    /**\n     * Adds a new emit rate gradient (please note that this will only work if you set the targetStopDuration property)\n     * @param gradient defines the gradient to use (between 0 and 1)\n     * @param factor defines the emit rate value to affect to the specified gradient\n     * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from\n     * @returns the current particle system\n     */\n    addEmitRateGradient(gradient, factor, factor2) {\n        if (!this._emitRateGradients) {\n            this._emitRateGradients = [];\n        }\n        this._addFactorGradient(this._emitRateGradients, gradient, factor, factor2);\n        return this;\n    }\n    /**\n     * Remove a specific emit rate gradient\n     * @param gradient defines the gradient to remove\n     * @returns the current particle system\n     */\n    removeEmitRateGradient(gradient) {\n        this._removeFactorGradient(this._emitRateGradients, gradient);\n        return this;\n    }\n    /**\n     * Adds a new start size gradient (please note that this will only work if you set the targetStopDuration property)\n     * @param gradient defines the gradient to use (between 0 and 1)\n     * @param factor defines the start size value to affect to the specified gradient\n     * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from\n     * @returns the current particle system\n     */\n    addStartSizeGradient(gradient, factor, factor2) {\n        if (!this._startSizeGradients) {\n            this._startSizeGradients = [];\n        }\n        this._addFactorGradient(this._startSizeGradients, gradient, factor, factor2);\n        return this;\n    }\n    /**\n     * Remove a specific start size gradient\n     * @param gradient defines the gradient to remove\n     * @returns the current particle system\n     */\n    removeStartSizeGradient(gradient) {\n        this._removeFactorGradient(this._startSizeGradients, gradient);\n        return this;\n    }\n    _createRampGradientTexture() {\n        if (!this._rampGradients || !this._rampGradients.length || this._rampGradientsTexture || !this._scene) {\n            return;\n        }\n        const data = new Uint8Array(this._rawTextureWidth * 4);\n        const tmpColor = TmpColors.Color3[0];\n        for (let x = 0; x < this._rawTextureWidth; x++) {\n            const ratio = x / this._rawTextureWidth;\n            GradientHelper.GetCurrentGradient(ratio, this._rampGradients, (currentGradient, nextGradient, scale) => {\n                Color3.LerpToRef(currentGradient.color, nextGradient.color, scale, tmpColor);\n                data[x * 4] = tmpColor.r * 255;\n                data[x * 4 + 1] = tmpColor.g * 255;\n                data[x * 4 + 2] = tmpColor.b * 255;\n                data[x * 4 + 3] = 255;\n            });\n        }\n        this._rampGradientsTexture = RawTexture.CreateRGBATexture(data, this._rawTextureWidth, 1, this._scene, false, false, 1);\n    }\n    /**\n     * Gets the current list of ramp gradients.\n     * You must use addRampGradient and removeRampGradient to update this list\n     * @returns the list of ramp gradients\n     */\n    getRampGradients() {\n        return this._rampGradients;\n    }\n    /** Force the system to rebuild all gradients that need to be resync */\n    forceRefreshGradients() {\n        this._syncRampGradientTexture();\n    }\n    _syncRampGradientTexture() {\n        if (!this._rampGradients) {\n            return;\n        }\n        this._rampGradients.sort((a, b) => {\n            if (a.gradient < b.gradient) {\n                return -1;\n            }\n            else if (a.gradient > b.gradient) {\n                return 1;\n            }\n            return 0;\n        });\n        if (this._rampGradientsTexture) {\n            this._rampGradientsTexture.dispose();\n            this._rampGradientsTexture = null;\n        }\n        this._createRampGradientTexture();\n    }\n    /**\n     * Adds a new ramp gradient used to remap particle colors\n     * @param gradient defines the gradient to use (between 0 and 1)\n     * @param color defines the color to affect to the specified gradient\n     * @returns the current particle system\n     */\n    addRampGradient(gradient, color) {\n        if (!this._rampGradients) {\n            this._rampGradients = [];\n        }\n        const rampGradient = new Color3Gradient(gradient, color);\n        this._rampGradients.push(rampGradient);\n        this._syncRampGradientTexture();\n        return this;\n    }\n    /**\n     * Remove a specific ramp gradient\n     * @param gradient defines the gradient to remove\n     * @returns the current particle system\n     */\n    removeRampGradient(gradient) {\n        this._removeGradientAndTexture(gradient, this._rampGradients, this._rampGradientsTexture);\n        this._rampGradientsTexture = null;\n        if (this._rampGradients && this._rampGradients.length > 0) {\n            this._createRampGradientTexture();\n        }\n        return this;\n    }\n    /**\n     * Adds a new color gradient\n     * @param gradient defines the gradient to use (between 0 and 1)\n     * @param color1 defines the color to affect to the specified gradient\n     * @param color2 defines an additional color used to define a range ([color, color2]) with main color to pick the final color from\n     * @returns this particle system\n     */\n    addColorGradient(gradient, color1, color2) {\n        if (!this._colorGradients) {\n            this._colorGradients = [];\n        }\n        const colorGradient = new ColorGradient(gradient, color1, color2);\n        this._colorGradients.push(colorGradient);\n        this._colorGradients.sort((a, b) => {\n            if (a.gradient < b.gradient) {\n                return -1;\n            }\n            else if (a.gradient > b.gradient) {\n                return 1;\n            }\n            return 0;\n        });\n        return this;\n    }\n    /**\n     * Remove a specific color gradient\n     * @param gradient defines the gradient to remove\n     * @returns this particle system\n     */\n    removeColorGradient(gradient) {\n        if (!this._colorGradients) {\n            return this;\n        }\n        let index = 0;\n        for (const colorGradient of this._colorGradients) {\n            if (colorGradient.gradient === gradient) {\n                this._colorGradients.splice(index, 1);\n                break;\n            }\n            index++;\n        }\n        return this;\n    }\n    /**\n     * Resets the draw wrappers cache\n     */\n    resetDrawCache() {\n        for (const drawWrappers of this._drawWrappers) {\n            if (drawWrappers) {\n                for (const drawWrapper of drawWrappers) {\n                    drawWrapper === null || drawWrapper === void 0 ? void 0 : drawWrapper.dispose();\n                }\n            }\n        }\n        this._drawWrappers = [];\n    }\n    _fetchR(u, v, width, height, pixels) {\n        u = Math.abs(u) * 0.5 + 0.5;\n        v = Math.abs(v) * 0.5 + 0.5;\n        const wrappedU = (u * width) % width | 0;\n        const wrappedV = (v * height) % height | 0;\n        const position = (wrappedU + wrappedV * width) * 4;\n        return pixels[position] / 255;\n    }\n    _reset() {\n        this._resetEffect();\n    }\n    _resetEffect() {\n        if (this._vertexBuffer) {\n            this._vertexBuffer.dispose();\n            this._vertexBuffer = null;\n        }\n        if (this._spriteBuffer) {\n            this._spriteBuffer.dispose();\n            this._spriteBuffer = null;\n        }\n        if (this._vertexArrayObject) {\n            this._engine.releaseVertexArrayObject(this._vertexArrayObject);\n            this._vertexArrayObject = null;\n        }\n        this._createVertexBuffers();\n    }\n    _createVertexBuffers() {\n        this._vertexBufferSize = this._useInstancing ? 10 : 12;\n        if (this._isAnimationSheetEnabled) {\n            this._vertexBufferSize += 1;\n        }\n        if (!this._isBillboardBased || this.billboardMode === ParticleSystem.BILLBOARDMODE_STRETCHED || this.billboardMode === ParticleSystem.BILLBOARDMODE_STRETCHED_LOCAL) {\n            this._vertexBufferSize += 3;\n        }\n        if (this._useRampGradients) {\n            this._vertexBufferSize += 4;\n        }\n        const engine = this._engine;\n        const vertexSize = this._vertexBufferSize * (this._useInstancing ? 1 : 4);\n        this._vertexData = new Float32Array(this._capacity * vertexSize);\n        this._vertexBuffer = new Buffer(engine, this._vertexData, true, vertexSize);\n        let dataOffset = 0;\n        const positions = this._vertexBuffer.createVertexBuffer(VertexBuffer.PositionKind, dataOffset, 3, this._vertexBufferSize, this._useInstancing);\n        this._vertexBuffers[VertexBuffer.PositionKind] = positions;\n        dataOffset += 3;\n        const colors = this._vertexBuffer.createVertexBuffer(VertexBuffer.ColorKind, dataOffset, 4, this._vertexBufferSize, this._useInstancing);\n        this._vertexBuffers[VertexBuffer.ColorKind] = colors;\n        dataOffset += 4;\n        const options = this._vertexBuffer.createVertexBuffer(\"angle\", dataOffset, 1, this._vertexBufferSize, this._useInstancing);\n        this._vertexBuffers[\"angle\"] = options;\n        dataOffset += 1;\n        const size = this._vertexBuffer.createVertexBuffer(\"size\", dataOffset, 2, this._vertexBufferSize, this._useInstancing);\n        this._vertexBuffers[\"size\"] = size;\n        dataOffset += 2;\n        if (this._isAnimationSheetEnabled) {\n            const cellIndexBuffer = this._vertexBuffer.createVertexBuffer(\"cellIndex\", dataOffset, 1, this._vertexBufferSize, this._useInstancing);\n            this._vertexBuffers[\"cellIndex\"] = cellIndexBuffer;\n            dataOffset += 1;\n        }\n        if (!this._isBillboardBased || this.billboardMode === ParticleSystem.BILLBOARDMODE_STRETCHED || this.billboardMode === ParticleSystem.BILLBOARDMODE_STRETCHED_LOCAL) {\n            const directionBuffer = this._vertexBuffer.createVertexBuffer(\"direction\", dataOffset, 3, this._vertexBufferSize, this._useInstancing);\n            this._vertexBuffers[\"direction\"] = directionBuffer;\n            dataOffset += 3;\n        }\n        if (this._useRampGradients) {\n            const rampDataBuffer = this._vertexBuffer.createVertexBuffer(\"remapData\", dataOffset, 4, this._vertexBufferSize, this._useInstancing);\n            this._vertexBuffers[\"remapData\"] = rampDataBuffer;\n            dataOffset += 4;\n        }\n        let offsets;\n        if (this._useInstancing) {\n            const spriteData = new Float32Array([0, 0, 1, 0, 0, 1, 1, 1]);\n            this._spriteBuffer = new Buffer(engine, spriteData, false, 2);\n            offsets = this._spriteBuffer.createVertexBuffer(\"offset\", 0, 2);\n        }\n        else {\n            offsets = this._vertexBuffer.createVertexBuffer(\"offset\", dataOffset, 2, this._vertexBufferSize, this._useInstancing);\n            dataOffset += 2;\n        }\n        this._vertexBuffers[\"offset\"] = offsets;\n        this.resetDrawCache();\n    }\n    _createIndexBuffer() {\n        if (this._useInstancing) {\n            return;\n        }\n        const indices = [];\n        let index = 0;\n        for (let count = 0; count < this._capacity; count++) {\n            indices.push(index);\n            indices.push(index + 1);\n            indices.push(index + 2);\n            indices.push(index);\n            indices.push(index + 2);\n            indices.push(index + 3);\n            index += 4;\n        }\n        this._indexBuffer = this._engine.createIndexBuffer(indices);\n    }\n    /**\n     * Gets the maximum number of particles active at the same time.\n     * @returns The max number of active particles.\n     */\n    getCapacity() {\n        return this._capacity;\n    }\n    /**\n     * Gets whether there are still active particles in the system.\n     * @returns True if it is alive, otherwise false.\n     */\n    isAlive() {\n        return this._alive;\n    }\n    /**\n     * Gets if the system has been started. (Note: this will still be true after stop is called)\n     * @returns True if it has been started, otherwise false.\n     */\n    isStarted() {\n        return this._started;\n    }\n    _prepareSubEmitterInternalArray() {\n        this._subEmitters = new Array();\n        if (this.subEmitters) {\n            this.subEmitters.forEach((subEmitter) => {\n                if (subEmitter instanceof ParticleSystem) {\n                    this._subEmitters.push([new SubEmitter(subEmitter)]);\n                }\n                else if (subEmitter instanceof SubEmitter) {\n                    this._subEmitters.push([subEmitter]);\n                }\n                else if (subEmitter instanceof Array) {\n                    this._subEmitters.push(subEmitter);\n                }\n            });\n        }\n    }\n    /**\n     * Starts the particle system and begins to emit\n     * @param delay defines the delay in milliseconds before starting the system (this.startDelay by default)\n     */\n    start(delay = this.startDelay) {\n        var _a;\n        if (!this.targetStopDuration && this._hasTargetStopDurationDependantGradient()) {\n            throw \"Particle system started with a targetStopDuration dependant gradient (eg. startSizeGradients) but no targetStopDuration set\";\n        }\n        if (delay) {\n            setTimeout(() => {\n                this.start(0);\n            }, delay);\n            return;\n        }\n        // Convert the subEmitters field to the constant type field _subEmitters\n        this._prepareSubEmitterInternalArray();\n        this._started = true;\n        this._stopped = false;\n        this._actualFrame = 0;\n        if (this._subEmitters && this._subEmitters.length != 0) {\n            this.activeSubSystems = new Array();\n        }\n        // Reset emit gradient so it acts the same on every start\n        if (this._emitRateGradients) {\n            if (this._emitRateGradients.length > 0) {\n                this._currentEmitRateGradient = this._emitRateGradients[0];\n                this._currentEmitRate1 = this._currentEmitRateGradient.getFactor();\n                this._currentEmitRate2 = this._currentEmitRate1;\n            }\n            if (this._emitRateGradients.length > 1) {\n                this._currentEmitRate2 = this._emitRateGradients[1].getFactor();\n            }\n        }\n        // Reset start size gradient so it acts the same on every start\n        if (this._startSizeGradients) {\n            if (this._startSizeGradients.length > 0) {\n                this._currentStartSizeGradient = this._startSizeGradients[0];\n                this._currentStartSize1 = this._currentStartSizeGradient.getFactor();\n                this._currentStartSize2 = this._currentStartSize1;\n            }\n            if (this._startSizeGradients.length > 1) {\n                this._currentStartSize2 = this._startSizeGradients[1].getFactor();\n            }\n        }\n        if (this.preWarmCycles) {\n            if (((_a = this.emitter) === null || _a === void 0 ? void 0 : _a.getClassName().indexOf(\"Mesh\")) !== -1) {\n                this.emitter.computeWorldMatrix(true);\n            }\n            const noiseTextureAsProcedural = this.noiseTexture;\n            if (noiseTextureAsProcedural && noiseTextureAsProcedural.onGeneratedObservable) {\n                noiseTextureAsProcedural.onGeneratedObservable.addOnce(() => {\n                    setTimeout(() => {\n                        for (let index = 0; index < this.preWarmCycles; index++) {\n                            this.animate(true);\n                            noiseTextureAsProcedural.render();\n                        }\n                    });\n                });\n            }\n            else {\n                for (let index = 0; index < this.preWarmCycles; index++) {\n                    this.animate(true);\n                }\n            }\n        }\n        // Animations\n        if (this.beginAnimationOnStart && this.animations && this.animations.length > 0 && this._scene) {\n            this._scene.beginAnimation(this, this.beginAnimationFrom, this.beginAnimationTo, this.beginAnimationLoop);\n        }\n    }\n    /**\n     * Stops the particle system.\n     * @param stopSubEmitters if true it will stop the current system and all created sub-Systems if false it will stop the current root system only, this param is used by the root particle system only. the default value is true.\n     */\n    stop(stopSubEmitters = true) {\n        if (this._stopped) {\n            return;\n        }\n        this.onStoppedObservable.notifyObservers(this);\n        this._stopped = true;\n        if (stopSubEmitters) {\n            this._stopSubEmitters();\n        }\n    }\n    // animation sheet\n    /**\n     * Remove all active particles\n     */\n    reset() {\n        this._stockParticles.length = 0;\n        this._particles.length = 0;\n    }\n    /**\n     * @internal (for internal use only)\n     */\n    _appendParticleVertex(index, particle, offsetX, offsetY) {\n        let offset = index * this._vertexBufferSize;\n        this._vertexData[offset++] = particle.position.x + this.worldOffset.x;\n        this._vertexData[offset++] = particle.position.y + this.worldOffset.y;\n        this._vertexData[offset++] = particle.position.z + this.worldOffset.z;\n        this._vertexData[offset++] = particle.color.r;\n        this._vertexData[offset++] = particle.color.g;\n        this._vertexData[offset++] = particle.color.b;\n        this._vertexData[offset++] = particle.color.a;\n        this._vertexData[offset++] = particle.angle;\n        this._vertexData[offset++] = particle.scale.x * particle.size;\n        this._vertexData[offset++] = particle.scale.y * particle.size;\n        if (this._isAnimationSheetEnabled) {\n            this._vertexData[offset++] = particle.cellIndex;\n        }\n        if (!this._isBillboardBased) {\n            if (particle._initialDirection) {\n                let initialDirection = particle._initialDirection;\n                if (this.isLocal) {\n                    Vector3.TransformNormalToRef(initialDirection, this._emitterWorldMatrix, TmpVectors.Vector3[0]);\n                    initialDirection = TmpVectors.Vector3[0];\n                }\n                if (initialDirection.x === 0 && initialDirection.z === 0) {\n                    initialDirection.x = 0.001;\n                }\n                this._vertexData[offset++] = initialDirection.x;\n                this._vertexData[offset++] = initialDirection.y;\n                this._vertexData[offset++] = initialDirection.z;\n            }\n            else {\n                let direction = particle.direction;\n                if (this.isLocal) {\n                    Vector3.TransformNormalToRef(direction, this._emitterWorldMatrix, TmpVectors.Vector3[0]);\n                    direction = TmpVectors.Vector3[0];\n                }\n                if (direction.x === 0 && direction.z === 0) {\n                    direction.x = 0.001;\n                }\n                this._vertexData[offset++] = direction.x;\n                this._vertexData[offset++] = direction.y;\n                this._vertexData[offset++] = direction.z;\n            }\n        }\n        else if (this.billboardMode === ParticleSystem.BILLBOARDMODE_STRETCHED || this.billboardMode === ParticleSystem.BILLBOARDMODE_STRETCHED_LOCAL) {\n            this._vertexData[offset++] = particle.direction.x;\n            this._vertexData[offset++] = particle.direction.y;\n            this._vertexData[offset++] = particle.direction.z;\n        }\n        if (this._useRampGradients && particle.remapData) {\n            this._vertexData[offset++] = particle.remapData.x;\n            this._vertexData[offset++] = particle.remapData.y;\n            this._vertexData[offset++] = particle.remapData.z;\n            this._vertexData[offset++] = particle.remapData.w;\n        }\n        if (!this._useInstancing) {\n            if (this._isAnimationSheetEnabled) {\n                if (offsetX === 0) {\n                    offsetX = this._epsilon;\n                }\n                else if (offsetX === 1) {\n                    offsetX = 1 - this._epsilon;\n                }\n                if (offsetY === 0) {\n                    offsetY = this._epsilon;\n                }\n                else if (offsetY === 1) {\n                    offsetY = 1 - this._epsilon;\n                }\n            }\n            this._vertexData[offset++] = offsetX;\n            this._vertexData[offset++] = offsetY;\n        }\n    }\n    _stopSubEmitters() {\n        if (!this.activeSubSystems) {\n            return;\n        }\n        this.activeSubSystems.forEach((subSystem) => {\n            subSystem.stop(true);\n        });\n        this.activeSubSystems = new Array();\n    }\n    _removeFromRoot() {\n        if (!this._rootParticleSystem) {\n            return;\n        }\n        const index = this._rootParticleSystem.activeSubSystems.indexOf(this);\n        if (index !== -1) {\n            this._rootParticleSystem.activeSubSystems.splice(index, 1);\n        }\n        this._rootParticleSystem = null;\n    }\n    // End of sub system methods\n    _update(newParticles) {\n        // Update current\n        this._alive = this._particles.length > 0;\n        if (this.emitter.position) {\n            const emitterMesh = this.emitter;\n            this._emitterWorldMatrix = emitterMesh.getWorldMatrix();\n        }\n        else {\n            const emitterPosition = this.emitter;\n            this._emitterWorldMatrix = Matrix.Translation(emitterPosition.x, emitterPosition.y, emitterPosition.z);\n        }\n        this._emitterWorldMatrix.invertToRef(this._emitterInverseWorldMatrix);\n        this.updateFunction(this._particles);\n        // Add new ones\n        let particle;\n        for (let index = 0; index < newParticles; index++) {\n            if (this._particles.length === this._capacity) {\n                break;\n            }\n            particle = this._createParticle();\n            this._particles.push(particle);\n            // Life time\n            if (this.targetStopDuration && this._lifeTimeGradients && this._lifeTimeGradients.length > 0) {\n                const ratio = Scalar.Clamp(this._actualFrame / this.targetStopDuration);\n                GradientHelper.GetCurrentGradient(ratio, this._lifeTimeGradients, (currentGradient, nextGradient) => {\n                    const factorGradient1 = currentGradient;\n                    const factorGradient2 = nextGradient;\n                    const lifeTime1 = factorGradient1.getFactor();\n                    const lifeTime2 = factorGradient2.getFactor();\n                    const gradient = (ratio - factorGradient1.gradient) / (factorGradient2.gradient - factorGradient1.gradient);\n                    particle.lifeTime = Scalar.Lerp(lifeTime1, lifeTime2, gradient);\n                });\n            }\n            else {\n                particle.lifeTime = Scalar.RandomRange(this.minLifeTime, this.maxLifeTime);\n            }\n            // Emitter\n            const emitPower = Scalar.RandomRange(this.minEmitPower, this.maxEmitPower);\n            if (this.startPositionFunction) {\n                this.startPositionFunction(this._emitterWorldMatrix, particle.position, particle, this.isLocal);\n            }\n            else {\n                this.particleEmitterType.startPositionFunction(this._emitterWorldMatrix, particle.position, particle, this.isLocal);\n            }\n            if (this.isLocal) {\n                if (!particle._localPosition) {\n                    particle._localPosition = particle.position.clone();\n                }\n                else {\n                    particle._localPosition.copyFrom(particle.position);\n                }\n                Vector3.TransformCoordinatesToRef(particle._localPosition, this._emitterWorldMatrix, particle.position);\n            }\n            if (this.startDirectionFunction) {\n                this.startDirectionFunction(this._emitterWorldMatrix, particle.direction, particle, this.isLocal);\n            }\n            else {\n                this.particleEmitterType.startDirectionFunction(this._emitterWorldMatrix, particle.direction, particle, this.isLocal, this._emitterInverseWorldMatrix);\n            }\n            if (emitPower === 0) {\n                if (!particle._initialDirection) {\n                    particle._initialDirection = particle.direction.clone();\n                }\n                else {\n                    particle._initialDirection.copyFrom(particle.direction);\n                }\n            }\n            else {\n                particle._initialDirection = null;\n            }\n            particle.direction.scaleInPlace(emitPower);\n            // Size\n            if (!this._sizeGradients || this._sizeGradients.length === 0) {\n                particle.size = Scalar.RandomRange(this.minSize, this.maxSize);\n            }\n            else {\n                particle._currentSizeGradient = this._sizeGradients[0];\n                particle._currentSize1 = particle._currentSizeGradient.getFactor();\n                particle.size = particle._currentSize1;\n                if (this._sizeGradients.length > 1) {\n                    particle._currentSize2 = this._sizeGradients[1].getFactor();\n                }\n                else {\n                    particle._currentSize2 = particle._currentSize1;\n                }\n            }\n            // Size and scale\n            particle.scale.copyFromFloats(Scalar.RandomRange(this.minScaleX, this.maxScaleX), Scalar.RandomRange(this.minScaleY, this.maxScaleY));\n            // Adjust scale by start size\n            if (this._startSizeGradients && this._startSizeGradients[0] && this.targetStopDuration) {\n                const ratio = this._actualFrame / this.targetStopDuration;\n                GradientHelper.GetCurrentGradient(ratio, this._startSizeGradients, (currentGradient, nextGradient, scale) => {\n                    if (currentGradient !== this._currentStartSizeGradient) {\n                        this._currentStartSize1 = this._currentStartSize2;\n                        this._currentStartSize2 = nextGradient.getFactor();\n                        this._currentStartSizeGradient = currentGradient;\n                    }\n                    const value = Scalar.Lerp(this._currentStartSize1, this._currentStartSize2, scale);\n                    particle.scale.scaleInPlace(value);\n                });\n            }\n            // Angle\n            if (!this._angularSpeedGradients || this._angularSpeedGradients.length === 0) {\n                particle.angularSpeed = Scalar.RandomRange(this.minAngularSpeed, this.maxAngularSpeed);\n            }\n            else {\n                particle._currentAngularSpeedGradient = this._angularSpeedGradients[0];\n                particle.angularSpeed = particle._currentAngularSpeedGradient.getFactor();\n                particle._currentAngularSpeed1 = particle.angularSpeed;\n                if (this._angularSpeedGradients.length > 1) {\n                    particle._currentAngularSpeed2 = this._angularSpeedGradients[1].getFactor();\n                }\n                else {\n                    particle._currentAngularSpeed2 = particle._currentAngularSpeed1;\n                }\n            }\n            particle.angle = Scalar.RandomRange(this.minInitialRotation, this.maxInitialRotation);\n            // Velocity\n            if (this._velocityGradients && this._velocityGradients.length > 0) {\n                particle._currentVelocityGradient = this._velocityGradients[0];\n                particle._currentVelocity1 = particle._currentVelocityGradient.getFactor();\n                if (this._velocityGradients.length > 1) {\n                    particle._currentVelocity2 = this._velocityGradients[1].getFactor();\n                }\n                else {\n                    particle._currentVelocity2 = particle._currentVelocity1;\n                }\n            }\n            // Limit velocity\n            if (this._limitVelocityGradients && this._limitVelocityGradients.length > 0) {\n                particle._currentLimitVelocityGradient = this._limitVelocityGradients[0];\n                particle._currentLimitVelocity1 = particle._currentLimitVelocityGradient.getFactor();\n                if (this._limitVelocityGradients.length > 1) {\n                    particle._currentLimitVelocity2 = this._limitVelocityGradients[1].getFactor();\n                }\n                else {\n                    particle._currentLimitVelocity2 = particle._currentLimitVelocity1;\n                }\n            }\n            // Drag\n            if (this._dragGradients && this._dragGradients.length > 0) {\n                particle._currentDragGradient = this._dragGradients[0];\n                particle._currentDrag1 = particle._currentDragGradient.getFactor();\n                if (this._dragGradients.length > 1) {\n                    particle._currentDrag2 = this._dragGradients[1].getFactor();\n                }\n                else {\n                    particle._currentDrag2 = particle._currentDrag1;\n                }\n            }\n            // Color\n            if (!this._colorGradients || this._colorGradients.length === 0) {\n                const step = Scalar.RandomRange(0, 1.0);\n                Color4.LerpToRef(this.color1, this.color2, step, particle.color);\n                this.colorDead.subtractToRef(particle.color, this._colorDiff);\n                this._colorDiff.scaleToRef(1.0 / particle.lifeTime, particle.colorStep);\n            }\n            else {\n                particle._currentColorGradient = this._colorGradients[0];\n                particle._currentColorGradient.getColorToRef(particle.color);\n                particle._currentColor1.copyFrom(particle.color);\n                if (this._colorGradients.length > 1) {\n                    this._colorGradients[1].getColorToRef(particle._currentColor2);\n                }\n                else {\n                    particle._currentColor2.copyFrom(particle.color);\n                }\n            }\n            // Sheet\n            if (this._isAnimationSheetEnabled) {\n                particle._initialStartSpriteCellID = this.startSpriteCellID;\n                particle._initialEndSpriteCellID = this.endSpriteCellID;\n                particle._initialSpriteCellLoop = this.spriteCellLoop;\n            }\n            // Inherited Velocity\n            particle.direction.addInPlace(this._inheritedVelocityOffset);\n            // Ramp\n            if (this._useRampGradients) {\n                particle.remapData = new Vector4(0, 1, 0, 1);\n            }\n            // Noise texture coordinates\n            if (this.noiseTexture) {\n                if (particle._randomNoiseCoordinates1) {\n                    particle._randomNoiseCoordinates1.copyFromFloats(Math.random(), Math.random(), Math.random());\n                    particle._randomNoiseCoordinates2.copyFromFloats(Math.random(), Math.random(), Math.random());\n                }\n                else {\n                    particle._randomNoiseCoordinates1 = new Vector3(Math.random(), Math.random(), Math.random());\n                    particle._randomNoiseCoordinates2 = new Vector3(Math.random(), Math.random(), Math.random());\n                }\n            }\n            // Update the position of the attached sub-emitters to match their attached particle\n            particle._inheritParticleInfoToSubEmitters();\n        }\n    }\n    /**\n     * @internal\n     */\n    static _GetAttributeNamesOrOptions(isAnimationSheetEnabled = false, isBillboardBased = false, useRampGradients = false) {\n        const attributeNamesOrOptions = [VertexBuffer.PositionKind, VertexBuffer.ColorKind, \"angle\", \"offset\", \"size\"];\n        if (isAnimationSheetEnabled) {\n            attributeNamesOrOptions.push(\"cellIndex\");\n        }\n        if (!isBillboardBased) {\n            attributeNamesOrOptions.push(\"direction\");\n        }\n        if (useRampGradients) {\n            attributeNamesOrOptions.push(\"remapData\");\n        }\n        return attributeNamesOrOptions;\n    }\n    /**\n     * @internal\n     */\n    static _GetEffectCreationOptions(isAnimationSheetEnabled = false, useLogarithmicDepth = false) {\n        const effectCreationOption = [\"invView\", \"view\", \"projection\", \"textureMask\", \"translationPivot\", \"eyePosition\"];\n        addClipPlaneUniforms(effectCreationOption);\n        if (isAnimationSheetEnabled) {\n            effectCreationOption.push(\"particlesInfos\");\n        }\n        if (useLogarithmicDepth) {\n            effectCreationOption.push(\"logarithmicDepthConstant\");\n        }\n        return effectCreationOption;\n    }\n    /**\n     * Fill the defines array according to the current settings of the particle system\n     * @param defines Array to be updated\n     * @param blendMode blend mode to take into account when updating the array\n     */\n    fillDefines(defines, blendMode) {\n        if (this._scene) {\n            prepareDefinesForClipPlanes(this, this._scene, defines);\n        }\n        if (this._isAnimationSheetEnabled) {\n            defines.push(\"#define ANIMATESHEET\");\n        }\n        if (this.useLogarithmicDepth) {\n            defines.push(\"#define LOGARITHMICDEPTH\");\n        }\n        if (blendMode === ParticleSystem.BLENDMODE_MULTIPLY) {\n            defines.push(\"#define BLENDMULTIPLYMODE\");\n        }\n        if (this._useRampGradients) {\n            defines.push(\"#define RAMPGRADIENT\");\n        }\n        if (this._isBillboardBased) {\n            defines.push(\"#define BILLBOARD\");\n            switch (this.billboardMode) {\n                case ParticleSystem.BILLBOARDMODE_Y:\n                    defines.push(\"#define BILLBOARDY\");\n                    break;\n                case ParticleSystem.BILLBOARDMODE_STRETCHED:\n                case ParticleSystem.BILLBOARDMODE_STRETCHED_LOCAL:\n                    defines.push(\"#define BILLBOARDSTRETCHED\");\n                    if (this.billboardMode === ParticleSystem.BILLBOARDMODE_STRETCHED_LOCAL) {\n                        defines.push(\"#define BILLBOARDSTRETCHED_LOCAL\");\n                    }\n                    break;\n                case ParticleSystem.BILLBOARDMODE_ALL:\n                    defines.push(\"#define BILLBOARDMODE_ALL\");\n                    break;\n                default:\n                    break;\n            }\n        }\n        if (this._imageProcessingConfiguration) {\n            this._imageProcessingConfiguration.prepareDefines(this._imageProcessingConfigurationDefines);\n            defines.push(this._imageProcessingConfigurationDefines.toString());\n        }\n    }\n    /**\n     * Fill the uniforms, attributes and samplers arrays according to the current settings of the particle system\n     * @param uniforms Uniforms array to fill\n     * @param attributes Attributes array to fill\n     * @param samplers Samplers array to fill\n     */\n    fillUniformsAttributesAndSamplerNames(uniforms, attributes, samplers) {\n        attributes.push(...ParticleSystem._GetAttributeNamesOrOptions(this._isAnimationSheetEnabled, this._isBillboardBased && this.billboardMode !== ParticleSystem.BILLBOARDMODE_STRETCHED && this.billboardMode !== ParticleSystem.BILLBOARDMODE_STRETCHED_LOCAL, this._useRampGradients));\n        uniforms.push(...ParticleSystem._GetEffectCreationOptions(this._isAnimationSheetEnabled, this.useLogarithmicDepth));\n        samplers.push(\"diffuseSampler\", \"rampSampler\");\n        if (this._imageProcessingConfiguration) {\n            ImageProcessingConfiguration.PrepareUniforms(uniforms, this._imageProcessingConfigurationDefines);\n            ImageProcessingConfiguration.PrepareSamplers(samplers, this._imageProcessingConfigurationDefines);\n        }\n    }\n    /**\n     * @internal\n     */\n    _getWrapper(blendMode) {\n        const customWrapper = this._getCustomDrawWrapper(blendMode);\n        if (customWrapper === null || customWrapper === void 0 ? void 0 : customWrapper.effect) {\n            return customWrapper;\n        }\n        const defines = [];\n        this.fillDefines(defines, blendMode);\n        // Effect\n        const currentRenderPassId = this._engine._features.supportRenderPasses ? this._engine.currentRenderPassId : 0;\n        let drawWrappers = this._drawWrappers[currentRenderPassId];\n        if (!drawWrappers) {\n            drawWrappers = this._drawWrappers[currentRenderPassId] = [];\n        }\n        let drawWrapper = drawWrappers[blendMode];\n        if (!drawWrapper) {\n            drawWrapper = new DrawWrapper(this._engine);\n            if (drawWrapper.drawContext) {\n                drawWrapper.drawContext.useInstancing = this._useInstancing;\n            }\n            drawWrappers[blendMode] = drawWrapper;\n        }\n        const join = defines.join(\"\\n\");\n        if (drawWrapper.defines !== join) {\n            const attributesNamesOrOptions = [];\n            const effectCreationOption = [];\n            const samplers = [];\n            this.fillUniformsAttributesAndSamplerNames(effectCreationOption, attributesNamesOrOptions, samplers);\n            drawWrapper.setEffect(this._engine.createEffect(\"particles\", attributesNamesOrOptions, effectCreationOption, samplers, join), join);\n        }\n        return drawWrapper;\n    }\n    /**\n     * Animates the particle system for the current frame by emitting new particles and or animating the living ones.\n     * @param preWarmOnly will prevent the system from updating the vertex buffer (default is false)\n     */\n    animate(preWarmOnly = false) {\n        var _a;\n        if (!this._started) {\n            return;\n        }\n        if (!preWarmOnly && this._scene) {\n            // Check\n            if (!this.isReady()) {\n                return;\n            }\n            if (this._currentRenderId === this._scene.getFrameId()) {\n                return;\n            }\n            this._currentRenderId = this._scene.getFrameId();\n        }\n        this._scaledUpdateSpeed = this.updateSpeed * (preWarmOnly ? this.preWarmStepOffset : ((_a = this._scene) === null || _a === void 0 ? void 0 : _a.getAnimationRatio()) || 1);\n        // Determine the number of particles we need to create\n        let newParticles;\n        if (this.manualEmitCount > -1) {\n            newParticles = this.manualEmitCount;\n            this._newPartsExcess = 0;\n            this.manualEmitCount = 0;\n        }\n        else {\n            let rate = this.emitRate;\n            if (this._emitRateGradients && this._emitRateGradients.length > 0 && this.targetStopDuration) {\n                const ratio = this._actualFrame / this.targetStopDuration;\n                GradientHelper.GetCurrentGradient(ratio, this._emitRateGradients, (currentGradient, nextGradient, scale) => {\n                    if (currentGradient !== this._currentEmitRateGradient) {\n                        this._currentEmitRate1 = this._currentEmitRate2;\n                        this._currentEmitRate2 = nextGradient.getFactor();\n                        this._currentEmitRateGradient = currentGradient;\n                    }\n                    rate = Scalar.Lerp(this._currentEmitRate1, this._currentEmitRate2, scale);\n                });\n            }\n            newParticles = (rate * this._scaledUpdateSpeed) >> 0;\n            this._newPartsExcess += rate * this._scaledUpdateSpeed - newParticles;\n        }\n        if (this._newPartsExcess > 1.0) {\n            newParticles += this._newPartsExcess >> 0;\n            this._newPartsExcess -= this._newPartsExcess >> 0;\n        }\n        this._alive = false;\n        if (!this._stopped) {\n            this._actualFrame += this._scaledUpdateSpeed;\n            if (this.targetStopDuration && this._actualFrame >= this.targetStopDuration) {\n                this.stop();\n            }\n        }\n        else {\n            newParticles = 0;\n        }\n        this._update(newParticles);\n        // Stopped?\n        if (this._stopped) {\n            if (!this._alive) {\n                this._started = false;\n                if (this.onAnimationEnd) {\n                    this.onAnimationEnd();\n                }\n                if (this.disposeOnStop && this._scene) {\n                    this._scene._toBeDisposed.push(this);\n                }\n            }\n        }\n        if (!preWarmOnly) {\n            // Update VBO\n            let offset = 0;\n            for (let index = 0; index < this._particles.length; index++) {\n                const particle = this._particles[index];\n                this._appendParticleVertices(offset, particle);\n                offset += this._useInstancing ? 1 : 4;\n            }\n            if (this._vertexBuffer) {\n                this._vertexBuffer.updateDirectly(this._vertexData, 0, this._particles.length);\n            }\n        }\n        if (this.manualEmitCount === 0 && this.disposeOnStop) {\n            this.stop();\n        }\n    }\n    _appendParticleVertices(offset, particle) {\n        this._appendParticleVertex(offset++, particle, 0, 0);\n        if (!this._useInstancing) {\n            this._appendParticleVertex(offset++, particle, 1, 0);\n            this._appendParticleVertex(offset++, particle, 1, 1);\n            this._appendParticleVertex(offset++, particle, 0, 1);\n        }\n    }\n    /**\n     * Rebuilds the particle system.\n     */\n    rebuild() {\n        var _a, _b;\n        if (this._engine.getCaps().vertexArrayObject) {\n            this._vertexArrayObject = null;\n        }\n        this._createIndexBuffer();\n        (_a = this._spriteBuffer) === null || _a === void 0 ? void 0 : _a._rebuild();\n        (_b = this._vertexBuffer) === null || _b === void 0 ? void 0 : _b._rebuild();\n        for (const key in this._vertexBuffers) {\n            this._vertexBuffers[key]._rebuild();\n        }\n        this.resetDrawCache();\n    }\n    /**\n     * Is this system ready to be used/rendered\n     * @returns true if the system is ready\n     */\n    isReady() {\n        if (!this.emitter || (this._imageProcessingConfiguration && !this._imageProcessingConfiguration.isReady()) || !this.particleTexture || !this.particleTexture.isReady()) {\n            return false;\n        }\n        if (this.blendMode !== ParticleSystem.BLENDMODE_MULTIPLYADD) {\n            if (!this._getWrapper(this.blendMode).effect.isReady()) {\n                return false;\n            }\n        }\n        else {\n            if (!this._getWrapper(ParticleSystem.BLENDMODE_MULTIPLY).effect.isReady()) {\n                return false;\n            }\n            if (!this._getWrapper(ParticleSystem.BLENDMODE_ADD).effect.isReady()) {\n                return false;\n            }\n        }\n        return true;\n    }\n    _render(blendMode) {\n        var _a, _b;\n        const drawWrapper = this._getWrapper(blendMode);\n        const effect = drawWrapper.effect;\n        const engine = this._engine;\n        // Render\n        engine.enableEffect(drawWrapper);\n        const viewMatrix = (_a = this.defaultViewMatrix) !== null && _a !== void 0 ? _a : this._scene.getViewMatrix();\n        effect.setTexture(\"diffuseSampler\", this.particleTexture);\n        effect.setMatrix(\"view\", viewMatrix);\n        effect.setMatrix(\"projection\", (_b = this.defaultProjectionMatrix) !== null && _b !== void 0 ? _b : this._scene.getProjectionMatrix());\n        if (this._isAnimationSheetEnabled && this.particleTexture) {\n            const baseSize = this.particleTexture.getBaseSize();\n            effect.setFloat3(\"particlesInfos\", this.spriteCellWidth / baseSize.width, this.spriteCellHeight / baseSize.height, this.spriteCellWidth / baseSize.width);\n        }\n        effect.setVector2(\"translationPivot\", this.translationPivot);\n        effect.setFloat4(\"textureMask\", this.textureMask.r, this.textureMask.g, this.textureMask.b, this.textureMask.a);\n        if (this._isBillboardBased && this._scene) {\n            const camera = this._scene.activeCamera;\n            effect.setVector3(\"eyePosition\", camera.globalPosition);\n        }\n        if (this._rampGradientsTexture) {\n            if (!this._rampGradients || !this._rampGradients.length) {\n                this._rampGradientsTexture.dispose();\n                this._rampGradientsTexture = null;\n            }\n            effect.setTexture(\"rampSampler\", this._rampGradientsTexture);\n        }\n        const defines = effect.defines;\n        if (this._scene) {\n            bindClipPlane(effect, this, this._scene);\n        }\n        if (defines.indexOf(\"#define BILLBOARDMODE_ALL\") >= 0) {\n            viewMatrix.invertToRef(TmpVectors.Matrix[0]);\n            effect.setMatrix(\"invView\", TmpVectors.Matrix[0]);\n        }\n        if (this._vertexArrayObject !== undefined) {\n            if (!this._vertexArrayObject) {\n                this._vertexArrayObject = this._engine.recordVertexArrayObject(this._vertexBuffers, this._indexBuffer, effect);\n            }\n            this._engine.bindVertexArrayObject(this._vertexArrayObject, this._indexBuffer);\n        }\n        else {\n            engine.bindBuffers(this._vertexBuffers, this._indexBuffer, effect);\n        }\n        // Log. depth\n        if (this.useLogarithmicDepth && this._scene) {\n            MaterialHelper.BindLogDepth(defines, effect, this._scene);\n        }\n        // image processing\n        if (this._imageProcessingConfiguration && !this._imageProcessingConfiguration.applyByPostProcess) {\n            this._imageProcessingConfiguration.bind(effect);\n        }\n        // Draw order\n        switch (blendMode) {\n            case ParticleSystem.BLENDMODE_ADD:\n                engine.setAlphaMode(1);\n                break;\n            case ParticleSystem.BLENDMODE_ONEONE:\n                engine.setAlphaMode(6);\n                break;\n            case ParticleSystem.BLENDMODE_STANDARD:\n                engine.setAlphaMode(2);\n                break;\n            case ParticleSystem.BLENDMODE_MULTIPLY:\n                engine.setAlphaMode(4);\n                break;\n        }\n        if (this._onBeforeDrawParticlesObservable) {\n            this._onBeforeDrawParticlesObservable.notifyObservers(effect);\n        }\n        if (this._useInstancing) {\n            engine.drawArraysType(7, 0, 4, this._particles.length);\n        }\n        else {\n            engine.drawElementsType(0, 0, this._particles.length * 6);\n        }\n        return this._particles.length;\n    }\n    /**\n     * Renders the particle system in its current state.\n     * @returns the current number of particles\n     */\n    render() {\n        // Check\n        if (!this.isReady() || !this._particles.length) {\n            return 0;\n        }\n        const engine = this._engine;\n        if (engine.setState) {\n            engine.setState(false);\n            if (this.forceDepthWrite) {\n                engine.setDepthWrite(true);\n            }\n        }\n        let outparticles = 0;\n        if (this.blendMode === ParticleSystem.BLENDMODE_MULTIPLYADD) {\n            outparticles = this._render(ParticleSystem.BLENDMODE_MULTIPLY) + this._render(ParticleSystem.BLENDMODE_ADD);\n        }\n        else {\n            outparticles = this._render(this.blendMode);\n        }\n        this._engine.unbindInstanceAttributes();\n        this._engine.setAlphaMode(0);\n        return outparticles;\n    }\n    /**\n     * Disposes the particle system and free the associated resources\n     * @param disposeTexture defines if the particle texture must be disposed as well (true by default)\n     */\n    dispose(disposeTexture = true) {\n        this.resetDrawCache();\n        if (this._vertexBuffer) {\n            this._vertexBuffer.dispose();\n            this._vertexBuffer = null;\n        }\n        if (this._spriteBuffer) {\n            this._spriteBuffer.dispose();\n            this._spriteBuffer = null;\n        }\n        if (this._indexBuffer) {\n            this._engine._releaseBuffer(this._indexBuffer);\n            this._indexBuffer = null;\n        }\n        if (this._vertexArrayObject) {\n            this._engine.releaseVertexArrayObject(this._vertexArrayObject);\n            this._vertexArrayObject = null;\n        }\n        if (disposeTexture && this.particleTexture) {\n            this.particleTexture.dispose();\n            this.particleTexture = null;\n        }\n        if (disposeTexture && this.noiseTexture) {\n            this.noiseTexture.dispose();\n            this.noiseTexture = null;\n        }\n        if (this._rampGradientsTexture) {\n            this._rampGradientsTexture.dispose();\n            this._rampGradientsTexture = null;\n        }\n        this._removeFromRoot();\n        if (this.subEmitters && !this._subEmitters) {\n            this._prepareSubEmitterInternalArray();\n        }\n        if (this._subEmitters && this._subEmitters.length) {\n            for (let index = 0; index < this._subEmitters.length; index++) {\n                for (const subEmitter of this._subEmitters[index]) {\n                    subEmitter.dispose();\n                }\n            }\n            this._subEmitters = [];\n            this.subEmitters = [];\n        }\n        if (this._disposeEmitterOnDispose && this.emitter && this.emitter.dispose) {\n            this.emitter.dispose(true);\n        }\n        if (this._onBeforeDrawParticlesObservable) {\n            this._onBeforeDrawParticlesObservable.clear();\n        }\n        // Remove from scene\n        if (this._scene) {\n            const index = this._scene.particleSystems.indexOf(this);\n            if (index > -1) {\n                this._scene.particleSystems.splice(index, 1);\n            }\n            this._scene._activeParticleSystems.dispose();\n        }\n        // Callback\n        this.onDisposeObservable.notifyObservers(this);\n        this.onDisposeObservable.clear();\n        this.onStoppedObservable.clear();\n        this.reset();\n    }\n    // Clone\n    /**\n     * Clones the particle system.\n     * @param name The name of the cloned object\n     * @param newEmitter The new emitter to use\n     * @param cloneTexture Also clone the textures if true\n     * @returns the cloned particle system\n     */\n    clone(name, newEmitter, cloneTexture = false) {\n        const custom = { ...this._customWrappers };\n        let program = null;\n        const engine = this._engine;\n        if (engine.createEffectForParticles) {\n            if (this.customShader != null) {\n                program = this.customShader;\n                const defines = program.shaderOptions.defines.length > 0 ? program.shaderOptions.defines.join(\"\\n\") : \"\";\n                const effect = engine.createEffectForParticles(program.shaderPath.fragmentElement, program.shaderOptions.uniforms, program.shaderOptions.samplers, defines);\n                if (!custom[0]) {\n                    this.setCustomEffect(effect, 0);\n                }\n                else {\n                    custom[0].effect = effect;\n                }\n            }\n        }\n        const serialization = this.serialize(cloneTexture);\n        const result = ParticleSystem.Parse(serialization, this._scene || this._engine, this._rootUrl);\n        result.name = name;\n        result.customShader = program;\n        result._customWrappers = custom;\n        if (newEmitter === undefined) {\n            newEmitter = this.emitter;\n        }\n        if (this.noiseTexture) {\n            result.noiseTexture = this.noiseTexture.clone();\n        }\n        result.emitter = newEmitter;\n        if (!this.preventAutoStart) {\n            result.start();\n        }\n        return result;\n    }\n    /**\n     * Serializes the particle system to a JSON object\n     * @param serializeTexture defines if the texture must be serialized as well\n     * @returns the JSON object\n     */\n    serialize(serializeTexture = false) {\n        const serializationObject = {};\n        ParticleSystem._Serialize(serializationObject, this, serializeTexture);\n        serializationObject.textureMask = this.textureMask.asArray();\n        serializationObject.customShader = this.customShader;\n        serializationObject.preventAutoStart = this.preventAutoStart;\n        // SubEmitters\n        if (this.subEmitters) {\n            serializationObject.subEmitters = [];\n            if (!this._subEmitters) {\n                this._prepareSubEmitterInternalArray();\n            }\n            for (const subs of this._subEmitters) {\n                const cell = [];\n                for (const sub of subs) {\n                    cell.push(sub.serialize(serializeTexture));\n                }\n                serializationObject.subEmitters.push(cell);\n            }\n        }\n        return serializationObject;\n    }\n    /**\n     * @internal\n     */\n    static _Serialize(serializationObject, particleSystem, serializeTexture) {\n        serializationObject.name = particleSystem.name;\n        serializationObject.id = particleSystem.id;\n        serializationObject.capacity = particleSystem.getCapacity();\n        serializationObject.disposeOnStop = particleSystem.disposeOnStop;\n        serializationObject.manualEmitCount = particleSystem.manualEmitCount;\n        // Emitter\n        if (particleSystem.emitter.position) {\n            const emitterMesh = particleSystem.emitter;\n            serializationObject.emitterId = emitterMesh.id;\n        }\n        else {\n            const emitterPosition = particleSystem.emitter;\n            serializationObject.emitter = emitterPosition.asArray();\n        }\n        // Emitter\n        if (particleSystem.particleEmitterType) {\n            serializationObject.particleEmitterType = particleSystem.particleEmitterType.serialize();\n        }\n        if (particleSystem.particleTexture) {\n            if (serializeTexture) {\n                serializationObject.texture = particleSystem.particleTexture.serialize();\n            }\n            else {\n                serializationObject.textureName = particleSystem.particleTexture.name;\n                serializationObject.invertY = !!particleSystem.particleTexture._invertY;\n            }\n        }\n        serializationObject.isLocal = particleSystem.isLocal;\n        // Animations\n        SerializationHelper.AppendSerializedAnimations(particleSystem, serializationObject);\n        serializationObject.beginAnimationOnStart = particleSystem.beginAnimationOnStart;\n        serializationObject.beginAnimationFrom = particleSystem.beginAnimationFrom;\n        serializationObject.beginAnimationTo = particleSystem.beginAnimationTo;\n        serializationObject.beginAnimationLoop = particleSystem.beginAnimationLoop;\n        // Particle system\n        serializationObject.startDelay = particleSystem.startDelay;\n        serializationObject.renderingGroupId = particleSystem.renderingGroupId;\n        serializationObject.isBillboardBased = particleSystem.isBillboardBased;\n        serializationObject.billboardMode = particleSystem.billboardMode;\n        serializationObject.minAngularSpeed = particleSystem.minAngularSpeed;\n        serializationObject.maxAngularSpeed = particleSystem.maxAngularSpeed;\n        serializationObject.minSize = particleSystem.minSize;\n        serializationObject.maxSize = particleSystem.maxSize;\n        serializationObject.minScaleX = particleSystem.minScaleX;\n        serializationObject.maxScaleX = particleSystem.maxScaleX;\n        serializationObject.minScaleY = particleSystem.minScaleY;\n        serializationObject.maxScaleY = particleSystem.maxScaleY;\n        serializationObject.minEmitPower = particleSystem.minEmitPower;\n        serializationObject.maxEmitPower = particleSystem.maxEmitPower;\n        serializationObject.minLifeTime = particleSystem.minLifeTime;\n        serializationObject.maxLifeTime = particleSystem.maxLifeTime;\n        serializationObject.emitRate = particleSystem.emitRate;\n        serializationObject.gravity = particleSystem.gravity.asArray();\n        serializationObject.noiseStrength = particleSystem.noiseStrength.asArray();\n        serializationObject.color1 = particleSystem.color1.asArray();\n        serializationObject.color2 = particleSystem.color2.asArray();\n        serializationObject.colorDead = particleSystem.colorDead.asArray();\n        serializationObject.updateSpeed = particleSystem.updateSpeed;\n        serializationObject.targetStopDuration = particleSystem.targetStopDuration;\n        serializationObject.blendMode = particleSystem.blendMode;\n        serializationObject.preWarmCycles = particleSystem.preWarmCycles;\n        serializationObject.preWarmStepOffset = particleSystem.preWarmStepOffset;\n        serializationObject.minInitialRotation = particleSystem.minInitialRotation;\n        serializationObject.maxInitialRotation = particleSystem.maxInitialRotation;\n        serializationObject.startSpriteCellID = particleSystem.startSpriteCellID;\n        serializationObject.spriteCellLoop = particleSystem.spriteCellLoop;\n        serializationObject.endSpriteCellID = particleSystem.endSpriteCellID;\n        serializationObject.spriteCellChangeSpeed = particleSystem.spriteCellChangeSpeed;\n        serializationObject.spriteCellWidth = particleSystem.spriteCellWidth;\n        serializationObject.spriteCellHeight = particleSystem.spriteCellHeight;\n        serializationObject.spriteRandomStartCell = particleSystem.spriteRandomStartCell;\n        serializationObject.isAnimationSheetEnabled = particleSystem.isAnimationSheetEnabled;\n        serializationObject.useLogarithmicDepth = particleSystem.useLogarithmicDepth;\n        const colorGradients = particleSystem.getColorGradients();\n        if (colorGradients) {\n            serializationObject.colorGradients = [];\n            for (const colorGradient of colorGradients) {\n                const serializedGradient = {\n                    gradient: colorGradient.gradient,\n                    color1: colorGradient.color1.asArray(),\n                };\n                if (colorGradient.color2) {\n                    serializedGradient.color2 = colorGradient.color2.asArray();\n                }\n                else {\n                    serializedGradient.color2 = colorGradient.color1.asArray();\n                }\n                serializationObject.colorGradients.push(serializedGradient);\n            }\n        }\n        const rampGradients = particleSystem.getRampGradients();\n        if (rampGradients) {\n            serializationObject.rampGradients = [];\n            for (const rampGradient of rampGradients) {\n                const serializedGradient = {\n                    gradient: rampGradient.gradient,\n                    color: rampGradient.color.asArray(),\n                };\n                serializationObject.rampGradients.push(serializedGradient);\n            }\n            serializationObject.useRampGradients = particleSystem.useRampGradients;\n        }\n        const colorRemapGradients = particleSystem.getColorRemapGradients();\n        if (colorRemapGradients) {\n            serializationObject.colorRemapGradients = [];\n            for (const colorRemapGradient of colorRemapGradients) {\n                const serializedGradient = {\n                    gradient: colorRemapGradient.gradient,\n                    factor1: colorRemapGradient.factor1,\n                };\n                if (colorRemapGradient.factor2 !== undefined) {\n                    serializedGradient.factor2 = colorRemapGradient.factor2;\n                }\n                else {\n                    serializedGradient.factor2 = colorRemapGradient.factor1;\n                }\n                serializationObject.colorRemapGradients.push(serializedGradient);\n            }\n        }\n        const alphaRemapGradients = particleSystem.getAlphaRemapGradients();\n        if (alphaRemapGradients) {\n            serializationObject.alphaRemapGradients = [];\n            for (const alphaRemapGradient of alphaRemapGradients) {\n                const serializedGradient = {\n                    gradient: alphaRemapGradient.gradient,\n                    factor1: alphaRemapGradient.factor1,\n                };\n                if (alphaRemapGradient.factor2 !== undefined) {\n                    serializedGradient.factor2 = alphaRemapGradient.factor2;\n                }\n                else {\n                    serializedGradient.factor2 = alphaRemapGradient.factor1;\n                }\n                serializationObject.alphaRemapGradients.push(serializedGradient);\n            }\n        }\n        const sizeGradients = particleSystem.getSizeGradients();\n        if (sizeGradients) {\n            serializationObject.sizeGradients = [];\n            for (const sizeGradient of sizeGradients) {\n                const serializedGradient = {\n                    gradient: sizeGradient.gradient,\n                    factor1: sizeGradient.factor1,\n                };\n                if (sizeGradient.factor2 !== undefined) {\n                    serializedGradient.factor2 = sizeGradient.factor2;\n                }\n                else {\n                    serializedGradient.factor2 = sizeGradient.factor1;\n                }\n                serializationObject.sizeGradients.push(serializedGradient);\n            }\n        }\n        const angularSpeedGradients = particleSystem.getAngularSpeedGradients();\n        if (angularSpeedGradients) {\n            serializationObject.angularSpeedGradients = [];\n            for (const angularSpeedGradient of angularSpeedGradients) {\n                const serializedGradient = {\n                    gradient: angularSpeedGradient.gradient,\n                    factor1: angularSpeedGradient.factor1,\n                };\n                if (angularSpeedGradient.factor2 !== undefined) {\n                    serializedGradient.factor2 = angularSpeedGradient.factor2;\n                }\n                else {\n                    serializedGradient.factor2 = angularSpeedGradient.factor1;\n                }\n                serializationObject.angularSpeedGradients.push(serializedGradient);\n            }\n        }\n        const velocityGradients = particleSystem.getVelocityGradients();\n        if (velocityGradients) {\n            serializationObject.velocityGradients = [];\n            for (const velocityGradient of velocityGradients) {\n                const serializedGradient = {\n                    gradient: velocityGradient.gradient,\n                    factor1: velocityGradient.factor1,\n                };\n                if (velocityGradient.factor2 !== undefined) {\n                    serializedGradient.factor2 = velocityGradient.factor2;\n                }\n                else {\n                    serializedGradient.factor2 = velocityGradient.factor1;\n                }\n                serializationObject.velocityGradients.push(serializedGradient);\n            }\n        }\n        const dragGradients = particleSystem.getDragGradients();\n        if (dragGradients) {\n            serializationObject.dragGradients = [];\n            for (const dragGradient of dragGradients) {\n                const serializedGradient = {\n                    gradient: dragGradient.gradient,\n                    factor1: dragGradient.factor1,\n                };\n                if (dragGradient.factor2 !== undefined) {\n                    serializedGradient.factor2 = dragGradient.factor2;\n                }\n                else {\n                    serializedGradient.factor2 = dragGradient.factor1;\n                }\n                serializationObject.dragGradients.push(serializedGradient);\n            }\n        }\n        const emitRateGradients = particleSystem.getEmitRateGradients();\n        if (emitRateGradients) {\n            serializationObject.emitRateGradients = [];\n            for (const emitRateGradient of emitRateGradients) {\n                const serializedGradient = {\n                    gradient: emitRateGradient.gradient,\n                    factor1: emitRateGradient.factor1,\n                };\n                if (emitRateGradient.factor2 !== undefined) {\n                    serializedGradient.factor2 = emitRateGradient.factor2;\n                }\n                else {\n                    serializedGradient.factor2 = emitRateGradient.factor1;\n                }\n                serializationObject.emitRateGradients.push(serializedGradient);\n            }\n        }\n        const startSizeGradients = particleSystem.getStartSizeGradients();\n        if (startSizeGradients) {\n            serializationObject.startSizeGradients = [];\n            for (const startSizeGradient of startSizeGradients) {\n                const serializedGradient = {\n                    gradient: startSizeGradient.gradient,\n                    factor1: startSizeGradient.factor1,\n                };\n                if (startSizeGradient.factor2 !== undefined) {\n                    serializedGradient.factor2 = startSizeGradient.factor2;\n                }\n                else {\n                    serializedGradient.factor2 = startSizeGradient.factor1;\n                }\n                serializationObject.startSizeGradients.push(serializedGradient);\n            }\n        }\n        const lifeTimeGradients = particleSystem.getLifeTimeGradients();\n        if (lifeTimeGradients) {\n            serializationObject.lifeTimeGradients = [];\n            for (const lifeTimeGradient of lifeTimeGradients) {\n                const serializedGradient = {\n                    gradient: lifeTimeGradient.gradient,\n                    factor1: lifeTimeGradient.factor1,\n                };\n                if (lifeTimeGradient.factor2 !== undefined) {\n                    serializedGradient.factor2 = lifeTimeGradient.factor2;\n                }\n                else {\n                    serializedGradient.factor2 = lifeTimeGradient.factor1;\n                }\n                serializationObject.lifeTimeGradients.push(serializedGradient);\n            }\n        }\n        const limitVelocityGradients = particleSystem.getLimitVelocityGradients();\n        if (limitVelocityGradients) {\n            serializationObject.limitVelocityGradients = [];\n            for (const limitVelocityGradient of limitVelocityGradients) {\n                const serializedGradient = {\n                    gradient: limitVelocityGradient.gradient,\n                    factor1: limitVelocityGradient.factor1,\n                };\n                if (limitVelocityGradient.factor2 !== undefined) {\n                    serializedGradient.factor2 = limitVelocityGradient.factor2;\n                }\n                else {\n                    serializedGradient.factor2 = limitVelocityGradient.factor1;\n                }\n                serializationObject.limitVelocityGradients.push(serializedGradient);\n            }\n            serializationObject.limitVelocityDamping = particleSystem.limitVelocityDamping;\n        }\n        if (particleSystem.noiseTexture) {\n            serializationObject.noiseTexture = particleSystem.noiseTexture.serialize();\n        }\n    }\n    /**\n     * @internal\n     */\n    static _Parse(parsedParticleSystem, particleSystem, sceneOrEngine, rootUrl) {\n        var _a, _b, _c;\n        let scene;\n        if (sceneOrEngine instanceof ThinEngine) {\n            scene = null;\n        }\n        else {\n            scene = sceneOrEngine;\n        }\n        const internalClass = GetClass(\"BABYLON.Texture\");\n        if (internalClass && scene) {\n            // Texture\n            if (parsedParticleSystem.texture) {\n                particleSystem.particleTexture = internalClass.Parse(parsedParticleSystem.texture, scene, rootUrl);\n            }\n            else if (parsedParticleSystem.textureName) {\n                particleSystem.particleTexture = new internalClass(rootUrl + parsedParticleSystem.textureName, scene, false, parsedParticleSystem.invertY !== undefined ? parsedParticleSystem.invertY : true);\n                particleSystem.particleTexture.name = parsedParticleSystem.textureName;\n            }\n        }\n        // Emitter\n        if (!parsedParticleSystem.emitterId && parsedParticleSystem.emitterId !== 0 && parsedParticleSystem.emitter === undefined) {\n            particleSystem.emitter = Vector3.Zero();\n        }\n        else if (parsedParticleSystem.emitterId && scene) {\n            particleSystem.emitter = scene.getLastMeshById(parsedParticleSystem.emitterId);\n        }\n        else {\n            particleSystem.emitter = Vector3.FromArray(parsedParticleSystem.emitter);\n        }\n        particleSystem.isLocal = !!parsedParticleSystem.isLocal;\n        // Misc.\n        if (parsedParticleSystem.renderingGroupId !== undefined) {\n            particleSystem.renderingGroupId = parsedParticleSystem.renderingGroupId;\n        }\n        if (parsedParticleSystem.isBillboardBased !== undefined) {\n            particleSystem.isBillboardBased = parsedParticleSystem.isBillboardBased;\n        }\n        if (parsedParticleSystem.billboardMode !== undefined) {\n            particleSystem.billboardMode = parsedParticleSystem.billboardMode;\n        }\n        if (parsedParticleSystem.useLogarithmicDepth !== undefined) {\n            particleSystem.useLogarithmicDepth = parsedParticleSystem.useLogarithmicDepth;\n        }\n        // Animations\n        if (parsedParticleSystem.animations) {\n            for (let animationIndex = 0; animationIndex < parsedParticleSystem.animations.length; animationIndex++) {\n                const parsedAnimation = parsedParticleSystem.animations[animationIndex];\n                const internalClass = GetClass(\"BABYLON.Animation\");\n                if (internalClass) {\n                    particleSystem.animations.push(internalClass.Parse(parsedAnimation));\n                }\n            }\n            particleSystem.beginAnimationOnStart = parsedParticleSystem.beginAnimationOnStart;\n            particleSystem.beginAnimationFrom = parsedParticleSystem.beginAnimationFrom;\n            particleSystem.beginAnimationTo = parsedParticleSystem.beginAnimationTo;\n            particleSystem.beginAnimationLoop = parsedParticleSystem.beginAnimationLoop;\n        }\n        if (parsedParticleSystem.autoAnimate && scene) {\n            scene.beginAnimation(particleSystem, parsedParticleSystem.autoAnimateFrom, parsedParticleSystem.autoAnimateTo, parsedParticleSystem.autoAnimateLoop, parsedParticleSystem.autoAnimateSpeed || 1.0);\n        }\n        // Particle system\n        particleSystem.startDelay = parsedParticleSystem.startDelay | 0;\n        particleSystem.minAngularSpeed = parsedParticleSystem.minAngularSpeed;\n        particleSystem.maxAngularSpeed = parsedParticleSystem.maxAngularSpeed;\n        particleSystem.minSize = parsedParticleSystem.minSize;\n        particleSystem.maxSize = parsedParticleSystem.maxSize;\n        if (parsedParticleSystem.minScaleX) {\n            particleSystem.minScaleX = parsedParticleSystem.minScaleX;\n            particleSystem.maxScaleX = parsedParticleSystem.maxScaleX;\n            particleSystem.minScaleY = parsedParticleSystem.minScaleY;\n            particleSystem.maxScaleY = parsedParticleSystem.maxScaleY;\n        }\n        if (parsedParticleSystem.preWarmCycles !== undefined) {\n            particleSystem.preWarmCycles = parsedParticleSystem.preWarmCycles;\n            particleSystem.preWarmStepOffset = parsedParticleSystem.preWarmStepOffset;\n        }\n        if (parsedParticleSystem.minInitialRotation !== undefined) {\n            particleSystem.minInitialRotation = parsedParticleSystem.minInitialRotation;\n            particleSystem.maxInitialRotation = parsedParticleSystem.maxInitialRotation;\n        }\n        particleSystem.minLifeTime = parsedParticleSystem.minLifeTime;\n        particleSystem.maxLifeTime = parsedParticleSystem.maxLifeTime;\n        particleSystem.minEmitPower = parsedParticleSystem.minEmitPower;\n        particleSystem.maxEmitPower = parsedParticleSystem.maxEmitPower;\n        particleSystem.emitRate = parsedParticleSystem.emitRate;\n        particleSystem.gravity = Vector3.FromArray(parsedParticleSystem.gravity);\n        if (parsedParticleSystem.noiseStrength) {\n            particleSystem.noiseStrength = Vector3.FromArray(parsedParticleSystem.noiseStrength);\n        }\n        particleSystem.color1 = Color4.FromArray(parsedParticleSystem.color1);\n        particleSystem.color2 = Color4.FromArray(parsedParticleSystem.color2);\n        particleSystem.colorDead = Color4.FromArray(parsedParticleSystem.colorDead);\n        particleSystem.updateSpeed = parsedParticleSystem.updateSpeed;\n        particleSystem.targetStopDuration = parsedParticleSystem.targetStopDuration;\n        particleSystem.blendMode = parsedParticleSystem.blendMode;\n        if (parsedParticleSystem.colorGradients) {\n            for (const colorGradient of parsedParticleSystem.colorGradients) {\n                particleSystem.addColorGradient(colorGradient.gradient, Color4.FromArray(colorGradient.color1), colorGradient.color2 ? Color4.FromArray(colorGradient.color2) : undefined);\n            }\n        }\n        if (parsedParticleSystem.rampGradients) {\n            for (const rampGradient of parsedParticleSystem.rampGradients) {\n                particleSystem.addRampGradient(rampGradient.gradient, Color3.FromArray(rampGradient.color));\n            }\n            particleSystem.useRampGradients = parsedParticleSystem.useRampGradients;\n        }\n        if (parsedParticleSystem.colorRemapGradients) {\n            for (const colorRemapGradient of parsedParticleSystem.colorRemapGradients) {\n                particleSystem.addColorRemapGradient(colorRemapGradient.gradient, colorRemapGradient.factor1 !== undefined ? colorRemapGradient.factor1 : colorRemapGradient.factor, colorRemapGradient.factor2);\n            }\n        }\n        if (parsedParticleSystem.alphaRemapGradients) {\n            for (const alphaRemapGradient of parsedParticleSystem.alphaRemapGradients) {\n                particleSystem.addAlphaRemapGradient(alphaRemapGradient.gradient, alphaRemapGradient.factor1 !== undefined ? alphaRemapGradient.factor1 : alphaRemapGradient.factor, alphaRemapGradient.factor2);\n            }\n        }\n        if (parsedParticleSystem.sizeGradients) {\n            for (const sizeGradient of parsedParticleSystem.sizeGradients) {\n                particleSystem.addSizeGradient(sizeGradient.gradient, sizeGradient.factor1 !== undefined ? sizeGradient.factor1 : sizeGradient.factor, sizeGradient.factor2);\n            }\n        }\n        if (parsedParticleSystem.angularSpeedGradients) {\n            for (const angularSpeedGradient of parsedParticleSystem.angularSpeedGradients) {\n                particleSystem.addAngularSpeedGradient(angularSpeedGradient.gradient, angularSpeedGradient.factor1 !== undefined ? angularSpeedGradient.factor1 : angularSpeedGradient.factor, angularSpeedGradient.factor2);\n            }\n        }\n        if (parsedParticleSystem.velocityGradients) {\n            for (const velocityGradient of parsedParticleSystem.velocityGradients) {\n                particleSystem.addVelocityGradient(velocityGradient.gradient, velocityGradient.factor1 !== undefined ? velocityGradient.factor1 : velocityGradient.factor, velocityGradient.factor2);\n            }\n        }\n        if (parsedParticleSystem.dragGradients) {\n            for (const dragGradient of parsedParticleSystem.dragGradients) {\n                particleSystem.addDragGradient(dragGradient.gradient, dragGradient.factor1 !== undefined ? dragGradient.factor1 : dragGradient.factor, dragGradient.factor2);\n            }\n        }\n        if (parsedParticleSystem.emitRateGradients) {\n            for (const emitRateGradient of parsedParticleSystem.emitRateGradients) {\n                particleSystem.addEmitRateGradient(emitRateGradient.gradient, emitRateGradient.factor1 !== undefined ? emitRateGradient.factor1 : emitRateGradient.factor, emitRateGradient.factor2);\n            }\n        }\n        if (parsedParticleSystem.startSizeGradients) {\n            for (const startSizeGradient of parsedParticleSystem.startSizeGradients) {\n                particleSystem.addStartSizeGradient(startSizeGradient.gradient, startSizeGradient.factor1 !== undefined ? startSizeGradient.factor1 : startSizeGradient.factor, startSizeGradient.factor2);\n            }\n        }\n        if (parsedParticleSystem.lifeTimeGradients) {\n            for (const lifeTimeGradient of parsedParticleSystem.lifeTimeGradients) {\n                particleSystem.addLifeTimeGradient(lifeTimeGradient.gradient, lifeTimeGradient.factor1 !== undefined ? lifeTimeGradient.factor1 : lifeTimeGradient.factor, lifeTimeGradient.factor2);\n            }\n        }\n        if (parsedParticleSystem.limitVelocityGradients) {\n            for (const limitVelocityGradient of parsedParticleSystem.limitVelocityGradients) {\n                particleSystem.addLimitVelocityGradient(limitVelocityGradient.gradient, limitVelocityGradient.factor1 !== undefined ? limitVelocityGradient.factor1 : limitVelocityGradient.factor, limitVelocityGradient.factor2);\n            }\n            particleSystem.limitVelocityDamping = parsedParticleSystem.limitVelocityDamping;\n        }\n        if (parsedParticleSystem.noiseTexture && scene) {\n            const internalClass = GetClass(\"BABYLON.ProceduralTexture\");\n            particleSystem.noiseTexture = internalClass.Parse(parsedParticleSystem.noiseTexture, scene, rootUrl);\n        }\n        // Emitter\n        let emitterType;\n        if (parsedParticleSystem.particleEmitterType) {\n            switch (parsedParticleSystem.particleEmitterType.type) {\n                case \"SphereParticleEmitter\":\n                    emitterType = new SphereParticleEmitter();\n                    break;\n                case \"SphereDirectedParticleEmitter\":\n                    emitterType = new SphereDirectedParticleEmitter();\n                    break;\n                case \"ConeEmitter\":\n                case \"ConeParticleEmitter\":\n                    emitterType = new ConeParticleEmitter();\n                    break;\n                case \"CylinderParticleEmitter\":\n                    emitterType = new CylinderParticleEmitter();\n                    break;\n                case \"CylinderDirectedParticleEmitter\":\n                    emitterType = new CylinderDirectedParticleEmitter();\n                    break;\n                case \"HemisphericParticleEmitter\":\n                    emitterType = new HemisphericParticleEmitter();\n                    break;\n                case \"PointParticleEmitter\":\n                    emitterType = new PointParticleEmitter();\n                    break;\n                case \"MeshParticleEmitter\":\n                    emitterType = new MeshParticleEmitter();\n                    break;\n                case \"BoxEmitter\":\n                case \"BoxParticleEmitter\":\n                default:\n                    emitterType = new BoxParticleEmitter();\n                    break;\n            }\n            emitterType.parse(parsedParticleSystem.particleEmitterType, scene);\n        }\n        else {\n            emitterType = new BoxParticleEmitter();\n            emitterType.parse(parsedParticleSystem, scene);\n        }\n        particleSystem.particleEmitterType = emitterType;\n        // Animation sheet\n        particleSystem.startSpriteCellID = parsedParticleSystem.startSpriteCellID;\n        particleSystem.endSpriteCellID = parsedParticleSystem.endSpriteCellID;\n        particleSystem.spriteCellLoop = (_a = parsedParticleSystem.spriteCellLoop) !== null && _a !== void 0 ? _a : true;\n        particleSystem.spriteCellWidth = parsedParticleSystem.spriteCellWidth;\n        particleSystem.spriteCellHeight = parsedParticleSystem.spriteCellHeight;\n        particleSystem.spriteCellChangeSpeed = parsedParticleSystem.spriteCellChangeSpeed;\n        particleSystem.spriteRandomStartCell = parsedParticleSystem.spriteRandomStartCell;\n        particleSystem.disposeOnStop = (_b = parsedParticleSystem.disposeOnStop) !== null && _b !== void 0 ? _b : false;\n        particleSystem.manualEmitCount = (_c = parsedParticleSystem.manualEmitCount) !== null && _c !== void 0 ? _c : -1;\n    }\n    /**\n     * Parses a JSON object to create a particle system.\n     * @param parsedParticleSystem The JSON object to parse\n     * @param sceneOrEngine The scene or the engine to create the particle system in\n     * @param rootUrl The root url to use to load external dependencies like texture\n     * @param doNotStart Ignore the preventAutoStart attribute and does not start\n     * @param capacity defines the system capacity (if null or undefined the sotred capacity will be used)\n     * @returns the Parsed particle system\n     */\n    static Parse(parsedParticleSystem, sceneOrEngine, rootUrl, doNotStart = false, capacity) {\n        const name = parsedParticleSystem.name;\n        let custom = null;\n        let program = null;\n        let engine;\n        let scene;\n        if (sceneOrEngine instanceof ThinEngine) {\n            engine = sceneOrEngine;\n        }\n        else {\n            scene = sceneOrEngine;\n            engine = scene.getEngine();\n        }\n        if (parsedParticleSystem.customShader && engine.createEffectForParticles) {\n            program = parsedParticleSystem.customShader;\n            const defines = program.shaderOptions.defines.length > 0 ? program.shaderOptions.defines.join(\"\\n\") : \"\";\n            custom = engine.createEffectForParticles(program.shaderPath.fragmentElement, program.shaderOptions.uniforms, program.shaderOptions.samplers, defines);\n        }\n        const particleSystem = new ParticleSystem(name, capacity || parsedParticleSystem.capacity, sceneOrEngine, custom, parsedParticleSystem.isAnimationSheetEnabled);\n        particleSystem.customShader = program;\n        particleSystem._rootUrl = rootUrl;\n        if (parsedParticleSystem.id) {\n            particleSystem.id = parsedParticleSystem.id;\n        }\n        // SubEmitters\n        if (parsedParticleSystem.subEmitters) {\n            particleSystem.subEmitters = [];\n            for (const cell of parsedParticleSystem.subEmitters) {\n                const cellArray = [];\n                for (const sub of cell) {\n                    cellArray.push(SubEmitter.Parse(sub, sceneOrEngine, rootUrl));\n                }\n                particleSystem.subEmitters.push(cellArray);\n            }\n        }\n        ParticleSystem._Parse(parsedParticleSystem, particleSystem, sceneOrEngine, rootUrl);\n        if (parsedParticleSystem.textureMask) {\n            particleSystem.textureMask = Color4.FromArray(parsedParticleSystem.textureMask);\n        }\n        // Auto start\n        if (parsedParticleSystem.preventAutoStart) {\n            particleSystem.preventAutoStart = parsedParticleSystem.preventAutoStart;\n        }\n        if (!doNotStart && !particleSystem.preventAutoStart) {\n            particleSystem.start();\n        }\n        return particleSystem;\n    }\n}\n/**\n * Billboard mode will only apply to Y axis\n */\nParticleSystem.BILLBOARDMODE_Y = 2;\n/**\n * Billboard mode will apply to all axes\n */\nParticleSystem.BILLBOARDMODE_ALL = 7;\n/**\n * Special billboard mode where the particle will be biilboard to the camera but rotated to align with direction\n */\nParticleSystem.BILLBOARDMODE_STRETCHED = 8;\n/**\n * Special billboard mode where the particle will be billboard to the camera but only around the axis of the direction of particle emission\n */\nParticleSystem.BILLBOARDMODE_STRETCHED_LOCAL = 9;\nSubEmitter._ParseParticleSystem = ParticleSystem.Parse;\n//# sourceMappingURL=particleSystem.js.map","import { Color3 } from \"../Maths/math.color.js\";\nimport { CreateSphere } from \"../Meshes/Builders/sphereBuilder.js\";\nimport { GPUParticleSystem } from \"./gpuParticleSystem.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\nimport { ParticleSystem } from \"../Particles/particleSystem.js\";\nimport { StandardMaterial } from \"../Materials/standardMaterial.js\";\n/** Internal class used to store shapes for emitters */\nclass ParticleSystemSetEmitterCreationOptions {\n}\n/**\n * Represents a set of particle systems working together to create a specific effect\n */\nexport class ParticleSystemSet {\n    constructor() {\n        this._emitterNodeIsOwned = true;\n        /**\n         * Gets the particle system list\n         */\n        this.systems = new Array();\n    }\n    /**\n     * Gets or sets the emitter node used with this set\n     */\n    get emitterNode() {\n        return this._emitterNode;\n    }\n    set emitterNode(value) {\n        if (this._emitterNodeIsOwned && this._emitterNode) {\n            if (this._emitterNode.dispose) {\n                this._emitterNode.dispose();\n            }\n            this._emitterNodeIsOwned = false;\n        }\n        for (const system of this.systems) {\n            system.emitter = value;\n        }\n        this._emitterNode = value;\n    }\n    /**\n     * Creates a new emitter mesh as a sphere\n     * @param options defines the options used to create the sphere\n     * @param options.diameter\n     * @param options.segments\n     * @param options.color\n     * @param renderingGroupId defines the renderingGroupId to use for the sphere\n     * @param scene defines the hosting scene\n     */\n    setEmitterAsSphere(options, renderingGroupId, scene) {\n        if (this._emitterNodeIsOwned && this._emitterNode) {\n            if (this._emitterNode.dispose) {\n                this._emitterNode.dispose();\n            }\n        }\n        this._emitterNodeIsOwned = true;\n        this._emitterCreationOptions = {\n            kind: \"Sphere\",\n            options: options,\n            renderingGroupId: renderingGroupId,\n        };\n        const emitterMesh = CreateSphere(\"emitterSphere\", { diameter: options.diameter, segments: options.segments }, scene);\n        emitterMesh.renderingGroupId = renderingGroupId;\n        const material = new StandardMaterial(\"emitterSphereMaterial\", scene);\n        material.emissiveColor = options.color;\n        emitterMesh.material = material;\n        for (const system of this.systems) {\n            system.emitter = emitterMesh;\n        }\n        this._emitterNode = emitterMesh;\n    }\n    /**\n     * Starts all particle systems of the set\n     * @param emitter defines an optional mesh to use as emitter for the particle systems\n     */\n    start(emitter) {\n        for (const system of this.systems) {\n            if (emitter) {\n                system.emitter = emitter;\n            }\n            system.start();\n        }\n    }\n    /**\n     * Release all associated resources\n     */\n    dispose() {\n        for (const system of this.systems) {\n            system.dispose();\n        }\n        this.systems.length = 0;\n        if (this._emitterNode) {\n            if (this._emitterNode.dispose) {\n                this._emitterNode.dispose();\n            }\n            this._emitterNode = null;\n        }\n    }\n    /**\n     * Serialize the set into a JSON compatible object\n     * @param serializeTexture defines if the texture must be serialized as well\n     * @returns a JSON compatible representation of the set\n     */\n    serialize(serializeTexture = false) {\n        const result = {};\n        result.systems = [];\n        for (const system of this.systems) {\n            result.systems.push(system.serialize(serializeTexture));\n        }\n        if (this._emitterNode) {\n            result.emitter = this._emitterCreationOptions;\n        }\n        return result;\n    }\n    /**\n     * Parse a new ParticleSystemSet from a serialized source\n     * @param data defines a JSON compatible representation of the set\n     * @param scene defines the hosting scene\n     * @param gpu defines if we want GPU particles or CPU particles\n     * @param capacity defines the system capacity (if null or undefined the sotred capacity will be used)\n     * @returns a new ParticleSystemSet\n     */\n    static Parse(data, scene, gpu = false, capacity) {\n        const result = new ParticleSystemSet();\n        const rootUrl = this.BaseAssetsUrl + \"/textures/\";\n        scene = scene || EngineStore.LastCreatedScene;\n        for (const system of data.systems) {\n            result.systems.push(gpu ? GPUParticleSystem.Parse(system, scene, rootUrl, true, capacity) : ParticleSystem.Parse(system, scene, rootUrl, true, capacity));\n        }\n        if (data.emitter) {\n            const options = data.emitter.options;\n            switch (data.emitter.kind) {\n                case \"Sphere\":\n                    result.setEmitterAsSphere({\n                        diameter: options.diameter,\n                        segments: options.segments,\n                        color: Color3.FromArray(options.color),\n                    }, data.emitter.renderingGroupId, scene);\n                    break;\n            }\n        }\n        return result;\n    }\n}\n/**\n * Gets or sets base Assets URL\n */\nParticleSystemSet.BaseAssetsUrl = \"https://assets.babylonjs.com/particles\";\n//# sourceMappingURL=particleSystemSet.js.map","import { Color4, Color3 } from \"../Maths/math.js\";\nimport { Vector2, Vector3, Vector4, TmpVectors, Matrix } from \"../Maths/math.vector.js\";\nimport { Logger } from \"../Misc/logger.js\";\nimport { VertexBuffer } from \"../Buffers/buffer.js\";\nimport { VertexData } from \"../Meshes/mesh.vertexData.js\";\nimport { Mesh } from \"../Meshes/mesh.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\nimport { CloudPoint, PointsGroup } from \"./cloudPoint.js\";\nimport { Ray } from \"../Culling/ray.js\";\nimport { StandardMaterial } from \"../Materials/standardMaterial.js\";\nimport { BaseTexture } from \"./../Materials/Textures/baseTexture.js\";\nimport { Scalar } from \"../Maths/math.scalar.js\";\n/** Defines the 4 color options */\nexport var PointColor;\n(function (PointColor) {\n    /** color value */\n    PointColor[PointColor[\"Color\"] = 2] = \"Color\";\n    /** uv value */\n    PointColor[PointColor[\"UV\"] = 1] = \"UV\";\n    /** random value */\n    PointColor[PointColor[\"Random\"] = 0] = \"Random\";\n    /** stated value */\n    PointColor[PointColor[\"Stated\"] = 3] = \"Stated\";\n})(PointColor || (PointColor = {}));\n/**\n * The PointCloudSystem (PCS) is a single updatable mesh. The points corresponding to the vertices of this big mesh.\n * As it is just a mesh, the PointCloudSystem has all the same properties as any other BJS mesh : not more, not less. It can be scaled, rotated, translated, enlighted, textured, moved, etc.\n\n * The PointCloudSystem is also a particle system, with each point being a particle. It provides some methods to manage the particles.\n * However it is behavior agnostic. This means it has no emitter, no particle physics, no particle recycler. You have to implement your own behavior.\n *\n * Full documentation here : TO BE ENTERED\n */\nexport class PointsCloudSystem {\n    /**\n     * Gets the particle positions computed by the Point Cloud System\n     */\n    get positions() {\n        return this._positions32;\n    }\n    /**\n     * Gets the particle colors computed by the Point Cloud System\n     */\n    get colors() {\n        return this._colors32;\n    }\n    /**\n     * Gets the particle uvs computed by the Point Cloud System\n     */\n    get uvs() {\n        return this._uvs32;\n    }\n    /**\n     * Creates a PCS (Points Cloud System) object\n     * @param name (String) is the PCS name, this will be the underlying mesh name\n     * @param pointSize (number) is the size for each point. Has no effect on a WebGPU engine.\n     * @param scene (Scene) is the scene in which the PCS is added\n     * @param options defines the options of the PCS e.g.\n     * * updatable (optional boolean, default true) : if the PCS must be updatable or immutable\n     * @param options.updatable\n     */\n    constructor(name, pointSize, scene, options) {\n        /**\n         *  The PCS array of cloud point objects. Just access each particle as with any classic array.\n         *  Example : var p = SPS.particles[i];\n         */\n        this.particles = new Array();\n        /**\n         * The PCS total number of particles. Read only. Use PCS.counter instead if you need to set your own value.\n         */\n        this.nbParticles = 0;\n        /**\n         * This a counter for your own usage. It's not set by any SPS functions.\n         */\n        this.counter = 0;\n        /**\n         * This empty object is intended to store some PCS specific or temporary values in order to lower the Garbage Collector activity.\n         * Please read :\n         */\n        this.vars = {};\n        this._promises = [];\n        this._positions = new Array();\n        this._indices = new Array();\n        this._normals = new Array();\n        this._colors = new Array();\n        this._uvs = new Array();\n        this._updatable = true;\n        this._isVisibilityBoxLocked = false;\n        this._alwaysVisible = false;\n        this._groups = new Array(); //start indices for each group of particles\n        this._groupCounter = 0;\n        this._computeParticleColor = true;\n        this._computeParticleTexture = true;\n        this._computeParticleRotation = true;\n        this._computeBoundingBox = false;\n        this._isReady = false;\n        this.name = name;\n        this._size = pointSize;\n        this._scene = scene || EngineStore.LastCreatedScene;\n        if (options && options.updatable !== undefined) {\n            this._updatable = options.updatable;\n        }\n        else {\n            this._updatable = true;\n        }\n    }\n    /**\n     * Builds the PCS underlying mesh. Returns a standard Mesh.\n     * If no points were added to the PCS, the returned mesh is just a single point.\n     * @param material The material to use to render the mesh. If not provided, will create a default one\n     * @returns a promise for the created mesh\n     */\n    buildMeshAsync(material) {\n        return Promise.all(this._promises).then(() => {\n            this._isReady = true;\n            return this._buildMesh(material);\n        });\n    }\n    /**\n     * @internal\n     */\n    _buildMesh(material) {\n        if (this.nbParticles === 0) {\n            this.addPoints(1);\n        }\n        this._positions32 = new Float32Array(this._positions);\n        this._uvs32 = new Float32Array(this._uvs);\n        this._colors32 = new Float32Array(this._colors);\n        const vertexData = new VertexData();\n        vertexData.set(this._positions32, VertexBuffer.PositionKind);\n        if (this._uvs32.length > 0) {\n            vertexData.set(this._uvs32, VertexBuffer.UVKind);\n        }\n        let ec = 0; //emissive color value 0 for UVs, 1 for color\n        if (this._colors32.length > 0) {\n            ec = 1;\n            vertexData.set(this._colors32, VertexBuffer.ColorKind);\n        }\n        const mesh = new Mesh(this.name, this._scene);\n        vertexData.applyToMesh(mesh, this._updatable);\n        this.mesh = mesh;\n        // free memory\n        this._positions = null;\n        this._uvs = null;\n        this._colors = null;\n        if (!this._updatable) {\n            this.particles.length = 0;\n        }\n        let mat = material;\n        if (!mat) {\n            mat = new StandardMaterial(\"point cloud material\", this._scene);\n            mat.emissiveColor = new Color3(ec, ec, ec);\n            mat.disableLighting = true;\n            mat.pointsCloud = true;\n            mat.pointSize = this._size;\n        }\n        mesh.material = mat;\n        return new Promise((resolve) => resolve(mesh));\n    }\n    // adds a new particle object in the particles array\n    _addParticle(idx, group, groupId, idxInGroup) {\n        const cp = new CloudPoint(idx, group, groupId, idxInGroup, this);\n        this.particles.push(cp);\n        return cp;\n    }\n    _randomUnitVector(particle) {\n        particle.position = new Vector3(Math.random(), Math.random(), Math.random());\n        particle.color = new Color4(1, 1, 1, 1);\n    }\n    _getColorIndicesForCoord(pointsGroup, x, y, width) {\n        const imageData = pointsGroup._groupImageData;\n        const color = y * (width * 4) + x * 4;\n        const colorIndices = [color, color + 1, color + 2, color + 3];\n        const redIndex = colorIndices[0];\n        const greenIndex = colorIndices[1];\n        const blueIndex = colorIndices[2];\n        const alphaIndex = colorIndices[3];\n        const redForCoord = imageData[redIndex];\n        const greenForCoord = imageData[greenIndex];\n        const blueForCoord = imageData[blueIndex];\n        const alphaForCoord = imageData[alphaIndex];\n        return new Color4(redForCoord / 255, greenForCoord / 255, blueForCoord / 255, alphaForCoord);\n    }\n    _setPointsColorOrUV(mesh, pointsGroup, isVolume, colorFromTexture, hasTexture, color, range) {\n        if (isVolume) {\n            mesh.updateFacetData();\n        }\n        const boundInfo = mesh.getBoundingInfo();\n        const diameter = 2 * boundInfo.boundingSphere.radius;\n        let meshPos = mesh.getVerticesData(VertexBuffer.PositionKind);\n        const meshInd = mesh.getIndices();\n        const meshUV = mesh.getVerticesData(VertexBuffer.UVKind);\n        const meshCol = mesh.getVerticesData(VertexBuffer.ColorKind);\n        const place = Vector3.Zero();\n        mesh.computeWorldMatrix();\n        const meshMatrix = mesh.getWorldMatrix();\n        if (!meshMatrix.isIdentity()) {\n            meshPos = meshPos.slice(0);\n            for (let p = 0; p < meshPos.length / 3; p++) {\n                Vector3.TransformCoordinatesFromFloatsToRef(meshPos[3 * p], meshPos[3 * p + 1], meshPos[3 * p + 2], meshMatrix, place);\n                meshPos[3 * p] = place.x;\n                meshPos[3 * p + 1] = place.y;\n                meshPos[3 * p + 2] = place.z;\n            }\n        }\n        let idxPoints = 0;\n        let id0 = 0;\n        let id1 = 0;\n        let id2 = 0;\n        let v0X = 0;\n        let v0Y = 0;\n        let v0Z = 0;\n        let v1X = 0;\n        let v1Y = 0;\n        let v1Z = 0;\n        let v2X = 0;\n        let v2Y = 0;\n        let v2Z = 0;\n        const vertex0 = Vector3.Zero();\n        const vertex1 = Vector3.Zero();\n        const vertex2 = Vector3.Zero();\n        const vec0 = Vector3.Zero();\n        const vec1 = Vector3.Zero();\n        let uv0X = 0;\n        let uv0Y = 0;\n        let uv1X = 0;\n        let uv1Y = 0;\n        let uv2X = 0;\n        let uv2Y = 0;\n        const uv0 = Vector2.Zero();\n        const uv1 = Vector2.Zero();\n        const uv2 = Vector2.Zero();\n        const uvec0 = Vector2.Zero();\n        const uvec1 = Vector2.Zero();\n        let col0X = 0;\n        let col0Y = 0;\n        let col0Z = 0;\n        let col0A = 0;\n        let col1X = 0;\n        let col1Y = 0;\n        let col1Z = 0;\n        let col1A = 0;\n        let col2X = 0;\n        let col2Y = 0;\n        let col2Z = 0;\n        let col2A = 0;\n        const col0 = Vector4.Zero();\n        const col1 = Vector4.Zero();\n        const col2 = Vector4.Zero();\n        const colvec0 = Vector4.Zero();\n        const colvec1 = Vector4.Zero();\n        let lamda = 0;\n        let mu = 0;\n        range = range ? range : 0;\n        let facetPoint;\n        let uvPoint;\n        let colPoint = new Vector4(0, 0, 0, 0);\n        let norm = Vector3.Zero();\n        let tang = Vector3.Zero();\n        let biNorm = Vector3.Zero();\n        let angle = 0;\n        let facetPlaneVec = Vector3.Zero();\n        let gap = 0;\n        let distance = 0;\n        const ray = new Ray(Vector3.Zero(), new Vector3(1, 0, 0));\n        let pickInfo;\n        let direction = Vector3.Zero();\n        for (let index = 0; index < meshInd.length / 3; index++) {\n            id0 = meshInd[3 * index];\n            id1 = meshInd[3 * index + 1];\n            id2 = meshInd[3 * index + 2];\n            v0X = meshPos[3 * id0];\n            v0Y = meshPos[3 * id0 + 1];\n            v0Z = meshPos[3 * id0 + 2];\n            v1X = meshPos[3 * id1];\n            v1Y = meshPos[3 * id1 + 1];\n            v1Z = meshPos[3 * id1 + 2];\n            v2X = meshPos[3 * id2];\n            v2Y = meshPos[3 * id2 + 1];\n            v2Z = meshPos[3 * id2 + 2];\n            vertex0.set(v0X, v0Y, v0Z);\n            vertex1.set(v1X, v1Y, v1Z);\n            vertex2.set(v2X, v2Y, v2Z);\n            vertex1.subtractToRef(vertex0, vec0);\n            vertex2.subtractToRef(vertex1, vec1);\n            if (meshUV) {\n                uv0X = meshUV[2 * id0];\n                uv0Y = meshUV[2 * id0 + 1];\n                uv1X = meshUV[2 * id1];\n                uv1Y = meshUV[2 * id1 + 1];\n                uv2X = meshUV[2 * id2];\n                uv2Y = meshUV[2 * id2 + 1];\n                uv0.set(uv0X, uv0Y);\n                uv1.set(uv1X, uv1Y);\n                uv2.set(uv2X, uv2Y);\n                uv1.subtractToRef(uv0, uvec0);\n                uv2.subtractToRef(uv1, uvec1);\n            }\n            if (meshCol && colorFromTexture) {\n                col0X = meshCol[4 * id0];\n                col0Y = meshCol[4 * id0 + 1];\n                col0Z = meshCol[4 * id0 + 2];\n                col0A = meshCol[4 * id0 + 3];\n                col1X = meshCol[4 * id1];\n                col1Y = meshCol[4 * id1 + 1];\n                col1Z = meshCol[4 * id1 + 2];\n                col1A = meshCol[4 * id1 + 3];\n                col2X = meshCol[4 * id2];\n                col2Y = meshCol[4 * id2 + 1];\n                col2Z = meshCol[4 * id2 + 2];\n                col2A = meshCol[4 * id2 + 3];\n                col0.set(col0X, col0Y, col0Z, col0A);\n                col1.set(col1X, col1Y, col1Z, col1A);\n                col2.set(col2X, col2Y, col2Z, col2A);\n                col1.subtractToRef(col0, colvec0);\n                col2.subtractToRef(col1, colvec1);\n            }\n            let width;\n            let height;\n            let deltaS;\n            let deltaV;\n            let h;\n            let s;\n            let v;\n            let hsvCol;\n            const statedColor = new Color3(0, 0, 0);\n            const colPoint3 = new Color3(0, 0, 0);\n            let pointColors;\n            let particle;\n            for (let i = 0; i < pointsGroup._groupDensity[index]; i++) {\n                idxPoints = this.particles.length;\n                this._addParticle(idxPoints, pointsGroup, this._groupCounter, index + i);\n                particle = this.particles[idxPoints];\n                //form a point inside the facet v0, v1, v2;\n                lamda = Scalar.RandomRange(0, 1);\n                mu = Scalar.RandomRange(0, 1);\n                facetPoint = vertex0.add(vec0.scale(lamda)).add(vec1.scale(lamda * mu));\n                if (isVolume) {\n                    norm = mesh.getFacetNormal(index).normalize().scale(-1);\n                    tang = vec0.clone().normalize();\n                    biNorm = Vector3.Cross(norm, tang);\n                    angle = Scalar.RandomRange(0, 2 * Math.PI);\n                    facetPlaneVec = tang.scale(Math.cos(angle)).add(biNorm.scale(Math.sin(angle)));\n                    angle = Scalar.RandomRange(0.1, Math.PI / 2);\n                    direction = facetPlaneVec.scale(Math.cos(angle)).add(norm.scale(Math.sin(angle)));\n                    ray.origin = facetPoint.add(direction.scale(0.00001));\n                    ray.direction = direction;\n                    ray.length = diameter;\n                    pickInfo = ray.intersectsMesh(mesh);\n                    if (pickInfo.hit) {\n                        distance = pickInfo.pickedPoint.subtract(facetPoint).length();\n                        gap = Scalar.RandomRange(0, 1) * distance;\n                        facetPoint.addInPlace(direction.scale(gap));\n                    }\n                }\n                particle.position = facetPoint.clone();\n                this._positions.push(particle.position.x, particle.position.y, particle.position.z);\n                if (colorFromTexture !== undefined) {\n                    if (meshUV) {\n                        uvPoint = uv0.add(uvec0.scale(lamda)).add(uvec1.scale(lamda * mu));\n                        if (colorFromTexture) {\n                            //Set particle color to texture color\n                            if (hasTexture && pointsGroup._groupImageData !== null) {\n                                width = pointsGroup._groupImgWidth;\n                                height = pointsGroup._groupImgHeight;\n                                pointColors = this._getColorIndicesForCoord(pointsGroup, Math.round(uvPoint.x * width), Math.round(uvPoint.y * height), width);\n                                particle.color = pointColors;\n                                this._colors.push(pointColors.r, pointColors.g, pointColors.b, pointColors.a);\n                            }\n                            else {\n                                if (meshCol) {\n                                    //failure in texture and colors available\n                                    colPoint = col0.add(colvec0.scale(lamda)).add(colvec1.scale(lamda * mu));\n                                    particle.color = new Color4(colPoint.x, colPoint.y, colPoint.z, colPoint.w);\n                                    this._colors.push(colPoint.x, colPoint.y, colPoint.z, colPoint.w);\n                                }\n                                else {\n                                    colPoint = col0.set(Math.random(), Math.random(), Math.random(), 1);\n                                    particle.color = new Color4(colPoint.x, colPoint.y, colPoint.z, colPoint.w);\n                                    this._colors.push(colPoint.x, colPoint.y, colPoint.z, colPoint.w);\n                                }\n                            }\n                        }\n                        else {\n                            //Set particle uv based on a mesh uv\n                            particle.uv = uvPoint.clone();\n                            this._uvs.push(particle.uv.x, particle.uv.y);\n                        }\n                    }\n                }\n                else {\n                    if (color) {\n                        statedColor.set(color.r, color.g, color.b);\n                        deltaS = Scalar.RandomRange(-range, range);\n                        deltaV = Scalar.RandomRange(-range, range);\n                        hsvCol = statedColor.toHSV();\n                        h = hsvCol.r;\n                        s = hsvCol.g + deltaS;\n                        v = hsvCol.b + deltaV;\n                        if (s < 0) {\n                            s = 0;\n                        }\n                        if (s > 1) {\n                            s = 1;\n                        }\n                        if (v < 0) {\n                            v = 0;\n                        }\n                        if (v > 1) {\n                            v = 1;\n                        }\n                        Color3.HSVtoRGBToRef(h, s, v, colPoint3);\n                        colPoint.set(colPoint3.r, colPoint3.g, colPoint3.b, 1);\n                    }\n                    else {\n                        colPoint = col0.set(Math.random(), Math.random(), Math.random(), 1);\n                    }\n                    particle.color = new Color4(colPoint.x, colPoint.y, colPoint.z, colPoint.w);\n                    this._colors.push(colPoint.x, colPoint.y, colPoint.z, colPoint.w);\n                }\n            }\n        }\n    }\n    // stores mesh texture in dynamic texture for color pixel retrieval\n    // when pointColor type is color for surface points\n    _colorFromTexture(mesh, pointsGroup, isVolume) {\n        if (mesh.material === null) {\n            Logger.Warn(mesh.name + \"has no material.\");\n            pointsGroup._groupImageData = null;\n            this._setPointsColorOrUV(mesh, pointsGroup, isVolume, true, false);\n            return;\n        }\n        const mat = mesh.material;\n        const textureList = mat.getActiveTextures();\n        if (textureList.length === 0) {\n            Logger.Warn(mesh.name + \"has no usable texture.\");\n            pointsGroup._groupImageData = null;\n            this._setPointsColorOrUV(mesh, pointsGroup, isVolume, true, false);\n            return;\n        }\n        const clone = mesh.clone();\n        clone.setEnabled(false);\n        this._promises.push(new Promise((resolve) => {\n            BaseTexture.WhenAllReady(textureList, () => {\n                let n = pointsGroup._textureNb;\n                if (n < 0) {\n                    n = 0;\n                }\n                if (n > textureList.length - 1) {\n                    n = textureList.length - 1;\n                }\n                const finalize = () => {\n                    pointsGroup._groupImgWidth = textureList[n].getSize().width;\n                    pointsGroup._groupImgHeight = textureList[n].getSize().height;\n                    this._setPointsColorOrUV(clone, pointsGroup, isVolume, true, true);\n                    clone.dispose();\n                    resolve();\n                };\n                pointsGroup._groupImageData = null;\n                const dataPromise = textureList[n].readPixels();\n                if (!dataPromise) {\n                    finalize();\n                }\n                else {\n                    dataPromise.then((data) => {\n                        pointsGroup._groupImageData = data;\n                        finalize();\n                    });\n                }\n            });\n        }));\n    }\n    // calculates the point density per facet of a mesh for surface points\n    _calculateDensity(nbPoints, positions, indices) {\n        let density = new Array();\n        let id0;\n        let id1;\n        let id2;\n        let v0X;\n        let v0Y;\n        let v0Z;\n        let v1X;\n        let v1Y;\n        let v1Z;\n        let v2X;\n        let v2Y;\n        let v2Z;\n        const vertex0 = Vector3.Zero();\n        const vertex1 = Vector3.Zero();\n        const vertex2 = Vector3.Zero();\n        const vec0 = Vector3.Zero();\n        const vec1 = Vector3.Zero();\n        const vec2 = Vector3.Zero();\n        let a; //length of side of triangle\n        let b; //length of side of triangle\n        let c; //length of side of triangle\n        let p; //perimeter of triangle\n        let area;\n        const areas = new Array();\n        let surfaceArea = 0;\n        const nbFacets = indices.length / 3;\n        //surface area\n        for (let index = 0; index < nbFacets; index++) {\n            id0 = indices[3 * index];\n            id1 = indices[3 * index + 1];\n            id2 = indices[3 * index + 2];\n            v0X = positions[3 * id0];\n            v0Y = positions[3 * id0 + 1];\n            v0Z = positions[3 * id0 + 2];\n            v1X = positions[3 * id1];\n            v1Y = positions[3 * id1 + 1];\n            v1Z = positions[3 * id1 + 2];\n            v2X = positions[3 * id2];\n            v2Y = positions[3 * id2 + 1];\n            v2Z = positions[3 * id2 + 2];\n            vertex0.set(v0X, v0Y, v0Z);\n            vertex1.set(v1X, v1Y, v1Z);\n            vertex2.set(v2X, v2Y, v2Z);\n            vertex1.subtractToRef(vertex0, vec0);\n            vertex2.subtractToRef(vertex1, vec1);\n            vertex2.subtractToRef(vertex0, vec2);\n            a = vec0.length();\n            b = vec1.length();\n            c = vec2.length();\n            p = (a + b + c) / 2;\n            area = Math.sqrt(p * (p - a) * (p - b) * (p - c));\n            surfaceArea += area;\n            areas[index] = area;\n        }\n        let pointCount = 0;\n        for (let index = 0; index < nbFacets; index++) {\n            density[index] = Math.floor((nbPoints * areas[index]) / surfaceArea);\n            pointCount += density[index];\n        }\n        const diff = nbPoints - pointCount;\n        const pointsPerFacet = Math.floor(diff / nbFacets);\n        const extraPoints = diff % nbFacets;\n        if (pointsPerFacet > 0) {\n            density = density.map((x) => x + pointsPerFacet);\n        }\n        for (let index = 0; index < extraPoints; index++) {\n            density[index] += 1;\n        }\n        return density;\n    }\n    /**\n     * Adds points to the PCS in random positions within a unit sphere\n     * @param nb (positive integer) the number of particles to be created from this model\n     * @param pointFunction is an optional javascript function to be called for each particle on PCS creation\n     * @returns the number of groups in the system\n     */\n    addPoints(nb, pointFunction = this._randomUnitVector) {\n        const pointsGroup = new PointsGroup(this._groupCounter, pointFunction);\n        let cp;\n        // particles\n        let idx = this.nbParticles;\n        for (let i = 0; i < nb; i++) {\n            cp = this._addParticle(idx, pointsGroup, this._groupCounter, i);\n            if (pointsGroup && pointsGroup._positionFunction) {\n                pointsGroup._positionFunction(cp, idx, i);\n            }\n            this._positions.push(cp.position.x, cp.position.y, cp.position.z);\n            if (cp.color) {\n                this._colors.push(cp.color.r, cp.color.g, cp.color.b, cp.color.a);\n            }\n            if (cp.uv) {\n                this._uvs.push(cp.uv.x, cp.uv.y);\n            }\n            idx++;\n        }\n        this.nbParticles += nb;\n        this._groupCounter++;\n        return this._groupCounter;\n    }\n    /**\n     * Adds points to the PCS from the surface of the model shape\n     * @param mesh is any Mesh object that will be used as a surface model for the points\n     * @param nb (positive integer) the number of particles to be created from this model\n     * @param colorWith determines whether a point is colored using color (default), uv, random, stated or none (invisible)\n     * @param color (color4) to be used when colorWith is stated or color (number) when used to specify texture position\n     * @param range (number from 0 to 1) to determine the variation in shape and tone for a stated color\n     * @returns the number of groups in the system\n     */\n    addSurfacePoints(mesh, nb, colorWith, color, range) {\n        let colored = colorWith ? colorWith : PointColor.Random;\n        if (isNaN(colored) || colored < 0 || colored > 3) {\n            colored = PointColor.Random;\n        }\n        const meshPos = mesh.getVerticesData(VertexBuffer.PositionKind);\n        const meshInd = mesh.getIndices();\n        this._groups.push(this._groupCounter);\n        const pointsGroup = new PointsGroup(this._groupCounter, null);\n        pointsGroup._groupDensity = this._calculateDensity(nb, meshPos, meshInd);\n        if (colored === PointColor.Color) {\n            pointsGroup._textureNb = color ? color : 0;\n        }\n        else {\n            color = color ? color : new Color4(1, 1, 1, 1);\n        }\n        switch (colored) {\n            case PointColor.Color:\n                this._colorFromTexture(mesh, pointsGroup, false);\n                break;\n            case PointColor.UV:\n                this._setPointsColorOrUV(mesh, pointsGroup, false, false, false);\n                break;\n            case PointColor.Random:\n                this._setPointsColorOrUV(mesh, pointsGroup, false);\n                break;\n            case PointColor.Stated:\n                this._setPointsColorOrUV(mesh, pointsGroup, false, undefined, undefined, color, range);\n                break;\n        }\n        this.nbParticles += nb;\n        this._groupCounter++;\n        return this._groupCounter - 1;\n    }\n    /**\n     * Adds points to the PCS inside the model shape\n     * @param mesh is any Mesh object that will be used as a surface model for the points\n     * @param nb (positive integer) the number of particles to be created from this model\n     * @param colorWith determines whether a point is colored using color (default), uv, random, stated or none (invisible)\n     * @param color (color4) to be used when colorWith is stated or color (number) when used to specify texture position\n     * @param range (number from 0 to 1) to determine the variation in shape and tone for a stated color\n     * @returns the number of groups in the system\n     */\n    addVolumePoints(mesh, nb, colorWith, color, range) {\n        let colored = colorWith ? colorWith : PointColor.Random;\n        if (isNaN(colored) || colored < 0 || colored > 3) {\n            colored = PointColor.Random;\n        }\n        const meshPos = mesh.getVerticesData(VertexBuffer.PositionKind);\n        const meshInd = mesh.getIndices();\n        this._groups.push(this._groupCounter);\n        const pointsGroup = new PointsGroup(this._groupCounter, null);\n        pointsGroup._groupDensity = this._calculateDensity(nb, meshPos, meshInd);\n        if (colored === PointColor.Color) {\n            pointsGroup._textureNb = color ? color : 0;\n        }\n        else {\n            color = color ? color : new Color4(1, 1, 1, 1);\n        }\n        switch (colored) {\n            case PointColor.Color:\n                this._colorFromTexture(mesh, pointsGroup, true);\n                break;\n            case PointColor.UV:\n                this._setPointsColorOrUV(mesh, pointsGroup, true, false, false);\n                break;\n            case PointColor.Random:\n                this._setPointsColorOrUV(mesh, pointsGroup, true);\n                break;\n            case PointColor.Stated:\n                this._setPointsColorOrUV(mesh, pointsGroup, true, undefined, undefined, color, range);\n                break;\n        }\n        this.nbParticles += nb;\n        this._groupCounter++;\n        return this._groupCounter - 1;\n    }\n    /**\n     *  Sets all the particles : this method actually really updates the mesh according to the particle positions, rotations, colors, textures, etc.\n     *  This method calls `updateParticle()` for each particle of the SPS.\n     *  For an animated SPS, it is usually called within the render loop.\n     * @param start The particle index in the particle array where to start to compute the particle property values _(default 0)_\n     * @param end The particle index in the particle array where to stop to compute the particle property values _(default nbParticle - 1)_\n     * @param update If the mesh must be finally updated on this call after all the particle computations _(default true)_\n     * @returns the PCS.\n     */\n    setParticles(start = 0, end = this.nbParticles - 1, update = true) {\n        var _a, _b;\n        if (!this._updatable || !this._isReady) {\n            return this;\n        }\n        // custom beforeUpdate\n        this.beforeUpdateParticles(start, end, update);\n        const rotMatrix = TmpVectors.Matrix[0];\n        const mesh = this.mesh;\n        const colors32 = this._colors32;\n        const positions32 = this._positions32;\n        const uvs32 = this._uvs32;\n        const tempVectors = TmpVectors.Vector3;\n        const camAxisX = tempVectors[5].copyFromFloats(1.0, 0.0, 0.0);\n        const camAxisY = tempVectors[6].copyFromFloats(0.0, 1.0, 0.0);\n        const camAxisZ = tempVectors[7].copyFromFloats(0.0, 0.0, 1.0);\n        const minimum = tempVectors[8].setAll(Number.MAX_VALUE);\n        const maximum = tempVectors[9].setAll(-Number.MAX_VALUE);\n        Matrix.IdentityToRef(rotMatrix);\n        let idx = 0; // current index of the particle\n        if ((_a = this.mesh) === null || _a === void 0 ? void 0 : _a.isFacetDataEnabled) {\n            this._computeBoundingBox = true;\n        }\n        end = end >= this.nbParticles ? this.nbParticles - 1 : end;\n        if (this._computeBoundingBox) {\n            if (start != 0 || end != this.nbParticles - 1) {\n                // only some particles are updated, then use the current existing BBox basis. Note : it can only increase.\n                const boundingInfo = (_b = this.mesh) === null || _b === void 0 ? void 0 : _b.getBoundingInfo();\n                if (boundingInfo) {\n                    minimum.copyFrom(boundingInfo.minimum);\n                    maximum.copyFrom(boundingInfo.maximum);\n                }\n            }\n        }\n        idx = 0; // particle index\n        let pindex = 0; //index in positions array\n        let cindex = 0; //index in color array\n        let uindex = 0; //index in uv array\n        // particle loop\n        for (let p = start; p <= end; p++) {\n            const particle = this.particles[p];\n            idx = particle.idx;\n            pindex = 3 * idx;\n            cindex = 4 * idx;\n            uindex = 2 * idx;\n            // call to custom user function to update the particle properties\n            this.updateParticle(particle);\n            const particleRotationMatrix = particle._rotationMatrix;\n            const particlePosition = particle.position;\n            const particleGlobalPosition = particle._globalPosition;\n            if (this._computeParticleRotation) {\n                particle.getRotationMatrix(rotMatrix);\n            }\n            const particleHasParent = particle.parentId !== null;\n            if (particleHasParent) {\n                const parent = this.particles[particle.parentId];\n                const parentRotationMatrix = parent._rotationMatrix;\n                const parentGlobalPosition = parent._globalPosition;\n                const rotatedY = particlePosition.x * parentRotationMatrix[1] + particlePosition.y * parentRotationMatrix[4] + particlePosition.z * parentRotationMatrix[7];\n                const rotatedX = particlePosition.x * parentRotationMatrix[0] + particlePosition.y * parentRotationMatrix[3] + particlePosition.z * parentRotationMatrix[6];\n                const rotatedZ = particlePosition.x * parentRotationMatrix[2] + particlePosition.y * parentRotationMatrix[5] + particlePosition.z * parentRotationMatrix[8];\n                particleGlobalPosition.x = parentGlobalPosition.x + rotatedX;\n                particleGlobalPosition.y = parentGlobalPosition.y + rotatedY;\n                particleGlobalPosition.z = parentGlobalPosition.z + rotatedZ;\n                if (this._computeParticleRotation) {\n                    const rotMatrixValues = rotMatrix.m;\n                    particleRotationMatrix[0] =\n                        rotMatrixValues[0] * parentRotationMatrix[0] + rotMatrixValues[1] * parentRotationMatrix[3] + rotMatrixValues[2] * parentRotationMatrix[6];\n                    particleRotationMatrix[1] =\n                        rotMatrixValues[0] * parentRotationMatrix[1] + rotMatrixValues[1] * parentRotationMatrix[4] + rotMatrixValues[2] * parentRotationMatrix[7];\n                    particleRotationMatrix[2] =\n                        rotMatrixValues[0] * parentRotationMatrix[2] + rotMatrixValues[1] * parentRotationMatrix[5] + rotMatrixValues[2] * parentRotationMatrix[8];\n                    particleRotationMatrix[3] =\n                        rotMatrixValues[4] * parentRotationMatrix[0] + rotMatrixValues[5] * parentRotationMatrix[3] + rotMatrixValues[6] * parentRotationMatrix[6];\n                    particleRotationMatrix[4] =\n                        rotMatrixValues[4] * parentRotationMatrix[1] + rotMatrixValues[5] * parentRotationMatrix[4] + rotMatrixValues[6] * parentRotationMatrix[7];\n                    particleRotationMatrix[5] =\n                        rotMatrixValues[4] * parentRotationMatrix[2] + rotMatrixValues[5] * parentRotationMatrix[5] + rotMatrixValues[6] * parentRotationMatrix[8];\n                    particleRotationMatrix[6] =\n                        rotMatrixValues[8] * parentRotationMatrix[0] + rotMatrixValues[9] * parentRotationMatrix[3] + rotMatrixValues[10] * parentRotationMatrix[6];\n                    particleRotationMatrix[7] =\n                        rotMatrixValues[8] * parentRotationMatrix[1] + rotMatrixValues[9] * parentRotationMatrix[4] + rotMatrixValues[10] * parentRotationMatrix[7];\n                    particleRotationMatrix[8] =\n                        rotMatrixValues[8] * parentRotationMatrix[2] + rotMatrixValues[9] * parentRotationMatrix[5] + rotMatrixValues[10] * parentRotationMatrix[8];\n                }\n            }\n            else {\n                particleGlobalPosition.x = 0;\n                particleGlobalPosition.y = 0;\n                particleGlobalPosition.z = 0;\n                if (this._computeParticleRotation) {\n                    const rotMatrixValues = rotMatrix.m;\n                    particleRotationMatrix[0] = rotMatrixValues[0];\n                    particleRotationMatrix[1] = rotMatrixValues[1];\n                    particleRotationMatrix[2] = rotMatrixValues[2];\n                    particleRotationMatrix[3] = rotMatrixValues[4];\n                    particleRotationMatrix[4] = rotMatrixValues[5];\n                    particleRotationMatrix[5] = rotMatrixValues[6];\n                    particleRotationMatrix[6] = rotMatrixValues[8];\n                    particleRotationMatrix[7] = rotMatrixValues[9];\n                    particleRotationMatrix[8] = rotMatrixValues[10];\n                }\n            }\n            const pivotBackTranslation = tempVectors[11];\n            if (particle.translateFromPivot) {\n                pivotBackTranslation.setAll(0.0);\n            }\n            else {\n                pivotBackTranslation.copyFrom(particle.pivot);\n            }\n            // positions\n            const tmpVertex = tempVectors[0];\n            tmpVertex.copyFrom(particle.position);\n            const vertexX = tmpVertex.x - particle.pivot.x;\n            const vertexY = tmpVertex.y - particle.pivot.y;\n            const vertexZ = tmpVertex.z - particle.pivot.z;\n            let rotatedX = vertexX * particleRotationMatrix[0] + vertexY * particleRotationMatrix[3] + vertexZ * particleRotationMatrix[6];\n            let rotatedY = vertexX * particleRotationMatrix[1] + vertexY * particleRotationMatrix[4] + vertexZ * particleRotationMatrix[7];\n            let rotatedZ = vertexX * particleRotationMatrix[2] + vertexY * particleRotationMatrix[5] + vertexZ * particleRotationMatrix[8];\n            rotatedX += pivotBackTranslation.x;\n            rotatedY += pivotBackTranslation.y;\n            rotatedZ += pivotBackTranslation.z;\n            const px = (positions32[pindex] = particleGlobalPosition.x + camAxisX.x * rotatedX + camAxisY.x * rotatedY + camAxisZ.x * rotatedZ);\n            const py = (positions32[pindex + 1] = particleGlobalPosition.y + camAxisX.y * rotatedX + camAxisY.y * rotatedY + camAxisZ.y * rotatedZ);\n            const pz = (positions32[pindex + 2] = particleGlobalPosition.z + camAxisX.z * rotatedX + camAxisY.z * rotatedY + camAxisZ.z * rotatedZ);\n            if (this._computeBoundingBox) {\n                minimum.minimizeInPlaceFromFloats(px, py, pz);\n                maximum.maximizeInPlaceFromFloats(px, py, pz);\n            }\n            if (this._computeParticleColor && particle.color) {\n                const color = particle.color;\n                const colors32 = this._colors32;\n                colors32[cindex] = color.r;\n                colors32[cindex + 1] = color.g;\n                colors32[cindex + 2] = color.b;\n                colors32[cindex + 3] = color.a;\n            }\n            if (this._computeParticleTexture && particle.uv) {\n                const uv = particle.uv;\n                const uvs32 = this._uvs32;\n                uvs32[uindex] = uv.x;\n                uvs32[uindex + 1] = uv.y;\n            }\n        }\n        // if the VBO must be updated\n        if (mesh) {\n            if (update) {\n                if (this._computeParticleColor) {\n                    mesh.updateVerticesData(VertexBuffer.ColorKind, colors32, false, false);\n                }\n                if (this._computeParticleTexture) {\n                    mesh.updateVerticesData(VertexBuffer.UVKind, uvs32, false, false);\n                }\n                mesh.updateVerticesData(VertexBuffer.PositionKind, positions32, false, false);\n            }\n            if (this._computeBoundingBox) {\n                if (mesh.hasBoundingInfo) {\n                    mesh.getBoundingInfo().reConstruct(minimum, maximum, mesh._worldMatrix);\n                }\n                else {\n                    mesh.buildBoundingInfo(minimum, maximum, mesh._worldMatrix);\n                }\n            }\n        }\n        this.afterUpdateParticles(start, end, update);\n        return this;\n    }\n    /**\n     * Disposes the PCS.\n     */\n    dispose() {\n        var _a;\n        (_a = this.mesh) === null || _a === void 0 ? void 0 : _a.dispose();\n        this.vars = null;\n        // drop references to internal big arrays for the GC\n        this._positions = null;\n        this._indices = null;\n        this._normals = null;\n        this._uvs = null;\n        this._colors = null;\n        this._indices32 = null;\n        this._positions32 = null;\n        this._uvs32 = null;\n        this._colors32 = null;\n    }\n    /**\n     * Visibility helper : Recomputes the visible size according to the mesh bounding box\n     * doc :\n     * @returns the PCS.\n     */\n    refreshVisibleSize() {\n        var _a;\n        if (!this._isVisibilityBoxLocked) {\n            (_a = this.mesh) === null || _a === void 0 ? void 0 : _a.refreshBoundingInfo();\n        }\n        return this;\n    }\n    /**\n     * Visibility helper : Sets the size of a visibility box, this sets the underlying mesh bounding box.\n     * @param size the size (float) of the visibility box\n     * note : this doesn't lock the PCS mesh bounding box.\n     * doc :\n     */\n    setVisibilityBox(size) {\n        if (!this.mesh) {\n            return;\n        }\n        const vis = size / 2;\n        this.mesh.buildBoundingInfo(new Vector3(-vis, -vis, -vis), new Vector3(vis, vis, vis));\n    }\n    /**\n     * Gets whether the PCS is always visible or not\n     * doc :\n     */\n    get isAlwaysVisible() {\n        return this._alwaysVisible;\n    }\n    /**\n     * Sets the PCS as always visible or not\n     * doc :\n     */\n    set isAlwaysVisible(val) {\n        if (!this.mesh) {\n            return;\n        }\n        this._alwaysVisible = val;\n        this.mesh.alwaysSelectAsActiveMesh = val;\n    }\n    /**\n     * Tells to `setParticles()` to compute the particle rotations or not\n     * Default value : false. The PCS is faster when it's set to false\n     * Note : particle rotations are only applied to parent particles\n     * Note : the particle rotations aren't stored values, so setting `computeParticleRotation` to false will prevents the particle to rotate\n     */\n    set computeParticleRotation(val) {\n        this._computeParticleRotation = val;\n    }\n    /**\n     * Tells to `setParticles()` to compute the particle colors or not.\n     * Default value : true. The PCS is faster when it's set to false.\n     * Note : the particle colors are stored values, so setting `computeParticleColor` to false will keep yet the last colors set.\n     */\n    set computeParticleColor(val) {\n        this._computeParticleColor = val;\n    }\n    set computeParticleTexture(val) {\n        this._computeParticleTexture = val;\n    }\n    /**\n     * Gets if `setParticles()` computes the particle colors or not.\n     * Default value : false. The PCS is faster when it's set to false.\n     * Note : the particle colors are stored values, so setting `computeParticleColor` to false will keep yet the last colors set.\n     */\n    get computeParticleColor() {\n        return this._computeParticleColor;\n    }\n    /**\n     * Gets if `setParticles()` computes the particle textures or not.\n     * Default value : false. The PCS is faster when it's set to false.\n     * Note : the particle textures are stored values, so setting `computeParticleTexture` to false will keep yet the last colors set.\n     */\n    get computeParticleTexture() {\n        return this._computeParticleTexture;\n    }\n    /**\n     * Tells to `setParticles()` to compute or not the mesh bounding box when computing the particle positions.\n     */\n    set computeBoundingBox(val) {\n        this._computeBoundingBox = val;\n    }\n    /**\n     * Gets if `setParticles()` computes or not the mesh bounding box when computing the particle positions.\n     */\n    get computeBoundingBox() {\n        return this._computeBoundingBox;\n    }\n    // =======================================================================\n    // Particle behavior logic\n    // these following methods may be overwritten by users to fit their needs\n    /**\n     * This function does nothing. It may be overwritten to set all the particle first values.\n     * The PCS doesn't call this function, you may have to call it by your own.\n     * doc :\n     */\n    initParticles() { }\n    /**\n     * This function does nothing. It may be overwritten to recycle a particle\n     * The PCS doesn't call this function, you can to call it\n     * doc :\n     * @param particle The particle to recycle\n     * @returns the recycled particle\n     */\n    recycleParticle(particle) {\n        return particle;\n    }\n    /**\n     * Updates a particle : this function should  be overwritten by the user.\n     * It is called on each particle by `setParticles()`. This is the place to code each particle behavior.\n     * doc :\n     * @example : just set a particle position or velocity and recycle conditions\n     * @param particle The particle to update\n     * @returns the updated particle\n     */\n    updateParticle(particle) {\n        return particle;\n    }\n    /**\n     * This will be called before any other treatment by `setParticles()` and will be passed three parameters.\n     * This does nothing and may be overwritten by the user.\n     * @param start the particle index in the particle array where to start to iterate, same than the value passed to setParticle()\n     * @param stop the particle index in the particle array where to stop to iterate, same than the value passed to setParticle()\n     * @param update the boolean update value actually passed to setParticles()\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    beforeUpdateParticles(start, stop, update) { }\n    /**\n     * This will be called  by `setParticles()` after all the other treatments and just before the actual mesh update.\n     * This will be passed three parameters.\n     * This does nothing and may be overwritten by the user.\n     * @param start the particle index in the particle array where to start to iterate, same than the value passed to setParticle()\n     * @param stop the particle index in the particle array where to stop to iterate, same than the value passed to setParticle()\n     * @param update the boolean update value actually passed to setParticles()\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    afterUpdateParticles(start, stop, update) { }\n}\n//# sourceMappingURL=pointsCloudSystem.js.map","import { Vector3 } from \"../Maths/math.vector.js\";\nimport { _WarnImport } from \"../Misc/devTools.js\";\nimport { GetClass } from \"../Misc/typeStore.js\";\n/**\n * Type of sub emitter\n */\nexport var SubEmitterType;\n(function (SubEmitterType) {\n    /**\n     * Attached to the particle over it's lifetime\n     */\n    SubEmitterType[SubEmitterType[\"ATTACHED\"] = 0] = \"ATTACHED\";\n    /**\n     * Created when the particle dies\n     */\n    SubEmitterType[SubEmitterType[\"END\"] = 1] = \"END\";\n})(SubEmitterType || (SubEmitterType = {}));\n/**\n * Sub emitter class used to emit particles from an existing particle\n */\nexport class SubEmitter {\n    /**\n     * Creates a sub emitter\n     * @param particleSystem the particle system to be used by the sub emitter\n     */\n    constructor(\n    /**\n     * the particle system to be used by the sub emitter\n     */\n    particleSystem) {\n        this.particleSystem = particleSystem;\n        /**\n         * Type of the submitter (Default: END)\n         */\n        this.type = SubEmitterType.END;\n        /**\n         * If the particle should inherit the direction from the particle it's attached to. (+Y will face the direction the particle is moving) (Default: false)\n         * Note: This only is supported when using an emitter of type Mesh\n         */\n        this.inheritDirection = false;\n        /**\n         * How much of the attached particles speed should be added to the sub emitted particle (default: 0)\n         */\n        this.inheritedVelocityAmount = 0;\n        // Create mesh as emitter to support rotation\n        if (!particleSystem.emitter || !particleSystem.emitter.dispose) {\n            const internalClass = GetClass(\"BABYLON.AbstractMesh\");\n            particleSystem.emitter = new internalClass(\"SubemitterSystemEmitter\", particleSystem.getScene());\n            particleSystem._disposeEmitterOnDispose = true;\n        }\n    }\n    /**\n     * Clones the sub emitter\n     * @returns the cloned sub emitter\n     */\n    clone() {\n        // Clone particle system\n        let emitter = this.particleSystem.emitter;\n        if (!emitter) {\n            emitter = new Vector3();\n        }\n        else if (emitter instanceof Vector3) {\n            emitter = emitter.clone();\n        }\n        else if (emitter.getClassName().indexOf(\"Mesh\") !== -1) {\n            const internalClass = GetClass(\"BABYLON.Mesh\");\n            emitter = new internalClass(\"\", emitter.getScene());\n            emitter.isVisible = false;\n        }\n        const clone = new SubEmitter(this.particleSystem.clone(this.particleSystem.name, emitter));\n        // Clone properties\n        clone.particleSystem.name += \"Clone\";\n        clone.type = this.type;\n        clone.inheritDirection = this.inheritDirection;\n        clone.inheritedVelocityAmount = this.inheritedVelocityAmount;\n        clone.particleSystem._disposeEmitterOnDispose = true;\n        clone.particleSystem.disposeOnStop = true;\n        return clone;\n    }\n    /**\n     * Serialize current object to a JSON object\n     * @param serializeTexture defines if the texture must be serialized as well\n     * @returns the serialized object\n     */\n    serialize(serializeTexture = false) {\n        const serializationObject = {};\n        serializationObject.type = this.type;\n        serializationObject.inheritDirection = this.inheritDirection;\n        serializationObject.inheritedVelocityAmount = this.inheritedVelocityAmount;\n        serializationObject.particleSystem = this.particleSystem.serialize(serializeTexture);\n        return serializationObject;\n    }\n    /**\n     * @internal\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    static _ParseParticleSystem(system, sceneOrEngine, rootUrl, doNotStart = false) {\n        throw _WarnImport(\"ParseParticle\");\n    }\n    /**\n     * Creates a new SubEmitter from a serialized JSON version\n     * @param serializationObject defines the JSON object to read from\n     * @param sceneOrEngine defines the hosting scene or the hosting engine\n     * @param rootUrl defines the rootUrl for data loading\n     * @returns a new SubEmitter\n     */\n    static Parse(serializationObject, sceneOrEngine, rootUrl) {\n        const system = serializationObject.particleSystem;\n        const subEmitter = new SubEmitter(SubEmitter._ParseParticleSystem(system, sceneOrEngine, rootUrl, true));\n        subEmitter.type = serializationObject.type;\n        subEmitter.inheritDirection = serializationObject.inheritDirection;\n        subEmitter.inheritedVelocityAmount = serializationObject.inheritedVelocityAmount;\n        subEmitter.particleSystem._isSubEmitter = true;\n        return subEmitter;\n    }\n    /** Release associated resources */\n    dispose() {\n        this.particleSystem.dispose();\n    }\n}\n//# sourceMappingURL=subEmitter.js.map","import { Logger } from \"../Misc/logger.js\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { SceneComponentConstants } from \"../sceneComponent.js\";\nimport { Scene } from \"../scene.js\";\nimport { PhysicsEngine as PhysicsEngineV1 } from \"./v1/physicsEngine.js\";\nimport { PhysicsEngine as PhysicsEngineV2 } from \"./v2/physicsEngine.js\";\n/**\n * Gets the current physics engine\n * @returns a IPhysicsEngine or null if none attached\n */\nScene.prototype.getPhysicsEngine = function () {\n    return this._physicsEngine;\n};\n/**\n * Enables physics to the current scene\n * @param gravity defines the scene's gravity for the physics engine\n * @param plugin defines the physics engine to be used. defaults to CannonJS.\n * @returns a boolean indicating if the physics engine was initialized\n */\nScene.prototype.enablePhysics = function (gravity = null, plugin) {\n    if (this._physicsEngine) {\n        return true;\n    }\n    // Register the component to the scene\n    let component = this._getComponent(SceneComponentConstants.NAME_PHYSICSENGINE);\n    if (!component) {\n        component = new PhysicsEngineSceneComponent(this);\n        this._addComponent(component);\n    }\n    try {\n        if (!plugin || (plugin === null || plugin === void 0 ? void 0 : plugin.getPluginVersion()) === 1) {\n            this._physicsEngine = new PhysicsEngineV1(gravity, plugin);\n        }\n        else if ((plugin === null || plugin === void 0 ? void 0 : plugin.getPluginVersion()) === 2) {\n            this._physicsEngine = new PhysicsEngineV2(gravity, plugin);\n        }\n        else {\n            throw new Error(\"Unsupported Physics plugin version.\");\n        }\n        this._physicsTimeAccumulator = 0;\n        return true;\n    }\n    catch (e) {\n        Logger.Error(e.message);\n        return false;\n    }\n};\n/**\n * Disables and disposes the physics engine associated with the scene\n */\nScene.prototype.disablePhysicsEngine = function () {\n    if (!this._physicsEngine) {\n        return;\n    }\n    this._physicsEngine.dispose();\n    this._physicsEngine = null;\n};\n/**\n * Gets a boolean indicating if there is an active physics engine\n * @returns a boolean indicating if there is an active physics engine\n */\nScene.prototype.isPhysicsEnabled = function () {\n    return this._physicsEngine !== undefined;\n};\n/**\n * Deletes a physics compound impostor\n * @param compound defines the compound to delete\n */\nScene.prototype.deleteCompoundImpostor = function (compound) {\n    const mesh = compound.parts[0].mesh;\n    if (mesh.physicsImpostor) {\n        mesh.physicsImpostor.dispose( /*true*/);\n        mesh.physicsImpostor = null;\n    }\n};\n/**\n * @internal\n */\nScene.prototype._advancePhysicsEngineStep = function (step) {\n    if (this._physicsEngine) {\n        const subTime = this._physicsEngine.getSubTimeStep();\n        if (subTime > 0) {\n            this._physicsTimeAccumulator += step;\n            while (this._physicsTimeAccumulator > subTime) {\n                this.onBeforePhysicsObservable.notifyObservers(this);\n                this._physicsEngine._step(subTime / 1000);\n                this.onAfterPhysicsObservable.notifyObservers(this);\n                this._physicsTimeAccumulator -= subTime;\n            }\n        }\n        else {\n            this.onBeforePhysicsObservable.notifyObservers(this);\n            this._physicsEngine._step(step / 1000);\n            this.onAfterPhysicsObservable.notifyObservers(this);\n        }\n    }\n};\n/**\n * Defines the physics engine scene component responsible to manage a physics engine\n */\nexport class PhysicsEngineSceneComponent {\n    /**\n     * Creates a new instance of the component for the given scene\n     * @param scene Defines the scene to register the component in\n     */\n    constructor(scene) {\n        /**\n         * The component name helpful to identify the component in the list of scene components.\n         */\n        this.name = SceneComponentConstants.NAME_PHYSICSENGINE;\n        this.scene = scene;\n        this.scene.onBeforePhysicsObservable = new Observable();\n        this.scene.onAfterPhysicsObservable = new Observable();\n        // Replace the function used to get the deterministic frame time\n        this.scene.getDeterministicFrameTime = () => {\n            if (this.scene._physicsEngine) {\n                return this.scene._physicsEngine.getTimeStep() * 1000;\n            }\n            return 1000.0 / 60.0;\n        };\n    }\n    /**\n     * Registers the component in a given scene\n     */\n    register() { }\n    /**\n     * Rebuilds the elements related to this component in case of\n     * context lost for instance.\n     */\n    rebuild() {\n        // Nothing to do for this component\n    }\n    /**\n     * Disposes the component and the associated resources\n     */\n    dispose() {\n        this.scene.onBeforePhysicsObservable.clear();\n        this.scene.onAfterPhysicsObservable.clear();\n        if (this.scene._physicsEngine) {\n            this.scene.disablePhysicsEngine();\n        }\n    }\n}\n//# sourceMappingURL=joinedPhysicsEngineComponent.js.map","import { Logger } from \"../Misc/logger.js\";\nimport { Vector3 } from \"../Maths/math.vector.js\";\nimport { CreateSphere } from \"../Meshes/Builders/sphereBuilder.js\";\nimport { CreateCylinder } from \"../Meshes/Builders/cylinderBuilder.js\";\nimport { Ray } from \"../Culling/ray.js\";\n/**\n * A helper for physics simulations\n * @see https://doc.babylonjs.com/features/featuresDeepDive/physics/usingPhysicsEngine#further-functionality-of-the-impostor-class\n */\nexport class PhysicsHelper {\n    /**\n     * Initializes the Physics helper\n     * @param scene Babylon.js scene\n     */\n    constructor(scene) {\n        this._hitData = { force: new Vector3(), contactPoint: new Vector3(), distanceFromOrigin: 0 };\n        this._scene = scene;\n        this._physicsEngine = this._scene.getPhysicsEngine();\n        if (!this._physicsEngine) {\n            Logger.Warn(\"Physics engine not enabled. Please enable the physics before you can use the methods.\");\n            return;\n        }\n    }\n    /**\n     * Applies a radial explosion impulse\n     * @param origin the origin of the explosion\n     * @param radiusOrEventOptions the radius or the options of radial explosion\n     * @param strength the explosion strength\n     * @param falloff possible options: Constant & Linear. Defaults to Constant\n     * @returns A physics radial explosion event, or null\n     */\n    applyRadialExplosionImpulse(origin, radiusOrEventOptions, strength, falloff) {\n        if (!this._physicsEngine) {\n            Logger.Warn(\"Physics engine not enabled. Please enable the physics before you call this method.\");\n            return null;\n        }\n        if (this._physicsEngine.getPluginVersion() === 1 && this._physicsEngine.getImpostors().length === 0) {\n            return null;\n        }\n        if (this._physicsEngine.getPluginVersion() === 2 && this._physicsEngine.getBodies().length === 0) {\n            return null;\n        }\n        let useCallback = false;\n        if (typeof radiusOrEventOptions === \"number\") {\n            const r = radiusOrEventOptions;\n            radiusOrEventOptions = new PhysicsRadialExplosionEventOptions();\n            radiusOrEventOptions.radius = r;\n            radiusOrEventOptions.strength = strength !== null && strength !== void 0 ? strength : radiusOrEventOptions.strength;\n            radiusOrEventOptions.falloff = falloff !== null && falloff !== void 0 ? falloff : radiusOrEventOptions.falloff;\n        }\n        else {\n            useCallback = !!(radiusOrEventOptions.affectedImpostorsCallback || radiusOrEventOptions.affectedBodiesCallback);\n        }\n        const event = new PhysicsRadialExplosionEvent(this._scene, radiusOrEventOptions);\n        const hitData = this._hitData;\n        if (this._physicsEngine.getPluginVersion() === 1) {\n            const affectedImpostorsWithData = Array();\n            const impostors = this._physicsEngine.getImpostors();\n            impostors.forEach((impostor) => {\n                if (!event.getImpostorHitData(impostor, origin, hitData)) {\n                    return;\n                }\n                impostor.applyImpulse(hitData.force, hitData.contactPoint);\n                if (useCallback) {\n                    affectedImpostorsWithData.push({\n                        impostor: impostor,\n                        hitData: this._copyPhysicsHitData(hitData),\n                    });\n                }\n            });\n            event.triggerAffectedImpostorsCallback(affectedImpostorsWithData);\n        }\n        else {\n            const affectedBodiesWithData = Array();\n            const bodies = this._physicsEngine.getBodies();\n            bodies.forEach((body) => {\n                if (!event.getBodyHitData(body, origin, hitData)) {\n                    return;\n                }\n                body.applyImpulse(hitData.force, hitData.contactPoint);\n                if (useCallback) {\n                    affectedBodiesWithData.push({\n                        body: body,\n                        hitData: this._copyPhysicsHitData(hitData),\n                    });\n                }\n            });\n            event.triggerAffectedBodiesCallback(affectedBodiesWithData);\n        }\n        event.dispose(false);\n        return event;\n    }\n    /**\n     * Applies a radial explosion force\n     * @param origin the origin of the explosion\n     * @param radiusOrEventOptions the radius or the options of radial explosion\n     * @param strength the explosion strength\n     * @param falloff possible options: Constant & Linear. Defaults to Constant\n     * @returns A physics radial explosion event, or null\n     */\n    applyRadialExplosionForce(origin, radiusOrEventOptions, strength, falloff) {\n        if (!this._physicsEngine) {\n            Logger.Warn(\"Physics engine not enabled. Please enable the physics before you call the PhysicsHelper.\");\n            return null;\n        }\n        if (this._physicsEngine.getPluginVersion() === 1 && this._physicsEngine.getImpostors().length === 0) {\n            return null;\n        }\n        if (this._physicsEngine.getPluginVersion() === 2 && this._physicsEngine.getBodies().length === 0) {\n            return null;\n        }\n        let useCallback = false;\n        if (typeof radiusOrEventOptions === \"number\") {\n            const r = radiusOrEventOptions;\n            radiusOrEventOptions = new PhysicsRadialExplosionEventOptions();\n            radiusOrEventOptions.radius = r;\n            radiusOrEventOptions.strength = strength !== null && strength !== void 0 ? strength : radiusOrEventOptions.strength;\n            radiusOrEventOptions.falloff = falloff !== null && falloff !== void 0 ? falloff : radiusOrEventOptions.falloff;\n        }\n        else {\n            useCallback = !!(radiusOrEventOptions.affectedImpostorsCallback || radiusOrEventOptions.affectedBodiesCallback);\n        }\n        const event = new PhysicsRadialExplosionEvent(this._scene, radiusOrEventOptions);\n        const hitData = this._hitData;\n        if (this._physicsEngine.getPluginVersion() === 1) {\n            const affectedImpostorsWithData = Array();\n            const impostors = this._physicsEngine.getImpostors();\n            impostors.forEach((impostor) => {\n                if (!event.getImpostorHitData(impostor, origin, hitData)) {\n                    return;\n                }\n                impostor.applyForce(hitData.force, hitData.contactPoint);\n                if (useCallback) {\n                    affectedImpostorsWithData.push({\n                        impostor: impostor,\n                        hitData: this._copyPhysicsHitData(hitData),\n                    });\n                }\n            });\n            event.triggerAffectedImpostorsCallback(affectedImpostorsWithData);\n        }\n        else {\n            const affectedBodiesWithData = Array();\n            const bodies = this._physicsEngine.getBodies();\n            bodies.forEach((body) => {\n                if (!event.getBodyHitData(body, origin, hitData)) {\n                    return;\n                }\n                body.applyForce(hitData.force, hitData.contactPoint);\n                if (useCallback) {\n                    affectedBodiesWithData.push({\n                        body: body,\n                        hitData: this._copyPhysicsHitData(hitData),\n                    });\n                }\n            });\n            event.triggerAffectedBodiesCallback(affectedBodiesWithData);\n        }\n        event.dispose(false);\n        return event;\n    }\n    /**\n     * Creates a gravitational field\n     * @param origin the origin of the gravitational field\n     * @param radiusOrEventOptions the radius or the options of radial gravitational field\n     * @param strength the gravitational field strength\n     * @param falloff possible options: Constant & Linear. Defaults to Constant\n     * @returns A physics gravitational field event, or null\n     */\n    gravitationalField(origin, radiusOrEventOptions, strength, falloff) {\n        if (!this._physicsEngine) {\n            Logger.Warn(\"Physics engine not enabled. Please enable the physics before you call the PhysicsHelper.\");\n            return null;\n        }\n        if (this._physicsEngine.getPluginVersion() === 1 && this._physicsEngine.getImpostors().length === 0) {\n            return null;\n        }\n        if (this._physicsEngine.getPluginVersion() === 2 && this._physicsEngine.getBodies().length === 0) {\n            return null;\n        }\n        if (typeof radiusOrEventOptions === \"number\") {\n            const r = radiusOrEventOptions;\n            radiusOrEventOptions = new PhysicsRadialExplosionEventOptions();\n            radiusOrEventOptions.radius = r;\n            radiusOrEventOptions.strength = strength !== null && strength !== void 0 ? strength : radiusOrEventOptions.strength;\n            radiusOrEventOptions.falloff = falloff !== null && falloff !== void 0 ? falloff : radiusOrEventOptions.falloff;\n        }\n        const event = new PhysicsGravitationalFieldEvent(this, this._scene, origin, radiusOrEventOptions);\n        event.dispose(false);\n        return event;\n    }\n    /**\n     * Creates a physics updraft event\n     * @param origin the origin of the updraft\n     * @param radiusOrEventOptions the radius or the options of the updraft\n     * @param strength the strength of the updraft\n     * @param height the height of the updraft\n     * @param updraftMode possible options: Center & Perpendicular. Defaults to Center\n     * @returns A physics updraft event, or null\n     */\n    updraft(origin, radiusOrEventOptions, strength, height, updraftMode) {\n        if (!this._physicsEngine) {\n            Logger.Warn(\"Physics engine not enabled. Please enable the physics before you call the PhysicsHelper.\");\n            return null;\n        }\n        if (this._physicsEngine.getPluginVersion() === 1 && this._physicsEngine.getImpostors().length === 0) {\n            return null;\n        }\n        if (this._physicsEngine.getPluginVersion() === 2 && this._physicsEngine.getBodies().length === 0) {\n            return null;\n        }\n        if (typeof radiusOrEventOptions === \"number\") {\n            const r = radiusOrEventOptions;\n            radiusOrEventOptions = new PhysicsUpdraftEventOptions();\n            radiusOrEventOptions.radius = r;\n            radiusOrEventOptions.strength = strength !== null && strength !== void 0 ? strength : radiusOrEventOptions.strength;\n            radiusOrEventOptions.height = height !== null && height !== void 0 ? height : radiusOrEventOptions.height;\n            radiusOrEventOptions.updraftMode = updraftMode !== null && updraftMode !== void 0 ? updraftMode : radiusOrEventOptions.updraftMode;\n        }\n        const event = new PhysicsUpdraftEvent(this._scene, origin, radiusOrEventOptions);\n        event.dispose(false);\n        return event;\n    }\n    /**\n     * Creates a physics vortex event\n     * @param origin the of the vortex\n     * @param radiusOrEventOptions the radius or the options of the vortex\n     * @param strength the strength of the vortex\n     * @param height   the height of the vortex\n     * @returns a Physics vortex event, or null\n     * A physics vortex event or null\n     */\n    vortex(origin, radiusOrEventOptions, strength, height) {\n        if (!this._physicsEngine) {\n            Logger.Warn(\"Physics engine not enabled. Please enable the physics before you call the PhysicsHelper.\");\n            return null;\n        }\n        if (this._physicsEngine.getPluginVersion() === 1 && this._physicsEngine.getImpostors().length === 0) {\n            return null;\n        }\n        if (this._physicsEngine.getPluginVersion() === 2 && this._physicsEngine.getBodies().length === 0) {\n            return null;\n        }\n        if (typeof radiusOrEventOptions === \"number\") {\n            const r = radiusOrEventOptions;\n            radiusOrEventOptions = new PhysicsVortexEventOptions();\n            radiusOrEventOptions.radius = r;\n            radiusOrEventOptions.strength = strength !== null && strength !== void 0 ? strength : radiusOrEventOptions.strength;\n            radiusOrEventOptions.height = height !== null && height !== void 0 ? height : radiusOrEventOptions.height;\n        }\n        const event = new PhysicsVortexEvent(this._scene, origin, radiusOrEventOptions);\n        event.dispose(false);\n        return event;\n    }\n    _copyPhysicsHitData(data) {\n        return { force: data.force.clone(), contactPoint: data.contactPoint.clone(), distanceFromOrigin: data.distanceFromOrigin };\n    }\n}\n/**\n * Represents a physics radial explosion event\n */\nclass PhysicsRadialExplosionEvent {\n    /**\n     * Initializes a radial explosion event\n     * @param _scene BabylonJS scene\n     * @param _options The options for the vortex event\n     */\n    constructor(_scene, _options) {\n        this._scene = _scene;\n        this._options = _options;\n        this._dataFetched = false; // check if the data has been fetched. If not, do cleanup\n        this._options = { ...new PhysicsRadialExplosionEventOptions(), ...this._options };\n    }\n    /**\n     * Returns the data related to the radial explosion event (sphere).\n     * @returns The radial explosion event data\n     */\n    getData() {\n        this._dataFetched = true;\n        return {\n            sphere: this._sphere,\n        };\n    }\n    _getHitData(mesh, center, origin, data) {\n        const direction = center.subtract(origin);\n        const ray = new Ray(origin, direction, this._options.radius);\n        const hit = ray.intersectsMesh(mesh);\n        const contactPoint = hit.pickedPoint;\n        if (!contactPoint) {\n            return false;\n        }\n        const distanceFromOrigin = Vector3.Distance(origin, contactPoint);\n        if (distanceFromOrigin > this._options.radius) {\n            return false;\n        }\n        const multiplier = this._options.falloff === PhysicsRadialImpulseFalloff.Constant ? this._options.strength : this._options.strength * (1 - distanceFromOrigin / this._options.radius);\n        const force = direction.multiplyByFloats(multiplier, multiplier, multiplier);\n        data.force = force;\n        data.contactPoint = contactPoint;\n        data.distanceFromOrigin = distanceFromOrigin;\n        return true;\n    }\n    /**\n     * Returns the force and contact point of the body or false, if the body is not affected by the force/impulse.\n     * @param body A physics body\n     * @param origin the origin of the explosion\n     * @returns A physics force and contact point, or null\n     */\n    getBodyHitData(body, origin, data) {\n        if (body.transformNode.getClassName() !== \"Mesh\" && body.transformNode.getClassName() !== \"InstancedMesh\") {\n            return false;\n        }\n        const mesh = body.transformNode;\n        if (!this._intersectsWithSphere(mesh, origin, this._options.radius)) {\n            return false;\n        }\n        const bodyObjectCenter = body.getObjectCenter();\n        this._getHitData(mesh, bodyObjectCenter, origin, data);\n        return true;\n    }\n    /**\n     * Returns the force and contact point of the impostor or false, if the impostor is not affected by the force/impulse.\n     * @param impostor A physics imposter\n     * @param origin the origin of the explosion\n     * @returns A physics force and contact point, or null\n     */\n    getImpostorHitData(impostor, origin, data) {\n        if (impostor.mass === 0) {\n            return false;\n        }\n        if (impostor.object.getClassName() !== \"Mesh\" && impostor.object.getClassName() !== \"InstancedMesh\") {\n            return false;\n        }\n        const mesh = impostor.object;\n        if (!this._intersectsWithSphere(mesh, origin, this._options.radius)) {\n            return false;\n        }\n        const impostorObjectCenter = impostor.getObjectCenter();\n        this._getHitData(mesh, impostorObjectCenter, origin, data);\n        return true;\n    }\n    /**\n     * Triggers affected impostors callbacks\n     * @param affectedImpostorsWithData defines the list of affected impostors (including associated data)\n     */\n    triggerAffectedImpostorsCallback(affectedImpostorsWithData) {\n        if (this._options.affectedImpostorsCallback) {\n            this._options.affectedImpostorsCallback(affectedImpostorsWithData);\n        }\n    }\n    /**\n     * Triggers affected bodies callbacks\n     * @param affectedBodiesWithData defines the list of affected bodies (including associated data)\n     */\n    triggerAffectedBodiesCallback(affectedBodiesWithData) {\n        if (this._options.affectedBodiesCallback) {\n            this._options.affectedBodiesCallback(affectedBodiesWithData);\n        }\n    }\n    /**\n     * Disposes the sphere.\n     * @param force Specifies if the sphere should be disposed by force\n     */\n    dispose(force = true) {\n        if (force) {\n            this._sphere.dispose();\n        }\n        else {\n            setTimeout(() => {\n                if (!this._dataFetched) {\n                    this._sphere.dispose();\n                }\n            }, 0);\n        }\n    }\n    /*** Helpers ***/\n    _prepareSphere() {\n        if (!this._sphere) {\n            this._sphere = CreateSphere(\"radialExplosionEventSphere\", this._options.sphere, this._scene);\n            this._sphere.isVisible = false;\n        }\n    }\n    _intersectsWithSphere(mesh, origin, radius) {\n        this._prepareSphere();\n        this._sphere.position = origin;\n        this._sphere.scaling.setAll(radius * 2);\n        this._sphere._updateBoundingInfo();\n        this._sphere.computeWorldMatrix(true);\n        return this._sphere.intersectsMesh(mesh, true);\n    }\n}\n/**\n * Represents a gravitational field event\n */\nclass PhysicsGravitationalFieldEvent {\n    /**\n     * Initializes the physics gravitational field event\n     * @param _physicsHelper A physics helper\n     * @param _scene BabylonJS scene\n     * @param _origin The origin position of the gravitational field event\n     * @param _options The options for the vortex event\n     */\n    constructor(_physicsHelper, _scene, _origin, _options) {\n        this._physicsHelper = _physicsHelper;\n        this._scene = _scene;\n        this._origin = _origin;\n        this._options = _options;\n        this._dataFetched = false; // check if the has been fetched the data. If not, do cleanup\n        this._options = { ...new PhysicsRadialExplosionEventOptions(), ...this._options };\n        this._tickCallback = this._tick.bind(this);\n        this._options.strength = this._options.strength * -1;\n    }\n    /**\n     * Returns the data related to the gravitational field event (sphere).\n     * @returns A gravitational field event\n     */\n    getData() {\n        this._dataFetched = true;\n        return {\n            sphere: this._sphere,\n        };\n    }\n    /**\n     * Enables the gravitational field.\n     */\n    enable() {\n        this._tickCallback.call(this);\n        this._scene.registerBeforeRender(this._tickCallback);\n    }\n    /**\n     * Disables the gravitational field.\n     */\n    disable() {\n        this._scene.unregisterBeforeRender(this._tickCallback);\n    }\n    /**\n     * Disposes the sphere.\n     * @param force The force to dispose from the gravitational field event\n     */\n    dispose(force = true) {\n        if (force) {\n            this._sphere.dispose();\n        }\n        else {\n            setTimeout(() => {\n                if (!this._dataFetched) {\n                    this._sphere.dispose();\n                }\n            }, 0);\n        }\n    }\n    _tick() {\n        // Since the params won't change, we fetch the event only once\n        if (this._sphere) {\n            this._physicsHelper.applyRadialExplosionForce(this._origin, this._options);\n        }\n        else {\n            const radialExplosionEvent = this._physicsHelper.applyRadialExplosionForce(this._origin, this._options);\n            if (radialExplosionEvent) {\n                this._sphere = radialExplosionEvent.getData().sphere.clone(\"radialExplosionEventSphereClone\");\n            }\n        }\n    }\n}\n/**\n * Represents a physics updraft event\n */\nclass PhysicsUpdraftEvent {\n    /**\n     * Initializes the physics updraft event\n     * @param _scene BabylonJS scene\n     * @param _origin The origin position of the updraft\n     * @param _options The options for the updraft event\n     */\n    constructor(_scene, _origin, _options) {\n        this._scene = _scene;\n        this._origin = _origin;\n        this._options = _options;\n        this._originTop = Vector3.Zero(); // the most upper part of the cylinder\n        this._originDirection = Vector3.Zero(); // used if the updraftMode is perpendicular\n        this._cylinderPosition = Vector3.Zero(); // to keep the cylinders position, because normally the origin is in the center and not on the bottom\n        this._dataFetched = false; // check if the has been fetched the data. If not, do cleanup\n        this._physicsEngine = this._scene.getPhysicsEngine();\n        this._options = { ...new PhysicsUpdraftEventOptions(), ...this._options };\n        this._origin.addToRef(new Vector3(0, this._options.height / 2, 0), this._cylinderPosition);\n        this._origin.addToRef(new Vector3(0, this._options.height, 0), this._originTop);\n        if (this._options.updraftMode === PhysicsUpdraftMode.Perpendicular) {\n            this._originDirection = this._origin.subtract(this._originTop).normalize();\n        }\n        this._tickCallback = this._tick.bind(this);\n        this._prepareCylinder();\n    }\n    /**\n     * Returns the data related to the updraft event (cylinder).\n     * @returns A physics updraft event\n     */\n    getData() {\n        this._dataFetched = true;\n        return {\n            cylinder: this._cylinder,\n        };\n    }\n    /**\n     * Enables the updraft.\n     */\n    enable() {\n        this._tickCallback.call(this);\n        this._scene.registerBeforeRender(this._tickCallback);\n    }\n    /**\n     * Disables the updraft.\n     */\n    disable() {\n        this._scene.unregisterBeforeRender(this._tickCallback);\n    }\n    /**\n     * Disposes the cylinder.\n     * @param force Specifies if the updraft should be disposed by force\n     */\n    dispose(force = true) {\n        if (!this._cylinder) {\n            return;\n        }\n        if (force) {\n            this._cylinder.dispose();\n        }\n        else {\n            setTimeout(() => {\n                if (!this._dataFetched) {\n                    this._cylinder.dispose();\n                }\n            }, 0);\n        }\n    }\n    _getHitData(center, data) {\n        let direction;\n        if (this._options.updraftMode === PhysicsUpdraftMode.Perpendicular) {\n            direction = this._originDirection;\n        }\n        else {\n            direction = center.subtract(this._originTop);\n        }\n        const distanceFromOrigin = Vector3.Distance(this._origin, center);\n        const multiplier = this._options.strength * -1;\n        const force = direction.multiplyByFloats(multiplier, multiplier, multiplier);\n        data.force = force;\n        data.contactPoint = center;\n        data.distanceFromOrigin = distanceFromOrigin;\n    }\n    _getBodyHitData(body, data) {\n        if (body.transformNode.getClassName() !== \"Mesh\" && body.transformNode.getClassName() !== \"InstancedMesh\") {\n            return false;\n        }\n        const bodyObject = body.transformNode;\n        if (!this._intersectsWithCylinder(bodyObject)) {\n            return false;\n        }\n        const center = body.getObjectCenter();\n        this._getHitData(center, data);\n        return true;\n    }\n    _getImpostorHitData(impostor, data) {\n        if (impostor.mass === 0) {\n            return false;\n        }\n        const impostorObject = impostor.object;\n        if (!this._intersectsWithCylinder(impostorObject)) {\n            return false;\n        }\n        const center = impostor.getObjectCenter();\n        this._getHitData(center, data);\n        return true;\n    }\n    _tick() {\n        const hitData = PhysicsUpdraftEvent.hitData;\n        if (this._physicsEngine.getPluginVersion() === 1) {\n            this._physicsEngine.getImpostors().forEach((impostor) => {\n                if (!this._getImpostorHitData(impostor, hitData)) {\n                    return;\n                }\n                impostor.applyForce(hitData.force, hitData.contactPoint);\n            });\n        }\n        else {\n            // V2\n            this._physicsEngine.getBodies().forEach((body) => {\n                if (!this._getBodyHitData(body, hitData)) {\n                    return;\n                }\n                body.applyForce(hitData.force, hitData.contactPoint);\n            });\n        }\n    }\n    /*** Helpers ***/\n    _prepareCylinder() {\n        if (!this._cylinder) {\n            this._cylinder = CreateCylinder(\"updraftEventCylinder\", {\n                height: this._options.height,\n                diameter: this._options.radius * 2,\n            }, this._scene);\n            this._cylinder.isVisible = false;\n        }\n    }\n    _intersectsWithCylinder(mesh) {\n        this._cylinder.position = this._cylinderPosition;\n        return this._cylinder.intersectsMesh(mesh, true);\n    }\n}\nPhysicsUpdraftEvent.hitData = { force: new Vector3(), contactPoint: new Vector3(), distanceFromOrigin: 0 };\n/**\n * Represents a physics vortex event\n */\nclass PhysicsVortexEvent {\n    /**\n     * Initializes the physics vortex event\n     * @param _scene The BabylonJS scene\n     * @param _origin The origin position of the vortex\n     * @param _options The options for the vortex event\n     */\n    constructor(_scene, _origin, _options) {\n        this._scene = _scene;\n        this._origin = _origin;\n        this._options = _options;\n        this._originTop = Vector3.Zero(); // the most upper part of the cylinder\n        this._cylinderPosition = Vector3.Zero(); // to keep the cylinders position, because normally the origin is in the center and not on the bottom\n        this._dataFetched = false; // check if the has been fetched the data. If not, do cleanup\n        this._physicsEngine = this._scene.getPhysicsEngine();\n        this._options = { ...new PhysicsVortexEventOptions(), ...this._options };\n        this._origin.addToRef(new Vector3(0, this._options.height / 2, 0), this._cylinderPosition);\n        this._origin.addToRef(new Vector3(0, this._options.height, 0), this._originTop);\n        this._tickCallback = this._tick.bind(this);\n        this._prepareCylinder();\n    }\n    /**\n     * Returns the data related to the vortex event (cylinder).\n     * @returns The physics vortex event data\n     */\n    getData() {\n        this._dataFetched = true;\n        return {\n            cylinder: this._cylinder,\n        };\n    }\n    /**\n     * Enables the vortex.\n     */\n    enable() {\n        this._tickCallback.call(this);\n        this._scene.registerBeforeRender(this._tickCallback);\n    }\n    /**\n     * Disables the cortex.\n     */\n    disable() {\n        this._scene.unregisterBeforeRender(this._tickCallback);\n    }\n    /**\n     * Disposes the sphere.\n     * @param force\n     */\n    dispose(force = true) {\n        if (force) {\n            this._cylinder.dispose();\n        }\n        else {\n            setTimeout(() => {\n                if (!this._dataFetched) {\n                    this._cylinder.dispose();\n                }\n            }, 0);\n        }\n    }\n    _getHitData(mesh, center, data) {\n        const originOnPlane = PhysicsVortexEvent.originOnPlane;\n        originOnPlane.set(this._origin.x, center.y, this._origin.z); // the distance to the origin as if both objects were on a plane (Y-axis)\n        const originToImpostorDirection = center.subtract(originOnPlane);\n        const ray = new Ray(originOnPlane, originToImpostorDirection, this._options.radius);\n        const hit = ray.intersectsMesh(mesh);\n        const contactPoint = hit.pickedPoint;\n        if (!contactPoint) {\n            return false;\n        }\n        const absoluteDistanceFromOrigin = hit.distance / this._options.radius;\n        let directionToOrigin = contactPoint.normalize();\n        if (absoluteDistanceFromOrigin > this._options.centripetalForceThreshold) {\n            directionToOrigin = directionToOrigin.negate();\n        }\n        let forceX;\n        let forceY;\n        let forceZ;\n        if (absoluteDistanceFromOrigin > this._options.centripetalForceThreshold) {\n            forceX = directionToOrigin.x * this._options.centripetalForceMultiplier;\n            forceY = directionToOrigin.y * this._options.updraftForceMultiplier;\n            forceZ = directionToOrigin.z * this._options.centripetalForceMultiplier;\n        }\n        else {\n            const perpendicularDirection = Vector3.Cross(originOnPlane, center).normalize();\n            forceX = (perpendicularDirection.x + directionToOrigin.x) * this._options.centrifugalForceMultiplier;\n            forceY = this._originTop.y * this._options.updraftForceMultiplier;\n            forceZ = (perpendicularDirection.z + directionToOrigin.z) * this._options.centrifugalForceMultiplier;\n        }\n        let force = new Vector3(forceX, forceY, forceZ);\n        force = force.multiplyByFloats(this._options.strength, this._options.strength, this._options.strength);\n        data.force = force;\n        data.contactPoint = center;\n        data.distanceFromOrigin = absoluteDistanceFromOrigin;\n        return true;\n    }\n    _getBodyHitData(body, data) {\n        if (body.transformNode.getClassName() !== \"Mesh\" && body.transformNode.getClassName() !== \"InstancedMesh\") {\n            return false;\n        }\n        const bodyObject = body.transformNode;\n        if (!this._intersectsWithCylinder(bodyObject)) {\n            return false;\n        }\n        const bodyCenter = body.getObjectCenter();\n        this._getHitData(bodyObject, bodyCenter, data);\n        return true;\n    }\n    _getImpostorHitData(impostor, data) {\n        if (impostor.mass === 0) {\n            return false;\n        }\n        if (impostor.object.getClassName() !== \"Mesh\" && impostor.object.getClassName() !== \"InstancedMesh\") {\n            return false;\n        }\n        const impostorObject = impostor.object;\n        if (!this._intersectsWithCylinder(impostorObject)) {\n            return false;\n        }\n        const impostorObjectCenter = impostor.getObjectCenter();\n        this._getHitData(impostorObject, impostorObjectCenter, data);\n        return true;\n    }\n    _tick() {\n        const hitData = PhysicsVortexEvent.hitData;\n        if (this._physicsEngine.getPluginVersion() === 1) {\n            this._physicsEngine.getImpostors().forEach((impostor) => {\n                if (!this._getImpostorHitData(impostor, hitData)) {\n                    return;\n                }\n                impostor.applyForce(hitData.force, hitData.contactPoint);\n            });\n        }\n        else {\n            this._physicsEngine.getBodies().forEach((body) => {\n                if (!this._getBodyHitData(body, hitData)) {\n                    return;\n                }\n                body.applyForce(hitData.force, hitData.contactPoint);\n            });\n        }\n    }\n    /*** Helpers ***/\n    _prepareCylinder() {\n        if (!this._cylinder) {\n            this._cylinder = CreateCylinder(\"vortexEventCylinder\", {\n                height: this._options.height,\n                diameter: this._options.radius * 2,\n            }, this._scene);\n            this._cylinder.isVisible = false;\n        }\n    }\n    _intersectsWithCylinder(mesh) {\n        this._cylinder.position = this._cylinderPosition;\n        return this._cylinder.intersectsMesh(mesh, true);\n    }\n}\nPhysicsVortexEvent.originOnPlane = Vector3.Zero();\nPhysicsVortexEvent.hitData = { force: new Vector3(), contactPoint: new Vector3(), distanceFromOrigin: 0 };\n/**\n * Options fot the radial explosion event\n * @see https://doc.babylonjs.com/features/featuresDeepDive/physics/usingPhysicsEngine#further-functionality-of-the-impostor-class\n */\nexport class PhysicsRadialExplosionEventOptions {\n    constructor() {\n        /**\n         * The radius of the sphere for the radial explosion.\n         */\n        this.radius = 5;\n        /**\n         * The strength of the explosion.\n         */\n        this.strength = 10;\n        /**\n         * The strength of the force in correspondence to the distance of the affected object\n         */\n        this.falloff = PhysicsRadialImpulseFalloff.Constant;\n        /**\n         * Sphere options for the radial explosion.\n         */\n        this.sphere = { segments: 32, diameter: 1 };\n    }\n}\n/**\n * Options fot the updraft event\n * @see https://doc.babylonjs.com/features/featuresDeepDive/physics/usingPhysicsEngine#further-functionality-of-the-impostor-class\n */\nexport class PhysicsUpdraftEventOptions {\n    constructor() {\n        /**\n         * The radius of the cylinder for the vortex\n         */\n        this.radius = 5;\n        /**\n         * The strength of the updraft.\n         */\n        this.strength = 10;\n        /**\n         * The height of the cylinder for the updraft.\n         */\n        this.height = 10;\n        /**\n         * The mode for the the updraft.\n         */\n        this.updraftMode = PhysicsUpdraftMode.Center;\n    }\n}\n/**\n * Options fot the vortex event\n * @see https://doc.babylonjs.com/features/featuresDeepDive/physics/usingPhysicsEngine#further-functionality-of-the-impostor-class\n */\nexport class PhysicsVortexEventOptions {\n    constructor() {\n        /**\n         * The radius of the cylinder for the vortex\n         */\n        this.radius = 5;\n        /**\n         * The strength of the vortex.\n         */\n        this.strength = 10;\n        /**\n         * The height of the cylinder for the vortex.\n         */\n        this.height = 10;\n        /**\n         * At which distance, relative to the radius the centripetal forces should kick in? Range: 0-1\n         */\n        this.centripetalForceThreshold = 0.7;\n        /**\n         * This multiplier determines with how much force the objects will be pushed sideways/around the vortex, when below the threshold.\n         */\n        this.centripetalForceMultiplier = 5;\n        /**\n         * This multiplier determines with how much force the objects will be pushed sideways/around the vortex, when above the threshold.\n         */\n        this.centrifugalForceMultiplier = 0.5;\n        /**\n         * This multiplier determines with how much force the objects will be pushed upwards, when in the vortex.\n         */\n        this.updraftForceMultiplier = 0.02;\n    }\n}\n/**\n * The strength of the force in correspondence to the distance of the affected object\n * @see https://doc.babylonjs.com/features/featuresDeepDive/physics/usingPhysicsEngine#further-functionality-of-the-impostor-class\n */\nexport var PhysicsRadialImpulseFalloff;\n(function (PhysicsRadialImpulseFalloff) {\n    /** Defines that impulse is constant in strength across it's whole radius */\n    PhysicsRadialImpulseFalloff[PhysicsRadialImpulseFalloff[\"Constant\"] = 0] = \"Constant\";\n    /** Defines that impulse gets weaker if it's further from the origin */\n    PhysicsRadialImpulseFalloff[PhysicsRadialImpulseFalloff[\"Linear\"] = 1] = \"Linear\";\n})(PhysicsRadialImpulseFalloff || (PhysicsRadialImpulseFalloff = {}));\n/**\n * The strength of the force in correspondence to the distance of the affected object\n * @see https://doc.babylonjs.com/features/featuresDeepDive/physics/usingPhysicsEngine#further-functionality-of-the-impostor-class\n */\nexport var PhysicsUpdraftMode;\n(function (PhysicsUpdraftMode) {\n    /** Defines that the upstream forces will pull towards the top center of the cylinder */\n    PhysicsUpdraftMode[PhysicsUpdraftMode[\"Center\"] = 0] = \"Center\";\n    /** Defines that once a impostor is inside the cylinder, it will shoot out perpendicular from the ground of the cylinder */\n    PhysicsUpdraftMode[PhysicsUpdraftMode[\"Perpendicular\"] = 1] = \"Perpendicular\";\n})(PhysicsUpdraftMode || (PhysicsUpdraftMode = {}));\n//# sourceMappingURL=physicsHelper.js.map","import { Vector3 } from \"../Maths/math.vector.js\";\n/**\n * Holds the data for the raycast result\n * @see https://doc.babylonjs.com/features/featuresDeepDive/physics/usingPhysicsEngine\n */\nexport class PhysicsRaycastResult {\n    constructor() {\n        this._hasHit = false;\n        this._hitDistance = 0;\n        this._hitNormalWorld = Vector3.Zero();\n        this._hitPointWorld = Vector3.Zero();\n        this._rayFromWorld = Vector3.Zero();\n        this._rayToWorld = Vector3.Zero();\n    }\n    /**\n     * Gets if there was a hit\n     */\n    get hasHit() {\n        return this._hasHit;\n    }\n    /**\n     * Gets the distance from the hit\n     */\n    get hitDistance() {\n        return this._hitDistance;\n    }\n    /**\n     * Gets the hit normal/direction in the world\n     */\n    get hitNormalWorld() {\n        return this._hitNormalWorld;\n    }\n    /**\n     * Gets the hit point in the world\n     */\n    get hitPointWorld() {\n        return this._hitPointWorld;\n    }\n    /**\n     * Gets the ray \"start point\" of the ray in the world\n     */\n    get rayFromWorld() {\n        return this._rayFromWorld;\n    }\n    /**\n     * Gets the ray \"end point\" of the ray in the world\n     */\n    get rayToWorld() {\n        return this._rayToWorld;\n    }\n    /**\n     * Sets the hit data (normal & point in world space)\n     * @param hitNormalWorld defines the normal in world space\n     * @param hitPointWorld defines the point in world space\n     */\n    setHitData(hitNormalWorld, hitPointWorld) {\n        this._hasHit = true;\n        this._hitNormalWorld = new Vector3(hitNormalWorld.x, hitNormalWorld.y, hitNormalWorld.z);\n        this._hitPointWorld = new Vector3(hitPointWorld.x, hitPointWorld.y, hitPointWorld.z);\n    }\n    /**\n     * Sets the distance from the start point to the hit point\n     * @param distance\n     */\n    setHitDistance(distance) {\n        this._hitDistance = distance;\n    }\n    /**\n     * Calculates the distance manually\n     */\n    calculateHitDistance() {\n        this._hitDistance = Vector3.Distance(this._rayFromWorld, this._hitPointWorld);\n    }\n    /**\n     * Resets all the values to default\n     * @param from The from point on world space\n     * @param to The to point on world space\n     */\n    reset(from = Vector3.Zero(), to = Vector3.Zero()) {\n        this._rayFromWorld = from;\n        this._rayToWorld = to;\n        this._hasHit = false;\n        this._hitDistance = 0;\n        this._hitNormalWorld = Vector3.Zero();\n        this._hitPointWorld = Vector3.Zero();\n    }\n}\n//# sourceMappingURL=physicsRaycastResult.js.map","import { Quaternion, Vector3, Matrix } from \"../../../Maths/math.vector.js\";\nimport { Logger } from \"../../../Misc/logger.js\";\nimport { PhysicsImpostor } from \"../physicsImpostor.js\";\nimport { PhysicsJoint } from \"../physicsJoint.js\";\nimport { VertexBuffer } from \"../../../Buffers/buffer.js\";\nimport { VertexData } from \"../../../Meshes/mesh.vertexData.js\";\nimport { ExtrudeShape } from \"../../../Meshes/Builders/shapeBuilder.js\";\nimport { CreateLines } from \"../../../Meshes/Builders/linesBuilder.js\";\nimport { PhysicsRaycastResult } from \"../../physicsRaycastResult.js\";\nimport { Scalar } from \"../../../Maths/math.scalar.js\";\nimport { Epsilon } from \"../../../Maths/math.constants.js\";\n/**\n * AmmoJS Physics plugin\n * @see https://doc.babylonjs.com/features/featuresDeepDive/physics/usingPhysicsEngine\n * @see https://github.com/kripken/ammo.js/\n */\nexport class AmmoJSPlugin {\n    /**\n     * Initializes the ammoJS plugin\n     * @param _useDeltaForWorldStep if the time between frames should be used when calculating physics steps (Default: true)\n     * @param ammoInjection can be used to inject your own ammo reference\n     * @param overlappingPairCache can be used to specify your own overlapping pair cache\n     */\n    constructor(_useDeltaForWorldStep = true, ammoInjection = Ammo, overlappingPairCache = null) {\n        this._useDeltaForWorldStep = _useDeltaForWorldStep;\n        /**\n         * Reference to the Ammo library\n         */\n        this.bjsAMMO = {};\n        /**\n         * Name of the plugin\n         */\n        this.name = \"AmmoJSPlugin\";\n        this._timeStep = 1 / 60;\n        this._fixedTimeStep = 1 / 60;\n        this._maxSteps = 5;\n        this._tmpQuaternion = new Quaternion();\n        this._tmpContactCallbackResult = false;\n        this._tmpContactPoint = new Vector3();\n        this._tmpContactNormal = new Vector3();\n        this._tmpVec3 = new Vector3();\n        this._tmpMatrix = new Matrix();\n        if (typeof ammoInjection === \"function\") {\n            Logger.Error(\"AmmoJS is not ready. Please make sure you await Ammo() before using the plugin.\");\n            return;\n        }\n        else {\n            this.bjsAMMO = ammoInjection;\n        }\n        if (!this.isSupported()) {\n            Logger.Error(\"AmmoJS is not available. Please make sure you included the js file.\");\n            return;\n        }\n        // Initialize the physics world\n        this._collisionConfiguration = new this.bjsAMMO.btSoftBodyRigidBodyCollisionConfiguration();\n        this._dispatcher = new this.bjsAMMO.btCollisionDispatcher(this._collisionConfiguration);\n        this._overlappingPairCache = overlappingPairCache || new this.bjsAMMO.btDbvtBroadphase();\n        this._solver = new this.bjsAMMO.btSequentialImpulseConstraintSolver();\n        this._softBodySolver = new this.bjsAMMO.btDefaultSoftBodySolver();\n        this.world = new this.bjsAMMO.btSoftRigidDynamicsWorld(this._dispatcher, this._overlappingPairCache, this._solver, this._collisionConfiguration, this._softBodySolver);\n        this._tmpAmmoConcreteContactResultCallback = new this.bjsAMMO.ConcreteContactResultCallback();\n        this._tmpAmmoConcreteContactResultCallback.addSingleResult = (contactPoint) => {\n            contactPoint = this.bjsAMMO.wrapPointer(contactPoint, this.bjsAMMO.btManifoldPoint);\n            const worldPoint = contactPoint.getPositionWorldOnA();\n            const worldNormal = contactPoint.m_normalWorldOnB;\n            this._tmpContactPoint.x = worldPoint.x();\n            this._tmpContactPoint.y = worldPoint.y();\n            this._tmpContactPoint.z = worldPoint.z();\n            this._tmpContactNormal.x = worldNormal.x();\n            this._tmpContactNormal.y = worldNormal.y();\n            this._tmpContactNormal.z = worldNormal.z();\n            this._tmpContactImpulse = contactPoint.getAppliedImpulse();\n            this._tmpContactDistance = contactPoint.getDistance();\n            this._tmpContactCallbackResult = true;\n        };\n        this._raycastResult = new PhysicsRaycastResult();\n        // Create temp ammo variables\n        this._tmpAmmoTransform = new this.bjsAMMO.btTransform();\n        this._tmpAmmoTransform.setIdentity();\n        this._tmpAmmoQuaternion = new this.bjsAMMO.btQuaternion(0, 0, 0, 1);\n        this._tmpAmmoVectorA = new this.bjsAMMO.btVector3(0, 0, 0);\n        this._tmpAmmoVectorB = new this.bjsAMMO.btVector3(0, 0, 0);\n        this._tmpAmmoVectorC = new this.bjsAMMO.btVector3(0, 0, 0);\n        this._tmpAmmoVectorD = new this.bjsAMMO.btVector3(0, 0, 0);\n    }\n    /**\n     *\n     * @returns plugin version\n     */\n    getPluginVersion() {\n        return 1;\n    }\n    /**\n     * Sets the gravity of the physics world (m/(s^2))\n     * @param gravity Gravity to set\n     */\n    setGravity(gravity) {\n        this._tmpAmmoVectorA.setValue(gravity.x, gravity.y, gravity.z);\n        this.world.setGravity(this._tmpAmmoVectorA);\n        this.world.getWorldInfo().set_m_gravity(this._tmpAmmoVectorA);\n    }\n    /**\n     * Amount of time to step forward on each frame (only used if useDeltaForWorldStep is false in the constructor)\n     * @param timeStep timestep to use in seconds\n     */\n    setTimeStep(timeStep) {\n        this._timeStep = timeStep;\n    }\n    /**\n     * Increment to step forward in the physics engine (If timeStep is set to 1/60 and fixedTimeStep is set to 1/120 the physics engine should run 2 steps per frame) (Default: 1/60)\n     * @param fixedTimeStep fixedTimeStep to use in seconds\n     */\n    setFixedTimeStep(fixedTimeStep) {\n        this._fixedTimeStep = fixedTimeStep;\n    }\n    /**\n     * Sets the maximum number of steps by the physics engine per frame (Default: 5)\n     * @param maxSteps the maximum number of steps by the physics engine per frame\n     */\n    setMaxSteps(maxSteps) {\n        this._maxSteps = maxSteps;\n    }\n    /**\n     * Gets the current timestep (only used if useDeltaForWorldStep is false in the constructor)\n     * @returns the current timestep in seconds\n     */\n    getTimeStep() {\n        return this._timeStep;\n    }\n    // Ammo's contactTest and contactPairTest take a callback that runs synchronously, wrap them so that they are easier to consume\n    _isImpostorInContact(impostor) {\n        this._tmpContactCallbackResult = false;\n        this.world.contactTest(impostor.physicsBody, this._tmpAmmoConcreteContactResultCallback);\n        return this._tmpContactCallbackResult;\n    }\n    // Ammo's collision events have some weird quirks\n    // contactPairTest fires too many events as it fires events even when objects are close together but contactTest does not\n    // so only fire event if both contactTest and contactPairTest have a hit\n    _isImpostorPairInContact(impostorA, impostorB) {\n        this._tmpContactCallbackResult = false;\n        this.world.contactPairTest(impostorA.physicsBody, impostorB.physicsBody, this._tmpAmmoConcreteContactResultCallback);\n        return this._tmpContactCallbackResult;\n    }\n    // Ammo's behavior when maxSteps > 0 does not behave as described in docs\n    // @see http://www.bulletphysics.org/mediawiki-1.5.8/index.php/Stepping_The_World\n    //\n    // When maxSteps is 0 do the entire simulation in one step\n    // When maxSteps is > 0, run up to maxStep times, if on the last step the (remaining step - fixedTimeStep) is < fixedTimeStep, the remainder will be used for the step. (eg. if remainder is 1.001 and fixedTimeStep is 1 the last step will be 1.001, if instead it did 2 steps (1, 0.001) issues occuered when having a tiny step in ammo)\n    // Note: To get deterministic physics, timeStep would always need to be divisible by fixedTimeStep\n    _stepSimulation(timeStep = 1 / 60, maxSteps = 10, fixedTimeStep = 1 / 60) {\n        if (maxSteps == 0) {\n            this.world.stepSimulation(timeStep, 0);\n        }\n        else {\n            while (maxSteps > 0 && timeStep > 0) {\n                if (timeStep - fixedTimeStep < fixedTimeStep) {\n                    this.world.stepSimulation(timeStep, 0);\n                    timeStep = 0;\n                }\n                else {\n                    timeStep -= fixedTimeStep;\n                    this.world.stepSimulation(fixedTimeStep, 0);\n                }\n                maxSteps--;\n            }\n        }\n    }\n    /**\n     * Moves the physics simulation forward delta seconds and updates the given physics imposters\n     * Prior to the step the imposters physics location is set to the position of the babylon meshes\n     * After the step the babylon meshes are set to the position of the physics imposters\n     * @param delta amount of time to step forward\n     * @param impostors array of imposters to update before/after the step\n     */\n    executeStep(delta, impostors) {\n        for (const impostor of impostors) {\n            // Update physics world objects to match babylon world\n            if (!impostor.soft) {\n                impostor.beforeStep();\n            }\n        }\n        this._stepSimulation(this._useDeltaForWorldStep ? delta : this._timeStep, this._maxSteps, this._fixedTimeStep);\n        for (const mainImpostor of impostors) {\n            // After physics update make babylon world objects match physics world objects\n            if (mainImpostor.soft) {\n                this._afterSoftStep(mainImpostor);\n            }\n            else {\n                mainImpostor.afterStep();\n            }\n            // Handle collision event\n            if (mainImpostor._onPhysicsCollideCallbacks.length > 0) {\n                if (this._isImpostorInContact(mainImpostor)) {\n                    for (const collideCallback of mainImpostor._onPhysicsCollideCallbacks) {\n                        for (const otherImpostor of collideCallback.otherImpostors) {\n                            if (mainImpostor.physicsBody.isActive() || otherImpostor.physicsBody.isActive()) {\n                                if (this._isImpostorPairInContact(mainImpostor, otherImpostor)) {\n                                    mainImpostor.onCollide({\n                                        body: otherImpostor.physicsBody,\n                                        point: this._tmpContactPoint,\n                                        distance: this._tmpContactDistance,\n                                        impulse: this._tmpContactImpulse,\n                                        normal: this._tmpContactNormal,\n                                    });\n                                    otherImpostor.onCollide({\n                                        body: mainImpostor.physicsBody,\n                                        point: this._tmpContactPoint,\n                                        distance: this._tmpContactDistance,\n                                        impulse: this._tmpContactImpulse,\n                                        normal: this._tmpContactNormal,\n                                    });\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * Update babylon mesh to match physics world object\n     * @param impostor imposter to match\n     */\n    _afterSoftStep(impostor) {\n        if (impostor.type === PhysicsImpostor.RopeImpostor) {\n            this._ropeStep(impostor);\n        }\n        else {\n            this._softbodyOrClothStep(impostor);\n        }\n    }\n    /**\n     * Update babylon mesh vertices vertices to match physics world softbody or cloth\n     * @param impostor imposter to match\n     */\n    _ropeStep(impostor) {\n        const bodyVertices = impostor.physicsBody.get_m_nodes();\n        const nbVertices = bodyVertices.size();\n        let node;\n        let nodePositions;\n        let x, y, z;\n        const path = new Array();\n        for (let n = 0; n < nbVertices; n++) {\n            node = bodyVertices.at(n);\n            nodePositions = node.get_m_x();\n            x = nodePositions.x();\n            y = nodePositions.y();\n            z = nodePositions.z();\n            path.push(new Vector3(x, y, z));\n        }\n        const object = impostor.object;\n        const shape = impostor.getParam(\"shape\");\n        if (impostor._isFromLine) {\n            impostor.object = CreateLines(\"lines\", { points: path, instance: object });\n        }\n        else {\n            impostor.object = ExtrudeShape(\"ext\", { shape: shape, path: path, instance: object });\n        }\n    }\n    /**\n     * Update babylon mesh vertices vertices to match physics world softbody or cloth\n     * @param impostor imposter to match\n     */\n    _softbodyOrClothStep(impostor) {\n        const normalDirection = impostor.type === PhysicsImpostor.ClothImpostor ? 1 : -1;\n        const object = impostor.object;\n        let vertexPositions = object.getVerticesData(VertexBuffer.PositionKind);\n        if (!vertexPositions) {\n            vertexPositions = [];\n        }\n        let vertexNormals = object.getVerticesData(VertexBuffer.NormalKind);\n        if (!vertexNormals) {\n            vertexNormals = [];\n        }\n        const nbVertices = vertexPositions.length / 3;\n        const bodyVertices = impostor.physicsBody.get_m_nodes();\n        let node;\n        let nodePositions;\n        let x, y, z;\n        let nx, ny, nz;\n        for (let n = 0; n < nbVertices; n++) {\n            node = bodyVertices.at(n);\n            nodePositions = node.get_m_x();\n            x = nodePositions.x();\n            y = nodePositions.y();\n            z = nodePositions.z() * normalDirection;\n            const nodeNormals = node.get_m_n();\n            nx = nodeNormals.x();\n            ny = nodeNormals.y();\n            nz = nodeNormals.z() * normalDirection;\n            vertexPositions[3 * n] = x;\n            vertexPositions[3 * n + 1] = y;\n            vertexPositions[3 * n + 2] = z;\n            vertexNormals[3 * n] = nx;\n            vertexNormals[3 * n + 1] = ny;\n            vertexNormals[3 * n + 2] = nz;\n        }\n        const vertex_data = new VertexData();\n        vertex_data.positions = vertexPositions;\n        vertex_data.normals = vertexNormals;\n        vertex_data.uvs = object.getVerticesData(VertexBuffer.UVKind);\n        vertex_data.colors = object.getVerticesData(VertexBuffer.ColorKind);\n        if (object && object.getIndices) {\n            vertex_data.indices = object.getIndices();\n        }\n        vertex_data.applyToMesh(object);\n    }\n    /**\n     * Applies an impulse on the imposter\n     * @param impostor imposter to apply impulse to\n     * @param force amount of force to be applied to the imposter\n     * @param contactPoint the location to apply the impulse on the imposter\n     */\n    applyImpulse(impostor, force, contactPoint) {\n        if (!impostor.soft) {\n            impostor.physicsBody.activate();\n            const worldPoint = this._tmpAmmoVectorA;\n            const impulse = this._tmpAmmoVectorB;\n            // Convert contactPoint relative to center of mass\n            if (impostor.object && impostor.object.getWorldMatrix) {\n                contactPoint.subtractInPlace(impostor.object.getWorldMatrix().getTranslation());\n            }\n            worldPoint.setValue(contactPoint.x, contactPoint.y, contactPoint.z);\n            impulse.setValue(force.x, force.y, force.z);\n            impostor.physicsBody.applyImpulse(impulse, worldPoint);\n        }\n        else {\n            Logger.Warn(\"Cannot be applied to a soft body\");\n        }\n    }\n    /**\n     * Applies a force on the imposter\n     * @param impostor imposter to apply force\n     * @param force amount of force to be applied to the imposter\n     * @param contactPoint the location to apply the force on the imposter\n     */\n    applyForce(impostor, force, contactPoint) {\n        if (!impostor.soft) {\n            impostor.physicsBody.activate();\n            const worldPoint = this._tmpAmmoVectorA;\n            const impulse = this._tmpAmmoVectorB;\n            // Convert contactPoint relative to center of mass\n            if (impostor.object && impostor.object.getWorldMatrix) {\n                const localTranslation = impostor.object.getWorldMatrix().getTranslation();\n                worldPoint.setValue(contactPoint.x - localTranslation.x, contactPoint.y - localTranslation.y, contactPoint.z - localTranslation.z);\n            }\n            else {\n                worldPoint.setValue(contactPoint.x, contactPoint.y, contactPoint.z);\n            }\n            impulse.setValue(force.x, force.y, force.z);\n            impostor.physicsBody.applyForce(impulse, worldPoint);\n        }\n        else {\n            Logger.Warn(\"Cannot be applied to a soft body\");\n        }\n    }\n    /**\n     * Creates a physics body using the plugin\n     * @param impostor the imposter to create the physics body on\n     */\n    generatePhysicsBody(impostor) {\n        // Note: this method will not be called on child imposotrs for compound impostors\n        impostor._pluginData.toDispose = [];\n        //parent-child relationship\n        if (impostor.parent) {\n            if (impostor.physicsBody) {\n                this.removePhysicsBody(impostor);\n                impostor.forceUpdate();\n            }\n            return;\n        }\n        if (impostor.isBodyInitRequired()) {\n            const colShape = this._createShape(impostor);\n            const mass = impostor.getParam(\"mass\");\n            impostor._pluginData.mass = mass;\n            if (impostor.soft) {\n                colShape.get_m_cfg().set_collisions(0x11);\n                colShape.get_m_cfg().set_kDP(impostor.getParam(\"damping\"));\n                this.bjsAMMO.castObject(colShape, this.bjsAMMO.btCollisionObject).getCollisionShape().setMargin(impostor.getParam(\"margin\"));\n                colShape.setActivationState(AmmoJSPlugin._DISABLE_DEACTIVATION_FLAG);\n                this.world.addSoftBody(colShape, 1, -1);\n                impostor.physicsBody = colShape;\n                impostor._pluginData.toDispose.push(colShape);\n                this.setBodyPressure(impostor, 0);\n                if (impostor.type === PhysicsImpostor.SoftbodyImpostor) {\n                    this.setBodyPressure(impostor, impostor.getParam(\"pressure\"));\n                }\n                this.setBodyStiffness(impostor, impostor.getParam(\"stiffness\"));\n                this.setBodyVelocityIterations(impostor, impostor.getParam(\"velocityIterations\"));\n                this.setBodyPositionIterations(impostor, impostor.getParam(\"positionIterations\"));\n            }\n            else {\n                const localInertia = new this.bjsAMMO.btVector3(0, 0, 0);\n                const startTransform = new this.bjsAMMO.btTransform();\n                impostor.object.computeWorldMatrix(true);\n                startTransform.setIdentity();\n                if (mass !== 0) {\n                    colShape.calculateLocalInertia(mass, localInertia);\n                }\n                this._tmpAmmoVectorA.setValue(impostor.object.position.x, impostor.object.position.y, impostor.object.position.z);\n                this._tmpAmmoQuaternion.setValue(impostor.object.rotationQuaternion.x, impostor.object.rotationQuaternion.y, impostor.object.rotationQuaternion.z, impostor.object.rotationQuaternion.w);\n                startTransform.setOrigin(this._tmpAmmoVectorA);\n                startTransform.setRotation(this._tmpAmmoQuaternion);\n                const myMotionState = new this.bjsAMMO.btDefaultMotionState(startTransform);\n                const rbInfo = new this.bjsAMMO.btRigidBodyConstructionInfo(mass, myMotionState, colShape, localInertia);\n                const body = new this.bjsAMMO.btRigidBody(rbInfo);\n                // Make objects kinematic if it's mass is 0\n                if (mass === 0) {\n                    body.setCollisionFlags(body.getCollisionFlags() | AmmoJSPlugin._KINEMATIC_FLAG);\n                    body.setActivationState(AmmoJSPlugin._DISABLE_DEACTIVATION_FLAG);\n                }\n                // Disable collision if NoImpostor, but keep collision if shape is btCompoundShape\n                if (impostor.type == PhysicsImpostor.NoImpostor && !colShape.getChildShape) {\n                    body.setCollisionFlags(body.getCollisionFlags() | AmmoJSPlugin._DISABLE_COLLISION_FLAG);\n                }\n                // compute delta position: compensate the difference between shape center and mesh origin\n                if (impostor.type !== PhysicsImpostor.MeshImpostor && impostor.type !== PhysicsImpostor.NoImpostor) {\n                    const boundingInfo = impostor.object.getBoundingInfo();\n                    this._tmpVec3.copyFrom(impostor.object.getAbsolutePosition());\n                    this._tmpVec3.subtractInPlace(boundingInfo.boundingBox.centerWorld);\n                    this._tmpVec3.x /= impostor.object.scaling.x;\n                    this._tmpVec3.y /= impostor.object.scaling.y;\n                    this._tmpVec3.z /= impostor.object.scaling.z;\n                    impostor.setDeltaPosition(this._tmpVec3);\n                }\n                const group = impostor.getParam(\"group\");\n                const mask = impostor.getParam(\"mask\");\n                if (group && mask) {\n                    this.world.addRigidBody(body, group, mask);\n                }\n                else {\n                    this.world.addRigidBody(body);\n                }\n                impostor.physicsBody = body;\n                impostor._pluginData.toDispose = impostor._pluginData.toDispose.concat([body, rbInfo, myMotionState, startTransform, localInertia, colShape]);\n            }\n            this.setBodyRestitution(impostor, impostor.getParam(\"restitution\"));\n            this.setBodyFriction(impostor, impostor.getParam(\"friction\"));\n        }\n    }\n    /**\n     * Removes the physics body from the imposter and disposes of the body's memory\n     * @param impostor imposter to remove the physics body from\n     */\n    removePhysicsBody(impostor) {\n        if (this.world) {\n            if (impostor.soft) {\n                this.world.removeSoftBody(impostor.physicsBody);\n            }\n            else {\n                this.world.removeRigidBody(impostor.physicsBody);\n            }\n            if (impostor._pluginData) {\n                impostor._pluginData.toDispose.forEach((d) => {\n                    this.bjsAMMO.destroy(d);\n                });\n                impostor._pluginData.toDispose = [];\n            }\n        }\n    }\n    /**\n     * Generates a joint\n     * @param impostorJoint the imposter joint to create the joint with\n     */\n    generateJoint(impostorJoint) {\n        const mainBody = impostorJoint.mainImpostor.physicsBody;\n        const connectedBody = impostorJoint.connectedImpostor.physicsBody;\n        if (!mainBody || !connectedBody) {\n            return;\n        }\n        const jointData = impostorJoint.joint.jointData;\n        if (!jointData.mainPivot) {\n            jointData.mainPivot = new Vector3(0, 0, 0);\n        }\n        if (!jointData.connectedPivot) {\n            jointData.connectedPivot = new Vector3(0, 0, 0);\n        }\n        let joint;\n        switch (impostorJoint.joint.type) {\n            case PhysicsJoint.DistanceJoint: {\n                const distance = jointData.maxDistance;\n                if (distance) {\n                    jointData.mainPivot = new Vector3(0, -distance / 2, 0);\n                    jointData.connectedPivot = new Vector3(0, distance / 2, 0);\n                }\n                joint = new this.bjsAMMO.btPoint2PointConstraint(mainBody, connectedBody, new this.bjsAMMO.btVector3(jointData.mainPivot.x, jointData.mainPivot.y, jointData.mainPivot.z), new this.bjsAMMO.btVector3(jointData.connectedPivot.x, jointData.connectedPivot.y, jointData.connectedPivot.z));\n                break;\n            }\n            case PhysicsJoint.HingeJoint: {\n                if (!jointData.mainAxis) {\n                    jointData.mainAxis = new Vector3(0, 0, 0);\n                }\n                if (!jointData.connectedAxis) {\n                    jointData.connectedAxis = new Vector3(0, 0, 0);\n                }\n                const mainAxis = new this.bjsAMMO.btVector3(jointData.mainAxis.x, jointData.mainAxis.y, jointData.mainAxis.z);\n                const connectedAxis = new this.bjsAMMO.btVector3(jointData.connectedAxis.x, jointData.connectedAxis.y, jointData.connectedAxis.z);\n                joint = new this.bjsAMMO.btHingeConstraint(mainBody, connectedBody, new this.bjsAMMO.btVector3(jointData.mainPivot.x, jointData.mainPivot.y, jointData.mainPivot.z), new this.bjsAMMO.btVector3(jointData.connectedPivot.x, jointData.connectedPivot.y, jointData.connectedPivot.z), mainAxis, connectedAxis);\n                break;\n            }\n            case PhysicsJoint.BallAndSocketJoint:\n                joint = new this.bjsAMMO.btPoint2PointConstraint(mainBody, connectedBody, new this.bjsAMMO.btVector3(jointData.mainPivot.x, jointData.mainPivot.y, jointData.mainPivot.z), new this.bjsAMMO.btVector3(jointData.connectedPivot.x, jointData.connectedPivot.y, jointData.connectedPivot.z));\n                break;\n            default:\n                Logger.Warn(\"JointType not currently supported by the Ammo plugin, falling back to PhysicsJoint.BallAndSocketJoint\");\n                joint = new this.bjsAMMO.btPoint2PointConstraint(mainBody, connectedBody, new this.bjsAMMO.btVector3(jointData.mainPivot.x, jointData.mainPivot.y, jointData.mainPivot.z), new this.bjsAMMO.btVector3(jointData.connectedPivot.x, jointData.connectedPivot.y, jointData.connectedPivot.z));\n                break;\n        }\n        this.world.addConstraint(joint, !impostorJoint.joint.jointData.collision);\n        impostorJoint.joint.physicsJoint = joint;\n    }\n    /**\n     * Removes a joint\n     * @param impostorJoint the imposter joint to remove the joint from\n     */\n    removeJoint(impostorJoint) {\n        if (this.world) {\n            this.world.removeConstraint(impostorJoint.joint.physicsJoint);\n        }\n    }\n    // adds all verticies (including child verticies) to the triangle mesh\n    _addMeshVerts(btTriangleMesh, topLevelObject, object) {\n        let triangleCount = 0;\n        if (object && object.getIndices && object.getWorldMatrix && object.getChildMeshes) {\n            let indices = object.getIndices();\n            if (!indices) {\n                indices = [];\n            }\n            let vertexPositions = object.getVerticesData(VertexBuffer.PositionKind);\n            if (!vertexPositions) {\n                vertexPositions = [];\n            }\n            let localMatrix;\n            if (topLevelObject && topLevelObject !== object) {\n                // top level matrix used for shape transform doesn't take scale into account.\n                // Moreover, every children vertex position must be in that space.\n                // So, each vertex position here is transform by (mesh world matrix * toplevelMatrix -1)\n                let topLevelQuaternion;\n                if (topLevelObject.rotationQuaternion) {\n                    topLevelQuaternion = topLevelObject.rotationQuaternion;\n                }\n                else if (topLevelObject.rotation) {\n                    topLevelQuaternion = Quaternion.FromEulerAngles(topLevelObject.rotation.x, topLevelObject.rotation.y, topLevelObject.rotation.z);\n                }\n                else {\n                    topLevelQuaternion = Quaternion.Identity();\n                }\n                const topLevelMatrix = Matrix.Compose(Vector3.One(), topLevelQuaternion, topLevelObject.position);\n                topLevelMatrix.invertToRef(this._tmpMatrix);\n                const wm = object.computeWorldMatrix(false);\n                localMatrix = wm.multiply(this._tmpMatrix);\n            }\n            else {\n                // current top level is same as object level -> only use local scaling\n                Matrix.ScalingToRef(object.scaling.x, object.scaling.y, object.scaling.z, this._tmpMatrix);\n                localMatrix = this._tmpMatrix;\n            }\n            const faceCount = indices.length / 3;\n            for (let i = 0; i < faceCount; i++) {\n                const triPoints = [];\n                for (let point = 0; point < 3; point++) {\n                    let v = new Vector3(vertexPositions[indices[i * 3 + point] * 3 + 0], vertexPositions[indices[i * 3 + point] * 3 + 1], vertexPositions[indices[i * 3 + point] * 3 + 2]);\n                    v = Vector3.TransformCoordinates(v, localMatrix);\n                    let vec;\n                    if (point == 0) {\n                        vec = this._tmpAmmoVectorA;\n                    }\n                    else if (point == 1) {\n                        vec = this._tmpAmmoVectorB;\n                    }\n                    else {\n                        vec = this._tmpAmmoVectorC;\n                    }\n                    vec.setValue(v.x, v.y, v.z);\n                    triPoints.push(vec);\n                }\n                btTriangleMesh.addTriangle(triPoints[0], triPoints[1], triPoints[2]);\n                triangleCount++;\n            }\n            object.getChildMeshes().forEach((m) => {\n                triangleCount += this._addMeshVerts(btTriangleMesh, topLevelObject, m);\n            });\n        }\n        return triangleCount;\n    }\n    /**\n     * Initialise the soft body vertices to match its object's (mesh) vertices\n     * Softbody vertices (nodes) are in world space and to match this\n     * The object's position and rotation is set to zero and so its vertices are also then set in world space\n     * @param impostor to create the softbody for\n     */\n    _softVertexData(impostor) {\n        const object = impostor.object;\n        if (object && object.getIndices && object.getWorldMatrix && object.getChildMeshes) {\n            let indices = object.getIndices();\n            if (!indices) {\n                indices = [];\n            }\n            let vertexPositions = object.getVerticesData(VertexBuffer.PositionKind);\n            if (!vertexPositions) {\n                vertexPositions = [];\n            }\n            let vertexNormals = object.getVerticesData(VertexBuffer.NormalKind);\n            if (!vertexNormals) {\n                vertexNormals = [];\n            }\n            object.computeWorldMatrix(false);\n            const newPoints = [];\n            const newNorms = [];\n            for (let i = 0; i < vertexPositions.length; i += 3) {\n                let v = new Vector3(vertexPositions[i], vertexPositions[i + 1], vertexPositions[i + 2]);\n                let n = new Vector3(vertexNormals[i], vertexNormals[i + 1], vertexNormals[i + 2]);\n                v = Vector3.TransformCoordinates(v, object.getWorldMatrix());\n                n = Vector3.TransformNormal(n, object.getWorldMatrix());\n                newPoints.push(v.x, v.y, v.z);\n                newNorms.push(n.x, n.y, n.z);\n            }\n            const vertex_data = new VertexData();\n            vertex_data.positions = newPoints;\n            vertex_data.normals = newNorms;\n            vertex_data.uvs = object.getVerticesData(VertexBuffer.UVKind);\n            vertex_data.colors = object.getVerticesData(VertexBuffer.ColorKind);\n            if (object && object.getIndices) {\n                vertex_data.indices = object.getIndices();\n            }\n            vertex_data.applyToMesh(object);\n            object.position = Vector3.Zero();\n            object.rotationQuaternion = null;\n            object.rotation = Vector3.Zero();\n            object.computeWorldMatrix(true);\n            return vertex_data;\n        }\n        return VertexData.ExtractFromMesh(object);\n    }\n    /**\n     * Create an impostor's soft body\n     * @param impostor to create the softbody for\n     */\n    _createSoftbody(impostor) {\n        const object = impostor.object;\n        if (object && object.getIndices) {\n            let indices = object.getIndices();\n            if (!indices) {\n                indices = [];\n            }\n            const vertex_data = this._softVertexData(impostor);\n            const vertexPositions = vertex_data.positions;\n            const vertexNormals = vertex_data.normals;\n            if (vertexPositions === null || vertexNormals === null) {\n                return new this.bjsAMMO.btCompoundShape();\n            }\n            else {\n                const triPoints = [];\n                const triNorms = [];\n                for (let i = 0; i < vertexPositions.length; i += 3) {\n                    const v = new Vector3(vertexPositions[i], vertexPositions[i + 1], vertexPositions[i + 2]);\n                    const n = new Vector3(vertexNormals[i], vertexNormals[i + 1], vertexNormals[i + 2]);\n                    triPoints.push(v.x, v.y, -v.z);\n                    triNorms.push(n.x, n.y, -n.z);\n                }\n                const softBody = new this.bjsAMMO.btSoftBodyHelpers().CreateFromTriMesh(this.world.getWorldInfo(), triPoints, object.getIndices(), indices.length / 3, true);\n                const nbVertices = vertexPositions.length / 3;\n                const bodyVertices = softBody.get_m_nodes();\n                let node;\n                let nodeNormals;\n                for (let i = 0; i < nbVertices; i++) {\n                    node = bodyVertices.at(i);\n                    nodeNormals = node.get_m_n();\n                    nodeNormals.setX(triNorms[3 * i]);\n                    nodeNormals.setY(triNorms[3 * i + 1]);\n                    nodeNormals.setZ(triNorms[3 * i + 2]);\n                }\n                return softBody;\n            }\n        }\n    }\n    /**\n     * Create cloth for an impostor\n     * @param impostor to create the softbody for\n     */\n    _createCloth(impostor) {\n        const object = impostor.object;\n        if (object && object.getIndices) {\n            let indices = object.getIndices();\n            if (!indices) {\n                indices = [];\n            }\n            const vertex_data = this._softVertexData(impostor);\n            const vertexPositions = vertex_data.positions;\n            const vertexNormals = vertex_data.normals;\n            if (vertexPositions === null || vertexNormals === null) {\n                return new this.bjsAMMO.btCompoundShape();\n            }\n            else {\n                const len = vertexPositions.length;\n                const segments = Math.sqrt(len / 3);\n                impostor.segments = segments;\n                const segs = segments - 1;\n                this._tmpAmmoVectorA.setValue(vertexPositions[0], vertexPositions[1], vertexPositions[2]);\n                this._tmpAmmoVectorB.setValue(vertexPositions[3 * segs], vertexPositions[3 * segs + 1], vertexPositions[3 * segs + 2]);\n                this._tmpAmmoVectorD.setValue(vertexPositions[len - 3], vertexPositions[len - 2], vertexPositions[len - 1]);\n                this._tmpAmmoVectorC.setValue(vertexPositions[len - 3 - 3 * segs], vertexPositions[len - 2 - 3 * segs], vertexPositions[len - 1 - 3 * segs]);\n                const clothBody = new this.bjsAMMO.btSoftBodyHelpers().CreatePatch(this.world.getWorldInfo(), this._tmpAmmoVectorA, this._tmpAmmoVectorB, this._tmpAmmoVectorC, this._tmpAmmoVectorD, segments, segments, impostor.getParam(\"fixedPoints\"), true);\n                return clothBody;\n            }\n        }\n    }\n    /**\n     * Create rope for an impostor\n     * @param impostor to create the softbody for\n     */\n    _createRope(impostor) {\n        let len;\n        let segments;\n        const vertex_data = this._softVertexData(impostor);\n        const vertexPositions = vertex_data.positions;\n        const vertexNormals = vertex_data.normals;\n        if (vertexPositions === null || vertexNormals === null) {\n            return new this.bjsAMMO.btCompoundShape();\n        }\n        //force the mesh to be updatable\n        vertex_data.applyToMesh(impostor.object, true);\n        impostor._isFromLine = true;\n        // If in lines mesh all normals will be zero\n        const vertexSquared = vertexNormals.map((x) => x * x);\n        const reducer = (accumulator, currentValue) => accumulator + currentValue;\n        const reduced = vertexSquared.reduce(reducer);\n        if (reduced === 0) {\n            // line mesh\n            len = vertexPositions.length;\n            segments = len / 3 - 1;\n            this._tmpAmmoVectorA.setValue(vertexPositions[0], vertexPositions[1], vertexPositions[2]);\n            this._tmpAmmoVectorB.setValue(vertexPositions[len - 3], vertexPositions[len - 2], vertexPositions[len - 1]);\n        }\n        else {\n            //extruded mesh\n            impostor._isFromLine = false;\n            const pathVectors = impostor.getParam(\"path\");\n            const shape = impostor.getParam(\"shape\");\n            if (shape === null) {\n                Logger.Warn(\"No shape available for extruded mesh\");\n                return new this.bjsAMMO.btCompoundShape();\n            }\n            len = pathVectors.length;\n            segments = len - 1;\n            this._tmpAmmoVectorA.setValue(pathVectors[0].x, pathVectors[0].y, pathVectors[0].z);\n            this._tmpAmmoVectorB.setValue(pathVectors[len - 1].x, pathVectors[len - 1].y, pathVectors[len - 1].z);\n        }\n        impostor.segments = segments;\n        let fixedPoints = impostor.getParam(\"fixedPoints\");\n        fixedPoints = fixedPoints > 3 ? 3 : fixedPoints;\n        const ropeBody = new this.bjsAMMO.btSoftBodyHelpers().CreateRope(this.world.getWorldInfo(), this._tmpAmmoVectorA, this._tmpAmmoVectorB, segments - 1, fixedPoints);\n        ropeBody.get_m_cfg().set_collisions(0x11);\n        return ropeBody;\n    }\n    /**\n     * Create a custom physics impostor shape using the plugin's onCreateCustomShape handler\n     * @param impostor to create the custom physics shape for\n     */\n    _createCustom(impostor) {\n        let returnValue = null;\n        if (this.onCreateCustomShape) {\n            returnValue = this.onCreateCustomShape(impostor);\n        }\n        if (returnValue == null) {\n            returnValue = new this.bjsAMMO.btCompoundShape();\n        }\n        return returnValue;\n    }\n    // adds all verticies (including child verticies) to the convex hull shape\n    _addHullVerts(btConvexHullShape, topLevelObject, object) {\n        let triangleCount = 0;\n        if (object && object.getIndices && object.getWorldMatrix && object.getChildMeshes) {\n            let indices = object.getIndices();\n            if (!indices) {\n                indices = [];\n            }\n            let vertexPositions = object.getVerticesData(VertexBuffer.PositionKind);\n            if (!vertexPositions) {\n                vertexPositions = [];\n            }\n            object.computeWorldMatrix(false);\n            const faceCount = indices.length / 3;\n            for (let i = 0; i < faceCount; i++) {\n                const triPoints = [];\n                for (let point = 0; point < 3; point++) {\n                    let v = new Vector3(vertexPositions[indices[i * 3 + point] * 3 + 0], vertexPositions[indices[i * 3 + point] * 3 + 1], vertexPositions[indices[i * 3 + point] * 3 + 2]);\n                    // Adjust for initial scaling\n                    Matrix.ScalingToRef(object.scaling.x, object.scaling.y, object.scaling.z, this._tmpMatrix);\n                    v = Vector3.TransformCoordinates(v, this._tmpMatrix);\n                    let vec;\n                    if (point == 0) {\n                        vec = this._tmpAmmoVectorA;\n                    }\n                    else if (point == 1) {\n                        vec = this._tmpAmmoVectorB;\n                    }\n                    else {\n                        vec = this._tmpAmmoVectorC;\n                    }\n                    vec.setValue(v.x, v.y, v.z);\n                    triPoints.push(vec);\n                }\n                btConvexHullShape.addPoint(triPoints[0], true);\n                btConvexHullShape.addPoint(triPoints[1], true);\n                btConvexHullShape.addPoint(triPoints[2], true);\n                triangleCount++;\n            }\n            object.getChildMeshes().forEach((m) => {\n                triangleCount += this._addHullVerts(btConvexHullShape, topLevelObject, m);\n            });\n        }\n        return triangleCount;\n    }\n    _createShape(impostor, ignoreChildren = false) {\n        const object = impostor.object;\n        let returnValue;\n        const impostorExtents = impostor.getObjectExtents();\n        if (!ignoreChildren) {\n            const meshChildren = impostor.object.getChildMeshes ? impostor.object.getChildMeshes(true) : [];\n            returnValue = new this.bjsAMMO.btCompoundShape();\n            // Add shape of all children to the compound shape\n            let childrenAdded = 0;\n            meshChildren.forEach((childMesh) => {\n                const childImpostor = childMesh.getPhysicsImpostor();\n                if (childImpostor) {\n                    if (childImpostor.type == PhysicsImpostor.MeshImpostor) {\n                        throw \"A child MeshImpostor is not supported. Only primitive impostors are supported as children (eg. box or sphere)\";\n                    }\n                    const shape = this._createShape(childImpostor);\n                    // Position needs to be scaled based on parent's scaling\n                    const parentMat = childMesh.parent.getWorldMatrix().clone();\n                    const s = new Vector3();\n                    parentMat.decompose(s);\n                    this._tmpAmmoTransform.getOrigin().setValue(childMesh.position.x * s.x, childMesh.position.y * s.y, childMesh.position.z * s.z);\n                    this._tmpAmmoQuaternion.setValue(childMesh.rotationQuaternion.x, childMesh.rotationQuaternion.y, childMesh.rotationQuaternion.z, childMesh.rotationQuaternion.w);\n                    this._tmpAmmoTransform.setRotation(this._tmpAmmoQuaternion);\n                    returnValue.addChildShape(this._tmpAmmoTransform, shape);\n                    childImpostor.dispose();\n                    childrenAdded++;\n                }\n            });\n            if (childrenAdded > 0) {\n                // Add parents shape as a child if present\n                if (impostor.type != PhysicsImpostor.NoImpostor) {\n                    const shape = this._createShape(impostor, true);\n                    if (shape) {\n                        this._tmpAmmoTransform.getOrigin().setValue(0, 0, 0);\n                        this._tmpAmmoQuaternion.setValue(0, 0, 0, 1);\n                        this._tmpAmmoTransform.setRotation(this._tmpAmmoQuaternion);\n                        returnValue.addChildShape(this._tmpAmmoTransform, shape);\n                    }\n                }\n                return returnValue;\n            }\n            else {\n                // If no children with impostors create the actual shape below instead\n                this.bjsAMMO.destroy(returnValue);\n                returnValue = null;\n            }\n        }\n        switch (impostor.type) {\n            case PhysicsImpostor.SphereImpostor:\n                // Is there a better way to compare floats number? With an epsilon or with a Math function\n                if (Scalar.WithinEpsilon(impostorExtents.x, impostorExtents.y, 0.0001) && Scalar.WithinEpsilon(impostorExtents.x, impostorExtents.z, 0.0001)) {\n                    returnValue = new this.bjsAMMO.btSphereShape(impostorExtents.x / 2);\n                }\n                else {\n                    // create a btMultiSphereShape because it's not possible to set a local scaling on a btSphereShape\n                    const positions = [new this.bjsAMMO.btVector3(0, 0, 0)];\n                    const radii = [1];\n                    returnValue = new this.bjsAMMO.btMultiSphereShape(positions, radii, 1);\n                    returnValue.setLocalScaling(new this.bjsAMMO.btVector3(impostorExtents.x / 2, impostorExtents.y / 2, impostorExtents.z / 2));\n                }\n                break;\n            case PhysicsImpostor.CapsuleImpostor:\n                {\n                    // https://pybullet.org/Bullet/BulletFull/classbtCapsuleShape.html#details\n                    // Height is just the height between the center of each 'sphere' of the capsule caps\n                    const capRadius = impostorExtents.x / 2;\n                    returnValue = new this.bjsAMMO.btCapsuleShape(capRadius, impostorExtents.y - capRadius * 2);\n                }\n                break;\n            case PhysicsImpostor.CylinderImpostor:\n                this._tmpAmmoVectorA.setValue(impostorExtents.x / 2, impostorExtents.y / 2, impostorExtents.z / 2);\n                returnValue = new this.bjsAMMO.btCylinderShape(this._tmpAmmoVectorA);\n                break;\n            case PhysicsImpostor.PlaneImpostor:\n            case PhysicsImpostor.BoxImpostor:\n                this._tmpAmmoVectorA.setValue(impostorExtents.x / 2, impostorExtents.y / 2, impostorExtents.z / 2);\n                returnValue = new this.bjsAMMO.btBoxShape(this._tmpAmmoVectorA);\n                break;\n            case PhysicsImpostor.MeshImpostor: {\n                if (impostor.getParam(\"mass\") == 0) {\n                    // Only create btBvhTriangleMeshShape if the impostor is static\n                    // See https://pybullet.org/Bullet/phpBB3/viewtopic.php?t=7283\n                    if (this.onCreateCustomMeshImpostor) {\n                        returnValue = this.onCreateCustomMeshImpostor(impostor);\n                    }\n                    else {\n                        const triMesh = new this.bjsAMMO.btTriangleMesh();\n                        impostor._pluginData.toDispose.push(triMesh);\n                        const triangleCount = this._addMeshVerts(triMesh, object, object);\n                        if (triangleCount == 0) {\n                            returnValue = new this.bjsAMMO.btCompoundShape();\n                        }\n                        else {\n                            returnValue = new this.bjsAMMO.btBvhTriangleMeshShape(triMesh);\n                        }\n                    }\n                    break;\n                }\n            }\n            // Otherwise create convexHullImpostor\n            // eslint-disable-next-line no-fallthrough\n            case PhysicsImpostor.ConvexHullImpostor: {\n                if (this.onCreateCustomConvexHullImpostor) {\n                    returnValue = this.onCreateCustomConvexHullImpostor(impostor);\n                }\n                else {\n                    const convexHull = new this.bjsAMMO.btConvexHullShape();\n                    const triangleCount = this._addHullVerts(convexHull, object, object);\n                    if (triangleCount == 0) {\n                        // Cleanup Unused Convex Hull Shape\n                        impostor._pluginData.toDispose.push(convexHull);\n                        returnValue = new this.bjsAMMO.btCompoundShape();\n                    }\n                    else {\n                        returnValue = convexHull;\n                    }\n                }\n                break;\n            }\n            case PhysicsImpostor.NoImpostor:\n                // Fill with sphere but collision is disabled on the rigid body in generatePhysicsBody, using an empty shape caused unexpected movement with joints\n                returnValue = new this.bjsAMMO.btSphereShape(impostorExtents.x / 2);\n                break;\n            case PhysicsImpostor.CustomImpostor:\n                // Only usable when the plugin's onCreateCustomShape is set\n                returnValue = this._createCustom(impostor);\n                break;\n            case PhysicsImpostor.SoftbodyImpostor:\n                // Only usable with a mesh that has sufficient and shared vertices\n                returnValue = this._createSoftbody(impostor);\n                break;\n            case PhysicsImpostor.ClothImpostor:\n                // Only usable with a ground mesh that has sufficient and shared vertices\n                returnValue = this._createCloth(impostor);\n                break;\n            case PhysicsImpostor.RopeImpostor:\n                // Only usable with a line mesh or an extruded mesh that is updatable\n                returnValue = this._createRope(impostor);\n                break;\n            default:\n                Logger.Warn(\"The impostor type is not currently supported by the ammo plugin.\");\n                break;\n        }\n        return returnValue;\n    }\n    /**\n     * Sets the mesh body position/rotation from the babylon impostor\n     * @param impostor imposter containing the physics body and babylon object\n     */\n    setTransformationFromPhysicsBody(impostor) {\n        impostor.physicsBody.getMotionState().getWorldTransform(this._tmpAmmoTransform);\n        impostor.object.position.set(this._tmpAmmoTransform.getOrigin().x(), this._tmpAmmoTransform.getOrigin().y(), this._tmpAmmoTransform.getOrigin().z());\n        if (!impostor.object.rotationQuaternion) {\n            if (impostor.object.rotation) {\n                this._tmpQuaternion.set(this._tmpAmmoTransform.getRotation().x(), this._tmpAmmoTransform.getRotation().y(), this._tmpAmmoTransform.getRotation().z(), this._tmpAmmoTransform.getRotation().w());\n                this._tmpQuaternion.toEulerAnglesToRef(impostor.object.rotation);\n            }\n        }\n        else {\n            impostor.object.rotationQuaternion.set(this._tmpAmmoTransform.getRotation().x(), this._tmpAmmoTransform.getRotation().y(), this._tmpAmmoTransform.getRotation().z(), this._tmpAmmoTransform.getRotation().w());\n        }\n    }\n    /**\n     * Sets the babylon object's position/rotation from the physics body's position/rotation\n     * @param impostor imposter containing the physics body and babylon object\n     * @param newPosition new position\n     * @param newRotation new rotation\n     */\n    setPhysicsBodyTransformation(impostor, newPosition, newRotation) {\n        const trans = impostor.physicsBody.getWorldTransform();\n        // If rotation/position has changed update and activate rigged body\n        if (Math.abs(trans.getOrigin().x() - newPosition.x) > Epsilon ||\n            Math.abs(trans.getOrigin().y() - newPosition.y) > Epsilon ||\n            Math.abs(trans.getOrigin().z() - newPosition.z) > Epsilon ||\n            Math.abs(trans.getRotation().x() - newRotation.x) > Epsilon ||\n            Math.abs(trans.getRotation().y() - newRotation.y) > Epsilon ||\n            Math.abs(trans.getRotation().z() - newRotation.z) > Epsilon ||\n            Math.abs(trans.getRotation().w() - newRotation.w) > Epsilon) {\n            this._tmpAmmoVectorA.setValue(newPosition.x, newPosition.y, newPosition.z);\n            trans.setOrigin(this._tmpAmmoVectorA);\n            this._tmpAmmoQuaternion.setValue(newRotation.x, newRotation.y, newRotation.z, newRotation.w);\n            trans.setRotation(this._tmpAmmoQuaternion);\n            impostor.physicsBody.setWorldTransform(trans);\n            if (impostor.mass == 0) {\n                // Kinematic objects must be updated using motion state\n                const motionState = impostor.physicsBody.getMotionState();\n                if (motionState) {\n                    motionState.setWorldTransform(trans);\n                }\n            }\n            else {\n                impostor.physicsBody.activate();\n            }\n        }\n    }\n    /**\n     * If this plugin is supported\n     * @returns true if its supported\n     */\n    isSupported() {\n        return this.bjsAMMO !== undefined;\n    }\n    /**\n     * Sets the linear velocity of the physics body\n     * @param impostor imposter to set the velocity on\n     * @param velocity velocity to set\n     */\n    setLinearVelocity(impostor, velocity) {\n        this._tmpAmmoVectorA.setValue(velocity.x, velocity.y, velocity.z);\n        if (impostor.soft) {\n            impostor.physicsBody.linearVelocity(this._tmpAmmoVectorA);\n        }\n        else {\n            impostor.physicsBody.setLinearVelocity(this._tmpAmmoVectorA);\n        }\n    }\n    /**\n     * Sets the angular velocity of the physics body\n     * @param impostor imposter to set the velocity on\n     * @param velocity velocity to set\n     */\n    setAngularVelocity(impostor, velocity) {\n        this._tmpAmmoVectorA.setValue(velocity.x, velocity.y, velocity.z);\n        if (impostor.soft) {\n            impostor.physicsBody.angularVelocity(this._tmpAmmoVectorA);\n        }\n        else {\n            impostor.physicsBody.setAngularVelocity(this._tmpAmmoVectorA);\n        }\n    }\n    /**\n     * gets the linear velocity\n     * @param impostor imposter to get linear velocity from\n     * @returns linear velocity\n     */\n    getLinearVelocity(impostor) {\n        let v;\n        if (impostor.soft) {\n            v = impostor.physicsBody.linearVelocity();\n        }\n        else {\n            v = impostor.physicsBody.getLinearVelocity();\n        }\n        if (!v) {\n            return null;\n        }\n        const result = new Vector3(v.x(), v.y(), v.z());\n        this.bjsAMMO.destroy(v);\n        return result;\n    }\n    /**\n     * gets the angular velocity\n     * @param impostor imposter to get angular velocity from\n     * @returns angular velocity\n     */\n    getAngularVelocity(impostor) {\n        let v;\n        if (impostor.soft) {\n            v = impostor.physicsBody.angularVelocity();\n        }\n        else {\n            v = impostor.physicsBody.getAngularVelocity();\n        }\n        if (!v) {\n            return null;\n        }\n        const result = new Vector3(v.x(), v.y(), v.z());\n        this.bjsAMMO.destroy(v);\n        return result;\n    }\n    /**\n     * Sets the mass of physics body\n     * @param impostor imposter to set the mass on\n     * @param mass mass to set\n     */\n    setBodyMass(impostor, mass) {\n        if (impostor.soft) {\n            impostor.physicsBody.setTotalMass(mass, false);\n        }\n        else {\n            impostor.physicsBody.setMassProps(mass);\n        }\n        impostor._pluginData.mass = mass;\n    }\n    /**\n     * Gets the mass of the physics body\n     * @param impostor imposter to get the mass from\n     * @returns mass\n     */\n    getBodyMass(impostor) {\n        return impostor._pluginData.mass || 0;\n    }\n    /**\n     * Gets friction of the impostor\n     * @param impostor impostor to get friction from\n     * @returns friction value\n     */\n    getBodyFriction(impostor) {\n        return impostor._pluginData.friction || 0;\n    }\n    /**\n     * Sets friction of the impostor\n     * @param impostor impostor to set friction on\n     * @param friction friction value\n     */\n    setBodyFriction(impostor, friction) {\n        if (impostor.soft) {\n            impostor.physicsBody.get_m_cfg().set_kDF(friction);\n        }\n        else {\n            impostor.physicsBody.setFriction(friction);\n        }\n        impostor._pluginData.friction = friction;\n    }\n    /**\n     * Gets restitution of the impostor\n     * @param impostor impostor to get restitution from\n     * @returns restitution value\n     */\n    getBodyRestitution(impostor) {\n        return impostor._pluginData.restitution || 0;\n    }\n    /**\n     * Sets restitution of the impostor\n     * @param impostor impostor to set resitution on\n     * @param restitution resitution value\n     */\n    setBodyRestitution(impostor, restitution) {\n        impostor.physicsBody.setRestitution(restitution);\n        impostor._pluginData.restitution = restitution;\n    }\n    /**\n     * Gets pressure inside the impostor\n     * @param impostor impostor to get pressure from\n     * @returns pressure value\n     */\n    getBodyPressure(impostor) {\n        if (!impostor.soft) {\n            Logger.Warn(\"Pressure is not a property of a rigid body\");\n            return 0;\n        }\n        return impostor._pluginData.pressure || 0;\n    }\n    /**\n     * Sets pressure inside a soft body impostor\n     * Cloth and rope must remain 0 pressure\n     * @param impostor impostor to set pressure on\n     * @param pressure pressure value\n     */\n    setBodyPressure(impostor, pressure) {\n        if (impostor.soft) {\n            if (impostor.type === PhysicsImpostor.SoftbodyImpostor) {\n                impostor.physicsBody.get_m_cfg().set_kPR(pressure);\n                impostor._pluginData.pressure = pressure;\n            }\n            else {\n                impostor.physicsBody.get_m_cfg().set_kPR(0);\n                impostor._pluginData.pressure = 0;\n            }\n        }\n        else {\n            Logger.Warn(\"Pressure can only be applied to a softbody\");\n        }\n    }\n    /**\n     * Gets stiffness of the impostor\n     * @param impostor impostor to get stiffness from\n     * @returns pressure value\n     */\n    getBodyStiffness(impostor) {\n        if (!impostor.soft) {\n            Logger.Warn(\"Stiffness is not a property of a rigid body\");\n            return 0;\n        }\n        return impostor._pluginData.stiffness || 0;\n    }\n    /**\n     * Sets stiffness of the impostor\n     * @param impostor impostor to set stiffness on\n     * @param stiffness stiffness value from 0 to 1\n     */\n    setBodyStiffness(impostor, stiffness) {\n        if (impostor.soft) {\n            stiffness = stiffness < 0 ? 0 : stiffness;\n            stiffness = stiffness > 1 ? 1 : stiffness;\n            impostor.physicsBody.get_m_materials().at(0).set_m_kLST(stiffness);\n            impostor._pluginData.stiffness = stiffness;\n        }\n        else {\n            Logger.Warn(\"Stiffness cannot be applied to a rigid body\");\n        }\n    }\n    /**\n     * Gets velocityIterations of the impostor\n     * @param impostor impostor to get velocity iterations from\n     * @returns velocityIterations value\n     */\n    getBodyVelocityIterations(impostor) {\n        if (!impostor.soft) {\n            Logger.Warn(\"Velocity iterations is not a property of a rigid body\");\n            return 0;\n        }\n        return impostor._pluginData.velocityIterations || 0;\n    }\n    /**\n     * Sets velocityIterations of the impostor\n     * @param impostor impostor to set velocity iterations on\n     * @param velocityIterations velocityIterations value\n     */\n    setBodyVelocityIterations(impostor, velocityIterations) {\n        if (impostor.soft) {\n            velocityIterations = velocityIterations < 0 ? 0 : velocityIterations;\n            impostor.physicsBody.get_m_cfg().set_viterations(velocityIterations);\n            impostor._pluginData.velocityIterations = velocityIterations;\n        }\n        else {\n            Logger.Warn(\"Velocity iterations cannot be applied to a rigid body\");\n        }\n    }\n    /**\n     * Gets positionIterations of the impostor\n     * @param impostor impostor to get position iterations from\n     * @returns positionIterations value\n     */\n    getBodyPositionIterations(impostor) {\n        if (!impostor.soft) {\n            Logger.Warn(\"Position iterations is not a property of a rigid body\");\n            return 0;\n        }\n        return impostor._pluginData.positionIterations || 0;\n    }\n    /**\n     * Sets positionIterations of the impostor\n     * @param impostor impostor to set position on\n     * @param positionIterations positionIterations value\n     */\n    setBodyPositionIterations(impostor, positionIterations) {\n        if (impostor.soft) {\n            positionIterations = positionIterations < 0 ? 0 : positionIterations;\n            impostor.physicsBody.get_m_cfg().set_piterations(positionIterations);\n            impostor._pluginData.positionIterations = positionIterations;\n        }\n        else {\n            Logger.Warn(\"Position iterations cannot be applied to a rigid body\");\n        }\n    }\n    /**\n     * Append an anchor to a cloth object\n     * @param impostor is the cloth impostor to add anchor to\n     * @param otherImpostor is the rigid impostor to anchor to\n     * @param width ratio across width from 0 to 1\n     * @param height ratio up height from 0 to 1\n     * @param influence the elasticity between cloth impostor and anchor from 0, very stretchy to 1, little stretch\n     * @param noCollisionBetweenLinkedBodies when true collisions between soft impostor and anchor are ignored; default false\n     */\n    appendAnchor(impostor, otherImpostor, width, height, influence = 1, noCollisionBetweenLinkedBodies = false) {\n        const segs = impostor.segments;\n        const nbAcross = Math.round((segs - 1) * width);\n        const nbUp = Math.round((segs - 1) * height);\n        const nbDown = segs - 1 - nbUp;\n        const node = nbAcross + segs * nbDown;\n        impostor.physicsBody.appendAnchor(node, otherImpostor.physicsBody, noCollisionBetweenLinkedBodies, influence);\n    }\n    /**\n     * Append an hook to a rope object\n     * @param impostor is the rope impostor to add hook to\n     * @param otherImpostor is the rigid impostor to hook to\n     * @param length ratio along the rope from 0 to 1\n     * @param influence the elasticity between soft impostor and anchor from 0, very stretchy to 1, little stretch\n     * @param noCollisionBetweenLinkedBodies when true collisions between soft impostor and anchor are ignored; default false\n     */\n    appendHook(impostor, otherImpostor, length, influence = 1, noCollisionBetweenLinkedBodies = false) {\n        const node = Math.round(impostor.segments * length);\n        impostor.physicsBody.appendAnchor(node, otherImpostor.physicsBody, noCollisionBetweenLinkedBodies, influence);\n    }\n    /**\n     * Sleeps the physics body and stops it from being active\n     * @param impostor impostor to sleep\n     */\n    sleepBody(impostor) {\n        impostor.physicsBody.forceActivationState(0);\n    }\n    /**\n     * Activates the physics body\n     * @param impostor impostor to activate\n     */\n    wakeUpBody(impostor) {\n        impostor.physicsBody.activate();\n    }\n    /**\n     * Updates the distance parameters of the joint\n     */\n    updateDistanceJoint() {\n        Logger.Warn(\"updateDistanceJoint is not currently supported by the Ammo physics plugin\");\n    }\n    /**\n     * Sets a motor on the joint\n     * @param joint joint to set motor on\n     * @param speed speed of the motor\n     * @param maxForce maximum force of the motor\n     */\n    setMotor(joint, speed, maxForce) {\n        joint.physicsJoint.enableAngularMotor(true, speed, maxForce);\n    }\n    /**\n     * Sets the motors limit\n     */\n    setLimit() {\n        Logger.Warn(\"setLimit is not currently supported by the Ammo physics plugin\");\n    }\n    /**\n     * Syncs the position and rotation of a mesh with the impostor\n     * @param mesh mesh to sync\n     * @param impostor impostor to update the mesh with\n     */\n    syncMeshWithImpostor(mesh, impostor) {\n        const body = impostor.physicsBody;\n        body.getMotionState().getWorldTransform(this._tmpAmmoTransform);\n        mesh.position.x = this._tmpAmmoTransform.getOrigin().x();\n        mesh.position.y = this._tmpAmmoTransform.getOrigin().y();\n        mesh.position.z = this._tmpAmmoTransform.getOrigin().z();\n        if (mesh.rotationQuaternion) {\n            mesh.rotationQuaternion.x = this._tmpAmmoTransform.getRotation().x();\n            mesh.rotationQuaternion.y = this._tmpAmmoTransform.getRotation().y();\n            mesh.rotationQuaternion.z = this._tmpAmmoTransform.getRotation().z();\n            mesh.rotationQuaternion.w = this._tmpAmmoTransform.getRotation().w();\n        }\n    }\n    /**\n     * Gets the radius of the impostor\n     * @param impostor impostor to get radius from\n     * @returns the radius\n     */\n    getRadius(impostor) {\n        const extents = impostor.getObjectExtents();\n        return extents.x / 2;\n    }\n    /**\n     * Gets the box size of the impostor\n     * @param impostor impostor to get box size from\n     * @param result the resulting box size\n     */\n    getBoxSizeToRef(impostor, result) {\n        const extents = impostor.getObjectExtents();\n        result.x = extents.x;\n        result.y = extents.y;\n        result.z = extents.z;\n    }\n    /**\n     * Disposes of the impostor\n     */\n    dispose() {\n        // Dispose of world\n        this.bjsAMMO.destroy(this.world);\n        this.bjsAMMO.destroy(this._solver);\n        this.bjsAMMO.destroy(this._overlappingPairCache);\n        this.bjsAMMO.destroy(this._dispatcher);\n        this.bjsAMMO.destroy(this._collisionConfiguration);\n        // Dispose of temp variables\n        this.bjsAMMO.destroy(this._tmpAmmoVectorA);\n        this.bjsAMMO.destroy(this._tmpAmmoVectorB);\n        this.bjsAMMO.destroy(this._tmpAmmoVectorC);\n        this.bjsAMMO.destroy(this._tmpAmmoTransform);\n        this.bjsAMMO.destroy(this._tmpAmmoQuaternion);\n        this.bjsAMMO.destroy(this._tmpAmmoConcreteContactResultCallback);\n        this.world = null;\n    }\n    /**\n     * Does a raycast in the physics world\n     * @param from where should the ray start?\n     * @param to where should the ray end?\n     * @returns PhysicsRaycastResult\n     */\n    raycast(from, to) {\n        this.raycastToRef(from, to, this._raycastResult);\n        return this._raycastResult;\n    }\n    /**\n     * Does a raycast in the physics world\n     * @param from when should the ray start?\n     * @param to when should the ray end?\n     * @param result resulting PhysicsRaycastResult\n     */\n    raycastToRef(from, to, result) {\n        this._tmpAmmoVectorRCA = new this.bjsAMMO.btVector3(from.x, from.y, from.z);\n        this._tmpAmmoVectorRCB = new this.bjsAMMO.btVector3(to.x, to.y, to.z);\n        const rayCallback = new this.bjsAMMO.ClosestRayResultCallback(this._tmpAmmoVectorRCA, this._tmpAmmoVectorRCB);\n        this.world.rayTest(this._tmpAmmoVectorRCA, this._tmpAmmoVectorRCB, rayCallback);\n        result.reset(from, to);\n        if (rayCallback.hasHit()) {\n            // TODO: do we want/need the body? If so, set all the data\n            /*\n            var rigidBody = this.bjsAMMO.btRigidBody.prototype.upcast(\n                rayCallback.get_m_collisionObject()\n            );\n            var body = {};\n            */\n            result.setHitData({\n                x: rayCallback.get_m_hitNormalWorld().x(),\n                y: rayCallback.get_m_hitNormalWorld().y(),\n                z: rayCallback.get_m_hitNormalWorld().z(),\n            }, {\n                x: rayCallback.get_m_hitPointWorld().x(),\n                y: rayCallback.get_m_hitPointWorld().y(),\n                z: rayCallback.get_m_hitPointWorld().z(),\n            });\n            result.calculateHitDistance();\n        }\n        this.bjsAMMO.destroy(rayCallback);\n        this.bjsAMMO.destroy(this._tmpAmmoVectorRCA);\n        this.bjsAMMO.destroy(this._tmpAmmoVectorRCB);\n    }\n}\nAmmoJSPlugin._DISABLE_COLLISION_FLAG = 4;\nAmmoJSPlugin._KINEMATIC_FLAG = 2;\nAmmoJSPlugin._DISABLE_DEACTIVATION_FLAG = 4;\n//# sourceMappingURL=ammoJSPlugin.js.map"],"names":["BoxParticleEmitter","constructor","this","direction1","direction2","minEmitBox","maxEmitBox","startDirectionFunction","worldMatrix","directionToUpdate","particle","isLocal","randX","x","randY","y","randZ","z","startPositionFunction","positionToUpdate","clone","newOne","applyToShader","uboOrEffect","setVector3","buildUniformLayout","ubo","addUniform","getEffectDefines","getClassName","serialize","serializationObject","type","asArray","parse","ConeParticleEmitter","radius","_radius","value","_buildHeight","angle","_angle","_height","Math","tan","PI","directionRandomizer","radiusRange","heightRange","emitFromSpawnPointOnly","_localPosition","normalize","position","subtractToRef","getTranslation","s","h","sin","cos","setFloat2","setFloat","defines","undefined","CustomParticleEmitter","particlePositionGenerator","particleDestinationGenerator","tmpVector","diffVector","scaleToRef","lifeTime","set","copyFrom","CylinderParticleEmitter","height","_tempVector","inverseWorldMatrix","atan2","yPos","radiusDistribution","positionRadius","sqrt","xPos","zPos","copyFromFloats","CylinderDirectedParticleEmitter","super","HemisphericParticleEmitter","direction","subtract","randRadius","v","phi","theta","acos","abs","PointParticleEmitter","MeshParticleEmitter","mesh","_mesh","_indices","getIndices","_positions","getVerticesData","_normals","_storedNormal","useMeshNormalsForDirection","randomFaceIndex","random","length","bu","bv","bw","faceIndexA","faceIndexB","faceIndexC","vertexA","vertexB","vertexC","randomVertex","_a","meshId","id","scene","getLastMeshById","SphereParticleEmitter","SphereDirectedParticleEmitter","BaseParticleSystem","noiseTexture","_noiseTexture","_reset","isAnimationSheetEnabled","_isAnimationSheetEnabled","useLogarithmicDepth","_useLogarithmicDepth","getScene","getEngine","getCaps","fragmentDepthSupported","_scene","_hasTargetStopDurationDependantGradient","_startSizeGradients","_emitRateGradients","_lifeTimeGradients","getDragGradients","_dragGradients","getLimitVelocityGradients","_limitVelocityGradients","getColorGradients","_colorGradients","getSizeGradients","_sizeGradients","getColorRemapGradients","_colorRemapGradients","getAlphaRemapGradients","_alphaRemapGradients","getLifeTimeGradients","getAngularSpeedGradients","_angularSpeedGradients","getVelocityGradients","_velocityGradients","getStartSizeGradients","getEmitRateGradients","particleEmitterType","billboardMode","_billboardMode","isBillboardBased","_isBillboardBased","imageProcessingConfiguration","_imageProcessingConfiguration","_attachImageProcessingConfiguration","configuration","_removeGradientAndTexture","gradient","gradients","texture","index","valueGradient","splice","dispose","name","animations","renderingGroupId","emitter","emitRate","manualEmitCount","updateSpeed","targetStopDuration","disposeOnStop","minEmitPower","maxEmitPower","minLifeTime","maxLifeTime","minSize","maxSize","minScaleX","maxScaleX","minScaleY","maxScaleY","minInitialRotation","maxInitialRotation","minAngularSpeed","maxAngularSpeed","layerMask","customShader","preventAutoStart","_wasDispatched","_rootUrl","noiseStrength","onAnimationEnd","blendMode","BLENDMODE_ONEONE","forceDepthWrite","preWarmCycles","preWarmStepOffset","spriteCellChangeSpeed","startSpriteCellID","endSpriteCellID","spriteCellWidth","spriteCellHeight","spriteCellLoop","spriteRandomStartCell","translationPivot","beginAnimationOnStart","beginAnimationFrom","beginAnimationTo","beginAnimationLoop","worldOffset","gravity","_rampGradients","startDelay","limitVelocityDamping","color1","color2","colorDead","textureMask","_isSubEmitter","_imageProcessingConfigurationDefines","createPointEmitter","particleEmitter","createHemisphericEmitter","createSphereEmitter","createDirectedSphereEmitter","createCylinderEmitter","createDirectedCylinderEmitter","createConeEmitter","createBoxEmitter","BLENDMODE_STANDARD","BLENDMODE_ADD","BLENDMODE_MULTIPLY","BLENDMODE_MULTIPLYADD","CloudPoint","particleIndex","group","groupId","idxInGroup","pcs","idx","color","rotation","uv","velocity","pivot","translateFromPivot","_pos","_ind","_stillInvisible","_rotationMatrix","parentId","_globalPosition","_group","_pcs","size","scale","quaternion","rotationQuaternion","q","intersectsMesh","target","isSphere","hasBoundingInfo","Error","getBoundingInfo","boundingSphere","intersectsPoint","add","bbox","boundingBox","maxX","maximumWorld","minX","minimumWorld","maxY","minY","maxZ","minZ","getRotationMatrix","m","toRotationMatrix","PointsGroup","groupID","posFunction","_positionFunction","GPUParticleSystem","IsSupported","caps","supportTransformFeedbacks","supportComputeShaders","getCapacity","_capacity","activeParticleCount","_activeCount","min","isReady","particleTexture","_getWrapper","effect","_platform","isUpdateBufferCreated","isUpdateBufferReady","_recreateUpdateEffect","isStarted","_started","isStopped","_stopped","isStopping","getActiveCount","_currentActiveCount","start","delay","setTimeout","_preWarmDone","beginAnimation","stop","reset","_releaseBuffers","releaseVertexBuffers","_targetIndex","getCustomEffect","_b","_customWrappers","_getCustomDrawWrapper","setCustomEffect","_engine","onBeforeDrawParticlesObservable","_onBeforeDrawParticlesObservable","vertexShaderName","vertexBuffers","_renderVertexBuffers","indexBuffer","addColorGradient","colorGradient","push","_refreshColorGradient","reorder","sort","a","b","_colorGradientsTexture","forceRefreshGradients","_refreshFactorGradient","removeColorGradient","resetDrawCache","_drawWrappers","drawContext","_addFactorGradient","factorGradients","factor","addSizeGradient","removeSizeGradient","_sizeGradientsTexture","textureName","that","addAngularSpeedGradient","removeAngularSpeedGradient","_angularSpeedGradientsTexture","addVelocityGradient","removeVelocityGradient","_velocityGradientsTexture","addLimitVelocityGradient","removeLimitVelocityGradient","_limitVelocityGradientsTexture","addDragGradient","removeDragGradient","_dragGradientsTexture","addEmitRateGradient","removeEmitRateGradient","addStartSizeGradient","removeStartSizeGradient","addColorRemapGradient","removeColorRemapGradient","addAlphaRemapGradient","removeAlphaRemapGradient","addRampGradient","removeRampGradient","getRampGradients","useRampGradients","addLifeTimeGradient","removeLifeTimeGradient","options","sceneOrEngine","customEffect","_accumulatedCount","_currentRenderId","_currentRenderingCameraUniqueId","_timeDelta","updateInAnimate","_actualFrame","_rawTextureWidth","onDisposeObservable","onStoppedObservable","isGPU","defaultProjectionMatrix","isNDCHalfZRange","uniqueId","getUniqueId","particleSystems","useInstancing","randomTextureSize","fullOptions","capacity","maxTextureSize","optionsAsNumber","isFinite","d","i","_randomTexture","Float32Array","wrapU","wrapV","_randomTexture2","_randomTextureSize","_createVertexBuffers","updateBuffer","renderBuffer","spriteSource","renderVertexBuffers","createVertexBuffer","_attributesStrideSize","offset","alignDataInBuffer","createVertexBuffers","_initialize","force","_buffer0","engine","data","Array","usingCustomEmitter","numDummies","spriteData","bufferData1","createParticleBuffer","bufferData2","_buffer1","_spriteBuffer","_sourceBuffer","_targetBuffer","_cachedUpdateDefines","_updateBuffer","createUpdateBuffer","customWrapper","fillDefines","drawWrapper","join","attributes","uniforms","samplers","fillUniformsAttributesAndSamplerNames","setEffect","createEffect","static","hasColorGradients","isBillboardStretched","attributeNamesOrOptions","effectCreationOption","prepareDefines","toString","_GetAttributeNamesOrOptions","_GetEffectCreationOptions","animate","preWarm","getAnimationRatio","_update","_createFactorGradientTexture","ratio","currentGradient","nextGradient","factor1","_createSizeGradientTexture","_createAngularSpeedGradientTexture","_createVelocityGradientTexture","_createLimitVelocityGradientTexture","_createDragGradientTexture","_createColorGradientTexture","Uint8Array","tmpColor","r","g","_render","emitterWM","enableEffect","viewMatrix","getViewMatrix","setMatrix","getProjectionMatrix","setTexture","setVector2","setDirectColor4","baseSize","getBaseSize","setFloat3","width","camera","activeCamera","globalPosition","indexOf","invView","invert","applyByPostProcess","bind","setAlphaMode","bindDrawBuffers","notifyObservers","drawArraysType","getWorldMatrix","emitterPosition","preUpdateParticleBuffer","setInt","setFloat4","updateParticleBuffer","tmpBuffer","render","forceUpdateOnly","getFrameId","intPart","outparticles","setState","setDepthWrite","rebuild","releaseBuffers","disposeTexture","rvb","key","clear","newEmitter","cloneTexture","custom","program","createEffectForParticles","shaderOptions","shaderPath","fragmentElement","serialization","result","Parse","serializeTexture","parsedParticleSystem","rootUrl","doNotStart","particleSystem","parent","_renderVAO","_updateVAO","_parent","_updateEffectOptions","uniformsNames","uniformBuffersNames","fallbacks","onCompiled","onError","indexParameters","maxSimultaneousLights","transformFeedbackVaryings","_updateEffect","_createUpdateVAO","recordVertexArrayObject","bindArrayBuffer","bindVertexArrayObject","targetBuffer","currentActiveCount","bindTransformFeedbackBuffer","getBuffer","setRasterizerState","beginTransformFeedback","endTransformFeedback","releaseVertexArrayObject","source","updateVertexBuffers","vao","_bufferComputeShader","_updateComputeShader","bindingsMapping","params","binding","particlesIn","particlesOut","randomTexture","randomTexture2","split","_simParamsComputeShader","setUniformBuffer","buffer","update","bindBuffers","setStorageBuffer","dispatch","ceil","ParticleHelper","useGPU","system","gpu","token","addPendingData","Promise","resolve","reject","removePendingData","BaseAssetsUrl","newData","JSON","systems","url","request","addEventListener","readyState","status","responseText","output","open","send","snippetId","CreateDefault","snippet","jsonPayload","SnippetUrl","replace","CreateFromSnippetAsync","ParseFromSnippetAsync","parsedData","container","individualParser","cache","fragmentName","attributesNamesOrOptions","allSamplers","vertex","concat","results","descendants","getDescendants","Particle","colorStep","age","angularSpeed","cellIndex","_attachedSubEmitters","_currentColor1","_currentColor2","_currentSize1","_currentSize2","_currentAngularSpeed1","_currentAngularSpeed2","_currentVelocity1","_currentVelocity2","_currentLimitVelocity1","_currentLimitVelocity2","_currentDrag1","_currentDrag2","_Count","_updateCellInfoFromSystem","updateCellIndex","offsetAge","changeSpeed","_randomCellOffset","dist","_initialEndSpriteCellID","_initialStartSpriteCellID","_initialSpriteCellLoop","_inheritParticleInfoToSubEmitter","subEmitter","emitterMesh","inheritDirection","temp","normalizeToRef","setDirection","inheritedVelocityAmount","_inheritedVelocityOffset","_inheritParticleInfoToSubEmitters","forEach","_currentColorGradient","_currentSizeGradient","_currentAngularSpeedGradient","_currentVelocityGradient","_currentLimitVelocityGradient","_currentDragGradient","copyTo","other","_initialDirection","remapData","_randomNoiseCoordinates1","_randomNoiseCoordinates2","ParticleSystem","onDispose","callback","_onDisposeObserver","remove","_useRampGradients","_resetEffect","particles","_particles","isAlive","_useInstancing","_vertexBuffers","_indexBuffer","epsilon","_emitterInverseWorldMatrix","_stockParticles","_newPartsExcess","_scaledColorStep","_colorDiff","_scaledDirection","_scaledGravity","_currentEmitRate1","_currentEmitRate2","_currentStartSize1","_currentStartSize2","_disposeEmitterOnDispose","recycleParticle","lastParticle","pop","_createParticle","_subEmitters","subEmitters","floor","_emitFromParticle","templateIndex","subSystem","_rootParticleSystem","activeSubSystems","_epsilon","vertexArrayObject","_vertexArrayObject","instancedArrays","_createIndexBuffer","noiseTextureData","updateFunction","noiseTextureSize","getSize","getContent","then","scaledUpdateSpeed","_scaledUpdateSpeed","previousAge","diff","getColorToRef","addInPlace","getFactor","directionScale","limitVelocity","scaleInPlace","drag","_emitterWorldMatrix","fetchedColorR","_fetchR","fetchedColorG","fetchedColorB","scaledForce","max","factor2","w","newGradient","_removeFactorGradient","factorGradient","_createRampGradientTexture","_rampGradientsTexture","_syncRampGradientTexture","rampGradient","drawWrappers","u","pixels","_vertexBuffer","_vertexBufferSize","BILLBOARDMODE_STRETCHED","BILLBOARDMODE_STRETCHED_LOCAL","vertexSize","_vertexData","dataOffset","positions","colors","cellIndexBuffer","directionBuffer","rampDataBuffer","offsets","indices","count","createIndexBuffer","_alive","_prepareSubEmitterInternalArray","_currentEmitRateGradient","_currentStartSizeGradient","computeWorldMatrix","noiseTextureAsProcedural","onGeneratedObservable","addOnce","stopSubEmitters","_stopSubEmitters","_appendParticleVertex","offsetX","offsetY","initialDirection","_removeFromRoot","newParticles","invertToRef","factorGradient1","factorGradient2","lifeTime1","lifeTime2","emitPower","step","BILLBOARDMODE_Y","BILLBOARDMODE_ALL","currentRenderPassId","_features","supportRenderPasses","preWarmOnly","rate","_toBeDisposed","_appendParticleVertices","updateDirectly","_rebuild","defaultViewMatrix","drawElementsType","unbindInstanceAttributes","_releaseBuffer","_activeParticleSystems","_Serialize","subs","cell","sub","emitterId","invertY","_invertY","colorGradients","serializedGradient","rampGradients","colorRemapGradients","colorRemapGradient","alphaRemapGradients","alphaRemapGradient","sizeGradients","sizeGradient","angularSpeedGradients","angularSpeedGradient","velocityGradients","velocityGradient","dragGradients","dragGradient","emitRateGradients","emitRateGradient","startSizeGradients","startSizeGradient","lifeTimeGradients","lifeTimeGradient","limitVelocityGradients","limitVelocityGradient","_c","internalClass","animationIndex","parsedAnimation","autoAnimate","autoAnimateFrom","autoAnimateTo","autoAnimateLoop","autoAnimateSpeed","emitterType","cellArray","_Parse","ParticleSystemSet","_emitterNodeIsOwned","emitterNode","_emitterNode","setEmitterAsSphere","_emitterCreationOptions","kind","diameter","segments","material","emissiveColor","PointColor","PointsCloudSystem","_positions32","_colors32","uvs","_uvs32","pointSize","nbParticles","counter","vars","_promises","_colors","_uvs","_updatable","_isVisibilityBoxLocked","_alwaysVisible","_groups","_groupCounter","_computeParticleColor","_computeParticleTexture","_computeParticleRotation","_computeBoundingBox","_isReady","_size","updatable","buildMeshAsync","all","_buildMesh","addPoints","vertexData","ec","applyToMesh","mat","disableLighting","pointsCloud","_addParticle","cp","_randomUnitVector","_getColorIndicesForCoord","pointsGroup","imageData","_groupImageData","colorIndices","greenIndex","blueIndex","alphaIndex","redForCoord","greenForCoord","blueForCoord","alphaForCoord","_setPointsColorOrUV","isVolume","colorFromTexture","hasTexture","range","updateFacetData","meshPos","meshInd","meshUV","meshCol","place","meshMatrix","isIdentity","slice","p","idxPoints","id0","id1","id2","v0X","v0Y","v0Z","v1X","v1Y","v1Z","v2X","v2Y","v2Z","vertex0","vertex1","vertex2","vec0","vec1","uv0X","uv0Y","uv1X","uv1Y","uv2X","uv2Y","uv0","uv1","uv2","uvec0","uvec1","col0X","col0Y","col0Z","col0A","col1X","col1Y","col1Z","col1A","col2X","col2Y","col2Z","col2A","col0","col1","col2","colvec0","colvec1","facetPoint","uvPoint","lamda","mu","colPoint","norm","tang","biNorm","facetPlaneVec","gap","distance","ray","pickInfo","deltaS","deltaV","hsvCol","statedColor","colPoint3","pointColors","_groupDensity","getFacetNormal","origin","hit","pickedPoint","_groupImgWidth","_groupImgHeight","round","toHSV","_colorFromTexture","textureList","getActiveTextures","setEnabled","n","_textureNb","finalize","dataPromise","readPixels","_calculateDensity","nbPoints","density","vec2","c","area","areas","surfaceArea","nbFacets","pointCount","pointsPerFacet","extraPoints","map","nb","pointFunction","addSurfacePoints","colorWith","colored","Random","isNaN","Color","UV","Stated","addVolumePoints","setParticles","end","beforeUpdateParticles","rotMatrix","colors32","positions32","uvs32","tempVectors","camAxisX","camAxisY","camAxisZ","minimum","setAll","Number","MAX_VALUE","maximum","isFacetDataEnabled","boundingInfo","pindex","cindex","uindex","updateParticle","particleRotationMatrix","particlePosition","particleGlobalPosition","parentRotationMatrix","parentGlobalPosition","rotatedY","rotatedX","rotatedZ","rotMatrixValues","pivotBackTranslation","tmpVertex","vertexX","vertexY","vertexZ","px","py","pz","minimizeInPlaceFromFloats","maximizeInPlaceFromFloats","updateVerticesData","reConstruct","_worldMatrix","buildBoundingInfo","afterUpdateParticles","_indices32","refreshVisibleSize","refreshBoundingInfo","setVisibilityBox","vis","isAlwaysVisible","val","alwaysSelectAsActiveMesh","computeParticleRotation","computeParticleColor","computeParticleTexture","computeBoundingBox","initParticles","SubEmitterType","SubEmitter","END","isVisible","_ParseParticleSystem","_physicsEngine","plugin","component","_getComponent","PhysicsEngineSceneComponent","_addComponent","getPluginVersion","_physicsTimeAccumulator","e","message","compound","parts","physicsImpostor","subTime","getSubTimeStep","onBeforePhysicsObservable","_step","onAfterPhysicsObservable","getDeterministicFrameTime","getTimeStep","register","disablePhysicsEngine","PhysicsRadialImpulseFalloff","PhysicsUpdraftMode","PhysicsUpdraftEvent","_origin","_options","_originTop","_originDirection","_cylinderPosition","_dataFetched","getPhysicsEngine","PhysicsUpdraftEventOptions","addToRef","updraftMode","Perpendicular","_tickCallback","_tick","_prepareCylinder","getData","cylinder","_cylinder","enable","call","registerBeforeRender","disable","unregisterBeforeRender","_getHitData","center","distanceFromOrigin","multiplier","strength","multiplyByFloats","contactPoint","_getBodyHitData","body","transformNode","bodyObject","_intersectsWithCylinder","getObjectCenter","_getImpostorHitData","impostor","mass","impostorObject","object","hitData","getImpostors","applyForce","getBodies","PhysicsVortexEvent","PhysicsVortexEventOptions","originOnPlane","originToImpostorDirection","absoluteDistanceFromOrigin","forceX","forceY","forceZ","directionToOrigin","centripetalForceThreshold","negate","centripetalForceMultiplier","updraftForceMultiplier","perpendicularDirection","centrifugalForceMultiplier","bodyCenter","impostorObjectCenter","Center","PhysicsRaycastResult","_hasHit","_hitDistance","_hitNormalWorld","_hitPointWorld","_rayFromWorld","_rayToWorld","hasHit","hitDistance","hitNormalWorld","hitPointWorld","rayFromWorld","rayToWorld","setHitData","setHitDistance","calculateHitDistance","from","to","AmmoJSPlugin","_useDeltaForWorldStep","ammoInjection","Ammo","overlappingPairCache","bjsAMMO","_timeStep","_fixedTimeStep","_maxSteps","_tmpQuaternion","_tmpContactCallbackResult","_tmpContactPoint","_tmpContactNormal","_tmpVec3","_tmpMatrix","isSupported","_collisionConfiguration","btSoftBodyRigidBodyCollisionConfiguration","_dispatcher","btCollisionDispatcher","_overlappingPairCache","btDbvtBroadphase","_solver","btSequentialImpulseConstraintSolver","_softBodySolver","btDefaultSoftBodySolver","world","btSoftRigidDynamicsWorld","_tmpAmmoConcreteContactResultCallback","ConcreteContactResultCallback","addSingleResult","worldPoint","wrapPointer","btManifoldPoint","getPositionWorldOnA","worldNormal","m_normalWorldOnB","_tmpContactImpulse","getAppliedImpulse","_tmpContactDistance","getDistance","_raycastResult","_tmpAmmoTransform","btTransform","setIdentity","_tmpAmmoQuaternion","btQuaternion","_tmpAmmoVectorA","btVector3","_tmpAmmoVectorB","_tmpAmmoVectorC","_tmpAmmoVectorD","setGravity","setValue","getWorldInfo","set_m_gravity","setTimeStep","timeStep","setFixedTimeStep","fixedTimeStep","setMaxSteps","maxSteps","_isImpostorInContact","contactTest","physicsBody","_isImpostorPairInContact","impostorA","impostorB","contactPairTest","_stepSimulation","stepSimulation","executeStep","delta","impostors","soft","beforeStep","mainImpostor","_afterSoftStep","afterStep","_onPhysicsCollideCallbacks","collideCallback","otherImpostor","otherImpostors","isActive","onCollide","point","impulse","normal","_ropeStep","_softbodyOrClothStep","bodyVertices","get_m_nodes","nbVertices","node","nodePositions","path","at","get_m_x","shape","getParam","_isFromLine","points","instance","normalDirection","vertexPositions","vertexNormals","nx","ny","nz","nodeNormals","get_m_n","vertex_data","normals","applyImpulse","activate","subtractInPlace","localTranslation","generatePhysicsBody","_pluginData","toDispose","removePhysicsBody","forceUpdate","isBodyInitRequired","colShape","_createShape","get_m_cfg","set_collisions","set_kDP","castObject","btCollisionObject","getCollisionShape","setMargin","setActivationState","_DISABLE_DEACTIVATION_FLAG","addSoftBody","setBodyPressure","setBodyStiffness","setBodyVelocityIterations","setBodyPositionIterations","localInertia","startTransform","calculateLocalInertia","setOrigin","setRotation","myMotionState","btDefaultMotionState","rbInfo","btRigidBodyConstructionInfo","btRigidBody","setCollisionFlags","getCollisionFlags","_KINEMATIC_FLAG","getChildShape","_DISABLE_COLLISION_FLAG","getAbsolutePosition","centerWorld","scaling","setDeltaPosition","mask","addRigidBody","setBodyRestitution","setBodyFriction","removeSoftBody","removeRigidBody","destroy","generateJoint","impostorJoint","mainBody","connectedBody","connectedImpostor","jointData","joint","mainPivot","connectedPivot","maxDistance","btPoint2PointConstraint","mainAxis","connectedAxis","btHingeConstraint","addConstraint","collision","physicsJoint","removeJoint","removeConstraint","_addMeshVerts","btTriangleMesh","topLevelObject","triangleCount","getChildMeshes","localMatrix","topLevelQuaternion","multiply","faceCount","triPoints","vec","addTriangle","_softVertexData","newPoints","newNorms","_createSoftbody","btCompoundShape","triNorms","softBody","btSoftBodyHelpers","CreateFromTriMesh","setX","setY","setZ","_createCloth","len","segs","CreatePatch","_createRope","reduce","accumulator","currentValue","pathVectors","fixedPoints","ropeBody","CreateRope","_createCustom","returnValue","onCreateCustomShape","_addHullVerts","btConvexHullShape","addPoint","ignoreChildren","impostorExtents","getObjectExtents","meshChildren","childrenAdded","childMesh","childImpostor","getPhysicsImpostor","parentMat","decompose","getOrigin","addChildShape","btSphereShape","radii","btMultiSphereShape","setLocalScaling","capRadius","btCapsuleShape","btCylinderShape","btBoxShape","onCreateCustomMeshImpostor","triMesh","btBvhTriangleMeshShape","onCreateCustomConvexHullImpostor","convexHull","setTransformationFromPhysicsBody","getMotionState","getWorldTransform","getRotation","toEulerAnglesToRef","setPhysicsBodyTransformation","newPosition","newRotation","trans","setWorldTransform","motionState","setLinearVelocity","linearVelocity","setAngularVelocity","angularVelocity","getLinearVelocity","getAngularVelocity","setBodyMass","setTotalMass","setMassProps","getBodyMass","getBodyFriction","friction","set_kDF","setFriction","getBodyRestitution","restitution","setRestitution","getBodyPressure","pressure","set_kPR","getBodyStiffness","stiffness","get_m_materials","set_m_kLST","getBodyVelocityIterations","velocityIterations","set_viterations","getBodyPositionIterations","positionIterations","set_piterations","appendAnchor","influence","noCollisionBetweenLinkedBodies","appendHook","sleepBody","forceActivationState","wakeUpBody","updateDistanceJoint","setMotor","speed","maxForce","enableAngularMotor","setLimit","syncMeshWithImpostor","getRadius","getBoxSizeToRef","extents","raycast","raycastToRef","_tmpAmmoVectorRCA","_tmpAmmoVectorRCB","rayCallback","ClosestRayResultCallback","rayTest","get_m_hitNormalWorld","get_m_hitPointWorld"],"sourceRoot":""}