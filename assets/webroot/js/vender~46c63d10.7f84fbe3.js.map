{"version":3,"file":"js/vender~46c63d10.7f84fbe3.js","mappings":"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T,EAAQyT,SAAWtlC,EAC7BqI,GAAK,EAAI1Q,KAAKmE,KAAK,IAAM,EAEzBypC,EAAc,EACf,EACDl9B,GACC,EACD,EACAA,EACA,GACC,GACAA,EACD,EACA,GACCA,EACD,EACA,GACC,GACAA,EACD,EACA,GACCA,EACD,GACC,EACDA,EACA,EACA,EACAA,EACAA,EACA,EACA,EACAA,EACA,GACC,GACAA,EACD,EACA,GACCA,EACD,GACC,GAGCm9B,EAAc,CAChB,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,GAAI,GAAI,GAAI,EAAG,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,EAAG,EAAG,EAAG,GAAI,GAAI,EAAG,GAAI,EAAG,EAAG,GAAI,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,GACxK,GAAI,EAAG,GAAI,GAAI,GAAI,EAAG,GAAI,EAAG,EAAG,GAG9BC,EAAsB,CACxB,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,GAEA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,IAGEC,EAAe,CACjB,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EAEA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GAgDEC,EAAS,CACX,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GAEExoC,EAAU,IAAIa,MACdd,EAAY,IAAIc,MAChB8zB,EAAU,IAAI9zB,MACd+zB,EAAM,IAAI/zB,MAChB,IAAI4nC,EAAiB,EAErB,MAAMC,EAAkB,IAAI7nC,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","sources":["webpack:///../../../node_modules/@babylonjs/core/Maths/math.axis.js","webpack:///../../../node_modules/@babylonjs/core/Maths/math.color.js","webpack:///../../../node_modules/@babylonjs/core/Maths/math.constants.js","webpack:///../../../node_modules/@babylonjs/core/Maths/math.frustum.js","webpack:///../../../node_modules/@babylonjs/core/Maths/math.functions.js","webpack:///../../../node_modules/@babylonjs/core/Maths/math.isovector.js","webpack:///../../../node_modules/@babylonjs/core/Maths/math.path.js","webpack:///../../../node_modules/@babylonjs/core/Maths/math.plane.js","webpack:///../../../node_modules/@babylonjs/core/Maths/math.scalar.js","webpack:///../../../node_modules/@babylonjs/core/Maths/math.size.js","webpack:///../../../node_modules/@babylonjs/core/Maths/math.vector.js","webpack:///../../../node_modules/@babylonjs/core/Maths/math.viewport.js","webpack:///../../../node_modules/@babylonjs/core/Maths/sphericalPolynomial.js","webpack:///../../../node_modules/@babylonjs/core/Meshes/Builders/boxBuilder.js","webpack:///../../../node_modules/@babylonjs/core/Meshes/Builders/capsuleBuilder.js","webpack:///../../../node_modules/@babylonjs/core/Meshes/Builders/cylinderBuilder.js","webpack:///../../../node_modules/@babylonjs/core/Meshes/Builders/decalBuilder.js","webpack:///../../../node_modules/@babylonjs/core/Meshes/Builders/discBuilder.js","webpack:///../../../node_modules/@babylonjs/core/Meshes/Builders/geodesicBuilder.js","webpack:///../../../node_modules/@babylonjs/core/Meshes/Builders/goldbergBuilder.js","webpack:///../../../node_modules/@babylonjs/core/Meshes/Builders/groundBuilder.js","webpack:///../../../node_modules/@babylonjs/core/Meshes/Builders/hemisphereBuilder.js","webpack:///../../../node_modules/@babylonjs/core/Meshes/Builders/icoSphereBuilder.js","webpack:///../../../node_modules/@babylonjs/core/Meshes/Builders/latheBuilder.js","webpack:///../../../node_modules/@babylonjs/core/Meshes/Builders/linesBuilder.js","webpack:///../../../node_modules/@babylonjs/core/Meshes/Builders/planeBuilder.js","webpack:///../../../node_modules/@babylonjs/core/Meshes/Builders/polygonBuilder.js","webpack:///../../../node_modules/@babylonjs/core/Meshes/Builders/polyhedronBuilder.js","webpack:///../../../node_modules/@babylonjs/core/Meshes/Builders/ribbonBuilder.js","webpack:///../../../node_modules/@babylonjs/core/Meshes/Builders/shapeBuilder.js","webpack:///../../../node_modules/@babylonjs/core/Meshes/Builders/sphereBuilder.js","webpack:///../../../node_modules/@babylonjs/core/Meshes/Builders/tiledBoxBuilder.js","webpack:///../../../node_modules/@babylonjs/core/Meshes/Builders/tiledPlaneBuilder.js","webpack:///../../../node_modules/@babylonjs/core/Meshes/Builders/torusBuilder.js","webpack:///../../../node_modules/@babylonjs/core/Meshes/Builders/torusKnotBuilder.js","webpack:///../../../node_modules/@babylonjs/core/Meshes/Builders/tubeBuilder.js","webpack:///../../../node_modules/@babylonjs/core/Meshes/Compression/dracoCompression.js","webpack:///../../../node_modules/@babylonjs/core/Meshes/Compression/meshoptCompression.js","webpack:///../../../node_modules/@babylonjs/core/Meshes/WebGL/webGLDataBuffer.js","webpack:///../../../node_modules/@babylonjs/core/Meshes/WebGPU/webgpuDataBuffer.js","webpack:///../../../node_modules/@babylonjs/core/Meshes/abstractMesh.js"],"sourcesContent":["import { Vector3 } from \"./math.vector.js\";\n/** Defines supported spaces */\nexport var Space;\n(function (Space) {\n    /** Local (object) space */\n    Space[Space[\"LOCAL\"] = 0] = \"LOCAL\";\n    /** World space */\n    Space[Space[\"WORLD\"] = 1] = \"WORLD\";\n    /** Bone space */\n    Space[Space[\"BONE\"] = 2] = \"BONE\";\n})(Space || (Space = {}));\n/** Defines the 3 main axes */\nexport class Axis {\n}\n/** X axis */\nAxis.X = new Vector3(1.0, 0.0, 0.0);\n/** Y axis */\nAxis.Y = new Vector3(0.0, 1.0, 0.0);\n/** Z axis */\nAxis.Z = new Vector3(0.0, 0.0, 1.0);\n/**\n * Defines cartesian components.\n */\nexport var Coordinate;\n(function (Coordinate) {\n    /** X axis */\n    Coordinate[Coordinate[\"X\"] = 0] = \"X\";\n    /** Y axis */\n    Coordinate[Coordinate[\"Y\"] = 1] = \"Y\";\n    /** Z axis */\n    Coordinate[Coordinate[\"Z\"] = 2] = \"Z\";\n})(Coordinate || (Coordinate = {}));\n//# sourceMappingURL=math.axis.js.map","import { Scalar } from \"./math.scalar.js\";\nimport { ToLinearSpace, ToGammaSpace } from \"./math.constants.js\";\nimport { ArrayTools } from \"../Misc/arrayTools.js\";\nimport { RegisterClass } from \"../Misc/typeStore.js\";\n/**\n * Class used to hold a RGB color\n */\nexport class Color3 {\n    /**\n     * Creates a new Color3 object from red, green, blue values, all between 0 and 1\n     * @param r defines the red component (between 0 and 1, default is 0)\n     * @param g defines the green component (between 0 and 1, default is 0)\n     * @param b defines the blue component (between 0 and 1, default is 0)\n     */\n    constructor(\n    /**\n     * Defines the red component (between 0 and 1, default is 0)\n     */\n    r = 0, \n    /**\n     * Defines the green component (between 0 and 1, default is 0)\n     */\n    g = 0, \n    /**\n     * Defines the blue component (between 0 and 1, default is 0)\n     */\n    b = 0) {\n        this.r = r;\n        this.g = g;\n        this.b = b;\n    }\n    /**\n     * Creates a string with the Color3 current values\n     * @returns the string representation of the Color3 object\n     */\n    toString() {\n        return \"{R: \" + this.r + \" G:\" + this.g + \" B:\" + this.b + \"}\";\n    }\n    /**\n     * Returns the string \"Color3\"\n     * @returns \"Color3\"\n     */\n    getClassName() {\n        return \"Color3\";\n    }\n    /**\n     * Compute the Color3 hash code\n     * @returns an unique number that can be used to hash Color3 objects\n     */\n    getHashCode() {\n        let hash = (this.r * 255) | 0;\n        hash = (hash * 397) ^ ((this.g * 255) | 0);\n        hash = (hash * 397) ^ ((this.b * 255) | 0);\n        return hash;\n    }\n    // Operators\n    /**\n     * Stores in the given array from the given starting index the red, green, blue values as successive elements\n     * @param array defines the array where to store the r,g,b components\n     * @param index defines an optional index in the target array to define where to start storing values\n     * @returns the current Color3 object\n     */\n    toArray(array, index = 0) {\n        array[index] = this.r;\n        array[index + 1] = this.g;\n        array[index + 2] = this.b;\n        return this;\n    }\n    /**\n     * Update the current color with values stored in an array from the starting index of the given array\n     * @param array defines the source array\n     * @param offset defines an offset in the source array\n     * @returns the current Color3 object\n     */\n    fromArray(array, offset = 0) {\n        Color3.FromArrayToRef(array, offset, this);\n        return this;\n    }\n    /**\n     * Returns a new Color4 object from the current Color3 and the given alpha\n     * @param alpha defines the alpha component on the new Color4 object (default is 1)\n     * @returns a new Color4 object\n     */\n    toColor4(alpha = 1) {\n        return new Color4(this.r, this.g, this.b, alpha);\n    }\n    /**\n     * Returns a new array populated with 3 numeric elements : red, green and blue values\n     * @returns the new array\n     */\n    asArray() {\n        return [this.r, this.g, this.b];\n    }\n    /**\n     * Returns the luminance value\n     * @returns a float value\n     */\n    toLuminance() {\n        return this.r * 0.3 + this.g * 0.59 + this.b * 0.11;\n    }\n    /**\n     * Multiply each Color3 rgb values by the given Color3 rgb values in a new Color3 object\n     * @param otherColor defines the second operand\n     * @returns the new Color3 object\n     */\n    multiply(otherColor) {\n        return new Color3(this.r * otherColor.r, this.g * otherColor.g, this.b * otherColor.b);\n    }\n    /**\n     * Multiply the rgb values of the Color3 and the given Color3 and stores the result in the object \"result\"\n     * @param otherColor defines the second operand\n     * @param result defines the Color3 object where to store the result\n     * @returns the current Color3\n     */\n    multiplyToRef(otherColor, result) {\n        result.r = this.r * otherColor.r;\n        result.g = this.g * otherColor.g;\n        result.b = this.b * otherColor.b;\n        return this;\n    }\n    /**\n     * Determines equality between Color3 objects\n     * @param otherColor defines the second operand\n     * @returns true if the rgb values are equal to the given ones\n     */\n    equals(otherColor) {\n        return otherColor && this.r === otherColor.r && this.g === otherColor.g && this.b === otherColor.b;\n    }\n    /**\n     * Determines equality between the current Color3 object and a set of r,b,g values\n     * @param r defines the red component to check\n     * @param g defines the green component to check\n     * @param b defines the blue component to check\n     * @returns true if the rgb values are equal to the given ones\n     */\n    equalsFloats(r, g, b) {\n        return this.r === r && this.g === g && this.b === b;\n    }\n    /**\n     * Creates a new Color3 with the current Color3 values multiplied by scale\n     * @param scale defines the scaling factor to apply\n     * @returns a new Color3 object\n     */\n    scale(scale) {\n        return new Color3(this.r * scale, this.g * scale, this.b * scale);\n    }\n    /**\n     * Multiplies the Color3 values by the float \"scale\"\n     * @param scale defines the scaling factor to apply\n     * @returns the current updated Color3\n     */\n    scaleInPlace(scale) {\n        this.r *= scale;\n        this.g *= scale;\n        this.b *= scale;\n        return this;\n    }\n    /**\n     * Multiplies the rgb values by scale and stores the result into \"result\"\n     * @param scale defines the scaling factor\n     * @param result defines the Color3 object where to store the result\n     * @returns the unmodified current Color3\n     */\n    scaleToRef(scale, result) {\n        result.r = this.r * scale;\n        result.g = this.g * scale;\n        result.b = this.b * scale;\n        return this;\n    }\n    /**\n     * Scale the current Color3 values by a factor and add the result to a given Color3\n     * @param scale defines the scale factor\n     * @param result defines color to store the result into\n     * @returns the unmodified current Color3\n     */\n    scaleAndAddToRef(scale, result) {\n        result.r += this.r * scale;\n        result.g += this.g * scale;\n        result.b += this.b * scale;\n        return this;\n    }\n    /**\n     * Clamps the rgb values by the min and max values and stores the result into \"result\"\n     * @param min defines minimum clamping value (default is 0)\n     * @param max defines maximum clamping value (default is 1)\n     * @param result defines color to store the result into\n     * @returns the original Color3\n     */\n    clampToRef(min = 0, max = 1, result) {\n        result.r = Scalar.Clamp(this.r, min, max);\n        result.g = Scalar.Clamp(this.g, min, max);\n        result.b = Scalar.Clamp(this.b, min, max);\n        return this;\n    }\n    /**\n     * Creates a new Color3 set with the added values of the current Color3 and of the given one\n     * @param otherColor defines the second operand\n     * @returns the new Color3\n     */\n    add(otherColor) {\n        return new Color3(this.r + otherColor.r, this.g + otherColor.g, this.b + otherColor.b);\n    }\n    /**\n     * Stores the result of the addition of the current Color3 and given one rgb values into \"result\"\n     * @param otherColor defines the second operand\n     * @param result defines Color3 object to store the result into\n     * @returns the unmodified current Color3\n     */\n    addToRef(otherColor, result) {\n        result.r = this.r + otherColor.r;\n        result.g = this.g + otherColor.g;\n        result.b = this.b + otherColor.b;\n        return this;\n    }\n    /**\n     * Returns a new Color3 set with the subtracted values of the given one from the current Color3\n     * @param otherColor defines the second operand\n     * @returns the new Color3\n     */\n    subtract(otherColor) {\n        return new Color3(this.r - otherColor.r, this.g - otherColor.g, this.b - otherColor.b);\n    }\n    /**\n     * Stores the result of the subtraction of given one from the current Color3 rgb values into \"result\"\n     * @param otherColor defines the second operand\n     * @param result defines Color3 object to store the result into\n     * @returns the unmodified current Color3\n     */\n    subtractToRef(otherColor, result) {\n        result.r = this.r - otherColor.r;\n        result.g = this.g - otherColor.g;\n        result.b = this.b - otherColor.b;\n        return this;\n    }\n    /**\n     * Copy the current object\n     * @returns a new Color3 copied the current one\n     */\n    clone() {\n        return new Color3(this.r, this.g, this.b);\n    }\n    /**\n     * Copies the rgb values from the source in the current Color3\n     * @param source defines the source Color3 object\n     * @returns the updated Color3 object\n     */\n    copyFrom(source) {\n        this.r = source.r;\n        this.g = source.g;\n        this.b = source.b;\n        return this;\n    }\n    /**\n     * Updates the Color3 rgb values from the given floats\n     * @param r defines the red component to read from\n     * @param g defines the green component to read from\n     * @param b defines the blue component to read from\n     * @returns the current Color3 object\n     */\n    copyFromFloats(r, g, b) {\n        this.r = r;\n        this.g = g;\n        this.b = b;\n        return this;\n    }\n    /**\n     * Updates the Color3 rgb values from the given floats\n     * @param r defines the red component to read from\n     * @param g defines the green component to read from\n     * @param b defines the blue component to read from\n     * @returns the current Color3 object\n     */\n    set(r, g, b) {\n        return this.copyFromFloats(r, g, b);\n    }\n    /**\n     * Compute the Color3 hexadecimal code as a string\n     * @returns a string containing the hexadecimal representation of the Color3 object\n     */\n    toHexString() {\n        const intR = Math.round(this.r * 255);\n        const intG = Math.round(this.g * 255);\n        const intB = Math.round(this.b * 255);\n        return \"#\" + Scalar.ToHex(intR) + Scalar.ToHex(intG) + Scalar.ToHex(intB);\n    }\n    /**\n     * Computes a new Color3 converted from the current one to linear space\n     * @returns a new Color3 object\n     */\n    toLinearSpace() {\n        const convertedColor = new Color3();\n        this.toLinearSpaceToRef(convertedColor);\n        return convertedColor;\n    }\n    /**\n     * Converts current color in rgb space to HSV values\n     * @returns a new color3 representing the HSV values\n     */\n    toHSV() {\n        const result = new Color3();\n        this.toHSVToRef(result);\n        return result;\n    }\n    /**\n     * Converts current color in rgb space to HSV values\n     * @param result defines the Color3 where to store the HSV values\n     */\n    toHSVToRef(result) {\n        const r = this.r;\n        const g = this.g;\n        const b = this.b;\n        const max = Math.max(r, g, b);\n        const min = Math.min(r, g, b);\n        let h = 0;\n        let s = 0;\n        const v = max;\n        const dm = max - min;\n        if (max !== 0) {\n            s = dm / max;\n        }\n        if (max != min) {\n            if (max == r) {\n                h = (g - b) / dm;\n                if (g < b) {\n                    h += 6;\n                }\n            }\n            else if (max == g) {\n                h = (b - r) / dm + 2;\n            }\n            else if (max == b) {\n                h = (r - g) / dm + 4;\n            }\n            h *= 60;\n        }\n        result.r = h;\n        result.g = s;\n        result.b = v;\n    }\n    /**\n     * Converts the Color3 values to linear space and stores the result in \"convertedColor\"\n     * @param convertedColor defines the Color3 object where to store the linear space version\n     * @returns the unmodified Color3\n     */\n    toLinearSpaceToRef(convertedColor) {\n        convertedColor.r = Math.pow(this.r, ToLinearSpace);\n        convertedColor.g = Math.pow(this.g, ToLinearSpace);\n        convertedColor.b = Math.pow(this.b, ToLinearSpace);\n        return this;\n    }\n    /**\n     * Computes a new Color3 converted from the current one to gamma space\n     * @returns a new Color3 object\n     */\n    toGammaSpace() {\n        const convertedColor = new Color3();\n        this.toGammaSpaceToRef(convertedColor);\n        return convertedColor;\n    }\n    /**\n     * Converts the Color3 values to gamma space and stores the result in \"convertedColor\"\n     * @param convertedColor defines the Color3 object where to store the gamma space version\n     * @returns the unmodified Color3\n     */\n    toGammaSpaceToRef(convertedColor) {\n        convertedColor.r = Math.pow(this.r, ToGammaSpace);\n        convertedColor.g = Math.pow(this.g, ToGammaSpace);\n        convertedColor.b = Math.pow(this.b, ToGammaSpace);\n        return this;\n    }\n    /**\n     * Converts Hue, saturation and value to a Color3 (RGB)\n     * @param hue defines the hue\n     * @param saturation defines the saturation\n     * @param value defines the value\n     * @param result defines the Color3 where to store the RGB values\n     */\n    static HSVtoRGBToRef(hue, saturation, value, result) {\n        const chroma = value * saturation;\n        const h = hue / 60;\n        const x = chroma * (1 - Math.abs((h % 2) - 1));\n        let r = 0;\n        let g = 0;\n        let b = 0;\n        if (h >= 0 && h <= 1) {\n            r = chroma;\n            g = x;\n        }\n        else if (h >= 1 && h <= 2) {\n            r = x;\n            g = chroma;\n        }\n        else if (h >= 2 && h <= 3) {\n            g = chroma;\n            b = x;\n        }\n        else if (h >= 3 && h <= 4) {\n            g = x;\n            b = chroma;\n        }\n        else if (h >= 4 && h <= 5) {\n            r = x;\n            b = chroma;\n        }\n        else if (h >= 5 && h <= 6) {\n            r = chroma;\n            b = x;\n        }\n        const m = value - chroma;\n        result.set(r + m, g + m, b + m);\n    }\n    /**\n     * Converts Hue, saturation and value to a new Color3 (RGB)\n     * @param hue defines the hue (value between 0 and 360)\n     * @param saturation defines the saturation (value between 0 and 1)\n     * @param value defines the value (value between 0 and 1)\n     * @returns a new Color3 object\n     */\n    static FromHSV(hue, saturation, value) {\n        const result = new Color3(0, 0, 0);\n        Color3.HSVtoRGBToRef(hue, saturation, value, result);\n        return result;\n    }\n    /**\n     * Creates a new Color3 from the string containing valid hexadecimal values\n     * @param hex defines a string containing valid hexadecimal values\n     * @returns a new Color3 object\n     */\n    static FromHexString(hex) {\n        if (hex.substring(0, 1) !== \"#\" || hex.length !== 7) {\n            return new Color3(0, 0, 0);\n        }\n        const r = parseInt(hex.substring(1, 3), 16);\n        const g = parseInt(hex.substring(3, 5), 16);\n        const b = parseInt(hex.substring(5, 7), 16);\n        return Color3.FromInts(r, g, b);\n    }\n    /**\n     * Creates a new Color3 from the starting index of the given array\n     * @param array defines the source array\n     * @param offset defines an offset in the source array\n     * @returns a new Color3 object\n     */\n    static FromArray(array, offset = 0) {\n        return new Color3(array[offset], array[offset + 1], array[offset + 2]);\n    }\n    /**\n     * Creates a new Color3 from the starting index element of the given array\n     * @param array defines the source array to read from\n     * @param offset defines the offset in the source array\n     * @param result defines the target Color3 object\n     */\n    static FromArrayToRef(array, offset = 0, result) {\n        result.r = array[offset];\n        result.g = array[offset + 1];\n        result.b = array[offset + 2];\n    }\n    /**\n     * Creates a new Color3 from integer values (< 256)\n     * @param r defines the red component to read from (value between 0 and 255)\n     * @param g defines the green component to read from (value between 0 and 255)\n     * @param b defines the blue component to read from (value between 0 and 255)\n     * @returns a new Color3 object\n     */\n    static FromInts(r, g, b) {\n        return new Color3(r / 255.0, g / 255.0, b / 255.0);\n    }\n    /**\n     * Creates a new Color3 with values linearly interpolated of \"amount\" between the start Color3 and the end Color3\n     * @param start defines the start Color3 value\n     * @param end defines the end Color3 value\n     * @param amount defines the gradient value between start and end\n     * @returns a new Color3 object\n     */\n    static Lerp(start, end, amount) {\n        const result = new Color3(0.0, 0.0, 0.0);\n        Color3.LerpToRef(start, end, amount, result);\n        return result;\n    }\n    /**\n     * Creates a new Color3 with values linearly interpolated of \"amount\" between the start Color3 and the end Color3\n     * @param left defines the start value\n     * @param right defines the end value\n     * @param amount defines the gradient factor\n     * @param result defines the Color3 object where to store the result\n     */\n    static LerpToRef(left, right, amount, result) {\n        result.r = left.r + (right.r - left.r) * amount;\n        result.g = left.g + (right.g - left.g) * amount;\n        result.b = left.b + (right.b - left.b) * amount;\n    }\n    /**\n     * Returns a new Color3 located for \"amount\" (float) on the Hermite interpolation spline defined by the vectors \"value1\", \"tangent1\", \"value2\", \"tangent2\"\n     * @param value1 defines the first control point\n     * @param tangent1 defines the first tangent Color3\n     * @param value2 defines the second control point\n     * @param tangent2 defines the second tangent Color3\n     * @param amount defines the amount on the interpolation spline (between 0 and 1)\n     * @returns the new Color3\n     */\n    static Hermite(value1, tangent1, value2, tangent2, amount) {\n        const squared = amount * amount;\n        const cubed = amount * squared;\n        const part1 = 2.0 * cubed - 3.0 * squared + 1.0;\n        const part2 = -2.0 * cubed + 3.0 * squared;\n        const part3 = cubed - 2.0 * squared + amount;\n        const part4 = cubed - squared;\n        const r = value1.r * part1 + value2.r * part2 + tangent1.r * part3 + tangent2.r * part4;\n        const g = value1.g * part1 + value2.g * part2 + tangent1.g * part3 + tangent2.g * part4;\n        const b = value1.b * part1 + value2.b * part2 + tangent1.b * part3 + tangent2.b * part4;\n        return new Color3(r, g, b);\n    }\n    /**\n     * Returns a new Color3 which is the 1st derivative of the Hermite spline defined by the colors \"value1\", \"value2\", \"tangent1\", \"tangent2\".\n     * @param value1 defines the first control point\n     * @param tangent1 defines the first tangent\n     * @param value2 defines the second control point\n     * @param tangent2 defines the second tangent\n     * @param time define where the derivative must be done\n     * @returns 1st derivative\n     */\n    static Hermite1stDerivative(value1, tangent1, value2, tangent2, time) {\n        const result = Color3.Black();\n        this.Hermite1stDerivativeToRef(value1, tangent1, value2, tangent2, time, result);\n        return result;\n    }\n    /**\n     * Returns a new Color3 which is the 1st derivative of the Hermite spline defined by the colors \"value1\", \"value2\", \"tangent1\", \"tangent2\".\n     * @param value1 defines the first control point\n     * @param tangent1 defines the first tangent\n     * @param value2 defines the second control point\n     * @param tangent2 defines the second tangent\n     * @param time define where the derivative must be done\n     * @param result define where to store the derivative\n     */\n    static Hermite1stDerivativeToRef(value1, tangent1, value2, tangent2, time, result) {\n        const t2 = time * time;\n        result.r = (t2 - time) * 6 * value1.r + (3 * t2 - 4 * time + 1) * tangent1.r + (-t2 + time) * 6 * value2.r + (3 * t2 - 2 * time) * tangent2.r;\n        result.g = (t2 - time) * 6 * value1.g + (3 * t2 - 4 * time + 1) * tangent1.g + (-t2 + time) * 6 * value2.g + (3 * t2 - 2 * time) * tangent2.g;\n        result.b = (t2 - time) * 6 * value1.b + (3 * t2 - 4 * time + 1) * tangent1.b + (-t2 + time) * 6 * value2.b + (3 * t2 - 2 * time) * tangent2.b;\n    }\n    /**\n     * Returns a Color3 value containing a red color\n     * @returns a new Color3 object\n     */\n    static Red() {\n        return new Color3(1, 0, 0);\n    }\n    /**\n     * Returns a Color3 value containing a green color\n     * @returns a new Color3 object\n     */\n    static Green() {\n        return new Color3(0, 1, 0);\n    }\n    /**\n     * Returns a Color3 value containing a blue color\n     * @returns a new Color3 object\n     */\n    static Blue() {\n        return new Color3(0, 0, 1);\n    }\n    /**\n     * Returns a Color3 value containing a black color\n     * @returns a new Color3 object\n     */\n    static Black() {\n        return new Color3(0, 0, 0);\n    }\n    /**\n     * Gets a Color3 value containing a black color that must not be updated\n     */\n    static get BlackReadOnly() {\n        return Color3._BlackReadOnly;\n    }\n    /**\n     * Returns a Color3 value containing a white color\n     * @returns a new Color3 object\n     */\n    static White() {\n        return new Color3(1, 1, 1);\n    }\n    /**\n     * Returns a Color3 value containing a purple color\n     * @returns a new Color3 object\n     */\n    static Purple() {\n        return new Color3(0.5, 0, 0.5);\n    }\n    /**\n     * Returns a Color3 value containing a magenta color\n     * @returns a new Color3 object\n     */\n    static Magenta() {\n        return new Color3(1, 0, 1);\n    }\n    /**\n     * Returns a Color3 value containing a yellow color\n     * @returns a new Color3 object\n     */\n    static Yellow() {\n        return new Color3(1, 1, 0);\n    }\n    /**\n     * Returns a Color3 value containing a gray color\n     * @returns a new Color3 object\n     */\n    static Gray() {\n        return new Color3(0.5, 0.5, 0.5);\n    }\n    /**\n     * Returns a Color3 value containing a teal color\n     * @returns a new Color3 object\n     */\n    static Teal() {\n        return new Color3(0, 1.0, 1.0);\n    }\n    /**\n     * Returns a Color3 value containing a random color\n     * @returns a new Color3 object\n     */\n    static Random() {\n        return new Color3(Math.random(), Math.random(), Math.random());\n    }\n}\n// Statics\nColor3._BlackReadOnly = Color3.Black();\n/**\n * Class used to hold a RBGA color\n */\nexport class Color4 {\n    /**\n     * Creates a new Color4 object from red, green, blue values, all between 0 and 1\n     * @param r defines the red component (between 0 and 1, default is 0)\n     * @param g defines the green component (between 0 and 1, default is 0)\n     * @param b defines the blue component (between 0 and 1, default is 0)\n     * @param a defines the alpha component (between 0 and 1, default is 1)\n     */\n    constructor(\n    /**\n     * Defines the red component (between 0 and 1, default is 0)\n     */\n    r = 0, \n    /**\n     * Defines the green component (between 0 and 1, default is 0)\n     */\n    g = 0, \n    /**\n     * Defines the blue component (between 0 and 1, default is 0)\n     */\n    b = 0, \n    /**\n     * Defines the alpha component (between 0 and 1, default is 1)\n     */\n    a = 1) {\n        this.r = r;\n        this.g = g;\n        this.b = b;\n        this.a = a;\n    }\n    // Operators\n    /**\n     * Adds in place the given Color4 values to the current Color4 object\n     * @param right defines the second operand\n     * @returns the current updated Color4 object\n     */\n    addInPlace(right) {\n        this.r += right.r;\n        this.g += right.g;\n        this.b += right.b;\n        this.a += right.a;\n        return this;\n    }\n    /**\n     * Creates a new array populated with 4 numeric elements : red, green, blue, alpha values\n     * @returns the new array\n     */\n    asArray() {\n        return [this.r, this.g, this.b, this.a];\n    }\n    /**\n     * Stores from the starting index in the given array the Color4 successive values\n     * @param array defines the array where to store the r,g,b components\n     * @param index defines an optional index in the target array to define where to start storing values\n     * @returns the current Color4 object\n     */\n    toArray(array, index = 0) {\n        array[index] = this.r;\n        array[index + 1] = this.g;\n        array[index + 2] = this.b;\n        array[index + 3] = this.a;\n        return this;\n    }\n    /**\n     * Update the current color with values stored in an array from the starting index of the given array\n     * @param array defines the source array\n     * @param offset defines an offset in the source array\n     * @returns the current Color4 object\n     */\n    fromArray(array, offset = 0) {\n        Color4.FromArrayToRef(array, offset, this);\n        return this;\n    }\n    /**\n     * Determines equality between Color4 objects\n     * @param otherColor defines the second operand\n     * @returns true if the rgba values are equal to the given ones\n     */\n    equals(otherColor) {\n        return otherColor && this.r === otherColor.r && this.g === otherColor.g && this.b === otherColor.b && this.a === otherColor.a;\n    }\n    /**\n     * Creates a new Color4 set with the added values of the current Color4 and of the given one\n     * @param right defines the second operand\n     * @returns a new Color4 object\n     */\n    add(right) {\n        return new Color4(this.r + right.r, this.g + right.g, this.b + right.b, this.a + right.a);\n    }\n    /**\n     * Creates a new Color4 set with the subtracted values of the given one from the current Color4\n     * @param right defines the second operand\n     * @returns a new Color4 object\n     */\n    subtract(right) {\n        return new Color4(this.r - right.r, this.g - right.g, this.b - right.b, this.a - right.a);\n    }\n    /**\n     * Subtracts the given ones from the current Color4 values and stores the results in \"result\"\n     * @param right defines the second operand\n     * @param result defines the Color4 object where to store the result\n     * @returns the current Color4 object\n     */\n    subtractToRef(right, result) {\n        result.r = this.r - right.r;\n        result.g = this.g - right.g;\n        result.b = this.b - right.b;\n        result.a = this.a - right.a;\n        return this;\n    }\n    /**\n     * Creates a new Color4 with the current Color4 values multiplied by scale\n     * @param scale defines the scaling factor to apply\n     * @returns a new Color4 object\n     */\n    scale(scale) {\n        return new Color4(this.r * scale, this.g * scale, this.b * scale, this.a * scale);\n    }\n    /**\n     * Multiplies the Color4 values by the float \"scale\"\n     * @param scale defines the scaling factor to apply\n     * @returns the current updated Color4\n     */\n    scaleInPlace(scale) {\n        this.r *= scale;\n        this.g *= scale;\n        this.b *= scale;\n        this.a *= scale;\n        return this;\n    }\n    /**\n     * Multiplies the current Color4 values by scale and stores the result in \"result\"\n     * @param scale defines the scaling factor to apply\n     * @param result defines the Color4 object where to store the result\n     * @returns the current unmodified Color4\n     */\n    scaleToRef(scale, result) {\n        result.r = this.r * scale;\n        result.g = this.g * scale;\n        result.b = this.b * scale;\n        result.a = this.a * scale;\n        return this;\n    }\n    /**\n     * Scale the current Color4 values by a factor and add the result to a given Color4\n     * @param scale defines the scale factor\n     * @param result defines the Color4 object where to store the result\n     * @returns the unmodified current Color4\n     */\n    scaleAndAddToRef(scale, result) {\n        result.r += this.r * scale;\n        result.g += this.g * scale;\n        result.b += this.b * scale;\n        result.a += this.a * scale;\n        return this;\n    }\n    /**\n     * Clamps the rgb values by the min and max values and stores the result into \"result\"\n     * @param min defines minimum clamping value (default is 0)\n     * @param max defines maximum clamping value (default is 1)\n     * @param result defines color to store the result into.\n     * @returns the current Color4\n     */\n    clampToRef(min = 0, max = 1, result) {\n        result.r = Scalar.Clamp(this.r, min, max);\n        result.g = Scalar.Clamp(this.g, min, max);\n        result.b = Scalar.Clamp(this.b, min, max);\n        result.a = Scalar.Clamp(this.a, min, max);\n        return this;\n    }\n    /**\n     * Multiply an Color4 value by another and return a new Color4 object\n     * @param color defines the Color4 value to multiply by\n     * @returns a new Color4 object\n     */\n    multiply(color) {\n        return new Color4(this.r * color.r, this.g * color.g, this.b * color.b, this.a * color.a);\n    }\n    /**\n     * Multiply a Color4 value by another and push the result in a reference value\n     * @param color defines the Color4 value to multiply by\n     * @param result defines the Color4 to fill the result in\n     * @returns the result Color4\n     */\n    multiplyToRef(color, result) {\n        result.r = this.r * color.r;\n        result.g = this.g * color.g;\n        result.b = this.b * color.b;\n        result.a = this.a * color.a;\n        return result;\n    }\n    /**\n     * Creates a string with the Color4 current values\n     * @returns the string representation of the Color4 object\n     */\n    toString() {\n        return \"{R: \" + this.r + \" G:\" + this.g + \" B:\" + this.b + \" A:\" + this.a + \"}\";\n    }\n    /**\n     * Returns the string \"Color4\"\n     * @returns \"Color4\"\n     */\n    getClassName() {\n        return \"Color4\";\n    }\n    /**\n     * Compute the Color4 hash code\n     * @returns an unique number that can be used to hash Color4 objects\n     */\n    getHashCode() {\n        let hash = (this.r * 255) | 0;\n        hash = (hash * 397) ^ ((this.g * 255) | 0);\n        hash = (hash * 397) ^ ((this.b * 255) | 0);\n        hash = (hash * 397) ^ ((this.a * 255) | 0);\n        return hash;\n    }\n    /**\n     * Creates a new Color4 copied from the current one\n     * @returns a new Color4 object\n     */\n    clone() {\n        return new Color4(this.r, this.g, this.b, this.a);\n    }\n    /**\n     * Copies the given Color4 values into the current one\n     * @param source defines the source Color4 object\n     * @returns the current updated Color4 object\n     */\n    copyFrom(source) {\n        this.r = source.r;\n        this.g = source.g;\n        this.b = source.b;\n        this.a = source.a;\n        return this;\n    }\n    /**\n     * Copies the given float values into the current one\n     * @param r defines the red component to read from\n     * @param g defines the green component to read from\n     * @param b defines the blue component to read from\n     * @param a defines the alpha component to read from\n     * @returns the current updated Color4 object\n     */\n    copyFromFloats(r, g, b, a) {\n        this.r = r;\n        this.g = g;\n        this.b = b;\n        this.a = a;\n        return this;\n    }\n    /**\n     * Copies the given float values into the current one\n     * @param r defines the red component to read from\n     * @param g defines the green component to read from\n     * @param b defines the blue component to read from\n     * @param a defines the alpha component to read from\n     * @returns the current updated Color4 object\n     */\n    set(r, g, b, a) {\n        return this.copyFromFloats(r, g, b, a);\n    }\n    /**\n     * Compute the Color4 hexadecimal code as a string\n     * @param returnAsColor3 defines if the string should only contains RGB values (off by default)\n     * @returns a string containing the hexadecimal representation of the Color4 object\n     */\n    toHexString(returnAsColor3 = false) {\n        const intR = Math.round(this.r * 255);\n        const intG = Math.round(this.g * 255);\n        const intB = Math.round(this.b * 255);\n        if (returnAsColor3) {\n            return \"#\" + Scalar.ToHex(intR) + Scalar.ToHex(intG) + Scalar.ToHex(intB);\n        }\n        const intA = Math.round(this.a * 255);\n        return \"#\" + Scalar.ToHex(intR) + Scalar.ToHex(intG) + Scalar.ToHex(intB) + Scalar.ToHex(intA);\n    }\n    /**\n     * Computes a new Color4 converted from the current one to linear space\n     * @returns a new Color4 object\n     */\n    toLinearSpace() {\n        const convertedColor = new Color4();\n        this.toLinearSpaceToRef(convertedColor);\n        return convertedColor;\n    }\n    /**\n     * Converts the Color4 values to linear space and stores the result in \"convertedColor\"\n     * @param convertedColor defines the Color4 object where to store the linear space version\n     * @returns the unmodified Color4\n     */\n    toLinearSpaceToRef(convertedColor) {\n        convertedColor.r = Math.pow(this.r, ToLinearSpace);\n        convertedColor.g = Math.pow(this.g, ToLinearSpace);\n        convertedColor.b = Math.pow(this.b, ToLinearSpace);\n        convertedColor.a = this.a;\n        return this;\n    }\n    /**\n     * Computes a new Color4 converted from the current one to gamma space\n     * @returns a new Color4 object\n     */\n    toGammaSpace() {\n        const convertedColor = new Color4();\n        this.toGammaSpaceToRef(convertedColor);\n        return convertedColor;\n    }\n    /**\n     * Converts the Color4 values to gamma space and stores the result in \"convertedColor\"\n     * @param convertedColor defines the Color4 object where to store the gamma space version\n     * @returns the unmodified Color4\n     */\n    toGammaSpaceToRef(convertedColor) {\n        convertedColor.r = Math.pow(this.r, ToGammaSpace);\n        convertedColor.g = Math.pow(this.g, ToGammaSpace);\n        convertedColor.b = Math.pow(this.b, ToGammaSpace);\n        convertedColor.a = this.a;\n        return this;\n    }\n    // Statics\n    /**\n     * Creates a new Color4 from the string containing valid hexadecimal values.\n     *\n     * A valid hex string is either in the format #RRGGBB or #RRGGBBAA.\n     *\n     * When a hex string without alpha is passed, the resulting Color4 has\n     * its alpha value set to 1.0.\n     *\n     * An invalid string results in a Color with all its channels set to 0.0,\n     * i.e. \"transparent black\".\n     *\n     * @param hex defines a string containing valid hexadecimal values\n     * @returns a new Color4 object\n     */\n    static FromHexString(hex) {\n        if (hex.substring(0, 1) !== \"#\" || (hex.length !== 9 && hex.length !== 7)) {\n            return new Color4(0.0, 0.0, 0.0, 0.0);\n        }\n        const r = parseInt(hex.substring(1, 3), 16);\n        const g = parseInt(hex.substring(3, 5), 16);\n        const b = parseInt(hex.substring(5, 7), 16);\n        const a = hex.length === 9 ? parseInt(hex.substring(7, 9), 16) : 255;\n        return Color4.FromInts(r, g, b, a);\n    }\n    /**\n     * Creates a new Color4 object set with the linearly interpolated values of \"amount\" between the left Color4 object and the right Color4 object\n     * @param left defines the start value\n     * @param right defines the end value\n     * @param amount defines the gradient factor\n     * @returns a new Color4 object\n     */\n    static Lerp(left, right, amount) {\n        const result = new Color4(0.0, 0.0, 0.0, 0.0);\n        Color4.LerpToRef(left, right, amount, result);\n        return result;\n    }\n    /**\n     * Set the given \"result\" with the linearly interpolated values of \"amount\" between the left Color4 object and the right Color4 object\n     * @param left defines the start value\n     * @param right defines the end value\n     * @param amount defines the gradient factor\n     * @param result defines the Color4 object where to store data\n     */\n    static LerpToRef(left, right, amount, result) {\n        result.r = left.r + (right.r - left.r) * amount;\n        result.g = left.g + (right.g - left.g) * amount;\n        result.b = left.b + (right.b - left.b) * amount;\n        result.a = left.a + (right.a - left.a) * amount;\n    }\n    /**\n     * Interpolate between two Color4 using Hermite interpolation\n     * @param value1 defines first Color4\n     * @param tangent1 defines the incoming tangent\n     * @param value2 defines second Color4\n     * @param tangent2 defines the outgoing tangent\n     * @param amount defines the target Color4\n     * @returns the new interpolated Color4\n     */\n    static Hermite(value1, tangent1, value2, tangent2, amount) {\n        const squared = amount * amount;\n        const cubed = amount * squared;\n        const part1 = 2.0 * cubed - 3.0 * squared + 1.0;\n        const part2 = -2.0 * cubed + 3.0 * squared;\n        const part3 = cubed - 2.0 * squared + amount;\n        const part4 = cubed - squared;\n        const r = value1.r * part1 + value2.r * part2 + tangent1.r * part3 + tangent2.r * part4;\n        const g = value1.g * part1 + value2.g * part2 + tangent1.g * part3 + tangent2.g * part4;\n        const b = value1.b * part1 + value2.b * part2 + tangent1.b * part3 + tangent2.b * part4;\n        const a = value1.a * part1 + value2.a * part2 + tangent1.a * part3 + tangent2.a * part4;\n        return new Color4(r, g, b, a);\n    }\n    /**\n     * Returns a new Color4 which is the 1st derivative of the Hermite spline defined by the colors \"value1\", \"value2\", \"tangent1\", \"tangent2\".\n     * @param value1 defines the first control point\n     * @param tangent1 defines the first tangent\n     * @param value2 defines the second control point\n     * @param tangent2 defines the second tangent\n     * @param time define where the derivative must be done\n     * @returns 1st derivative\n     */\n    static Hermite1stDerivative(value1, tangent1, value2, tangent2, time) {\n        const result = new Color4();\n        this.Hermite1stDerivativeToRef(value1, tangent1, value2, tangent2, time, result);\n        return result;\n    }\n    /**\n     * Update a Color4 with the 1st derivative of the Hermite spline defined by the colors \"value1\", \"value2\", \"tangent1\", \"tangent2\".\n     * @param value1 defines the first control point\n     * @param tangent1 defines the first tangent\n     * @param value2 defines the second control point\n     * @param tangent2 defines the second tangent\n     * @param time define where the derivative must be done\n     * @param result define where to store the derivative\n     */\n    static Hermite1stDerivativeToRef(value1, tangent1, value2, tangent2, time, result) {\n        const t2 = time * time;\n        result.r = (t2 - time) * 6 * value1.r + (3 * t2 - 4 * time + 1) * tangent1.r + (-t2 + time) * 6 * value2.r + (3 * t2 - 2 * time) * tangent2.r;\n        result.g = (t2 - time) * 6 * value1.g + (3 * t2 - 4 * time + 1) * tangent1.g + (-t2 + time) * 6 * value2.g + (3 * t2 - 2 * time) * tangent2.g;\n        result.b = (t2 - time) * 6 * value1.b + (3 * t2 - 4 * time + 1) * tangent1.b + (-t2 + time) * 6 * value2.b + (3 * t2 - 2 * time) * tangent2.b;\n        result.a = (t2 - time) * 6 * value1.a + (3 * t2 - 4 * time + 1) * tangent1.a + (-t2 + time) * 6 * value2.a + (3 * t2 - 2 * time) * tangent2.a;\n    }\n    /**\n     * Creates a new Color4 from a Color3 and an alpha value\n     * @param color3 defines the source Color3 to read from\n     * @param alpha defines the alpha component (1.0 by default)\n     * @returns a new Color4 object\n     */\n    static FromColor3(color3, alpha = 1.0) {\n        return new Color4(color3.r, color3.g, color3.b, alpha);\n    }\n    /**\n     * Creates a new Color4 from the starting index element of the given array\n     * @param array defines the source array to read from\n     * @param offset defines the offset in the source array\n     * @returns a new Color4 object\n     */\n    static FromArray(array, offset = 0) {\n        return new Color4(array[offset], array[offset + 1], array[offset + 2], array[offset + 3]);\n    }\n    /**\n     * Creates a new Color4 from the starting index element of the given array\n     * @param array defines the source array to read from\n     * @param offset defines the offset in the source array\n     * @param result defines the target Color4 object\n     */\n    static FromArrayToRef(array, offset = 0, result) {\n        result.r = array[offset];\n        result.g = array[offset + 1];\n        result.b = array[offset + 2];\n        result.a = array[offset + 3];\n    }\n    /**\n     * Creates a new Color3 from integer values (< 256)\n     * @param r defines the red component to read from (value between 0 and 255)\n     * @param g defines the green component to read from (value between 0 and 255)\n     * @param b defines the blue component to read from (value between 0 and 255)\n     * @param a defines the alpha component to read from (value between 0 and 255)\n     * @returns a new Color3 object\n     */\n    static FromInts(r, g, b, a) {\n        return new Color4(r / 255.0, g / 255.0, b / 255.0, a / 255.0);\n    }\n    /**\n     * Check the content of a given array and convert it to an array containing RGBA data\n     * If the original array was already containing count * 4 values then it is returned directly\n     * @param colors defines the array to check\n     * @param count defines the number of RGBA data to expect\n     * @returns an array containing count * 4 values (RGBA)\n     */\n    static CheckColors4(colors, count) {\n        // Check if color3 was used\n        if (colors.length === count * 3) {\n            const colors4 = [];\n            for (let index = 0; index < colors.length; index += 3) {\n                const newIndex = (index / 3) * 4;\n                colors4[newIndex] = colors[index];\n                colors4[newIndex + 1] = colors[index + 1];\n                colors4[newIndex + 2] = colors[index + 2];\n                colors4[newIndex + 3] = 1.0;\n            }\n            return colors4;\n        }\n        return colors;\n    }\n}\n/**\n * @internal\n */\nexport class TmpColors {\n}\nTmpColors.Color3 = ArrayTools.BuildArray(3, Color3.Black);\nTmpColors.Color4 = ArrayTools.BuildArray(3, () => new Color4(0, 0, 0, 0));\nRegisterClass(\"BABYLON.Color3\", Color3);\nRegisterClass(\"BABYLON.Color4\", Color4);\n//# sourceMappingURL=math.color.js.map","/**\n * Constant used to convert a value to gamma space\n * @ignorenaming\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport const ToGammaSpace = 1 / 2.2;\n/**\n * Constant used to convert a value to linear space\n * @ignorenaming\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport const ToLinearSpace = 2.2;\n/**\n * Constant Golden Ratio value in Babylon.js\n * @ignorenaming\n */\nexport const PHI = (1 + Math.sqrt(5)) / 2;\n/**\n * Constant used to define the minimal number value in Babylon.js\n * @ignorenaming\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nconst Epsilon = 0.001;\nexport { Epsilon };\n//# sourceMappingURL=math.constants.js.map","import { Plane } from \"./math.plane.js\";\n/**\n * Represents a camera frustum\n */\nexport class Frustum {\n    /**\n     * Gets the planes representing the frustum\n     * @param transform matrix to be applied to the returned planes\n     * @returns a new array of 6 Frustum planes computed by the given transformation matrix.\n     */\n    static GetPlanes(transform) {\n        const frustumPlanes = [];\n        for (let index = 0; index < 6; index++) {\n            frustumPlanes.push(new Plane(0.0, 0.0, 0.0, 0.0));\n        }\n        Frustum.GetPlanesToRef(transform, frustumPlanes);\n        return frustumPlanes;\n    }\n    /**\n     * Gets the near frustum plane transformed by the transform matrix\n     * @param transform transformation matrix to be applied to the resulting frustum plane\n     * @param frustumPlane the resulting frustum plane\n     */\n    static GetNearPlaneToRef(transform, frustumPlane) {\n        const m = transform.m;\n        frustumPlane.normal.x = m[3] + m[2];\n        frustumPlane.normal.y = m[7] + m[6];\n        frustumPlane.normal.z = m[11] + m[10];\n        frustumPlane.d = m[15] + m[14];\n        frustumPlane.normalize();\n    }\n    /**\n     * Gets the far frustum plane transformed by the transform matrix\n     * @param transform transformation matrix to be applied to the resulting frustum plane\n     * @param frustumPlane the resulting frustum plane\n     */\n    static GetFarPlaneToRef(transform, frustumPlane) {\n        const m = transform.m;\n        frustumPlane.normal.x = m[3] - m[2];\n        frustumPlane.normal.y = m[7] - m[6];\n        frustumPlane.normal.z = m[11] - m[10];\n        frustumPlane.d = m[15] - m[14];\n        frustumPlane.normalize();\n    }\n    /**\n     * Gets the left frustum plane transformed by the transform matrix\n     * @param transform transformation matrix to be applied to the resulting frustum plane\n     * @param frustumPlane the resulting frustum plane\n     */\n    static GetLeftPlaneToRef(transform, frustumPlane) {\n        const m = transform.m;\n        frustumPlane.normal.x = m[3] + m[0];\n        frustumPlane.normal.y = m[7] + m[4];\n        frustumPlane.normal.z = m[11] + m[8];\n        frustumPlane.d = m[15] + m[12];\n        frustumPlane.normalize();\n    }\n    /**\n     * Gets the right frustum plane transformed by the transform matrix\n     * @param transform transformation matrix to be applied to the resulting frustum plane\n     * @param frustumPlane the resulting frustum plane\n     */\n    static GetRightPlaneToRef(transform, frustumPlane) {\n        const m = transform.m;\n        frustumPlane.normal.x = m[3] - m[0];\n        frustumPlane.normal.y = m[7] - m[4];\n        frustumPlane.normal.z = m[11] - m[8];\n        frustumPlane.d = m[15] - m[12];\n        frustumPlane.normalize();\n    }\n    /**\n     * Gets the top frustum plane transformed by the transform matrix\n     * @param transform transformation matrix to be applied to the resulting frustum plane\n     * @param frustumPlane the resulting frustum plane\n     */\n    static GetTopPlaneToRef(transform, frustumPlane) {\n        const m = transform.m;\n        frustumPlane.normal.x = m[3] - m[1];\n        frustumPlane.normal.y = m[7] - m[5];\n        frustumPlane.normal.z = m[11] - m[9];\n        frustumPlane.d = m[15] - m[13];\n        frustumPlane.normalize();\n    }\n    /**\n     * Gets the bottom frustum plane transformed by the transform matrix\n     * @param transform transformation matrix to be applied to the resulting frustum plane\n     * @param frustumPlane the resulting frustum plane\n     */\n    static GetBottomPlaneToRef(transform, frustumPlane) {\n        const m = transform.m;\n        frustumPlane.normal.x = m[3] + m[1];\n        frustumPlane.normal.y = m[7] + m[5];\n        frustumPlane.normal.z = m[11] + m[9];\n        frustumPlane.d = m[15] + m[13];\n        frustumPlane.normalize();\n    }\n    /**\n     * Sets the given array \"frustumPlanes\" with the 6 Frustum planes computed by the given transformation matrix.\n     * @param transform transformation matrix to be applied to the resulting frustum planes\n     * @param frustumPlanes the resulting frustum planes\n     */\n    static GetPlanesToRef(transform, frustumPlanes) {\n        // Near\n        Frustum.GetNearPlaneToRef(transform, frustumPlanes[0]);\n        // Far\n        Frustum.GetFarPlaneToRef(transform, frustumPlanes[1]);\n        // Left\n        Frustum.GetLeftPlaneToRef(transform, frustumPlanes[2]);\n        // Right\n        Frustum.GetRightPlaneToRef(transform, frustumPlanes[3]);\n        // Top\n        Frustum.GetTopPlaneToRef(transform, frustumPlanes[4]);\n        // Bottom\n        Frustum.GetBottomPlaneToRef(transform, frustumPlanes[5]);\n    }\n}\n//# sourceMappingURL=math.frustum.js.map","import { __decorate } from \"../tslib.es6.js\";\nimport { Vector3 } from \"./math.vector.js\";\nimport { nativeOverride } from \"../Misc/decorators.js\";\n// This helper class is only here so we can apply the nativeOverride decorator to functions.\nclass MathHelpers {\n    static extractMinAndMaxIndexed(positions, indices, indexStart, indexCount, minimum, maximum) {\n        for (let index = indexStart; index < indexStart + indexCount; index++) {\n            const offset = indices[index] * 3;\n            const x = positions[offset];\n            const y = positions[offset + 1];\n            const z = positions[offset + 2];\n            minimum.minimizeInPlaceFromFloats(x, y, z);\n            maximum.maximizeInPlaceFromFloats(x, y, z);\n        }\n    }\n    static extractMinAndMax(positions, start, count, stride, minimum, maximum) {\n        for (let index = start, offset = start * stride; index < start + count; index++, offset += stride) {\n            const x = positions[offset];\n            const y = positions[offset + 1];\n            const z = positions[offset + 2];\n            minimum.minimizeInPlaceFromFloats(x, y, z);\n            maximum.maximizeInPlaceFromFloats(x, y, z);\n        }\n    }\n}\n__decorate([\n    nativeOverride.filter((...[positions, indices]) => !Array.isArray(positions) && !Array.isArray(indices))\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n], MathHelpers, \"extractMinAndMaxIndexed\", null);\n__decorate([\n    nativeOverride.filter((...[positions]) => !Array.isArray(positions))\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n], MathHelpers, \"extractMinAndMax\", null);\n/**\n * Extracts minimum and maximum values from a list of indexed positions\n * @param positions defines the positions to use\n * @param indices defines the indices to the positions\n * @param indexStart defines the start index\n * @param indexCount defines the end index\n * @param bias defines bias value to add to the result\n * @returns minimum and maximum values\n */\nexport function extractMinAndMaxIndexed(positions, indices, indexStart, indexCount, bias = null) {\n    const minimum = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\n    const maximum = new Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);\n    MathHelpers.extractMinAndMaxIndexed(positions, indices, indexStart, indexCount, minimum, maximum);\n    if (bias) {\n        minimum.x -= minimum.x * bias.x + bias.y;\n        minimum.y -= minimum.y * bias.x + bias.y;\n        minimum.z -= minimum.z * bias.x + bias.y;\n        maximum.x += maximum.x * bias.x + bias.y;\n        maximum.y += maximum.y * bias.x + bias.y;\n        maximum.z += maximum.z * bias.x + bias.y;\n    }\n    return {\n        minimum: minimum,\n        maximum: maximum,\n    };\n}\n/**\n * Extracts minimum and maximum values from a list of positions\n * @param positions defines the positions to use\n * @param start defines the start index in the positions array\n * @param count defines the number of positions to handle\n * @param bias defines bias value to add to the result\n * @param stride defines the stride size to use (distance between two positions in the positions array)\n * @returns minimum and maximum values\n */\nexport function extractMinAndMax(positions, start, count, bias = null, stride) {\n    const minimum = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\n    const maximum = new Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);\n    if (!stride) {\n        stride = 3;\n    }\n    MathHelpers.extractMinAndMax(positions, start, count, stride, minimum, maximum);\n    if (bias) {\n        minimum.x -= minimum.x * bias.x + bias.y;\n        minimum.y -= minimum.y * bias.x + bias.y;\n        minimum.z -= minimum.z * bias.x + bias.y;\n        maximum.x += maximum.x * bias.x + bias.y;\n        maximum.y += maximum.y * bias.x + bias.y;\n        maximum.z += maximum.z * bias.x + bias.y;\n    }\n    return {\n        minimum: minimum,\n        maximum: maximum,\n    };\n}\n//# sourceMappingURL=math.functions.js.map","import { Logger } from \"../Misc/logger.js\";\nimport { Vector3 } from \"./math.vector.js\";\n/**\n * Class representing an isovector a vector containing 2 INTEGER coordinates\n * x axis is horizontal\n * y axis is 60 deg counter clockwise from positive y axis\n * @internal\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport class _IsoVector {\n    /**\n     * Creates a new isovector from the given x and y coordinates\n     * @param x defines the first coordinate, must be an integer\n     * @param y defines the second coordinate, must be an integer\n     */\n    constructor(\n    /** defines the first coordinate */\n    x = 0, \n    /** defines the second coordinate */\n    y = 0) {\n        this.x = x;\n        this.y = y;\n        if (x !== Math.floor(x)) {\n            x === Math.floor(x);\n            Logger.Warn(\"x is not an integer, floor(x) used\");\n        }\n        if (y !== Math.floor(y)) {\n            y === Math.floor(y);\n            Logger.Warn(\"y is not an integer, floor(y) used\");\n        }\n    }\n    // Operators\n    /**\n     * Gets a new IsoVector copied from the IsoVector\n     * @returns a new IsoVector\n     */\n    clone() {\n        return new _IsoVector(this.x, this.y);\n    }\n    /**\n     * Rotates one IsoVector 60 degrees counter clockwise about another\n     * Please note that this is an in place operation\n     * @param other an IsoVector a center of rotation\n     * @returns the rotated IsoVector\n     */\n    rotate60About(other) {\n        //other IsoVector\n        const x = this.x;\n        this.x = other.x + other.y - this.y;\n        this.y = x + this.y - other.x;\n        return this;\n    }\n    /**\n     * Rotates one IsoVector 60 degrees clockwise about another\n     * Please note that this is an in place operation\n     * @param other an IsoVector as center of rotation\n     * @returns the rotated IsoVector\n     */\n    rotateNeg60About(other) {\n        const x = this.x;\n        this.x = x + this.y - other.y;\n        this.y = other.x + other.y - x;\n        return this;\n    }\n    /**\n     * For an equilateral triangle OAB with O at isovector (0, 0) and A at isovector (m, n)\n     * Rotates one IsoVector 120 degrees counter clockwise about the center of the triangle\n     * Please note that this is an in place operation\n     * @param m integer a measure a Primary triangle of order (m, n) m > n\n     * @param n >= 0 integer a measure for a Primary triangle of order (m, n)\n     * @returns the rotated IsoVector\n     */\n    rotate120(m, n) {\n        //m, n integers\n        if (m !== Math.floor(m)) {\n            m === Math.floor(m);\n            Logger.Warn(\"m not an integer only floor(m) used\");\n        }\n        if (n !== Math.floor(n)) {\n            n === Math.floor(n);\n            Logger.Warn(\"n not an integer only floor(n) used\");\n        }\n        const x = this.x;\n        this.x = m - x - this.y;\n        this.y = n + x;\n        return this;\n    }\n    /**\n     * For an equilateral triangle OAB with O at isovector (0, 0) and A at isovector (m, n)\n     * Rotates one IsoVector 120 degrees clockwise about the center of the triangle\n     * Please note that this is an in place operation\n     * @param m integer a measure a Primary triangle of order (m, n) m > n\n     * @param n >= 0 integer a measure for a Primary triangle of order (m, n)\n     * @returns the rotated IsoVector\n     */\n    rotateNeg120(m, n) {\n        //m, n integers\n        if (m !== Math.floor(m)) {\n            m === Math.floor(m);\n            Logger.Warn(\"m is not an integer, floor(m) used\");\n        }\n        if (n !== Math.floor(n)) {\n            n === Math.floor(n);\n            Logger.Warn(\"n is not an integer,   floor(n) used\");\n        }\n        const x = this.x;\n        this.x = this.y - n;\n        this.y = m + n - x - this.y;\n        return this;\n    }\n    /**\n     * Transforms an IsoVector to one in Cartesian 3D space based on an isovector\n     * @param origin an IsoVector\n     * @param isoGridSize\n     * @returns Point as a Vector3\n     */\n    toCartesianOrigin(origin, isoGridSize) {\n        const point = Vector3.Zero();\n        point.x = origin.x + 2 * this.x * isoGridSize + this.y * isoGridSize;\n        point.y = origin.y + Math.sqrt(3) * this.y * isoGridSize;\n        return point;\n    }\n    // Statics\n    /**\n     * Gets a new IsoVector(0, 0)\n     * @returns a new IsoVector\n     */\n    static Zero() {\n        return new _IsoVector(0, 0);\n    }\n}\n//# sourceMappingURL=math.isovector.js.map","import { Scalar } from \"./math.scalar.js\";\nimport { Vector2, Vector3, Quaternion, Matrix } from \"./math.vector.js\";\nimport { Epsilon } from \"./math.constants.js\";\n/**\n * Defines potential orientation for back face culling\n */\nexport var Orientation;\n(function (Orientation) {\n    /**\n     * Clockwise\n     */\n    Orientation[Orientation[\"CW\"] = 0] = \"CW\";\n    /** Counter clockwise */\n    Orientation[Orientation[\"CCW\"] = 1] = \"CCW\";\n})(Orientation || (Orientation = {}));\n/** Class used to represent a Bezier curve */\nexport class BezierCurve {\n    /**\n     * Returns the cubic Bezier interpolated value (float) at \"t\" (float) from the given x1, y1, x2, y2 floats\n     * @param t defines the time\n     * @param x1 defines the left coordinate on X axis\n     * @param y1 defines the left coordinate on Y axis\n     * @param x2 defines the right coordinate on X axis\n     * @param y2 defines the right coordinate on Y axis\n     * @returns the interpolated value\n     */\n    static Interpolate(t, x1, y1, x2, y2) {\n        // Extract X (which is equal to time here)\n        const f0 = 1 - 3 * x2 + 3 * x1;\n        const f1 = 3 * x2 - 6 * x1;\n        const f2 = 3 * x1;\n        let refinedT = t;\n        for (let i = 0; i < 5; i++) {\n            const refinedT2 = refinedT * refinedT;\n            const refinedT3 = refinedT2 * refinedT;\n            const x = f0 * refinedT3 + f1 * refinedT2 + f2 * refinedT;\n            const slope = 1.0 / (3.0 * f0 * refinedT2 + 2.0 * f1 * refinedT + f2);\n            refinedT -= (x - t) * slope;\n            refinedT = Math.min(1, Math.max(0, refinedT));\n        }\n        // Resolve cubic bezier for the given x\n        return 3 * Math.pow(1 - refinedT, 2) * refinedT * y1 + 3 * (1 - refinedT) * Math.pow(refinedT, 2) * y2 + Math.pow(refinedT, 3);\n    }\n}\n/**\n * Defines angle representation\n */\nexport class Angle {\n    /**\n     * Creates an Angle object of \"radians\" radians (float).\n     * @param radians the angle in radians\n     */\n    constructor(radians) {\n        this._radians = radians;\n        if (this._radians < 0.0) {\n            this._radians += 2.0 * Math.PI;\n        }\n    }\n    /**\n     * Get value in degrees\n     * @returns the Angle value in degrees (float)\n     */\n    degrees() {\n        return (this._radians * 180.0) / Math.PI;\n    }\n    /**\n     * Get value in radians\n     * @returns the Angle value in radians (float)\n     */\n    radians() {\n        return this._radians;\n    }\n    /**\n     * Gets a new Angle object valued with the gradient angle, in radians, of the line joining two points\n     * @param a defines first point as the origin\n     * @param b defines point\n     * @returns a new Angle\n     */\n    static BetweenTwoPoints(a, b) {\n        const delta = b.subtract(a);\n        const theta = Math.atan2(delta.y, delta.x);\n        return new Angle(theta);\n    }\n    /**\n     * Gets a new Angle object from the given float in radians\n     * @param radians defines the angle value in radians\n     * @returns a new Angle\n     */\n    static FromRadians(radians) {\n        return new Angle(radians);\n    }\n    /**\n     * Gets a new Angle object from the given float in degrees\n     * @param degrees defines the angle value in degrees\n     * @returns a new Angle\n     */\n    static FromDegrees(degrees) {\n        return new Angle((degrees * Math.PI) / 180.0);\n    }\n}\n/**\n * This represents an arc in a 2d space.\n */\nexport class Arc2 {\n    /**\n     * Creates an Arc object from the three given points : start, middle and end.\n     * @param startPoint Defines the start point of the arc\n     * @param midPoint Defines the middle point of the arc\n     * @param endPoint Defines the end point of the arc\n     */\n    constructor(\n    /** Defines the start point of the arc */\n    startPoint, \n    /** Defines the mid point of the arc */\n    midPoint, \n    /** Defines the end point of the arc */\n    endPoint) {\n        this.startPoint = startPoint;\n        this.midPoint = midPoint;\n        this.endPoint = endPoint;\n        const temp = Math.pow(midPoint.x, 2) + Math.pow(midPoint.y, 2);\n        const startToMid = (Math.pow(startPoint.x, 2) + Math.pow(startPoint.y, 2) - temp) / 2;\n        const midToEnd = (temp - Math.pow(endPoint.x, 2) - Math.pow(endPoint.y, 2)) / 2;\n        const det = (startPoint.x - midPoint.x) * (midPoint.y - endPoint.y) - (midPoint.x - endPoint.x) * (startPoint.y - midPoint.y);\n        this.centerPoint = new Vector2((startToMid * (midPoint.y - endPoint.y) - midToEnd * (startPoint.y - midPoint.y)) / det, ((startPoint.x - midPoint.x) * midToEnd - (midPoint.x - endPoint.x) * startToMid) / det);\n        this.radius = this.centerPoint.subtract(this.startPoint).length();\n        this.startAngle = Angle.BetweenTwoPoints(this.centerPoint, this.startPoint);\n        const a1 = this.startAngle.degrees();\n        let a2 = Angle.BetweenTwoPoints(this.centerPoint, this.midPoint).degrees();\n        let a3 = Angle.BetweenTwoPoints(this.centerPoint, this.endPoint).degrees();\n        // angles correction\n        if (a2 - a1 > +180.0) {\n            a2 -= 360.0;\n        }\n        if (a2 - a1 < -180.0) {\n            a2 += 360.0;\n        }\n        if (a3 - a2 > +180.0) {\n            a3 -= 360.0;\n        }\n        if (a3 - a2 < -180.0) {\n            a3 += 360.0;\n        }\n        this.orientation = a2 - a1 < 0 ? Orientation.CW : Orientation.CCW;\n        this.angle = Angle.FromDegrees(this.orientation === Orientation.CW ? a1 - a3 : a3 - a1);\n    }\n}\n/**\n * Represents a 2D path made up of multiple 2D points\n */\nexport class Path2 {\n    /**\n     * Creates a Path2 object from the starting 2D coordinates x and y.\n     * @param x the starting points x value\n     * @param y the starting points y value\n     */\n    constructor(x, y) {\n        this._points = new Array();\n        this._length = 0.0;\n        /**\n         * If the path start and end point are the same\n         */\n        this.closed = false;\n        this._points.push(new Vector2(x, y));\n    }\n    /**\n     * Adds a new segment until the given coordinates (x, y) to the current Path2.\n     * @param x the added points x value\n     * @param y the added points y value\n     * @returns the updated Path2.\n     */\n    addLineTo(x, y) {\n        if (this.closed) {\n            return this;\n        }\n        const newPoint = new Vector2(x, y);\n        const previousPoint = this._points[this._points.length - 1];\n        this._points.push(newPoint);\n        this._length += newPoint.subtract(previousPoint).length();\n        return this;\n    }\n    /**\n     * Adds _numberOfSegments_ segments according to the arc definition (middle point coordinates, end point coordinates, the arc start point being the current Path2 last point) to the current Path2.\n     * @param midX middle point x value\n     * @param midY middle point y value\n     * @param endX end point x value\n     * @param endY end point y value\n     * @param numberOfSegments (default: 36)\n     * @returns the updated Path2.\n     */\n    addArcTo(midX, midY, endX, endY, numberOfSegments = 36) {\n        if (this.closed) {\n            return this;\n        }\n        const startPoint = this._points[this._points.length - 1];\n        const midPoint = new Vector2(midX, midY);\n        const endPoint = new Vector2(endX, endY);\n        const arc = new Arc2(startPoint, midPoint, endPoint);\n        let increment = arc.angle.radians() / numberOfSegments;\n        if (arc.orientation === Orientation.CW) {\n            increment *= -1;\n        }\n        let currentAngle = arc.startAngle.radians() + increment;\n        for (let i = 0; i < numberOfSegments; i++) {\n            const x = Math.cos(currentAngle) * arc.radius + arc.centerPoint.x;\n            const y = Math.sin(currentAngle) * arc.radius + arc.centerPoint.y;\n            this.addLineTo(x, y);\n            currentAngle += increment;\n        }\n        return this;\n    }\n    /**\n     * Closes the Path2.\n     * @returns the Path2.\n     */\n    close() {\n        this.closed = true;\n        return this;\n    }\n    /**\n     * Gets the sum of the distance between each sequential point in the path\n     * @returns the Path2 total length (float).\n     */\n    length() {\n        let result = this._length;\n        if (this.closed) {\n            const lastPoint = this._points[this._points.length - 1];\n            const firstPoint = this._points[0];\n            result += firstPoint.subtract(lastPoint).length();\n        }\n        return result;\n    }\n    /**\n     * Gets the points which construct the path\n     * @returns the Path2 internal array of points.\n     */\n    getPoints() {\n        return this._points;\n    }\n    /**\n     * Retreives the point at the distance aways from the starting point\n     * @param normalizedLengthPosition the length along the path to retrieve the point from\n     * @returns a new Vector2 located at a percentage of the Path2 total length on this path.\n     */\n    getPointAtLengthPosition(normalizedLengthPosition) {\n        if (normalizedLengthPosition < 0 || normalizedLengthPosition > 1) {\n            return Vector2.Zero();\n        }\n        const lengthPosition = normalizedLengthPosition * this.length();\n        let previousOffset = 0;\n        for (let i = 0; i < this._points.length; i++) {\n            const j = (i + 1) % this._points.length;\n            const a = this._points[i];\n            const b = this._points[j];\n            const bToA = b.subtract(a);\n            const nextOffset = bToA.length() + previousOffset;\n            if (lengthPosition >= previousOffset && lengthPosition <= nextOffset) {\n                const dir = bToA.normalize();\n                const localOffset = lengthPosition - previousOffset;\n                return new Vector2(a.x + dir.x * localOffset, a.y + dir.y * localOffset);\n            }\n            previousOffset = nextOffset;\n        }\n        return Vector2.Zero();\n    }\n    /**\n     * Creates a new path starting from an x and y position\n     * @param x starting x value\n     * @param y starting y value\n     * @returns a new Path2 starting at the coordinates (x, y).\n     */\n    static StartingAt(x, y) {\n        return new Path2(x, y);\n    }\n}\n/**\n * Represents a 3D path made up of multiple 3D points\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/path3D\n */\nexport class Path3D {\n    /**\n     * new Path3D(path, normal, raw)\n     * Creates a Path3D. A Path3D is a logical math object, so not a mesh.\n     * please read the description in the tutorial : https://doc.babylonjs.com/features/featuresDeepDive/mesh/path3D\n     * @param path an array of Vector3, the curve axis of the Path3D\n     * @param firstNormal (options) Vector3, the first wanted normal to the curve. Ex (0, 1, 0) for a vertical normal.\n     * @param raw (optional, default false) : boolean, if true the returned Path3D isn't normalized. Useful to depict path acceleration or speed.\n     * @param alignTangentsWithPath (optional, default false) : boolean, if true the tangents will be aligned with the path.\n     */\n    constructor(\n    /**\n     * an array of Vector3, the curve axis of the Path3D\n     */\n    path, firstNormal = null, raw, alignTangentsWithPath = false) {\n        this.path = path;\n        this._curve = new Array();\n        this._distances = new Array();\n        this._tangents = new Array();\n        this._normals = new Array();\n        this._binormals = new Array();\n        // holds interpolated point data\n        this._pointAtData = {\n            id: 0,\n            point: Vector3.Zero(),\n            previousPointArrayIndex: 0,\n            position: 0,\n            subPosition: 0,\n            interpolateReady: false,\n            interpolationMatrix: Matrix.Identity(),\n        };\n        for (let p = 0; p < path.length; p++) {\n            this._curve[p] = path[p].clone(); // hard copy\n        }\n        this._raw = raw || false;\n        this._alignTangentsWithPath = alignTangentsWithPath;\n        this._compute(firstNormal, alignTangentsWithPath);\n    }\n    /**\n     * Returns the Path3D array of successive Vector3 designing its curve.\n     * @returns the Path3D array of successive Vector3 designing its curve.\n     */\n    getCurve() {\n        return this._curve;\n    }\n    /**\n     * Returns the Path3D array of successive Vector3 designing its curve.\n     * @returns the Path3D array of successive Vector3 designing its curve.\n     */\n    getPoints() {\n        return this._curve;\n    }\n    /**\n     * @returns the computed length (float) of the path.\n     */\n    length() {\n        return this._distances[this._distances.length - 1];\n    }\n    /**\n     * Returns an array populated with tangent vectors on each Path3D curve point.\n     * @returns an array populated with tangent vectors on each Path3D curve point.\n     */\n    getTangents() {\n        return this._tangents;\n    }\n    /**\n     * Returns an array populated with normal vectors on each Path3D curve point.\n     * @returns an array populated with normal vectors on each Path3D curve point.\n     */\n    getNormals() {\n        return this._normals;\n    }\n    /**\n     * Returns an array populated with binormal vectors on each Path3D curve point.\n     * @returns an array populated with binormal vectors on each Path3D curve point.\n     */\n    getBinormals() {\n        return this._binormals;\n    }\n    /**\n     * Returns an array populated with distances (float) of the i-th point from the first curve point.\n     * @returns an array populated with distances (float) of the i-th point from the first curve point.\n     */\n    getDistances() {\n        return this._distances;\n    }\n    /**\n     * Returns an interpolated point along this path\n     * @param position the position of the point along this path, from 0.0 to 1.0\n     * @returns a new Vector3 as the point\n     */\n    getPointAt(position) {\n        return this._updatePointAtData(position).point;\n    }\n    /**\n     * Returns the tangent vector of an interpolated Path3D curve point at the specified position along this path.\n     * @param position the position of the point along this path, from 0.0 to 1.0\n     * @param interpolated (optional, default false) : boolean, if true returns an interpolated tangent instead of the tangent of the previous path point.\n     * @returns a tangent vector corresponding to the interpolated Path3D curve point, if not interpolated, the tangent is taken from the precomputed tangents array.\n     */\n    getTangentAt(position, interpolated = false) {\n        this._updatePointAtData(position, interpolated);\n        return interpolated ? Vector3.TransformCoordinates(Vector3.Forward(), this._pointAtData.interpolationMatrix) : this._tangents[this._pointAtData.previousPointArrayIndex];\n    }\n    /**\n     * Returns the tangent vector of an interpolated Path3D curve point at the specified position along this path.\n     * @param position the position of the point along this path, from 0.0 to 1.0\n     * @param interpolated (optional, default false) : boolean, if true returns an interpolated normal instead of the normal of the previous path point.\n     * @returns a normal vector corresponding to the interpolated Path3D curve point, if not interpolated, the normal is taken from the precomputed normals array.\n     */\n    getNormalAt(position, interpolated = false) {\n        this._updatePointAtData(position, interpolated);\n        return interpolated ? Vector3.TransformCoordinates(Vector3.Right(), this._pointAtData.interpolationMatrix) : this._normals[this._pointAtData.previousPointArrayIndex];\n    }\n    /**\n     * Returns the binormal vector of an interpolated Path3D curve point at the specified position along this path.\n     * @param position the position of the point along this path, from 0.0 to 1.0\n     * @param interpolated (optional, default false) : boolean, if true returns an interpolated binormal instead of the binormal of the previous path point.\n     * @returns a binormal vector corresponding to the interpolated Path3D curve point, if not interpolated, the binormal is taken from the precomputed binormals array.\n     */\n    getBinormalAt(position, interpolated = false) {\n        this._updatePointAtData(position, interpolated);\n        return interpolated ? Vector3.TransformCoordinates(Vector3.UpReadOnly, this._pointAtData.interpolationMatrix) : this._binormals[this._pointAtData.previousPointArrayIndex];\n    }\n    /**\n     * Returns the distance (float) of an interpolated Path3D curve point at the specified position along this path.\n     * @param position the position of the point along this path, from 0.0 to 1.0\n     * @returns the distance of the interpolated Path3D curve point at the specified position along this path.\n     */\n    getDistanceAt(position) {\n        return this.length() * position;\n    }\n    /**\n     * Returns the array index of the previous point of an interpolated point along this path\n     * @param position the position of the point to interpolate along this path, from 0.0 to 1.0\n     * @returns the array index\n     */\n    getPreviousPointIndexAt(position) {\n        this._updatePointAtData(position);\n        return this._pointAtData.previousPointArrayIndex;\n    }\n    /**\n     * Returns the position of an interpolated point relative to the two path points it lies between, from 0.0 (point A) to 1.0 (point B)\n     * @param position the position of the point to interpolate along this path, from 0.0 to 1.0\n     * @returns the sub position\n     */\n    getSubPositionAt(position) {\n        this._updatePointAtData(position);\n        return this._pointAtData.subPosition;\n    }\n    /**\n     * Returns the position of the closest virtual point on this path to an arbitrary Vector3, from 0.0 to 1.0\n     * @param target the vector of which to get the closest position to\n     * @returns the position of the closest virtual point on this path to the target vector\n     */\n    getClosestPositionTo(target) {\n        let smallestDistance = Number.MAX_VALUE;\n        let closestPosition = 0.0;\n        for (let i = 0; i < this._curve.length - 1; i++) {\n            const point = this._curve[i + 0];\n            const tangent = this._curve[i + 1].subtract(point).normalize();\n            const subLength = this._distances[i + 1] - this._distances[i + 0];\n            const subPosition = Math.min((Math.max(Vector3.Dot(tangent, target.subtract(point).normalize()), 0.0) * Vector3.Distance(point, target)) / subLength, 1.0);\n            const distance = Vector3.Distance(point.add(tangent.scale(subPosition * subLength)), target);\n            if (distance < smallestDistance) {\n                smallestDistance = distance;\n                closestPosition = (this._distances[i + 0] + subLength * subPosition) / this.length();\n            }\n        }\n        return closestPosition;\n    }\n    /**\n     * Returns a sub path (slice) of this path\n     * @param start the position of the fist path point, from 0.0 to 1.0, or a negative value, which will get wrapped around from the end of the path to 0.0 to 1.0 values\n     * @param end the position of the last path point, from 0.0 to 1.0, or a negative value, which will get wrapped around from the end of the path to 0.0 to 1.0 values\n     * @returns a sub path (slice) of this path\n     */\n    slice(start = 0.0, end = 1.0) {\n        if (start < 0.0) {\n            start = 1 - ((start * -1.0) % 1.0);\n        }\n        if (end < 0.0) {\n            end = 1 - ((end * -1.0) % 1.0);\n        }\n        if (start > end) {\n            const _start = start;\n            start = end;\n            end = _start;\n        }\n        const curvePoints = this.getCurve();\n        const startPoint = this.getPointAt(start);\n        let startIndex = this.getPreviousPointIndexAt(start);\n        const endPoint = this.getPointAt(end);\n        const endIndex = this.getPreviousPointIndexAt(end) + 1;\n        const slicePoints = [];\n        if (start !== 0.0) {\n            startIndex++;\n            slicePoints.push(startPoint);\n        }\n        slicePoints.push(...curvePoints.slice(startIndex, endIndex));\n        if (end !== 1.0 || start === 1.0) {\n            slicePoints.push(endPoint);\n        }\n        return new Path3D(slicePoints, this.getNormalAt(start), this._raw, this._alignTangentsWithPath);\n    }\n    /**\n     * Forces the Path3D tangent, normal, binormal and distance recomputation.\n     * @param path path which all values are copied into the curves points\n     * @param firstNormal which should be projected onto the curve\n     * @param alignTangentsWithPath (optional, default false) : boolean, if true the tangents will be aligned with the path\n     * @returns the same object updated.\n     */\n    update(path, firstNormal = null, alignTangentsWithPath = false) {\n        for (let p = 0; p < path.length; p++) {\n            this._curve[p].x = path[p].x;\n            this._curve[p].y = path[p].y;\n            this._curve[p].z = path[p].z;\n        }\n        this._compute(firstNormal, alignTangentsWithPath);\n        return this;\n    }\n    // private function compute() : computes tangents, normals and binormals\n    _compute(firstNormal, alignTangentsWithPath = false) {\n        const l = this._curve.length;\n        if (l < 2) {\n            return;\n        }\n        // first and last tangents\n        this._tangents[0] = this._getFirstNonNullVector(0);\n        if (!this._raw) {\n            this._tangents[0].normalize();\n        }\n        this._tangents[l - 1] = this._curve[l - 1].subtract(this._curve[l - 2]);\n        if (!this._raw) {\n            this._tangents[l - 1].normalize();\n        }\n        // normals and binormals at first point : arbitrary vector with _normalVector()\n        const tg0 = this._tangents[0];\n        const pp0 = this._normalVector(tg0, firstNormal);\n        this._normals[0] = pp0;\n        if (!this._raw) {\n            this._normals[0].normalize();\n        }\n        this._binormals[0] = Vector3.Cross(tg0, this._normals[0]);\n        if (!this._raw) {\n            this._binormals[0].normalize();\n        }\n        this._distances[0] = 0.0;\n        // normals and binormals : next points\n        let prev; // previous vector (segment)\n        let cur; // current vector (segment)\n        let curTang; // current tangent\n        // previous normal\n        let prevNor; // previous normal\n        let prevBinor; // previous binormal\n        for (let i = 1; i < l; i++) {\n            // tangents\n            prev = this._getLastNonNullVector(i);\n            if (i < l - 1) {\n                cur = this._getFirstNonNullVector(i);\n                this._tangents[i] = alignTangentsWithPath ? cur : prev.add(cur);\n                this._tangents[i].normalize();\n            }\n            this._distances[i] = this._distances[i - 1] + this._curve[i].subtract(this._curve[i - 1]).length();\n            // normals and binormals\n            // http://www.cs.cmu.edu/afs/andrew/scs/cs/15-462/web/old/asst2camera.html\n            curTang = this._tangents[i];\n            prevBinor = this._binormals[i - 1];\n            this._normals[i] = Vector3.Cross(prevBinor, curTang);\n            if (!this._raw) {\n                if (this._normals[i].length() === 0) {\n                    prevNor = this._normals[i - 1];\n                    this._normals[i] = prevNor.clone();\n                }\n                else {\n                    this._normals[i].normalize();\n                }\n            }\n            this._binormals[i] = Vector3.Cross(curTang, this._normals[i]);\n            if (!this._raw) {\n                this._binormals[i].normalize();\n            }\n        }\n        this._pointAtData.id = NaN;\n    }\n    // private function getFirstNonNullVector(index)\n    // returns the first non null vector from index : curve[index + N].subtract(curve[index])\n    _getFirstNonNullVector(index) {\n        let i = 1;\n        let nNVector = this._curve[index + i].subtract(this._curve[index]);\n        while (nNVector.length() === 0 && index + i + 1 < this._curve.length) {\n            i++;\n            nNVector = this._curve[index + i].subtract(this._curve[index]);\n        }\n        return nNVector;\n    }\n    // private function getLastNonNullVector(index)\n    // returns the last non null vector from index : curve[index].subtract(curve[index - N])\n    _getLastNonNullVector(index) {\n        let i = 1;\n        let nLVector = this._curve[index].subtract(this._curve[index - i]);\n        while (nLVector.length() === 0 && index > i + 1) {\n            i++;\n            nLVector = this._curve[index].subtract(this._curve[index - i]);\n        }\n        return nLVector;\n    }\n    // private function normalVector(v0, vt, va) :\n    // returns an arbitrary point in the plane defined by the point v0 and the vector vt orthogonal to this plane\n    // if va is passed, it returns the va projection on the plane orthogonal to vt at the point v0\n    _normalVector(vt, va) {\n        let normal0;\n        let tgl = vt.length();\n        if (tgl === 0.0) {\n            tgl = 1.0;\n        }\n        if (va === undefined || va === null) {\n            let point;\n            if (!Scalar.WithinEpsilon(Math.abs(vt.y) / tgl, 1.0, Epsilon)) {\n                // search for a point in the plane\n                point = new Vector3(0.0, -1.0, 0.0);\n            }\n            else if (!Scalar.WithinEpsilon(Math.abs(vt.x) / tgl, 1.0, Epsilon)) {\n                point = new Vector3(1.0, 0.0, 0.0);\n            }\n            else if (!Scalar.WithinEpsilon(Math.abs(vt.z) / tgl, 1.0, Epsilon)) {\n                point = new Vector3(0.0, 0.0, 1.0);\n            }\n            else {\n                point = Vector3.Zero();\n            }\n            normal0 = Vector3.Cross(vt, point);\n        }\n        else {\n            normal0 = Vector3.Cross(vt, va);\n            Vector3.CrossToRef(normal0, vt, normal0);\n        }\n        normal0.normalize();\n        return normal0;\n    }\n    /**\n     * Updates the point at data for an interpolated point along this curve\n     * @param position the position of the point along this curve, from 0.0 to 1.0\n     * @param interpolateTNB\n     * @interpolateTNB whether to compute the interpolated tangent, normal and binormal\n     * @returns the (updated) point at data\n     */\n    _updatePointAtData(position, interpolateTNB = false) {\n        // set an id for caching the result\n        if (this._pointAtData.id === position) {\n            if (!this._pointAtData.interpolateReady) {\n                this._updateInterpolationMatrix();\n            }\n            return this._pointAtData;\n        }\n        else {\n            this._pointAtData.id = position;\n        }\n        const curvePoints = this.getPoints();\n        // clamp position between 0.0 and 1.0\n        if (position <= 0.0) {\n            return this._setPointAtData(0.0, 0.0, curvePoints[0], 0, interpolateTNB);\n        }\n        else if (position >= 1.0) {\n            return this._setPointAtData(1.0, 1.0, curvePoints[curvePoints.length - 1], curvePoints.length - 1, interpolateTNB);\n        }\n        let previousPoint = curvePoints[0];\n        let currentPoint;\n        let currentLength = 0.0;\n        const targetLength = position * this.length();\n        for (let i = 1; i < curvePoints.length; i++) {\n            currentPoint = curvePoints[i];\n            const distance = Vector3.Distance(previousPoint, currentPoint);\n            currentLength += distance;\n            if (currentLength === targetLength) {\n                return this._setPointAtData(position, 1.0, currentPoint, i, interpolateTNB);\n            }\n            else if (currentLength > targetLength) {\n                const toLength = currentLength - targetLength;\n                const diff = toLength / distance;\n                const dir = previousPoint.subtract(currentPoint);\n                const point = currentPoint.add(dir.scaleInPlace(diff));\n                return this._setPointAtData(position, 1 - diff, point, i - 1, interpolateTNB);\n            }\n            previousPoint = currentPoint;\n        }\n        return this._pointAtData;\n    }\n    /**\n     * Updates the point at data from the specified parameters\n     * @param position where along the path the interpolated point is, from 0.0 to 1.0\n     * @param subPosition\n     * @param point the interpolated point\n     * @param parentIndex the index of an existing curve point that is on, or else positionally the first behind, the interpolated point\n     * @param interpolateTNB\n     */\n    _setPointAtData(position, subPosition, point, parentIndex, interpolateTNB) {\n        this._pointAtData.point = point;\n        this._pointAtData.position = position;\n        this._pointAtData.subPosition = subPosition;\n        this._pointAtData.previousPointArrayIndex = parentIndex;\n        this._pointAtData.interpolateReady = interpolateTNB;\n        if (interpolateTNB) {\n            this._updateInterpolationMatrix();\n        }\n        return this._pointAtData;\n    }\n    /**\n     * Updates the point at interpolation matrix for the tangents, normals and binormals\n     */\n    _updateInterpolationMatrix() {\n        this._pointAtData.interpolationMatrix = Matrix.Identity();\n        const parentIndex = this._pointAtData.previousPointArrayIndex;\n        if (parentIndex !== this._tangents.length - 1) {\n            const index = parentIndex + 1;\n            const tangentFrom = this._tangents[parentIndex].clone();\n            const normalFrom = this._normals[parentIndex].clone();\n            const binormalFrom = this._binormals[parentIndex].clone();\n            const tangentTo = this._tangents[index].clone();\n            const normalTo = this._normals[index].clone();\n            const binormalTo = this._binormals[index].clone();\n            const quatFrom = Quaternion.RotationQuaternionFromAxis(normalFrom, binormalFrom, tangentFrom);\n            const quatTo = Quaternion.RotationQuaternionFromAxis(normalTo, binormalTo, tangentTo);\n            const quatAt = Quaternion.Slerp(quatFrom, quatTo, this._pointAtData.subPosition);\n            quatAt.toRotationMatrix(this._pointAtData.interpolationMatrix);\n        }\n    }\n}\n/**\n * A Curve3 object is a logical object, so not a mesh, to handle curves in the 3D geometric space.\n * A Curve3 is designed from a series of successive Vector3.\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/drawCurves\n */\nexport class Curve3 {\n    /**\n     * Returns a Curve3 object along a Quadratic Bezier curve : https://doc.babylonjs.com/features/featuresDeepDive/mesh/drawCurves#quadratic-bezier-curve\n     * @param v0 (Vector3) the origin point of the Quadratic Bezier\n     * @param v1 (Vector3) the control point\n     * @param v2 (Vector3) the end point of the Quadratic Bezier\n     * @param nbPoints (integer) the wanted number of points in the curve\n     * @returns the created Curve3\n     */\n    static CreateQuadraticBezier(v0, v1, v2, nbPoints) {\n        nbPoints = nbPoints > 2 ? nbPoints : 3;\n        const bez = new Array();\n        const equation = (t, val0, val1, val2) => {\n            const res = (1.0 - t) * (1.0 - t) * val0 + 2.0 * t * (1.0 - t) * val1 + t * t * val2;\n            return res;\n        };\n        for (let i = 0; i <= nbPoints; i++) {\n            bez.push(new Vector3(equation(i / nbPoints, v0.x, v1.x, v2.x), equation(i / nbPoints, v0.y, v1.y, v2.y), equation(i / nbPoints, v0.z, v1.z, v2.z)));\n        }\n        return new Curve3(bez);\n    }\n    /**\n     * Returns a Curve3 object along a Cubic Bezier curve : https://doc.babylonjs.com/features/featuresDeepDive/mesh/drawCurves#cubic-bezier-curve\n     * @param v0 (Vector3) the origin point of the Cubic Bezier\n     * @param v1 (Vector3) the first control point\n     * @param v2 (Vector3) the second control point\n     * @param v3 (Vector3) the end point of the Cubic Bezier\n     * @param nbPoints (integer) the wanted number of points in the curve\n     * @returns the created Curve3\n     */\n    static CreateCubicBezier(v0, v1, v2, v3, nbPoints) {\n        nbPoints = nbPoints > 3 ? nbPoints : 4;\n        const bez = new Array();\n        const equation = (t, val0, val1, val2, val3) => {\n            const res = (1.0 - t) * (1.0 - t) * (1.0 - t) * val0 + 3.0 * t * (1.0 - t) * (1.0 - t) * val1 + 3.0 * t * t * (1.0 - t) * val2 + t * t * t * val3;\n            return res;\n        };\n        for (let i = 0; i <= nbPoints; i++) {\n            bez.push(new Vector3(equation(i / nbPoints, v0.x, v1.x, v2.x, v3.x), equation(i / nbPoints, v0.y, v1.y, v2.y, v3.y), equation(i / nbPoints, v0.z, v1.z, v2.z, v3.z)));\n        }\n        return new Curve3(bez);\n    }\n    /**\n     * Returns a Curve3 object along a Hermite Spline curve : https://doc.babylonjs.com/features/featuresDeepDive/mesh/drawCurves#hermite-spline\n     * @param p1 (Vector3) the origin point of the Hermite Spline\n     * @param t1 (Vector3) the tangent vector at the origin point\n     * @param p2 (Vector3) the end point of the Hermite Spline\n     * @param t2 (Vector3) the tangent vector at the end point\n     * @param nSeg (integer) the number of curve segments or nSeg + 1 points in the array\n     * @returns the created Curve3\n     */\n    static CreateHermiteSpline(p1, t1, p2, t2, nSeg) {\n        const hermite = new Array();\n        const step = 1.0 / nSeg;\n        for (let i = 0; i <= nSeg; i++) {\n            hermite.push(Vector3.Hermite(p1, t1, p2, t2, i * step));\n        }\n        return new Curve3(hermite);\n    }\n    /**\n     * Returns a Curve3 object along a CatmullRom Spline curve :\n     * @param points (array of Vector3) the points the spline must pass through. At least, four points required\n     * @param nbPoints (integer) the wanted number of points between each curve control points\n     * @param closed (boolean) optional with default false, when true forms a closed loop from the points\n     * @returns the created Curve3\n     */\n    static CreateCatmullRomSpline(points, nbPoints, closed) {\n        const catmullRom = new Array();\n        const step = 1.0 / nbPoints;\n        let amount = 0.0;\n        if (closed) {\n            const pointsCount = points.length;\n            for (let i = 0; i < pointsCount; i++) {\n                amount = 0;\n                for (let c = 0; c < nbPoints; c++) {\n                    catmullRom.push(Vector3.CatmullRom(points[i % pointsCount], points[(i + 1) % pointsCount], points[(i + 2) % pointsCount], points[(i + 3) % pointsCount], amount));\n                    amount += step;\n                }\n            }\n            catmullRom.push(catmullRom[0]);\n        }\n        else {\n            const totalPoints = new Array();\n            totalPoints.push(points[0].clone());\n            Array.prototype.push.apply(totalPoints, points);\n            totalPoints.push(points[points.length - 1].clone());\n            let i = 0;\n            for (; i < totalPoints.length - 3; i++) {\n                amount = 0;\n                for (let c = 0; c < nbPoints; c++) {\n                    catmullRom.push(Vector3.CatmullRom(totalPoints[i], totalPoints[i + 1], totalPoints[i + 2], totalPoints[i + 3], amount));\n                    amount += step;\n                }\n            }\n            i--;\n            catmullRom.push(Vector3.CatmullRom(totalPoints[i], totalPoints[i + 1], totalPoints[i + 2], totalPoints[i + 3], amount));\n        }\n        return new Curve3(catmullRom);\n    }\n    /**\n     * Returns a Curve3 object along an arc through three vector3 points:\n     * The three points should not be colinear. When they are the Curve3 is empty.\n     * @param first (Vector3) the first point the arc must pass through.\n     * @param second (Vector3) the second point the arc must pass through.\n     * @param third (Vector3) the third point the arc must pass through.\n     * @param steps (number) the larger the number of steps the more detailed the arc.\n     * @param closed (boolean) optional with default false, when true forms the chord from the first and third point\n     * @param fullCircle Circle (boolean) optional with default false, when true forms the complete circle through the three points\n     * @returns the created Curve3\n     */\n    static ArcThru3Points(first, second, third, steps = 32, closed = false, fullCircle = false) {\n        const arc = new Array();\n        const vec1 = second.subtract(first);\n        const vec2 = third.subtract(second);\n        const vec3 = first.subtract(third);\n        const zAxis = Vector3.Cross(vec1, vec2);\n        const len4 = zAxis.length();\n        if (len4 < Math.pow(10, -8)) {\n            return new Curve3(arc); // colinear points arc is empty\n        }\n        const len1_sq = vec1.lengthSquared();\n        const len2_sq = vec2.lengthSquared();\n        const len3_sq = vec3.lengthSquared();\n        const len4_sq = zAxis.lengthSquared();\n        const len1 = vec1.length();\n        const len2 = vec2.length();\n        const len3 = vec3.length();\n        const radius = (0.5 * len1 * len2 * len3) / len4;\n        const dot1 = Vector3.Dot(vec1, vec3);\n        const dot2 = Vector3.Dot(vec1, vec2);\n        const dot3 = Vector3.Dot(vec2, vec3);\n        const a = (-0.5 * len2_sq * dot1) / len4_sq;\n        const b = (-0.5 * len3_sq * dot2) / len4_sq;\n        const c = (-0.5 * len1_sq * dot3) / len4_sq;\n        const center = first.scale(a).add(second.scale(b)).add(third.scale(c));\n        const radiusVec = first.subtract(center);\n        const xAxis = radiusVec.normalize();\n        const yAxis = Vector3.Cross(zAxis, xAxis).normalize();\n        if (fullCircle) {\n            const dStep = (2 * Math.PI) / steps;\n            for (let theta = 0; theta <= 2 * Math.PI; theta += dStep) {\n                arc.push(center.add(xAxis.scale(radius * Math.cos(theta)).add(yAxis.scale(radius * Math.sin(theta)))));\n            }\n            arc.push(first);\n        }\n        else {\n            const dStep = 1 / steps;\n            let theta = 0;\n            let point = Vector3.Zero();\n            do {\n                point = center.add(xAxis.scale(radius * Math.cos(theta)).add(yAxis.scale(radius * Math.sin(theta))));\n                arc.push(point);\n                theta += dStep;\n            } while (!point.equalsWithEpsilon(third, radius * dStep * 1.1));\n            arc.push(third);\n            if (closed) {\n                arc.push(first);\n            }\n        }\n        return new Curve3(arc);\n    }\n    /**\n     * A Curve3 object is a logical object, so not a mesh, to handle curves in the 3D geometric space.\n     * A Curve3 is designed from a series of successive Vector3.\n     * Tuto : https://doc.babylonjs.com/features/featuresDeepDive/mesh/drawCurves#curve3-object\n     * @param points points which make up the curve\n     */\n    constructor(points) {\n        this._length = 0.0;\n        this._points = points;\n        this._length = this._computeLength(points);\n    }\n    /**\n     * @returns the Curve3 stored array of successive Vector3\n     */\n    getPoints() {\n        return this._points;\n    }\n    /**\n     * @returns the computed length (float) of the curve.\n     */\n    length() {\n        return this._length;\n    }\n    /**\n     * Returns a new instance of Curve3 object : var curve = curveA.continue(curveB);\n     * This new Curve3 is built by translating and sticking the curveB at the end of the curveA.\n     * curveA and curveB keep unchanged.\n     * @param curve the curve to continue from this curve\n     * @returns the newly constructed curve\n     */\n    continue(curve) {\n        const lastPoint = this._points[this._points.length - 1];\n        const continuedPoints = this._points.slice();\n        const curvePoints = curve.getPoints();\n        for (let i = 1; i < curvePoints.length; i++) {\n            continuedPoints.push(curvePoints[i].subtract(curvePoints[0]).add(lastPoint));\n        }\n        const continuedCurve = new Curve3(continuedPoints);\n        return continuedCurve;\n    }\n    _computeLength(path) {\n        let l = 0;\n        for (let i = 1; i < path.length; i++) {\n            l += path[i].subtract(path[i - 1]).length();\n        }\n        return l;\n    }\n}\n//# sourceMappingURL=math.path.js.map","import { Vector3, Matrix } from \"./math.vector.js\";\n/**\n * Represents a plane by the equation ax + by + cz + d = 0\n */\nexport class Plane {\n    /**\n     * Creates a Plane object according to the given floats a, b, c, d and the plane equation : ax + by + cz + d = 0\n     * @param a a component of the plane\n     * @param b b component of the plane\n     * @param c c component of the plane\n     * @param d d component of the plane\n     */\n    constructor(a, b, c, d) {\n        this.normal = new Vector3(a, b, c);\n        this.d = d;\n    }\n    /**\n     * @returns the plane coordinates as a new array of 4 elements [a, b, c, d].\n     */\n    asArray() {\n        return [this.normal.x, this.normal.y, this.normal.z, this.d];\n    }\n    // Methods\n    /**\n     * @returns a new plane copied from the current Plane.\n     */\n    clone() {\n        return new Plane(this.normal.x, this.normal.y, this.normal.z, this.d);\n    }\n    /**\n     * @returns the string \"Plane\".\n     */\n    getClassName() {\n        return \"Plane\";\n    }\n    /**\n     * @returns the Plane hash code.\n     */\n    getHashCode() {\n        let hash = this.normal.getHashCode();\n        hash = (hash * 397) ^ (this.d | 0);\n        return hash;\n    }\n    /**\n     * Normalize the current Plane in place.\n     * @returns the updated Plane.\n     */\n    normalize() {\n        const norm = Math.sqrt(this.normal.x * this.normal.x + this.normal.y * this.normal.y + this.normal.z * this.normal.z);\n        let magnitude = 0.0;\n        if (norm !== 0) {\n            magnitude = 1.0 / norm;\n        }\n        this.normal.x *= magnitude;\n        this.normal.y *= magnitude;\n        this.normal.z *= magnitude;\n        this.d *= magnitude;\n        return this;\n    }\n    /**\n     * Applies a transformation the plane and returns the result\n     * @param transformation the transformation matrix to be applied to the plane\n     * @returns a new Plane as the result of the transformation of the current Plane by the given matrix.\n     */\n    transform(transformation) {\n        const invertedMatrix = Plane._TmpMatrix;\n        transformation.invertToRef(invertedMatrix);\n        const m = invertedMatrix.m;\n        const x = this.normal.x;\n        const y = this.normal.y;\n        const z = this.normal.z;\n        const d = this.d;\n        const normalX = x * m[0] + y * m[1] + z * m[2] + d * m[3];\n        const normalY = x * m[4] + y * m[5] + z * m[6] + d * m[7];\n        const normalZ = x * m[8] + y * m[9] + z * m[10] + d * m[11];\n        const finalD = x * m[12] + y * m[13] + z * m[14] + d * m[15];\n        return new Plane(normalX, normalY, normalZ, finalD);\n    }\n    /**\n     * Compute the dot product between the point and the plane normal\n     * @param point point to calculate the dot product with\n     * @returns the dot product (float) of the point coordinates and the plane normal.\n     */\n    dotCoordinate(point) {\n        return this.normal.x * point.x + this.normal.y * point.y + this.normal.z * point.z + this.d;\n    }\n    /**\n     * Updates the current Plane from the plane defined by the three given points.\n     * @param point1 one of the points used to construct the plane\n     * @param point2 one of the points used to construct the plane\n     * @param point3 one of the points used to construct the plane\n     * @returns the updated Plane.\n     */\n    copyFromPoints(point1, point2, point3) {\n        const x1 = point2.x - point1.x;\n        const y1 = point2.y - point1.y;\n        const z1 = point2.z - point1.z;\n        const x2 = point3.x - point1.x;\n        const y2 = point3.y - point1.y;\n        const z2 = point3.z - point1.z;\n        const yz = y1 * z2 - z1 * y2;\n        const xz = z1 * x2 - x1 * z2;\n        const xy = x1 * y2 - y1 * x2;\n        const pyth = Math.sqrt(yz * yz + xz * xz + xy * xy);\n        let invPyth;\n        if (pyth !== 0) {\n            invPyth = 1.0 / pyth;\n        }\n        else {\n            invPyth = 0.0;\n        }\n        this.normal.x = yz * invPyth;\n        this.normal.y = xz * invPyth;\n        this.normal.z = xy * invPyth;\n        this.d = -(this.normal.x * point1.x + this.normal.y * point1.y + this.normal.z * point1.z);\n        return this;\n    }\n    /**\n     * Checks if the plane is facing a given direction (meaning if the plane's normal is pointing in the opposite direction of the given vector).\n     * Note that for this function to work as expected you should make sure that:\n     *   - direction and the plane normal are normalized\n     *   - epsilon is a number just bigger than -1, something like -0.99 for eg\n     * @param direction the direction to check if the plane is facing\n     * @param epsilon value the dot product is compared against (returns true if dot <= epsilon)\n     * @returns True if the plane is facing the given direction\n     */\n    isFrontFacingTo(direction, epsilon) {\n        const dot = Vector3.Dot(this.normal, direction);\n        return dot <= epsilon;\n    }\n    /**\n     * Calculates the distance to a point\n     * @param point point to calculate distance to\n     * @returns the signed distance (float) from the given point to the Plane.\n     */\n    signedDistanceTo(point) {\n        return Vector3.Dot(point, this.normal) + this.d;\n    }\n    // Statics\n    /**\n     * Creates a plane from an  array\n     * @param array the array to create a plane from\n     * @returns a new Plane from the given array.\n     */\n    static FromArray(array) {\n        return new Plane(array[0], array[1], array[2], array[3]);\n    }\n    /**\n     * Creates a plane from three points\n     * @param point1 point used to create the plane\n     * @param point2 point used to create the plane\n     * @param point3 point used to create the plane\n     * @returns a new Plane defined by the three given points.\n     */\n    static FromPoints(point1, point2, point3) {\n        const result = new Plane(0.0, 0.0, 0.0, 0.0);\n        result.copyFromPoints(point1, point2, point3);\n        return result;\n    }\n    /**\n     * Creates a plane from an origin point and a normal\n     * @param origin origin of the plane to be constructed\n     * @param normal normal of the plane to be constructed\n     * @returns a new Plane the normal vector to this plane at the given origin point.\n     * Note : the vector \"normal\" is updated because normalized.\n     */\n    static FromPositionAndNormal(origin, normal) {\n        const result = new Plane(0.0, 0.0, 0.0, 0.0);\n        normal.normalize();\n        result.normal = normal;\n        result.d = -(normal.x * origin.x + normal.y * origin.y + normal.z * origin.z);\n        return result;\n    }\n    /**\n     * Calculates the distance from a plane and a point\n     * @param origin origin of the plane to be constructed\n     * @param normal normal of the plane to be constructed\n     * @param point point to calculate distance to\n     * @returns the signed distance between the plane defined by the normal vector at the \"origin\"\" point and the given other point.\n     */\n    static SignedDistanceToPlaneFromPositionAndNormal(origin, normal, point) {\n        const d = -(normal.x * origin.x + normal.y * origin.y + normal.z * origin.z);\n        return Vector3.Dot(point, normal) + d;\n    }\n}\nPlane._TmpMatrix = Matrix.Identity();\n//# sourceMappingURL=math.plane.js.map","/**\n * Scalar computation library\n */\nexport class Scalar {\n    /**\n     * Boolean : true if the absolute difference between a and b is lower than epsilon (default = 1.401298E-45)\n     * @param a number\n     * @param b number\n     * @param epsilon (default = 1.401298E-45)\n     * @returns true if the absolute difference between a and b is lower than epsilon (default = 1.401298E-45)\n     */\n    static WithinEpsilon(a, b, epsilon = 1.401298e-45) {\n        return Math.abs(a - b) <= epsilon;\n    }\n    /**\n     * Returns a string : the upper case translation of the number i to hexadecimal.\n     * @param i number\n     * @returns the upper case translation of the number i to hexadecimal.\n     */\n    static ToHex(i) {\n        const str = i.toString(16);\n        if (i <= 15) {\n            return (\"0\" + str).toUpperCase();\n        }\n        return str.toUpperCase();\n    }\n    /**\n     * Returns -1 if value is negative and +1 is value is positive.\n     * @param value the value\n     * @returns the value itself if it's equal to zero.\n     */\n    static Sign(value) {\n        value = +value; // convert to a number\n        if (value === 0 || isNaN(value)) {\n            return value;\n        }\n        return value > 0 ? 1 : -1;\n    }\n    /**\n     * Returns the value itself if it's between min and max.\n     * Returns min if the value is lower than min.\n     * Returns max if the value is greater than max.\n     * @param value the value to clmap\n     * @param min the min value to clamp to (default: 0)\n     * @param max the max value to clamp to (default: 1)\n     * @returns the clamped value\n     */\n    static Clamp(value, min = 0, max = 1) {\n        return Math.min(max, Math.max(min, value));\n    }\n    /**\n     * the log2 of value.\n     * @param value the value to compute log2 of\n     * @returns the log2 of value.\n     */\n    static Log2(value) {\n        return Math.log(value) * Math.LOG2E;\n    }\n    /**\n     * the floor part of a log2 value.\n     * @param value the value to compute log2 of\n     * @returns the log2 of value.\n     */\n    static ILog2(value) {\n        if (Math.log2) {\n            return Math.floor(Math.log2(value));\n        }\n        if (value < 0) {\n            return NaN;\n        }\n        else if (value === 0) {\n            return -Infinity;\n        }\n        let n = 0;\n        if (value < 1) {\n            while (value < 1) {\n                n++;\n                value = value * 2;\n            }\n            n = -n;\n        }\n        else if (value > 1) {\n            while (value > 1) {\n                n++;\n                value = Math.floor(value / 2);\n            }\n        }\n        return n;\n    }\n    /**\n     * Loops the value, so that it is never larger than length and never smaller than 0.\n     *\n     * This is similar to the modulo operator but it works with floating point numbers.\n     * For example, using 3.0 for t and 2.5 for length, the result would be 0.5.\n     * With t = 5 and length = 2.5, the result would be 0.0.\n     * Note, however, that the behaviour is not defined for negative numbers as it is for the modulo operator\n     * @param value the value\n     * @param length the length\n     * @returns the looped value\n     */\n    static Repeat(value, length) {\n        return value - Math.floor(value / length) * length;\n    }\n    /**\n     * Normalize the value between 0.0 and 1.0 using min and max values\n     * @param value value to normalize\n     * @param min max to normalize between\n     * @param max min to normalize between\n     * @returns the normalized value\n     */\n    static Normalize(value, min, max) {\n        return (value - min) / (max - min);\n    }\n    /**\n     * Denormalize the value from 0.0 and 1.0 using min and max values\n     * @param normalized value to denormalize\n     * @param min max to denormalize between\n     * @param max min to denormalize between\n     * @returns the denormalized value\n     */\n    static Denormalize(normalized, min, max) {\n        return normalized * (max - min) + min;\n    }\n    /**\n     * Calculates the shortest difference between two given angles given in degrees.\n     * @param current current angle in degrees\n     * @param target target angle in degrees\n     * @returns the delta\n     */\n    static DeltaAngle(current, target) {\n        let num = Scalar.Repeat(target - current, 360.0);\n        if (num > 180.0) {\n            num -= 360.0;\n        }\n        return num;\n    }\n    /**\n     * PingPongs the value t, so that it is never larger than length and never smaller than 0.\n     * @param tx value\n     * @param length length\n     * @returns The returned value will move back and forth between 0 and length\n     */\n    static PingPong(tx, length) {\n        const t = Scalar.Repeat(tx, length * 2.0);\n        return length - Math.abs(t - length);\n    }\n    /**\n     * Interpolates between min and max with smoothing at the limits.\n     *\n     * This function interpolates between min and max in a similar way to Lerp. However, the interpolation will gradually speed up\n     * from the start and slow down toward the end. This is useful for creating natural-looking animation, fading and other transitions.\n     * @param from from\n     * @param to to\n     * @param tx value\n     * @returns the smooth stepped value\n     */\n    static SmoothStep(from, to, tx) {\n        let t = Scalar.Clamp(tx);\n        t = -2.0 * t * t * t + 3.0 * t * t;\n        return to * t + from * (1.0 - t);\n    }\n    /**\n     * Moves a value current towards target.\n     *\n     * This is essentially the same as Mathf.Lerp but instead the function will ensure that the speed never exceeds maxDelta.\n     * Negative values of maxDelta pushes the value away from target.\n     * @param current current value\n     * @param target target value\n     * @param maxDelta max distance to move\n     * @returns resulting value\n     */\n    static MoveTowards(current, target, maxDelta) {\n        let result = 0;\n        if (Math.abs(target - current) <= maxDelta) {\n            result = target;\n        }\n        else {\n            result = current + Scalar.Sign(target - current) * maxDelta;\n        }\n        return result;\n    }\n    /**\n     * Same as MoveTowards but makes sure the values interpolate correctly when they wrap around 360 degrees.\n     *\n     * Variables current and target are assumed to be in degrees. For optimization reasons, negative values of maxDelta\n     *  are not supported and may cause oscillation. To push current away from a target angle, add 180 to that angle instead.\n     * @param current current value\n     * @param target target value\n     * @param maxDelta max distance to move\n     * @returns resulting angle\n     */\n    static MoveTowardsAngle(current, target, maxDelta) {\n        const num = Scalar.DeltaAngle(current, target);\n        let result = 0;\n        if (-maxDelta < num && num < maxDelta) {\n            result = target;\n        }\n        else {\n            target = current + num;\n            result = Scalar.MoveTowards(current, target, maxDelta);\n        }\n        return result;\n    }\n    /**\n     * Creates a new scalar with values linearly interpolated of \"amount\" between the start scalar and the end scalar.\n     * @param start start value\n     * @param end target value\n     * @param amount amount to lerp between\n     * @returns the lerped value\n     */\n    static Lerp(start, end, amount) {\n        return start + (end - start) * amount;\n    }\n    /**\n     * Same as Lerp but makes sure the values interpolate correctly when they wrap around 360 degrees.\n     * The parameter t is clamped to the range [0, 1]. Variables a and b are assumed to be in degrees.\n     * @param start start value\n     * @param end target value\n     * @param amount amount to lerp between\n     * @returns the lerped value\n     */\n    static LerpAngle(start, end, amount) {\n        let num = Scalar.Repeat(end - start, 360.0);\n        if (num > 180.0) {\n            num -= 360.0;\n        }\n        return start + num * Scalar.Clamp(amount);\n    }\n    /**\n     * Calculates the linear parameter t that produces the interpolant value within the range [a, b].\n     * @param a start value\n     * @param b target value\n     * @param value value between a and b\n     * @returns the inverseLerp value\n     */\n    static InverseLerp(a, b, value) {\n        let result = 0;\n        if (a != b) {\n            result = Scalar.Clamp((value - a) / (b - a));\n        }\n        else {\n            result = 0.0;\n        }\n        return result;\n    }\n    /**\n     * Returns a new scalar located for \"amount\" (float) on the Hermite spline defined by the scalars \"value1\", \"value3\", \"tangent1\", \"tangent2\".\n     * @see http://mathworld.wolfram.com/HermitePolynomial.html\n     * @param value1 defines the first control point\n     * @param tangent1 defines the first tangent\n     * @param value2 defines the second control point\n     * @param tangent2 defines the second tangent\n     * @param amount defines the amount on the interpolation spline (between 0 and 1)\n     * @returns hermite result\n     */\n    static Hermite(value1, tangent1, value2, tangent2, amount) {\n        const squared = amount * amount;\n        const cubed = amount * squared;\n        const part1 = 2.0 * cubed - 3.0 * squared + 1.0;\n        const part2 = -2.0 * cubed + 3.0 * squared;\n        const part3 = cubed - 2.0 * squared + amount;\n        const part4 = cubed - squared;\n        return value1 * part1 + value2 * part2 + tangent1 * part3 + tangent2 * part4;\n    }\n    /**\n     * Returns a new scalar which is the 1st derivative of the Hermite spline defined by the scalars \"value1\", \"value2\", \"tangent1\", \"tangent2\".\n     * @param value1 defines the first control point\n     * @param tangent1 defines the first tangent\n     * @param value2 defines the second control point\n     * @param tangent2 defines the second tangent\n     * @param time define where the derivative must be done\n     * @returns 1st derivative\n     */\n    static Hermite1stDerivative(value1, tangent1, value2, tangent2, time) {\n        const t2 = time * time;\n        return (t2 - time) * 6 * value1 + (3 * t2 - 4 * time + 1) * tangent1 + (-t2 + time) * 6 * value2 + (3 * t2 - 2 * time) * tangent2;\n    }\n    /**\n     * Returns a random float number between and min and max values\n     * @param min min value of random\n     * @param max max value of random\n     * @returns random value\n     */\n    static RandomRange(min, max) {\n        if (min === max) {\n            return min;\n        }\n        return Math.random() * (max - min) + min;\n    }\n    /**\n     * This function returns percentage of a number in a given range.\n     *\n     * RangeToPercent(40,20,60) will return 0.5 (50%)\n     * RangeToPercent(34,0,100) will return 0.34 (34%)\n     * @param number to convert to percentage\n     * @param min min range\n     * @param max max range\n     * @returns the percentage\n     */\n    static RangeToPercent(number, min, max) {\n        return (number - min) / (max - min);\n    }\n    /**\n     * This function returns number that corresponds to the percentage in a given range.\n     *\n     * PercentToRange(0.34,0,100) will return 34.\n     * @param percent to convert to number\n     * @param min min range\n     * @param max max range\n     * @returns the number\n     */\n    static PercentToRange(percent, min, max) {\n        return (max - min) * percent + min;\n    }\n    /**\n     * Returns the angle converted to equivalent value between -Math.PI and Math.PI radians.\n     * @param angle The angle to normalize in radian.\n     * @returns The converted angle.\n     */\n    static NormalizeRadians(angle) {\n        // More precise but slower version kept for reference.\n        // angle = angle % Tools.TwoPi;\n        // angle = (angle + Tools.TwoPi) % Tools.TwoPi;\n        //if (angle > Math.PI) {\n        //\tangle -= Tools.TwoPi;\n        //}\n        angle -= Scalar.TwoPi * Math.floor((angle + Math.PI) / Scalar.TwoPi);\n        return angle;\n    }\n    /**\n     * Returns the highest common factor of two integers.\n     * @param a first parameter\n     * @param b second parameter\n     * @returns HCF of a and b\n     */\n    static HCF(a, b) {\n        const r = a % b;\n        if (r === 0) {\n            return b;\n        }\n        return Scalar.HCF(b, r);\n    }\n}\n/**\n * Two pi constants convenient for computation.\n */\nScalar.TwoPi = Math.PI * 2;\n//# sourceMappingURL=math.scalar.js.map","/**\n * Size containing width and height\n */\nexport class Size {\n    /**\n     * Creates a Size object from the given width and height (floats).\n     * @param width width of the new size\n     * @param height height of the new size\n     */\n    constructor(width, height) {\n        this.width = width;\n        this.height = height;\n    }\n    /**\n     * Returns a string with the Size width and height\n     * @returns a string with the Size width and height\n     */\n    toString() {\n        return `{W: ${this.width}, H: ${this.height}}`;\n    }\n    /**\n     * \"Size\"\n     * @returns the string \"Size\"\n     */\n    getClassName() {\n        return \"Size\";\n    }\n    /**\n     * Returns the Size hash code.\n     * @returns a hash code for a unique width and height\n     */\n    getHashCode() {\n        let hash = this.width | 0;\n        hash = (hash * 397) ^ (this.height | 0);\n        return hash;\n    }\n    /**\n     * Updates the current size from the given one.\n     * @param src the given size\n     */\n    copyFrom(src) {\n        this.width = src.width;\n        this.height = src.height;\n    }\n    /**\n     * Updates in place the current Size from the given floats.\n     * @param width width of the new size\n     * @param height height of the new size\n     * @returns the updated Size.\n     */\n    copyFromFloats(width, height) {\n        this.width = width;\n        this.height = height;\n        return this;\n    }\n    /**\n     * Updates in place the current Size from the given floats.\n     * @param width width to set\n     * @param height height to set\n     * @returns the updated Size.\n     */\n    set(width, height) {\n        return this.copyFromFloats(width, height);\n    }\n    /**\n     * Multiplies the width and height by numbers\n     * @param w factor to multiple the width by\n     * @param h factor to multiple the height by\n     * @returns a new Size set with the multiplication result of the current Size and the given floats.\n     */\n    multiplyByFloats(w, h) {\n        return new Size(this.width * w, this.height * h);\n    }\n    /**\n     * Clones the size\n     * @returns a new Size copied from the given one.\n     */\n    clone() {\n        return new Size(this.width, this.height);\n    }\n    /**\n     * True if the current Size and the given one width and height are strictly equal.\n     * @param other the other size to compare against\n     * @returns True if the current Size and the given one width and height are strictly equal.\n     */\n    equals(other) {\n        if (!other) {\n            return false;\n        }\n        return this.width === other.width && this.height === other.height;\n    }\n    /**\n     * The surface of the Size : width * height (float).\n     */\n    get surface() {\n        return this.width * this.height;\n    }\n    /**\n     * Create a new size of zero\n     * @returns a new Size set to (0.0, 0.0)\n     */\n    static Zero() {\n        return new Size(0.0, 0.0);\n    }\n    /**\n     * Sums the width and height of two sizes\n     * @param otherSize size to add to this size\n     * @returns a new Size set as the addition result of the current Size and the given one.\n     */\n    add(otherSize) {\n        const r = new Size(this.width + otherSize.width, this.height + otherSize.height);\n        return r;\n    }\n    /**\n     * Subtracts the width and height of two\n     * @param otherSize size to subtract to this size\n     * @returns a new Size set as the subtraction result of  the given one from the current Size.\n     */\n    subtract(otherSize) {\n        const r = new Size(this.width - otherSize.width, this.height - otherSize.height);\n        return r;\n    }\n    /**\n     * Creates a new Size set at the linear interpolation \"amount\" between \"start\" and \"end\"\n     * @param start starting size to lerp between\n     * @param end end size to lerp between\n     * @param amount amount to lerp between the start and end values\n     * @returns a new Size set at the linear interpolation \"amount\" between \"start\" and \"end\"\n     */\n    static Lerp(start, end, amount) {\n        const w = start.width + (end.width - start.width) * amount;\n        const h = start.height + (end.height - start.height) * amount;\n        return new Size(w, h);\n    }\n}\n//# sourceMappingURL=math.size.js.map","/* eslint-disable @typescript-eslint/naming-convention */\nimport { Scalar } from \"./math.scalar.js\";\nimport { Epsilon } from \"./math.constants.js\";\nimport { ArrayTools } from \"../Misc/arrayTools.js\";\nimport { RegisterClass } from \"../Misc/typeStore.js\";\nimport { PerformanceConfigurator } from \"../Engines/performanceConfigurator.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\n// eslint-disable-next-line @typescript-eslint/naming-convention\nconst _ExtractAsInt = (value) => {\n    return parseInt(value.toString().replace(/\\W/g, \"\"));\n};\n/**\n * Class representing a vector containing 2 coordinates\n * Example Playground - Overview -  https://playground.babylonjs.com/#QYBWV4#9\n */\nexport class Vector2 {\n    /**\n     * Creates a new Vector2 from the given x and y coordinates\n     * @param x defines the first coordinate\n     * @param y defines the second coordinate\n     */\n    constructor(\n    /** defines the first coordinate */\n    x = 0, \n    /** defines the second coordinate */\n    y = 0) {\n        this.x = x;\n        this.y = y;\n    }\n    /**\n     * Gets a string with the Vector2 coordinates\n     * @returns a string with the Vector2 coordinates\n     */\n    toString() {\n        return `{X: ${this.x} Y: ${this.y}}`;\n    }\n    /**\n     * Gets class name\n     * @returns the string \"Vector2\"\n     */\n    getClassName() {\n        return \"Vector2\";\n    }\n    /**\n     * Gets current vector hash code\n     * @returns the Vector2 hash code as a number\n     */\n    getHashCode() {\n        const x = _ExtractAsInt(this.x);\n        const y = _ExtractAsInt(this.y);\n        let hash = x;\n        hash = (hash * 397) ^ y;\n        return hash;\n    }\n    // Operators\n    /**\n     * Sets the Vector2 coordinates in the given array or Float32Array from the given index.\n     * Example Playground https://playground.babylonjs.com/#QYBWV4#15\n     * @param array defines the source array\n     * @param index defines the offset in source array\n     * @returns the current Vector2\n     */\n    toArray(array, index = 0) {\n        array[index] = this.x;\n        array[index + 1] = this.y;\n        return this;\n    }\n    /**\n     * Update the current vector from an array\n     * Example Playground https://playground.babylonjs.com/#QYBWV4#39\n     * @param array defines the destination array\n     * @param index defines the offset in the destination array\n     * @returns the current Vector2\n     */\n    fromArray(array, index = 0) {\n        Vector2.FromArrayToRef(array, index, this);\n        return this;\n    }\n    /**\n     * Copy the current vector to an array\n     * Example Playground https://playground.babylonjs.com/#QYBWV4#40\n     * @returns a new array with 2 elements: the Vector2 coordinates.\n     */\n    asArray() {\n        const result = new Array();\n        this.toArray(result, 0);\n        return result;\n    }\n    /**\n     * Sets the Vector2 coordinates with the given Vector2 coordinates\n     * Example Playground https://playground.babylonjs.com/#QYBWV4#24\n     * @param source defines the source Vector2\n     * @returns the current updated Vector2\n     */\n    copyFrom(source) {\n        this.x = source.x;\n        this.y = source.y;\n        return this;\n    }\n    /**\n     * Sets the Vector2 coordinates with the given floats\n     * Example Playground https://playground.babylonjs.com/#QYBWV4#25\n     * @param x defines the first coordinate\n     * @param y defines the second coordinate\n     * @returns the current updated Vector2\n     */\n    copyFromFloats(x, y) {\n        this.x = x;\n        this.y = y;\n        return this;\n    }\n    /**\n     * Sets the Vector2 coordinates with the given floats\n     * Example Playground https://playground.babylonjs.com/#QYBWV4#62\n     * @param x defines the first coordinate\n     * @param y defines the second coordinate\n     * @returns the current updated Vector2\n     */\n    set(x, y) {\n        return this.copyFromFloats(x, y);\n    }\n    /**\n     * Add another vector with the current one\n     * Example Playground https://playground.babylonjs.com/#QYBWV4#11\n     * @param otherVector defines the other vector\n     * @returns a new Vector2 set with the addition of the current Vector2 and the given one coordinates\n     */\n    add(otherVector) {\n        return new this.constructor(this.x + otherVector.x, this.y + otherVector.y);\n    }\n    /**\n     * Sets the \"result\" coordinates with the addition of the current Vector2 and the given one coordinates\n     * Example Playground https://playground.babylonjs.com/#QYBWV4#12\n     * @param otherVector defines the other vector\n     * @param result defines the target vector\n     * @returns result input\n     */\n    addToRef(otherVector, result) {\n        result.x = this.x + otherVector.x;\n        result.y = this.y + otherVector.y;\n        return result;\n    }\n    /**\n     * Set the Vector2 coordinates by adding the given Vector2 coordinates\n     * Example Playground https://playground.babylonjs.com/#QYBWV4#13\n     * @param otherVector defines the other vector\n     * @returns the current updated Vector2\n     */\n    addInPlace(otherVector) {\n        this.x += otherVector.x;\n        this.y += otherVector.y;\n        return this;\n    }\n    /**\n     * Gets a new Vector2 by adding the current Vector2 coordinates to the given Vector3 x, y coordinates\n     * Example Playground https://playground.babylonjs.com/#QYBWV4#14\n     * @param otherVector defines the other vector\n     * @returns a new Vector2\n     */\n    addVector3(otherVector) {\n        return new this.constructor(this.x + otherVector.x, this.y + otherVector.y);\n    }\n    /**\n     * Gets a new Vector2 set with the subtracted coordinates of the given one from the current Vector2\n     * Example Playground https://playground.babylonjs.com/#QYBWV4#61\n     * @param otherVector defines the other vector\n     * @returns a new Vector2\n     */\n    subtract(otherVector) {\n        return new this.constructor(this.x - otherVector.x, this.y - otherVector.y);\n    }\n    /**\n     * Sets the \"result\" coordinates with the subtraction of the given one from the current Vector2 coordinates.\n     * Example Playground https://playground.babylonjs.com/#QYBWV4#63\n     * @param otherVector defines the other vector\n     * @param result defines the target vector\n     * @returns result input\n     */\n    subtractToRef(otherVector, result) {\n        result.x = this.x - otherVector.x;\n        result.y = this.y - otherVector.y;\n        return result;\n    }\n    /**\n     * Sets the current Vector2 coordinates by subtracting from it the given one coordinates\n     * Example Playground https://playground.babylonjs.com/#QYBWV4#88\n     * @param otherVector defines the other vector\n     * @returns the current updated Vector2\n     */\n    subtractInPlace(otherVector) {\n        this.x -= otherVector.x;\n        this.y -= otherVector.y;\n        return this;\n    }\n    /**\n     * Multiplies in place the current Vector2 coordinates by the given ones\n     * Example Playground https://playground.babylonjs.com/#QYBWV4#43\n     * @param otherVector defines the other vector\n     * @returns the current updated Vector2\n     */\n    multiplyInPlace(otherVector) {\n        this.x *= otherVector.x;\n        this.y *= otherVector.y;\n        return this;\n    }\n    /**\n     * Returns a new Vector2 set with the multiplication of the current Vector2 and the given one coordinates\n     * Example Playground https://playground.babylonjs.com/#QYBWV4#42\n     * @param otherVector defines the other vector\n     * @returns a new Vector2\n     */\n    multiply(otherVector) {\n        return new this.constructor(this.x * otherVector.x, this.y * otherVector.y);\n    }\n    /**\n     * Sets \"result\" coordinates with the multiplication of the current Vector2 and the given one coordinates\n     * Example Playground https://playground.babylonjs.com/#QYBWV4#44\n     * @param otherVector defines the other vector\n     * @param result defines the target vector\n     * @returns result input\n     */\n    multiplyToRef(otherVector, result) {\n        result.x = this.x * otherVector.x;\n        result.y = this.y * otherVector.y;\n        return result;\n    }\n    /**\n     * Gets a new Vector2 set with the Vector2 coordinates multiplied by the given floats\n     * Example Playground https://playground.babylonjs.com/#QYBWV4#89\n     * @param x defines the first coordinate\n     * @param y defines the second coordinate\n     * @returns a new Vector2\n     */\n    multiplyByFloats(x, y) {\n        return new this.constructor(this.x * x, this.y * y);\n    }\n    /**\n     * Returns a new Vector2 set with the Vector2 coordinates divided by the given one coordinates\n     * Example Playground https://playground.babylonjs.com/#QYBWV4#27\n     * @param otherVector defines the other vector\n     * @returns a new Vector2\n     */\n    divide(otherVector) {\n        return new this.constructor(this.x / otherVector.x, this.y / otherVector.y);\n    }\n    /**\n     * Sets the \"result\" coordinates with the Vector2 divided by the given one coordinates\n     * Example Playground https://playground.babylonjs.com/#QYBWV4#30\n     * @param otherVector defines the other vector\n     * @param result defines the target vector\n     * @returns result input\n     */\n    divideToRef(otherVector, result) {\n        result.x = this.x / otherVector.x;\n        result.y = this.y / otherVector.y;\n        return result;\n    }\n    /**\n     * Divides the current Vector2 coordinates by the given ones\n     * Example Playground https://playground.babylonjs.com/#QYBWV4#28\n     * @param otherVector defines the other vector\n     * @returns the current updated Vector2\n     */\n    divideInPlace(otherVector) {\n        return this.divideToRef(otherVector, this);\n    }\n    /**\n     * Gets a new Vector2 with current Vector2 negated coordinates\n     * Example Playground https://playground.babylonjs.com/#QYBWV4#22\n     * @returns a new Vector2\n     */\n    negate() {\n        return new this.constructor(-this.x, -this.y);\n    }\n    /**\n     * Negate this vector in place\n     * Example Playground https://playground.babylonjs.com/#QYBWV4#23\n     * @returns this\n     */\n    negateInPlace() {\n        this.x *= -1;\n        this.y *= -1;\n        return this;\n    }\n    /**\n     * Negate the current Vector2 and stores the result in the given vector \"result\" coordinates\n     * Example Playground https://playground.babylonjs.com/#QYBWV4#41\n     * @param result defines the Vector3 object where to store the result\n     * @returns the result\n     */\n    negateToRef(result) {\n        return result.copyFromFloats(this.x * -1, this.y * -1);\n    }\n    /**\n     * Multiply the Vector2 coordinates by\n     * Example Playground https://playground.babylonjs.com/#QYBWV4#59\n     * @param scale defines the scaling factor\n     * @returns the current updated Vector2\n     */\n    scaleInPlace(scale) {\n        this.x *= scale;\n        this.y *= scale;\n        return this;\n    }\n    /**\n     * Returns a new Vector2 scaled by \"scale\" from the current Vector2\n     * Example Playground https://playground.babylonjs.com/#QYBWV4#52\n     * @param scale defines the scaling factor\n     * @returns a new Vector2\n     */\n    scale(scale) {\n        const result = new this.constructor(0, 0);\n        this.scaleToRef(scale, result);\n        return result;\n    }\n    /**\n     * Scale the current Vector2 values by a factor to a given Vector2\n     * Example Playground https://playground.babylonjs.com/#QYBWV4#57\n     * @param scale defines the scale factor\n     * @param result defines the Vector2 object where to store the result\n     * @returns result input\n     */\n    scaleToRef(scale, result) {\n        result.x = this.x * scale;\n        result.y = this.y * scale;\n        return result;\n    }\n    /**\n     * Scale the current Vector2 values by a factor and add the result to a given Vector2\n     * Example Playground https://playground.babylonjs.com/#QYBWV4#58\n     * @param scale defines the scale factor\n     * @param result defines the Vector2 object where to store the result\n     * @returns result input\n     */\n    scaleAndAddToRef(scale, result) {\n        result.x += this.x * scale;\n        result.y += this.y * scale;\n        return result;\n    }\n    /**\n     * Gets a boolean if two vectors are equals\n     * Example Playground https://playground.babylonjs.com/#QYBWV4#31\n     * @param otherVector defines the other vector\n     * @returns true if the given vector coordinates strictly equal the current Vector2 ones\n     */\n    equals(otherVector) {\n        return otherVector && this.x === otherVector.x && this.y === otherVector.y;\n    }\n    /**\n     * Gets a boolean if two vectors are equals (using an epsilon value)\n     * Example Playground https://playground.babylonjs.com/#QYBWV4#32\n     * @param otherVector defines the other vector\n     * @param epsilon defines the minimal distance to consider equality\n     * @returns true if the given vector coordinates are close to the current ones by a distance of epsilon.\n     */\n    equalsWithEpsilon(otherVector, epsilon = Epsilon) {\n        return otherVector && Scalar.WithinEpsilon(this.x, otherVector.x, epsilon) && Scalar.WithinEpsilon(this.y, otherVector.y, epsilon);\n    }\n    /**\n     * Gets a new Vector2 from current Vector2 floored values\n     * Example Playground https://playground.babylonjs.com/#QYBWV4#35\n     * eg (1.2, 2.31) returns (1, 2)\n     * @returns a new Vector2\n     */\n    floor() {\n        return new this.constructor(Math.floor(this.x), Math.floor(this.y));\n    }\n    /**\n     * Gets a new Vector2 from current Vector2 fractional values\n     * Example Playground https://playground.babylonjs.com/#QYBWV4#34\n     * eg (1.2, 2.31) returns (0.2, 0.31)\n     * @returns a new Vector2\n     */\n    fract() {\n        return new this.constructor(this.x - Math.floor(this.x), this.y - Math.floor(this.y));\n    }\n    /**\n     * Rotate the current vector into a given result vector\n     * Example Playground https://playground.babylonjs.com/#QYBWV4#49\n     * @param angle defines the rotation angle\n     * @param result defines the result vector where to store the rotated vector\n     * @returns result input\n     */\n    rotateToRef(angle, result) {\n        const cos = Math.cos(angle);\n        const sin = Math.sin(angle);\n        result.x = cos * this.x - sin * this.y;\n        result.y = sin * this.x + cos * this.y;\n        return result;\n    }\n    // Properties\n    /**\n     * Gets the length of the vector\n     * @returns the vector length (float)\n     */\n    length() {\n        return Math.sqrt(this.x * this.x + this.y * this.y);\n    }\n    /**\n     * Gets the vector squared length\n     * @returns the vector squared length (float)\n     */\n    lengthSquared() {\n        return this.x * this.x + this.y * this.y;\n    }\n    // Methods\n    /**\n     * Normalize the vector\n     * Example Playground https://playground.babylonjs.com/#QYBWV4#48\n     * @returns the current updated Vector2\n     */\n    normalize() {\n        Vector2.NormalizeToRef(this, this);\n        return this;\n    }\n    /**\n     * Gets a new Vector2 copied from the Vector2\n     * Example Playground https://playground.babylonjs.com/#QYBWV4#20\n     * @returns a new Vector2\n     */\n    clone() {\n        return new this.constructor(this.x, this.y);\n    }\n    // Statics\n    /**\n     * Gets a new Vector2(0, 0)\n     * @returns a new Vector2\n     */\n    static Zero() {\n        return new Vector2(0, 0);\n    }\n    /**\n     * Gets a new Vector2(1, 1)\n     * @returns a new Vector2\n     */\n    static One() {\n        return new Vector2(1, 1);\n    }\n    /**\n     * Returns a new Vector2 with random values between min and max\n     * @param min the minimum random value\n     * @param max the maximum random value\n     * @returns a Vector2 with random values between min and max\n     */\n    static Random(min = 0, max = 1) {\n        return new Vector2(Scalar.RandomRange(min, max), Scalar.RandomRange(min, max));\n    }\n    /**\n     * Gets a zero Vector2 that must not be updated\n     */\n    static get ZeroReadOnly() {\n        return Vector2._ZeroReadOnly;\n    }\n    /**\n     * Gets a new Vector2 set from the given index element of the given array\n     * Example Playground https://playground.babylonjs.com/#QYBWV4#79\n     * @param array defines the data source\n     * @param offset defines the offset in the data source\n     * @returns a new Vector2\n     */\n    static FromArray(array, offset = 0) {\n        return new Vector2(array[offset], array[offset + 1]);\n    }\n    /**\n     * Sets \"result\" from the given index element of the given array\n     * Example Playground https://playground.babylonjs.com/#QYBWV4#80\n     * @param array defines the data source\n     * @param offset defines the offset in the data source\n     * @param result defines the target vector\n     * @returns result input\n     */\n    static FromArrayToRef(array, offset, result) {\n        result.x = array[offset];\n        result.y = array[offset + 1];\n        return result;\n    }\n    /**\n     * Gets a new Vector2 located for \"amount\" (float) on the CatmullRom spline defined by the given four Vector2\n     * Example Playground https://playground.babylonjs.com/#QYBWV4#65\n     * @param value1 defines 1st point of control\n     * @param value2 defines 2nd point of control\n     * @param value3 defines 3rd point of control\n     * @param value4 defines 4th point of control\n     * @param amount defines the interpolation factor\n     * @returns a new Vector2\n     */\n    static CatmullRom(value1, value2, value3, value4, amount) {\n        const squared = amount * amount;\n        const cubed = amount * squared;\n        const x = 0.5 *\n            (2.0 * value2.x +\n                (-value1.x + value3.x) * amount +\n                (2.0 * value1.x - 5.0 * value2.x + 4.0 * value3.x - value4.x) * squared +\n                (-value1.x + 3.0 * value2.x - 3.0 * value3.x + value4.x) * cubed);\n        const y = 0.5 *\n            (2.0 * value2.y +\n                (-value1.y + value3.y) * amount +\n                (2.0 * value1.y - 5.0 * value2.y + 4.0 * value3.y - value4.y) * squared +\n                (-value1.y + 3.0 * value2.y - 3.0 * value3.y + value4.y) * cubed);\n        return new value1.constructor(x, y);\n    }\n    /**\n     * Returns a new Vector2 set with same the coordinates than \"value\" ones if the vector \"value\" is in the square defined by \"min\" and \"max\".\n     * If a coordinate of \"value\" is lower than \"min\" coordinates, the returned Vector2 is given this \"min\" coordinate.\n     * If a coordinate of \"value\" is greater than \"max\" coordinates, the returned Vector2 is given this \"max\" coordinate\n     * Example Playground https://playground.babylonjs.com/#QYBWV4#76\n     * @param value defines the value to clamp\n     * @param min defines the lower limit\n     * @param max defines the upper limit\n     * @returns a new Vector2\n     */\n    static Clamp(value, min, max) {\n        let x = value.x;\n        x = x > max.x ? max.x : x;\n        x = x < min.x ? min.x : x;\n        let y = value.y;\n        y = y > max.y ? max.y : y;\n        y = y < min.y ? min.y : y;\n        return new value.constructor(x, y);\n    }\n    /**\n     * Returns a new Vector2 located for \"amount\" (float) on the Hermite spline defined by the vectors \"value1\", \"value2\", \"tangent1\", \"tangent2\"\n     * Example Playground https://playground.babylonjs.com/#QYBWV4#81\n     * @param value1 defines the 1st control point\n     * @param tangent1 defines the outgoing tangent\n     * @param value2 defines the 2nd control point\n     * @param tangent2 defines the incoming tangent\n     * @param amount defines the interpolation factor\n     * @returns a new Vector2\n     */\n    static Hermite(value1, tangent1, value2, tangent2, amount) {\n        const squared = amount * amount;\n        const cubed = amount * squared;\n        const part1 = 2.0 * cubed - 3.0 * squared + 1.0;\n        const part2 = -2.0 * cubed + 3.0 * squared;\n        const part3 = cubed - 2.0 * squared + amount;\n        const part4 = cubed - squared;\n        const x = value1.x * part1 + value2.x * part2 + tangent1.x * part3 + tangent2.x * part4;\n        const y = value1.y * part1 + value2.y * part2 + tangent1.y * part3 + tangent2.y * part4;\n        return new value1.constructor(x, y);\n    }\n    /**\n     * Returns a new Vector2 which is the 1st derivative of the Hermite spline defined by the vectors \"value1\", \"value2\", \"tangent1\", \"tangent2\".\n     * Example Playground https://playground.babylonjs.com/#QYBWV4#82\n     * @param value1 defines the first control point\n     * @param tangent1 defines the first tangent\n     * @param value2 defines the second control point\n     * @param tangent2 defines the second tangent\n     * @param time define where the derivative must be done\n     * @returns 1st derivative\n     */\n    static Hermite1stDerivative(value1, tangent1, value2, tangent2, time) {\n        const result = new value1.constructor();\n        this.Hermite1stDerivativeToRef(value1, tangent1, value2, tangent2, time, result);\n        return result;\n    }\n    /**\n     * Returns a new Vector2 which is the 1st derivative of the Hermite spline defined by the vectors \"value1\", \"value2\", \"tangent1\", \"tangent2\".\n     * Example Playground https://playground.babylonjs.com/#QYBWV4#83\n     * @param value1 defines the first control point\n     * @param tangent1 defines the first tangent\n     * @param value2 defines the second control point\n     * @param tangent2 defines the second tangent\n     * @param time define where the derivative must be done\n     * @param result define where the derivative will be stored\n     * @returns result input\n     */\n    static Hermite1stDerivativeToRef(value1, tangent1, value2, tangent2, time, result) {\n        const t2 = time * time;\n        result.x = (t2 - time) * 6 * value1.x + (3 * t2 - 4 * time + 1) * tangent1.x + (-t2 + time) * 6 * value2.x + (3 * t2 - 2 * time) * tangent2.x;\n        result.y = (t2 - time) * 6 * value1.y + (3 * t2 - 4 * time + 1) * tangent1.y + (-t2 + time) * 6 * value2.y + (3 * t2 - 2 * time) * tangent2.y;\n        return result;\n    }\n    /**\n     * Returns a new Vector2 located for \"amount\" (float) on the linear interpolation between the vector \"start\" adn the vector \"end\".\n     * Example Playground https://playground.babylonjs.com/#QYBWV4#84\n     * @param start defines the start vector\n     * @param end defines the end vector\n     * @param amount defines the interpolation factor\n     * @returns a new Vector2\n     */\n    static Lerp(start, end, amount) {\n        const x = start.x + (end.x - start.x) * amount;\n        const y = start.y + (end.y - start.y) * amount;\n        return new start.constructor(x, y);\n    }\n    /**\n     * Gets the dot product of the vector \"left\" and the vector \"right\"\n     * Example Playground https://playground.babylonjs.com/#QYBWV4#90\n     * @param left defines first vector\n     * @param right defines second vector\n     * @returns the dot product (float)\n     */\n    static Dot(left, right) {\n        return left.x * right.x + left.y * right.y;\n    }\n    /**\n     * Returns a new Vector2 equal to the normalized given vector\n     * Example Playground https://playground.babylonjs.com/#QYBWV4#46\n     * @param vector defines the vector to normalize\n     * @returns a new Vector2\n     */\n    static Normalize(vector) {\n        const newVector = new vector.constructor();\n        this.NormalizeToRef(vector, newVector);\n        return newVector;\n    }\n    /**\n     * Normalize a given vector into a second one\n     * Example Playground https://playground.babylonjs.com/#QYBWV4#50\n     * @param vector defines the vector to normalize\n     * @param result defines the vector where to store the result\n     * @returns result input\n     */\n    static NormalizeToRef(vector, result) {\n        const len = vector.length();\n        if (len === 0) {\n            return result;\n        }\n        result.x = vector.x / len;\n        result.y = vector.y / len;\n        return result;\n    }\n    /**\n     * Gets a new Vector2 set with the minimal coordinate values from the \"left\" and \"right\" vectors\n     * Example Playground https://playground.babylonjs.com/#QYBWV4#86\n     * @param left defines 1st vector\n     * @param right defines 2nd vector\n     * @returns a new Vector2\n     */\n    static Minimize(left, right) {\n        const x = left.x < right.x ? left.x : right.x;\n        const y = left.y < right.y ? left.y : right.y;\n        return new left.constructor(x, y);\n    }\n    /**\n     * Gets a new Vector2 set with the maximal coordinate values from the \"left\" and \"right\" vectors\n     * Example Playground https://playground.babylonjs.com/#QYBWV4#86\n     * @param left defines 1st vector\n     * @param right defines 2nd vector\n     * @returns a new Vector2\n     */\n    static Maximize(left, right) {\n        const x = left.x > right.x ? left.x : right.x;\n        const y = left.y > right.y ? left.y : right.y;\n        return new left.constructor(x, y);\n    }\n    /**\n     * Gets a new Vector2 set with the transformed coordinates of the given vector by the given transformation matrix\n     * Example Playground https://playground.babylonjs.com/#QYBWV4#17\n     * @param vector defines the vector to transform\n     * @param transformation defines the matrix to apply\n     * @returns a new Vector2\n     */\n    static Transform(vector, transformation) {\n        const result = new vector.constructor();\n        Vector2.TransformToRef(vector, transformation, result);\n        return result;\n    }\n    /**\n     * Transforms the given vector coordinates by the given transformation matrix and stores the result in the vector \"result\" coordinates\n     * Example Playground https://playground.babylonjs.com/#QYBWV4#19\n     * @param vector defines the vector to transform\n     * @param transformation defines the matrix to apply\n     * @param result defines the target vector\n     * @returns result input\n     */\n    static TransformToRef(vector, transformation, result) {\n        const m = transformation.m;\n        const x = vector.x * m[0] + vector.y * m[4] + m[12];\n        const y = vector.x * m[1] + vector.y * m[5] + m[13];\n        result.x = x;\n        result.y = y;\n        return result;\n    }\n    /**\n     * Determines if a given vector is included in a triangle\n     * Example Playground https://playground.babylonjs.com/#QYBWV4#87\n     * @param p defines the vector to test\n     * @param p0 defines 1st triangle point\n     * @param p1 defines 2nd triangle point\n     * @param p2 defines 3rd triangle point\n     * @returns true if the point \"p\" is in the triangle defined by the vectors \"p0\", \"p1\", \"p2\"\n     */\n    static PointInTriangle(p, p0, p1, p2) {\n        const a = (1 / 2) * (-p1.y * p2.x + p0.y * (-p1.x + p2.x) + p0.x * (p1.y - p2.y) + p1.x * p2.y);\n        const sign = a < 0 ? -1 : 1;\n        const s = (p0.y * p2.x - p0.x * p2.y + (p2.y - p0.y) * p.x + (p0.x - p2.x) * p.y) * sign;\n        const t = (p0.x * p1.y - p0.y * p1.x + (p0.y - p1.y) * p.x + (p1.x - p0.x) * p.y) * sign;\n        return s > 0 && t > 0 && s + t < 2 * a * sign;\n    }\n    /**\n     * Gets the distance between the vectors \"value1\" and \"value2\"\n     * Example Playground https://playground.babylonjs.com/#QYBWV4#71\n     * @param value1 defines first vector\n     * @param value2 defines second vector\n     * @returns the distance between vectors\n     */\n    static Distance(value1, value2) {\n        return Math.sqrt(Vector2.DistanceSquared(value1, value2));\n    }\n    /**\n     * Returns the squared distance between the vectors \"value1\" and \"value2\"\n     * Example Playground https://playground.babylonjs.com/#QYBWV4#72\n     * @param value1 defines first vector\n     * @param value2 defines second vector\n     * @returns the squared distance between vectors\n     */\n    static DistanceSquared(value1, value2) {\n        const x = value1.x - value2.x;\n        const y = value1.y - value2.y;\n        return x * x + y * y;\n    }\n    /**\n     * Gets a new Vector2 located at the center of the vectors \"value1\" and \"value2\"\n     * Example Playground https://playground.babylonjs.com/#QYBWV4#86\n     * Example Playground https://playground.babylonjs.com/#QYBWV4#66\n     * @param value1 defines first vector\n     * @param value2 defines second vector\n     * @returns a new Vector2\n     */\n    static Center(value1, value2) {\n        const result = new value1.constructor();\n        return Vector2.CenterToRef(value1, value2, result);\n    }\n    /**\n     * Gets the center of the vectors \"value1\" and \"value2\" and stores the result in the vector \"ref\"\n     * Example Playground https://playground.babylonjs.com/#QYBWV4#66\n     * @param value1 defines first vector\n     * @param value2 defines second vector\n     * @param ref defines third vector\n     * @returns ref\n     */\n    static CenterToRef(value1, value2, ref) {\n        return ref.copyFromFloats((value1.x + value2.x) / 2, (value1.y + value2.y) / 2);\n    }\n    /**\n     * Gets the shortest distance (float) between the point \"p\" and the segment defined by the two points \"segA\" and \"segB\".\n     * Example Playground https://playground.babylonjs.com/#QYBWV4#77\n     * @param p defines the middle point\n     * @param segA defines one point of the segment\n     * @param segB defines the other point of the segment\n     * @returns the shortest distance\n     */\n    static DistanceOfPointFromSegment(p, segA, segB) {\n        const l2 = Vector2.DistanceSquared(segA, segB);\n        if (l2 === 0.0) {\n            return Vector2.Distance(p, segA);\n        }\n        const v = segB.subtract(segA);\n        const t = Math.max(0, Math.min(1, Vector2.Dot(p.subtract(segA), v) / l2));\n        const proj = segA.add(v.multiplyByFloats(t, t));\n        return Vector2.Distance(p, proj);\n    }\n}\nVector2._ZeroReadOnly = Vector2.Zero();\n/**\n * Class used to store (x,y,z) vector representation\n * A Vector3 is the main object used in 3D geometry\n * It can represent either the coordinates of a point the space, either a direction\n * Reminder: js uses a left handed forward facing system\n * Example Playground - Overview - https://playground.babylonjs.com/#R1F8YU\n */\nexport class Vector3 {\n    /** Gets or sets the x coordinate */\n    get x() {\n        return this._x;\n    }\n    set x(value) {\n        this._x = value;\n        this._isDirty = true;\n    }\n    /** Gets or sets the y coordinate */\n    get y() {\n        return this._y;\n    }\n    set y(value) {\n        this._y = value;\n        this._isDirty = true;\n    }\n    /** Gets or sets the z coordinate */\n    get z() {\n        return this._z;\n    }\n    set z(value) {\n        this._z = value;\n        this._isDirty = true;\n    }\n    /**\n     * Creates a new Vector3 object from the given x, y, z (floats) coordinates.\n     * @param x defines the first coordinates (on X axis)\n     * @param y defines the second coordinates (on Y axis)\n     * @param z defines the third coordinates (on Z axis)\n     */\n    constructor(x = 0, y = 0, z = 0) {\n        /** @internal */\n        this._isDirty = true;\n        this._x = x;\n        this._y = y;\n        this._z = z;\n    }\n    /**\n     * Creates a string representation of the Vector3\n     * Example Playground https://playground.babylonjs.com/#R1F8YU#67\n     * @returns a string with the Vector3 coordinates.\n     */\n    toString() {\n        return `{X: ${this._x} Y: ${this._y} Z: ${this._z}}`;\n    }\n    /**\n     * Gets the class name\n     * @returns the string \"Vector3\"\n     */\n    getClassName() {\n        return \"Vector3\";\n    }\n    /**\n     * Creates the Vector3 hash code\n     * @returns a number which tends to be unique between Vector3 instances\n     */\n    getHashCode() {\n        const x = _ExtractAsInt(this._x);\n        const y = _ExtractAsInt(this._y);\n        const z = _ExtractAsInt(this._z);\n        let hash = x;\n        hash = (hash * 397) ^ y;\n        hash = (hash * 397) ^ z;\n        return hash;\n    }\n    // Operators\n    /**\n     * Creates an array containing three elements : the coordinates of the Vector3\n     * Example Playground https://playground.babylonjs.com/#R1F8YU#10\n     * @returns a new array of numbers\n     */\n    asArray() {\n        const result = [];\n        this.toArray(result, 0);\n        return result;\n    }\n    /**\n     * Populates the given array or Float32Array from the given index with the successive coordinates of the Vector3\n     * Example Playground https://playground.babylonjs.com/#R1F8YU#65\n     * @param array defines the destination array\n     * @param index defines the offset in the destination array\n     * @returns the current Vector3\n     */\n    toArray(array, index = 0) {\n        array[index] = this._x;\n        array[index + 1] = this._y;\n        array[index + 2] = this._z;\n        return this;\n    }\n    /**\n     * Update the current vector from an array\n     * Example Playground https://playground.babylonjs.com/#R1F8YU#24\n     * @param array defines the destination array\n     * @param index defines the offset in the destination array\n     * @returns the current Vector3\n     */\n    fromArray(array, index = 0) {\n        Vector3.FromArrayToRef(array, index, this);\n        return this;\n    }\n    /**\n     * Converts the current Vector3 into a quaternion (considering that the Vector3 contains Euler angles representation of a rotation)\n     * Example Playground https://playground.babylonjs.com/#R1F8YU#66\n     * @returns a new Quaternion object, computed from the Vector3 coordinates\n     */\n    toQuaternion() {\n        return Quaternion.RotationYawPitchRoll(this._y, this._x, this._z);\n    }\n    /**\n     * Adds the given vector to the current Vector3\n     * Example Playground https://playground.babylonjs.com/#R1F8YU#4\n     * @param otherVector defines the second operand\n     * @returns the current updated Vector3\n     */\n    addInPlace(otherVector) {\n        return this.addInPlaceFromFloats(otherVector._x, otherVector._y, otherVector._z);\n    }\n    /**\n     * Adds the given coordinates to the current Vector3\n     * Example Playground https://playground.babylonjs.com/#R1F8YU#5\n     * @param x defines the x coordinate of the operand\n     * @param y defines the y coordinate of the operand\n     * @param z defines the z coordinate of the operand\n     * @returns the current updated Vector3\n     */\n    addInPlaceFromFloats(x, y, z) {\n        this._x += x;\n        this._y += y;\n        this._z += z;\n        this._isDirty = true;\n        return this;\n    }\n    /**\n     * Gets a new Vector3, result of the addition the current Vector3 and the given vector\n     * Example Playground https://playground.babylonjs.com/#R1F8YU#3\n     * @param otherVector defines the second operand\n     * @returns the resulting Vector3\n     */\n    add(otherVector) {\n        return new this.constructor(this._x + otherVector._x, this._y + otherVector._y, this._z + otherVector._z);\n    }\n    /**\n     * Adds the current Vector3 to the given one and stores the result in the vector \"result\"\n     * Example Playground https://playground.babylonjs.com/#R1F8YU#6\n     * @param otherVector defines the second operand\n     * @param result defines the Vector3 object where to store the result\n     * @returns the result\n     */\n    addToRef(otherVector, result) {\n        return result.copyFromFloats(this._x + otherVector._x, this._y + otherVector._y, this._z + otherVector._z);\n    }\n    /**\n     * Subtract the given vector from the current Vector3\n     * Example Playground https://playground.babylonjs.com/#R1F8YU#61\n     * @param otherVector defines the second operand\n     * @returns the current updated Vector3\n     */\n    subtractInPlace(otherVector) {\n        this._x -= otherVector._x;\n        this._y -= otherVector._y;\n        this._z -= otherVector._z;\n        this._isDirty = true;\n        return this;\n    }\n    /**\n     * Returns a new Vector3, result of the subtraction of the given vector from the current Vector3\n     * Example Playground https://playground.babylonjs.com/#R1F8YU#60\n     * @param otherVector defines the second operand\n     * @returns the resulting Vector3\n     */\n    subtract(otherVector) {\n        return new this.constructor(this._x - otherVector._x, this._y - otherVector._y, this._z - otherVector._z);\n    }\n    /**\n     * Subtracts the given vector from the current Vector3 and stores the result in the vector \"result\".\n     * Example Playground https://playground.babylonjs.com/#R1F8YU#63\n     * @param otherVector defines the second operand\n     * @param result defines the Vector3 object where to store the result\n     * @returns the result\n     */\n    subtractToRef(otherVector, result) {\n        return this.subtractFromFloatsToRef(otherVector._x, otherVector._y, otherVector._z, result);\n    }\n    /**\n     * Returns a new Vector3 set with the subtraction of the given floats from the current Vector3 coordinates\n     * Example Playground https://playground.babylonjs.com/#R1F8YU#62\n     * @param x defines the x coordinate of the operand\n     * @param y defines the y coordinate of the operand\n     * @param z defines the z coordinate of the operand\n     * @returns the resulting Vector3\n     */\n    subtractFromFloats(x, y, z) {\n        return new this.constructor(this._x - x, this._y - y, this._z - z);\n    }\n    /**\n     * Subtracts the given floats from the current Vector3 coordinates and set the given vector \"result\" with this result\n     * Example Playground https://playground.babylonjs.com/#R1F8YU#64\n     * @param x defines the x coordinate of the operand\n     * @param y defines the y coordinate of the operand\n     * @param z defines the z coordinate of the operand\n     * @param result defines the Vector3 object where to store the result\n     * @returns the result\n     */\n    subtractFromFloatsToRef(x, y, z, result) {\n        return result.copyFromFloats(this._x - x, this._y - y, this._z - z);\n    }\n    /**\n     * Gets a new Vector3 set with the current Vector3 negated coordinates\n     * Example Playground https://playground.babylonjs.com/#R1F8YU#35\n     * @returns a new Vector3\n     */\n    negate() {\n        return new this.constructor(-this._x, -this._y, -this._z);\n    }\n    /**\n     * Negate this vector in place\n     * Example Playground https://playground.babylonjs.com/#R1F8YU#36\n     * @returns this\n     */\n    negateInPlace() {\n        this._x *= -1;\n        this._y *= -1;\n        this._z *= -1;\n        this._isDirty = true;\n        return this;\n    }\n    /**\n     * Negate the current Vector3 and stores the result in the given vector \"result\" coordinates\n     * Example Playground https://playground.babylonjs.com/#R1F8YU#37\n     * @param result defines the Vector3 object where to store the result\n     * @returns the result\n     */\n    negateToRef(result) {\n        return result.copyFromFloats(this._x * -1, this._y * -1, this._z * -1);\n    }\n    /**\n     * Multiplies the Vector3 coordinates by the float \"scale\"\n     * Example Playground https://playground.babylonjs.com/#R1F8YU#56\n     * @param scale defines the multiplier factor\n     * @returns the current updated Vector3\n     */\n    scaleInPlace(scale) {\n        this._x *= scale;\n        this._y *= scale;\n        this._z *= scale;\n        this._isDirty = true;\n        return this;\n    }\n    /**\n     * Returns a new Vector3 set with the current Vector3 coordinates multiplied by the float \"scale\"\n     * Example Playground https://playground.babylonjs.com/#R1F8YU#53\n     * @param scale defines the multiplier factor\n     * @returns a new Vector3\n     */\n    scale(scale) {\n        return new this.constructor(this._x * scale, this._y * scale, this._z * scale);\n    }\n    /**\n     * Multiplies the current Vector3 coordinates by the float \"scale\" and stores the result in the given vector \"result\" coordinates\n     * Example Playground https://playground.babylonjs.com/#R1F8YU#57\n     * @param scale defines the multiplier factor\n     * @param result defines the Vector3 object where to store the result\n     * @returns the result\n     */\n    scaleToRef(scale, result) {\n        return result.copyFromFloats(this._x * scale, this._y * scale, this._z * scale);\n    }\n    /**\n     * Creates a vector normal (perpendicular) to the current Vector3 and stores the result in the given vector\n     * Out of the infinite possibilities the normal chosen is the one formed by rotating the current vector\n     * 90 degrees about an axis which lies perpendicular to the current vector\n     * and its projection on the xz plane. In the case of a current vector in the xz plane\n     * the normal is calculated to be along the y axis.\n     * Example Playground https://playground.babylonjs.com/#R1F8YU#230\n     * Example Playground https://playground.babylonjs.com/#R1F8YU#231\n     * @param result defines the Vector3 object where to store the resultant normal\n     * returns the result\n     */\n    getNormalToRef(result) {\n        /**\n         * Calculates the spherical coordinates of the current vector\n         * so saves on memory rather than importing whole Spherical Class\n         */\n        const radius = this.length();\n        let theta = Math.acos(this.y / radius);\n        const phi = Math.atan2(this.z, this.x);\n        //makes angle 90 degs to current vector\n        if (theta > Math.PI / 2) {\n            theta -= Math.PI / 2;\n        }\n        else {\n            theta += Math.PI / 2;\n        }\n        //Calculates resutant normal vector from spherical coordinate of perpendicular vector\n        const x = radius * Math.sin(theta) * Math.cos(phi);\n        const y = radius * Math.cos(theta);\n        const z = radius * Math.sin(theta) * Math.sin(phi);\n        result.set(x, y, z);\n        return result;\n    }\n    /**\n     * Rotates the vector using the given unit quaternion and stores the new vector in result\n     * Example Playground https://playground.babylonjs.com/#R1F8YU#9\n     * @param q the unit quaternion representing the rotation\n     * @param result the output vector\n     * @returns the result\n     */\n    applyRotationQuaternionToRef(q, result) {\n        const ix = q._w * this._x + q._y * this._z - q._z * this._y;\n        const iy = q._w * this._y + q._z * this._x - q._x * this._z;\n        const iz = q._w * this._z + q._x * this._y - q._y * this._x;\n        const iw = -q._x * this._x - q._y * this._y - q._z * this._z;\n        result._x = ix * q._w + iw * -q._x + iy * -q._z - iz * -q._y;\n        result._y = iy * q._w + iw * -q._y + iz * -q._x - ix * -q._z;\n        result._z = iz * q._w + iw * -q._z + ix * -q._y - iy * -q._x;\n        result._isDirty = true;\n        return result;\n    }\n    /**\n     * Rotates the vector in place using the given unit quaternion\n     * Example Playground https://playground.babylonjs.com/#R1F8YU#8\n     * @param q the unit quaternion representing the rotation\n     * @returns the current updated Vector3\n     */\n    applyRotationQuaternionInPlace(q) {\n        return this.applyRotationQuaternionToRef(q, this);\n    }\n    /**\n     * Rotates the vector using the given unit quaternion and returns the new vector\n     * Example Playground https://playground.babylonjs.com/#R1F8YU#7\n     * @param q the unit quaternion representing the rotation\n     * @returns a new Vector3\n     */\n    applyRotationQuaternion(q) {\n        return this.applyRotationQuaternionToRef(q, new this.constructor());\n    }\n    /**\n     * Scale the current Vector3 values by a factor and add the result to a given Vector3\n     * Example Playground https://playground.babylonjs.com/#R1F8YU#55\n     * @param scale defines the scale factor\n     * @param result defines the Vector3 object where to store the result\n     * @returns result input\n     */\n    scaleAndAddToRef(scale, result) {\n        return result.addInPlaceFromFloats(this._x * scale, this._y * scale, this._z * scale);\n    }\n    /**\n     * Projects the current point Vector3 to a plane along a ray starting from a specified origin and passing through the current point Vector3.\n     * Example Playground https://playground.babylonjs.com/#R1F8YU#48\n     * @param plane defines the plane to project to\n     * @param origin defines the origin of the projection ray\n     * @returns the projected vector3\n     */\n    projectOnPlane(plane, origin) {\n        const result = new this.constructor();\n        this.projectOnPlaneToRef(plane, origin, result);\n        return result;\n    }\n    /**\n     * Projects the current point Vector3 to a plane along a ray starting from a specified origin and passing through the current point Vector3.\n     * Example Playground https://playground.babylonjs.com/#R1F8YU#49\n     * @param plane defines the plane to project to\n     * @param origin defines the origin of the projection ray\n     * @param result defines the Vector3 where to store the result\n     * @returns result input\n     */\n    projectOnPlaneToRef(plane, origin, result) {\n        const n = plane.normal;\n        const d = plane.d;\n        const V = MathTmp.Vector3[0];\n        // ray direction\n        this.subtractToRef(origin, V);\n        V.normalize();\n        const denom = Vector3.Dot(V, n);\n        //When the ray is close to parallel to the plane return infinity vector\n        if (Math.abs(denom) < Math.pow(10, -10)) {\n            result.setAll(Infinity);\n        }\n        else {\n            const t = -(Vector3.Dot(origin, n) + d) / denom;\n            // P = P0 + t*V\n            const scaledV = V.scaleInPlace(t);\n            origin.addToRef(scaledV, result);\n        }\n        return result;\n    }\n    /**\n     * Returns true if the current Vector3 and the given vector coordinates are strictly equal\n     * Example Playground https://playground.babylonjs.com/#R1F8YU#19\n     * @param otherVector defines the second operand\n     * @returns true if both vectors are equals\n     */\n    equals(otherVector) {\n        return otherVector && this._x === otherVector._x && this._y === otherVector._y && this._z === otherVector._z;\n    }\n    /**\n     * Returns true if the current Vector3 and the given vector coordinates are distant less than epsilon\n     * Example Playground https://playground.babylonjs.com/#R1F8YU#21\n     * @param otherVector defines the second operand\n     * @param epsilon defines the minimal distance to define values as equals\n     * @returns true if both vectors are distant less than epsilon\n     */\n    equalsWithEpsilon(otherVector, epsilon = Epsilon) {\n        return (otherVector &&\n            Scalar.WithinEpsilon(this._x, otherVector._x, epsilon) &&\n            Scalar.WithinEpsilon(this._y, otherVector._y, epsilon) &&\n            Scalar.WithinEpsilon(this._z, otherVector._z, epsilon));\n    }\n    /**\n     * Returns true if the current Vector3 coordinates equals the given floats\n     * Example Playground https://playground.babylonjs.com/#R1F8YU#20\n     * @param x defines the x coordinate of the operand\n     * @param y defines the y coordinate of the operand\n     * @param z defines the z coordinate of the operand\n     * @returns true if both vectors are equal\n     */\n    equalsToFloats(x, y, z) {\n        return this._x === x && this._y === y && this._z === z;\n    }\n    /**\n     * Multiplies the current Vector3 coordinates by the given ones\n     * Example Playground https://playground.babylonjs.com/#R1F8YU#32\n     * @param otherVector defines the second operand\n     * @returns the current updated Vector3\n     */\n    multiplyInPlace(otherVector) {\n        this._x *= otherVector._x;\n        this._y *= otherVector._y;\n        this._z *= otherVector._z;\n        this._isDirty = true;\n        return this;\n    }\n    /**\n     * Returns a new Vector3, result of the multiplication of the current Vector3 by the given vector\n     * Example Playground https://playground.babylonjs.com/#R1F8YU#31\n     * @param otherVector defines the second operand\n     * @returns the new Vector3\n     */\n    multiply(otherVector) {\n        return this.multiplyByFloats(otherVector._x, otherVector._y, otherVector._z);\n    }\n    /**\n     * Multiplies the current Vector3 by the given one and stores the result in the given vector \"result\"\n     * Example Playground https://playground.babylonjs.com/#R1F8YU#33\n     * @param otherVector defines the second operand\n     * @param result defines the Vector3 object where to store the result\n     * @returns the result\n     */\n    multiplyToRef(otherVector, result) {\n        return result.copyFromFloats(this._x * otherVector._x, this._y * otherVector._y, this._z * otherVector._z);\n    }\n    /**\n     * Returns a new Vector3 set with the result of the multiplication of the current Vector3 coordinates by the given floats\n     * Example Playground https://playground.babylonjs.com/#R1F8YU#34\n     * @param x defines the x coordinate of the operand\n     * @param y defines the y coordinate of the operand\n     * @param z defines the z coordinate of the operand\n     * @returns the new Vector3\n     */\n    multiplyByFloats(x, y, z) {\n        return new this.constructor(this._x * x, this._y * y, this._z * z);\n    }\n    /**\n     * Returns a new Vector3 set with the result of the division of the current Vector3 coordinates by the given ones\n     * Example Playground https://playground.babylonjs.com/#R1F8YU#16\n     * @param otherVector defines the second operand\n     * @returns the new Vector3\n     */\n    divide(otherVector) {\n        return new this.constructor(this._x / otherVector._x, this._y / otherVector._y, this._z / otherVector._z);\n    }\n    /**\n     * Divides the current Vector3 coordinates by the given ones and stores the result in the given vector \"result\"\n     * Example Playground https://playground.babylonjs.com/#R1F8YU#18\n     * @param otherVector defines the second operand\n     * @param result defines the Vector3 object where to store the result\n     * @returns the result\n     */\n    divideToRef(otherVector, result) {\n        return result.copyFromFloats(this._x / otherVector._x, this._y / otherVector._y, this._z / otherVector._z);\n    }\n    /**\n     * Divides the current Vector3 coordinates by the given ones.\n     * Example Playground https://playground.babylonjs.com/#R1F8YU#17\n     * @param otherVector defines the second operand\n     * @returns the current updated Vector3\n     */\n    divideInPlace(otherVector) {\n        return this.divideToRef(otherVector, this);\n    }\n    /**\n     * Updates the current Vector3 with the minimal coordinate values between its and the given vector ones\n     * Example Playground https://playground.babylonjs.com/#R1F8YU#29\n     * @param other defines the second operand\n     * @returns the current updated Vector3\n     */\n    minimizeInPlace(other) {\n        return this.minimizeInPlaceFromFloats(other._x, other._y, other._z);\n    }\n    /**\n     * Updates the current Vector3 with the maximal coordinate values between its and the given vector ones.\n     * Example Playground https://playground.babylonjs.com/#R1F8YU#27\n     * @param other defines the second operand\n     * @returns the current updated Vector3\n     */\n    maximizeInPlace(other) {\n        return this.maximizeInPlaceFromFloats(other._x, other._y, other._z);\n    }\n    /**\n     * Updates the current Vector3 with the minimal coordinate values between its and the given coordinates\n     * Example Playground https://playground.babylonjs.com/#R1F8YU#30\n     * @param x defines the x coordinate of the operand\n     * @param y defines the y coordinate of the operand\n     * @param z defines the z coordinate of the operand\n     * @returns the current updated Vector3\n     */\n    minimizeInPlaceFromFloats(x, y, z) {\n        if (x < this._x) {\n            this.x = x;\n        }\n        if (y < this._y) {\n            this.y = y;\n        }\n        if (z < this._z) {\n            this.z = z;\n        }\n        return this;\n    }\n    /**\n     * Updates the current Vector3 with the maximal coordinate values between its and the given coordinates.\n     * Example Playground https://playground.babylonjs.com/#R1F8YU#28\n     * @param x defines the x coordinate of the operand\n     * @param y defines the y coordinate of the operand\n     * @param z defines the z coordinate of the operand\n     * @returns the current updated Vector3\n     */\n    maximizeInPlaceFromFloats(x, y, z) {\n        if (x > this._x) {\n            this.x = x;\n        }\n        if (y > this._y) {\n            this.y = y;\n        }\n        if (z > this._z) {\n            this.z = z;\n        }\n        return this;\n    }\n    /**\n     * Due to float precision, scale of a mesh could be uniform but float values are off by a small fraction\n     * Check if is non uniform within a certain amount of decimal places to account for this\n     * @param epsilon the amount the values can differ\n     * @returns if the the vector is non uniform to a certain number of decimal places\n     */\n    isNonUniformWithinEpsilon(epsilon) {\n        const absX = Math.abs(this._x);\n        const absY = Math.abs(this._y);\n        if (!Scalar.WithinEpsilon(absX, absY, epsilon)) {\n            return true;\n        }\n        const absZ = Math.abs(this._z);\n        if (!Scalar.WithinEpsilon(absX, absZ, epsilon)) {\n            return true;\n        }\n        if (!Scalar.WithinEpsilon(absY, absZ, epsilon)) {\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Gets a boolean indicating that the vector is non uniform meaning x, y or z are not all the same\n     */\n    get isNonUniform() {\n        const absX = Math.abs(this._x);\n        const absY = Math.abs(this._y);\n        if (absX !== absY) {\n            return true;\n        }\n        const absZ = Math.abs(this._z);\n        if (absX !== absZ) {\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Gets a new Vector3 from current Vector3 floored values\n     * Example Playground https://playground.babylonjs.com/#R1F8YU#22\n     * @returns a new Vector3\n     */\n    floor() {\n        return new this.constructor(Math.floor(this._x), Math.floor(this._y), Math.floor(this._z));\n    }\n    /**\n     * Gets a new Vector3 from current Vector3 fractional values\n     * Example Playground https://playground.babylonjs.com/#R1F8YU#23\n     * @returns a new Vector3\n     */\n    fract() {\n        return new this.constructor(this._x - Math.floor(this._x), this._y - Math.floor(this._y), this._z - Math.floor(this._z));\n    }\n    // Properties\n    /**\n     * Gets the length of the Vector3\n     * Example Playground https://playground.babylonjs.com/#R1F8YU#25\n     * @returns the length of the Vector3\n     */\n    length() {\n        return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z);\n    }\n    /**\n     * Gets the squared length of the Vector3\n     * Example Playground https://playground.babylonjs.com/#R1F8YU#26\n     * @returns squared length of the Vector3\n     */\n    lengthSquared() {\n        return this._x * this._x + this._y * this._y + this._z * this._z;\n    }\n    /**\n     * Gets a boolean indicating if the vector contains a zero in one of its components\n     * Example Playground https://playground.babylonjs.com/#R1F8YU#1\n     */\n    get hasAZeroComponent() {\n        return this._x * this._y * this._z === 0;\n    }\n    /**\n     * Normalize the current Vector3.\n     * Please note that this is an in place operation.\n     * Example Playground https://playground.babylonjs.com/#R1F8YU#122\n     * @returns the current updated Vector3\n     */\n    normalize() {\n        return this.normalizeFromLength(this.length());\n    }\n    /**\n     * Reorders the x y z properties of the vector in place\n     * Example Playground https://playground.babylonjs.com/#R1F8YU#44\n     * @param order new ordering of the properties (eg. for vector 1,2,3 with \"ZYX\" will produce 3,2,1)\n     * @returns the current updated vector\n     */\n    reorderInPlace(order) {\n        order = order.toLowerCase();\n        if (order === \"xyz\") {\n            return this;\n        }\n        MathTmp.Vector3[0].copyFrom(this);\n        [\"x\", \"y\", \"z\"].forEach((val, i) => {\n            this[val] = MathTmp.Vector3[0][order[i]];\n        });\n        return this;\n    }\n    /**\n     * Rotates the vector around 0,0,0 by a quaternion\n     * Example Playground https://playground.babylonjs.com/#R1F8YU#47\n     * @param quaternion the rotation quaternion\n     * @param result vector to store the result\n     * @returns the resulting vector\n     */\n    rotateByQuaternionToRef(quaternion, result) {\n        quaternion.toRotationMatrix(MathTmp.Matrix[0]);\n        Vector3.TransformCoordinatesToRef(this, MathTmp.Matrix[0], result);\n        return result;\n    }\n    /**\n     * Rotates a vector around a given point\n     * Example Playground https://playground.babylonjs.com/#R1F8YU#46\n     * @param quaternion the rotation quaternion\n     * @param point the point to rotate around\n     * @param result vector to store the result\n     * @returns the resulting vector\n     */\n    rotateByQuaternionAroundPointToRef(quaternion, point, result) {\n        this.subtractToRef(point, MathTmp.Vector3[0]);\n        MathTmp.Vector3[0].rotateByQuaternionToRef(quaternion, MathTmp.Vector3[0]);\n        point.addToRef(MathTmp.Vector3[0], result);\n        return result;\n    }\n    /**\n     * Returns a new Vector3 as the cross product of the current vector and the \"other\" one\n     * The cross product is then orthogonal to both current and \"other\"\n     * Example Playground https://playground.babylonjs.com/#R1F8YU#14\n     * @param other defines the right operand\n     * @returns the cross product\n     */\n    cross(other) {\n        const result = new this.constructor();\n        return Vector3.CrossToRef(this, other, result);\n    }\n    /**\n     * Normalize the current Vector3 with the given input length.\n     * Please note that this is an in place operation.\n     * Example Playground https://playground.babylonjs.com/#R1F8YU#123\n     * @param len the length of the vector\n     * @returns the current updated Vector3\n     */\n    normalizeFromLength(len) {\n        if (len === 0 || len === 1.0) {\n            return this;\n        }\n        return this.scaleInPlace(1.0 / len);\n    }\n    /**\n     * Normalize the current Vector3 to a new vector\n     * Example Playground https://playground.babylonjs.com/#R1F8YU#124\n     * @returns the new Vector3\n     */\n    normalizeToNew() {\n        const normalized = new this.constructor(0, 0, 0);\n        this.normalizeToRef(normalized);\n        return normalized;\n    }\n    /**\n     * Normalize the current Vector3 to the reference\n     * Example Playground https://playground.babylonjs.com/#R1F8YU#125\n     * @param reference define the Vector3 to update\n     * @returns the updated Vector3\n     */\n    normalizeToRef(reference) {\n        const len = this.length();\n        if (len === 0 || len === 1.0) {\n            return reference.copyFromFloats(this._x, this._y, this._z);\n        }\n        return this.scaleToRef(1.0 / len, reference);\n    }\n    /**\n     * Creates a new Vector3 copied from the current Vector3\n     * Example Playground https://playground.babylonjs.com/#R1F8YU#11\n     * @returns the new Vector3\n     */\n    clone() {\n        return new this.constructor(this._x, this._y, this._z);\n    }\n    /**\n     * Copies the given vector coordinates to the current Vector3 ones\n     * Example Playground https://playground.babylonjs.com/#R1F8YU#12\n     * @param source defines the source Vector3\n     * @returns the current updated Vector3\n     */\n    copyFrom(source) {\n        return this.copyFromFloats(source._x, source._y, source._z);\n    }\n    /**\n     * Copies the given floats to the current Vector3 coordinates\n     * Example Playground https://playground.babylonjs.com/#R1F8YU#13\n     * @param x defines the x coordinate of the operand\n     * @param y defines the y coordinate of the operand\n     * @param z defines the z coordinate of the operand\n     * @returns the current updated Vector3\n     */\n    copyFromFloats(x, y, z) {\n        this._x = x;\n        this._y = y;\n        this._z = z;\n        this._isDirty = true;\n        return this;\n    }\n    /**\n     * Copies the given floats to the current Vector3 coordinates\n     * Example Playground https://playground.babylonjs.com/#R1F8YU#58\n     * @param x defines the x coordinate of the operand\n     * @param y defines the y coordinate of the operand\n     * @param z defines the z coordinate of the operand\n     * @returns the current updated Vector3\n     */\n    set(x, y, z) {\n        return this.copyFromFloats(x, y, z);\n    }\n    /**\n     * Copies the given float to the current Vector3 coordinates\n     * Example Playground https://playground.babylonjs.com/#R1F8YU#59\n     * @param v defines the x, y and z coordinates of the operand\n     * @returns the current updated Vector3\n     */\n    setAll(v) {\n        this._x = this._y = this._z = v;\n        this._isDirty = true;\n        return this;\n    }\n    // Statics\n    /**\n     * Get the clip factor between two vectors\n     * Example Playground https://playground.babylonjs.com/#R1F8YU#126\n     * @param vector0 defines the first operand\n     * @param vector1 defines the second operand\n     * @param axis defines the axis to use\n     * @param size defines the size along the axis\n     * @returns the clip factor\n     */\n    static GetClipFactor(vector0, vector1, axis, size) {\n        const d0 = Vector3.Dot(vector0, axis) - size;\n        const d1 = Vector3.Dot(vector1, axis) - size;\n        const s = d0 / (d0 - d1);\n        return s;\n    }\n    /**\n     * Get angle between two vectors\n     * Example Playground https://playground.babylonjs.com/#R1F8YU#86\n     * @param vector0 the starting point\n     * @param vector1 the ending point\n     * @param normal direction of the normal\n     * @returns the angle between vector0 and vector1\n     */\n    static GetAngleBetweenVectors(vector0, vector1, normal) {\n        const v0 = vector0.normalizeToRef(MathTmp.Vector3[1]);\n        const v1 = vector1.normalizeToRef(MathTmp.Vector3[2]);\n        let dot = Vector3.Dot(v0, v1);\n        // Vectors are normalized so dot will be in [-1, 1] (aside precision issues enough to break the result which explains the below clamp)\n        dot = Scalar.Clamp(dot, -1, 1);\n        const angle = Math.acos(dot);\n        const n = MathTmp.Vector3[3];\n        Vector3.CrossToRef(v0, v1, n);\n        if (Vector3.Dot(n, normal) > 0) {\n            return isNaN(angle) ? 0 : angle;\n        }\n        return isNaN(angle) ? -Math.PI : -Math.acos(dot);\n    }\n    /**\n     * Get angle between two vectors projected on a plane\n     * Example Playground https://playground.babylonjs.com/#R1F8YU#87\n     * Expectation compute time: 0.01 ms (median) and 0.02 ms (percentile 95%)\n     * @param vector0 angle between vector0 and vector1\n     * @param vector1 angle between vector0 and vector1\n     * @param normal Normal of the projection plane\n     * @returns the angle in radians (float) between vector0 and vector1 projected on the plane with the specified normal\n     */\n    static GetAngleBetweenVectorsOnPlane(vector0, vector1, normal) {\n        MathTmp.Vector3[0].copyFrom(vector0);\n        const v0 = MathTmp.Vector3[0];\n        MathTmp.Vector3[1].copyFrom(vector1);\n        const v1 = MathTmp.Vector3[1];\n        MathTmp.Vector3[2].copyFrom(normal);\n        const vNormal = MathTmp.Vector3[2];\n        const right = MathTmp.Vector3[3];\n        const forward = MathTmp.Vector3[4];\n        v0.normalize();\n        v1.normalize();\n        vNormal.normalize();\n        Vector3.CrossToRef(vNormal, v0, right);\n        Vector3.CrossToRef(right, vNormal, forward);\n        const angle = Math.atan2(Vector3.Dot(v1, right), Vector3.Dot(v1, forward));\n        return Scalar.NormalizeRadians(angle);\n    }\n    /**\n     * Gets the rotation that aligns the roll axis (Y) to the line joining the start point to the target point and stores it in the ref Vector3\n     * Example PG https://playground.babylonjs.com/#R1F8YU#189\n     * @param start the starting point\n     * @param target the target point\n     * @param ref the vector3 to store the result\n     * @returns ref in the form (pitch, yaw, 0)\n     */\n    static PitchYawRollToMoveBetweenPointsToRef(start, target, ref) {\n        const diff = TmpVectors.Vector3[0];\n        target.subtractToRef(start, diff);\n        ref._y = Math.atan2(diff.x, diff.z) || 0;\n        ref._x = Math.atan2(Math.sqrt(diff.x ** 2 + diff.z ** 2), diff.y) || 0;\n        ref._z = 0;\n        ref._isDirty = true;\n        return ref;\n    }\n    /**\n     * Gets the rotation that aligns the roll axis (Y) to the line joining the start point to the target point\n     * Example PG https://playground.babylonjs.com/#R1F8YU#188\n     * @param start the starting point\n     * @param target the target point\n     * @returns the rotation in the form (pitch, yaw, 0)\n     */\n    static PitchYawRollToMoveBetweenPoints(start, target) {\n        const ref = Vector3.Zero();\n        return Vector3.PitchYawRollToMoveBetweenPointsToRef(start, target, ref);\n    }\n    /**\n     * Slerp between two vectors. See also `SmoothToRef`\n     * Slerp is a spherical linear interpolation\n     * giving a slow in and out effect\n     * Example Playground 1 https://playground.babylonjs.com/#R1F8YU#108\n     * Example Playground 2 https://playground.babylonjs.com/#R1F8YU#109\n     * @param vector0 Start vector\n     * @param vector1 End vector\n     * @param slerp amount (will be clamped between 0 and 1)\n     * @param result The slerped vector\n     */\n    static SlerpToRef(vector0, vector1, slerp, result) {\n        slerp = Scalar.Clamp(slerp, 0, 1);\n        const vector0Dir = MathTmp.Vector3[0];\n        const vector1Dir = MathTmp.Vector3[1];\n        vector0Dir.copyFrom(vector0);\n        const vector0Length = vector0Dir.length();\n        vector0Dir.normalizeFromLength(vector0Length);\n        vector1Dir.copyFrom(vector1);\n        const vector1Length = vector1Dir.length();\n        vector1Dir.normalizeFromLength(vector1Length);\n        const dot = Vector3.Dot(vector0Dir, vector1Dir);\n        let scale0;\n        let scale1;\n        if (dot < 1 - Epsilon) {\n            const omega = Math.acos(dot);\n            const invSin = 1 / Math.sin(omega);\n            scale0 = Math.sin((1 - slerp) * omega) * invSin;\n            scale1 = Math.sin(slerp * omega) * invSin;\n        }\n        else {\n            // Use linear interpolation\n            scale0 = 1 - slerp;\n            scale1 = slerp;\n        }\n        vector0Dir.scaleInPlace(scale0);\n        vector1Dir.scaleInPlace(scale1);\n        result.copyFrom(vector0Dir).addInPlace(vector1Dir);\n        result.scaleInPlace(Scalar.Lerp(vector0Length, vector1Length, slerp));\n        return result;\n    }\n    /**\n     * Smooth interpolation between two vectors using Slerp\n     * Example Playground https://playground.babylonjs.com/#R1F8YU#110\n     * @param source source vector\n     * @param goal goal vector\n     * @param deltaTime current interpolation frame\n     * @param lerpTime total interpolation time\n     * @param result the smoothed vector\n     */\n    static SmoothToRef(source, goal, deltaTime, lerpTime, result) {\n        Vector3.SlerpToRef(source, goal, lerpTime === 0 ? 1 : deltaTime / lerpTime, result);\n        return result;\n    }\n    /**\n     * Returns a new Vector3 set from the index \"offset\" of the given array\n     * Example Playground https://playground.babylonjs.com/#R1F8YU#83\n     * @param array defines the source array\n     * @param offset defines the offset in the source array\n     * @returns the new Vector3\n     */\n    static FromArray(array, offset = 0) {\n        return new Vector3(array[offset], array[offset + 1], array[offset + 2]);\n    }\n    /**\n     * Returns a new Vector3 set from the index \"offset\" of the given Float32Array\n     * @param array defines the source array\n     * @param offset defines the offset in the source array\n     * @returns the new Vector3\n     * @deprecated Please use FromArray instead.\n     */\n    static FromFloatArray(array, offset) {\n        return Vector3.FromArray(array, offset);\n    }\n    /**\n     * Sets the given vector \"result\" with the element values from the index \"offset\" of the given array\n     * Example Playground https://playground.babylonjs.com/#R1F8YU#84\n     * @param array defines the source array\n     * @param offset defines the offset in the source array\n     * @param result defines the Vector3 where to store the result\n     * @returns result input\n     */\n    static FromArrayToRef(array, offset, result) {\n        result._x = array[offset];\n        result._y = array[offset + 1];\n        result._z = array[offset + 2];\n        result._isDirty = true;\n        return result;\n    }\n    /**\n     * Sets the given vector \"result\" with the element values from the index \"offset\" of the given Float32Array\n     * @param array defines the source array\n     * @param offset defines the offset in the source array\n     * @param result defines the Vector3 where to store the result\n     * @deprecated Please use FromArrayToRef instead.\n     */\n    static FromFloatArrayToRef(array, offset, result) {\n        return Vector3.FromArrayToRef(array, offset, result);\n    }\n    /**\n     * Sets the given vector \"result\" with the given floats.\n     * Example Playground https://playground.babylonjs.com/#R1F8YU#85\n     * @param x defines the x coordinate of the source\n     * @param y defines the y coordinate of the source\n     * @param z defines the z coordinate of the source\n     * @param result defines the Vector3 where to store the result\n     */\n    static FromFloatsToRef(x, y, z, result) {\n        result.copyFromFloats(x, y, z);\n        return result;\n    }\n    /**\n     * Returns a new Vector3 set to (0.0, 0.0, 0.0)\n     * @returns a new empty Vector3\n     */\n    static Zero() {\n        return new Vector3(0.0, 0.0, 0.0);\n    }\n    /**\n     * Returns a new Vector3 set to (1.0, 1.0, 1.0)\n     * @returns a new Vector3\n     */\n    static One() {\n        return new Vector3(1.0, 1.0, 1.0);\n    }\n    /**\n     * Returns a new Vector3 set to (0.0, 1.0, 0.0)\n     * Example Playground https://playground.babylonjs.com/#R1F8YU#71\n     * @returns a new up Vector3\n     */\n    static Up() {\n        return new Vector3(0.0, 1.0, 0.0);\n    }\n    /**\n     * Gets an up Vector3 that must not be updated\n     */\n    static get UpReadOnly() {\n        return Vector3._UpReadOnly;\n    }\n    /**\n     * Gets a down Vector3 that must not be updated\n     */\n    static get DownReadOnly() {\n        return Vector3._DownReadOnly;\n    }\n    /**\n     * Gets a right Vector3 that must not be updated\n     */\n    static get RightReadOnly() {\n        return Vector3._RightReadOnly;\n    }\n    /**\n     * Gets a left Vector3 that must not be updated\n     */\n    static get LeftReadOnly() {\n        return Vector3._LeftReadOnly;\n    }\n    /**\n     * Gets a forward Vector3 that must not be updated\n     */\n    static get LeftHandedForwardReadOnly() {\n        return Vector3._LeftHandedForwardReadOnly;\n    }\n    /**\n     * Gets a forward Vector3 that must not be updated\n     */\n    static get RightHandedForwardReadOnly() {\n        return Vector3._RightHandedForwardReadOnly;\n    }\n    /**\n     * Gets a zero Vector3 that must not be updated\n     */\n    static get ZeroReadOnly() {\n        return Vector3._ZeroReadOnly;\n    }\n    /**\n     * Returns a new Vector3 set to (0.0, -1.0, 0.0)\n     * Example Playground https://playground.babylonjs.com/#R1F8YU#71\n     * @returns a new down Vector3\n     */\n    static Down() {\n        return new Vector3(0.0, -1.0, 0.0);\n    }\n    /**\n     * Returns a new Vector3 set to (0.0, 0.0, 1.0)\n     * Example Playground https://playground.babylonjs.com/#R1F8YU#71\n     * @param rightHandedSystem is the scene right-handed (negative z)\n     * @returns a new forward Vector3\n     */\n    static Forward(rightHandedSystem = false) {\n        return new Vector3(0.0, 0.0, rightHandedSystem ? -1.0 : 1.0);\n    }\n    /**\n     * Returns a new Vector3 set to (0.0, 0.0, -1.0)\n     * Example Playground https://playground.babylonjs.com/#R1F8YU#71\n     * @param rightHandedSystem is the scene right-handed (negative-z)\n     * @returns a new Backward Vector3\n     */\n    static Backward(rightHandedSystem = false) {\n        return new Vector3(0.0, 0.0, rightHandedSystem ? 1.0 : -1.0);\n    }\n    /**\n     * Returns a new Vector3 set to (1.0, 0.0, 0.0)\n     * Example Playground https://playground.babylonjs.com/#R1F8YU#71\n     * @returns a new right Vector3\n     */\n    static Right() {\n        return new Vector3(1.0, 0.0, 0.0);\n    }\n    /**\n     * Returns a new Vector3 set to (-1.0, 0.0, 0.0)\n     * Example Playground https://playground.babylonjs.com/#R1F8YU#71\n     * @returns a new left Vector3\n     */\n    static Left() {\n        return new Vector3(-1.0, 0.0, 0.0);\n    }\n    /**\n     * Returns a new Vector3 with random values between min and max\n     * @param min the minimum random value\n     * @param max the maximum random value\n     * @returns a Vector3 with random values between min and max\n     */\n    static Random(min = 0, max = 1) {\n        return new Vector3(Scalar.RandomRange(min, max), Scalar.RandomRange(min, max), Scalar.RandomRange(min, max));\n    }\n    /**\n     * Returns a new Vector3 set with the result of the transformation by the given matrix of the given vector.\n     * This method computes transformed coordinates only, not transformed direction vectors (ie. it takes translation in account)\n     * Example Playground https://playground.babylonjs.com/#R1F8YU#111\n     * @param vector defines the Vector3 to transform\n     * @param transformation defines the transformation matrix\n     * @returns the transformed Vector3\n     */\n    static TransformCoordinates(vector, transformation) {\n        const result = Vector3.Zero();\n        Vector3.TransformCoordinatesToRef(vector, transformation, result);\n        return result;\n    }\n    /**\n     * Sets the given vector \"result\" coordinates with the result of the transformation by the given matrix of the given vector\n     * This method computes transformed coordinates only, not transformed direction vectors (ie. it takes translation in account)\n     * Example Playground https://playground.babylonjs.com/#R1F8YU#113\n     * @param vector defines the Vector3 to transform\n     * @param transformation defines the transformation matrix\n     * @param result defines the Vector3 where to store the result\n     * @returns result input\n     */\n    static TransformCoordinatesToRef(vector, transformation, result) {\n        Vector3.TransformCoordinatesFromFloatsToRef(vector._x, vector._y, vector._z, transformation, result);\n        return result;\n    }\n    /**\n     * Sets the given vector \"result\" coordinates with the result of the transformation by the given matrix of the given floats (x, y, z)\n     * This method computes transformed coordinates only, not transformed direction vectors\n     * Example Playground https://playground.babylonjs.com/#R1F8YU#115\n     * @param x define the x coordinate of the source vector\n     * @param y define the y coordinate of the source vector\n     * @param z define the z coordinate of the source vector\n     * @param transformation defines the transformation matrix\n     * @param result defines the Vector3 where to store the result\n     * @returns result input\n     */\n    static TransformCoordinatesFromFloatsToRef(x, y, z, transformation, result) {\n        const m = transformation.m;\n        const rx = x * m[0] + y * m[4] + z * m[8] + m[12];\n        const ry = x * m[1] + y * m[5] + z * m[9] + m[13];\n        const rz = x * m[2] + y * m[6] + z * m[10] + m[14];\n        const rw = 1 / (x * m[3] + y * m[7] + z * m[11] + m[15]);\n        result._x = rx * rw;\n        result._y = ry * rw;\n        result._z = rz * rw;\n        result._isDirty = true;\n        return result;\n    }\n    /**\n     * Returns a new Vector3 set with the result of the normal transformation by the given matrix of the given vector\n     * This methods computes transformed normalized direction vectors only (ie. it does not apply translation)\n     * Example Playground https://playground.babylonjs.com/#R1F8YU#112\n     * @param vector defines the Vector3 to transform\n     * @param transformation defines the transformation matrix\n     * @returns the new Vector3\n     */\n    static TransformNormal(vector, transformation) {\n        const result = Vector3.Zero();\n        Vector3.TransformNormalToRef(vector, transformation, result);\n        return result;\n    }\n    /**\n     * Sets the given vector \"result\" with the result of the normal transformation by the given matrix of the given vector\n     * This methods computes transformed normalized direction vectors only (ie. it does not apply translation)\n     * Example Playground https://playground.babylonjs.com/#R1F8YU#114\n     * @param vector defines the Vector3 to transform\n     * @param transformation defines the transformation matrix\n     * @param result defines the Vector3 where to store the result\n     * @returns result input\n     */\n    static TransformNormalToRef(vector, transformation, result) {\n        this.TransformNormalFromFloatsToRef(vector._x, vector._y, vector._z, transformation, result);\n        return result;\n    }\n    /**\n     * Sets the given vector \"result\" with the result of the normal transformation by the given matrix of the given floats (x, y, z)\n     * This methods computes transformed normalized direction vectors only (ie. it does not apply translation)\n     * Example Playground https://playground.babylonjs.com/#R1F8YU#116\n     * @param x define the x coordinate of the source vector\n     * @param y define the y coordinate of the source vector\n     * @param z define the z coordinate of the source vector\n     * @param transformation defines the transformation matrix\n     * @param result defines the Vector3 where to store the result\n     * @returns result input\n     */\n    static TransformNormalFromFloatsToRef(x, y, z, transformation, result) {\n        const m = transformation.m;\n        result._x = x * m[0] + y * m[4] + z * m[8];\n        result._y = x * m[1] + y * m[5] + z * m[9];\n        result._z = x * m[2] + y * m[6] + z * m[10];\n        result._isDirty = true;\n        return result;\n    }\n    /**\n     * Returns a new Vector3 located for \"amount\" on the CatmullRom interpolation spline defined by the vectors \"value1\", \"value2\", \"value3\", \"value4\"\n     * Example Playground https://playground.babylonjs.com/#R1F8YU#69\n     * @param value1 defines the first control point\n     * @param value2 defines the second control point\n     * @param value3 defines the third control point\n     * @param value4 defines the fourth control point\n     * @param amount defines the amount on the spline to use\n     * @returns the new Vector3\n     */\n    static CatmullRom(value1, value2, value3, value4, amount) {\n        const squared = amount * amount;\n        const cubed = amount * squared;\n        const x = 0.5 *\n            (2.0 * value2._x +\n                (-value1._x + value3._x) * amount +\n                (2.0 * value1._x - 5.0 * value2._x + 4.0 * value3._x - value4._x) * squared +\n                (-value1._x + 3.0 * value2._x - 3.0 * value3._x + value4._x) * cubed);\n        const y = 0.5 *\n            (2.0 * value2._y +\n                (-value1._y + value3._y) * amount +\n                (2.0 * value1._y - 5.0 * value2._y + 4.0 * value3._y - value4._y) * squared +\n                (-value1._y + 3.0 * value2._y - 3.0 * value3._y + value4._y) * cubed);\n        const z = 0.5 *\n            (2.0 * value2._z +\n                (-value1._z + value3._z) * amount +\n                (2.0 * value1._z - 5.0 * value2._z + 4.0 * value3._z - value4._z) * squared +\n                (-value1._z + 3.0 * value2._z - 3.0 * value3._z + value4._z) * cubed);\n        return new value1.constructor(x, y, z);\n    }\n    /**\n     * Returns a new Vector3 set with the coordinates of \"value\", if the vector \"value\" is in the cube defined by the vectors \"min\" and \"max\"\n     * If a coordinate value of \"value\" is lower than one of the \"min\" coordinate, then this \"value\" coordinate is set with the \"min\" one\n     * If a coordinate value of \"value\" is greater than one of the \"max\" coordinate, then this \"value\" coordinate is set with the \"max\" one\n     * Example Playground https://playground.babylonjs.com/#R1F8YU#76\n     * @param value defines the current value\n     * @param min defines the lower range value\n     * @param max defines the upper range value\n     * @returns the new Vector3\n     */\n    static Clamp(value, min, max) {\n        const result = new value.constructor();\n        Vector3.ClampToRef(value, min, max, result);\n        return result;\n    }\n    /**\n     * Sets the given vector \"result\" with the coordinates of \"value\", if the vector \"value\" is in the cube defined by the vectors \"min\" and \"max\"\n     * If a coordinate value of \"value\" is lower than one of the \"min\" coordinate, then this \"value\" coordinate is set with the \"min\" one\n     * If a coordinate value of \"value\" is greater than one of the \"max\" coordinate, then this \"value\" coordinate is set with the \"max\" one\n     * Example Playground https://playground.babylonjs.com/#R1F8YU#77\n     * @param value defines the current value\n     * @param min defines the lower range value\n     * @param max defines the upper range value\n     * @param result defines the Vector3 where to store the result\n     * @returns result input\n     */\n    static ClampToRef(value, min, max, result) {\n        let x = value._x;\n        x = x > max._x ? max._x : x;\n        x = x < min._x ? min._x : x;\n        let y = value._y;\n        y = y > max._y ? max._y : y;\n        y = y < min._y ? min._y : y;\n        let z = value._z;\n        z = z > max._z ? max._z : z;\n        z = z < min._z ? min._z : z;\n        result.copyFromFloats(x, y, z);\n        return result;\n    }\n    /**\n     * Checks if a given vector is inside a specific range\n     * Example Playground https://playground.babylonjs.com/#R1F8YU#75\n     * @param v defines the vector to test\n     * @param min defines the minimum range\n     * @param max defines the maximum range\n     */\n    static CheckExtends(v, min, max) {\n        min.minimizeInPlace(v);\n        max.maximizeInPlace(v);\n    }\n    /**\n     * Returns a new Vector3 located for \"amount\" (float) on the Hermite interpolation spline defined by the vectors \"value1\", \"tangent1\", \"value2\", \"tangent2\"\n     * Example Playground https://playground.babylonjs.com/#R1F8YU#89\n     * @param value1 defines the first control point\n     * @param tangent1 defines the first tangent vector\n     * @param value2 defines the second control point\n     * @param tangent2 defines the second tangent vector\n     * @param amount defines the amount on the interpolation spline (between 0 and 1)\n     * @returns the new Vector3\n     */\n    static Hermite(value1, tangent1, value2, tangent2, amount) {\n        const squared = amount * amount;\n        const cubed = amount * squared;\n        const part1 = 2.0 * cubed - 3.0 * squared + 1.0;\n        const part2 = -2.0 * cubed + 3.0 * squared;\n        const part3 = cubed - 2.0 * squared + amount;\n        const part4 = cubed - squared;\n        const x = value1._x * part1 + value2._x * part2 + tangent1._x * part3 + tangent2._x * part4;\n        const y = value1._y * part1 + value2._y * part2 + tangent1._y * part3 + tangent2._y * part4;\n        const z = value1._z * part1 + value2._z * part2 + tangent1._z * part3 + tangent2._z * part4;\n        return new value1.constructor(x, y, z);\n    }\n    /**\n     * Returns a new Vector3 which is the 1st derivative of the Hermite spline defined by the vectors \"value1\", \"value2\", \"tangent1\", \"tangent2\".\n     * Example Playground https://playground.babylonjs.com/#R1F8YU#90\n     * @param value1 defines the first control point\n     * @param tangent1 defines the first tangent\n     * @param value2 defines the second control point\n     * @param tangent2 defines the second tangent\n     * @param time define where the derivative must be done\n     * @returns 1st derivative\n     */\n    static Hermite1stDerivative(value1, tangent1, value2, tangent2, time) {\n        const result = new value1.constructor();\n        this.Hermite1stDerivativeToRef(value1, tangent1, value2, tangent2, time, result);\n        return result;\n    }\n    /**\n     * Update a Vector3 with the 1st derivative of the Hermite spline defined by the vectors \"value1\", \"value2\", \"tangent1\", \"tangent2\".\n     * Example Playground https://playground.babylonjs.com/#R1F8YU#91\n     * @param value1 defines the first control point\n     * @param tangent1 defines the first tangent\n     * @param value2 defines the second control point\n     * @param tangent2 defines the second tangent\n     * @param time define where the derivative must be done\n     * @param result define where to store the derivative\n     * @returns result input\n     */\n    static Hermite1stDerivativeToRef(value1, tangent1, value2, tangent2, time, result) {\n        const t2 = time * time;\n        result._x = (t2 - time) * 6 * value1._x + (3 * t2 - 4 * time + 1) * tangent1._x + (-t2 + time) * 6 * value2._x + (3 * t2 - 2 * time) * tangent2._x;\n        result._y = (t2 - time) * 6 * value1._y + (3 * t2 - 4 * time + 1) * tangent1._y + (-t2 + time) * 6 * value2._y + (3 * t2 - 2 * time) * tangent2._y;\n        result._z = (t2 - time) * 6 * value1._z + (3 * t2 - 4 * time + 1) * tangent1._z + (-t2 + time) * 6 * value2._z + (3 * t2 - 2 * time) * tangent2._z;\n        result._isDirty = true;\n        return result;\n    }\n    /**\n     * Returns a new Vector3 located for \"amount\" (float) on the linear interpolation between the vectors \"start\" and \"end\"\n     * Example Playground https://playground.babylonjs.com/#R1F8YU#95\n     * @param start defines the start value\n     * @param end defines the end value\n     * @param amount max defines amount between both (between 0 and 1)\n     * @returns the new Vector3\n     */\n    static Lerp(start, end, amount) {\n        const result = new start.constructor(0, 0, 0);\n        Vector3.LerpToRef(start, end, amount, result);\n        return result;\n    }\n    /**\n     * Sets the given vector \"result\" with the result of the linear interpolation from the vector \"start\" for \"amount\" to the vector \"end\"\n     * Example Playground https://playground.babylonjs.com/#R1F8YU#93\n     * @param start defines the start value\n     * @param end defines the end value\n     * @param amount max defines amount between both (between 0 and 1)\n     * @param result defines the Vector3 where to store the result\n     * @returns result input\n     */\n    static LerpToRef(start, end, amount, result) {\n        result._x = start._x + (end._x - start._x) * amount;\n        result._y = start._y + (end._y - start._y) * amount;\n        result._z = start._z + (end._z - start._z) * amount;\n        result._isDirty = true;\n        return result;\n    }\n    /**\n     * Returns the dot product (float) between the vectors \"left\" and \"right\"\n     * Example Playground https://playground.babylonjs.com/#R1F8YU#82\n     * @param left defines the left operand\n     * @param right defines the right operand\n     * @returns the dot product\n     */\n    static Dot(left, right) {\n        return left._x * right._x + left._y * right._y + left._z * right._z;\n    }\n    /**\n     * Returns a new Vector3 as the cross product of the vectors \"left\" and \"right\"\n     * The cross product is then orthogonal to both \"left\" and \"right\"\n     * Example Playground https://playground.babylonjs.com/#R1F8YU#15\n     * @param left defines the left operand\n     * @param right defines the right operand\n     * @returns the cross product\n     */\n    static Cross(left, right) {\n        const result = new left.constructor();\n        Vector3.CrossToRef(left, right, result);\n        return result;\n    }\n    /**\n     * Sets the given vector \"result\" with the cross product of \"left\" and \"right\"\n     * The cross product is then orthogonal to both \"left\" and \"right\"\n     * Example Playground https://playground.babylonjs.com/#R1F8YU#78\n     * @param left defines the left operand\n     * @param right defines the right operand\n     * @param result defines the Vector3 where to store the result\n     * @returns result input\n     */\n    static CrossToRef(left, right, result) {\n        const x = left._y * right._z - left._z * right._y;\n        const y = left._z * right._x - left._x * right._z;\n        const z = left._x * right._y - left._y * right._x;\n        result.copyFromFloats(x, y, z);\n        return result;\n    }\n    /**\n     * Returns a new Vector3 as the normalization of the given vector\n     * Example Playground https://playground.babylonjs.com/#R1F8YU#98\n     * @param vector defines the Vector3 to normalize\n     * @returns the new Vector3\n     */\n    static Normalize(vector) {\n        const result = Vector3.Zero();\n        Vector3.NormalizeToRef(vector, result);\n        return result;\n    }\n    /**\n     * Sets the given vector \"result\" with the normalization of the given first vector\n     * Example Playground https://playground.babylonjs.com/#R1F8YU#98\n     * @param vector defines the Vector3 to normalize\n     * @param result defines the Vector3 where to store the result\n     * @returns result input\n     */\n    static NormalizeToRef(vector, result) {\n        vector.normalizeToRef(result);\n        return result;\n    }\n    /**\n     * Project a Vector3 onto screen space\n     * Example Playground https://playground.babylonjs.com/#R1F8YU#101\n     * @param vector defines the Vector3 to project\n     * @param world defines the world matrix to use\n     * @param transform defines the transform (view x projection) matrix to use\n     * @param viewport defines the screen viewport to use\n     * @returns the new Vector3\n     */\n    static Project(vector, world, transform, viewport) {\n        const result = new vector.constructor();\n        Vector3.ProjectToRef(vector, world, transform, viewport, result);\n        return result;\n    }\n    /**\n     * Project a Vector3 onto screen space to reference\n     * Example Playground https://playground.babylonjs.com/#R1F8YU#102\n     * @param vector defines the Vector3 to project\n     * @param world defines the world matrix to use\n     * @param transform defines the transform (view x projection) matrix to use\n     * @param viewport defines the screen viewport to use\n     * @param result the vector in which the screen space will be stored\n     * @returns result input\n     */\n    static ProjectToRef(vector, world, transform, viewport, result) {\n        const cw = viewport.width;\n        const ch = viewport.height;\n        const cx = viewport.x;\n        const cy = viewport.y;\n        const viewportMatrix = MathTmp.Matrix[1];\n        Matrix.FromValuesToRef(cw / 2.0, 0, 0, 0, 0, -ch / 2.0, 0, 0, 0, 0, 0.5, 0, cx + cw / 2.0, ch / 2.0 + cy, 0.5, 1, viewportMatrix);\n        const matrix = MathTmp.Matrix[0];\n        world.multiplyToRef(transform, matrix);\n        matrix.multiplyToRef(viewportMatrix, matrix);\n        Vector3.TransformCoordinatesToRef(vector, matrix, result);\n        return result;\n    }\n    /**\n     * Reflects a vector off the plane defined by a normalized normal\n     * @param inDirection defines the vector direction\n     * @param normal defines the normal - Must be normalized\n     * @returns the resulting vector\n     */\n    static Reflect(inDirection, normal) {\n        return this.ReflectToRef(inDirection, normal, new Vector3());\n    }\n    /**\n     * Reflects a vector off the plane defined by a normalized normal to reference\n     * @param inDirection defines the vector direction\n     * @param normal defines the normal - Must be normalized\n     * @param result defines the Vector3 where to store the result\n     * @returns the resulting vector\n     */\n    static ReflectToRef(inDirection, normal, ref) {\n        const tmp = TmpVectors.Vector3[0];\n        tmp.copyFrom(normal).scaleInPlace(2 * Vector3.Dot(inDirection, normal));\n        return ref.copyFrom(inDirection).subtractInPlace(tmp);\n    }\n    /**\n     * @internal\n     */\n    static _UnprojectFromInvertedMatrixToRef(source, matrix, result) {\n        Vector3.TransformCoordinatesToRef(source, matrix, result);\n        const m = matrix.m;\n        const num = source._x * m[3] + source._y * m[7] + source._z * m[11] + m[15];\n        if (Scalar.WithinEpsilon(num, 1.0)) {\n            result.scaleInPlace(1.0 / num);\n        }\n        return result;\n    }\n    /**\n     * Unproject from screen space to object space\n     * Example Playground https://playground.babylonjs.com/#R1F8YU#121\n     * @param source defines the screen space Vector3 to use\n     * @param viewportWidth defines the current width of the viewport\n     * @param viewportHeight defines the current height of the viewport\n     * @param world defines the world matrix to use (can be set to Identity to go to world space)\n     * @param transform defines the transform (view x projection) matrix to use\n     * @returns the new Vector3\n     */\n    static UnprojectFromTransform(source, viewportWidth, viewportHeight, world, transform) {\n        return this.Unproject(source, viewportWidth, viewportHeight, world, transform, Matrix.IdentityReadOnly);\n    }\n    /**\n     * Unproject from screen space to object space\n     * Example Playground https://playground.babylonjs.com/#R1F8YU#117\n     * @param source defines the screen space Vector3 to use\n     * @param viewportWidth defines the current width of the viewport\n     * @param viewportHeight defines the current height of the viewport\n     * @param world defines the world matrix to use (can be set to Identity to go to world space)\n     * @param view defines the view matrix to use\n     * @param projection defines the projection matrix to use\n     * @returns the new Vector3\n     */\n    static Unproject(source, viewportWidth, viewportHeight, world, view, projection) {\n        const result = new source.constructor();\n        Vector3.UnprojectToRef(source, viewportWidth, viewportHeight, world, view, projection, result);\n        return result;\n    }\n    /**\n     * Unproject from screen space to object space\n     * Example Playground https://playground.babylonjs.com/#R1F8YU#119\n     * @param source defines the screen space Vector3 to use\n     * @param viewportWidth defines the current width of the viewport\n     * @param viewportHeight defines the current height of the viewport\n     * @param world defines the world matrix to use (can be set to Identity to go to world space)\n     * @param view defines the view matrix to use\n     * @param projection defines the projection matrix to use\n     * @param result defines the Vector3 where to store the result\n     * @returns result input\n     */\n    static UnprojectToRef(source, viewportWidth, viewportHeight, world, view, projection, result) {\n        Vector3.UnprojectFloatsToRef(source._x, source._y, source._z, viewportWidth, viewportHeight, world, view, projection, result);\n        return result;\n    }\n    /**\n     * Unproject from screen space to object space\n     * Example Playground https://playground.babylonjs.com/#R1F8YU#120\n     * @param sourceX defines the screen space x coordinate to use\n     * @param sourceY defines the screen space y coordinate to use\n     * @param sourceZ defines the screen space z coordinate to use\n     * @param viewportWidth defines the current width of the viewport\n     * @param viewportHeight defines the current height of the viewport\n     * @param world defines the world matrix to use (can be set to Identity to go to world space)\n     * @param view defines the view matrix to use\n     * @param projection defines the projection matrix to use\n     * @param result defines the Vector3 where to store the result\n     * @returns result input\n     */\n    static UnprojectFloatsToRef(sourceX, sourceY, sourceZ, viewportWidth, viewportHeight, world, view, projection, result) {\n        var _a;\n        const matrix = MathTmp.Matrix[0];\n        world.multiplyToRef(view, matrix);\n        matrix.multiplyToRef(projection, matrix);\n        matrix.invert();\n        const screenSource = MathTmp.Vector3[0];\n        screenSource.x = (sourceX / viewportWidth) * 2 - 1;\n        screenSource.y = -((sourceY / viewportHeight) * 2 - 1);\n        if ((_a = EngineStore.LastCreatedEngine) === null || _a === void 0 ? void 0 : _a.isNDCHalfZRange) {\n            screenSource.z = sourceZ;\n        }\n        else {\n            screenSource.z = 2 * sourceZ - 1.0;\n        }\n        Vector3._UnprojectFromInvertedMatrixToRef(screenSource, matrix, result);\n        return result;\n    }\n    /**\n     * Gets the minimal coordinate values between two Vector3\n     * Example Playground https://playground.babylonjs.com/#R1F8YU#97\n     * @param left defines the first operand\n     * @param right defines the second operand\n     * @returns the new Vector3\n     */\n    static Minimize(left, right) {\n        const min = new left.constructor();\n        min.copyFrom(left);\n        min.minimizeInPlace(right);\n        return min;\n    }\n    /**\n     * Gets the maximal coordinate values between two Vector3\n     * Example Playground https://playground.babylonjs.com/#R1F8YU#96\n     * @param left defines the first operand\n     * @param right defines the second operand\n     * @returns the new Vector3\n     */\n    static Maximize(left, right) {\n        const max = new left.constructor();\n        max.copyFrom(left);\n        max.maximizeInPlace(right);\n        return max;\n    }\n    /**\n     * Returns the distance between the vectors \"value1\" and \"value2\"\n     * Example Playground https://playground.babylonjs.com/#R1F8YU#81\n     * @param value1 defines the first operand\n     * @param value2 defines the second operand\n     * @returns the distance\n     */\n    static Distance(value1, value2) {\n        return Math.sqrt(Vector3.DistanceSquared(value1, value2));\n    }\n    /**\n     * Returns the squared distance between the vectors \"value1\" and \"value2\"\n     * Example Playground https://playground.babylonjs.com/#R1F8YU#80\n     * @param value1 defines the first operand\n     * @param value2 defines the second operand\n     * @returns the squared distance\n     */\n    static DistanceSquared(value1, value2) {\n        const x = value1._x - value2._x;\n        const y = value1._y - value2._y;\n        const z = value1._z - value2._z;\n        return x * x + y * y + z * z;\n    }\n    /**\n     * Projects \"vector\" on the triangle determined by its extremities \"p0\", \"p1\" and \"p2\", stores the result in \"ref\"\n     * and returns the distance to the projected point.\n     * Example Playground https://playground.babylonjs.com/#R1F8YU#104\n     * From http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.104.4264&rep=rep1&type=pdf\n     *\n     * @param vector the vector to get distance from\n     * @param p0 extremity of the triangle\n     * @param p1 extremity of the triangle\n     * @param p2 extremity of the triangle\n     * @param ref variable to store the result to\n     * @returns The distance between \"ref\" and \"vector\"\n     */\n    static ProjectOnTriangleToRef(vector, p0, p1, p2, ref) {\n        const p1p0 = MathTmp.Vector3[0];\n        const p2p0 = MathTmp.Vector3[1];\n        const p2p1 = MathTmp.Vector3[2];\n        const normal = MathTmp.Vector3[3];\n        const vectorp0 = MathTmp.Vector3[4];\n        // Triangle vectors\n        p1.subtractToRef(p0, p1p0);\n        p2.subtractToRef(p0, p2p0);\n        p2.subtractToRef(p1, p2p1);\n        const p1p0L = p1p0.length();\n        const p2p0L = p2p0.length();\n        const p2p1L = p2p1.length();\n        if (p1p0L < Epsilon || p2p0L < Epsilon || p2p1L < Epsilon) {\n            // This is a degenerate triangle. As we assume this is part of a non-degenerate mesh,\n            // we will find a better intersection later.\n            // Let's just return one of the extremities\n            ref.copyFrom(p0);\n            return Vector3.Distance(vector, p0);\n        }\n        // Compute normal and vector to p0\n        vector.subtractToRef(p0, vectorp0);\n        Vector3.CrossToRef(p1p0, p2p0, normal);\n        const nl = normal.length();\n        if (nl < Epsilon) {\n            // Extremities are aligned, we are back on the case of a degenerate triangle\n            ref.copyFrom(p0);\n            return Vector3.Distance(vector, p0);\n        }\n        normal.normalizeFromLength(nl);\n        let l = vectorp0.length();\n        if (l < Epsilon) {\n            // Vector is p0\n            ref.copyFrom(p0);\n            return 0;\n        }\n        vectorp0.normalizeFromLength(l);\n        // Project to \"proj\" that lies on the triangle plane\n        const cosA = Vector3.Dot(normal, vectorp0);\n        const projVector = MathTmp.Vector3[5];\n        const proj = MathTmp.Vector3[6];\n        projVector.copyFrom(normal).scaleInPlace(-l * cosA);\n        proj.copyFrom(vector).addInPlace(projVector);\n        // Compute barycentric coordinates (v0, v1 and v2 are axis from barycenter to extremities)\n        const v0 = MathTmp.Vector3[4];\n        const v1 = MathTmp.Vector3[5];\n        const v2 = MathTmp.Vector3[7];\n        const tmp = MathTmp.Vector3[8];\n        v0.copyFrom(p1p0).scaleInPlace(1 / p1p0L);\n        tmp.copyFrom(p2p0).scaleInPlace(1 / p2p0L);\n        v0.addInPlace(tmp).scaleInPlace(-1);\n        v1.copyFrom(p1p0).scaleInPlace(-1 / p1p0L);\n        tmp.copyFrom(p2p1).scaleInPlace(1 / p2p1L);\n        v1.addInPlace(tmp).scaleInPlace(-1);\n        v2.copyFrom(p2p1).scaleInPlace(-1 / p2p1L);\n        tmp.copyFrom(p2p0).scaleInPlace(-1 / p2p0L);\n        v2.addInPlace(tmp).scaleInPlace(-1);\n        // Determines which edge of the triangle is closest to \"proj\"\n        const projP = MathTmp.Vector3[9];\n        let dot;\n        projP.copyFrom(proj).subtractInPlace(p0);\n        Vector3.CrossToRef(v0, projP, tmp);\n        dot = Vector3.Dot(tmp, normal);\n        const s0 = dot;\n        projP.copyFrom(proj).subtractInPlace(p1);\n        Vector3.CrossToRef(v1, projP, tmp);\n        dot = Vector3.Dot(tmp, normal);\n        const s1 = dot;\n        projP.copyFrom(proj).subtractInPlace(p2);\n        Vector3.CrossToRef(v2, projP, tmp);\n        dot = Vector3.Dot(tmp, normal);\n        const s2 = dot;\n        const edge = MathTmp.Vector3[10];\n        let e0, e1;\n        if (s0 > 0 && s1 < 0) {\n            edge.copyFrom(p1p0);\n            e0 = p0;\n            e1 = p1;\n        }\n        else if (s1 > 0 && s2 < 0) {\n            edge.copyFrom(p2p1);\n            e0 = p1;\n            e1 = p2;\n        }\n        else {\n            edge.copyFrom(p2p0).scaleInPlace(-1);\n            e0 = p2;\n            e1 = p0;\n        }\n        // Determines if \"proj\" lies inside the triangle\n        const tmp2 = MathTmp.Vector3[9];\n        const tmp3 = MathTmp.Vector3[4];\n        e0.subtractToRef(proj, tmp);\n        e1.subtractToRef(proj, tmp2);\n        Vector3.CrossToRef(tmp, tmp2, tmp3);\n        const isOutside = Vector3.Dot(tmp3, normal) < 0;\n        // If inside, we already found the projected point, \"proj\"\n        if (!isOutside) {\n            ref.copyFrom(proj);\n            return Math.abs(l * cosA);\n        }\n        // If outside, we find \"triProj\", the closest point from \"proj\" on the closest edge\n        const r = MathTmp.Vector3[5];\n        Vector3.CrossToRef(edge, tmp3, r);\n        r.normalize();\n        const e0proj = MathTmp.Vector3[9];\n        e0proj.copyFrom(e0).subtractInPlace(proj);\n        const e0projL = e0proj.length();\n        if (e0projL < Epsilon) {\n            // Proj is e0\n            ref.copyFrom(e0);\n            return Vector3.Distance(vector, e0);\n        }\n        e0proj.normalizeFromLength(e0projL);\n        const cosG = Vector3.Dot(r, e0proj);\n        const triProj = MathTmp.Vector3[7];\n        triProj.copyFrom(proj).addInPlace(r.scaleInPlace(e0projL * cosG));\n        // Now we clamp \"triProj\" so it lies between e0 and e1\n        tmp.copyFrom(triProj).subtractInPlace(e0);\n        l = edge.length();\n        edge.normalizeFromLength(l);\n        let t = Vector3.Dot(tmp, edge) / Math.max(l, Epsilon);\n        t = Scalar.Clamp(t, 0, 1);\n        triProj.copyFrom(e0).addInPlace(edge.scaleInPlace(t * l));\n        ref.copyFrom(triProj);\n        return Vector3.Distance(vector, triProj);\n    }\n    /**\n     * Returns a new Vector3 located at the center between \"value1\" and \"value2\"\n     * Example Playground https://playground.babylonjs.com/#R1F8YU#72\n     * @param value1 defines the first operand\n     * @param value2 defines the second operand\n     * @returns the new Vector3\n     */\n    static Center(value1, value2) {\n        return Vector3.CenterToRef(value1, value2, Vector3.Zero());\n    }\n    /**\n     * Gets the center of the vectors \"value1\" and \"value2\" and stores the result in the vector \"ref\"\n     * Example Playground https://playground.babylonjs.com/#R1F8YU#73\n     * @param value1 defines first vector\n     * @param value2 defines second vector\n     * @param ref defines third vector\n     * @returns ref\n     */\n    static CenterToRef(value1, value2, ref) {\n        return ref.copyFromFloats((value1._x + value2._x) / 2, (value1._y + value2._y) / 2, (value1._z + value2._z) / 2);\n    }\n    /**\n     * Given three orthogonal normalized left-handed oriented Vector3 axis in space (target system),\n     * RotationFromAxis() returns the rotation Euler angles (ex : rotation.x, rotation.y, rotation.z) to apply\n     * to something in order to rotate it from its local system to the given target system\n     * Note: axis1, axis2 and axis3 are normalized during this operation\n     * Example Playground https://playground.babylonjs.com/#R1F8YU#106\n     * @param axis1 defines the first axis\n     * @param axis2 defines the second axis\n     * @param axis3 defines the third axis\n     * @returns a new Vector3\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/transforms/center_origin/target_align\n     */\n    static RotationFromAxis(axis1, axis2, axis3) {\n        const rotation = new axis1.constructor();\n        Vector3.RotationFromAxisToRef(axis1, axis2, axis3, rotation);\n        return rotation;\n    }\n    /**\n     * The same than RotationFromAxis but updates the given ref Vector3 parameter instead of returning a new Vector3\n     * Example Playground https://playground.babylonjs.com/#R1F8YU#107\n     * @param axis1 defines the first axis\n     * @param axis2 defines the second axis\n     * @param axis3 defines the third axis\n     * @param ref defines the Vector3 where to store the result\n     * @returns result input\n     */\n    static RotationFromAxisToRef(axis1, axis2, axis3, ref) {\n        const quat = MathTmp.Quaternion[0];\n        Quaternion.RotationQuaternionFromAxisToRef(axis1, axis2, axis3, quat);\n        quat.toEulerAnglesToRef(ref);\n        return ref;\n    }\n}\nVector3._UpReadOnly = Vector3.Up();\nVector3._DownReadOnly = Vector3.Down();\nVector3._LeftHandedForwardReadOnly = Vector3.Forward(false);\nVector3._RightHandedForwardReadOnly = Vector3.Forward(true);\nVector3._RightReadOnly = Vector3.Right();\nVector3._LeftReadOnly = Vector3.Left();\nVector3._ZeroReadOnly = Vector3.Zero();\n/**\n * Vector4 class created for EulerAngle class conversion to Quaternion\n */\nexport class Vector4 {\n    /**\n     * Creates a Vector4 object from the given floats.\n     * @param x x value of the vector\n     * @param y y value of the vector\n     * @param z z value of the vector\n     * @param w w value of the vector\n     */\n    constructor(\n    /** x value of the vector */\n    x = 0, \n    /** y value of the vector */\n    y = 0, \n    /** z value of the vector */\n    z = 0, \n    /** w value of the vector */\n    w = 0) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n        this.w = w;\n    }\n    /**\n     * Returns the string with the Vector4 coordinates.\n     * @returns a string containing all the vector values\n     */\n    toString() {\n        return `{X: ${this.x} Y: ${this.y} Z: ${this.z} W: ${this.w}}`;\n    }\n    /**\n     * Returns the string \"Vector4\".\n     * @returns \"Vector4\"\n     */\n    getClassName() {\n        return \"Vector4\";\n    }\n    /**\n     * Returns the Vector4 hash code.\n     * @returns a unique hash code\n     */\n    getHashCode() {\n        const x = _ExtractAsInt(this.x);\n        const y = _ExtractAsInt(this.y);\n        const z = _ExtractAsInt(this.z);\n        const w = _ExtractAsInt(this.w);\n        let hash = x;\n        hash = (hash * 397) ^ y;\n        hash = (hash * 397) ^ z;\n        hash = (hash * 397) ^ w;\n        return hash;\n    }\n    // Operators\n    /**\n     * Returns a new array populated with 4 elements : the Vector4 coordinates.\n     * @returns the resulting array\n     */\n    asArray() {\n        const result = new Array();\n        this.toArray(result, 0);\n        return result;\n    }\n    /**\n     * Populates the given array from the given index with the Vector4 coordinates.\n     * @param array array to populate\n     * @param index index of the array to start at (default: 0)\n     * @returns the Vector4.\n     */\n    toArray(array, index) {\n        if (index === undefined) {\n            index = 0;\n        }\n        array[index] = this.x;\n        array[index + 1] = this.y;\n        array[index + 2] = this.z;\n        array[index + 3] = this.w;\n        return this;\n    }\n    /**\n     * Update the current vector from an array\n     * @param array defines the destination array\n     * @param index defines the offset in the destination array\n     * @returns the current Vector3\n     */\n    fromArray(array, index = 0) {\n        Vector4.FromArrayToRef(array, index, this);\n        return this;\n    }\n    /**\n     * Adds the given vector to the current Vector4.\n     * @param otherVector the vector to add\n     * @returns the updated Vector4.\n     */\n    addInPlace(otherVector) {\n        this.x += otherVector.x;\n        this.y += otherVector.y;\n        this.z += otherVector.z;\n        this.w += otherVector.w;\n        return this;\n    }\n    /**\n     * Returns a new Vector4 as the result of the addition of the current Vector4 and the given one.\n     * @param otherVector the vector to add\n     * @returns the resulting vector\n     */\n    add(otherVector) {\n        return new this.constructor(this.x + otherVector.x, this.y + otherVector.y, this.z + otherVector.z, this.w + otherVector.w);\n    }\n    /**\n     * Updates the given vector \"result\" with the result of the addition of the current Vector4 and the given one.\n     * @param otherVector the vector to add\n     * @param result the vector to store the result\n     * @returns result input\n     */\n    addToRef(otherVector, result) {\n        result.x = this.x + otherVector.x;\n        result.y = this.y + otherVector.y;\n        result.z = this.z + otherVector.z;\n        result.w = this.w + otherVector.w;\n        return result;\n    }\n    /**\n     * Subtract in place the given vector from the current Vector4.\n     * @param otherVector the vector to subtract\n     * @returns the updated Vector4.\n     */\n    subtractInPlace(otherVector) {\n        this.x -= otherVector.x;\n        this.y -= otherVector.y;\n        this.z -= otherVector.z;\n        this.w -= otherVector.w;\n        return this;\n    }\n    /**\n     * Returns a new Vector4 with the result of the subtraction of the given vector from the current Vector4.\n     * @param otherVector the vector to add\n     * @returns the new vector with the result\n     */\n    subtract(otherVector) {\n        return new this.constructor(this.x - otherVector.x, this.y - otherVector.y, this.z - otherVector.z, this.w - otherVector.w);\n    }\n    /**\n     * Sets the given vector \"result\" with the result of the subtraction of the given vector from the current Vector4.\n     * @param otherVector the vector to subtract\n     * @param result the vector to store the result\n     * @returns result input\n     */\n    subtractToRef(otherVector, result) {\n        result.x = this.x - otherVector.x;\n        result.y = this.y - otherVector.y;\n        result.z = this.z - otherVector.z;\n        result.w = this.w - otherVector.w;\n        return result;\n    }\n    /**\n     * Returns a new Vector4 set with the result of the subtraction of the given floats from the current Vector4 coordinates.\n     */\n    /**\n     * Returns a new Vector4 set with the result of the subtraction of the given floats from the current Vector4 coordinates.\n     * @param x value to subtract\n     * @param y value to subtract\n     * @param z value to subtract\n     * @param w value to subtract\n     * @returns new vector containing the result\n     */\n    subtractFromFloats(x, y, z, w) {\n        return new this.constructor(this.x - x, this.y - y, this.z - z, this.w - w);\n    }\n    /**\n     * Sets the given vector \"result\" set with the result of the subtraction of the given floats from the current Vector4 coordinates.\n     * @param x value to subtract\n     * @param y value to subtract\n     * @param z value to subtract\n     * @param w value to subtract\n     * @param result the vector to store the result in\n     * @returns result input\n     */\n    subtractFromFloatsToRef(x, y, z, w, result) {\n        result.x = this.x - x;\n        result.y = this.y - y;\n        result.z = this.z - z;\n        result.w = this.w - w;\n        return result;\n    }\n    /**\n     * Returns a new Vector4 set with the current Vector4 negated coordinates.\n     * @returns a new vector with the negated values\n     */\n    negate() {\n        return new this.constructor(-this.x, -this.y, -this.z, -this.w);\n    }\n    /**\n     * Negate this vector in place\n     * @returns this\n     */\n    negateInPlace() {\n        this.x *= -1;\n        this.y *= -1;\n        this.z *= -1;\n        this.w *= -1;\n        return this;\n    }\n    /**\n     * Negate the current Vector4 and stores the result in the given vector \"result\" coordinates\n     * @param result defines the Vector3 object where to store the result\n     * @returns the result\n     */\n    negateToRef(result) {\n        return result.copyFromFloats(this.x * -1, this.y * -1, this.z * -1, this.w * -1);\n    }\n    /**\n     * Multiplies the current Vector4 coordinates by scale (float).\n     * @param scale the number to scale with\n     * @returns the updated Vector4.\n     */\n    scaleInPlace(scale) {\n        this.x *= scale;\n        this.y *= scale;\n        this.z *= scale;\n        this.w *= scale;\n        return this;\n    }\n    /**\n     * Returns a new Vector4 set with the current Vector4 coordinates multiplied by scale (float).\n     * @param scale the number to scale with\n     * @returns a new vector with the result\n     */\n    scale(scale) {\n        return new this.constructor(this.x * scale, this.y * scale, this.z * scale, this.w * scale);\n    }\n    /**\n     * Sets the given vector \"result\" with the current Vector4 coordinates multiplied by scale (float).\n     * @param scale the number to scale with\n     * @param result a vector to store the result in\n     * @returns result input\n     */\n    scaleToRef(scale, result) {\n        result.x = this.x * scale;\n        result.y = this.y * scale;\n        result.z = this.z * scale;\n        result.w = this.w * scale;\n        return result;\n    }\n    /**\n     * Scale the current Vector4 values by a factor and add the result to a given Vector4\n     * @param scale defines the scale factor\n     * @param result defines the Vector4 object where to store the result\n     * @returns result input\n     */\n    scaleAndAddToRef(scale, result) {\n        result.x += this.x * scale;\n        result.y += this.y * scale;\n        result.z += this.z * scale;\n        result.w += this.w * scale;\n        return result;\n    }\n    /**\n     * Boolean : True if the current Vector4 coordinates are stricly equal to the given ones.\n     * @param otherVector the vector to compare against\n     * @returns true if they are equal\n     */\n    equals(otherVector) {\n        return otherVector && this.x === otherVector.x && this.y === otherVector.y && this.z === otherVector.z && this.w === otherVector.w;\n    }\n    /**\n     * Boolean : True if the current Vector4 coordinates are each beneath the distance \"epsilon\" from the given vector ones.\n     * @param otherVector vector to compare against\n     * @param epsilon (Default: very small number)\n     * @returns true if they are equal\n     */\n    equalsWithEpsilon(otherVector, epsilon = Epsilon) {\n        return (otherVector &&\n            Scalar.WithinEpsilon(this.x, otherVector.x, epsilon) &&\n            Scalar.WithinEpsilon(this.y, otherVector.y, epsilon) &&\n            Scalar.WithinEpsilon(this.z, otherVector.z, epsilon) &&\n            Scalar.WithinEpsilon(this.w, otherVector.w, epsilon));\n    }\n    /**\n     * Boolean : True if the given floats are strictly equal to the current Vector4 coordinates.\n     * @param x x value to compare against\n     * @param y y value to compare against\n     * @param z z value to compare against\n     * @param w w value to compare against\n     * @returns true if equal\n     */\n    equalsToFloats(x, y, z, w) {\n        return this.x === x && this.y === y && this.z === z && this.w === w;\n    }\n    /**\n     * Multiplies in place the current Vector4 by the given one.\n     * @param otherVector vector to multiple with\n     * @returns the updated Vector4.\n     */\n    multiplyInPlace(otherVector) {\n        this.x *= otherVector.x;\n        this.y *= otherVector.y;\n        this.z *= otherVector.z;\n        this.w *= otherVector.w;\n        return this;\n    }\n    /**\n     * Returns a new Vector4 set with the multiplication result of the current Vector4 and the given one.\n     * @param otherVector vector to multiple with\n     * @returns resulting new vector\n     */\n    multiply(otherVector) {\n        return new this.constructor(this.x * otherVector.x, this.y * otherVector.y, this.z * otherVector.z, this.w * otherVector.w);\n    }\n    /**\n     * Updates the given vector \"result\" with the multiplication result of the current Vector4 and the given one.\n     * @param otherVector vector to multiple with\n     * @param result vector to store the result\n     * @returns result input\n     */\n    multiplyToRef(otherVector, result) {\n        result.x = this.x * otherVector.x;\n        result.y = this.y * otherVector.y;\n        result.z = this.z * otherVector.z;\n        result.w = this.w * otherVector.w;\n        return result;\n    }\n    /**\n     * Returns a new Vector4 set with the multiplication result of the given floats and the current Vector4 coordinates.\n     * @param x x value multiply with\n     * @param y y value multiply with\n     * @param z z value multiply with\n     * @param w w value multiply with\n     * @returns resulting new vector\n     */\n    multiplyByFloats(x, y, z, w) {\n        return new this.constructor(this.x * x, this.y * y, this.z * z, this.w * w);\n    }\n    /**\n     * Returns a new Vector4 set with the division result of the current Vector4 by the given one.\n     * @param otherVector vector to devide with\n     * @returns resulting new vector\n     */\n    divide(otherVector) {\n        return new this.constructor(this.x / otherVector.x, this.y / otherVector.y, this.z / otherVector.z, this.w / otherVector.w);\n    }\n    /**\n     * Updates the given vector \"result\" with the division result of the current Vector4 by the given one.\n     * @param otherVector vector to devide with\n     * @param result vector to store the result\n     * @returns result input\n     */\n    divideToRef(otherVector, result) {\n        result.x = this.x / otherVector.x;\n        result.y = this.y / otherVector.y;\n        result.z = this.z / otherVector.z;\n        result.w = this.w / otherVector.w;\n        return result;\n    }\n    /**\n     * Divides the current Vector3 coordinates by the given ones.\n     * @param otherVector vector to devide with\n     * @returns the updated Vector3.\n     */\n    divideInPlace(otherVector) {\n        return this.divideToRef(otherVector, this);\n    }\n    /**\n     * Updates the Vector4 coordinates with the minimum values between its own and the given vector ones\n     * @param other defines the second operand\n     * @returns the current updated Vector4\n     */\n    minimizeInPlace(other) {\n        if (other.x < this.x) {\n            this.x = other.x;\n        }\n        if (other.y < this.y) {\n            this.y = other.y;\n        }\n        if (other.z < this.z) {\n            this.z = other.z;\n        }\n        if (other.w < this.w) {\n            this.w = other.w;\n        }\n        return this;\n    }\n    /**\n     * Updates the Vector4 coordinates with the maximum values between its own and the given vector ones\n     * @param other defines the second operand\n     * @returns the current updated Vector4\n     */\n    maximizeInPlace(other) {\n        if (other.x > this.x) {\n            this.x = other.x;\n        }\n        if (other.y > this.y) {\n            this.y = other.y;\n        }\n        if (other.z > this.z) {\n            this.z = other.z;\n        }\n        if (other.w > this.w) {\n            this.w = other.w;\n        }\n        return this;\n    }\n    /**\n     * Gets a new Vector4 from current Vector4 floored values\n     * @returns a new Vector4\n     */\n    floor() {\n        return new this.constructor(Math.floor(this.x), Math.floor(this.y), Math.floor(this.z), Math.floor(this.w));\n    }\n    /**\n     * Gets a new Vector4 from current Vector4 fractional values\n     * @returns a new Vector4\n     */\n    fract() {\n        return new this.constructor(this.x - Math.floor(this.x), this.y - Math.floor(this.y), this.z - Math.floor(this.z), this.w - Math.floor(this.w));\n    }\n    // Properties\n    /**\n     * Returns the Vector4 length (float).\n     * @returns the length\n     */\n    length() {\n        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);\n    }\n    /**\n     * Returns the Vector4 squared length (float).\n     * @returns the length squared\n     */\n    lengthSquared() {\n        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;\n    }\n    // Methods\n    /**\n     * Normalizes in place the Vector4.\n     * @returns the updated Vector4.\n     */\n    normalize() {\n        const len = this.length();\n        if (len === 0) {\n            return this;\n        }\n        return this.scaleInPlace(1.0 / len);\n    }\n    /**\n     * Returns a new Vector3 from the Vector4 (x, y, z) coordinates.\n     * @returns this converted to a new vector3\n     */\n    toVector3() {\n        return new Vector3(this.x, this.y, this.z);\n    }\n    /**\n     * Returns a new Vector4 copied from the current one.\n     * @returns the new cloned vector\n     */\n    clone() {\n        return new this.constructor(this.x, this.y, this.z, this.w);\n    }\n    /**\n     * Updates the current Vector4 with the given one coordinates.\n     * @param source the source vector to copy from\n     * @returns the updated Vector4.\n     */\n    copyFrom(source) {\n        this.x = source.x;\n        this.y = source.y;\n        this.z = source.z;\n        this.w = source.w;\n        return this;\n    }\n    /**\n     * Updates the current Vector4 coordinates with the given floats.\n     * @param x float to copy from\n     * @param y float to copy from\n     * @param z float to copy from\n     * @param w float to copy from\n     * @returns the updated Vector4.\n     */\n    copyFromFloats(x, y, z, w) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n        this.w = w;\n        return this;\n    }\n    /**\n     * Updates the current Vector4 coordinates with the given floats.\n     * @param x float to set from\n     * @param y float to set from\n     * @param z float to set from\n     * @param w float to set from\n     * @returns the updated Vector4.\n     */\n    set(x, y, z, w) {\n        return this.copyFromFloats(x, y, z, w);\n    }\n    /**\n     * Copies the given float to the current Vector3 coordinates\n     * @param v defines the x, y, z and w coordinates of the operand\n     * @returns the current updated Vector3\n     */\n    setAll(v) {\n        this.x = this.y = this.z = this.w = v;\n        return this;\n    }\n    // Statics\n    /**\n     * Returns a new Vector4 set from the starting index of the given array.\n     * @param array the array to pull values from\n     * @param offset the offset into the array to start at\n     * @returns the new vector\n     */\n    static FromArray(array, offset) {\n        if (!offset) {\n            offset = 0;\n        }\n        return new Vector4(array[offset], array[offset + 1], array[offset + 2], array[offset + 3]);\n    }\n    /**\n     * Updates the given vector \"result\" from the starting index of the given array.\n     * @param array the array to pull values from\n     * @param offset the offset into the array to start at\n     * @param result the vector to store the result in\n     * @returns result input\n     */\n    static FromArrayToRef(array, offset, result) {\n        result.x = array[offset];\n        result.y = array[offset + 1];\n        result.z = array[offset + 2];\n        result.w = array[offset + 3];\n        return result;\n    }\n    /**\n     * Updates the given vector \"result\" from the starting index of the given Float32Array.\n     * @param array the array to pull values from\n     * @param offset the offset into the array to start at\n     * @param result the vector to store the result in\n     * @returns result input\n     */\n    static FromFloatArrayToRef(array, offset, result) {\n        Vector4.FromArrayToRef(array, offset, result);\n        return result;\n    }\n    /**\n     * Updates the given vector \"result\" coordinates from the given floats.\n     * @param x float to set from\n     * @param y float to set from\n     * @param z float to set from\n     * @param w float to set from\n     * @param result the vector to the floats in\n     * @returns result input\n     */\n    static FromFloatsToRef(x, y, z, w, result) {\n        result.x = x;\n        result.y = y;\n        result.z = z;\n        result.w = w;\n        return result;\n    }\n    /**\n     * Returns a new Vector4 set to (0.0, 0.0, 0.0, 0.0)\n     * @returns the new vector\n     */\n    static Zero() {\n        return new Vector4(0.0, 0.0, 0.0, 0.0);\n    }\n    /**\n     * Returns a new Vector4 set to (1.0, 1.0, 1.0, 1.0)\n     * @returns the new vector\n     */\n    static One() {\n        return new Vector4(1.0, 1.0, 1.0, 1.0);\n    }\n    /**\n     * Returns a new Vector4 with random values between min and max\n     * @param min the minimum random value\n     * @param max the maximum random value\n     * @returns a Vector4 with random values between min and max\n     */\n    static Random(min = 0, max = 1) {\n        return new Vector4(Scalar.RandomRange(min, max), Scalar.RandomRange(min, max), Scalar.RandomRange(min, max), Scalar.RandomRange(min, max));\n    }\n    /**\n     * Gets a zero Vector4 that must not be updated\n     */\n    static get ZeroReadOnly() {\n        return Vector4._ZeroReadOnly;\n    }\n    /**\n     * Returns a new normalized Vector4 from the given one.\n     * @param vector the vector to normalize\n     * @returns the vector\n     */\n    static Normalize(vector) {\n        const result = Vector4.Zero();\n        Vector4.NormalizeToRef(vector, result);\n        return result;\n    }\n    /**\n     * Updates the given vector \"result\" from the normalization of the given one.\n     * @param vector the vector to normalize\n     * @param result the vector to store the result in\n     * @returns result input\n     */\n    static NormalizeToRef(vector, result) {\n        result.copyFrom(vector);\n        result.normalize();\n        return result;\n    }\n    /**\n     * Returns a vector with the minimum values from the left and right vectors\n     * @param left left vector to minimize\n     * @param right right vector to minimize\n     * @returns a new vector with the minimum of the left and right vector values\n     */\n    static Minimize(left, right) {\n        const min = new left.constructor();\n        min.copyFrom(left);\n        min.minimizeInPlace(right);\n        return min;\n    }\n    /**\n     * Returns a vector with the maximum values from the left and right vectors\n     * @param left left vector to maximize\n     * @param right right vector to maximize\n     * @returns a new vector with the maximum of the left and right vector values\n     */\n    static Maximize(left, right) {\n        const max = new left.constructor();\n        max.copyFrom(left);\n        max.maximizeInPlace(right);\n        return max;\n    }\n    /**\n     * Returns the distance (float) between the vectors \"value1\" and \"value2\".\n     * @param value1 value to calulate the distance between\n     * @param value2 value to calulate the distance between\n     * @returns the distance between the two vectors\n     */\n    static Distance(value1, value2) {\n        return Math.sqrt(Vector4.DistanceSquared(value1, value2));\n    }\n    /**\n     * Returns the squared distance (float) between the vectors \"value1\" and \"value2\".\n     * @param value1 value to calulate the distance between\n     * @param value2 value to calulate the distance between\n     * @returns the distance between the two vectors squared\n     */\n    static DistanceSquared(value1, value2) {\n        const x = value1.x - value2.x;\n        const y = value1.y - value2.y;\n        const z = value1.z - value2.z;\n        const w = value1.w - value2.w;\n        return x * x + y * y + z * z + w * w;\n    }\n    /**\n     * Returns a new Vector4 located at the center between the vectors \"value1\" and \"value2\".\n     * @param value1 value to calulate the center between\n     * @param value2 value to calulate the center between\n     * @returns the center between the two vectors\n     */\n    static Center(value1, value2) {\n        return Vector4.CenterToRef(value1, value2, Vector4.Zero());\n    }\n    /**\n     * Gets the center of the vectors \"value1\" and \"value2\" and stores the result in the vector \"ref\"\n     * @param value1 defines first vector\n     * @param value2 defines second vector\n     * @param ref defines third vector\n     * @returns ref\n     */\n    static CenterToRef(value1, value2, ref) {\n        return ref.copyFromFloats((value1.x + value2.x) / 2, (value1.y + value2.y) / 2, (value1.z + value2.z) / 2, (value1.w + value2.w) / 2);\n    }\n    /**\n     * Returns a new Vector4 set with the result of the transformation by the given matrix of the given vector.\n     * This method computes tranformed coordinates only, not transformed direction vectors (ie. it takes translation in account)\n     * The difference with Vector3.TransformCoordinates is that the w component is not used to divide the other coordinates but is returned in the w coordinate instead\n     * @param vector defines the Vector3 to transform\n     * @param transformation defines the transformation matrix\n     * @returns the transformed Vector4\n     */\n    static TransformCoordinates(vector, transformation) {\n        const result = Vector4.Zero();\n        Vector4.TransformCoordinatesToRef(vector, transformation, result);\n        return result;\n    }\n    /**\n     * Sets the given vector \"result\" coordinates with the result of the transformation by the given matrix of the given vector\n     * This method computes tranformed coordinates only, not transformed direction vectors (ie. it takes translation in account)\n     * The difference with Vector3.TransformCoordinatesToRef is that the w component is not used to divide the other coordinates but is returned in the w coordinate instead\n     * @param vector defines the Vector3 to transform\n     * @param transformation defines the transformation matrix\n     * @param result defines the Vector4 where to store the result\n     * @returns result input\n     */\n    static TransformCoordinatesToRef(vector, transformation, result) {\n        Vector4.TransformCoordinatesFromFloatsToRef(vector._x, vector._y, vector._z, transformation, result);\n        return result;\n    }\n    /**\n     * Sets the given vector \"result\" coordinates with the result of the transformation by the given matrix of the given floats (x, y, z)\n     * This method computes tranformed coordinates only, not transformed direction vectors\n     * The difference with Vector3.TransformCoordinatesFromFloatsToRef is that the w component is not used to divide the other coordinates but is returned in the w coordinate instead\n     * @param x define the x coordinate of the source vector\n     * @param y define the y coordinate of the source vector\n     * @param z define the z coordinate of the source vector\n     * @param transformation defines the transformation matrix\n     * @param result defines the Vector4 where to store the result\n     * @returns result input\n     */\n    static TransformCoordinatesFromFloatsToRef(x, y, z, transformation, result) {\n        const m = transformation.m;\n        const rx = x * m[0] + y * m[4] + z * m[8] + m[12];\n        const ry = x * m[1] + y * m[5] + z * m[9] + m[13];\n        const rz = x * m[2] + y * m[6] + z * m[10] + m[14];\n        const rw = x * m[3] + y * m[7] + z * m[11] + m[15];\n        result.x = rx;\n        result.y = ry;\n        result.z = rz;\n        result.w = rw;\n        return result;\n    }\n    /**\n     * Returns a new Vector4 set with the result of the normal transformation by the given matrix of the given vector.\n     * This methods computes transformed normalized direction vectors only.\n     * @param vector the vector to transform\n     * @param transformation the transformation matrix to apply\n     * @returns the new vector\n     */\n    static TransformNormal(vector, transformation) {\n        const result = new vector.constructor();\n        Vector4.TransformNormalToRef(vector, transformation, result);\n        return result;\n    }\n    /**\n     * Sets the given vector \"result\" with the result of the normal transformation by the given matrix of the given vector.\n     * This methods computes transformed normalized direction vectors only.\n     * @param vector the vector to transform\n     * @param transformation the transformation matrix to apply\n     * @param result the vector to store the result in\n     * @returns result input\n     */\n    static TransformNormalToRef(vector, transformation, result) {\n        const m = transformation.m;\n        const x = vector.x * m[0] + vector.y * m[4] + vector.z * m[8];\n        const y = vector.x * m[1] + vector.y * m[5] + vector.z * m[9];\n        const z = vector.x * m[2] + vector.y * m[6] + vector.z * m[10];\n        result.x = x;\n        result.y = y;\n        result.z = z;\n        result.w = vector.w;\n        return result;\n    }\n    /**\n     * Sets the given vector \"result\" with the result of the normal transformation by the given matrix of the given floats (x, y, z, w).\n     * This methods computes transformed normalized direction vectors only.\n     * @param x value to transform\n     * @param y value to transform\n     * @param z value to transform\n     * @param w value to transform\n     * @param transformation the transformation matrix to apply\n     * @param result the vector to store the results in\n     * @returns result input\n     */\n    static TransformNormalFromFloatsToRef(x, y, z, w, transformation, result) {\n        const m = transformation.m;\n        result.x = x * m[0] + y * m[4] + z * m[8];\n        result.y = x * m[1] + y * m[5] + z * m[9];\n        result.z = x * m[2] + y * m[6] + z * m[10];\n        result.w = w;\n        return result;\n    }\n    /**\n     * Creates a new Vector4 from a Vector3\n     * @param source defines the source data\n     * @param w defines the 4th component (default is 0)\n     * @returns a new Vector4\n     */\n    static FromVector3(source, w = 0) {\n        return new Vector4(source._x, source._y, source._z, w);\n    }\n}\nVector4._ZeroReadOnly = Vector4.Zero();\n/**\n * Class used to store quaternion data\n * Example Playground - Overview - https://playground.babylonjs.com/#L49EJ7#100\n * @see https://en.wikipedia.org/wiki/Quaternion\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/transforms\n */\nexport class Quaternion {\n    /** Gets or sets the x coordinate */\n    get x() {\n        return this._x;\n    }\n    set x(value) {\n        this._x = value;\n        this._isDirty = true;\n    }\n    /** Gets or sets the y coordinate */\n    get y() {\n        return this._y;\n    }\n    set y(value) {\n        this._y = value;\n        this._isDirty = true;\n    }\n    /** Gets or sets the z coordinate */\n    get z() {\n        return this._z;\n    }\n    set z(value) {\n        this._z = value;\n        this._isDirty = true;\n    }\n    /** Gets or sets the w coordinate */\n    get w() {\n        return this._w;\n    }\n    set w(value) {\n        this._w = value;\n        this._isDirty = true;\n    }\n    /**\n     * Creates a new Quaternion from the given floats\n     * @param x defines the first component (0 by default)\n     * @param y defines the second component (0 by default)\n     * @param z defines the third component (0 by default)\n     * @param w defines the fourth component (1.0 by default)\n     */\n    constructor(x = 0.0, y = 0.0, z = 0.0, w = 1.0) {\n        /** @internal */\n        this._isDirty = true;\n        this._x = x;\n        this._y = y;\n        this._z = z;\n        this._w = w;\n    }\n    /**\n     * Gets a string representation for the current quaternion\n     * @returns a string with the Quaternion coordinates\n     */\n    toString() {\n        return `{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`;\n    }\n    /**\n     * Gets the class name of the quaternion\n     * @returns the string \"Quaternion\"\n     */\n    getClassName() {\n        return \"Quaternion\";\n    }\n    /**\n     * Gets a hash code for this quaternion\n     * @returns the quaternion hash code\n     */\n    getHashCode() {\n        const x = _ExtractAsInt(this._x);\n        const y = _ExtractAsInt(this._y);\n        const z = _ExtractAsInt(this._z);\n        const w = _ExtractAsInt(this._w);\n        let hash = x;\n        hash = (hash * 397) ^ y;\n        hash = (hash * 397) ^ z;\n        hash = (hash * 397) ^ w;\n        return hash;\n    }\n    /**\n     * Copy the quaternion to an array\n     * Example Playground https://playground.babylonjs.com/#L49EJ7#13\n     * @returns a new array populated with 4 elements from the quaternion coordinates\n     */\n    asArray() {\n        return [this._x, this._y, this._z, this._w];\n    }\n    /**\n     * Stores from the starting index in the given array the Quaternion successive values\n     * Example Playground https://playground.babylonjs.com/#L49EJ7#59\n     * @param array defines the array where to store the x,y,z,w components\n     * @param index defines an optional index in the target array to define where to start storing values\n     * @returns the current Quaternion object\n     */\n    toArray(array, index = 0) {\n        array[index] = this._x;\n        array[index + 1] = this._y;\n        array[index + 2] = this._z;\n        array[index + 3] = this._w;\n        return this;\n    }\n    /**\n     * Check if two quaternions are equals\n     * Example Playground https://playground.babylonjs.com/#L49EJ7#38\n     * @param otherQuaternion defines the second operand\n     * @returns true if the current quaternion and the given one coordinates are strictly equals\n     */\n    equals(otherQuaternion) {\n        return otherQuaternion && this._x === otherQuaternion._x && this._y === otherQuaternion._y && this._z === otherQuaternion._z && this._w === otherQuaternion._w;\n    }\n    /**\n     * Gets a boolean if two quaternions are equals (using an epsilon value)\n     * Example Playground https://playground.babylonjs.com/#L49EJ7#37\n     * @param otherQuaternion defines the other quaternion\n     * @param epsilon defines the minimal distance to consider equality\n     * @returns true if the given quaternion coordinates are close to the current ones by a distance of epsilon.\n     */\n    equalsWithEpsilon(otherQuaternion, epsilon = Epsilon) {\n        return (otherQuaternion &&\n            Scalar.WithinEpsilon(this._x, otherQuaternion._x, epsilon) &&\n            Scalar.WithinEpsilon(this._y, otherQuaternion._y, epsilon) &&\n            Scalar.WithinEpsilon(this._z, otherQuaternion._z, epsilon) &&\n            Scalar.WithinEpsilon(this._w, otherQuaternion._w, epsilon));\n    }\n    /**\n     * Clone the current quaternion\n     * Example Playground https://playground.babylonjs.com/#L49EJ7#12\n     * @returns a new quaternion copied from the current one\n     */\n    clone() {\n        return new this.constructor(this._x, this._y, this._z, this._w);\n    }\n    /**\n     * Copy a quaternion to the current one\n     * Example Playground https://playground.babylonjs.com/#L49EJ7#86\n     * @param other defines the other quaternion\n     * @returns the updated current quaternion\n     */\n    copyFrom(other) {\n        this._x = other._x;\n        this._y = other._y;\n        this._z = other._z;\n        this._w = other._w;\n        this._isDirty = true;\n        return this;\n    }\n    /**\n     * Updates the current quaternion with the given float coordinates\n     * Example Playground https://playground.babylonjs.com/#L49EJ7#87\n     * @param x defines the x coordinate\n     * @param y defines the y coordinate\n     * @param z defines the z coordinate\n     * @param w defines the w coordinate\n     * @returns the updated current quaternion\n     */\n    copyFromFloats(x, y, z, w) {\n        this._x = x;\n        this._y = y;\n        this._z = z;\n        this._w = w;\n        this._isDirty = true;\n        return this;\n    }\n    /**\n     * Updates the current quaternion from the given float coordinates\n     * Example Playground https://playground.babylonjs.com/#L49EJ7#56\n     * @param x defines the x coordinate\n     * @param y defines the y coordinate\n     * @param z defines the z coordinate\n     * @param w defines the w coordinate\n     * @returns the updated current quaternion\n     */\n    set(x, y, z, w) {\n        return this.copyFromFloats(x, y, z, w);\n    }\n    /**\n     * Adds two quaternions\n     * Example Playground https://playground.babylonjs.com/#L49EJ7#10\n     * @param other defines the second operand\n     * @returns a new quaternion as the addition result of the given one and the current quaternion\n     */\n    add(other) {\n        return new this.constructor(this._x + other._x, this._y + other._y, this._z + other._z, this._w + other._w);\n    }\n    /**\n     * Add a quaternion to the current one\n     * Example Playground https://playground.babylonjs.com/#L49EJ7#11\n     * @param other defines the quaternion to add\n     * @returns the current quaternion\n     */\n    addInPlace(other) {\n        this._x += other._x;\n        this._y += other._y;\n        this._z += other._z;\n        this._w += other._w;\n        this._isDirty = true;\n        return this;\n    }\n    /**\n     * Subtract two quaternions\n     * Example Playground https://playground.babylonjs.com/#L49EJ7#57\n     * @param other defines the second operand\n     * @returns a new quaternion as the subtraction result of the given one from the current one\n     */\n    subtract(other) {\n        return new this.constructor(this._x - other._x, this._y - other._y, this._z - other._z, this._w - other._w);\n    }\n    /**\n     * Subtract a quaternion to the current one\n     * Example Playground https://playground.babylonjs.com/#L49EJ7#58\n     * @param other defines the quaternion to subtract\n     * @returns the current quaternion\n     */\n    subtractInPlace(other) {\n        this._x -= other._x;\n        this._y -= other._y;\n        this._z -= other._z;\n        this._w -= other._w;\n        this._isDirty = true;\n        return this;\n    }\n    /**\n     * Multiplies the current quaternion by a scale factor\n     * Example Playground https://playground.babylonjs.com/#L49EJ7#88\n     * @param value defines the scale factor\n     * @returns a new quaternion set by multiplying the current quaternion coordinates by the float \"scale\"\n     */\n    scale(value) {\n        return new this.constructor(this._x * value, this._y * value, this._z * value, this._w * value);\n    }\n    /**\n     * Scale the current quaternion values by a factor and stores the result to a given quaternion\n     * Example Playground https://playground.babylonjs.com/#L49EJ7#89\n     * @param scale defines the scale factor\n     * @param result defines the Quaternion object where to store the result\n     * @returns result input\n     */\n    scaleToRef(scale, result) {\n        result._x = this._x * scale;\n        result._y = this._y * scale;\n        result._z = this._z * scale;\n        result._w = this._w * scale;\n        result._isDirty = true;\n        return result;\n    }\n    /**\n     * Multiplies in place the current quaternion by a scale factor\n     * Example Playground https://playground.babylonjs.com/#L49EJ7#90\n     * @param value defines the scale factor\n     * @returns the current modified quaternion\n     */\n    scaleInPlace(value) {\n        this._x *= value;\n        this._y *= value;\n        this._z *= value;\n        this._w *= value;\n        this._isDirty = true;\n        return this;\n    }\n    /**\n     * Scale the current quaternion values by a factor and add the result to a given quaternion\n     * Example Playground https://playground.babylonjs.com/#L49EJ7#91\n     * @param scale defines the scale factor\n     * @param result defines the Quaternion object where to store the result\n     * @returns result input\n     */\n    scaleAndAddToRef(scale, result) {\n        result._x += this._x * scale;\n        result._y += this._y * scale;\n        result._z += this._z * scale;\n        result._w += this._w * scale;\n        result._isDirty = true;\n        return result;\n    }\n    /**\n     * Multiplies two quaternions\n     * Example Playground https://playground.babylonjs.com/#L49EJ7#43\n     * @param q1 defines the second operand\n     * @returns a new quaternion set as the multiplication result of the current one with the given one \"q1\"\n     */\n    multiply(q1) {\n        const result = new this.constructor(0, 0, 0, 1.0);\n        this.multiplyToRef(q1, result);\n        return result;\n    }\n    /**\n     * Sets the given \"result\" as the the multiplication result of the current one with the given one \"q1\"\n     * Example Playground https://playground.babylonjs.com/#L49EJ7#45\n     * @param q1 defines the second operand\n     * @param result defines the target quaternion\n     * @returns the current quaternion\n     */\n    multiplyToRef(q1, result) {\n        const x = this._x * q1._w + this._y * q1._z - this._z * q1._y + this._w * q1._x;\n        const y = -this._x * q1._z + this._y * q1._w + this._z * q1._x + this._w * q1._y;\n        const z = this._x * q1._y - this._y * q1._x + this._z * q1._w + this._w * q1._z;\n        const w = -this._x * q1._x - this._y * q1._y - this._z * q1._z + this._w * q1._w;\n        result.copyFromFloats(x, y, z, w);\n        return result;\n    }\n    /**\n     * Updates the current quaternion with the multiplication of itself with the given one \"q1\"\n     * Example Playground https://playground.babylonjs.com/#L49EJ7#46\n     * @param q1 defines the second operand\n     * @returns the currentupdated quaternion\n     */\n    multiplyInPlace(q1) {\n        this.multiplyToRef(q1, this);\n        return this;\n    }\n    /**\n     * Conjugates the current quaternion and stores the result in the given quaternion\n     * Example Playground https://playground.babylonjs.com/#L49EJ7#81\n     * @param ref defines the target quaternion\n     * @returns result input\n     */\n    conjugateToRef(ref) {\n        ref.copyFromFloats(-this._x, -this._y, -this._z, this._w);\n        return ref;\n    }\n    /**\n     * Conjugates in place the current quaternion\n     * Example Playground https://playground.babylonjs.com/#L49EJ7#82\n     * @returns the current updated quaternion\n     */\n    conjugateInPlace() {\n        this._x *= -1;\n        this._y *= -1;\n        this._z *= -1;\n        this._isDirty = true;\n        return this;\n    }\n    /**\n     * Conjugates (1-q) the current quaternion\n     * Example Playground https://playground.babylonjs.com/#L49EJ7#83\n     * @returns a new quaternion\n     */\n    conjugate() {\n        return new this.constructor(-this._x, -this._y, -this._z, this._w);\n    }\n    /**\n     * Returns the inverse of the current quaternion\n     * Example Playground https://playground.babylonjs.com/#L49EJ7#84\n     * @returns a new quaternion\n     */\n    invert() {\n        const conjugate = this.conjugate();\n        const lengthSquared = this.lengthSquared();\n        if (lengthSquared == 0 || lengthSquared == 1) {\n            return conjugate;\n        }\n        conjugate.scaleInPlace(1 / lengthSquared);\n        return conjugate;\n    }\n    /**\n     * Invert in place the current quaternion\n     * Example Playground https://playground.babylonjs.com/#L49EJ7#85\n     * @returns this quaternion\n     */\n    invertInPlace() {\n        this.conjugateInPlace();\n        const lengthSquared = this.lengthSquared();\n        if (lengthSquared == 0 || lengthSquared == 1) {\n            return this;\n        }\n        this.scaleInPlace(1 / lengthSquared);\n        return this;\n    }\n    /**\n     * Gets squared length of current quaternion\n     * Example Playground https://playground.babylonjs.com/#L49EJ7#29\n     * @returns the quaternion length (float)\n     */\n    lengthSquared() {\n        return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;\n    }\n    /**\n     * Gets length of current quaternion\n     * Example Playground https://playground.babylonjs.com/#L49EJ7#28\n     * @returns the quaternion length (float)\n     */\n    length() {\n        return Math.sqrt(this.lengthSquared());\n    }\n    /**\n     * Normalize in place the current quaternion\n     * Example Playground https://playground.babylonjs.com/#L49EJ7#54\n     * @returns the current updated quaternion\n     */\n    normalize() {\n        const len = this.length();\n        if (len === 0) {\n            return this;\n        }\n        const inv = 1.0 / len;\n        this.scaleInPlace(inv);\n        return this;\n    }\n    /**\n     * Normalize a copy of the current quaternion\n     * Example Playground https://playground.babylonjs.com/#L49EJ7#55\n     * @returns the normalized quaternion\n     */\n    normalizeToNew() {\n        const len = this.length();\n        if (len === 0) {\n            return this.clone();\n        }\n        const inv = 1.0 / len;\n        return this.scale(inv);\n    }\n    /**\n     * Returns a new Vector3 set with the Euler angles translated from the current quaternion\n     * Example Playground https://playground.babylonjs.com/#L49EJ7#32\n     * @returns a new Vector3 containing the Euler angles\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/transforms/center_origin/rotation_conventions\n     */\n    toEulerAngles() {\n        const result = Vector3.Zero();\n        this.toEulerAnglesToRef(result);\n        return result;\n    }\n    /**\n     * Sets the given vector3 \"result\" with the Euler angles translated from the current quaternion\n     * Example Playground https://playground.babylonjs.com/#L49EJ7#31\n     * @param result defines the vector which will be filled with the Euler angles\n     * @returns result input\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/transforms/center_origin/rotation_conventions\n     */\n    toEulerAnglesToRef(result) {\n        const qz = this._z;\n        const qx = this._x;\n        const qy = this._y;\n        const qw = this._w;\n        const zAxisY = qy * qz - qx * qw;\n        const limit = 0.4999999;\n        if (zAxisY < -limit) {\n            result._y = 2 * Math.atan2(qy, qw);\n            result._x = Math.PI / 2;\n            result._z = 0;\n            result._isDirty = true;\n        }\n        else if (zAxisY > limit) {\n            result._y = 2 * Math.atan2(qy, qw);\n            result._x = -Math.PI / 2;\n            result._z = 0;\n            result._isDirty = true;\n        }\n        else {\n            const sqw = qw * qw;\n            const sqz = qz * qz;\n            const sqx = qx * qx;\n            const sqy = qy * qy;\n            result._z = Math.atan2(2.0 * (qx * qy + qz * qw), -sqz - sqx + sqy + sqw);\n            result._x = Math.asin(-2.0 * zAxisY);\n            result._y = Math.atan2(2.0 * (qz * qx + qy * qw), sqz - sqx - sqy + sqw);\n            result._isDirty = true;\n        }\n        return result;\n    }\n    /**\n     * Updates the given rotation matrix with the current quaternion values\n     * Example Playground https://playground.babylonjs.com/#L49EJ7#67\n     * @param result defines the target matrix\n     * @returns the current unchanged quaternion\n     */\n    toRotationMatrix(result) {\n        Matrix.FromQuaternionToRef(this, result);\n        return result;\n    }\n    /**\n     * Updates the current quaternion from the given rotation matrix values\n     * Example Playground https://playground.babylonjs.com/#L49EJ7#41\n     * @param matrix defines the source matrix\n     * @returns the current updated quaternion\n     */\n    fromRotationMatrix(matrix) {\n        Quaternion.FromRotationMatrixToRef(matrix, this);\n        return this;\n    }\n    // Statics\n    /**\n     * Creates a new quaternion from a rotation matrix\n     * Example Playground https://playground.babylonjs.com/#L49EJ7#101\n     * @param matrix defines the source matrix\n     * @returns a new quaternion created from the given rotation matrix values\n     */\n    static FromRotationMatrix(matrix) {\n        const result = new Quaternion();\n        Quaternion.FromRotationMatrixToRef(matrix, result);\n        return result;\n    }\n    /**\n     * Updates the given quaternion with the given rotation matrix values\n     * Example Playground https://playground.babylonjs.com/#L49EJ7#102\n     * @param matrix defines the source matrix\n     * @param result defines the target quaternion\n     * @returns result input\n     */\n    static FromRotationMatrixToRef(matrix, result) {\n        const data = matrix.m;\n        const m11 = data[0], m12 = data[4], m13 = data[8];\n        const m21 = data[1], m22 = data[5], m23 = data[9];\n        const m31 = data[2], m32 = data[6], m33 = data[10];\n        const trace = m11 + m22 + m33;\n        let s;\n        if (trace > 0) {\n            s = 0.5 / Math.sqrt(trace + 1.0);\n            result._w = 0.25 / s;\n            result._x = (m32 - m23) * s;\n            result._y = (m13 - m31) * s;\n            result._z = (m21 - m12) * s;\n            result._isDirty = true;\n        }\n        else if (m11 > m22 && m11 > m33) {\n            s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);\n            result._w = (m32 - m23) / s;\n            result._x = 0.25 * s;\n            result._y = (m12 + m21) / s;\n            result._z = (m13 + m31) / s;\n            result._isDirty = true;\n        }\n        else if (m22 > m33) {\n            s = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);\n            result._w = (m13 - m31) / s;\n            result._x = (m12 + m21) / s;\n            result._y = 0.25 * s;\n            result._z = (m23 + m32) / s;\n            result._isDirty = true;\n        }\n        else {\n            s = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);\n            result._w = (m21 - m12) / s;\n            result._x = (m13 + m31) / s;\n            result._y = (m23 + m32) / s;\n            result._z = 0.25 * s;\n            result._isDirty = true;\n        }\n        return result;\n    }\n    /**\n     * Returns the dot product (float) between the quaternions \"left\" and \"right\"\n     * Example Playground https://playground.babylonjs.com/#L49EJ7#61\n     * @param left defines the left operand\n     * @param right defines the right operand\n     * @returns the dot product\n     */\n    static Dot(left, right) {\n        return left._x * right._x + left._y * right._y + left._z * right._z + left._w * right._w;\n    }\n    /**\n     * Checks if the orientations of two rotation quaternions are close to each other\n     * Example Playground https://playground.babylonjs.com/#L49EJ7#60\n     * @param quat0 defines the first quaternion to check\n     * @param quat1 defines the second quaternion to check\n     * @param epsilon defines closeness, 0 same orientation, 1 PI apart, default 0.1\n     * @returns true if the two quaternions are close to each other within epsilon\n     */\n    static AreClose(quat0, quat1, epsilon = 0.1) {\n        const dot = Quaternion.Dot(quat0, quat1);\n        return 1 - dot * dot <= epsilon;\n    }\n    /**\n     * Smooth interpolation between two quaternions using Slerp\n     * Example Playground https://playground.babylonjs.com/#L49EJ7#93\n     * @param source source quaternion\n     * @param goal goal quaternion\n     * @param deltaTime current interpolation frame\n     * @param lerpTime total interpolation time\n     * @param result the smoothed quaternion\n     */\n    static SmoothToRef(source, goal, deltaTime, lerpTime, result) {\n        let slerp = lerpTime === 0 ? 1 : deltaTime / lerpTime;\n        slerp = Scalar.Clamp(slerp, 0, 1);\n        Quaternion.SlerpToRef(source, goal, slerp, result);\n        return result;\n    }\n    /**\n     * Creates an empty quaternion\n     * @returns a new quaternion set to (0.0, 0.0, 0.0)\n     */\n    static Zero() {\n        return new Quaternion(0.0, 0.0, 0.0, 0.0);\n    }\n    /**\n     * Inverse a given quaternion\n     * Example Playground https://playground.babylonjs.com/#L49EJ7#103\n     * @param q defines the source quaternion\n     * @returns a new quaternion as the inverted current quaternion\n     */\n    static Inverse(q) {\n        return new q.constructor(-q._x, -q._y, -q._z, q._w);\n    }\n    /**\n     * Inverse a given quaternion\n     * Example Playground https://playground.babylonjs.com/#L49EJ7#104\n     * @param q defines the source quaternion\n     * @param result the quaternion the result will be stored in\n     * @returns the result quaternion\n     */\n    static InverseToRef(q, result) {\n        result.set(-q._x, -q._y, -q._z, q._w);\n        return result;\n    }\n    /**\n     * Creates an identity quaternion\n     * @returns the identity quaternion\n     */\n    static Identity() {\n        return new Quaternion(0.0, 0.0, 0.0, 1.0);\n    }\n    /**\n     * Gets a boolean indicating if the given quaternion is identity\n     * @param quaternion defines the quaternion to check\n     * @returns true if the quaternion is identity\n     */\n    static IsIdentity(quaternion) {\n        return quaternion && quaternion._x === 0 && quaternion._y === 0 && quaternion._z === 0 && quaternion._w === 1;\n    }\n    /**\n     * Creates a quaternion from a rotation around an axis\n     * Example Playground https://playground.babylonjs.com/#L49EJ7#72\n     * @param axis defines the axis to use\n     * @param angle defines the angle to use\n     * @returns a new quaternion created from the given axis (Vector3) and angle in radians (float)\n     */\n    static RotationAxis(axis, angle) {\n        return Quaternion.RotationAxisToRef(axis, angle, new Quaternion());\n    }\n    /**\n     * Creates a rotation around an axis and stores it into the given quaternion\n     * Example Playground https://playground.babylonjs.com/#L49EJ7#73\n     * @param axis defines the axis to use\n     * @param angle defines the angle to use\n     * @param result defines the target quaternion\n     * @returns the target quaternion\n     */\n    static RotationAxisToRef(axis, angle, result) {\n        const sin = Math.sin(angle / 2);\n        axis.normalize();\n        result._w = Math.cos(angle / 2);\n        result._x = axis._x * sin;\n        result._y = axis._y * sin;\n        result._z = axis._z * sin;\n        result._isDirty = true;\n        return result;\n    }\n    /**\n     * Creates a new quaternion from data stored into an array\n     * Example Playground https://playground.babylonjs.com/#L49EJ7#63\n     * @param array defines the data source\n     * @param offset defines the offset in the source array where the data starts\n     * @returns a new quaternion\n     */\n    static FromArray(array, offset) {\n        if (!offset) {\n            offset = 0;\n        }\n        return new Quaternion(array[offset], array[offset + 1], array[offset + 2], array[offset + 3]);\n    }\n    /**\n     * Updates the given quaternion \"result\" from the starting index of the given array.\n     * Example Playground https://playground.babylonjs.com/#L49EJ7#64\n     * @param array the array to pull values from\n     * @param offset the offset into the array to start at\n     * @param result the quaternion to store the result in\n     * @returns result input\n     */\n    static FromArrayToRef(array, offset, result) {\n        result._x = array[offset];\n        result._y = array[offset + 1];\n        result._z = array[offset + 2];\n        result._w = array[offset + 3];\n        result._isDirty = true;\n        return result;\n    }\n    /**\n     * Create a quaternion from Euler rotation angles\n     * Example Playground https://playground.babylonjs.com/#L49EJ7#33\n     * @param x Pitch\n     * @param y Yaw\n     * @param z Roll\n     * @returns the new Quaternion\n     */\n    static FromEulerAngles(x, y, z) {\n        const q = new Quaternion();\n        Quaternion.RotationYawPitchRollToRef(y, x, z, q);\n        return q;\n    }\n    /**\n     * Updates a quaternion from Euler rotation angles\n     * Example Playground https://playground.babylonjs.com/#L49EJ7#34\n     * @param x Pitch\n     * @param y Yaw\n     * @param z Roll\n     * @param result the quaternion to store the result\n     * @returns the updated quaternion\n     */\n    static FromEulerAnglesToRef(x, y, z, result) {\n        Quaternion.RotationYawPitchRollToRef(y, x, z, result);\n        return result;\n    }\n    /**\n     * Create a quaternion from Euler rotation vector\n     * Example Playground https://playground.babylonjs.com/#L49EJ7#35\n     * @param vec the Euler vector (x Pitch, y Yaw, z Roll)\n     * @returns the new Quaternion\n     */\n    static FromEulerVector(vec) {\n        const q = new Quaternion();\n        Quaternion.RotationYawPitchRollToRef(vec._y, vec._x, vec._z, q);\n        return q;\n    }\n    /**\n     * Updates a quaternion from Euler rotation vector\n     * Example Playground https://playground.babylonjs.com/#L49EJ7#36\n     * @param vec the Euler vector (x Pitch, y Yaw, z Roll)\n     * @param result the quaternion to store the result\n     * @returns the updated quaternion\n     */\n    static FromEulerVectorToRef(vec, result) {\n        Quaternion.RotationYawPitchRollToRef(vec._y, vec._x, vec._z, result);\n        return result;\n    }\n    /**\n     * Updates a quaternion so that it rotates vector vecFrom to vector vecTo\n     * Example Playground - https://playground.babylonjs.com/#L49EJ7#70\n     * @param vecFrom defines the direction vector from which to rotate\n     * @param vecTo defines the direction vector to which to rotate\n     * @param result the quaternion to store the result\n     * @returns the updated quaternion\n     */\n    static FromUnitVectorsToRef(vecFrom, vecTo, result) {\n        const r = Vector3.Dot(vecFrom, vecTo) + 1;\n        if (r < Epsilon) {\n            if (Math.abs(vecFrom.x) > Math.abs(vecFrom.z)) {\n                result.set(-vecFrom.y, vecFrom.x, 0, 0);\n            }\n            else {\n                result.set(0, -vecFrom.z, vecFrom.y, 0);\n            }\n        }\n        else {\n            Vector3.CrossToRef(vecFrom, vecTo, TmpVectors.Vector3[0]);\n            result.set(TmpVectors.Vector3[0].x, TmpVectors.Vector3[0].y, TmpVectors.Vector3[0].z, r);\n        }\n        return result.normalize();\n    }\n    /**\n     * Creates a new quaternion from the given Euler float angles (y, x, z)\n     * Example Playground https://playground.babylonjs.com/#L49EJ7#77\n     * @param yaw defines the rotation around Y axis\n     * @param pitch defines the rotation around X axis\n     * @param roll defines the rotation around Z axis\n     * @returns the new quaternion\n     */\n    static RotationYawPitchRoll(yaw, pitch, roll) {\n        const q = new Quaternion();\n        Quaternion.RotationYawPitchRollToRef(yaw, pitch, roll, q);\n        return q;\n    }\n    /**\n     * Creates a new rotation from the given Euler float angles (y, x, z) and stores it in the target quaternion\n     * Example Playground https://playground.babylonjs.com/#L49EJ7#78\n     * @param yaw defines the rotation around Y axis\n     * @param pitch defines the rotation around X axis\n     * @param roll defines the rotation around Z axis\n     * @param result defines the target quaternion\n     * @returns result input\n     */\n    static RotationYawPitchRollToRef(yaw, pitch, roll, result) {\n        // Produces a quaternion from Euler angles in the z-y-x orientation (Tait-Bryan angles)\n        const halfRoll = roll * 0.5;\n        const halfPitch = pitch * 0.5;\n        const halfYaw = yaw * 0.5;\n        const sinRoll = Math.sin(halfRoll);\n        const cosRoll = Math.cos(halfRoll);\n        const sinPitch = Math.sin(halfPitch);\n        const cosPitch = Math.cos(halfPitch);\n        const sinYaw = Math.sin(halfYaw);\n        const cosYaw = Math.cos(halfYaw);\n        result._x = cosYaw * sinPitch * cosRoll + sinYaw * cosPitch * sinRoll;\n        result._y = sinYaw * cosPitch * cosRoll - cosYaw * sinPitch * sinRoll;\n        result._z = cosYaw * cosPitch * sinRoll - sinYaw * sinPitch * cosRoll;\n        result._w = cosYaw * cosPitch * cosRoll + sinYaw * sinPitch * sinRoll;\n        result._isDirty = true;\n        return result;\n    }\n    /**\n     * Creates a new quaternion from the given Euler float angles expressed in z-x-z orientation\n     * Example Playground https://playground.babylonjs.com/#L49EJ7#68\n     * @param alpha defines the rotation around first axis\n     * @param beta defines the rotation around second axis\n     * @param gamma defines the rotation around third axis\n     * @returns the new quaternion\n     */\n    static RotationAlphaBetaGamma(alpha, beta, gamma) {\n        const result = new Quaternion();\n        Quaternion.RotationAlphaBetaGammaToRef(alpha, beta, gamma, result);\n        return result;\n    }\n    /**\n     * Creates a new quaternion from the given Euler float angles expressed in z-x-z orientation and stores it in the target quaternion\n     * Example Playground https://playground.babylonjs.com/#L49EJ7#69\n     * @param alpha defines the rotation around first axis\n     * @param beta defines the rotation around second axis\n     * @param gamma defines the rotation around third axis\n     * @param result defines the target quaternion\n     * @returns result input\n     */\n    static RotationAlphaBetaGammaToRef(alpha, beta, gamma, result) {\n        // Produces a quaternion from Euler angles in the z-x-z orientation\n        const halfGammaPlusAlpha = (gamma + alpha) * 0.5;\n        const halfGammaMinusAlpha = (gamma - alpha) * 0.5;\n        const halfBeta = beta * 0.5;\n        result._x = Math.cos(halfGammaMinusAlpha) * Math.sin(halfBeta);\n        result._y = Math.sin(halfGammaMinusAlpha) * Math.sin(halfBeta);\n        result._z = Math.sin(halfGammaPlusAlpha) * Math.cos(halfBeta);\n        result._w = Math.cos(halfGammaPlusAlpha) * Math.cos(halfBeta);\n        result._isDirty = true;\n        return result;\n    }\n    /**\n     * Creates a new quaternion containing the rotation value to reach the target (axis1, axis2, axis3) orientation as a rotated XYZ system (axis1, axis2 and axis3 are normalized during this operation)\n     * Example Playground https://playground.babylonjs.com/#L49EJ7#75\n     * @param axis1 defines the first axis\n     * @param axis2 defines the second axis\n     * @param axis3 defines the third axis\n     * @returns the new quaternion\n     */\n    static RotationQuaternionFromAxis(axis1, axis2, axis3) {\n        const quat = new Quaternion(0.0, 0.0, 0.0, 0.0);\n        Quaternion.RotationQuaternionFromAxisToRef(axis1, axis2, axis3, quat);\n        return quat;\n    }\n    /**\n     * Creates a rotation value to reach the target (axis1, axis2, axis3) orientation as a rotated XYZ system (axis1, axis2 and axis3 are normalized during this operation) and stores it in the target quaternion\n     * Example Playground https://playground.babylonjs.com/#L49EJ7#76\n     * @param axis1 defines the first axis\n     * @param axis2 defines the second axis\n     * @param axis3 defines the third axis\n     * @param ref defines the target quaternion\n     * @returns result input\n     */\n    static RotationQuaternionFromAxisToRef(axis1, axis2, axis3, ref) {\n        const rotMat = MathTmp.Matrix[0];\n        Matrix.FromXYZAxesToRef(axis1.normalize(), axis2.normalize(), axis3.normalize(), rotMat);\n        Quaternion.FromRotationMatrixToRef(rotMat, ref);\n        return ref;\n    }\n    /**\n     * Creates a new rotation value to orient an object to look towards the given forward direction, the up direction being oriented like \"up\".\n     * This function works in left handed mode\n     * Example Playground https://playground.babylonjs.com/#L49EJ7#96\n     * @param forward defines the forward direction - Must be normalized and orthogonal to up.\n     * @param up defines the up vector for the entity - Must be normalized and orthogonal to forward.\n     * @returns A new quaternion oriented toward the specified forward and up.\n     */\n    static FromLookDirectionLH(forward, up) {\n        const quat = new Quaternion();\n        Quaternion.FromLookDirectionLHToRef(forward, up, quat);\n        return quat;\n    }\n    /**\n     * Creates a new rotation value to orient an object to look towards the given forward direction with the up direction being oriented like \"up\", and stores it in the target quaternion.\n     * This function works in left handed mode\n     * Example Playground https://playground.babylonjs.com/#L49EJ7#97\n     * @param forward defines the forward direction - Must be normalized and orthogonal to up.\n     * @param up defines the up vector for the entity - Must be normalized and orthogonal to forward.\n     * @param ref defines the target quaternion.\n     * @returns result input\n     */\n    static FromLookDirectionLHToRef(forward, up, ref) {\n        const rotMat = MathTmp.Matrix[0];\n        Matrix.LookDirectionLHToRef(forward, up, rotMat);\n        Quaternion.FromRotationMatrixToRef(rotMat, ref);\n        return ref;\n    }\n    /**\n     * Creates a new rotation value to orient an object to look towards the given forward direction, the up direction being oriented like \"up\".\n     * This function works in right handed mode\n     * Example Playground https://playground.babylonjs.com/#L49EJ7#98\n     * @param forward defines the forward direction - Must be normalized and orthogonal to up.\n     * @param up defines the up vector for the entity - Must be normalized and orthogonal to forward.\n     * @returns A new quaternion oriented toward the specified forward and up.\n     */\n    static FromLookDirectionRH(forward, up) {\n        const quat = new Quaternion();\n        Quaternion.FromLookDirectionRHToRef(forward, up, quat);\n        return quat;\n    }\n    /**\n     * Creates a new rotation value to orient an object to look towards the given forward direction with the up direction being oriented like \"up\", and stores it in the target quaternion.\n     * This function works in right handed mode\n     * Example Playground https://playground.babylonjs.com/#L49EJ7#105\n     * @param forward defines the forward direction - Must be normalized and orthogonal to up.\n     * @param up defines the up vector for the entity - Must be normalized and orthogonal to forward.\n     * @param ref defines the target quaternion.\n     * @returns result input\n     */\n    static FromLookDirectionRHToRef(forward, up, ref) {\n        const rotMat = MathTmp.Matrix[0];\n        Matrix.LookDirectionRHToRef(forward, up, rotMat);\n        return Quaternion.FromRotationMatrixToRef(rotMat, ref);\n    }\n    /**\n     * Interpolates between two quaternions\n     * Example Playground https://playground.babylonjs.com/#L49EJ7#79\n     * @param left defines first quaternion\n     * @param right defines second quaternion\n     * @param amount defines the gradient to use\n     * @returns the new interpolated quaternion\n     */\n    static Slerp(left, right, amount) {\n        const result = Quaternion.Identity();\n        Quaternion.SlerpToRef(left, right, amount, result);\n        return result;\n    }\n    /**\n     * Interpolates between two quaternions and stores it into a target quaternion\n     * Example Playground https://playground.babylonjs.com/#L49EJ7#92\n     * @param left defines first quaternion\n     * @param right defines second quaternion\n     * @param amount defines the gradient to use\n     * @param result defines the target quaternion\n     * @returns result input\n     */\n    static SlerpToRef(left, right, amount, result) {\n        let num2;\n        let num3;\n        let num4 = left._x * right._x + left._y * right._y + left._z * right._z + left._w * right._w;\n        let flag = false;\n        if (num4 < 0) {\n            flag = true;\n            num4 = -num4;\n        }\n        if (num4 > 0.999999) {\n            num3 = 1 - amount;\n            num2 = flag ? -amount : amount;\n        }\n        else {\n            const num5 = Math.acos(num4);\n            const num6 = 1.0 / Math.sin(num5);\n            num3 = Math.sin((1.0 - amount) * num5) * num6;\n            num2 = flag ? -Math.sin(amount * num5) * num6 : Math.sin(amount * num5) * num6;\n        }\n        result._x = num3 * left._x + num2 * right._x;\n        result._y = num3 * left._y + num2 * right._y;\n        result._z = num3 * left._z + num2 * right._z;\n        result._w = num3 * left._w + num2 * right._w;\n        result._isDirty = true;\n        return result;\n    }\n    /**\n     * Interpolate between two quaternions using Hermite interpolation\n     * Example Playground https://playground.babylonjs.com/#L49EJ7#47\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/drawCurves#hermite-quaternion-spline\n     * @param value1 defines first quaternion\n     * @param tangent1 defines the incoming tangent\n     * @param value2 defines second quaternion\n     * @param tangent2 defines the outgoing tangent\n     * @param amount defines the target quaternion\n     * @returns the new interpolated quaternion\n     */\n    static Hermite(value1, tangent1, value2, tangent2, amount) {\n        const squared = amount * amount;\n        const cubed = amount * squared;\n        const part1 = 2.0 * cubed - 3.0 * squared + 1.0;\n        const part2 = -2.0 * cubed + 3.0 * squared;\n        const part3 = cubed - 2.0 * squared + amount;\n        const part4 = cubed - squared;\n        const x = value1._x * part1 + value2._x * part2 + tangent1._x * part3 + tangent2._x * part4;\n        const y = value1._y * part1 + value2._y * part2 + tangent1._y * part3 + tangent2._y * part4;\n        const z = value1._z * part1 + value2._z * part2 + tangent1._z * part3 + tangent2._z * part4;\n        const w = value1._w * part1 + value2._w * part2 + tangent1._w * part3 + tangent2._w * part4;\n        return new value1.constructor(x, y, z, w);\n    }\n    /**\n     * Returns a new Quaternion which is the 1st derivative of the Hermite spline defined by the quaternions \"value1\", \"value2\", \"tangent1\", \"tangent2\".\n     * Example Playground https://playground.babylonjs.com/#L49EJ7#48\n     * @param value1 defines the first control point\n     * @param tangent1 defines the first tangent\n     * @param value2 defines the second control point\n     * @param tangent2 defines the second tangent\n     * @param time define where the derivative must be done\n     * @returns 1st derivative\n     */\n    static Hermite1stDerivative(value1, tangent1, value2, tangent2, time) {\n        const result = new value1.constructor();\n        this.Hermite1stDerivativeToRef(value1, tangent1, value2, tangent2, time, result);\n        return result;\n    }\n    /**\n     * Update a Quaternion with the 1st derivative of the Hermite spline defined by the quaternions \"value1\", \"value2\", \"tangent1\", \"tangent2\".\n     * Example Playground https://playground.babylonjs.com/#L49EJ7#49\n     * @param value1 defines the first control point\n     * @param tangent1 defines the first tangent\n     * @param value2 defines the second control point\n     * @param tangent2 defines the second tangent\n     * @param time define where the derivative must be done\n     * @param result define where to store the derivative\n     * @returns result input\n     */\n    static Hermite1stDerivativeToRef(value1, tangent1, value2, tangent2, time, result) {\n        const t2 = time * time;\n        result._x = (t2 - time) * 6 * value1._x + (3 * t2 - 4 * time + 1) * tangent1._x + (-t2 + time) * 6 * value2._x + (3 * t2 - 2 * time) * tangent2._x;\n        result._y = (t2 - time) * 6 * value1._y + (3 * t2 - 4 * time + 1) * tangent1._y + (-t2 + time) * 6 * value2._y + (3 * t2 - 2 * time) * tangent2._y;\n        result._z = (t2 - time) * 6 * value1._z + (3 * t2 - 4 * time + 1) * tangent1._z + (-t2 + time) * 6 * value2._z + (3 * t2 - 2 * time) * tangent2._z;\n        result._w = (t2 - time) * 6 * value1._w + (3 * t2 - 4 * time + 1) * tangent1._w + (-t2 + time) * 6 * value2._w + (3 * t2 - 2 * time) * tangent2._w;\n        result._isDirty = true;\n        return result;\n    }\n}\n/**\n * Class used to store matrix data (4x4)\n * Note on matrix definitions in Babylon.js for setting values directly\n * rather than using one of the methods available.\n * Matrix size is given by rows x columns.\n * A Vector3 is a 1 X 3 matrix [x, y, z].\n *\n * In Babylon.js multiplying a 1 x 3 matrix by a 4 x 4 matrix\n * is done using BABYLON.Vector4.TransformCoordinates(Vector3, Matrix).\n * and extending the passed Vector3 to a Vector4, V = [x, y, z, 1].\n * Let M be a matrix with elements m(row, column), so that\n * m(2, 3) is the element in row 2 column 3 of M.\n *\n * Multiplication is of the form VM and has the resulting Vector4\n * VM = [xm(0, 0) + ym(1, 0) + zm(2, 0) + m(3, 0), xm(0, 1) + ym(1, 1) + zm(2, 1) + m(3, 1), xm(0, 2) + ym(1, 2) + zm(2, 2) + m(3, 2), xm(0, 3) + ym(1, 3) + zm(2, 3) + m(3, 3)].\n * On the web you will find many examples that use the opposite convention of MV,\n * in which case to make use of the examples you will need to transpose the matrix.\n *\n * Example Playground - Overview Linear Algebra - https://playground.babylonjs.com/#AV9X17\n * Example Playground - Overview Transformation - https://playground.babylonjs.com/#AV9X17#1\n * Example Playground - Overview Projection - https://playground.babylonjs.com/#AV9X17#2\n */\nexport class Matrix {\n    /**\n     * Gets the precision of matrix computations\n     */\n    static get Use64Bits() {\n        return PerformanceConfigurator.MatrixUse64Bits;\n    }\n    /**\n     * Gets the internal data of the matrix\n     */\n    get m() {\n        return this._m;\n    }\n    /**\n     * Update the updateFlag to indicate that the matrix has been updated\n     */\n    markAsUpdated() {\n        this.updateFlag = Matrix._UpdateFlagSeed++;\n        this._isIdentity = false;\n        this._isIdentity3x2 = false;\n        this._isIdentityDirty = true;\n        this._isIdentity3x2Dirty = true;\n    }\n    _updateIdentityStatus(isIdentity, isIdentityDirty = false, isIdentity3x2 = false, isIdentity3x2Dirty = true) {\n        this._isIdentity = isIdentity;\n        this._isIdentity3x2 = isIdentity || isIdentity3x2;\n        this._isIdentityDirty = this._isIdentity ? false : isIdentityDirty;\n        this._isIdentity3x2Dirty = this._isIdentity3x2 ? false : isIdentity3x2Dirty;\n    }\n    /**\n     * Creates an empty matrix (filled with zeros)\n     */\n    constructor() {\n        this._isIdentity = false;\n        this._isIdentityDirty = true;\n        this._isIdentity3x2 = true;\n        this._isIdentity3x2Dirty = true;\n        /**\n         * Gets the update flag of the matrix which is an unique number for the matrix.\n         * It will be incremented every time the matrix data change.\n         * You can use it to speed the comparison between two versions of the same matrix.\n         */\n        this.updateFlag = -1;\n        if (PerformanceConfigurator.MatrixTrackPrecisionChange) {\n            PerformanceConfigurator.MatrixTrackedMatrices.push(this);\n        }\n        this._m = new PerformanceConfigurator.MatrixCurrentType(16);\n        this.markAsUpdated();\n    }\n    // Properties\n    /**\n     * Check if the current matrix is identity\n     * @returns true is the matrix is the identity matrix\n     */\n    isIdentity() {\n        if (this._isIdentityDirty) {\n            this._isIdentityDirty = false;\n            const m = this._m;\n            this._isIdentity =\n                m[0] === 1.0 &&\n                    m[1] === 0.0 &&\n                    m[2] === 0.0 &&\n                    m[3] === 0.0 &&\n                    m[4] === 0.0 &&\n                    m[5] === 1.0 &&\n                    m[6] === 0.0 &&\n                    m[7] === 0.0 &&\n                    m[8] === 0.0 &&\n                    m[9] === 0.0 &&\n                    m[10] === 1.0 &&\n                    m[11] === 0.0 &&\n                    m[12] === 0.0 &&\n                    m[13] === 0.0 &&\n                    m[14] === 0.0 &&\n                    m[15] === 1.0;\n        }\n        return this._isIdentity;\n    }\n    /**\n     * Check if the current matrix is identity as a texture matrix (3x2 store in 4x4)\n     * @returns true is the matrix is the identity matrix\n     */\n    isIdentityAs3x2() {\n        if (this._isIdentity3x2Dirty) {\n            this._isIdentity3x2Dirty = false;\n            if (this._m[0] !== 1.0 || this._m[5] !== 1.0 || this._m[15] !== 1.0) {\n                this._isIdentity3x2 = false;\n            }\n            else if (this._m[1] !== 0.0 ||\n                this._m[2] !== 0.0 ||\n                this._m[3] !== 0.0 ||\n                this._m[4] !== 0.0 ||\n                this._m[6] !== 0.0 ||\n                this._m[7] !== 0.0 ||\n                this._m[8] !== 0.0 ||\n                this._m[9] !== 0.0 ||\n                this._m[10] !== 0.0 ||\n                this._m[11] !== 0.0 ||\n                this._m[12] !== 0.0 ||\n                this._m[13] !== 0.0 ||\n                this._m[14] !== 0.0) {\n                this._isIdentity3x2 = false;\n            }\n            else {\n                this._isIdentity3x2 = true;\n            }\n        }\n        return this._isIdentity3x2;\n    }\n    /**\n     * Gets the determinant of the matrix\n     * Example Playground - https://playground.babylonjs.com/#AV9X17#34\n     * @returns the matrix determinant\n     */\n    determinant() {\n        if (this._isIdentity === true) {\n            return 1;\n        }\n        const m = this._m;\n        const m00 = m[0], m01 = m[1], m02 = m[2], m03 = m[3];\n        const m10 = m[4], m11 = m[5], m12 = m[6], m13 = m[7];\n        const m20 = m[8], m21 = m[9], m22 = m[10], m23 = m[11];\n        const m30 = m[12], m31 = m[13], m32 = m[14], m33 = m[15];\n        // https://en.wikipedia.org/wiki/Laplace_expansion\n        // to compute the deterrminant of a 4x4 Matrix we compute the cofactors of any row or column,\n        // then we multiply each Cofactor by its corresponding matrix value and sum them all to get the determinant\n        // Cofactor(i, j) = sign(i,j) * det(Minor(i, j))\n        // where\n        //  - sign(i,j) = (i+j) % 2 === 0 ? 1 : -1\n        //  - Minor(i, j) is the 3x3 matrix we get by removing row i and column j from current Matrix\n        //\n        // Here we do that for the 1st row.\n        const det_22_33 = m22 * m33 - m32 * m23;\n        const det_21_33 = m21 * m33 - m31 * m23;\n        const det_21_32 = m21 * m32 - m31 * m22;\n        const det_20_33 = m20 * m33 - m30 * m23;\n        const det_20_32 = m20 * m32 - m22 * m30;\n        const det_20_31 = m20 * m31 - m30 * m21;\n        const cofact_00 = +(m11 * det_22_33 - m12 * det_21_33 + m13 * det_21_32);\n        const cofact_01 = -(m10 * det_22_33 - m12 * det_20_33 + m13 * det_20_32);\n        const cofact_02 = +(m10 * det_21_33 - m11 * det_20_33 + m13 * det_20_31);\n        const cofact_03 = -(m10 * det_21_32 - m11 * det_20_32 + m12 * det_20_31);\n        return m00 * cofact_00 + m01 * cofact_01 + m02 * cofact_02 + m03 * cofact_03;\n    }\n    // Methods\n    /**\n     * Returns the matrix as a Float32Array or Array<number>\n     * Example Playground - https://playground.babylonjs.com/#AV9X17#49\n     * @returns the matrix underlying array\n     */\n    toArray() {\n        return this._m;\n    }\n    /**\n     * Returns the matrix as a Float32Array or Array<number>\n     * Example Playground - https://playground.babylonjs.com/#AV9X17#114\n     * @returns the matrix underlying array.\n     */\n    asArray() {\n        return this._m;\n    }\n    /**\n     * Inverts the current matrix in place\n     * Example Playground - https://playground.babylonjs.com/#AV9X17#118\n     * @returns the current inverted matrix\n     */\n    invert() {\n        this.invertToRef(this);\n        return this;\n    }\n    /**\n     * Sets all the matrix elements to zero\n     * @returns the current matrix\n     */\n    reset() {\n        Matrix.FromValuesToRef(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, this);\n        this._updateIdentityStatus(false);\n        return this;\n    }\n    /**\n     * Adds the current matrix with a second one\n     * Example Playground - https://playground.babylonjs.com/#AV9X17#44\n     * @param other defines the matrix to add\n     * @returns a new matrix as the addition of the current matrix and the given one\n     */\n    add(other) {\n        const result = new this.constructor();\n        this.addToRef(other, result);\n        return result;\n    }\n    /**\n     * Sets the given matrix \"result\" to the addition of the current matrix and the given one\n     * Example Playground - https://playground.babylonjs.com/#AV9X17#45\n     * @param other defines the matrix to add\n     * @param result defines the target matrix\n     * @returns result input\n     */\n    addToRef(other, result) {\n        const m = this._m;\n        const resultM = result._m;\n        const otherM = other.m;\n        for (let index = 0; index < 16; index++) {\n            resultM[index] = m[index] + otherM[index];\n        }\n        result.markAsUpdated();\n        return result;\n    }\n    /**\n     * Adds in place the given matrix to the current matrix\n     * Example Playground - https://playground.babylonjs.com/#AV9X17#46\n     * @param other defines the second operand\n     * @returns the current updated matrix\n     */\n    addToSelf(other) {\n        const m = this._m;\n        const otherM = other.m;\n        for (let index = 0; index < 16; index++) {\n            m[index] += otherM[index];\n        }\n        this.markAsUpdated();\n        return this;\n    }\n    /**\n     * Sets the given matrix to the current inverted Matrix\n     * Example Playground - https://playground.babylonjs.com/#AV9X17#119\n     * @param other defines the target matrix\n     * @returns result input\n     */\n    invertToRef(other) {\n        if (this._isIdentity === true) {\n            Matrix.IdentityToRef(other);\n            return other;\n        }\n        // the inverse of a Matrix is the transpose of cofactor matrix divided by the determinant\n        const m = this._m;\n        const m00 = m[0], m01 = m[1], m02 = m[2], m03 = m[3];\n        const m10 = m[4], m11 = m[5], m12 = m[6], m13 = m[7];\n        const m20 = m[8], m21 = m[9], m22 = m[10], m23 = m[11];\n        const m30 = m[12], m31 = m[13], m32 = m[14], m33 = m[15];\n        const det_22_33 = m22 * m33 - m32 * m23;\n        const det_21_33 = m21 * m33 - m31 * m23;\n        const det_21_32 = m21 * m32 - m31 * m22;\n        const det_20_33 = m20 * m33 - m30 * m23;\n        const det_20_32 = m20 * m32 - m22 * m30;\n        const det_20_31 = m20 * m31 - m30 * m21;\n        const cofact_00 = +(m11 * det_22_33 - m12 * det_21_33 + m13 * det_21_32);\n        const cofact_01 = -(m10 * det_22_33 - m12 * det_20_33 + m13 * det_20_32);\n        const cofact_02 = +(m10 * det_21_33 - m11 * det_20_33 + m13 * det_20_31);\n        const cofact_03 = -(m10 * det_21_32 - m11 * det_20_32 + m12 * det_20_31);\n        const det = m00 * cofact_00 + m01 * cofact_01 + m02 * cofact_02 + m03 * cofact_03;\n        if (det === 0) {\n            // not invertible\n            other.copyFrom(this);\n            return other;\n        }\n        const detInv = 1 / det;\n        const det_12_33 = m12 * m33 - m32 * m13;\n        const det_11_33 = m11 * m33 - m31 * m13;\n        const det_11_32 = m11 * m32 - m31 * m12;\n        const det_10_33 = m10 * m33 - m30 * m13;\n        const det_10_32 = m10 * m32 - m30 * m12;\n        const det_10_31 = m10 * m31 - m30 * m11;\n        const det_12_23 = m12 * m23 - m22 * m13;\n        const det_11_23 = m11 * m23 - m21 * m13;\n        const det_11_22 = m11 * m22 - m21 * m12;\n        const det_10_23 = m10 * m23 - m20 * m13;\n        const det_10_22 = m10 * m22 - m20 * m12;\n        const det_10_21 = m10 * m21 - m20 * m11;\n        const cofact_10 = -(m01 * det_22_33 - m02 * det_21_33 + m03 * det_21_32);\n        const cofact_11 = +(m00 * det_22_33 - m02 * det_20_33 + m03 * det_20_32);\n        const cofact_12 = -(m00 * det_21_33 - m01 * det_20_33 + m03 * det_20_31);\n        const cofact_13 = +(m00 * det_21_32 - m01 * det_20_32 + m02 * det_20_31);\n        const cofact_20 = +(m01 * det_12_33 - m02 * det_11_33 + m03 * det_11_32);\n        const cofact_21 = -(m00 * det_12_33 - m02 * det_10_33 + m03 * det_10_32);\n        const cofact_22 = +(m00 * det_11_33 - m01 * det_10_33 + m03 * det_10_31);\n        const cofact_23 = -(m00 * det_11_32 - m01 * det_10_32 + m02 * det_10_31);\n        const cofact_30 = -(m01 * det_12_23 - m02 * det_11_23 + m03 * det_11_22);\n        const cofact_31 = +(m00 * det_12_23 - m02 * det_10_23 + m03 * det_10_22);\n        const cofact_32 = -(m00 * det_11_23 - m01 * det_10_23 + m03 * det_10_21);\n        const cofact_33 = +(m00 * det_11_22 - m01 * det_10_22 + m02 * det_10_21);\n        Matrix.FromValuesToRef(cofact_00 * detInv, cofact_10 * detInv, cofact_20 * detInv, cofact_30 * detInv, cofact_01 * detInv, cofact_11 * detInv, cofact_21 * detInv, cofact_31 * detInv, cofact_02 * detInv, cofact_12 * detInv, cofact_22 * detInv, cofact_32 * detInv, cofact_03 * detInv, cofact_13 * detInv, cofact_23 * detInv, cofact_33 * detInv, other);\n        return other;\n    }\n    /**\n     * add a value at the specified position in the current Matrix\n     * Example Playground - https://playground.babylonjs.com/#AV9X17#47\n     * @param index the index of the value within the matrix. between 0 and 15.\n     * @param value the value to be added\n     * @returns the current updated matrix\n     */\n    addAtIndex(index, value) {\n        this._m[index] += value;\n        this.markAsUpdated();\n        return this;\n    }\n    /**\n     * mutiply the specified position in the current Matrix by a value\n     * @param index the index of the value within the matrix. between 0 and 15.\n     * @param value the value to be added\n     * @returns the current updated matrix\n     */\n    multiplyAtIndex(index, value) {\n        this._m[index] *= value;\n        this.markAsUpdated();\n        return this;\n    }\n    /**\n     * Inserts the translation vector (using 3 floats) in the current matrix\n     * Example Playground - https://playground.babylonjs.com/#AV9X17#120\n     * @param x defines the 1st component of the translation\n     * @param y defines the 2nd component of the translation\n     * @param z defines the 3rd component of the translation\n     * @returns the current updated matrix\n     */\n    setTranslationFromFloats(x, y, z) {\n        this._m[12] = x;\n        this._m[13] = y;\n        this._m[14] = z;\n        this.markAsUpdated();\n        return this;\n    }\n    /**\n     * Adds the translation vector (using 3 floats) in the current matrix\n     * Example Playground - https://playground.babylonjs.com/#AV9X17#20\n     * Example Playground - https://playground.babylonjs.com/#AV9X17#48\n     * @param x defines the 1st component of the translation\n     * @param y defines the 2nd component of the translation\n     * @param z defines the 3rd component of the translation\n     * @returns the current updated matrix\n     */\n    addTranslationFromFloats(x, y, z) {\n        this._m[12] += x;\n        this._m[13] += y;\n        this._m[14] += z;\n        this.markAsUpdated();\n        return this;\n    }\n    /**\n     * Inserts the translation vector in the current matrix\n     * Example Playground - https://playground.babylonjs.com/#AV9X17#121\n     * @param vector3 defines the translation to insert\n     * @returns the current updated matrix\n     */\n    setTranslation(vector3) {\n        return this.setTranslationFromFloats(vector3._x, vector3._y, vector3._z);\n    }\n    /**\n     * Gets the translation value of the current matrix\n     * Example Playground - https://playground.babylonjs.com/#AV9X17#122\n     * @returns a new Vector3 as the extracted translation from the matrix\n     */\n    getTranslation() {\n        return new Vector3(this._m[12], this._m[13], this._m[14]);\n    }\n    /**\n     * Fill a Vector3 with the extracted translation from the matrix\n     * Example Playground - https://playground.babylonjs.com/#AV9X17#123\n     * @param result defines the Vector3 where to store the translation\n     * @returns the current matrix\n     */\n    getTranslationToRef(result) {\n        result.x = this._m[12];\n        result.y = this._m[13];\n        result.z = this._m[14];\n        return result;\n    }\n    /**\n     * Remove rotation and scaling part from the matrix\n     * @returns the updated matrix\n     */\n    removeRotationAndScaling() {\n        const m = this.m;\n        Matrix.FromValuesToRef(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, m[12], m[13], m[14], m[15], this);\n        this._updateIdentityStatus(m[12] === 0 && m[13] === 0 && m[14] === 0 && m[15] === 1);\n        return this;\n    }\n    /**\n     * Multiply two matrices\n     * Example Playground - https://playground.babylonjs.com/#AV9X17#15\n     * A.multiply(B) means apply B to A so result is B x A\n     * @param other defines the second operand\n     * @returns a new matrix set with the multiplication result of the current Matrix and the given one\n     */\n    multiply(other) {\n        const result = new this.constructor();\n        this.multiplyToRef(other, result);\n        return result;\n    }\n    /**\n     * Copy the current matrix from the given one\n     * Example Playground - https://playground.babylonjs.com/#AV9X17#21\n     * @param other defines the source matrix\n     * @returns the current updated matrix\n     */\n    copyFrom(other) {\n        other.copyToArray(this._m);\n        const o = other;\n        this.updateFlag = o.updateFlag;\n        this._updateIdentityStatus(o._isIdentity, o._isIdentityDirty, o._isIdentity3x2, o._isIdentity3x2Dirty);\n        return this;\n    }\n    /**\n     * Populates the given array from the starting index with the current matrix values\n     * @param array defines the target array\n     * @param offset defines the offset in the target array where to start storing values\n     * @returns the current matrix\n     */\n    copyToArray(array, offset = 0) {\n        const source = this._m;\n        array[offset] = source[0];\n        array[offset + 1] = source[1];\n        array[offset + 2] = source[2];\n        array[offset + 3] = source[3];\n        array[offset + 4] = source[4];\n        array[offset + 5] = source[5];\n        array[offset + 6] = source[6];\n        array[offset + 7] = source[7];\n        array[offset + 8] = source[8];\n        array[offset + 9] = source[9];\n        array[offset + 10] = source[10];\n        array[offset + 11] = source[11];\n        array[offset + 12] = source[12];\n        array[offset + 13] = source[13];\n        array[offset + 14] = source[14];\n        array[offset + 15] = source[15];\n        return this;\n    }\n    /**\n     * Sets the given matrix \"result\" with the multiplication result of the current Matrix and the given one\n     * A.multiplyToRef(B, R) means apply B to A and store in R and R = B x A\n     * Example Playground - https://playground.babylonjs.com/#AV9X17#16\n     * @param other defines the second operand\n     * @param result defines the matrix where to store the multiplication\n     * @returns result input\n     */\n    multiplyToRef(other, result) {\n        if (this._isIdentity) {\n            result.copyFrom(other);\n            return result;\n        }\n        if (other._isIdentity) {\n            result.copyFrom(this);\n            return result;\n        }\n        this.multiplyToArray(other, result._m, 0);\n        result.markAsUpdated();\n        return result;\n    }\n    /**\n     * Sets the Float32Array \"result\" from the given index \"offset\" with the multiplication of the current matrix and the given one\n     * @param other defines the second operand\n     * @param result defines the array where to store the multiplication\n     * @param offset defines the offset in the target array where to start storing values\n     * @returns the current matrix\n     */\n    multiplyToArray(other, result, offset) {\n        const m = this._m;\n        const otherM = other.m;\n        const tm0 = m[0], tm1 = m[1], tm2 = m[2], tm3 = m[3];\n        const tm4 = m[4], tm5 = m[5], tm6 = m[6], tm7 = m[7];\n        const tm8 = m[8], tm9 = m[9], tm10 = m[10], tm11 = m[11];\n        const tm12 = m[12], tm13 = m[13], tm14 = m[14], tm15 = m[15];\n        const om0 = otherM[0], om1 = otherM[1], om2 = otherM[2], om3 = otherM[3];\n        const om4 = otherM[4], om5 = otherM[5], om6 = otherM[6], om7 = otherM[7];\n        const om8 = otherM[8], om9 = otherM[9], om10 = otherM[10], om11 = otherM[11];\n        const om12 = otherM[12], om13 = otherM[13], om14 = otherM[14], om15 = otherM[15];\n        result[offset] = tm0 * om0 + tm1 * om4 + tm2 * om8 + tm3 * om12;\n        result[offset + 1] = tm0 * om1 + tm1 * om5 + tm2 * om9 + tm3 * om13;\n        result[offset + 2] = tm0 * om2 + tm1 * om6 + tm2 * om10 + tm3 * om14;\n        result[offset + 3] = tm0 * om3 + tm1 * om7 + tm2 * om11 + tm3 * om15;\n        result[offset + 4] = tm4 * om0 + tm5 * om4 + tm6 * om8 + tm7 * om12;\n        result[offset + 5] = tm4 * om1 + tm5 * om5 + tm6 * om9 + tm7 * om13;\n        result[offset + 6] = tm4 * om2 + tm5 * om6 + tm6 * om10 + tm7 * om14;\n        result[offset + 7] = tm4 * om3 + tm5 * om7 + tm6 * om11 + tm7 * om15;\n        result[offset + 8] = tm8 * om0 + tm9 * om4 + tm10 * om8 + tm11 * om12;\n        result[offset + 9] = tm8 * om1 + tm9 * om5 + tm10 * om9 + tm11 * om13;\n        result[offset + 10] = tm8 * om2 + tm9 * om6 + tm10 * om10 + tm11 * om14;\n        result[offset + 11] = tm8 * om3 + tm9 * om7 + tm10 * om11 + tm11 * om15;\n        result[offset + 12] = tm12 * om0 + tm13 * om4 + tm14 * om8 + tm15 * om12;\n        result[offset + 13] = tm12 * om1 + tm13 * om5 + tm14 * om9 + tm15 * om13;\n        result[offset + 14] = tm12 * om2 + tm13 * om6 + tm14 * om10 + tm15 * om14;\n        result[offset + 15] = tm12 * om3 + tm13 * om7 + tm14 * om11 + tm15 * om15;\n        return this;\n    }\n    /**\n     * Check equality between this matrix and a second one\n     * @param value defines the second matrix to compare\n     * @returns true is the current matrix and the given one values are strictly equal\n     */\n    equals(value) {\n        const other = value;\n        if (!other) {\n            return false;\n        }\n        if (this._isIdentity || other._isIdentity) {\n            if (!this._isIdentityDirty && !other._isIdentityDirty) {\n                return this._isIdentity && other._isIdentity;\n            }\n        }\n        const m = this.m;\n        const om = other.m;\n        return (m[0] === om[0] &&\n            m[1] === om[1] &&\n            m[2] === om[2] &&\n            m[3] === om[3] &&\n            m[4] === om[4] &&\n            m[5] === om[5] &&\n            m[6] === om[6] &&\n            m[7] === om[7] &&\n            m[8] === om[8] &&\n            m[9] === om[9] &&\n            m[10] === om[10] &&\n            m[11] === om[11] &&\n            m[12] === om[12] &&\n            m[13] === om[13] &&\n            m[14] === om[14] &&\n            m[15] === om[15]);\n    }\n    /**\n     * Clone the current matrix\n     * Example Playground - https://playground.babylonjs.com/#AV9X17#18\n     * @returns a new matrix from the current matrix\n     */\n    clone() {\n        const matrix = new this.constructor();\n        matrix.copyFrom(this);\n        return matrix;\n    }\n    /**\n     * Returns the name of the current matrix class\n     * @returns the string \"Matrix\"\n     */\n    getClassName() {\n        return \"Matrix\";\n    }\n    /**\n     * Gets the hash code of the current matrix\n     * @returns the hash code\n     */\n    getHashCode() {\n        let hash = _ExtractAsInt(this._m[0]);\n        for (let i = 1; i < 16; i++) {\n            hash = (hash * 397) ^ _ExtractAsInt(this._m[i]);\n        }\n        return hash;\n    }\n    /**\n     * Decomposes the current Matrix into a translation, rotation and scaling components of the provided node\n     * Example Playground - https://playground.babylonjs.com/#AV9X17#13\n     * @param node the node to decompose the matrix to\n     * @returns true if operation was successful\n     */\n    decomposeToTransformNode(node) {\n        node.rotationQuaternion = node.rotationQuaternion || new Quaternion();\n        return this.decompose(node.scaling, node.rotationQuaternion, node.position);\n    }\n    /**\n     * Decomposes the current Matrix into a translation, rotation and scaling components\n     * Example Playground - https://playground.babylonjs.com/#AV9X17#12\n     * @param scale defines the scale vector3 given as a reference to update\n     * @param rotation defines the rotation quaternion given as a reference to update\n     * @param translation defines the translation vector3 given as a reference to update\n     * @param preserveScalingNode Use scaling sign coming from this node. Otherwise scaling sign might change.\n     * @returns true if operation was successful\n     */\n    decompose(scale, rotation, translation, preserveScalingNode) {\n        if (this._isIdentity) {\n            if (translation) {\n                translation.setAll(0);\n            }\n            if (scale) {\n                scale.setAll(1);\n            }\n            if (rotation) {\n                rotation.copyFromFloats(0, 0, 0, 1);\n            }\n            return true;\n        }\n        const m = this._m;\n        if (translation) {\n            translation.copyFromFloats(m[12], m[13], m[14]);\n        }\n        scale = scale || MathTmp.Vector3[0];\n        scale.x = Math.sqrt(m[0] * m[0] + m[1] * m[1] + m[2] * m[2]);\n        scale.y = Math.sqrt(m[4] * m[4] + m[5] * m[5] + m[6] * m[6]);\n        scale.z = Math.sqrt(m[8] * m[8] + m[9] * m[9] + m[10] * m[10]);\n        if (preserveScalingNode) {\n            const signX = preserveScalingNode.scaling.x < 0 ? -1 : 1;\n            const signY = preserveScalingNode.scaling.y < 0 ? -1 : 1;\n            const signZ = preserveScalingNode.scaling.z < 0 ? -1 : 1;\n            scale.x *= signX;\n            scale.y *= signY;\n            scale.z *= signZ;\n        }\n        else {\n            if (this.determinant() <= 0) {\n                scale.y *= -1;\n            }\n        }\n        if (scale._x === 0 || scale._y === 0 || scale._z === 0) {\n            if (rotation) {\n                rotation.copyFromFloats(0.0, 0.0, 0.0, 1.0);\n            }\n            return false;\n        }\n        if (rotation) {\n            const sx = 1 / scale._x, sy = 1 / scale._y, sz = 1 / scale._z;\n            Matrix.FromValuesToRef(m[0] * sx, m[1] * sx, m[2] * sx, 0.0, m[4] * sy, m[5] * sy, m[6] * sy, 0.0, m[8] * sz, m[9] * sz, m[10] * sz, 0.0, 0.0, 0.0, 0.0, 1.0, MathTmp.Matrix[0]);\n            Quaternion.FromRotationMatrixToRef(MathTmp.Matrix[0], rotation);\n        }\n        return true;\n    }\n    /**\n     * Gets specific row of the matrix\n     * Example Playground - https://playground.babylonjs.com/#AV9X17#36\n     * @param index defines the number of the row to get\n     * @returns the index-th row of the current matrix as a new Vector4\n     */\n    getRow(index) {\n        if (index < 0 || index > 3) {\n            return null;\n        }\n        const i = index * 4;\n        return new Vector4(this._m[i + 0], this._m[i + 1], this._m[i + 2], this._m[i + 3]);\n    }\n    /**\n     * Gets specific row of the matrix to ref\n     * Example Playground - https://playground.babylonjs.com/#AV9X17#36\n     * @param index defines the number of the row to get\n     * @param rowVector vector to store the index-th row of the current matrix\n     * @returns result input\n     */\n    getRowToRef(index, rowVector) {\n        if (index >= 0 && index < 3) {\n            const i = index * 4;\n            rowVector.x = this._m[i + 0];\n            rowVector.y = this._m[i + 1];\n            rowVector.z = this._m[i + 2];\n            rowVector.w = this._m[i + 3];\n        }\n        return rowVector;\n    }\n    /**\n     * Sets the index-th row of the current matrix to the vector4 values\n     * Example Playground - https://playground.babylonjs.com/#AV9X17#36\n     * @param index defines the number of the row to set\n     * @param row defines the target vector4\n     * @returns the updated current matrix\n     */\n    setRow(index, row) {\n        return this.setRowFromFloats(index, row.x, row.y, row.z, row.w);\n    }\n    /**\n     * Compute the transpose of the matrix\n     * Example Playground - https://playground.babylonjs.com/#AV9X17#40\n     * @returns the new transposed matrix\n     */\n    transpose() {\n        const result = new this.constructor();\n        Matrix.TransposeToRef(this, result);\n        return result;\n    }\n    /**\n     * Compute the transpose of the matrix and store it in a given matrix\n     * Example Playground - https://playground.babylonjs.com/#AV9X17#41\n     * @param result defines the target matrix\n     * @returns result input\n     */\n    transposeToRef(result) {\n        Matrix.TransposeToRef(this, result);\n        return result;\n    }\n    /**\n     * Sets the index-th row of the current matrix with the given 4 x float values\n     * Example Playground - https://playground.babylonjs.com/#AV9X17#36\n     * @param index defines the row index\n     * @param x defines the x component to set\n     * @param y defines the y component to set\n     * @param z defines the z component to set\n     * @param w defines the w component to set\n     * @returns the updated current matrix\n     */\n    setRowFromFloats(index, x, y, z, w) {\n        if (index < 0 || index > 3) {\n            return this;\n        }\n        const i = index * 4;\n        this._m[i + 0] = x;\n        this._m[i + 1] = y;\n        this._m[i + 2] = z;\n        this._m[i + 3] = w;\n        this.markAsUpdated();\n        return this;\n    }\n    /**\n     * Compute a new matrix set with the current matrix values multiplied by scale (float)\n     * @param scale defines the scale factor\n     * @returns a new matrix\n     */\n    scale(scale) {\n        const result = new this.constructor();\n        this.scaleToRef(scale, result);\n        return result;\n    }\n    /**\n     * Scale the current matrix values by a factor to a given result matrix\n     * @param scale defines the scale factor\n     * @param result defines the matrix to store the result\n     * @returns result input\n     */\n    scaleToRef(scale, result) {\n        for (let index = 0; index < 16; index++) {\n            result._m[index] = this._m[index] * scale;\n        }\n        result.markAsUpdated();\n        return result;\n    }\n    /**\n     * Scale the current matrix values by a factor and add the result to a given matrix\n     * @param scale defines the scale factor\n     * @param result defines the Matrix to store the result\n     * @returns result input\n     */\n    scaleAndAddToRef(scale, result) {\n        for (let index = 0; index < 16; index++) {\n            result._m[index] += this._m[index] * scale;\n        }\n        result.markAsUpdated();\n        return result;\n    }\n    /**\n     * Writes to the given matrix a normal matrix, computed from this one (using values from identity matrix for fourth row and column).\n     * Example Playground - https://playground.babylonjs.com/#AV9X17#17\n     * @param ref matrix to store the result\n     */\n    toNormalMatrix(ref) {\n        const tmp = MathTmp.Matrix[0];\n        this.invertToRef(tmp);\n        tmp.transposeToRef(ref);\n        const m = ref._m;\n        Matrix.FromValuesToRef(m[0], m[1], m[2], 0.0, m[4], m[5], m[6], 0.0, m[8], m[9], m[10], 0.0, 0.0, 0.0, 0.0, 1.0, ref);\n        return ref;\n    }\n    /**\n     * Gets only rotation part of the current matrix\n     * @returns a new matrix sets to the extracted rotation matrix from the current one\n     */\n    getRotationMatrix() {\n        const result = new this.constructor();\n        this.getRotationMatrixToRef(result);\n        return result;\n    }\n    /**\n     * Extracts the rotation matrix from the current one and sets it as the given \"result\"\n     * @param result defines the target matrix to store data to\n     * @returns result input\n     */\n    getRotationMatrixToRef(result) {\n        const scale = MathTmp.Vector3[0];\n        if (!this.decompose(scale)) {\n            Matrix.IdentityToRef(result);\n            return result;\n        }\n        const m = this._m;\n        const sx = 1 / scale._x, sy = 1 / scale._y, sz = 1 / scale._z;\n        Matrix.FromValuesToRef(m[0] * sx, m[1] * sx, m[2] * sx, 0.0, m[4] * sy, m[5] * sy, m[6] * sy, 0.0, m[8] * sz, m[9] * sz, m[10] * sz, 0.0, 0.0, 0.0, 0.0, 1.0, result);\n        return result;\n    }\n    /**\n     * Toggles model matrix from being right handed to left handed in place and vice versa\n     */\n    toggleModelMatrixHandInPlace() {\n        const m = this._m;\n        m[2] *= -1;\n        m[6] *= -1;\n        m[8] *= -1;\n        m[9] *= -1;\n        m[14] *= -1;\n        this.markAsUpdated();\n        return this;\n    }\n    /**\n     * Toggles projection matrix from being right handed to left handed in place and vice versa\n     */\n    toggleProjectionMatrixHandInPlace() {\n        const m = this._m;\n        m[8] *= -1;\n        m[9] *= -1;\n        m[10] *= -1;\n        m[11] *= -1;\n        this.markAsUpdated();\n        return this;\n    }\n    // Statics\n    /**\n     * Creates a matrix from an array\n     * Example Playground - https://playground.babylonjs.com/#AV9X17#42\n     * @param array defines the source array\n     * @param offset defines an offset in the source array\n     * @returns a new Matrix set from the starting index of the given array\n     */\n    static FromArray(array, offset = 0) {\n        const result = new Matrix();\n        Matrix.FromArrayToRef(array, offset, result);\n        return result;\n    }\n    /**\n     * Copy the content of an array into a given matrix\n     * Example Playground - https://playground.babylonjs.com/#AV9X17#43\n     * @param array defines the source array\n     * @param offset defines an offset in the source array\n     * @param result defines the target matrix\n     * @returns result input\n     */\n    static FromArrayToRef(array, offset, result) {\n        for (let index = 0; index < 16; index++) {\n            result._m[index] = array[index + offset];\n        }\n        result.markAsUpdated();\n        return result;\n    }\n    /**\n     * Stores an array into a matrix after having multiplied each component by a given factor\n     * Example Playground - https://playground.babylonjs.com/#AV9X17#50\n     * @param array defines the source array\n     * @param offset defines the offset in the source array\n     * @param scale defines the scaling factor\n     * @param result defines the target matrix\n     * @returns result input\n     */\n    static FromFloat32ArrayToRefScaled(array, offset, scale, result) {\n        for (let index = 0; index < 16; index++) {\n            result._m[index] = array[index + offset] * scale;\n        }\n        result.markAsUpdated();\n        return result;\n    }\n    /**\n     * Gets an identity matrix that must not be updated\n     */\n    static get IdentityReadOnly() {\n        return Matrix._IdentityReadOnly;\n    }\n    /**\n     * Stores a list of values (16) inside a given matrix\n     * @param initialM11 defines 1st value of 1st row\n     * @param initialM12 defines 2nd value of 1st row\n     * @param initialM13 defines 3rd value of 1st row\n     * @param initialM14 defines 4th value of 1st row\n     * @param initialM21 defines 1st value of 2nd row\n     * @param initialM22 defines 2nd value of 2nd row\n     * @param initialM23 defines 3rd value of 2nd row\n     * @param initialM24 defines 4th value of 2nd row\n     * @param initialM31 defines 1st value of 3rd row\n     * @param initialM32 defines 2nd value of 3rd row\n     * @param initialM33 defines 3rd value of 3rd row\n     * @param initialM34 defines 4th value of 3rd row\n     * @param initialM41 defines 1st value of 4th row\n     * @param initialM42 defines 2nd value of 4th row\n     * @param initialM43 defines 3rd value of 4th row\n     * @param initialM44 defines 4th value of 4th row\n     * @param result defines the target matrix\n     * @returns result input\n     */\n    static FromValuesToRef(initialM11, initialM12, initialM13, initialM14, initialM21, initialM22, initialM23, initialM24, initialM31, initialM32, initialM33, initialM34, initialM41, initialM42, initialM43, initialM44, result) {\n        const m = result._m;\n        m[0] = initialM11;\n        m[1] = initialM12;\n        m[2] = initialM13;\n        m[3] = initialM14;\n        m[4] = initialM21;\n        m[5] = initialM22;\n        m[6] = initialM23;\n        m[7] = initialM24;\n        m[8] = initialM31;\n        m[9] = initialM32;\n        m[10] = initialM33;\n        m[11] = initialM34;\n        m[12] = initialM41;\n        m[13] = initialM42;\n        m[14] = initialM43;\n        m[15] = initialM44;\n        result.markAsUpdated();\n    }\n    /**\n     * Creates new matrix from a list of values (16)\n     * @param initialM11 defines 1st value of 1st row\n     * @param initialM12 defines 2nd value of 1st row\n     * @param initialM13 defines 3rd value of 1st row\n     * @param initialM14 defines 4th value of 1st row\n     * @param initialM21 defines 1st value of 2nd row\n     * @param initialM22 defines 2nd value of 2nd row\n     * @param initialM23 defines 3rd value of 2nd row\n     * @param initialM24 defines 4th value of 2nd row\n     * @param initialM31 defines 1st value of 3rd row\n     * @param initialM32 defines 2nd value of 3rd row\n     * @param initialM33 defines 3rd value of 3rd row\n     * @param initialM34 defines 4th value of 3rd row\n     * @param initialM41 defines 1st value of 4th row\n     * @param initialM42 defines 2nd value of 4th row\n     * @param initialM43 defines 3rd value of 4th row\n     * @param initialM44 defines 4th value of 4th row\n     * @returns the new matrix\n     */\n    static FromValues(initialM11, initialM12, initialM13, initialM14, initialM21, initialM22, initialM23, initialM24, initialM31, initialM32, initialM33, initialM34, initialM41, initialM42, initialM43, initialM44) {\n        const result = new Matrix();\n        const m = result._m;\n        m[0] = initialM11;\n        m[1] = initialM12;\n        m[2] = initialM13;\n        m[3] = initialM14;\n        m[4] = initialM21;\n        m[5] = initialM22;\n        m[6] = initialM23;\n        m[7] = initialM24;\n        m[8] = initialM31;\n        m[9] = initialM32;\n        m[10] = initialM33;\n        m[11] = initialM34;\n        m[12] = initialM41;\n        m[13] = initialM42;\n        m[14] = initialM43;\n        m[15] = initialM44;\n        result.markAsUpdated();\n        return result;\n    }\n    /**\n     * Creates a new matrix composed by merging scale (vector3), rotation (quaternion) and translation (vector3)\n     * Example Playground - https://playground.babylonjs.com/#AV9X17#24\n     * @param scale defines the scale vector3\n     * @param rotation defines the rotation quaternion\n     * @param translation defines the translation vector3\n     * @returns a new matrix\n     */\n    static Compose(scale, rotation, translation) {\n        const result = new Matrix();\n        Matrix.ComposeToRef(scale, rotation, translation, result);\n        return result;\n    }\n    /**\n     * Sets a matrix to a value composed by merging scale (vector3), rotation (quaternion) and translation (vector3)\n     * Example Playground - https://playground.babylonjs.com/#AV9X17#25\n     * @param scale defines the scale vector3\n     * @param rotation defines the rotation quaternion\n     * @param translation defines the translation vector3\n     * @param result defines the target matrix\n     * @returns result input\n     */\n    static ComposeToRef(scale, rotation, translation, result) {\n        const m = result._m;\n        const x = rotation._x, y = rotation._y, z = rotation._z, w = rotation._w;\n        const x2 = x + x, y2 = y + y, z2 = z + z;\n        const xx = x * x2, xy = x * y2, xz = x * z2;\n        const yy = y * y2, yz = y * z2, zz = z * z2;\n        const wx = w * x2, wy = w * y2, wz = w * z2;\n        const sx = scale._x, sy = scale._y, sz = scale._z;\n        m[0] = (1 - (yy + zz)) * sx;\n        m[1] = (xy + wz) * sx;\n        m[2] = (xz - wy) * sx;\n        m[3] = 0;\n        m[4] = (xy - wz) * sy;\n        m[5] = (1 - (xx + zz)) * sy;\n        m[6] = (yz + wx) * sy;\n        m[7] = 0;\n        m[8] = (xz + wy) * sz;\n        m[9] = (yz - wx) * sz;\n        m[10] = (1 - (xx + yy)) * sz;\n        m[11] = 0;\n        m[12] = translation._x;\n        m[13] = translation._y;\n        m[14] = translation._z;\n        m[15] = 1;\n        result.markAsUpdated();\n        return result;\n    }\n    /**\n     * Creates a new identity matrix\n     * @returns a new identity matrix\n     */\n    static Identity() {\n        const identity = Matrix.FromValues(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0);\n        identity._updateIdentityStatus(true);\n        return identity;\n    }\n    /**\n     * Creates a new identity matrix and stores the result in a given matrix\n     * @param result defines the target matrix\n     * @returns result input\n     */\n    static IdentityToRef(result) {\n        Matrix.FromValuesToRef(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, result);\n        result._updateIdentityStatus(true);\n        return result;\n    }\n    /**\n     * Creates a new zero matrix\n     * @returns a new zero matrix\n     */\n    static Zero() {\n        const zero = Matrix.FromValues(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);\n        zero._updateIdentityStatus(false);\n        return zero;\n    }\n    /**\n     * Creates a new rotation matrix for \"angle\" radians around the X axis\n     * Example Playground - https://playground.babylonjs.com/#AV9X17#97\n     * @param angle defines the angle (in radians) to use\n     * @returns the new matrix\n     */\n    static RotationX(angle) {\n        const result = new Matrix();\n        Matrix.RotationXToRef(angle, result);\n        return result;\n    }\n    /**\n     * Creates a new matrix as the invert of a given matrix\n     * Example Playground - https://playground.babylonjs.com/#AV9X17#124\n     * @param source defines the source matrix\n     * @returns the new matrix\n     */\n    static Invert(source) {\n        const result = new source.constructor();\n        source.invertToRef(result);\n        return result;\n    }\n    /**\n     * Creates a new rotation matrix for \"angle\" radians around the X axis and stores it in a given matrix\n     * Example Playground - https://playground.babylonjs.com/#AV9X17#98\n     * @param angle defines the angle (in radians) to use\n     * @param result defines the target matrix\n     * @returns result input\n     */\n    static RotationXToRef(angle, result) {\n        const s = Math.sin(angle);\n        const c = Math.cos(angle);\n        Matrix.FromValuesToRef(1.0, 0.0, 0.0, 0.0, 0.0, c, s, 0.0, 0.0, -s, c, 0.0, 0.0, 0.0, 0.0, 1.0, result);\n        result._updateIdentityStatus(c === 1 && s === 0);\n        return result;\n    }\n    /**\n     * Creates a new rotation matrix for \"angle\" radians around the Y axis\n     * Example Playground - https://playground.babylonjs.com/#AV9X17#99\n     * @param angle defines the angle (in radians) to use\n     * @returns the new matrix\n     */\n    static RotationY(angle) {\n        const result = new Matrix();\n        Matrix.RotationYToRef(angle, result);\n        return result;\n    }\n    /**\n     * Creates a new rotation matrix for \"angle\" radians around the Y axis and stores it in a given matrix\n     * Example Playground - https://playground.babylonjs.com/#AV9X17#100\n     * @param angle defines the angle (in radians) to use\n     * @param result defines the target matrix\n     * @returns result input\n     */\n    static RotationYToRef(angle, result) {\n        const s = Math.sin(angle);\n        const c = Math.cos(angle);\n        Matrix.FromValuesToRef(c, 0.0, -s, 0.0, 0.0, 1.0, 0.0, 0.0, s, 0.0, c, 0.0, 0.0, 0.0, 0.0, 1.0, result);\n        result._updateIdentityStatus(c === 1 && s === 0);\n        return result;\n    }\n    /**\n     * Creates a new rotation matrix for \"angle\" radians around the Z axis\n     * Example Playground - https://playground.babylonjs.com/#AV9X17#101\n     * @param angle defines the angle (in radians) to use\n     * @returns the new matrix\n     */\n    static RotationZ(angle) {\n        const result = new Matrix();\n        Matrix.RotationZToRef(angle, result);\n        return result;\n    }\n    /**\n     * Creates a new rotation matrix for \"angle\" radians around the Z axis and stores it in a given matrix\n     * Example Playground - https://playground.babylonjs.com/#AV9X17#102\n     * @param angle defines the angle (in radians) to use\n     * @param result defines the target matrix\n     * @returns result input\n     */\n    static RotationZToRef(angle, result) {\n        const s = Math.sin(angle);\n        const c = Math.cos(angle);\n        Matrix.FromValuesToRef(c, s, 0.0, 0.0, -s, c, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, result);\n        result._updateIdentityStatus(c === 1 && s === 0);\n        return result;\n    }\n    /**\n     * Creates a new rotation matrix for \"angle\" radians around the given axis\n     * Example Playground - https://playground.babylonjs.com/#AV9X17#96\n     * @param axis defines the axis to use\n     * @param angle defines the angle (in radians) to use\n     * @returns the new matrix\n     */\n    static RotationAxis(axis, angle) {\n        const result = new Matrix();\n        Matrix.RotationAxisToRef(axis, angle, result);\n        return result;\n    }\n    /**\n     * Creates a new rotation matrix for \"angle\" radians around the given axis and stores it in a given matrix\n     * Example Playground - https://playground.babylonjs.com/#AV9X17#94\n     * @param axis defines the axis to use\n     * @param angle defines the angle (in radians) to use\n     * @param result defines the target matrix\n     * @returns result input\n     */\n    static RotationAxisToRef(axis, angle, result) {\n        const s = Math.sin(-angle);\n        const c = Math.cos(-angle);\n        const c1 = 1 - c;\n        axis.normalize();\n        const m = result._m;\n        m[0] = axis._x * axis._x * c1 + c;\n        m[1] = axis._x * axis._y * c1 - axis._z * s;\n        m[2] = axis._x * axis._z * c1 + axis._y * s;\n        m[3] = 0.0;\n        m[4] = axis._y * axis._x * c1 + axis._z * s;\n        m[5] = axis._y * axis._y * c1 + c;\n        m[6] = axis._y * axis._z * c1 - axis._x * s;\n        m[7] = 0.0;\n        m[8] = axis._z * axis._x * c1 - axis._y * s;\n        m[9] = axis._z * axis._y * c1 + axis._x * s;\n        m[10] = axis._z * axis._z * c1 + c;\n        m[11] = 0.0;\n        m[12] = 0.0;\n        m[13] = 0.0;\n        m[14] = 0.0;\n        m[15] = 1.0;\n        result.markAsUpdated();\n        return result;\n    }\n    /**\n     * Takes normalised vectors and returns a rotation matrix to align \"from\" with \"to\".\n     * Taken from http://www.iquilezles.org/www/articles/noacos/noacos.htm\n     * Example Playground - https://playground.babylonjs.com/#AV9X17#93\n     * @param from defines the vector to align\n     * @param to defines the vector to align to\n     * @param result defines the target matrix\n     * @returns result input\n     */\n    static RotationAlignToRef(from, to, result) {\n        const c = Vector3.Dot(to, from);\n        const m = result._m;\n        if (c < -1 + Epsilon) {\n            // from and to are colinear and opposite direction.\n            // compute a PI rotation on Z axis\n            m[0] = -1;\n            m[1] = 0;\n            m[2] = 0;\n            m[3] = 0;\n            m[4] = 0;\n            m[5] = -1;\n            m[6] = 0;\n            m[7] = 0;\n            m[8] = 0;\n            m[9] = 0;\n            m[10] = 1;\n            m[11] = 0;\n        }\n        else {\n            const v = Vector3.Cross(to, from);\n            const k = 1 / (1 + c);\n            m[0] = v._x * v._x * k + c;\n            m[1] = v._y * v._x * k - v._z;\n            m[2] = v._z * v._x * k + v._y;\n            m[3] = 0;\n            m[4] = v._x * v._y * k + v._z;\n            m[5] = v._y * v._y * k + c;\n            m[6] = v._z * v._y * k - v._x;\n            m[7] = 0;\n            m[8] = v._x * v._z * k - v._y;\n            m[9] = v._y * v._z * k + v._x;\n            m[10] = v._z * v._z * k + c;\n            m[11] = 0;\n        }\n        m[12] = 0;\n        m[13] = 0;\n        m[14] = 0;\n        m[15] = 1;\n        result.markAsUpdated();\n        return result;\n    }\n    /**\n     * Creates a rotation matrix\n     * Example Playground - https://playground.babylonjs.com/#AV9X17#103\n     * Example Playground - https://playground.babylonjs.com/#AV9X17#105\n     * @param yaw defines the yaw angle in radians (Y axis)\n     * @param pitch defines the pitch angle in radians (X axis)\n     * @param roll defines the roll angle in radians (Z axis)\n     * @returns the new rotation matrix\n     */\n    static RotationYawPitchRoll(yaw, pitch, roll) {\n        const result = new Matrix();\n        Matrix.RotationYawPitchRollToRef(yaw, pitch, roll, result);\n        return result;\n    }\n    /**\n     * Creates a rotation matrix and stores it in a given matrix\n     * Example Playground - https://playground.babylonjs.com/#AV9X17#104\n     * @param yaw defines the yaw angle in radians (Y axis)\n     * @param pitch defines the pitch angle in radians (X axis)\n     * @param roll defines the roll angle in radians (Z axis)\n     * @param result defines the target matrix\n     * @returns result input\n     */\n    static RotationYawPitchRollToRef(yaw, pitch, roll, result) {\n        Quaternion.RotationYawPitchRollToRef(yaw, pitch, roll, MathTmp.Quaternion[0]);\n        MathTmp.Quaternion[0].toRotationMatrix(result);\n        return result;\n    }\n    /**\n     * Creates a scaling matrix\n     * Example Playground - https://playground.babylonjs.com/#AV9X17#107\n     * @param x defines the scale factor on X axis\n     * @param y defines the scale factor on Y axis\n     * @param z defines the scale factor on Z axis\n     * @returns the new matrix\n     */\n    static Scaling(x, y, z) {\n        const result = new Matrix();\n        Matrix.ScalingToRef(x, y, z, result);\n        return result;\n    }\n    /**\n     * Creates a scaling matrix and stores it in a given matrix\n     * Example Playground - https://playground.babylonjs.com/#AV9X17#108\n     * @param x defines the scale factor on X axis\n     * @param y defines the scale factor on Y axis\n     * @param z defines the scale factor on Z axis\n     * @param result defines the target matrix\n     * @returns result input\n     */\n    static ScalingToRef(x, y, z, result) {\n        Matrix.FromValuesToRef(x, 0.0, 0.0, 0.0, 0.0, y, 0.0, 0.0, 0.0, 0.0, z, 0.0, 0.0, 0.0, 0.0, 1.0, result);\n        result._updateIdentityStatus(x === 1 && y === 1 && z === 1);\n        return result;\n    }\n    /**\n     * Creates a translation matrix\n     * Example Playground - https://playground.babylonjs.com/#AV9X17#109\n     * @param x defines the translation on X axis\n     * @param y defines the translation on Y axis\n     * @param z defines the translationon Z axis\n     * @returns the new matrix\n     */\n    static Translation(x, y, z) {\n        const result = new Matrix();\n        Matrix.TranslationToRef(x, y, z, result);\n        return result;\n    }\n    /**\n     * Creates a translation matrix and stores it in a given matrix\n     * Example Playground - https://playground.babylonjs.com/#AV9X17#110\n     * @param x defines the translation on X axis\n     * @param y defines the translation on Y axis\n     * @param z defines the translationon Z axis\n     * @param result defines the target matrix\n     * @returns result input\n     */\n    static TranslationToRef(x, y, z, result) {\n        Matrix.FromValuesToRef(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, x, y, z, 1.0, result);\n        result._updateIdentityStatus(x === 0 && y === 0 && z === 0);\n        return result;\n    }\n    /**\n     * Returns a new Matrix whose values are the interpolated values for \"gradient\" (float) between the ones of the matrices \"startValue\" and \"endValue\".\n     * Example Playground - https://playground.babylonjs.com/#AV9X17#55\n     * @param startValue defines the start value\n     * @param endValue defines the end value\n     * @param gradient defines the gradient factor\n     * @returns the new matrix\n     */\n    static Lerp(startValue, endValue, gradient) {\n        const result = new startValue.constructor();\n        Matrix.LerpToRef(startValue, endValue, gradient, result);\n        return result;\n    }\n    /**\n     * Set the given matrix \"result\" as the interpolated values for \"gradient\" (float) between the ones of the matrices \"startValue\" and \"endValue\".\n     * Example Playground - https://playground.babylonjs.com/#AV9X17#54\n     * @param startValue defines the start value\n     * @param endValue defines the end value\n     * @param gradient defines the gradient factor\n     * @param result defines the Matrix object where to store data\n     * @returns result input\n     */\n    static LerpToRef(startValue, endValue, gradient, result) {\n        const resultM = result._m;\n        const startM = startValue.m;\n        const endM = endValue.m;\n        for (let index = 0; index < 16; index++) {\n            resultM[index] = startM[index] * (1.0 - gradient) + endM[index] * gradient;\n        }\n        result.markAsUpdated();\n        return result;\n    }\n    /**\n     * Builds a new matrix whose values are computed by:\n     * * decomposing the the \"startValue\" and \"endValue\" matrices into their respective scale, rotation and translation matrices\n     * * interpolating for \"gradient\" (float) the values between each of these decomposed matrices between the start and the end\n     * * recomposing a new matrix from these 3 interpolated scale, rotation and translation matrices\n     * Example Playground - https://playground.babylonjs.com/#AV9X17#22\n     * Example Playground - https://playground.babylonjs.com/#AV9X17#51\n     * @param startValue defines the first matrix\n     * @param endValue defines the second matrix\n     * @param gradient defines the gradient between the two matrices\n     * @returns the new matrix\n     */\n    static DecomposeLerp(startValue, endValue, gradient) {\n        const result = new startValue.constructor();\n        Matrix.DecomposeLerpToRef(startValue, endValue, gradient, result);\n        return result;\n    }\n    /**\n     * Update a matrix to values which are computed by:\n     * * decomposing the the \"startValue\" and \"endValue\" matrices into their respective scale, rotation and translation matrices\n     * * interpolating for \"gradient\" (float) the values between each of these decomposed matrices between the start and the end\n     * * recomposing a new matrix from these 3 interpolated scale, rotation and translation matrices\n     * Example Playground - https://playground.babylonjs.com/#AV9X17#23\n     * Example Playground - https://playground.babylonjs.com/#AV9X17#53\n     * @param startValue defines the first matrix\n     * @param endValue defines the second matrix\n     * @param gradient defines the gradient between the two matrices\n     * @param result defines the target matrix\n     * @returns result input\n     */\n    static DecomposeLerpToRef(startValue, endValue, gradient, result) {\n        const startScale = MathTmp.Vector3[0];\n        const startRotation = MathTmp.Quaternion[0];\n        const startTranslation = MathTmp.Vector3[1];\n        startValue.decompose(startScale, startRotation, startTranslation);\n        const endScale = MathTmp.Vector3[2];\n        const endRotation = MathTmp.Quaternion[1];\n        const endTranslation = MathTmp.Vector3[3];\n        endValue.decompose(endScale, endRotation, endTranslation);\n        const resultScale = MathTmp.Vector3[4];\n        Vector3.LerpToRef(startScale, endScale, gradient, resultScale);\n        const resultRotation = MathTmp.Quaternion[2];\n        Quaternion.SlerpToRef(startRotation, endRotation, gradient, resultRotation);\n        const resultTranslation = MathTmp.Vector3[5];\n        Vector3.LerpToRef(startTranslation, endTranslation, gradient, resultTranslation);\n        Matrix.ComposeToRef(resultScale, resultRotation, resultTranslation, result);\n        return result;\n    }\n    /**\n     * Creates a new matrix that transforms vertices from world space to camera space. It takes three vectors as arguments that together describe the position and orientation of the camera.\n     * This function generates a matrix suitable for a left handed coordinate system\n     * Example Playground - https://playground.babylonjs.com/#AV9X17#58\n     * Example Playground - https://playground.babylonjs.com/#AV9X17#59\n     * @param eye defines the final position of the entity\n     * @param target defines where the entity should look at\n     * @param up defines the up vector for the entity\n     * @returns the new matrix\n     */\n    static LookAtLH(eye, target, up) {\n        const result = new Matrix();\n        Matrix.LookAtLHToRef(eye, target, up, result);\n        return result;\n    }\n    /**\n     * Sets the given \"result\" Matrix to a matrix that transforms vertices from world space to camera space. It takes three vectors as arguments that together describe the position and orientation of the camera.\n     * This function generates a matrix suitable for a left handed coordinate system\n     * Example Playground - https://playground.babylonjs.com/#AV9X17#60\n     * Example Playground - https://playground.babylonjs.com/#AV9X17#61\n     * @param eye defines the final position of the entity\n     * @param target defines where the entity should look at\n     * @param up defines the up vector for the entity\n     * @param result defines the target matrix\n     * @returns result input\n     */\n    static LookAtLHToRef(eye, target, up, result) {\n        const xAxis = MathTmp.Vector3[0];\n        const yAxis = MathTmp.Vector3[1];\n        const zAxis = MathTmp.Vector3[2];\n        // Z axis\n        target.subtractToRef(eye, zAxis);\n        zAxis.normalize();\n        // X axis\n        Vector3.CrossToRef(up, zAxis, xAxis);\n        const xSquareLength = xAxis.lengthSquared();\n        if (xSquareLength === 0) {\n            xAxis.x = 1.0;\n        }\n        else {\n            xAxis.normalizeFromLength(Math.sqrt(xSquareLength));\n        }\n        // Y axis\n        Vector3.CrossToRef(zAxis, xAxis, yAxis);\n        yAxis.normalize();\n        // Eye angles\n        const ex = -Vector3.Dot(xAxis, eye);\n        const ey = -Vector3.Dot(yAxis, eye);\n        const ez = -Vector3.Dot(zAxis, eye);\n        Matrix.FromValuesToRef(xAxis._x, yAxis._x, zAxis._x, 0.0, xAxis._y, yAxis._y, zAxis._y, 0.0, xAxis._z, yAxis._z, zAxis._z, 0.0, ex, ey, ez, 1.0, result);\n    }\n    /**\n     * Creates a new matrix that transforms vertices from world space to camera space. It takes three vectors as arguments that together describe the position and orientation of the camera.\n     * This function generates a matrix suitable for a right handed coordinate system\n     * Example Playground - https://playground.babylonjs.com/#AV9X17#62\n     * Example Playground - https://playground.babylonjs.com/#AV9X17#63\n     * @param eye defines the final position of the entity\n     * @param target defines where the entity should look at\n     * @param up defines the up vector for the entity\n     * @returns the new matrix\n     */\n    static LookAtRH(eye, target, up) {\n        const result = new Matrix();\n        Matrix.LookAtRHToRef(eye, target, up, result);\n        return result;\n    }\n    /**\n     * Sets the given \"result\" Matrix to a matrix that transforms vertices from world space to camera space. It takes three vectors as arguments that together describe the position and orientation of the camera.\n     * This function generates a matrix suitable for a right handed coordinate system\n     * Example Playground - https://playground.babylonjs.com/#AV9X17#64\n     * Example Playground - https://playground.babylonjs.com/#AV9X17#65\n     * @param eye defines the final position of the entity\n     * @param target defines where the entity should look at\n     * @param up defines the up vector for the entity\n     * @param result defines the target matrix\n     * @returns result input\n     */\n    static LookAtRHToRef(eye, target, up, result) {\n        const xAxis = MathTmp.Vector3[0];\n        const yAxis = MathTmp.Vector3[1];\n        const zAxis = MathTmp.Vector3[2];\n        // Z axis\n        eye.subtractToRef(target, zAxis);\n        zAxis.normalize();\n        // X axis\n        Vector3.CrossToRef(up, zAxis, xAxis);\n        const xSquareLength = xAxis.lengthSquared();\n        if (xSquareLength === 0) {\n            xAxis.x = 1.0;\n        }\n        else {\n            xAxis.normalizeFromLength(Math.sqrt(xSquareLength));\n        }\n        // Y axis\n        Vector3.CrossToRef(zAxis, xAxis, yAxis);\n        yAxis.normalize();\n        // Eye angles\n        const ex = -Vector3.Dot(xAxis, eye);\n        const ey = -Vector3.Dot(yAxis, eye);\n        const ez = -Vector3.Dot(zAxis, eye);\n        Matrix.FromValuesToRef(xAxis._x, yAxis._x, zAxis._x, 0.0, xAxis._y, yAxis._y, zAxis._y, 0.0, xAxis._z, yAxis._z, zAxis._z, 0.0, ex, ey, ez, 1.0, result);\n        return result;\n    }\n    /**\n     * Creates a new matrix that transforms vertices from world space to camera space. It takes two vectors as arguments that together describe the orientation of the camera. The position is assumed to be at the origin (0,0,0)\n     * This function generates a matrix suitable for a left handed coordinate system\n     * Example Playground - https://playground.babylonjs.com/#AV9X17#66\n     * @param forward defines the forward direction - Must be normalized and orthogonal to up.\n     * @param up defines the up vector for the entity - Must be normalized and orthogonal to forward.\n     * @returns the new matrix\n     */\n    static LookDirectionLH(forward, up) {\n        const result = new Matrix();\n        Matrix.LookDirectionLHToRef(forward, up, result);\n        return result;\n    }\n    /**\n     * Sets the given \"result\" Matrix to a matrix that transforms vertices from world space to camera space. It takes two vectors as arguments that together describe the orientation of the camera. The position is assumed to be at the origin (0,0,0)\n     * This function generates a matrix suitable for a left handed coordinate system\n     * Example Playground - https://playground.babylonjs.com/#AV9X17#67\n     * @param forward defines the forward direction - Must be normalized and orthogonal to up.\n     * @param up defines the up vector for the entity - Must be normalized and orthogonal to forward.\n     * @param result defines the target matrix\n     * @returns result input\n     */\n    static LookDirectionLHToRef(forward, up, result) {\n        const back = MathTmp.Vector3[0];\n        back.copyFrom(forward);\n        back.scaleInPlace(-1);\n        const left = MathTmp.Vector3[1];\n        Vector3.CrossToRef(up, back, left);\n        // Generate the rotation matrix.\n        Matrix.FromValuesToRef(left._x, left._y, left._z, 0.0, up._x, up._y, up._z, 0.0, back._x, back._y, back._z, 0.0, 0, 0, 0, 1.0, result);\n        return result;\n    }\n    /**\n     * Creates a new matrix that transforms vertices from world space to camera space. It takes two vectors as arguments that together describe the orientation of the camera. The position is assumed to be at the origin (0,0,0)\n     * This function generates a matrix suitable for a right handed coordinate system\n     * Example Playground - https://playground.babylonjs.com/#AV9X17#68\n     * @param forward defines the forward direction - Must be normalized and orthogonal to up.\n     * @param up defines the up vector for the entity - Must be normalized and orthogonal to forward.\n     * @returns the new matrix\n     */\n    static LookDirectionRH(forward, up) {\n        const result = new Matrix();\n        Matrix.LookDirectionRHToRef(forward, up, result);\n        return result;\n    }\n    /**\n     * Sets the given \"result\" Matrix to a matrix that transforms vertices from world space to camera space. It takes two vectors as arguments that together describe the orientation of the camera. The position is assumed to be at the origin (0,0,0)\n     * This function generates a matrix suitable for a right handed coordinate system\n     * Example Playground - https://playground.babylonjs.com/#AV9X17#69\n     * @param forward defines the forward direction - Must be normalized and orthogonal to up.\n     * @param up defines the up vector for the entity - Must be normalized and orthogonal to forward.\n     * @param result defines the target matrix\n     * @returns result input\n     */\n    static LookDirectionRHToRef(forward, up, result) {\n        const right = MathTmp.Vector3[2];\n        Vector3.CrossToRef(up, forward, right);\n        // Generate the rotation matrix.\n        Matrix.FromValuesToRef(right._x, right._y, right._z, 0.0, up._x, up._y, up._z, 0.0, forward._x, forward._y, forward._z, 0.0, 0, 0, 0, 1.0, result);\n        return result;\n    }\n    /**\n     * Create a left-handed orthographic projection matrix\n     * Example Playground - https://playground.babylonjs.com/#AV9X17#70\n     * @param width defines the viewport width\n     * @param height defines the viewport height\n     * @param znear defines the near clip plane\n     * @param zfar defines the far clip plane\n     * @param halfZRange true to generate NDC coordinates between 0 and 1 instead of -1 and 1 (default: false)\n     * @returns a new matrix as a left-handed orthographic projection matrix\n     */\n    static OrthoLH(width, height, znear, zfar, halfZRange) {\n        const matrix = new Matrix();\n        Matrix.OrthoLHToRef(width, height, znear, zfar, matrix, halfZRange);\n        return matrix;\n    }\n    /**\n     * Store a left-handed orthographic projection to a given matrix\n     * Example Playground - https://playground.babylonjs.com/#AV9X17#71\n     * @param width defines the viewport width\n     * @param height defines the viewport height\n     * @param znear defines the near clip plane\n     * @param zfar defines the far clip plane\n     * @param result defines the target matrix\n     * @param halfZRange true to generate NDC coordinates between 0 and 1 instead of -1 and 1 (default: false)\n     * @returns result input\n     */\n    static OrthoLHToRef(width, height, znear, zfar, result, halfZRange) {\n        const n = znear;\n        const f = zfar;\n        const a = 2.0 / width;\n        const b = 2.0 / height;\n        const c = 2.0 / (f - n);\n        const d = -(f + n) / (f - n);\n        Matrix.FromValuesToRef(a, 0.0, 0.0, 0.0, 0.0, b, 0.0, 0.0, 0.0, 0.0, c, 0.0, 0.0, 0.0, d, 1.0, result);\n        if (halfZRange) {\n            result.multiplyToRef(mtxConvertNDCToHalfZRange, result);\n        }\n        result._updateIdentityStatus(a === 1 && b === 1 && c === 1 && d === 0);\n        return result;\n    }\n    /**\n     * Create a left-handed orthographic projection matrix\n     * Example Playground - https://playground.babylonjs.com/#AV9X17#72\n     * @param left defines the viewport left coordinate\n     * @param right defines the viewport right coordinate\n     * @param bottom defines the viewport bottom coordinate\n     * @param top defines the viewport top coordinate\n     * @param znear defines the near clip plane\n     * @param zfar defines the far clip plane\n     * @param halfZRange true to generate NDC coordinates between 0 and 1 instead of -1 and 1 (default: false)\n     * @returns a new matrix as a left-handed orthographic projection matrix\n     */\n    static OrthoOffCenterLH(left, right, bottom, top, znear, zfar, halfZRange) {\n        const matrix = new Matrix();\n        Matrix.OrthoOffCenterLHToRef(left, right, bottom, top, znear, zfar, matrix, halfZRange);\n        return matrix;\n    }\n    /**\n     * Stores a left-handed orthographic projection into a given matrix\n     * Example Playground - https://playground.babylonjs.com/#AV9X17#73\n     * @param left defines the viewport left coordinate\n     * @param right defines the viewport right coordinate\n     * @param bottom defines the viewport bottom coordinate\n     * @param top defines the viewport top coordinate\n     * @param znear defines the near clip plane\n     * @param zfar defines the far clip plane\n     * @param result defines the target matrix\n     * @param halfZRange true to generate NDC coordinates between 0 and 1 instead of -1 and 1 (default: false)\n     * @returns result input\n     */\n    static OrthoOffCenterLHToRef(left, right, bottom, top, znear, zfar, result, halfZRange) {\n        const n = znear;\n        const f = zfar;\n        const a = 2.0 / (right - left);\n        const b = 2.0 / (top - bottom);\n        const c = 2.0 / (f - n);\n        const d = -(f + n) / (f - n);\n        const i0 = (left + right) / (left - right);\n        const i1 = (top + bottom) / (bottom - top);\n        Matrix.FromValuesToRef(a, 0.0, 0.0, 0.0, 0.0, b, 0.0, 0.0, 0.0, 0.0, c, 0.0, i0, i1, d, 1.0, result);\n        if (halfZRange) {\n            result.multiplyToRef(mtxConvertNDCToHalfZRange, result);\n        }\n        result.markAsUpdated();\n        return result;\n    }\n    /**\n     * Creates a right-handed orthographic projection matrix\n     * Example Playground - https://playground.babylonjs.com/#AV9X17#76\n     * @param left defines the viewport left coordinate\n     * @param right defines the viewport right coordinate\n     * @param bottom defines the viewport bottom coordinate\n     * @param top defines the viewport top coordinate\n     * @param znear defines the near clip plane\n     * @param zfar defines the far clip plane\n     * @param halfZRange true to generate NDC coordinates between 0 and 1 instead of -1 and 1 (default: false)\n     * @returns a new matrix as a right-handed orthographic projection matrix\n     */\n    static OrthoOffCenterRH(left, right, bottom, top, znear, zfar, halfZRange) {\n        const matrix = new Matrix();\n        Matrix.OrthoOffCenterRHToRef(left, right, bottom, top, znear, zfar, matrix, halfZRange);\n        return matrix;\n    }\n    /**\n     * Stores a right-handed orthographic projection into a given matrix\n     * Example Playground - https://playground.babylonjs.com/#AV9X17#77\n     * @param left defines the viewport left coordinate\n     * @param right defines the viewport right coordinate\n     * @param bottom defines the viewport bottom coordinate\n     * @param top defines the viewport top coordinate\n     * @param znear defines the near clip plane\n     * @param zfar defines the far clip plane\n     * @param result defines the target matrix\n     * @param halfZRange true to generate NDC coordinates between 0 and 1 instead of -1 and 1 (default: false)\n     * @returns result input\n     */\n    static OrthoOffCenterRHToRef(left, right, bottom, top, znear, zfar, result, halfZRange) {\n        Matrix.OrthoOffCenterLHToRef(left, right, bottom, top, znear, zfar, result, halfZRange);\n        result._m[10] *= -1; // No need to call markAsUpdated as previous function already called it and let _isIdentityDirty to true\n        return result;\n    }\n    /**\n     * Creates a left-handed perspective projection matrix\n     * Example Playground - https://playground.babylonjs.com/#AV9X17#85\n     * @param width defines the viewport width\n     * @param height defines the viewport height\n     * @param znear defines the near clip plane\n     * @param zfar defines the far clip plane\n     * @param halfZRange true to generate NDC coordinates between 0 and 1 instead of -1 and 1 (default: false)\n     * @param projectionPlaneTilt optional tilt angle of the projection plane around the X axis (horizontal)\n     * @returns a new matrix as a left-handed perspective projection matrix\n     */\n    static PerspectiveLH(width, height, znear, zfar, halfZRange, projectionPlaneTilt = 0) {\n        const matrix = new Matrix();\n        const n = znear;\n        const f = zfar;\n        const a = (2.0 * n) / width;\n        const b = (2.0 * n) / height;\n        const c = (f + n) / (f - n);\n        const d = (-2.0 * f * n) / (f - n);\n        const rot = Math.tan(projectionPlaneTilt);\n        Matrix.FromValuesToRef(a, 0.0, 0.0, 0.0, 0.0, b, 0.0, rot, 0.0, 0.0, c, 1.0, 0.0, 0.0, d, 0.0, matrix);\n        if (halfZRange) {\n            matrix.multiplyToRef(mtxConvertNDCToHalfZRange, matrix);\n        }\n        matrix._updateIdentityStatus(false);\n        return matrix;\n    }\n    /**\n     * Creates a left-handed perspective projection matrix\n     * Example Playground - https://playground.babylonjs.com/#AV9X17#78\n     * @param fov defines the horizontal field of view\n     * @param aspect defines the aspect ratio\n     * @param znear defines the near clip plane\n     * @param zfar defines the far clip plane. If 0, assume we are in \"infinite zfar\" mode\n     * @param halfZRange true to generate NDC coordinates between 0 and 1 instead of -1 and 1 (default: false)\n     * @param projectionPlaneTilt optional tilt angle of the projection plane around the X axis (horizontal)\n     * @param reverseDepthBufferMode true to indicate that we are in a reverse depth buffer mode (meaning znear and zfar have been inverted when calling the function)\n     * @returns a new matrix as a left-handed perspective projection matrix\n     */\n    static PerspectiveFovLH(fov, aspect, znear, zfar, halfZRange, projectionPlaneTilt = 0, reverseDepthBufferMode = false) {\n        const matrix = new Matrix();\n        Matrix.PerspectiveFovLHToRef(fov, aspect, znear, zfar, matrix, true, halfZRange, projectionPlaneTilt, reverseDepthBufferMode);\n        return matrix;\n    }\n    /**\n     * Stores a left-handed perspective projection into a given matrix\n     * Example Playground - https://playground.babylonjs.com/#AV9X17#81\n     * @param fov defines the horizontal field of view\n     * @param aspect defines the aspect ratio\n     * @param znear defines the near clip plane\n     * @param zfar defines the far clip plane. If 0, assume we are in \"infinite zfar\" mode\n     * @param result defines the target matrix\n     * @param isVerticalFovFixed defines it the fov is vertically fixed (default) or horizontally\n     * @param halfZRange true to generate NDC coordinates between 0 and 1 instead of -1 and 1 (default: false)\n     * @param projectionPlaneTilt optional tilt angle of the projection plane around the X axis (horizontal)\n     * @param reverseDepthBufferMode true to indicate that we are in a reverse depth buffer mode (meaning znear and zfar have been inverted when calling the function)\n     * @returns result input\n     */\n    static PerspectiveFovLHToRef(fov, aspect, znear, zfar, result, isVerticalFovFixed = true, halfZRange, projectionPlaneTilt = 0, reverseDepthBufferMode = false) {\n        const n = znear;\n        const f = zfar;\n        const t = 1.0 / Math.tan(fov * 0.5);\n        const a = isVerticalFovFixed ? t / aspect : t;\n        const b = isVerticalFovFixed ? t : t * aspect;\n        const c = reverseDepthBufferMode && n === 0 ? -1 : f !== 0 ? (f + n) / (f - n) : 1;\n        const d = reverseDepthBufferMode && n === 0 ? 2 * f : f !== 0 ? (-2.0 * f * n) / (f - n) : -2 * n;\n        const rot = Math.tan(projectionPlaneTilt);\n        Matrix.FromValuesToRef(a, 0.0, 0.0, 0.0, 0.0, b, 0.0, rot, 0.0, 0.0, c, 1.0, 0.0, 0.0, d, 0.0, result);\n        if (halfZRange) {\n            result.multiplyToRef(mtxConvertNDCToHalfZRange, result);\n        }\n        result._updateIdentityStatus(false);\n        return result;\n    }\n    /**\n     * Stores a left-handed perspective projection into a given matrix with depth reversed\n     * Example Playground - https://playground.babylonjs.com/#AV9X17#89\n     * @param fov defines the horizontal field of view\n     * @param aspect defines the aspect ratio\n     * @param znear defines the near clip plane\n     * @param zfar not used as infinity is used as far clip\n     * @param result defines the target matrix\n     * @param isVerticalFovFixed defines it the fov is vertically fixed (default) or horizontally\n     * @param halfZRange true to generate NDC coordinates between 0 and 1 instead of -1 and 1 (default: false)\n     * @param projectionPlaneTilt optional tilt angle of the projection plane around the X axis (horizontal)\n     * @returns result input\n     */\n    static PerspectiveFovReverseLHToRef(fov, aspect, znear, zfar, result, isVerticalFovFixed = true, halfZRange, projectionPlaneTilt = 0) {\n        const t = 1.0 / Math.tan(fov * 0.5);\n        const a = isVerticalFovFixed ? t / aspect : t;\n        const b = isVerticalFovFixed ? t : t * aspect;\n        const rot = Math.tan(projectionPlaneTilt);\n        Matrix.FromValuesToRef(a, 0.0, 0.0, 0.0, 0.0, b, 0.0, rot, 0.0, 0.0, -znear, 1.0, 0.0, 0.0, 1.0, 0.0, result);\n        if (halfZRange) {\n            result.multiplyToRef(mtxConvertNDCToHalfZRange, result);\n        }\n        result._updateIdentityStatus(false);\n        return result;\n    }\n    /**\n     * Creates a right-handed perspective projection matrix\n     * Example Playground - https://playground.babylonjs.com/#AV9X17#83\n     * @param fov defines the horizontal field of view\n     * @param aspect defines the aspect ratio\n     * @param znear defines the near clip plane\n     * @param zfar defines the far clip plane. If 0, assume we are in \"infinite zfar\" mode\n     * @param halfZRange true to generate NDC coordinates between 0 and 1 instead of -1 and 1 (default: false)\n     * @param projectionPlaneTilt optional tilt angle of the projection plane around the X axis (horizontal)\n     * @param reverseDepthBufferMode true to indicate that we are in a reverse depth buffer mode (meaning znear and zfar have been inverted when calling the function)\n     * @returns a new matrix as a right-handed perspective projection matrix\n     */\n    static PerspectiveFovRH(fov, aspect, znear, zfar, halfZRange, projectionPlaneTilt = 0, reverseDepthBufferMode = false) {\n        const matrix = new Matrix();\n        Matrix.PerspectiveFovRHToRef(fov, aspect, znear, zfar, matrix, true, halfZRange, projectionPlaneTilt, reverseDepthBufferMode);\n        return matrix;\n    }\n    /**\n     * Stores a right-handed perspective projection into a given matrix\n     * Example Playground - https://playground.babylonjs.com/#AV9X17#84\n     * @param fov defines the horizontal field of view\n     * @param aspect defines the aspect ratio\n     * @param znear defines the near clip plane\n     * @param zfar defines the far clip plane. If 0, assume we are in \"infinite zfar\" mode\n     * @param result defines the target matrix\n     * @param isVerticalFovFixed defines it the fov is vertically fixed (default) or horizontally\n     * @param halfZRange true to generate NDC coordinates between 0 and 1 instead of -1 and 1 (default: false)\n     * @param projectionPlaneTilt optional tilt angle of the projection plane around the X axis (horizontal)\n     * @param reverseDepthBufferMode true to indicate that we are in a reverse depth buffer mode (meaning znear and zfar have been inverted when calling the function)\n     * @returns result input\n     */\n    static PerspectiveFovRHToRef(fov, aspect, znear, zfar, result, isVerticalFovFixed = true, halfZRange, projectionPlaneTilt = 0, reverseDepthBufferMode = false) {\n        //alternatively this could be expressed as:\n        //    m = PerspectiveFovLHToRef\n        //    m[10] *= -1.0;\n        //    m[11] *= -1.0;\n        const n = znear;\n        const f = zfar;\n        const t = 1.0 / Math.tan(fov * 0.5);\n        const a = isVerticalFovFixed ? t / aspect : t;\n        const b = isVerticalFovFixed ? t : t * aspect;\n        const c = reverseDepthBufferMode && n === 0 ? 1 : f !== 0 ? -(f + n) / (f - n) : -1;\n        const d = reverseDepthBufferMode && n === 0 ? 2 * f : f !== 0 ? (-2 * f * n) / (f - n) : -2 * n;\n        const rot = Math.tan(projectionPlaneTilt);\n        Matrix.FromValuesToRef(a, 0.0, 0.0, 0.0, 0.0, b, 0.0, rot, 0.0, 0.0, c, -1.0, 0.0, 0.0, d, 0.0, result);\n        if (halfZRange) {\n            result.multiplyToRef(mtxConvertNDCToHalfZRange, result);\n        }\n        result._updateIdentityStatus(false);\n        return result;\n    }\n    /**\n     * Stores a right-handed perspective projection into a given matrix\n     * Example Playground - https://playground.babylonjs.com/#AV9X17#90\n     * @param fov defines the horizontal field of view\n     * @param aspect defines the aspect ratio\n     * @param znear defines the near clip plane\n     * @param zfar not used as infinity is used as far clip\n     * @param result defines the target matrix\n     * @param isVerticalFovFixed defines it the fov is vertically fixed (default) or horizontally\n     * @param halfZRange true to generate NDC coordinates between 0 and 1 instead of -1 and 1 (default: false)\n     * @param projectionPlaneTilt optional tilt angle of the projection plane around the X axis (horizontal)\n     * @returns result input\n     */\n    static PerspectiveFovReverseRHToRef(fov, aspect, znear, zfar, result, isVerticalFovFixed = true, halfZRange, projectionPlaneTilt = 0) {\n        const t = 1.0 / Math.tan(fov * 0.5);\n        const a = isVerticalFovFixed ? t / aspect : t;\n        const b = isVerticalFovFixed ? t : t * aspect;\n        const rot = Math.tan(projectionPlaneTilt);\n        Matrix.FromValuesToRef(a, 0.0, 0.0, 0.0, 0.0, b, 0.0, rot, 0.0, 0.0, -znear, -1.0, 0.0, 0.0, -1.0, 0.0, result);\n        if (halfZRange) {\n            result.multiplyToRef(mtxConvertNDCToHalfZRange, result);\n        }\n        result._updateIdentityStatus(false);\n        return result;\n    }\n    /**\n     * Stores a perspective projection for WebVR info a given matrix\n     * Example Playground - https://playground.babylonjs.com/#AV9X17#92\n     * @param fov defines the field of view\n     * @param fov.upDegrees\n     * @param fov.downDegrees\n     * @param fov.leftDegrees\n     * @param fov.rightDegrees\n     * @param znear defines the near clip plane\n     * @param zfar defines the far clip plane\n     * @param result defines the target matrix\n     * @param rightHanded defines if the matrix must be in right-handed mode (false by default)\n     * @param halfZRange true to generate NDC coordinates between 0 and 1 instead of -1 and 1 (default: false)\n     * @param projectionPlaneTilt optional tilt angle of the projection plane around the X axis (horizontal)\n     * @returns result input\n     */\n    static PerspectiveFovWebVRToRef(fov, znear, zfar, result, rightHanded = false, halfZRange, projectionPlaneTilt = 0) {\n        const rightHandedFactor = rightHanded ? -1 : 1;\n        const upTan = Math.tan((fov.upDegrees * Math.PI) / 180.0);\n        const downTan = Math.tan((fov.downDegrees * Math.PI) / 180.0);\n        const leftTan = Math.tan((fov.leftDegrees * Math.PI) / 180.0);\n        const rightTan = Math.tan((fov.rightDegrees * Math.PI) / 180.0);\n        const xScale = 2.0 / (leftTan + rightTan);\n        const yScale = 2.0 / (upTan + downTan);\n        const rot = Math.tan(projectionPlaneTilt);\n        const m = result._m;\n        m[0] = xScale;\n        m[1] = m[2] = m[3] = m[4] = 0.0;\n        m[5] = yScale;\n        m[6] = 0.0;\n        m[7] = rot;\n        m[8] = (leftTan - rightTan) * xScale * 0.5;\n        m[9] = -((upTan - downTan) * yScale * 0.5);\n        m[10] = -zfar / (znear - zfar);\n        m[11] = 1.0 * rightHandedFactor;\n        m[12] = m[13] = m[15] = 0.0;\n        m[14] = -(2.0 * zfar * znear) / (zfar - znear);\n        if (halfZRange) {\n            result.multiplyToRef(mtxConvertNDCToHalfZRange, result);\n        }\n        result.markAsUpdated();\n        return result;\n    }\n    /**\n     * Computes a complete transformation matrix\n     * Example Playground - https://playground.babylonjs.com/#AV9X17#113\n     * @param viewport defines the viewport to use\n     * @param world defines the world matrix\n     * @param view defines the view matrix\n     * @param projection defines the projection matrix\n     * @param zmin defines the near clip plane\n     * @param zmax defines the far clip plane\n     * @returns the transformation matrix\n     */\n    static GetFinalMatrix(viewport, world, view, projection, zmin, zmax) {\n        const cw = viewport.width;\n        const ch = viewport.height;\n        const cx = viewport.x;\n        const cy = viewport.y;\n        const viewportMatrix = Matrix.FromValues(cw / 2.0, 0.0, 0.0, 0.0, 0.0, -ch / 2.0, 0.0, 0.0, 0.0, 0.0, zmax - zmin, 0.0, cx + cw / 2.0, ch / 2.0 + cy, zmin, 1.0);\n        const matrix = new world.constructor();\n        world.multiplyToRef(view, matrix);\n        matrix.multiplyToRef(projection, matrix);\n        return matrix.multiplyToRef(viewportMatrix, matrix);\n    }\n    /**\n     * Extracts a 2x2 matrix from a given matrix and store the result in a Float32Array\n     * @param matrix defines the matrix to use\n     * @returns a new Float32Array array with 4 elements : the 2x2 matrix extracted from the given matrix\n     */\n    static GetAsMatrix2x2(matrix) {\n        const m = matrix.m;\n        const arr = [m[0], m[1], m[4], m[5]];\n        return PerformanceConfigurator.MatrixUse64Bits ? arr : new Float32Array(arr);\n    }\n    /**\n     * Extracts a 3x3 matrix from a given matrix and store the result in a Float32Array\n     * @param matrix defines the matrix to use\n     * @returns a new Float32Array array with 9 elements : the 3x3 matrix extracted from the given matrix\n     */\n    static GetAsMatrix3x3(matrix) {\n        const m = matrix.m;\n        const arr = [m[0], m[1], m[2], m[4], m[5], m[6], m[8], m[9], m[10]];\n        return PerformanceConfigurator.MatrixUse64Bits ? arr : new Float32Array(arr);\n    }\n    /**\n     * Compute the transpose of a given matrix\n     * Example Playground - https://playground.babylonjs.com/#AV9X17#111\n     * @param matrix defines the matrix to transpose\n     * @returns the new matrix\n     */\n    static Transpose(matrix) {\n        const result = new matrix.constructor();\n        Matrix.TransposeToRef(matrix, result);\n        return result;\n    }\n    /**\n     * Compute the transpose of a matrix and store it in a target matrix\n     * Example Playground - https://playground.babylonjs.com/#AV9X17#112\n     * @param matrix defines the matrix to transpose\n     * @param result defines the target matrix\n     * @returns result input\n     */\n    static TransposeToRef(matrix, result) {\n        const rm = result._m;\n        const mm = matrix.m;\n        rm[0] = mm[0];\n        rm[1] = mm[4];\n        rm[2] = mm[8];\n        rm[3] = mm[12];\n        rm[4] = mm[1];\n        rm[5] = mm[5];\n        rm[6] = mm[9];\n        rm[7] = mm[13];\n        rm[8] = mm[2];\n        rm[9] = mm[6];\n        rm[10] = mm[10];\n        rm[11] = mm[14];\n        rm[12] = mm[3];\n        rm[13] = mm[7];\n        rm[14] = mm[11];\n        rm[15] = mm[15];\n        result.markAsUpdated();\n        // identity-ness does not change when transposing\n        result._updateIdentityStatus(matrix._isIdentity, matrix._isIdentityDirty);\n        return result;\n    }\n    /**\n     * Computes a reflection matrix from a plane\n     * Example Playground - https://playground.babylonjs.com/#AV9X17#87\n     * @param plane defines the reflection plane\n     * @returns a new matrix\n     */\n    static Reflection(plane) {\n        const matrix = new Matrix();\n        Matrix.ReflectionToRef(plane, matrix);\n        return matrix;\n    }\n    /**\n     * Computes a reflection matrix from a plane\n     * Example Playground - https://playground.babylonjs.com/#AV9X17#88\n     * @param plane defines the reflection plane\n     * @param result defines the target matrix\n     * @returns result input\n     */\n    static ReflectionToRef(plane, result) {\n        plane.normalize();\n        const x = plane.normal.x;\n        const y = plane.normal.y;\n        const z = plane.normal.z;\n        const temp = -2 * x;\n        const temp2 = -2 * y;\n        const temp3 = -2 * z;\n        Matrix.FromValuesToRef(temp * x + 1, temp2 * x, temp3 * x, 0.0, temp * y, temp2 * y + 1, temp3 * y, 0.0, temp * z, temp2 * z, temp3 * z + 1, 0.0, temp * plane.d, temp2 * plane.d, temp3 * plane.d, 1.0, result);\n        return result;\n    }\n    /**\n     * Sets the given matrix as a rotation matrix composed from the 3 left handed axes\n     * @param xaxis defines the value of the 1st axis\n     * @param yaxis defines the value of the 2nd axis\n     * @param zaxis defines the value of the 3rd axis\n     * @param result defines the target matrix\n     * @returns result input\n     */\n    static FromXYZAxesToRef(xaxis, yaxis, zaxis, result) {\n        Matrix.FromValuesToRef(xaxis._x, xaxis._y, xaxis._z, 0.0, yaxis._x, yaxis._y, yaxis._z, 0.0, zaxis._x, zaxis._y, zaxis._z, 0.0, 0.0, 0.0, 0.0, 1.0, result);\n        return result;\n    }\n    /**\n     * Creates a rotation matrix from a quaternion and stores it in a target matrix\n     * @param quat defines the quaternion to use\n     * @param result defines the target matrix\n     * @returns result input\n     */\n    static FromQuaternionToRef(quat, result) {\n        const xx = quat._x * quat._x;\n        const yy = quat._y * quat._y;\n        const zz = quat._z * quat._z;\n        const xy = quat._x * quat._y;\n        const zw = quat._z * quat._w;\n        const zx = quat._z * quat._x;\n        const yw = quat._y * quat._w;\n        const yz = quat._y * quat._z;\n        const xw = quat._x * quat._w;\n        result._m[0] = 1.0 - 2.0 * (yy + zz);\n        result._m[1] = 2.0 * (xy + zw);\n        result._m[2] = 2.0 * (zx - yw);\n        result._m[3] = 0.0;\n        result._m[4] = 2.0 * (xy - zw);\n        result._m[5] = 1.0 - 2.0 * (zz + xx);\n        result._m[6] = 2.0 * (yz + xw);\n        result._m[7] = 0.0;\n        result._m[8] = 2.0 * (zx + yw);\n        result._m[9] = 2.0 * (yz - xw);\n        result._m[10] = 1.0 - 2.0 * (yy + xx);\n        result._m[11] = 0.0;\n        result._m[12] = 0.0;\n        result._m[13] = 0.0;\n        result._m[14] = 0.0;\n        result._m[15] = 1.0;\n        result.markAsUpdated();\n        return result;\n    }\n}\nMatrix._UpdateFlagSeed = 0;\nMatrix._IdentityReadOnly = Matrix.Identity();\n/**\n * @internal\n * Same as Tmp but not exported to keep it only for math functions to avoid conflicts\n */\nclass MathTmp {\n}\nMathTmp.Vector3 = ArrayTools.BuildTuple(11, Vector3.Zero);\nMathTmp.Matrix = ArrayTools.BuildTuple(2, Matrix.Identity);\nMathTmp.Quaternion = ArrayTools.BuildTuple(3, Quaternion.Zero);\n/**\n * @internal\n */\nexport class TmpVectors {\n}\nTmpVectors.Vector2 = ArrayTools.BuildTuple(3, Vector2.Zero); // 3 temp Vector2 at once should be enough\nTmpVectors.Vector3 = ArrayTools.BuildTuple(13, Vector3.Zero); // 13 temp Vector3 at once should be enough\nTmpVectors.Vector4 = ArrayTools.BuildTuple(3, Vector4.Zero); // 3 temp Vector4 at once should be enough\nTmpVectors.Quaternion = ArrayTools.BuildTuple(2, Quaternion.Zero); // 2 temp Quaternion at once should be enough\nTmpVectors.Matrix = ArrayTools.BuildTuple(8, Matrix.Identity); // 8 temp Matrices at once should be enough\nRegisterClass(\"BABYLON.Vector2\", Vector2);\nRegisterClass(\"BABYLON.Vector3\", Vector3);\nRegisterClass(\"BABYLON.Vector4\", Vector4);\nRegisterClass(\"BABYLON.Matrix\", Matrix);\nconst mtxConvertNDCToHalfZRange = Matrix.FromValues(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0.5, 0, 0, 0, 0.5, 1);\n//# sourceMappingURL=math.vector.js.map","/**\n * Class used to represent a viewport on screen\n */\nexport class Viewport {\n    /**\n     * Creates a Viewport object located at (x, y) and sized (width, height)\n     * @param x defines viewport left coordinate\n     * @param y defines viewport top coordinate\n     * @param width defines the viewport width\n     * @param height defines the viewport height\n     */\n    constructor(\n    /** viewport left coordinate */\n    x, \n    /** viewport top coordinate */\n    y, \n    /**viewport width */\n    width, \n    /** viewport height */\n    height) {\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n    }\n    /**\n     * Creates a new viewport using absolute sizing (from 0-> width, 0-> height instead of 0->1)\n     * @param renderWidth defines the rendering width\n     * @param renderHeight defines the rendering height\n     * @returns a new Viewport\n     */\n    toGlobal(renderWidth, renderHeight) {\n        return new Viewport(this.x * renderWidth, this.y * renderHeight, this.width * renderWidth, this.height * renderHeight);\n    }\n    /**\n     * Stores absolute viewport value into a target viewport (from 0-> width, 0-> height instead of 0->1)\n     * @param renderWidth defines the rendering width\n     * @param renderHeight defines the rendering height\n     * @param ref defines the target viewport\n     * @returns the current viewport\n     */\n    toGlobalToRef(renderWidth, renderHeight, ref) {\n        ref.x = this.x * renderWidth;\n        ref.y = this.y * renderHeight;\n        ref.width = this.width * renderWidth;\n        ref.height = this.height * renderHeight;\n        return this;\n    }\n    /**\n     * Returns a new Viewport copied from the current one\n     * @returns a new Viewport\n     */\n    clone() {\n        return new Viewport(this.x, this.y, this.width, this.height);\n    }\n}\n//# sourceMappingURL=math.viewport.js.map","/* eslint-disable @typescript-eslint/naming-convention */\nimport { Vector3 } from \"../Maths/math.vector.js\";\nimport { TmpVectors } from \"./math.js\";\n// https://dickyjim.wordpress.com/2013/09/04/spherical-harmonics-for-beginners/\n// http://silviojemma.com/public/papers/lighting/spherical-harmonic-lighting.pdf\n// https://www.ppsloan.org/publications/StupidSH36.pdf\n// http://cseweb.ucsd.edu/~ravir/papers/envmap/envmap.pdf\n// https://www.ppsloan.org/publications/SHJCGT.pdf\n// https://www.ppsloan.org/publications/shdering.pdf\n// https://google.github.io/filament/Filament.md.html#annex/sphericalharmonics\n// https://patapom.com/blog/SHPortal/\n// https://imdoingitwrong.wordpress.com/2011/04/14/spherical-harmonics-wtf/\n// Using real SH basis:\n//  m>0             m   m\n// y   = sqrt(2) * K * P * cos(m*phi) * cos(theta)\n//  l               l   l\n//\n//  m<0             m   |m|\n// y   = sqrt(2) * K * P * sin(m*phi) * cos(theta)\n//  l               l   l\n//\n//  m=0   0   0\n// y   = K * P * trigono terms\n//  l     l   l\n//\n//  m       (2l + 1)(l - |m|)!\n// K = sqrt(------------------)\n//  l           4pi(l + |m|)!\n//\n// and P by recursion:\n//\n// P00(x) = 1\n// P01(x) = x\n// Pll(x) = (-1^l)(2l - 1)!!(1-x*x)^(1/2)\n//          ((2l - 1)x[Pl-1/m]-(l + m - 1)[Pl-2/m])\n// Plm(x) = ---------------------------------------\n//                         l - m\n// Leaving the trigonometric terms aside we can precompute the constants to :\nconst SH3ylmBasisConstants = [\n    Math.sqrt(1 / (4 * Math.PI)),\n    -Math.sqrt(3 / (4 * Math.PI)),\n    Math.sqrt(3 / (4 * Math.PI)),\n    -Math.sqrt(3 / (4 * Math.PI)),\n    Math.sqrt(15 / (4 * Math.PI)),\n    -Math.sqrt(15 / (4 * Math.PI)),\n    Math.sqrt(5 / (16 * Math.PI)),\n    -Math.sqrt(15 / (4 * Math.PI)),\n    Math.sqrt(15 / (16 * Math.PI)), // l22\n];\n// cm = cos(m * phi)\n// sm = sin(m * phi)\n// {x,y,z} = {cos(phi)sin(theta), sin(phi)sin(theta), cos(theta)}\n// By recursion on using trigo identities:\nconst SH3ylmBasisTrigonometricTerms = [\n    () => 1,\n    (direction) => direction.y,\n    (direction) => direction.z,\n    (direction) => direction.x,\n    (direction) => direction.x * direction.y,\n    (direction) => direction.y * direction.z,\n    (direction) => 3 * direction.z * direction.z - 1,\n    (direction) => direction.x * direction.z,\n    (direction) => direction.x * direction.x - direction.y * direction.y, // l22\n];\n// Wrap the full compute\nconst applySH3 = (lm, direction) => {\n    return SH3ylmBasisConstants[lm] * SH3ylmBasisTrigonometricTerms[lm](direction);\n};\n// Derived from the integration of the a kernel convolution to SH.\n// Great explanation here: https://patapom.com/blog/SHPortal/#about-distant-radiance-and-irradiance-environments\nconst SHCosKernelConvolution = [Math.PI, (2 * Math.PI) / 3, (2 * Math.PI) / 3, (2 * Math.PI) / 3, Math.PI / 4, Math.PI / 4, Math.PI / 4, Math.PI / 4, Math.PI / 4];\n/**\n * Class representing spherical harmonics coefficients to the 3rd degree\n */\nexport class SphericalHarmonics {\n    constructor() {\n        /**\n         * Defines whether or not the harmonics have been prescaled for rendering.\n         */\n        this.preScaled = false;\n        /**\n         * The l0,0 coefficients of the spherical harmonics\n         */\n        this.l00 = Vector3.Zero();\n        /**\n         * The l1,-1 coefficients of the spherical harmonics\n         */\n        this.l1_1 = Vector3.Zero();\n        /**\n         * The l1,0 coefficients of the spherical harmonics\n         */\n        this.l10 = Vector3.Zero();\n        /**\n         * The l1,1 coefficients of the spherical harmonics\n         */\n        this.l11 = Vector3.Zero();\n        /**\n         * The l2,-2 coefficients of the spherical harmonics\n         */\n        this.l2_2 = Vector3.Zero();\n        /**\n         * The l2,-1 coefficients of the spherical harmonics\n         */\n        this.l2_1 = Vector3.Zero();\n        /**\n         * The l2,0 coefficients of the spherical harmonics\n         */\n        this.l20 = Vector3.Zero();\n        /**\n         * The l2,1 coefficients of the spherical harmonics\n         */\n        this.l21 = Vector3.Zero();\n        /**\n         * The l2,2 coefficients of the spherical harmonics\n         */\n        this.l22 = Vector3.Zero();\n    }\n    /**\n     * Adds a light to the spherical harmonics\n     * @param direction the direction of the light\n     * @param color the color of the light\n     * @param deltaSolidAngle the delta solid angle of the light\n     */\n    addLight(direction, color, deltaSolidAngle) {\n        TmpVectors.Vector3[0].set(color.r, color.g, color.b);\n        const colorVector = TmpVectors.Vector3[0];\n        const c = TmpVectors.Vector3[1];\n        colorVector.scaleToRef(deltaSolidAngle, c);\n        c.scaleToRef(applySH3(0, direction), TmpVectors.Vector3[2]);\n        this.l00.addInPlace(TmpVectors.Vector3[2]);\n        c.scaleToRef(applySH3(1, direction), TmpVectors.Vector3[2]);\n        this.l1_1.addInPlace(TmpVectors.Vector3[2]);\n        c.scaleToRef(applySH3(2, direction), TmpVectors.Vector3[2]);\n        this.l10.addInPlace(TmpVectors.Vector3[2]);\n        c.scaleToRef(applySH3(3, direction), TmpVectors.Vector3[2]);\n        this.l11.addInPlace(TmpVectors.Vector3[2]);\n        c.scaleToRef(applySH3(4, direction), TmpVectors.Vector3[2]);\n        this.l2_2.addInPlace(TmpVectors.Vector3[2]);\n        c.scaleToRef(applySH3(5, direction), TmpVectors.Vector3[2]);\n        this.l2_1.addInPlace(TmpVectors.Vector3[2]);\n        c.scaleToRef(applySH3(6, direction), TmpVectors.Vector3[2]);\n        this.l20.addInPlace(TmpVectors.Vector3[2]);\n        c.scaleToRef(applySH3(7, direction), TmpVectors.Vector3[2]);\n        this.l21.addInPlace(TmpVectors.Vector3[2]);\n        c.scaleToRef(applySH3(8, direction), TmpVectors.Vector3[2]);\n        this.l22.addInPlace(TmpVectors.Vector3[2]);\n    }\n    /**\n     * Scales the spherical harmonics by the given amount\n     * @param scale the amount to scale\n     */\n    scaleInPlace(scale) {\n        this.l00.scaleInPlace(scale);\n        this.l1_1.scaleInPlace(scale);\n        this.l10.scaleInPlace(scale);\n        this.l11.scaleInPlace(scale);\n        this.l2_2.scaleInPlace(scale);\n        this.l2_1.scaleInPlace(scale);\n        this.l20.scaleInPlace(scale);\n        this.l21.scaleInPlace(scale);\n        this.l22.scaleInPlace(scale);\n    }\n    /**\n     * Convert from incident radiance (Li) to irradiance (E) by applying convolution with the cosine-weighted hemisphere.\n     *\n     * ```\n     * E_lm = A_l * L_lm\n     * ```\n     *\n     * In spherical harmonics this convolution amounts to scaling factors for each frequency band.\n     * This corresponds to equation 5 in \"An Efficient Representation for Irradiance Environment Maps\", where\n     * the scaling factors are given in equation 9.\n     */\n    convertIncidentRadianceToIrradiance() {\n        // Constant (Band 0)\n        this.l00.scaleInPlace(SHCosKernelConvolution[0]);\n        // Linear (Band 1)\n        this.l1_1.scaleInPlace(SHCosKernelConvolution[1]);\n        this.l10.scaleInPlace(SHCosKernelConvolution[2]);\n        this.l11.scaleInPlace(SHCosKernelConvolution[3]);\n        // Quadratic (Band 2)\n        this.l2_2.scaleInPlace(SHCosKernelConvolution[4]);\n        this.l2_1.scaleInPlace(SHCosKernelConvolution[5]);\n        this.l20.scaleInPlace(SHCosKernelConvolution[6]);\n        this.l21.scaleInPlace(SHCosKernelConvolution[7]);\n        this.l22.scaleInPlace(SHCosKernelConvolution[8]);\n    }\n    /**\n     * Convert from irradiance to outgoing radiance for Lambertian BDRF, suitable for efficient shader evaluation.\n     *\n     * ```\n     * L = (1/pi) * E * rho\n     * ```\n     *\n     * This is done by an additional scale by 1/pi, so is a fairly trivial operation but important conceptually.\n     */\n    convertIrradianceToLambertianRadiance() {\n        this.scaleInPlace(1.0 / Math.PI);\n        // The resultant SH now represents outgoing radiance, so includes the Lambert 1/pi normalisation factor but without albedo (rho) applied\n        // (The pixel shader must apply albedo after texture fetches, etc).\n    }\n    /**\n     * Integrates the reconstruction coefficients directly in to the SH preventing further\n     * required operations at run time.\n     *\n     * This is simply done by scaling back the SH with Ylm constants parameter.\n     * The trigonometric part being applied by the shader at run time.\n     */\n    preScaleForRendering() {\n        this.preScaled = true;\n        this.l00.scaleInPlace(SH3ylmBasisConstants[0]);\n        this.l1_1.scaleInPlace(SH3ylmBasisConstants[1]);\n        this.l10.scaleInPlace(SH3ylmBasisConstants[2]);\n        this.l11.scaleInPlace(SH3ylmBasisConstants[3]);\n        this.l2_2.scaleInPlace(SH3ylmBasisConstants[4]);\n        this.l2_1.scaleInPlace(SH3ylmBasisConstants[5]);\n        this.l20.scaleInPlace(SH3ylmBasisConstants[6]);\n        this.l21.scaleInPlace(SH3ylmBasisConstants[7]);\n        this.l22.scaleInPlace(SH3ylmBasisConstants[8]);\n    }\n    /**\n     * update the spherical harmonics coefficients from the given array\n     * @param data defines the 9x3 coefficients (l00, l1-1, l10, l11, l2-2, l2-1, l20, l21, l22)\n     * @returns the spherical harmonics (this)\n     */\n    updateFromArray(data) {\n        Vector3.FromArrayToRef(data[0], 0, this.l00);\n        Vector3.FromArrayToRef(data[1], 0, this.l1_1);\n        Vector3.FromArrayToRef(data[2], 0, this.l10);\n        Vector3.FromArrayToRef(data[3], 0, this.l11);\n        Vector3.FromArrayToRef(data[4], 0, this.l2_2);\n        Vector3.FromArrayToRef(data[5], 0, this.l2_1);\n        Vector3.FromArrayToRef(data[6], 0, this.l20);\n        Vector3.FromArrayToRef(data[7], 0, this.l21);\n        Vector3.FromArrayToRef(data[8], 0, this.l22);\n        return this;\n    }\n    /**\n     * update the spherical harmonics coefficients from the given floats array\n     * @param data defines the 9x3 coefficients (l00, l1-1, l10, l11, l2-2, l2-1, l20, l21, l22)\n     * @returns the spherical harmonics (this)\n     */\n    updateFromFloatsArray(data) {\n        Vector3.FromFloatsToRef(data[0], data[1], data[2], this.l00);\n        Vector3.FromFloatsToRef(data[3], data[4], data[5], this.l1_1);\n        Vector3.FromFloatsToRef(data[6], data[7], data[8], this.l10);\n        Vector3.FromFloatsToRef(data[9], data[10], data[11], this.l11);\n        Vector3.FromFloatsToRef(data[12], data[13], data[14], this.l2_2);\n        Vector3.FromFloatsToRef(data[15], data[16], data[17], this.l2_1);\n        Vector3.FromFloatsToRef(data[18], data[19], data[20], this.l20);\n        Vector3.FromFloatsToRef(data[21], data[22], data[23], this.l21);\n        Vector3.FromFloatsToRef(data[24], data[25], data[26], this.l22);\n        return this;\n    }\n    /**\n     * Constructs a spherical harmonics from an array.\n     * @param data defines the 9x3 coefficients (l00, l1-1, l10, l11, l2-2, l2-1, l20, l21, l22)\n     * @returns the spherical harmonics\n     */\n    static FromArray(data) {\n        const sh = new SphericalHarmonics();\n        return sh.updateFromArray(data);\n    }\n    // Keep for references.\n    /**\n     * Gets the spherical harmonics from polynomial\n     * @param polynomial the spherical polynomial\n     * @returns the spherical harmonics\n     */\n    static FromPolynomial(polynomial) {\n        const result = new SphericalHarmonics();\n        result.l00 = polynomial.xx.scale(0.376127).add(polynomial.yy.scale(0.376127)).add(polynomial.zz.scale(0.376126));\n        result.l1_1 = polynomial.y.scale(0.977204);\n        result.l10 = polynomial.z.scale(0.977204);\n        result.l11 = polynomial.x.scale(0.977204);\n        result.l2_2 = polynomial.xy.scale(1.16538);\n        result.l2_1 = polynomial.yz.scale(1.16538);\n        result.l20 = polynomial.zz.scale(1.34567).subtract(polynomial.xx.scale(0.672834)).subtract(polynomial.yy.scale(0.672834));\n        result.l21 = polynomial.zx.scale(1.16538);\n        result.l22 = polynomial.xx.scale(1.16538).subtract(polynomial.yy.scale(1.16538));\n        result.l1_1.scaleInPlace(-1);\n        result.l11.scaleInPlace(-1);\n        result.l2_1.scaleInPlace(-1);\n        result.l21.scaleInPlace(-1);\n        result.scaleInPlace(Math.PI);\n        return result;\n    }\n}\n/**\n * Class representing spherical polynomial coefficients to the 3rd degree\n */\nexport class SphericalPolynomial {\n    constructor() {\n        /**\n         * The x coefficients of the spherical polynomial\n         */\n        this.x = Vector3.Zero();\n        /**\n         * The y coefficients of the spherical polynomial\n         */\n        this.y = Vector3.Zero();\n        /**\n         * The z coefficients of the spherical polynomial\n         */\n        this.z = Vector3.Zero();\n        /**\n         * The xx coefficients of the spherical polynomial\n         */\n        this.xx = Vector3.Zero();\n        /**\n         * The yy coefficients of the spherical polynomial\n         */\n        this.yy = Vector3.Zero();\n        /**\n         * The zz coefficients of the spherical polynomial\n         */\n        this.zz = Vector3.Zero();\n        /**\n         * The xy coefficients of the spherical polynomial\n         */\n        this.xy = Vector3.Zero();\n        /**\n         * The yz coefficients of the spherical polynomial\n         */\n        this.yz = Vector3.Zero();\n        /**\n         * The zx coefficients of the spherical polynomial\n         */\n        this.zx = Vector3.Zero();\n    }\n    /**\n     * The spherical harmonics used to create the polynomials.\n     */\n    get preScaledHarmonics() {\n        if (!this._harmonics) {\n            this._harmonics = SphericalHarmonics.FromPolynomial(this);\n        }\n        if (!this._harmonics.preScaled) {\n            this._harmonics.preScaleForRendering();\n        }\n        return this._harmonics;\n    }\n    /**\n     * Adds an ambient color to the spherical polynomial\n     * @param color the color to add\n     */\n    addAmbient(color) {\n        TmpVectors.Vector3[0].copyFromFloats(color.r, color.g, color.b);\n        const colorVector = TmpVectors.Vector3[0];\n        this.xx.addInPlace(colorVector);\n        this.yy.addInPlace(colorVector);\n        this.zz.addInPlace(colorVector);\n    }\n    /**\n     * Scales the spherical polynomial by the given amount\n     * @param scale the amount to scale\n     */\n    scaleInPlace(scale) {\n        this.x.scaleInPlace(scale);\n        this.y.scaleInPlace(scale);\n        this.z.scaleInPlace(scale);\n        this.xx.scaleInPlace(scale);\n        this.yy.scaleInPlace(scale);\n        this.zz.scaleInPlace(scale);\n        this.yz.scaleInPlace(scale);\n        this.zx.scaleInPlace(scale);\n        this.xy.scaleInPlace(scale);\n    }\n    /**\n     * Updates the spherical polynomial from harmonics\n     * @param harmonics the spherical harmonics\n     * @returns the spherical polynomial\n     */\n    updateFromHarmonics(harmonics) {\n        this._harmonics = harmonics;\n        this.x.copyFrom(harmonics.l11);\n        this.x.scaleInPlace(1.02333).scaleInPlace(-1);\n        this.y.copyFrom(harmonics.l1_1);\n        this.y.scaleInPlace(1.02333).scaleInPlace(-1);\n        this.z.copyFrom(harmonics.l10);\n        this.z.scaleInPlace(1.02333);\n        this.xx.copyFrom(harmonics.l00);\n        TmpVectors.Vector3[0].copyFrom(harmonics.l20).scaleInPlace(0.247708);\n        TmpVectors.Vector3[1].copyFrom(harmonics.l22).scaleInPlace(0.429043);\n        this.xx.scaleInPlace(0.886277).subtractInPlace(TmpVectors.Vector3[0]).addInPlace(TmpVectors.Vector3[1]);\n        this.yy.copyFrom(harmonics.l00);\n        this.yy.scaleInPlace(0.886277).subtractInPlace(TmpVectors.Vector3[0]).subtractInPlace(TmpVectors.Vector3[1]);\n        this.zz.copyFrom(harmonics.l00);\n        TmpVectors.Vector3[0].copyFrom(harmonics.l20).scaleInPlace(0.495417);\n        this.zz.scaleInPlace(0.886277).addInPlace(TmpVectors.Vector3[0]);\n        this.yz.copyFrom(harmonics.l2_1);\n        this.yz.scaleInPlace(0.858086).scaleInPlace(-1);\n        this.zx.copyFrom(harmonics.l21);\n        this.zx.scaleInPlace(0.858086).scaleInPlace(-1);\n        this.xy.copyFrom(harmonics.l2_2);\n        this.xy.scaleInPlace(0.858086);\n        this.scaleInPlace(1.0 / Math.PI);\n        return this;\n    }\n    /**\n     * Gets the spherical polynomial from harmonics\n     * @param harmonics the spherical harmonics\n     * @returns the spherical polynomial\n     */\n    static FromHarmonics(harmonics) {\n        const result = new SphericalPolynomial();\n        return result.updateFromHarmonics(harmonics);\n    }\n    /**\n     * Constructs a spherical polynomial from an array.\n     * @param data defines the 9x3 coefficients (x, y, z, xx, yy, zz, yz, zx, xy)\n     * @returns the spherical polynomial\n     */\n    static FromArray(data) {\n        const sp = new SphericalPolynomial();\n        Vector3.FromArrayToRef(data[0], 0, sp.x);\n        Vector3.FromArrayToRef(data[1], 0, sp.y);\n        Vector3.FromArrayToRef(data[2], 0, sp.z);\n        Vector3.FromArrayToRef(data[3], 0, sp.xx);\n        Vector3.FromArrayToRef(data[4], 0, sp.yy);\n        Vector3.FromArrayToRef(data[5], 0, sp.zz);\n        Vector3.FromArrayToRef(data[6], 0, sp.yz);\n        Vector3.FromArrayToRef(data[7], 0, sp.zx);\n        Vector3.FromArrayToRef(data[8], 0, sp.xy);\n        return sp;\n    }\n}\n//# sourceMappingURL=sphericalPolynomial.js.map","import { Vector4 } from \"../../Maths/math.vector.js\";\nimport { Color4 } from \"../../Maths/math.color.js\";\nimport { Mesh } from \"../mesh.js\";\nimport { VertexData } from \"../mesh.vertexData.js\";\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions.js\";\n/**\n * Creates the VertexData for a box\n * @param options an object used to set the following optional parameters for the box, required but can be empty\n * * size sets the width, height and depth of the box to the value of size, optional default 1\n * * width sets the width (x direction) of the box, overwrites the width set by size, optional, default size\n * * height sets the height (y direction) of the box, overwrites the height set by size, optional, default size\n * * depth sets the depth (z direction) of the box, overwrites the depth set by size, optional, default size\n * * faceUV an array of 6 Vector4 elements used to set different images to each box side\n * * faceColors an array of 6 Color3 elements used to set different colors to each box side\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\n * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\n * @param options.size\n * @param options.width\n * @param options.height\n * @param options.depth\n * @param options.faceUV\n * @param options.faceColors\n * @param options.sideOrientation\n * @param options.frontUVs\n * @param options.backUVs\n * @param options.wrap\n * @param options.topBaseAt\n * @param options.bottomBaseAt\n * @returns the VertexData of the box\n */\nexport function CreateBoxVertexData(options) {\n    const nbFaces = 6;\n    let indices = [0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23];\n    const normals = [\n        0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, 0, 1, 0, 0, 1, 0, 0,\n        1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0,\n    ];\n    const uvs = [];\n    let positions = [];\n    const width = options.width || options.size || 1;\n    const height = options.height || options.size || 1;\n    const depth = options.depth || options.size || 1;\n    const wrap = options.wrap || false;\n    let topBaseAt = options.topBaseAt === void 0 ? 1 : options.topBaseAt;\n    let bottomBaseAt = options.bottomBaseAt === void 0 ? 0 : options.bottomBaseAt;\n    topBaseAt = (topBaseAt + 4) % 4; // places values as 0 to 3\n    bottomBaseAt = (bottomBaseAt + 4) % 4; // places values as 0 to 3\n    const topOrder = [2, 0, 3, 1];\n    const bottomOrder = [2, 0, 1, 3];\n    let topIndex = topOrder[topBaseAt];\n    let bottomIndex = bottomOrder[bottomBaseAt];\n    let basePositions = [\n        1, -1, 1, -1, -1, 1, -1, 1, 1, 1, 1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1, 1, 1, -1, 1, -1, -1, 1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1,\n        1, 1, -1, 1, -1, 1, 1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, -1, -1, -1, -1, -1, 1,\n    ];\n    if (wrap) {\n        indices = [2, 3, 0, 2, 0, 1, 4, 5, 6, 4, 6, 7, 9, 10, 11, 9, 11, 8, 12, 14, 15, 12, 13, 14];\n        basePositions = [\n            -1, 1, 1, 1, 1, 1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1, 1, 1, 1, 1, 1, -1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1, 1, 1, -1, -1, 1, -1, -1, -1,\n        ];\n        let topFaceBase = [\n            [1, 1, 1],\n            [-1, 1, 1],\n            [-1, 1, -1],\n            [1, 1, -1],\n        ];\n        let bottomFaceBase = [\n            [-1, -1, 1],\n            [1, -1, 1],\n            [1, -1, -1],\n            [-1, -1, -1],\n        ];\n        const topFaceOrder = [17, 18, 19, 16];\n        const bottomFaceOrder = [22, 23, 20, 21];\n        while (topIndex > 0) {\n            topFaceBase.unshift(topFaceBase.pop());\n            topFaceOrder.unshift(topFaceOrder.pop());\n            topIndex--;\n        }\n        while (bottomIndex > 0) {\n            bottomFaceBase.unshift(bottomFaceBase.pop());\n            bottomFaceOrder.unshift(bottomFaceOrder.pop());\n            bottomIndex--;\n        }\n        topFaceBase = topFaceBase.flat();\n        bottomFaceBase = bottomFaceBase.flat();\n        basePositions = basePositions.concat(topFaceBase).concat(bottomFaceBase);\n        indices.push(topFaceOrder[0], topFaceOrder[2], topFaceOrder[3], topFaceOrder[0], topFaceOrder[1], topFaceOrder[2]);\n        indices.push(bottomFaceOrder[0], bottomFaceOrder[2], bottomFaceOrder[3], bottomFaceOrder[0], bottomFaceOrder[1], bottomFaceOrder[2]);\n    }\n    const scaleArray = [width / 2, height / 2, depth / 2];\n    positions = basePositions.reduce((accumulator, currentValue, currentIndex) => accumulator.concat(currentValue * scaleArray[currentIndex % 3]), []);\n    const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\n    const faceUV = options.faceUV || new Array(6);\n    const faceColors = options.faceColors;\n    const colors = [];\n    // default face colors and UV if undefined\n    for (let f = 0; f < 6; f++) {\n        if (faceUV[f] === undefined) {\n            faceUV[f] = new Vector4(0, 0, 1, 1);\n        }\n        if (faceColors && faceColors[f] === undefined) {\n            faceColors[f] = new Color4(1, 1, 1, 1);\n        }\n    }\n    // Create each face in turn.\n    for (let index = 0; index < nbFaces; index++) {\n        uvs.push(faceUV[index].z, CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 - faceUV[index].w : faceUV[index].w);\n        uvs.push(faceUV[index].x, CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 - faceUV[index].w : faceUV[index].w);\n        uvs.push(faceUV[index].x, CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 - faceUV[index].y : faceUV[index].y);\n        uvs.push(faceUV[index].z, CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 - faceUV[index].y : faceUV[index].y);\n        if (faceColors) {\n            for (let c = 0; c < 4; c++) {\n                colors.push(faceColors[index].r, faceColors[index].g, faceColors[index].b, faceColors[index].a);\n            }\n        }\n    }\n    // sides\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\n    // Result\n    const vertexData = new VertexData();\n    vertexData.indices = indices;\n    vertexData.positions = positions;\n    vertexData.normals = normals;\n    vertexData.uvs = uvs;\n    if (faceColors) {\n        const totalColors = sideOrientation === VertexData.DOUBLESIDE ? colors.concat(colors) : colors;\n        vertexData.colors = totalColors;\n    }\n    return vertexData;\n}\n/**\n * Creates a box mesh\n * * The parameter `size` sets the size (float) of each box side (default 1)\n * * You can set some different box dimensions by using the parameters `width`, `height` and `depth` (all by default have the same value of `size`)\n * * You can set different colors and different images to each box side by using the parameters `faceColors` (an array of 6 Color3 elements) and `faceUV` (an array of 6 Vector4 elements)\n * * Please read this tutorial : https://doc.babylonjs.com/features/featuresDeepDive/materials/using/texturePerBoxFace\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#side-orientation\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#box\n * @param name defines the name of the mesh\n * @param options defines the options used to create the mesh\n * @param options.size\n * @param options.width\n * @param options.height\n * @param options.depth\n * @param options.faceUV\n * @param options.faceColors\n * @param options.sideOrientation\n * @param options.frontUVs\n * @param options.backUVs\n * @param options.wrap\n * @param options.topBaseAt\n * @param options.bottomBaseAt\n * @param options.updatable\n * @param scene defines the hosting scene\n * @returns the box mesh\n */\nexport function CreateBox(name, options = {}, scene = null) {\n    const box = new Mesh(name, scene);\n    options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\n    box._originalBuilderSideOrientation = options.sideOrientation;\n    const vertexData = CreateBoxVertexData(options);\n    vertexData.applyToMesh(box, options.updatable);\n    return box;\n}\n/**\n * Class containing static functions to help procedurally build meshes\n * @deprecated please use CreateBox directly\n */\nexport const BoxBuilder = {\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    CreateBox,\n};\n// Side effects\nVertexData.CreateBox = CreateBoxVertexData;\nMesh.CreateBox = (name, size, scene = null, updatable, sideOrientation) => {\n    const options = {\n        size,\n        sideOrientation,\n        updatable,\n    };\n    return CreateBox(name, options, scene);\n};\n//# sourceMappingURL=boxBuilder.js.map","import { VertexData } from \"../mesh.vertexData.js\";\nimport { Vector2, Vector3, Matrix } from \"../../Maths/math.vector.js\";\nimport { Mesh } from \"../mesh.js\";\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions.js\";\n/**\n * Scripts based off of https://github.com/maximeq/three-js-capsule-geometry/blob/master/src/CapsuleBufferGeometry.js\n * @param options the constructors options used to shape the mesh.\n * @returns the capsule VertexData\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set/capsule\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport function CreateCapsuleVertexData(options = {\n    subdivisions: 2,\n    tessellation: 16,\n    height: 1,\n    radius: 0.25,\n    capSubdivisions: 6,\n}) {\n    const subdivisions = Math.max(options.subdivisions ? options.subdivisions : 2, 1);\n    const tessellation = Math.max(options.tessellation ? options.tessellation : 16, 3);\n    const height = Math.max(options.height ? options.height : 1, 0);\n    const radius = Math.max(options.radius ? options.radius : 0.25, 0);\n    const capDetail = Math.max(options.capSubdivisions ? options.capSubdivisions : 6, 1);\n    const radialSegments = tessellation;\n    const heightSegments = subdivisions;\n    const radiusTop = Math.max(options.radiusTop ? options.radiusTop : radius, 0);\n    const radiusBottom = Math.max(options.radiusBottom ? options.radiusBottom : radius, 0);\n    const heightMinusCaps = height - (radiusTop + radiusBottom);\n    const thetaStart = 0.0;\n    const thetaLength = 2.0 * Math.PI;\n    const capsTopSegments = Math.max(options.topCapSubdivisions ? options.topCapSubdivisions : capDetail, 1);\n    const capsBottomSegments = Math.max(options.bottomCapSubdivisions ? options.bottomCapSubdivisions : capDetail, 1);\n    const alpha = Math.acos((radiusBottom - radiusTop) / height);\n    let indices = [];\n    const vertices = [];\n    const normals = [];\n    const uvs = [];\n    let index = 0;\n    const indexArray = [], halfHeight = heightMinusCaps * 0.5;\n    const pi2 = Math.PI * 0.5;\n    let x, y;\n    const normal = Vector3.Zero();\n    const vertex = Vector3.Zero();\n    const cosAlpha = Math.cos(alpha);\n    const sinAlpha = Math.sin(alpha);\n    const coneLength = new Vector2(radiusTop * sinAlpha, halfHeight + radiusTop * cosAlpha)\n        .subtract(new Vector2(radiusBottom * sinAlpha, -halfHeight + radiusBottom * cosAlpha))\n        .length();\n    // Total length for v texture coord\n    const vl = radiusTop * alpha + coneLength + radiusBottom * (pi2 - alpha);\n    let v = 0;\n    for (y = 0; y <= capsTopSegments; y++) {\n        const indexRow = [];\n        const a = pi2 - alpha * (y / capsTopSegments);\n        v += (radiusTop * alpha) / capsTopSegments;\n        const cosA = Math.cos(a);\n        const sinA = Math.sin(a);\n        // calculate the radius of the current row\n        const _radius = cosA * radiusTop;\n        for (x = 0; x <= radialSegments; x++) {\n            const u = x / radialSegments;\n            const theta = u * thetaLength + thetaStart;\n            const sinTheta = Math.sin(theta);\n            const cosTheta = Math.cos(theta);\n            // vertex\n            vertex.x = _radius * sinTheta;\n            vertex.y = halfHeight + sinA * radiusTop;\n            vertex.z = _radius * cosTheta;\n            vertices.push(vertex.x, vertex.y, vertex.z);\n            // normal\n            normal.set(cosA * sinTheta, sinA, cosA * cosTheta);\n            normals.push(normal.x, normal.y, normal.z);\n            // uv\n            uvs.push(u, CompatibilityOptions.UseOpenGLOrientationForUV ? v / vl : 1 - v / vl);\n            // save index of vertex in respective row\n            indexRow.push(index);\n            // increase index\n            index++;\n        }\n        // now save vertices of the row in our index array\n        indexArray.push(indexRow);\n    }\n    const coneHeight = height - radiusTop - radiusBottom + cosAlpha * radiusTop - cosAlpha * radiusBottom;\n    const slope = (sinAlpha * (radiusBottom - radiusTop)) / coneHeight;\n    for (y = 1; y <= heightSegments; y++) {\n        const indexRow = [];\n        v += coneLength / heightSegments;\n        // calculate the radius of the current row\n        const _radius = sinAlpha * ((y * (radiusBottom - radiusTop)) / heightSegments + radiusTop);\n        for (x = 0; x <= radialSegments; x++) {\n            const u = x / radialSegments;\n            const theta = u * thetaLength + thetaStart;\n            const sinTheta = Math.sin(theta);\n            const cosTheta = Math.cos(theta);\n            // vertex\n            vertex.x = _radius * sinTheta;\n            vertex.y = halfHeight + cosAlpha * radiusTop - (y * coneHeight) / heightSegments;\n            vertex.z = _radius * cosTheta;\n            vertices.push(vertex.x, vertex.y, vertex.z);\n            // normal\n            normal.set(sinTheta, slope, cosTheta).normalize();\n            normals.push(normal.x, normal.y, normal.z);\n            // uv\n            uvs.push(u, CompatibilityOptions.UseOpenGLOrientationForUV ? v / vl : 1 - v / vl);\n            // save index of vertex in respective row\n            indexRow.push(index);\n            // increase index\n            index++;\n        }\n        // now save vertices of the row in our index array\n        indexArray.push(indexRow);\n    }\n    for (y = 1; y <= capsBottomSegments; y++) {\n        const indexRow = [];\n        const a = pi2 - alpha - (Math.PI - alpha) * (y / capsBottomSegments);\n        v += (radiusBottom * alpha) / capsBottomSegments;\n        const cosA = Math.cos(a);\n        const sinA = Math.sin(a);\n        // calculate the radius of the current row\n        const _radius = cosA * radiusBottom;\n        for (x = 0; x <= radialSegments; x++) {\n            const u = x / radialSegments;\n            const theta = u * thetaLength + thetaStart;\n            const sinTheta = Math.sin(theta);\n            const cosTheta = Math.cos(theta);\n            // vertex\n            vertex.x = _radius * sinTheta;\n            vertex.y = -halfHeight + sinA * radiusBottom;\n            vertex.z = _radius * cosTheta;\n            vertices.push(vertex.x, vertex.y, vertex.z);\n            // normal\n            normal.set(cosA * sinTheta, sinA, cosA * cosTheta);\n            normals.push(normal.x, normal.y, normal.z);\n            // uv\n            uvs.push(u, CompatibilityOptions.UseOpenGLOrientationForUV ? v / vl : 1 - v / vl);\n            // save index of vertex in respective row\n            indexRow.push(index);\n            // increase index\n            index++;\n        }\n        // now save vertices of the row in our index array\n        indexArray.push(indexRow);\n    }\n    // generate indices\n    for (x = 0; x < radialSegments; x++) {\n        for (y = 0; y < capsTopSegments + heightSegments + capsBottomSegments; y++) {\n            // we use the index array to access the correct indices\n            const i1 = indexArray[y][x];\n            const i2 = indexArray[y + 1][x];\n            const i3 = indexArray[y + 1][x + 1];\n            const i4 = indexArray[y][x + 1];\n            // face one\n            indices.push(i1);\n            indices.push(i2);\n            indices.push(i4);\n            // face two\n            indices.push(i2);\n            indices.push(i3);\n            indices.push(i4);\n        }\n    }\n    indices = indices.reverse();\n    if (options.orientation && !options.orientation.equals(Vector3.Up())) {\n        const m = new Matrix();\n        options.orientation\n            .clone()\n            .scale(Math.PI * 0.5)\n            .cross(Vector3.Up())\n            .toQuaternion()\n            .toRotationMatrix(m);\n        const v = Vector3.Zero();\n        for (let i = 0; i < vertices.length; i += 3) {\n            v.set(vertices[i], vertices[i + 1], vertices[i + 2]);\n            Vector3.TransformCoordinatesToRef(v.clone(), m, v);\n            vertices[i] = v.x;\n            vertices[i + 1] = v.y;\n            vertices[i + 2] = v.z;\n        }\n    }\n    const vDat = new VertexData();\n    vDat.positions = vertices;\n    vDat.normals = normals;\n    vDat.uvs = uvs;\n    vDat.indices = indices;\n    return vDat;\n}\n/**\n * Creates a capsule or a pill mesh\n * @param name defines the name of the mesh\n * @param options The constructors options.\n * @param scene The scene the mesh is scoped to.\n * @returns Capsule Mesh\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport function CreateCapsule(name, options = {\n    orientation: Vector3.Up(),\n    subdivisions: 2,\n    tessellation: 16,\n    height: 1,\n    radius: 0.25,\n    capSubdivisions: 6,\n    updatable: false,\n}, scene = null) {\n    const capsule = new Mesh(name, scene);\n    const vertexData = CreateCapsuleVertexData(options);\n    vertexData.applyToMesh(capsule, options.updatable);\n    return capsule;\n}\n/**\n * Class containing static functions to help procedurally build meshes\n * @deprecated please use CreateCapsule directly\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport const CapsuleBuilder = {\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    CreateCapsule,\n};\n/**\n * Creates a capsule or a pill mesh\n * @param name defines the name of the mesh.\n * @param options the constructors options used to shape the mesh.\n * @param scene defines the scene the mesh is scoped to.\n * @returns the capsule mesh\n * @see https://doc.babylonjs.com/how_to/capsule_shape\n */\nMesh.CreateCapsule = (name, options, scene) => {\n    return CreateCapsule(name, options, scene);\n};\nVertexData.CreateCapsule = CreateCapsuleVertexData;\n//# sourceMappingURL=capsuleBuilder.js.map","import { Vector4, Vector3, Vector2 } from \"../../Maths/math.vector.js\";\nimport { Color4 } from \"../../Maths/math.color.js\";\nimport { Mesh } from \"../mesh.js\";\nimport { VertexData } from \"../mesh.vertexData.js\";\nimport { Scene } from \"../../scene.js\";\nimport { Axis } from \"../../Maths/math.axis.js\";\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions.js\";\n/**\n * Creates the VertexData for a cylinder, cone or prism\n * @param options an object used to set the following optional parameters for the box, required but can be empty\n * * height sets the height (y direction) of the cylinder, optional, default 2\n * * diameterTop sets the diameter of the top of the cone, overwrites diameter,  optional, default diameter\n * * diameterBottom sets the diameter of the bottom of the cone, overwrites diameter,  optional, default diameter\n * * diameter sets the diameter of the top and bottom of the cone, optional default 1\n * * tessellation the number of prism sides, 3 for a triangular prism, optional, default 24\n * * subdivisions` the number of rings along the cylinder height, optional, default 1\n * * arc a number from 0 to 1, to create an unclosed cylinder based on the fraction of the circumference given by the arc value, optional, default 1\n * * faceColors an array of Color3 elements used to set different colors to the top, rings and bottom respectively\n * * faceUV an array of Vector4 elements used to set different images to the top, rings and bottom respectively\n * * hasRings when true makes each subdivision independently treated as a face for faceUV and faceColors, optional, default false\n * * enclose when true closes an open cylinder by adding extra flat faces between the height axis and vertical edges, think cut cake\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\n * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\n * @param options.height\n * @param options.diameterTop\n * @param options.diameterBottom\n * @param options.diameter\n * @param options.tessellation\n * @param options.subdivisions\n * @param options.arc\n * @param options.faceColors\n * @param options.faceUV\n * @param options.hasRings\n * @param options.enclose\n * @param options.cap\n * @param options.sideOrientation\n * @param options.frontUVs\n * @param options.backUVs\n * @returns the VertexData of the cylinder, cone or prism\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport function CreateCylinderVertexData(options) {\n    const height = options.height || 2;\n    let diameterTop = options.diameterTop === 0 ? 0 : options.diameterTop || options.diameter || 1;\n    let diameterBottom = options.diameterBottom === 0 ? 0 : options.diameterBottom || options.diameter || 1;\n    diameterTop = diameterTop || 0.00001; // Prevent broken normals\n    diameterBottom = diameterBottom || 0.00001; // Prevent broken normals\n    const tessellation = options.tessellation || 24;\n    const subdivisions = options.subdivisions || 1;\n    const hasRings = options.hasRings ? true : false;\n    const enclose = options.enclose ? true : false;\n    const cap = options.cap === 0 ? 0 : options.cap || Mesh.CAP_ALL;\n    const arc = options.arc && (options.arc <= 0 || options.arc > 1) ? 1.0 : options.arc || 1.0;\n    const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\n    const faceUV = options.faceUV || new Array(3);\n    const faceColors = options.faceColors;\n    // default face colors and UV if undefined\n    const quadNb = arc !== 1 && enclose ? 2 : 0;\n    const ringNb = hasRings ? subdivisions : 1;\n    const surfaceNb = 2 + (1 + quadNb) * ringNb;\n    let f;\n    for (f = 0; f < surfaceNb; f++) {\n        if (faceColors && faceColors[f] === undefined) {\n            faceColors[f] = new Color4(1, 1, 1, 1);\n        }\n    }\n    for (f = 0; f < surfaceNb; f++) {\n        if (faceUV && faceUV[f] === undefined) {\n            faceUV[f] = new Vector4(0, 0, 1, 1);\n        }\n    }\n    const indices = new Array();\n    const positions = new Array();\n    const normals = new Array();\n    const uvs = new Array();\n    const colors = new Array();\n    const angleStep = (Math.PI * 2 * arc) / tessellation;\n    let angle;\n    let h;\n    let radius;\n    const tan = (diameterBottom - diameterTop) / 2 / height;\n    const ringVertex = Vector3.Zero();\n    const ringNormal = Vector3.Zero();\n    const ringFirstVertex = Vector3.Zero();\n    const ringFirstNormal = Vector3.Zero();\n    const quadNormal = Vector3.Zero();\n    const Y = Axis.Y;\n    // positions, normals, uvs\n    let i;\n    let j;\n    let r;\n    let ringIdx = 1;\n    let s = 1; // surface index\n    let cs = 0;\n    let v = 0;\n    for (i = 0; i <= subdivisions; i++) {\n        h = i / subdivisions;\n        radius = (h * (diameterTop - diameterBottom) + diameterBottom) / 2;\n        ringIdx = hasRings && i !== 0 && i !== subdivisions ? 2 : 1;\n        for (r = 0; r < ringIdx; r++) {\n            if (hasRings) {\n                s += r;\n            }\n            if (enclose) {\n                s += 2 * r;\n            }\n            for (j = 0; j <= tessellation; j++) {\n                angle = j * angleStep;\n                // position\n                ringVertex.x = Math.cos(-angle) * radius;\n                ringVertex.y = -height / 2 + h * height;\n                ringVertex.z = Math.sin(-angle) * radius;\n                // normal\n                if (diameterTop === 0 && i === subdivisions) {\n                    // if no top cap, reuse former normals\n                    ringNormal.x = normals[normals.length - (tessellation + 1) * 3];\n                    ringNormal.y = normals[normals.length - (tessellation + 1) * 3 + 1];\n                    ringNormal.z = normals[normals.length - (tessellation + 1) * 3 + 2];\n                }\n                else {\n                    ringNormal.x = ringVertex.x;\n                    ringNormal.z = ringVertex.z;\n                    ringNormal.y = Math.sqrt(ringNormal.x * ringNormal.x + ringNormal.z * ringNormal.z) * tan;\n                    ringNormal.normalize();\n                }\n                // keep first ring vertex values for enclose\n                if (j === 0) {\n                    ringFirstVertex.copyFrom(ringVertex);\n                    ringFirstNormal.copyFrom(ringNormal);\n                }\n                positions.push(ringVertex.x, ringVertex.y, ringVertex.z);\n                normals.push(ringNormal.x, ringNormal.y, ringNormal.z);\n                if (hasRings) {\n                    v = cs !== s ? faceUV[s].y : faceUV[s].w;\n                }\n                else {\n                    v = faceUV[s].y + (faceUV[s].w - faceUV[s].y) * h;\n                }\n                uvs.push(faceUV[s].x + ((faceUV[s].z - faceUV[s].x) * j) / tessellation, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v : v);\n                if (faceColors) {\n                    colors.push(faceColors[s].r, faceColors[s].g, faceColors[s].b, faceColors[s].a);\n                }\n            }\n            // if enclose, add four vertices and their dedicated normals\n            if (arc !== 1 && enclose) {\n                positions.push(ringVertex.x, ringVertex.y, ringVertex.z);\n                positions.push(0, ringVertex.y, 0);\n                positions.push(0, ringVertex.y, 0);\n                positions.push(ringFirstVertex.x, ringFirstVertex.y, ringFirstVertex.z);\n                Vector3.CrossToRef(Y, ringNormal, quadNormal);\n                quadNormal.normalize();\n                normals.push(quadNormal.x, quadNormal.y, quadNormal.z, quadNormal.x, quadNormal.y, quadNormal.z);\n                Vector3.CrossToRef(ringFirstNormal, Y, quadNormal);\n                quadNormal.normalize();\n                normals.push(quadNormal.x, quadNormal.y, quadNormal.z, quadNormal.x, quadNormal.y, quadNormal.z);\n                if (hasRings) {\n                    v = cs !== s ? faceUV[s + 1].y : faceUV[s + 1].w;\n                }\n                else {\n                    v = faceUV[s + 1].y + (faceUV[s + 1].w - faceUV[s + 1].y) * h;\n                }\n                uvs.push(faceUV[s + 1].x, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v : v);\n                uvs.push(faceUV[s + 1].z, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v : v);\n                if (hasRings) {\n                    v = cs !== s ? faceUV[s + 2].y : faceUV[s + 2].w;\n                }\n                else {\n                    v = faceUV[s + 2].y + (faceUV[s + 2].w - faceUV[s + 2].y) * h;\n                }\n                uvs.push(faceUV[s + 2].x, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v : v);\n                uvs.push(faceUV[s + 2].z, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v : v);\n                if (faceColors) {\n                    colors.push(faceColors[s + 1].r, faceColors[s + 1].g, faceColors[s + 1].b, faceColors[s + 1].a);\n                    colors.push(faceColors[s + 1].r, faceColors[s + 1].g, faceColors[s + 1].b, faceColors[s + 1].a);\n                    colors.push(faceColors[s + 2].r, faceColors[s + 2].g, faceColors[s + 2].b, faceColors[s + 2].a);\n                    colors.push(faceColors[s + 2].r, faceColors[s + 2].g, faceColors[s + 2].b, faceColors[s + 2].a);\n                }\n            }\n            if (cs !== s) {\n                cs = s;\n            }\n        }\n    }\n    // indices\n    const e = arc !== 1 && enclose ? tessellation + 4 : tessellation; // correction of number of iteration if enclose\n    i = 0;\n    for (s = 0; s < subdivisions; s++) {\n        let i0 = 0;\n        let i1 = 0;\n        let i2 = 0;\n        let i3 = 0;\n        for (j = 0; j < tessellation; j++) {\n            i0 = i * (e + 1) + j;\n            i1 = (i + 1) * (e + 1) + j;\n            i2 = i * (e + 1) + (j + 1);\n            i3 = (i + 1) * (e + 1) + (j + 1);\n            indices.push(i0, i1, i2);\n            indices.push(i3, i2, i1);\n        }\n        if (arc !== 1 && enclose) {\n            // if enclose, add two quads\n            indices.push(i0 + 2, i1 + 2, i2 + 2);\n            indices.push(i3 + 2, i2 + 2, i1 + 2);\n            indices.push(i0 + 4, i1 + 4, i2 + 4);\n            indices.push(i3 + 4, i2 + 4, i1 + 4);\n        }\n        i = hasRings ? i + 2 : i + 1;\n    }\n    // Caps\n    const createCylinderCap = (isTop) => {\n        const radius = isTop ? diameterTop / 2 : diameterBottom / 2;\n        if (radius === 0) {\n            return;\n        }\n        // Cap positions, normals & uvs\n        let angle;\n        let circleVector;\n        let i;\n        const u = isTop ? faceUV[surfaceNb - 1] : faceUV[0];\n        let c = null;\n        if (faceColors) {\n            c = isTop ? faceColors[surfaceNb - 1] : faceColors[0];\n        }\n        // cap center\n        const vbase = positions.length / 3;\n        const offset = isTop ? height / 2 : -height / 2;\n        const center = new Vector3(0, offset, 0);\n        positions.push(center.x, center.y, center.z);\n        normals.push(0, isTop ? 1 : -1, 0);\n        const v = u.y + (u.w - u.y) * 0.5;\n        uvs.push(u.x + (u.z - u.x) * 0.5, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v : v);\n        if (c) {\n            colors.push(c.r, c.g, c.b, c.a);\n        }\n        const textureScale = new Vector2(0.5, 0.5);\n        for (i = 0; i <= tessellation; i++) {\n            angle = (Math.PI * 2 * i * arc) / tessellation;\n            const cos = Math.cos(-angle);\n            const sin = Math.sin(-angle);\n            circleVector = new Vector3(cos * radius, offset, sin * radius);\n            const textureCoordinate = new Vector2(cos * textureScale.x + 0.5, sin * textureScale.y + 0.5);\n            positions.push(circleVector.x, circleVector.y, circleVector.z);\n            normals.push(0, isTop ? 1 : -1, 0);\n            const v = u.y + (u.w - u.y) * textureCoordinate.y;\n            uvs.push(u.x + (u.z - u.x) * textureCoordinate.x, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v : v);\n            if (c) {\n                colors.push(c.r, c.g, c.b, c.a);\n            }\n        }\n        // Cap indices\n        for (i = 0; i < tessellation; i++) {\n            if (!isTop) {\n                indices.push(vbase);\n                indices.push(vbase + (i + 1));\n                indices.push(vbase + (i + 2));\n            }\n            else {\n                indices.push(vbase);\n                indices.push(vbase + (i + 2));\n                indices.push(vbase + (i + 1));\n            }\n        }\n    };\n    // add caps to geometry based on cap parameter\n    if (cap === Mesh.CAP_START || cap === Mesh.CAP_ALL) {\n        createCylinderCap(false);\n    }\n    if (cap === Mesh.CAP_END || cap === Mesh.CAP_ALL) {\n        createCylinderCap(true);\n    }\n    // Sides\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\n    const vertexData = new VertexData();\n    vertexData.indices = indices;\n    vertexData.positions = positions;\n    vertexData.normals = normals;\n    vertexData.uvs = uvs;\n    if (faceColors) {\n        vertexData.colors = colors;\n    }\n    return vertexData;\n}\n/**\n * Creates a cylinder or a cone mesh\n * * The parameter `height` sets the height size (float) of the cylinder/cone (float, default 2).\n * * The parameter `diameter` sets the diameter of the top and bottom cap at once (float, default 1).\n * * The parameters `diameterTop` and `diameterBottom` overwrite the parameter `diameter` and set respectively the top cap and bottom cap diameter (floats, default 1). The parameter \"diameterBottom\" can't be zero.\n * * The parameter `tessellation` sets the number of cylinder sides (positive integer, default 24). Set it to 3 to get a prism for instance.\n * * The parameter `subdivisions` sets the number of rings along the cylinder height (positive integer, default 1).\n * * The parameter `hasRings` (boolean, default false) makes the subdivisions independent from each other, so they become different faces.\n * * The parameter `enclose`  (boolean, default false) adds two extra faces per subdivision to a sliced cylinder to close it around its height axis.\n * * The parameter `cap` sets the way the cylinder is capped. Possible values : BABYLON.Mesh.NO_CAP, BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL (default).\n * * The parameter `arc` (float, default 1) is the ratio (max 1) to apply to the circumference to slice the cylinder.\n * * You can set different colors and different images to each box side by using the parameters `faceColors` (an array of n Color3 elements) and `faceUV` (an array of n Vector4 elements).\n * * The value of n is the number of cylinder faces. If the cylinder has only 1 subdivisions, n equals : top face + cylinder surface + bottom face = 3\n * * Now, if the cylinder has 5 independent subdivisions (hasRings = true), n equals : top face + 5 stripe surfaces + bottom face = 2 + 5 = 7\n * * Finally, if the cylinder has 5 independent subdivisions and is enclose, n equals : top face + 5 x (stripe surface + 2 closing faces) + bottom face = 2 + 5 * 3 = 17\n * * Each array (color or UVs) is always ordered the same way : the first element is the bottom cap, the last element is the top cap. The other elements are each a ring surface.\n * * If `enclose` is false, a ring surface is one element.\n * * If `enclose` is true, a ring surface is 3 successive elements in the array : the tubular surface, then the two closing faces.\n * * Example how to set colors and textures on a sliced cylinder : https://www.html5gamedevs.com/topic/17945-creating-a-closed-slice-of-a-cylinder/#comment-106379\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#side-orientation\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\n * @param name defines the name of the mesh\n * @param options defines the options used to create the mesh\n * @param options.height\n * @param options.diameterTop\n * @param options.diameterBottom\n * @param options.diameter\n * @param options.tessellation\n * @param options.subdivisions\n * @param options.arc\n * @param options.faceColors\n * @param options.faceUV\n * @param options.updatable\n * @param options.hasRings\n * @param options.enclose\n * @param options.cap\n * @param options.sideOrientation\n * @param options.frontUVs\n * @param options.backUVs\n * @param scene defines the hosting scene\n * @returns the cylinder mesh\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#cylinder-or-cone\n */\nexport function CreateCylinder(name, options = {}, scene) {\n    const cylinder = new Mesh(name, scene);\n    options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\n    cylinder._originalBuilderSideOrientation = options.sideOrientation;\n    const vertexData = CreateCylinderVertexData(options);\n    vertexData.applyToMesh(cylinder, options.updatable);\n    return cylinder;\n}\n/**\n * Class containing static functions to help procedurally build meshes\n * @deprecated Please use CreateCylinder directly\n */\nexport const CylinderBuilder = {\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    CreateCylinder,\n};\nVertexData.CreateCylinder = CreateCylinderVertexData;\nMesh.CreateCylinder = (name, height, diameterTop, diameterBottom, tessellation, subdivisions, scene, updatable, sideOrientation) => {\n    if (scene === undefined || !(scene instanceof Scene)) {\n        if (scene !== undefined) {\n            sideOrientation = updatable || Mesh.DEFAULTSIDE;\n            updatable = scene;\n        }\n        scene = subdivisions;\n        subdivisions = 1;\n    }\n    const options = {\n        height,\n        diameterTop,\n        diameterBottom,\n        tessellation,\n        subdivisions,\n        sideOrientation,\n        updatable,\n    };\n    return CreateCylinder(name, options, scene);\n};\n//# sourceMappingURL=cylinderBuilder.js.map","import { Vector3, Matrix, Vector2 } from \"../../Maths/math.vector.js\";\nimport { Scalar } from \"../../Maths/math.scalar.js\";\nimport { Mesh } from \"../mesh.js\";\nimport { VertexBuffer } from \"../../Buffers/buffer.js\";\nimport { VertexData } from \"../mesh.vertexData.js\";\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions.js\";\nconst xpAxis = new Vector3(1, 0, 0);\nconst xnAxis = new Vector3(-1, 0, 0);\nconst ypAxis = new Vector3(0, 1, 0);\nconst ynAxis = new Vector3(0, -1, 0);\nconst zpAxis = new Vector3(0, 0, 1);\nconst znAxis = new Vector3(0, 0, -1);\n/** @internal */\nclass DecalVertex {\n    constructor(position = Vector3.Zero(), normal = Vector3.Up(), uv = Vector2.Zero(), vertexIdx = 0, vertexIdxForBones = 0, localPositionOverride = null, localNormalOverride = null, matrixIndicesOverride = null, matrixWeightsOverride = null) {\n        this.position = position;\n        this.normal = normal;\n        this.uv = uv;\n        this.vertexIdx = vertexIdx;\n        this.vertexIdxForBones = vertexIdxForBones;\n        this.localPositionOverride = localPositionOverride;\n        this.localNormalOverride = localNormalOverride;\n        this.matrixIndicesOverride = matrixIndicesOverride;\n        this.matrixWeightsOverride = matrixWeightsOverride;\n    }\n    clone() {\n        var _a, _b, _c, _d;\n        return new DecalVertex(this.position.clone(), this.normal.clone(), this.uv.clone(), this.vertexIdx, this.vertexIdxForBones, (_a = this.localPositionOverride) === null || _a === void 0 ? void 0 : _a.slice(), (_b = this.localNormalOverride) === null || _b === void 0 ? void 0 : _b.slice(), (_c = this.matrixIndicesOverride) === null || _c === void 0 ? void 0 : _c.slice(), (_d = this.matrixWeightsOverride) === null || _d === void 0 ? void 0 : _d.slice());\n    }\n}\n/**\n * Creates a decal mesh.\n * A decal is a mesh usually applied as a model onto the surface of another mesh. So don't forget the parameter `sourceMesh` depicting the decal\n * * The parameter `position` (Vector3, default `(0, 0, 0)`) sets the position of the decal in World coordinates\n * * The parameter `normal` (Vector3, default `Vector3.Up`) sets the normal of the mesh where the decal is applied onto in World coordinates\n * * The parameter `size` (Vector3, default `(1, 1, 1)`) sets the decal scaling\n * * The parameter `angle` (float in radian, default 0) sets the angle to rotate the decal\n * * The parameter `captureUVS` defines if we need to capture the uvs or compute them\n * * The parameter `cullBackFaces` defines if the back faces should be removed from the decal mesh\n * * The parameter `localMode` defines that the computations should be done with the local mesh coordinates instead of the world space coordinates.\n * *    Use this mode if you want the decal to be parented to the sourceMesh and move/rotate with it.\n * Note: Meshes with morph targets are not supported!\n * @param name defines the name of the mesh\n * @param sourceMesh defines the mesh where the decal must be applied\n * @param options defines the options used to create the mesh\n * @param options.position\n * @param options.normal\n * @param options.size\n * @param options.angle\n * @param options.captureUVS\n * @param options.cullBackFaces\n * @param options.localMode\n * @returns the decal mesh\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/decals\n */\nexport function CreateDecal(name, sourceMesh, options) {\n    const hasSkeleton = !!sourceMesh.skeleton;\n    const useLocalComputation = options.localMode || hasSkeleton;\n    const meshHasOverridenMaterial = sourceMesh.overrideMaterialSideOrientation !== null && sourceMesh.overrideMaterialSideOrientation !== undefined;\n    const indices = sourceMesh.getIndices();\n    const positions = hasSkeleton ? sourceMesh.getPositionData(true, true) : sourceMesh.getVerticesData(VertexBuffer.PositionKind);\n    const normals = hasSkeleton ? sourceMesh.getNormalsData(true, true) : sourceMesh.getVerticesData(VertexBuffer.NormalKind);\n    const localPositions = useLocalComputation ? (hasSkeleton ? sourceMesh.getVerticesData(VertexBuffer.PositionKind) : positions) : null;\n    const localNormals = useLocalComputation ? (hasSkeleton ? sourceMesh.getVerticesData(VertexBuffer.NormalKind) : normals) : null;\n    const uvs = sourceMesh.getVerticesData(VertexBuffer.UVKind);\n    const matIndices = hasSkeleton ? sourceMesh.getVerticesData(VertexBuffer.MatricesIndicesKind) : null;\n    const matWeights = hasSkeleton ? sourceMesh.getVerticesData(VertexBuffer.MatricesWeightsKind) : null;\n    const matIndicesExtra = hasSkeleton ? sourceMesh.getVerticesData(VertexBuffer.MatricesIndicesExtraKind) : null;\n    const matWeightsExtra = hasSkeleton ? sourceMesh.getVerticesData(VertexBuffer.MatricesWeightsExtraKind) : null;\n    const position = options.position || Vector3.Zero();\n    let normal = options.normal || Vector3.Up();\n    const size = options.size || Vector3.One();\n    const angle = options.angle || 0;\n    // Getting correct rotation\n    if (!normal) {\n        const target = new Vector3(0, 0, 1);\n        const camera = sourceMesh.getScene().activeCamera;\n        const cameraWorldTarget = Vector3.TransformCoordinates(target, camera.getWorldMatrix());\n        normal = camera.globalPosition.subtract(cameraWorldTarget);\n    }\n    const yaw = -Math.atan2(normal.z, normal.x) - Math.PI / 2;\n    const len = Math.sqrt(normal.x * normal.x + normal.z * normal.z);\n    const pitch = Math.atan2(normal.y, len);\n    // Matrix\n    const decalWorldMatrix = Matrix.RotationYawPitchRoll(yaw, pitch, angle).multiply(Matrix.Translation(position.x, position.y, position.z));\n    const inverseDecalWorldMatrix = Matrix.Invert(decalWorldMatrix);\n    const meshWorldMatrix = sourceMesh.getWorldMatrix();\n    const transformMatrix = meshWorldMatrix.multiply(inverseDecalWorldMatrix);\n    const vertexData = new VertexData();\n    vertexData.indices = [];\n    vertexData.positions = [];\n    vertexData.normals = [];\n    vertexData.uvs = [];\n    vertexData.matricesIndices = hasSkeleton ? [] : null;\n    vertexData.matricesWeights = hasSkeleton ? [] : null;\n    vertexData.matricesIndicesExtra = matIndicesExtra ? [] : null;\n    vertexData.matricesWeightsExtra = matWeightsExtra ? [] : null;\n    let currentVertexDataIndex = 0;\n    const extractDecalVector3 = (indexId) => {\n        const result = new DecalVertex();\n        if (!indices || !positions || !normals) {\n            return result;\n        }\n        const vertexId = indices[indexId];\n        result.vertexIdx = vertexId * 3;\n        result.vertexIdxForBones = vertexId * 4;\n        // Send vector to decal local world\n        result.position = new Vector3(positions[vertexId * 3], positions[vertexId * 3 + 1], positions[vertexId * 3 + 2]);\n        Vector3.TransformCoordinatesToRef(result.position, transformMatrix, result.position);\n        // Get normal\n        result.normal = new Vector3(normals[vertexId * 3], normals[vertexId * 3 + 1], normals[vertexId * 3 + 2]);\n        Vector3.TransformNormalToRef(result.normal, transformMatrix, result.normal);\n        if (options.captureUVS && uvs) {\n            const v = uvs[vertexId * 2 + 1];\n            result.uv = new Vector2(uvs[vertexId * 2], CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v : v);\n        }\n        return result;\n    };\n    const emptyArray = [0, 0, 0, 0];\n    // Inspired by https://github.com/mrdoob/three.js/blob/eee231960882f6f3b6113405f524956145148146/examples/js/geometries/DecalGeometry.js\n    const clip = (vertices, axis) => {\n        if (vertices.length === 0) {\n            return vertices;\n        }\n        const clipSize = 0.5 * Math.abs(Vector3.Dot(size, axis));\n        const indexOf = (arr, val, start, num) => {\n            for (let i = 0; i < num; ++i) {\n                if (arr[start + i] === val) {\n                    return start + i;\n                }\n            }\n            return -1;\n        };\n        const clipVertices = (v0, v1) => {\n            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r;\n            const clipFactor = Vector3.GetClipFactor(v0.position, v1.position, axis, clipSize);\n            let indices = emptyArray;\n            let weights = emptyArray;\n            if (matIndices && matWeights) {\n                const mat0Index = v0.matrixIndicesOverride ? 0 : v0.vertexIdxForBones;\n                const v0Indices = (_a = v0.matrixIndicesOverride) !== null && _a !== void 0 ? _a : matIndices;\n                const v0Weights = (_b = v0.matrixWeightsOverride) !== null && _b !== void 0 ? _b : matWeights;\n                const mat1Index = v1.matrixIndicesOverride ? 0 : v1.vertexIdxForBones;\n                const v1Indices = (_c = v1.matrixIndicesOverride) !== null && _c !== void 0 ? _c : matIndices;\n                const v1Weights = (_d = v1.matrixWeightsOverride) !== null && _d !== void 0 ? _d : matWeights;\n                indices = [0, 0, 0, 0];\n                weights = [0, 0, 0, 0];\n                let index = 0;\n                for (let i = 0; i < 4; ++i) {\n                    if (v0Weights[mat0Index + i] > 0) {\n                        const idx = indexOf(v1Indices, v0Indices[mat0Index + i], mat1Index, 4);\n                        indices[index] = v0Indices[mat0Index + i];\n                        weights[index] = Scalar.Lerp(v0Weights[mat0Index + i], idx >= 0 ? v1Weights[idx] : 0, clipFactor);\n                        index++;\n                    }\n                }\n                for (let i = 0; i < 4 && index < 4; ++i) {\n                    const ind = v1Indices[mat1Index + i];\n                    if (indexOf(v0Indices, ind, mat0Index, 4) !== -1)\n                        continue;\n                    indices[index] = ind;\n                    weights[index] = Scalar.Lerp(0, v1Weights[mat1Index + i], clipFactor);\n                    index++;\n                }\n                const sumw = weights[0] + weights[1] + weights[2] + weights[3];\n                weights[0] /= sumw;\n                weights[1] /= sumw;\n                weights[2] /= sumw;\n                weights[3] /= sumw;\n            }\n            const v0LocalPositionX = v0.localPositionOverride ? v0.localPositionOverride[0] : (_e = localPositions === null || localPositions === void 0 ? void 0 : localPositions[v0.vertexIdx]) !== null && _e !== void 0 ? _e : 0;\n            const v0LocalPositionY = v0.localPositionOverride ? v0.localPositionOverride[1] : (_f = localPositions === null || localPositions === void 0 ? void 0 : localPositions[v0.vertexIdx + 1]) !== null && _f !== void 0 ? _f : 0;\n            const v0LocalPositionZ = v0.localPositionOverride ? v0.localPositionOverride[2] : (_g = localPositions === null || localPositions === void 0 ? void 0 : localPositions[v0.vertexIdx + 2]) !== null && _g !== void 0 ? _g : 0;\n            const v1LocalPositionX = v1.localPositionOverride ? v1.localPositionOverride[0] : (_h = localPositions === null || localPositions === void 0 ? void 0 : localPositions[v1.vertexIdx]) !== null && _h !== void 0 ? _h : 0;\n            const v1LocalPositionY = v1.localPositionOverride ? v1.localPositionOverride[1] : (_j = localPositions === null || localPositions === void 0 ? void 0 : localPositions[v1.vertexIdx + 1]) !== null && _j !== void 0 ? _j : 0;\n            const v1LocalPositionZ = v1.localPositionOverride ? v1.localPositionOverride[2] : (_k = localPositions === null || localPositions === void 0 ? void 0 : localPositions[v1.vertexIdx + 2]) !== null && _k !== void 0 ? _k : 0;\n            const v0LocalNormalX = v0.localNormalOverride ? v0.localNormalOverride[0] : (_l = localNormals === null || localNormals === void 0 ? void 0 : localNormals[v0.vertexIdx]) !== null && _l !== void 0 ? _l : 0;\n            const v0LocalNormalY = v0.localNormalOverride ? v0.localNormalOverride[1] : (_m = localNormals === null || localNormals === void 0 ? void 0 : localNormals[v0.vertexIdx + 1]) !== null && _m !== void 0 ? _m : 0;\n            const v0LocalNormalZ = v0.localNormalOverride ? v0.localNormalOverride[2] : (_o = localNormals === null || localNormals === void 0 ? void 0 : localNormals[v0.vertexIdx + 2]) !== null && _o !== void 0 ? _o : 0;\n            const v1LocalNormalX = v1.localNormalOverride ? v1.localNormalOverride[0] : (_p = localNormals === null || localNormals === void 0 ? void 0 : localNormals[v1.vertexIdx]) !== null && _p !== void 0 ? _p : 0;\n            const v1LocalNormalY = v1.localNormalOverride ? v1.localNormalOverride[1] : (_q = localNormals === null || localNormals === void 0 ? void 0 : localNormals[v1.vertexIdx + 1]) !== null && _q !== void 0 ? _q : 0;\n            const v1LocalNormalZ = v1.localNormalOverride ? v1.localNormalOverride[2] : (_r = localNormals === null || localNormals === void 0 ? void 0 : localNormals[v1.vertexIdx + 2]) !== null && _r !== void 0 ? _r : 0;\n            const interpNormalX = v0LocalNormalX + (v1LocalNormalX - v0LocalNormalX) * clipFactor;\n            const interpNormalY = v0LocalNormalY + (v1LocalNormalY - v0LocalNormalY) * clipFactor;\n            const interpNormalZ = v0LocalNormalZ + (v1LocalNormalZ - v0LocalNormalZ) * clipFactor;\n            const norm = Math.sqrt(interpNormalX * interpNormalX + interpNormalY * interpNormalY + interpNormalZ * interpNormalZ);\n            return new DecalVertex(Vector3.Lerp(v0.position, v1.position, clipFactor), Vector3.Lerp(v0.normal, v1.normal, clipFactor).normalize(), Vector2.Lerp(v0.uv, v1.uv, clipFactor), -1, -1, localPositions\n                ? [\n                    v0LocalPositionX + (v1LocalPositionX - v0LocalPositionX) * clipFactor,\n                    v0LocalPositionY + (v1LocalPositionY - v0LocalPositionY) * clipFactor,\n                    v0LocalPositionZ + (v1LocalPositionZ - v0LocalPositionZ) * clipFactor,\n                ]\n                : null, localNormals ? [interpNormalX / norm, interpNormalY / norm, interpNormalZ / norm] : null, indices, weights);\n        };\n        let clipResult = null;\n        if (vertices.length > 3) {\n            clipResult = new Array();\n        }\n        for (let index = 0; index < vertices.length; index += 3) {\n            let total = 0;\n            let nV1 = null;\n            let nV2 = null;\n            let nV3 = null;\n            let nV4 = null;\n            const d1 = Vector3.Dot(vertices[index].position, axis) - clipSize;\n            const d2 = Vector3.Dot(vertices[index + 1].position, axis) - clipSize;\n            const d3 = Vector3.Dot(vertices[index + 2].position, axis) - clipSize;\n            const v1Out = d1 > 0;\n            const v2Out = d2 > 0;\n            const v3Out = d3 > 0;\n            total = (v1Out ? 1 : 0) + (v2Out ? 1 : 0) + (v3Out ? 1 : 0);\n            switch (total) {\n                case 0:\n                    if (vertices.length > 3) {\n                        clipResult.push(vertices[index]);\n                        clipResult.push(vertices[index + 1]);\n                        clipResult.push(vertices[index + 2]);\n                    }\n                    else {\n                        clipResult = vertices;\n                    }\n                    break;\n                case 1:\n                    clipResult = clipResult !== null && clipResult !== void 0 ? clipResult : new Array();\n                    if (v1Out) {\n                        nV1 = vertices[index + 1];\n                        nV2 = vertices[index + 2];\n                        nV3 = clipVertices(vertices[index], nV1);\n                        nV4 = clipVertices(vertices[index], nV2);\n                    }\n                    if (v2Out) {\n                        nV1 = vertices[index];\n                        nV2 = vertices[index + 2];\n                        nV3 = clipVertices(vertices[index + 1], nV1);\n                        nV4 = clipVertices(vertices[index + 1], nV2);\n                        clipResult.push(nV3);\n                        clipResult.push(nV2.clone());\n                        clipResult.push(nV1.clone());\n                        clipResult.push(nV2.clone());\n                        clipResult.push(nV3.clone());\n                        clipResult.push(nV4);\n                        break;\n                    }\n                    if (v3Out) {\n                        nV1 = vertices[index];\n                        nV2 = vertices[index + 1];\n                        nV3 = clipVertices(vertices[index + 2], nV1);\n                        nV4 = clipVertices(vertices[index + 2], nV2);\n                    }\n                    if (nV1 && nV2 && nV3 && nV4) {\n                        clipResult.push(nV1.clone());\n                        clipResult.push(nV2.clone());\n                        clipResult.push(nV3);\n                        clipResult.push(nV4);\n                        clipResult.push(nV3.clone());\n                        clipResult.push(nV2.clone());\n                    }\n                    break;\n                case 2:\n                    clipResult = clipResult !== null && clipResult !== void 0 ? clipResult : new Array();\n                    if (!v1Out) {\n                        nV1 = vertices[index].clone();\n                        nV2 = clipVertices(nV1, vertices[index + 1]);\n                        nV3 = clipVertices(nV1, vertices[index + 2]);\n                        clipResult.push(nV1);\n                        clipResult.push(nV2);\n                        clipResult.push(nV3);\n                    }\n                    if (!v2Out) {\n                        nV1 = vertices[index + 1].clone();\n                        nV2 = clipVertices(nV1, vertices[index + 2]);\n                        nV3 = clipVertices(nV1, vertices[index]);\n                        clipResult.push(nV1);\n                        clipResult.push(nV2);\n                        clipResult.push(nV3);\n                    }\n                    if (!v3Out) {\n                        nV1 = vertices[index + 2].clone();\n                        nV2 = clipVertices(nV1, vertices[index]);\n                        nV3 = clipVertices(nV1, vertices[index + 1]);\n                        clipResult.push(nV1);\n                        clipResult.push(nV2);\n                        clipResult.push(nV3);\n                    }\n                    break;\n                case 3:\n                    break;\n            }\n        }\n        return clipResult;\n    };\n    const oneFaceVertices = new Array(3);\n    for (let index = 0; index < indices.length; index += 3) {\n        let faceVertices = oneFaceVertices;\n        faceVertices[0] = extractDecalVector3(index);\n        if (meshHasOverridenMaterial && useLocalComputation) {\n            faceVertices[1] = extractDecalVector3(index + 2);\n            faceVertices[2] = extractDecalVector3(index + 1);\n        }\n        else {\n            faceVertices[1] = extractDecalVector3(index + 1);\n            faceVertices[2] = extractDecalVector3(index + 2);\n        }\n        if (options.cullBackFaces) {\n            // If all the normals of the vertices of the face are pointing away from the view direction we discard the face.\n            // As computations are done in the decal coordinate space, the viewDirection is (0,0,1), so when dot(vertexNormal, -viewDirection) <= 0 the vertex is culled\n            if (-faceVertices[0].normal.z <= 0 && -faceVertices[1].normal.z <= 0 && -faceVertices[2].normal.z <= 0) {\n                continue;\n            }\n        }\n        // Clip\n        faceVertices = clip(faceVertices, xpAxis);\n        if (!faceVertices)\n            continue;\n        faceVertices = clip(faceVertices, xnAxis);\n        if (!faceVertices)\n            continue;\n        faceVertices = clip(faceVertices, ypAxis);\n        if (!faceVertices)\n            continue;\n        faceVertices = clip(faceVertices, ynAxis);\n        if (!faceVertices)\n            continue;\n        faceVertices = clip(faceVertices, zpAxis);\n        if (!faceVertices)\n            continue;\n        faceVertices = clip(faceVertices, znAxis);\n        if (!faceVertices)\n            continue;\n        // Add UVs and get back to world\n        for (let vIndex = 0; vIndex < faceVertices.length; vIndex++) {\n            const vertex = faceVertices[vIndex];\n            //TODO check for Int32Array | Uint32Array | Uint16Array\n            vertexData.indices.push(currentVertexDataIndex);\n            if (useLocalComputation) {\n                if (vertex.localPositionOverride) {\n                    vertexData.positions[currentVertexDataIndex * 3] = vertex.localPositionOverride[0];\n                    vertexData.positions[currentVertexDataIndex * 3 + 1] = vertex.localPositionOverride[1];\n                    vertexData.positions[currentVertexDataIndex * 3 + 2] = vertex.localPositionOverride[2];\n                }\n                else if (localPositions) {\n                    vertexData.positions[currentVertexDataIndex * 3] = localPositions[vertex.vertexIdx];\n                    vertexData.positions[currentVertexDataIndex * 3 + 1] = localPositions[vertex.vertexIdx + 1];\n                    vertexData.positions[currentVertexDataIndex * 3 + 2] = localPositions[vertex.vertexIdx + 2];\n                }\n                if (vertex.localNormalOverride) {\n                    vertexData.normals[currentVertexDataIndex * 3] = vertex.localNormalOverride[0];\n                    vertexData.normals[currentVertexDataIndex * 3 + 1] = vertex.localNormalOverride[1];\n                    vertexData.normals[currentVertexDataIndex * 3 + 2] = vertex.localNormalOverride[2];\n                }\n                else if (localNormals) {\n                    vertexData.normals[currentVertexDataIndex * 3] = localNormals[vertex.vertexIdx];\n                    vertexData.normals[currentVertexDataIndex * 3 + 1] = localNormals[vertex.vertexIdx + 1];\n                    vertexData.normals[currentVertexDataIndex * 3 + 2] = localNormals[vertex.vertexIdx + 2];\n                }\n            }\n            else {\n                vertex.position.toArray(vertexData.positions, currentVertexDataIndex * 3);\n                vertex.normal.toArray(vertexData.normals, currentVertexDataIndex * 3);\n            }\n            if (vertexData.matricesIndices && vertexData.matricesWeights) {\n                if (vertex.matrixIndicesOverride) {\n                    vertexData.matricesIndices[currentVertexDataIndex * 4] = vertex.matrixIndicesOverride[0];\n                    vertexData.matricesIndices[currentVertexDataIndex * 4 + 1] = vertex.matrixIndicesOverride[1];\n                    vertexData.matricesIndices[currentVertexDataIndex * 4 + 2] = vertex.matrixIndicesOverride[2];\n                    vertexData.matricesIndices[currentVertexDataIndex * 4 + 3] = vertex.matrixIndicesOverride[3];\n                }\n                else {\n                    if (matIndices) {\n                        vertexData.matricesIndices[currentVertexDataIndex * 4] = matIndices[vertex.vertexIdxForBones];\n                        vertexData.matricesIndices[currentVertexDataIndex * 4 + 1] = matIndices[vertex.vertexIdxForBones + 1];\n                        vertexData.matricesIndices[currentVertexDataIndex * 4 + 2] = matIndices[vertex.vertexIdxForBones + 2];\n                        vertexData.matricesIndices[currentVertexDataIndex * 4 + 3] = matIndices[vertex.vertexIdxForBones + 3];\n                    }\n                    if (matIndicesExtra && vertexData.matricesIndicesExtra) {\n                        vertexData.matricesIndicesExtra[currentVertexDataIndex * 4] = matIndicesExtra[vertex.vertexIdxForBones];\n                        vertexData.matricesIndicesExtra[currentVertexDataIndex * 4 + 1] = matIndicesExtra[vertex.vertexIdxForBones + 1];\n                        vertexData.matricesIndicesExtra[currentVertexDataIndex * 4 + 2] = matIndicesExtra[vertex.vertexIdxForBones + 2];\n                        vertexData.matricesIndicesExtra[currentVertexDataIndex * 4 + 3] = matIndicesExtra[vertex.vertexIdxForBones + 3];\n                    }\n                }\n                if (vertex.matrixWeightsOverride) {\n                    vertexData.matricesWeights[currentVertexDataIndex * 4] = vertex.matrixWeightsOverride[0];\n                    vertexData.matricesWeights[currentVertexDataIndex * 4 + 1] = vertex.matrixWeightsOverride[1];\n                    vertexData.matricesWeights[currentVertexDataIndex * 4 + 2] = vertex.matrixWeightsOverride[2];\n                    vertexData.matricesWeights[currentVertexDataIndex * 4 + 3] = vertex.matrixWeightsOverride[3];\n                }\n                else {\n                    if (matWeights) {\n                        vertexData.matricesWeights[currentVertexDataIndex * 4] = matWeights[vertex.vertexIdxForBones];\n                        vertexData.matricesWeights[currentVertexDataIndex * 4 + 1] = matWeights[vertex.vertexIdxForBones + 1];\n                        vertexData.matricesWeights[currentVertexDataIndex * 4 + 2] = matWeights[vertex.vertexIdxForBones + 2];\n                        vertexData.matricesWeights[currentVertexDataIndex * 4 + 3] = matWeights[vertex.vertexIdxForBones + 3];\n                    }\n                    if (matWeightsExtra && vertexData.matricesWeightsExtra) {\n                        vertexData.matricesWeightsExtra[currentVertexDataIndex * 4] = matWeightsExtra[vertex.vertexIdxForBones];\n                        vertexData.matricesWeightsExtra[currentVertexDataIndex * 4 + 1] = matWeightsExtra[vertex.vertexIdxForBones + 1];\n                        vertexData.matricesWeightsExtra[currentVertexDataIndex * 4 + 2] = matWeightsExtra[vertex.vertexIdxForBones + 2];\n                        vertexData.matricesWeightsExtra[currentVertexDataIndex * 4 + 3] = matWeightsExtra[vertex.vertexIdxForBones + 3];\n                    }\n                }\n            }\n            if (!options.captureUVS) {\n                vertexData.uvs.push(0.5 + vertex.position.x / size.x);\n                const v = 0.5 + vertex.position.y / size.y;\n                vertexData.uvs.push(CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v : v);\n            }\n            else {\n                vertex.uv.toArray(vertexData.uvs, currentVertexDataIndex * 2);\n            }\n            currentVertexDataIndex++;\n        }\n    }\n    // Return mesh\n    const decal = new Mesh(name, sourceMesh.getScene());\n    vertexData.applyToMesh(decal);\n    if (useLocalComputation) {\n        decal.skeleton = sourceMesh.skeleton;\n        decal.parent = sourceMesh;\n    }\n    else {\n        decal.position = position.clone();\n        decal.rotation = new Vector3(pitch, yaw, angle);\n    }\n    decal.computeWorldMatrix(true);\n    decal.refreshBoundingInfo(true, true);\n    return decal;\n}\n/**\n * Class containing static functions to help procedurally build meshes\n * @deprecated use the function directly from the module\n */\nexport const DecalBuilder = {\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    CreateDecal,\n};\nMesh.CreateDecal = (name, sourceMesh, position, normal, size, angle) => {\n    const options = {\n        position,\n        normal,\n        size,\n        angle,\n    };\n    return CreateDecal(name, sourceMesh, options);\n};\n//# sourceMappingURL=decalBuilder.js.map","import { Mesh } from \"../mesh.js\";\nimport { VertexData } from \"../mesh.vertexData.js\";\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions.js\";\n/**\n * Creates the VertexData of the Disc or regular Polygon\n * @param options an object used to set the following optional parameters for the disc, required but can be empty\n * * radius the radius of the disc, optional default 0.5\n * * tessellation the number of polygon sides, optional, default 64\n * * arc a number from 0 to 1, to create an unclosed polygon based on the fraction of the circumference given by the arc value, optional, default 1\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\n * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\n * @param options.radius\n * @param options.tessellation\n * @param options.arc\n * @param options.sideOrientation\n * @param options.frontUVs\n * @param options.backUVs\n * @returns the VertexData of the box\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport function CreateDiscVertexData(options) {\n    const positions = new Array();\n    const indices = new Array();\n    const normals = new Array();\n    const uvs = new Array();\n    const radius = options.radius || 0.5;\n    const tessellation = options.tessellation || 64;\n    const arc = options.arc && (options.arc <= 0 || options.arc > 1) ? 1.0 : options.arc || 1.0;\n    const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\n    // positions and uvs\n    positions.push(0, 0, 0); // disc center first\n    uvs.push(0.5, 0.5);\n    const theta = Math.PI * 2 * arc;\n    const step = arc === 1 ? theta / tessellation : theta / (tessellation - 1);\n    let a = 0;\n    for (let t = 0; t < tessellation; t++) {\n        const x = Math.cos(a);\n        const y = Math.sin(a);\n        const u = (x + 1) / 2;\n        const v = (1 - y) / 2;\n        positions.push(radius * x, radius * y, 0);\n        uvs.push(u, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v : v);\n        a += step;\n    }\n    if (arc === 1) {\n        positions.push(positions[3], positions[4], positions[5]); // close the circle\n        uvs.push(uvs[2], CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - uvs[3] : uvs[3]);\n    }\n    //indices\n    const vertexNb = positions.length / 3;\n    for (let i = 1; i < vertexNb - 1; i++) {\n        indices.push(i + 1, 0, i);\n    }\n    // result\n    VertexData.ComputeNormals(positions, indices, normals);\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\n    const vertexData = new VertexData();\n    vertexData.indices = indices;\n    vertexData.positions = positions;\n    vertexData.normals = normals;\n    vertexData.uvs = uvs;\n    return vertexData;\n}\n/**\n * Creates a plane polygonal mesh.  By default, this is a disc\n * * The parameter `radius` sets the radius size (float) of the polygon (default 0.5)\n * * The parameter `tessellation` sets the number of polygon sides (positive integer, default 64). So a tessellation valued to 3 will build a triangle, to 4 a square, etc\n * * You can create an unclosed polygon with the parameter `arc` (positive float, default 1), valued between 0 and 1, what is the ratio of the circumference : 2 x PI x ratio\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#side-orientation\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\n * @param name defines the name of the mesh\n * @param options defines the options used to create the mesh\n * @param options.radius\n * @param options.tessellation\n * @param options.arc\n * @param options.updatable\n * @param options.sideOrientation\n * @param options.frontUVs\n * @param options.backUVs\n * @param scene defines the hosting scene\n * @returns the plane polygonal mesh\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#disc-or-regular-polygon\n */\nexport function CreateDisc(name, options = {}, scene = null) {\n    const disc = new Mesh(name, scene);\n    options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\n    disc._originalBuilderSideOrientation = options.sideOrientation;\n    const vertexData = CreateDiscVertexData(options);\n    vertexData.applyToMesh(disc, options.updatable);\n    return disc;\n}\n/**\n * Class containing static functions to help procedurally build meshes\n * @deprecated please use CreateDisc directly\n */\nexport const DiscBuilder = {\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    CreateDisc,\n};\nVertexData.CreateDisc = CreateDiscVertexData;\nMesh.CreateDisc = (name, radius, tessellation, scene = null, updatable, sideOrientation) => {\n    const options = {\n        radius,\n        tessellation,\n        sideOrientation,\n        updatable,\n    };\n    return CreateDisc(name, options, scene);\n};\n//# sourceMappingURL=discBuilder.js.map","import { CreatePolyhedron } from \"./polyhedronBuilder.js\";\nimport { Logger } from \"../../Misc/logger.js\";\nimport { _PrimaryIsoTriangle, GeodesicData } from \"../geodesicMesh.js\";\n/**\n * Creates the Mesh for a Geodesic Polyhedron\n * @see https://en.wikipedia.org/wiki/Geodesic_polyhedron\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/polyhedra/geodesic_poly\n * @param name defines the name of the mesh\n * @param options an object used to set the following optional parameters for the polyhedron, required but can be empty\n * * m number of horizontal steps along an isogrid\n * * n number of angled steps along an isogrid\n * * size the size of the Geodesic, optional default 1\n * * sizeX allows stretching in the x direction, optional, default size\n * * sizeY allows stretching in the y direction, optional, default size\n * * sizeZ allows stretching in the z direction, optional, default size\n * * faceUV an array of Vector4 elements used to set different images to the top, rings and bottom respectively\n * * faceColors an array of Color3 elements used to set different colors to the top, rings and bottom respectively\n * * flat when true creates a flat shaded mesh, optional, default true\n * * subdivisions increasing the subdivisions increases the number of faces, optional, default 4\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\n * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\n * @param options.n\n * @param options.size\n * @param options.sizeX\n * @param options.sizeY\n * @param options.sizeZ\n * @param options.faceUV\n * @param options.faceColors\n * @param options.flat\n * @param options.updatable\n * @param options.sideOrientation\n * @param options.frontUVs\n * @param options.backUVs\n * @param options.m\n * @param scene defines the hosting scene\n * @returns Geodesic mesh\n */\nexport function CreateGeodesic(name, options, scene = null) {\n    let m = options.m || 1;\n    if (m !== Math.floor(m)) {\n        m === Math.floor(m);\n        Logger.Warn(\"m not an integer only floor(m) used\");\n    }\n    let n = options.n || 0;\n    if (n !== Math.floor(n)) {\n        n === Math.floor(n);\n        Logger.Warn(\"n not an integer only floor(n) used\");\n    }\n    if (n > m) {\n        const temp = n;\n        n = m;\n        m = temp;\n        Logger.Warn(\"n > m therefore m and n swapped\");\n    }\n    const primTri = new _PrimaryIsoTriangle();\n    primTri.build(m, n);\n    const geodesicData = GeodesicData.BuildGeodesicData(primTri);\n    const geoOptions = {\n        custom: geodesicData,\n        size: options.size,\n        sizeX: options.sizeX,\n        sizeY: options.sizeY,\n        sizeZ: options.sizeZ,\n        faceUV: options.faceUV,\n        faceColors: options.faceColors,\n        flat: options.flat,\n        updatable: options.updatable,\n        sideOrientation: options.sideOrientation,\n        frontUVs: options.frontUVs,\n        backUVs: options.backUVs,\n    };\n    const geodesic = CreatePolyhedron(name, geoOptions, scene);\n    return geodesic;\n}\n//# sourceMappingURL=geodesicBuilder.js.map","import { Vector3 } from \"../../Maths/math.vector.js\";\nimport { Color4 } from \"../../Maths/math.color.js\";\nimport { Mesh } from \"../../Meshes/mesh.js\";\nimport { VertexData } from \"../mesh.vertexData.js\";\nimport { Logger } from \"../../Misc/logger.js\";\nimport { _PrimaryIsoTriangle, GeodesicData } from \"../geodesicMesh.js\";\nimport { GoldbergMesh } from \"../goldbergMesh.js\";\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions.js\";\n/**\n * Creates the Mesh for a Goldberg Polyhedron\n * @param options an object used to set the following optional parameters for the polyhedron, required but can be empty\n * @param goldbergData polyhedronData defining the Goldberg polyhedron\n * @returns GoldbergSphere mesh\n */\nexport function CreateGoldbergVertexData(options, goldbergData) {\n    const size = options.size;\n    const sizeX = options.sizeX || size || 1;\n    const sizeY = options.sizeY || size || 1;\n    const sizeZ = options.sizeZ || size || 1;\n    const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\n    const positions = new Array();\n    const indices = new Array();\n    const normals = new Array();\n    const uvs = new Array();\n    let minX = Infinity;\n    let maxX = -Infinity;\n    let minY = Infinity;\n    let maxY = -Infinity;\n    for (let v = 0; v < goldbergData.vertex.length; v++) {\n        minX = Math.min(minX, goldbergData.vertex[v][0] * sizeX);\n        maxX = Math.max(maxX, goldbergData.vertex[v][0] * sizeX);\n        minY = Math.min(minY, goldbergData.vertex[v][1] * sizeY);\n        maxY = Math.max(maxY, goldbergData.vertex[v][1] * sizeY);\n    }\n    let index = 0;\n    for (let f = 0; f < goldbergData.face.length; f++) {\n        const verts = goldbergData.face[f];\n        const a = Vector3.FromArray(goldbergData.vertex[verts[0]]);\n        const b = Vector3.FromArray(goldbergData.vertex[verts[2]]);\n        const c = Vector3.FromArray(goldbergData.vertex[verts[1]]);\n        const ba = b.subtract(a);\n        const ca = c.subtract(a);\n        const norm = Vector3.Cross(ca, ba).normalize();\n        for (let v = 0; v < verts.length; v++) {\n            normals.push(norm.x, norm.y, norm.z);\n            const pdata = goldbergData.vertex[verts[v]];\n            positions.push(pdata[0] * sizeX, pdata[1] * sizeY, pdata[2] * sizeZ);\n            const vCoord = (pdata[1] * sizeY - minY) / (maxY - minY);\n            uvs.push((pdata[0] * sizeX - minX) / (maxX - minX), CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - vCoord : vCoord);\n        }\n        for (let v = 0; v < verts.length - 2; v++) {\n            indices.push(index, index + v + 2, index + v + 1);\n        }\n        index += verts.length;\n    }\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs);\n    const vertexData = new VertexData();\n    vertexData.positions = positions;\n    vertexData.indices = indices;\n    vertexData.normals = normals;\n    vertexData.uvs = uvs;\n    return vertexData;\n}\n/**\n * Creates the Mesh for a Goldberg Polyhedron which is made from 12 pentagonal and the rest hexagonal faces\n * @see https://en.wikipedia.org/wiki/Goldberg_polyhedron\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/polyhedra/goldberg_poly\n * @param name defines the name of the mesh\n * @param options an object used to set the following optional parameters for the polyhedron, required but can be empty\n * @param scene defines the hosting scene\n * @returns Goldberg mesh\n */\nexport function CreateGoldberg(name, options, scene = null) {\n    const size = options.size;\n    const sizeX = options.sizeX || size || 1;\n    const sizeY = options.sizeY || size || 1;\n    const sizeZ = options.sizeZ || size || 1;\n    let m = options.m || 1;\n    if (m !== Math.floor(m)) {\n        m === Math.floor(m);\n        Logger.Warn(\"m not an integer only floor(m) used\");\n    }\n    let n = options.n || 0;\n    if (n !== Math.floor(n)) {\n        n === Math.floor(n);\n        Logger.Warn(\"n not an integer only floor(n) used\");\n    }\n    if (n > m) {\n        const temp = n;\n        n = m;\n        m = temp;\n        Logger.Warn(\"n > m therefore m and n swapped\");\n    }\n    const primTri = new _PrimaryIsoTriangle();\n    primTri.build(m, n);\n    const geodesicData = GeodesicData.BuildGeodesicData(primTri);\n    const goldbergData = geodesicData.toGoldbergPolyhedronData();\n    const goldberg = new GoldbergMesh(name, scene);\n    options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\n    goldberg._originalBuilderSideOrientation = options.sideOrientation;\n    const vertexData = CreateGoldbergVertexData(options, goldbergData);\n    vertexData.applyToMesh(goldberg, options.updatable);\n    goldberg.goldbergData.nbSharedFaces = geodesicData.sharedNodes;\n    goldberg.goldbergData.nbUnsharedFaces = geodesicData.poleNodes;\n    goldberg.goldbergData.adjacentFaces = geodesicData.adjacentFaces;\n    goldberg.goldbergData.nbFaces = goldberg.goldbergData.nbSharedFaces + goldberg.goldbergData.nbUnsharedFaces;\n    goldberg.goldbergData.nbFacesAtPole = (goldberg.goldbergData.nbUnsharedFaces - 12) / 12;\n    for (let f = 0; f < geodesicData.vertex.length; f++) {\n        goldberg.goldbergData.faceCenters.push(Vector3.FromArray(geodesicData.vertex[f]));\n        goldberg.goldbergData.faceCenters[f].x *= sizeX;\n        goldberg.goldbergData.faceCenters[f].y *= sizeY;\n        goldberg.goldbergData.faceCenters[f].z *= sizeZ;\n        goldberg.goldbergData.faceColors.push(new Color4(1, 1, 1, 1));\n    }\n    for (let f = 0; f < goldbergData.face.length; f++) {\n        const verts = goldbergData.face[f];\n        const a = Vector3.FromArray(goldbergData.vertex[verts[0]]);\n        const b = Vector3.FromArray(goldbergData.vertex[verts[2]]);\n        const c = Vector3.FromArray(goldbergData.vertex[verts[1]]);\n        const ba = b.subtract(a);\n        const ca = c.subtract(a);\n        const norm = Vector3.Cross(ca, ba).normalize();\n        const z = Vector3.Cross(ca, norm).normalize();\n        goldberg.goldbergData.faceXaxis.push(ca.normalize());\n        goldberg.goldbergData.faceYaxis.push(norm);\n        goldberg.goldbergData.faceZaxis.push(z);\n    }\n    return goldberg;\n}\nMesh.CreateGoldberg = CreateGoldberg;\n//# sourceMappingURL=goldbergBuilder.js.map","import { Vector3 } from \"../../Maths/math.vector.js\";\nimport { Color3 } from \"../../Maths/math.color.js\";\nimport { Mesh } from \"../mesh.js\";\nimport { VertexData } from \"../mesh.vertexData.js\";\nimport { GroundMesh } from \"../groundMesh.js\";\nimport { Tools } from \"../../Misc/tools.js\";\nimport { EngineStore } from \"../../Engines/engineStore.js\";\nimport { Epsilon } from \"../../Maths/math.constants.js\";\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions.js\";\n/**\n * Creates the VertexData for a Ground\n * @param options an object used to set the following optional parameters for the Ground, required but can be empty\n *  - width the width (x direction) of the ground, optional, default 1\n *  - height the height (z direction) of the ground, optional, default 1\n *  - subdivisions the number of subdivisions per side, optional, default 1\n * @param options.width\n * @param options.height\n * @param options.subdivisions\n * @param options.subdivisionsX\n * @param options.subdivisionsY\n * @returns the VertexData of the Ground\n */\nexport function CreateGroundVertexData(options) {\n    const indices = [];\n    const positions = [];\n    const normals = [];\n    const uvs = [];\n    let row, col;\n    const width = options.width || 1;\n    const height = options.height || 1;\n    const subdivisionsX = options.subdivisionsX || options.subdivisions || 1;\n    const subdivisionsY = options.subdivisionsY || options.subdivisions || 1;\n    for (row = 0; row <= subdivisionsY; row++) {\n        for (col = 0; col <= subdivisionsX; col++) {\n            const position = new Vector3((col * width) / subdivisionsX - width / 2.0, 0, ((subdivisionsY - row) * height) / subdivisionsY - height / 2.0);\n            const normal = new Vector3(0, 1.0, 0);\n            positions.push(position.x, position.y, position.z);\n            normals.push(normal.x, normal.y, normal.z);\n            uvs.push(col / subdivisionsX, CompatibilityOptions.UseOpenGLOrientationForUV ? row / subdivisionsY : 1.0 - row / subdivisionsY);\n        }\n    }\n    for (row = 0; row < subdivisionsY; row++) {\n        for (col = 0; col < subdivisionsX; col++) {\n            indices.push(col + 1 + (row + 1) * (subdivisionsX + 1));\n            indices.push(col + 1 + row * (subdivisionsX + 1));\n            indices.push(col + row * (subdivisionsX + 1));\n            indices.push(col + (row + 1) * (subdivisionsX + 1));\n            indices.push(col + 1 + (row + 1) * (subdivisionsX + 1));\n            indices.push(col + row * (subdivisionsX + 1));\n        }\n    }\n    // Result\n    const vertexData = new VertexData();\n    vertexData.indices = indices;\n    vertexData.positions = positions;\n    vertexData.normals = normals;\n    vertexData.uvs = uvs;\n    return vertexData;\n}\n/**\n * Creates the VertexData for a TiledGround by subdividing the ground into tiles\n * @param options an object used to set the following optional parameters for the Ground, required but can be empty\n * * xmin the ground minimum X coordinate, optional, default -1\n * * zmin the ground minimum Z coordinate, optional, default -1\n * * xmax the ground maximum X coordinate, optional, default 1\n * * zmax the ground maximum Z coordinate, optional, default 1\n * * subdivisions a javascript object {w: positive integer, h: positive integer}, `w` and `h` are the numbers of subdivisions on the ground width and height creating 'tiles', default {w: 6, h: 6}\n * * precision a javascript object {w: positive integer, h: positive integer}, `w` and `h` are the numbers of subdivisions on the tile width and height, default {w: 2, h: 2}\n * @param options.xmin\n * @param options.zmin\n * @param options.xmax\n * @param options.zmax\n * @param options.subdivisions\n * @param options.subdivisions.w\n * @param options.subdivisions.h\n * @param options.precision\n * @param options.precision.w\n * @param options.precision.h\n * @returns the VertexData of the TiledGround\n */\nexport function CreateTiledGroundVertexData(options) {\n    const xmin = options.xmin !== undefined && options.xmin !== null ? options.xmin : -1.0;\n    const zmin = options.zmin !== undefined && options.zmin !== null ? options.zmin : -1.0;\n    const xmax = options.xmax !== undefined && options.xmax !== null ? options.xmax : 1.0;\n    const zmax = options.zmax !== undefined && options.zmax !== null ? options.zmax : 1.0;\n    const subdivisions = options.subdivisions || { w: 1, h: 1 };\n    const precision = options.precision || { w: 1, h: 1 };\n    const indices = new Array();\n    const positions = new Array();\n    const normals = new Array();\n    const uvs = new Array();\n    let row, col, tileRow, tileCol;\n    subdivisions.h = subdivisions.h < 1 ? 1 : subdivisions.h;\n    subdivisions.w = subdivisions.w < 1 ? 1 : subdivisions.w;\n    precision.w = precision.w < 1 ? 1 : precision.w;\n    precision.h = precision.h < 1 ? 1 : precision.h;\n    const tileSize = {\n        w: (xmax - xmin) / subdivisions.w,\n        h: (zmax - zmin) / subdivisions.h,\n    };\n    function applyTile(xTileMin, zTileMin, xTileMax, zTileMax) {\n        // Indices\n        const base = positions.length / 3;\n        const rowLength = precision.w + 1;\n        for (row = 0; row < precision.h; row++) {\n            for (col = 0; col < precision.w; col++) {\n                const square = [base + col + row * rowLength, base + (col + 1) + row * rowLength, base + (col + 1) + (row + 1) * rowLength, base + col + (row + 1) * rowLength];\n                indices.push(square[1]);\n                indices.push(square[2]);\n                indices.push(square[3]);\n                indices.push(square[0]);\n                indices.push(square[1]);\n                indices.push(square[3]);\n            }\n        }\n        // Position, normals and uvs\n        const position = Vector3.Zero();\n        const normal = new Vector3(0, 1.0, 0);\n        for (row = 0; row <= precision.h; row++) {\n            position.z = (row * (zTileMax - zTileMin)) / precision.h + zTileMin;\n            for (col = 0; col <= precision.w; col++) {\n                position.x = (col * (xTileMax - xTileMin)) / precision.w + xTileMin;\n                position.y = 0;\n                positions.push(position.x, position.y, position.z);\n                normals.push(normal.x, normal.y, normal.z);\n                uvs.push(col / precision.w, row / precision.h);\n            }\n        }\n    }\n    for (tileRow = 0; tileRow < subdivisions.h; tileRow++) {\n        for (tileCol = 0; tileCol < subdivisions.w; tileCol++) {\n            applyTile(xmin + tileCol * tileSize.w, zmin + tileRow * tileSize.h, xmin + (tileCol + 1) * tileSize.w, zmin + (tileRow + 1) * tileSize.h);\n        }\n    }\n    // Result\n    const vertexData = new VertexData();\n    vertexData.indices = indices;\n    vertexData.positions = positions;\n    vertexData.normals = normals;\n    vertexData.uvs = uvs;\n    return vertexData;\n}\n/**\n * Creates the VertexData of the Ground designed from a heightmap\n * @param options an object used to set the following parameters for the Ground, required and provided by CreateGroundFromHeightMap\n * * width the width (x direction) of the ground\n * * height the height (z direction) of the ground\n * * subdivisions the number of subdivisions per side\n * * minHeight the minimum altitude on the ground, optional, default 0\n * * maxHeight the maximum altitude on the ground, optional default 1\n * * colorFilter the filter to apply to the image pixel colors to compute the height, optional Color3, default (0.3, 0.59, 0.11)\n * * buffer the array holding the image color data\n * * bufferWidth the width of image\n * * bufferHeight the height of image\n * * alphaFilter Remove any data where the alpha channel is below this value, defaults 0 (all data visible)\n * @param options.width\n * @param options.height\n * @param options.subdivisions\n * @param options.minHeight\n * @param options.maxHeight\n * @param options.colorFilter\n * @param options.buffer\n * @param options.bufferWidth\n * @param options.bufferHeight\n * @param options.alphaFilter\n * @returns the VertexData of the Ground designed from a heightmap\n */\nexport function CreateGroundFromHeightMapVertexData(options) {\n    const indices = [];\n    const positions = [];\n    const normals = [];\n    const uvs = [];\n    let row, col;\n    const filter = options.colorFilter || new Color3(0.3, 0.59, 0.11);\n    const alphaFilter = options.alphaFilter || 0.0;\n    let invert = false;\n    if (options.minHeight > options.maxHeight) {\n        invert = true;\n        const temp = options.maxHeight;\n        options.maxHeight = options.minHeight;\n        options.minHeight = temp;\n    }\n    // Vertices\n    for (row = 0; row <= options.subdivisions; row++) {\n        for (col = 0; col <= options.subdivisions; col++) {\n            const position = new Vector3((col * options.width) / options.subdivisions - options.width / 2.0, 0, ((options.subdivisions - row) * options.height) / options.subdivisions - options.height / 2.0);\n            // Compute height\n            const heightMapX = (((position.x + options.width / 2) / options.width) * (options.bufferWidth - 1)) | 0;\n            const heightMapY = ((1.0 - (position.z + options.height / 2) / options.height) * (options.bufferHeight - 1)) | 0;\n            const pos = (heightMapX + heightMapY * options.bufferWidth) * 4;\n            let r = options.buffer[pos] / 255.0;\n            let g = options.buffer[pos + 1] / 255.0;\n            let b = options.buffer[pos + 2] / 255.0;\n            const a = options.buffer[pos + 3] / 255.0;\n            if (invert) {\n                r = 1.0 - r;\n                g = 1.0 - g;\n                b = 1.0 - b;\n            }\n            const gradient = r * filter.r + g * filter.g + b * filter.b;\n            // If our alpha channel is not within our filter then we will assign a 'special' height\n            // Then when building the indices, we will ignore any vertex that is using the special height\n            if (a >= alphaFilter) {\n                position.y = options.minHeight + (options.maxHeight - options.minHeight) * gradient;\n            }\n            else {\n                position.y = options.minHeight - Epsilon; // We can't have a height below minHeight, normally.\n            }\n            // Add  vertex\n            positions.push(position.x, position.y, position.z);\n            normals.push(0, 0, 0);\n            uvs.push(col / options.subdivisions, 1.0 - row / options.subdivisions);\n        }\n    }\n    // Indices\n    for (row = 0; row < options.subdivisions; row++) {\n        for (col = 0; col < options.subdivisions; col++) {\n            // Calculate Indices\n            const idx1 = col + 1 + (row + 1) * (options.subdivisions + 1);\n            const idx2 = col + 1 + row * (options.subdivisions + 1);\n            const idx3 = col + row * (options.subdivisions + 1);\n            const idx4 = col + (row + 1) * (options.subdivisions + 1);\n            // Check that all indices are visible (based on our special height)\n            // Only display the vertex if all Indices are visible\n            // Positions are stored x,y,z for each vertex, hence the * 3 and + 1 for height\n            const isVisibleIdx1 = positions[idx1 * 3 + 1] >= options.minHeight;\n            const isVisibleIdx2 = positions[idx2 * 3 + 1] >= options.minHeight;\n            const isVisibleIdx3 = positions[idx3 * 3 + 1] >= options.minHeight;\n            if (isVisibleIdx1 && isVisibleIdx2 && isVisibleIdx3) {\n                indices.push(idx1);\n                indices.push(idx2);\n                indices.push(idx3);\n            }\n            const isVisibleIdx4 = positions[idx4 * 3 + 1] >= options.minHeight;\n            if (isVisibleIdx4 && isVisibleIdx1 && isVisibleIdx3) {\n                indices.push(idx4);\n                indices.push(idx1);\n                indices.push(idx3);\n            }\n        }\n    }\n    // Normals\n    VertexData.ComputeNormals(positions, indices, normals);\n    // Result\n    const vertexData = new VertexData();\n    vertexData.indices = indices;\n    vertexData.positions = positions;\n    vertexData.normals = normals;\n    vertexData.uvs = uvs;\n    return vertexData;\n}\n/**\n * Creates a ground mesh\n * * The parameters `width` and `height` (floats, default 1) set the width and height sizes of the ground\n * * The parameter `subdivisions` (positive integer) sets the number of subdivisions per side\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\n * @param name defines the name of the mesh\n * @param options defines the options used to create the mesh\n * @param options.width\n * @param options.height\n * @param options.subdivisions\n * @param options.subdivisionsX\n * @param options.subdivisionsY\n * @param options.updatable\n * @param scene defines the hosting scene\n * @returns the ground mesh\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#ground\n */\nexport function CreateGround(name, options = {}, scene) {\n    const ground = new GroundMesh(name, scene);\n    ground._setReady(false);\n    ground._subdivisionsX = options.subdivisionsX || options.subdivisions || 1;\n    ground._subdivisionsY = options.subdivisionsY || options.subdivisions || 1;\n    ground._width = options.width || 1;\n    ground._height = options.height || 1;\n    ground._maxX = ground._width / 2;\n    ground._maxZ = ground._height / 2;\n    ground._minX = -ground._maxX;\n    ground._minZ = -ground._maxZ;\n    const vertexData = CreateGroundVertexData(options);\n    vertexData.applyToMesh(ground, options.updatable);\n    ground._setReady(true);\n    return ground;\n}\n/**\n * Creates a tiled ground mesh\n * * The parameters `xmin` and `xmax` (floats, default -1 and 1) set the ground minimum and maximum X coordinates\n * * The parameters `zmin` and `zmax` (floats, default -1 and 1) set the ground minimum and maximum Z coordinates\n * * The parameter `subdivisions` is a javascript object `{w: positive integer, h: positive integer}` (default `{w: 6, h: 6}`). `w` and `h` are the numbers of subdivisions on the ground width and height. Each subdivision is called a tile\n * * The parameter `precision` is a javascript object `{w: positive integer, h: positive integer}` (default `{w: 2, h: 2}`). `w` and `h` are the numbers of subdivisions on the ground width and height of each tile\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\n * @param name defines the name of the mesh\n * @param options defines the options used to create the mesh\n * @param options.xmin\n * @param options.zmin\n * @param options.xmax\n * @param options.zmax\n * @param options.subdivisions\n * @param options.subdivisions.w\n * @param options.subdivisions.h\n * @param options.precision\n * @param options.precision.w\n * @param options.precision.h\n * @param options.updatable\n * @param scene defines the hosting scene\n * @returns the tiled ground mesh\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#tiled-ground\n */\nexport function CreateTiledGround(name, options, scene = null) {\n    const tiledGround = new Mesh(name, scene);\n    const vertexData = CreateTiledGroundVertexData(options);\n    vertexData.applyToMesh(tiledGround, options.updatable);\n    return tiledGround;\n}\n/**\n * Creates a ground mesh from a height map\n * * The parameter `url` sets the URL of the height map image resource.\n * * The parameters `width` and `height` (positive floats, default 10) set the ground width and height sizes.\n * * The parameter `subdivisions` (positive integer, default 1) sets the number of subdivision per side.\n * * The parameter `minHeight` (float, default 0) is the minimum altitude on the ground.\n * * The parameter `maxHeight` (float, default 1) is the maximum altitude on the ground.\n * * The parameter `colorFilter` (optional Color3, default (0.3, 0.59, 0.11) ) is the filter to apply to the image pixel colors to compute the height.\n * * The parameter `onReady` is a javascript callback function that will be called  once the mesh is just built (the height map download can last some time).\n * * The parameter `alphaFilter` will filter any data where the alpha channel is below this value, defaults 0 (all data visible)\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\n * @param name defines the name of the mesh\n * @param url defines the url to the height map\n * @param options defines the options used to create the mesh\n * @param options.width\n * @param options.height\n * @param options.subdivisions\n * @param options.minHeight\n * @param options.maxHeight\n * @param options.colorFilter\n * @param options.alphaFilter\n * @param options.updatable\n * @param options.onReady\n * @param scene defines the hosting scene\n * @returns the ground mesh\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set/height_map\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#ground-from-a-height-map\n */\nexport function CreateGroundFromHeightMap(name, url, options = {}, scene = null) {\n    const width = options.width || 10.0;\n    const height = options.height || 10.0;\n    const subdivisions = options.subdivisions || 1 | 0;\n    const minHeight = options.minHeight || 0.0;\n    const maxHeight = options.maxHeight || 1.0;\n    const filter = options.colorFilter || new Color3(0.3, 0.59, 0.11);\n    const alphaFilter = options.alphaFilter || 0.0;\n    const updatable = options.updatable;\n    const onReady = options.onReady;\n    scene = scene || EngineStore.LastCreatedScene;\n    const ground = new GroundMesh(name, scene);\n    ground._subdivisionsX = subdivisions;\n    ground._subdivisionsY = subdivisions;\n    ground._width = width;\n    ground._height = height;\n    ground._maxX = ground._width / 2.0;\n    ground._maxZ = ground._height / 2.0;\n    ground._minX = -ground._maxX;\n    ground._minZ = -ground._maxZ;\n    ground._setReady(false);\n    const onload = (img) => {\n        const bufferWidth = img.width;\n        const bufferHeight = img.height;\n        if (scene.isDisposed) {\n            return;\n        }\n        const buffer = scene === null || scene === void 0 ? void 0 : scene.getEngine().resizeImageBitmap(img, bufferWidth, bufferHeight);\n        const vertexData = CreateGroundFromHeightMapVertexData({\n            width: width,\n            height: height,\n            subdivisions: subdivisions,\n            minHeight: minHeight,\n            maxHeight: maxHeight,\n            colorFilter: filter,\n            buffer: buffer,\n            bufferWidth: bufferWidth,\n            bufferHeight: bufferHeight,\n            alphaFilter: alphaFilter,\n        });\n        vertexData.applyToMesh(ground, updatable);\n        //execute ready callback, if set\n        if (onReady) {\n            onReady(ground);\n        }\n        ground._setReady(true);\n    };\n    Tools.LoadImage(url, onload, () => { }, scene.offlineProvider);\n    return ground;\n}\n/**\n * Class containing static functions to help procedurally build meshes\n * @deprecated use the functions directly from the module\n */\nexport const GroundBuilder = {\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    CreateGround,\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    CreateGroundFromHeightMap,\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    CreateTiledGround,\n};\nVertexData.CreateGround = CreateGroundVertexData;\nVertexData.CreateTiledGround = CreateTiledGroundVertexData;\nVertexData.CreateGroundFromHeightMap = CreateGroundFromHeightMapVertexData;\nMesh.CreateGround = (name, width, height, subdivisions, scene, updatable) => {\n    const options = {\n        width,\n        height,\n        subdivisions,\n        updatable,\n    };\n    return CreateGround(name, options, scene);\n};\nMesh.CreateTiledGround = (name, xmin, zmin, xmax, zmax, subdivisions, precision, scene, updatable) => {\n    const options = {\n        xmin,\n        zmin,\n        xmax,\n        zmax,\n        subdivisions,\n        precision,\n        updatable,\n    };\n    return CreateTiledGround(name, options, scene);\n};\nMesh.CreateGroundFromHeightMap = (name, url, width, height, subdivisions, minHeight, maxHeight, scene, updatable, onReady, alphaFilter) => {\n    const options = {\n        width,\n        height,\n        subdivisions,\n        minHeight,\n        maxHeight,\n        updatable,\n        onReady,\n        alphaFilter,\n    };\n    return CreateGroundFromHeightMap(name, url, options, scene);\n};\n//# sourceMappingURL=groundBuilder.js.map","import { Mesh } from \"../mesh.js\";\nimport { CreateSphere } from \"../Builders/sphereBuilder.js\";\nimport { CreateDisc } from \"./discBuilder.js\";\n/**\n * Creates a hemisphere mesh\n * @param name defines the name of the mesh\n * @param options defines the options used to create the mesh\n * @param options.segments\n * @param options.diameter\n * @param options.sideOrientation\n * @param scene defines the hosting scene\n * @returns the hemisphere mesh\n */\nexport function CreateHemisphere(name, options = {}, scene) {\n    if (!options.diameter) {\n        options.diameter = 1;\n    }\n    if (!options.segments) {\n        options.segments = 16;\n    }\n    const halfSphere = CreateSphere(\"\", { slice: 0.5, diameter: options.diameter, segments: options.segments }, scene);\n    const disc = CreateDisc(\"\", { radius: options.diameter / 2, tessellation: options.segments * 3 + (4 - options.segments) }, scene);\n    disc.rotation.x = -Math.PI / 2;\n    disc.parent = halfSphere;\n    const merged = Mesh.MergeMeshes([disc, halfSphere], true);\n    merged.name = name;\n    return merged;\n}\n/**\n * Class containing static functions to help procedurally build meshes\n * @deprecated use the function directly from the module\n */\nexport const HemisphereBuilder = {\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    CreateHemisphere,\n};\n/**\n * Creates a hemispheric light\n * @param name\n * @param segments\n * @param diameter\n * @param scene\n */\nMesh.CreateHemisphere = (name, segments, diameter, scene) => {\n    const options = {\n        segments: segments,\n        diameter: diameter,\n    };\n    return CreateHemisphere(name, options, scene);\n};\n//# sourceMappingURL=hemisphereBuilder.js.map","import { Vector3, Vector2 } from \"../../Maths/math.vector.js\";\nimport { Mesh } from \"../mesh.js\";\nimport { VertexData } from \"../mesh.vertexData.js\";\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions.js\";\n/**\n * Creates the VertexData of the IcoSphere\n * @param options an object used to set the following optional parameters for the IcoSphere, required but can be empty\n * * radius the radius of the IcoSphere, optional default 1\n * * radiusX allows stretching in the x direction, optional, default radius\n * * radiusY allows stretching in the y direction, optional, default radius\n * * radiusZ allows stretching in the z direction, optional, default radius\n * * flat when true creates a flat shaded mesh, optional, default true\n * * subdivisions increasing the subdivisions increases the number of faces, optional, default 4\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\n * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\n * @param options.radius\n * @param options.radiusX\n * @param options.radiusY\n * @param options.radiusZ\n * @param options.flat\n * @param options.subdivisions\n * @param options.sideOrientation\n * @param options.frontUVs\n * @param options.backUVs\n * @returns the VertexData of the IcoSphere\n */\nexport function CreateIcoSphereVertexData(options) {\n    const sideOrientation = options.sideOrientation || VertexData.DEFAULTSIDE;\n    const radius = options.radius || 1;\n    const flat = options.flat === undefined ? true : options.flat;\n    const subdivisions = options.subdivisions || 4;\n    const radiusX = options.radiusX || radius;\n    const radiusY = options.radiusY || radius;\n    const radiusZ = options.radiusZ || radius;\n    const t = (1 + Math.sqrt(5)) / 2;\n    // 12 vertex x,y,z\n    const icoVertices = [\n        -1,\n        t,\n        -0,\n        1,\n        t,\n        0,\n        -1,\n        -t,\n        0,\n        1,\n        -t,\n        0,\n        0,\n        -1,\n        -t,\n        0,\n        1,\n        -t,\n        0,\n        -1,\n        t,\n        0,\n        1,\n        t,\n        t,\n        0,\n        1,\n        t,\n        0,\n        -1,\n        -t,\n        0,\n        1,\n        -t,\n        0,\n        -1, // v8-11\n    ];\n    // index of 3 vertex makes a face of icopshere\n    const ico_indices = [\n        0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 12, 22, 23, 1, 5, 20, 5, 11, 4, 23, 22, 13, 22, 18, 6, 7, 1, 8, 14, 21, 4, 14, 4, 2, 16, 13, 6, 15, 6, 19, 3, 8, 9, 4, 21, 5, 13, 17,\n        23, 6, 13, 22, 19, 6, 18, 9, 8, 1,\n    ];\n    // vertex for uv have aliased position, not for UV\n    const vertices_unalias_id = [\n        0,\n        1,\n        2,\n        3,\n        4,\n        5,\n        6,\n        7,\n        8,\n        9,\n        10,\n        11,\n        // vertex alias\n        0,\n        2,\n        3,\n        3,\n        3,\n        4,\n        7,\n        8,\n        9,\n        9,\n        10,\n        11, // 23: B + 12\n    ];\n    // uv as integer step (not pixels !)\n    const ico_vertexuv = [\n        5,\n        1,\n        3,\n        1,\n        6,\n        4,\n        0,\n        0,\n        5,\n        3,\n        4,\n        2,\n        2,\n        2,\n        4,\n        0,\n        2,\n        0,\n        1,\n        1,\n        6,\n        0,\n        6,\n        2,\n        // vertex alias (for same vertex on different faces)\n        0,\n        4,\n        3,\n        3,\n        4,\n        4,\n        3,\n        1,\n        4,\n        2,\n        4,\n        4,\n        0,\n        2,\n        1,\n        1,\n        2,\n        2,\n        3,\n        3,\n        1,\n        3,\n        2,\n        4, // 23: B + 12\n    ];\n    // Vertices[0, 1, ...9, A, B] : position on UV plane\n    // '+' indicate duplicate position to be fixed (3,9:0,2,3,4,7,8,A,B)\n    // First island of uv mapping\n    // v = 4h          3+  2\n    // v = 3h        9+  4\n    // v = 2h      9+  5   B\n    // v = 1h    9   1   0\n    // v = 0h  3   8   7   A\n    //     u = 0 1 2 3 4 5 6  *a\n    // Second island of uv mapping\n    // v = 4h  0+  B+  4+\n    // v = 3h    A+  2+\n    // v = 2h  7+  6   3+\n    // v = 1h    8+  3+\n    // v = 0h\n    //     u = 0 1 2 3 4 5 6  *a\n    // Face layout on texture UV mapping\n    // ============\n    // \\ 4  /\\ 16 /   ======\n    //  \\  /  \\  /   /\\ 11 /\n    //   \\/ 7  \\/   /  \\  /\n    //    =======  / 10 \\/\n    //   /\\ 17 /\\  =======\n    //  /  \\  /  \\ \\ 15 /\\\n    // / 8  \\/ 12 \\ \\  /  \\\n    // ============  \\/ 6  \\\n    // \\ 18 /\\  ============\n    //  \\  /  \\ \\ 5  /\\ 0  /\n    //   \\/ 13 \\ \\  /  \\  /\n    //   =======  \\/ 1  \\/\n    //       =============\n    //      /\\ 19 /\\  2 /\\\n    //     /  \\  /  \\  /  \\\n    //    / 14 \\/ 9  \\/  3 \\\n    //   ===================\n    // uv step is u:1 or 0.5, v:cos(30)=sqrt(3)/2, ratio approx is 84/97\n    const ustep = 138 / 1024;\n    const vstep = 239 / 1024;\n    const uoffset = 60 / 1024;\n    const voffset = 26 / 1024;\n    // Second island should have margin, not to touch the first island\n    // avoid any borderline artefact in pixel rounding\n    const island_u_offset = -40 / 1024;\n    const island_v_offset = +20 / 1024;\n    // face is either island 0 or 1 :\n    // second island is for faces : [4, 7, 8, 12, 13, 16, 17, 18]\n    const island = [\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        1,\n        1,\n        0,\n        0,\n        0,\n        1,\n        1,\n        0,\n        0,\n        1,\n        1,\n        1,\n        0, //  15 - 19\n    ];\n    const indices = new Array();\n    const positions = new Array();\n    const normals = new Array();\n    const uvs = new Array();\n    let current_indice = 0;\n    // prepare array of 3 vector (empty) (to be worked in place, shared for each face)\n    const face_vertex_pos = new Array(3);\n    const face_vertex_uv = new Array(3);\n    let v012;\n    for (v012 = 0; v012 < 3; v012++) {\n        face_vertex_pos[v012] = Vector3.Zero();\n        face_vertex_uv[v012] = Vector2.Zero();\n    }\n    // create all with normals\n    for (let face = 0; face < 20; face++) {\n        // 3 vertex per face\n        for (v012 = 0; v012 < 3; v012++) {\n            // look up vertex 0,1,2 to its index in 0 to 11 (or 23 including alias)\n            const v_id = ico_indices[3 * face + v012];\n            // vertex have 3D position (x,y,z)\n            face_vertex_pos[v012].copyFromFloats(icoVertices[3 * vertices_unalias_id[v_id]], icoVertices[3 * vertices_unalias_id[v_id] + 1], icoVertices[3 * vertices_unalias_id[v_id] + 2]);\n            // Normalize to get normal\n            face_vertex_pos[v012].normalize();\n            // uv Coordinates from vertex ID\n            face_vertex_uv[v012].copyFromFloats(ico_vertexuv[2 * v_id] * ustep + uoffset + island[face] * island_u_offset, ico_vertexuv[2 * v_id + 1] * vstep + voffset + island[face] * island_v_offset);\n        }\n        // Subdivide the face (interpolate pos, norm, uv)\n        // - pos is linear interpolation, then projected to sphere (converge polyhedron to sphere)\n        // - norm is linear interpolation of vertex corner normal\n        //   (to be checked if better to re-calc from face vertex, or if approximation is OK ??? )\n        // - uv is linear interpolation\n        //\n        // Topology is as below for sub-divide by 2\n        // vertex shown as v0,v1,v2\n        // interp index is i1 to progress in range [v0,v1[\n        // interp index is i2 to progress in range [v0,v2[\n        // face index as  (i1,i2)  for /\\  : (i1,i2),(i1+1,i2),(i1,i2+1)\n        //            and (i1,i2)' for \\/  : (i1+1,i2),(i1+1,i2+1),(i1,i2+1)\n        //\n        //\n        //                    i2    v2\n        //                    ^    ^\n        //                   /    / \\\n        //                  /    /   \\\n        //                 /    /     \\\n        //                /    / (0,1) \\\n        //               /    #---------\\\n        //              /    / \\ (0,0)'/ \\\n        //             /    /   \\     /   \\\n        //            /    /     \\   /     \\\n        //           /    / (0,0) \\ / (1,0) \\\n        //          /    #---------#---------\\\n        //              v0                    v1\n        //\n        //              --------------------> i1\n        //\n        // interp of (i1,i2):\n        //  along i2 :  x0=lerp(v0,v2, i2/S) <---> x1=lerp(v1,v2, i2/S)\n        //  along i1 :  lerp(x0,x1, i1/(S-i2))\n        //\n        // centroid of triangle is needed to get help normal computation\n        //  (c1,c2) are used for centroid location\n        const interp_vertex = (i1, i2, c1, c2) => {\n            // vertex is interpolated from\n            //   - face_vertex_pos[0..2]\n            //   - face_vertex_uv[0..2]\n            const pos_x0 = Vector3.Lerp(face_vertex_pos[0], face_vertex_pos[2], i2 / subdivisions);\n            const pos_x1 = Vector3.Lerp(face_vertex_pos[1], face_vertex_pos[2], i2 / subdivisions);\n            const pos_interp = subdivisions === i2 ? face_vertex_pos[2] : Vector3.Lerp(pos_x0, pos_x1, i1 / (subdivisions - i2));\n            pos_interp.normalize();\n            let vertex_normal;\n            if (flat) {\n                // in flat mode, recalculate normal as face centroid normal\n                const centroid_x0 = Vector3.Lerp(face_vertex_pos[0], face_vertex_pos[2], c2 / subdivisions);\n                const centroid_x1 = Vector3.Lerp(face_vertex_pos[1], face_vertex_pos[2], c2 / subdivisions);\n                vertex_normal = Vector3.Lerp(centroid_x0, centroid_x1, c1 / (subdivisions - c2));\n            }\n            else {\n                // in smooth mode, recalculate normal from each single vertex position\n                vertex_normal = new Vector3(pos_interp.x, pos_interp.y, pos_interp.z);\n            }\n            // Vertex normal need correction due to X,Y,Z radius scaling\n            vertex_normal.x /= radiusX;\n            vertex_normal.y /= radiusY;\n            vertex_normal.z /= radiusZ;\n            vertex_normal.normalize();\n            const uv_x0 = Vector2.Lerp(face_vertex_uv[0], face_vertex_uv[2], i2 / subdivisions);\n            const uv_x1 = Vector2.Lerp(face_vertex_uv[1], face_vertex_uv[2], i2 / subdivisions);\n            const uv_interp = subdivisions === i2 ? face_vertex_uv[2] : Vector2.Lerp(uv_x0, uv_x1, i1 / (subdivisions - i2));\n            positions.push(pos_interp.x * radiusX, pos_interp.y * radiusY, pos_interp.z * radiusZ);\n            normals.push(vertex_normal.x, vertex_normal.y, vertex_normal.z);\n            uvs.push(uv_interp.x, CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 - uv_interp.y : uv_interp.y);\n            // push each vertex has member of a face\n            // Same vertex can belong to multiple face, it is pushed multiple time (duplicate vertex are present)\n            indices.push(current_indice);\n            current_indice++;\n        };\n        for (let i2 = 0; i2 < subdivisions; i2++) {\n            for (let i1 = 0; i1 + i2 < subdivisions; i1++) {\n                // face : (i1,i2)  for /\\  :\n                // interp for : (i1,i2),(i1+1,i2),(i1,i2+1)\n                interp_vertex(i1, i2, i1 + 1.0 / 3, i2 + 1.0 / 3);\n                interp_vertex(i1 + 1, i2, i1 + 1.0 / 3, i2 + 1.0 / 3);\n                interp_vertex(i1, i2 + 1, i1 + 1.0 / 3, i2 + 1.0 / 3);\n                if (i1 + i2 + 1 < subdivisions) {\n                    // face : (i1,i2)' for \\/  :\n                    // interp for (i1+1,i2),(i1+1,i2+1),(i1,i2+1)\n                    interp_vertex(i1 + 1, i2, i1 + 2.0 / 3, i2 + 2.0 / 3);\n                    interp_vertex(i1 + 1, i2 + 1, i1 + 2.0 / 3, i2 + 2.0 / 3);\n                    interp_vertex(i1, i2 + 1, i1 + 2.0 / 3, i2 + 2.0 / 3);\n                }\n            }\n        }\n    }\n    // Sides\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\n    // Result\n    const vertexData = new VertexData();\n    vertexData.indices = indices;\n    vertexData.positions = positions;\n    vertexData.normals = normals;\n    vertexData.uvs = uvs;\n    return vertexData;\n}\n/**\n * Creates a sphere based upon an icosahedron with 20 triangular faces which can be subdivided\n * * The parameter `radius` sets the radius size (float) of the icosphere (default 1)\n * * You can set some different icosphere dimensions, for instance to build an ellipsoid, by using the parameters `radiusX`, `radiusY` and `radiusZ` (all by default have the same value of `radius`)\n * * The parameter `subdivisions` sets the number of subdivisions (positive integer, default 4). The more subdivisions, the more faces on the icosphere whatever its size\n * * The parameter `flat` (boolean, default true) gives each side its own normals. Set it to false to get a smooth continuous light reflection on the surface\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#side-orientation\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\n * @param name defines the name of the mesh\n * @param options defines the options used to create the mesh\n * @param options.radius\n * @param options.radiusX\n * @param options.radiusY\n * @param options.radiusZ\n * @param options.flat\n * @param options.subdivisions\n * @param options.sideOrientation\n * @param options.frontUVs\n * @param options.backUVs\n * @param options.updatable\n * @param scene defines the hosting scene\n * @returns the icosahedron mesh\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/polyhedra#icosphere\n */\nexport function CreateIcoSphere(name, options = {}, scene = null) {\n    const sphere = new Mesh(name, scene);\n    options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\n    sphere._originalBuilderSideOrientation = options.sideOrientation;\n    const vertexData = CreateIcoSphereVertexData(options);\n    vertexData.applyToMesh(sphere, options.updatable);\n    return sphere;\n}\n/**\n * Class containing static functions to help procedurally build meshes\n * @deprecated use the function directly from the module\n */\nexport const IcoSphereBuilder = {\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    CreateIcoSphere,\n};\nVertexData.CreateIcoSphere = CreateIcoSphereVertexData;\nMesh.CreateIcoSphere = (name, options, scene) => {\n    return CreateIcoSphere(name, options, scene);\n};\n//# sourceMappingURL=icoSphereBuilder.js.map","import { Vector3 } from \"../../Maths/math.vector.js\";\nimport { Mesh } from \"../mesh.js\";\nimport { CreateRibbon } from \"./ribbonBuilder.js\";\n/**\n * Creates lathe mesh.\n * The lathe is a shape with a symmetry axis : a 2D model shape is rotated around this axis to design the lathe\n * * The parameter `shape` is a required array of successive Vector3. This array depicts the shape to be rotated in its local space : the shape must be designed in the xOy plane and will be rotated around the Y axis. It's usually a 2D shape, so the Vector3 z coordinates are often set to zero\n * * The parameter `radius` (positive float, default 1) is the radius value of the lathe\n * * The parameter `tessellation` (positive integer, default 64) is the side number of the lathe\n * * The parameter `clip` (positive integer, default 0) is the number of sides to not create without effecting the general shape of the sides\n * * The parameter `arc` (positive float, default 1) is the ratio of the lathe. 0.5 builds for instance half a lathe, so an opened shape\n * * The parameter `closed` (boolean, default true) opens/closes the lathe circumference. This should be set to false when used with the parameter \"arc\"\n * * The parameter `cap` sets the way the extruded shape is capped. Possible values : BABYLON.Mesh.NO_CAP (default), BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#side-orientation\n * * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\n * @param name defines the name of the mesh\n * @param options defines the options used to create the mesh\n * @param options.shape\n * @param options.radius\n * @param options.tessellation\n * @param options.clip\n * @param options.arc\n * @param options.closed\n * @param options.updatable\n * @param options.sideOrientation\n * @param options.frontUVs\n * @param options.backUVs\n * @param options.cap\n * @param options.invertUV\n * @param scene defines the hosting scene\n * @returns the lathe mesh\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param#lathe\n */\nexport function CreateLathe(name, options, scene = null) {\n    const arc = options.arc ? (options.arc <= 0 || options.arc > 1 ? 1.0 : options.arc) : 1.0;\n    const closed = options.closed === undefined ? true : options.closed;\n    const shape = options.shape;\n    const radius = options.radius || 1;\n    const tessellation = options.tessellation || 64;\n    const clip = options.clip || 0;\n    const updatable = options.updatable;\n    const sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\n    const cap = options.cap || Mesh.NO_CAP;\n    const pi2 = Math.PI * 2;\n    const paths = new Array();\n    const invertUV = options.invertUV || false;\n    let i = 0;\n    let p = 0;\n    const step = (pi2 / tessellation) * arc;\n    let rotated;\n    let path;\n    for (i = 0; i <= tessellation - clip; i++) {\n        path = [];\n        if (cap == Mesh.CAP_START || cap == Mesh.CAP_ALL) {\n            path.push(new Vector3(0, shape[0].y, 0));\n            path.push(new Vector3(Math.cos(i * step) * shape[0].x * radius, shape[0].y, Math.sin(i * step) * shape[0].x * radius));\n        }\n        for (p = 0; p < shape.length; p++) {\n            rotated = new Vector3(Math.cos(i * step) * shape[p].x * radius, shape[p].y, Math.sin(i * step) * shape[p].x * radius);\n            path.push(rotated);\n        }\n        if (cap == Mesh.CAP_END || cap == Mesh.CAP_ALL) {\n            path.push(new Vector3(Math.cos(i * step) * shape[shape.length - 1].x * radius, shape[shape.length - 1].y, Math.sin(i * step) * shape[shape.length - 1].x * radius));\n            path.push(new Vector3(0, shape[shape.length - 1].y, 0));\n        }\n        paths.push(path);\n    }\n    // lathe ribbon\n    const lathe = CreateRibbon(name, { pathArray: paths, closeArray: closed, sideOrientation: sideOrientation, updatable: updatable, invertUV: invertUV, frontUVs: options.frontUVs, backUVs: options.backUVs }, scene);\n    return lathe;\n}\n/**\n * Class containing static functions to help procedurally build meshes\n * @deprecated use the function direction from the module\n */\nexport const LatheBuilder = {\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    CreateLathe,\n};\nMesh.CreateLathe = (name, shape, radius, tessellation, scene, updatable, sideOrientation) => {\n    const options = {\n        shape: shape,\n        radius: radius,\n        tessellation: tessellation,\n        sideOrientation: sideOrientation,\n        updatable: updatable,\n    };\n    return CreateLathe(name, options, scene);\n};\n//# sourceMappingURL=latheBuilder.js.map","/* eslint-disable @typescript-eslint/naming-convention */\nimport { Vector3 } from \"../../Maths/math.vector.js\";\nimport { _CreationDataStorage, Mesh } from \"../mesh.js\";\nimport { VertexData } from \"../mesh.vertexData.js\";\nimport { LinesMesh } from \"../../Meshes/linesMesh.js\";\nimport { VertexBuffer } from \"../../Buffers/buffer.js\";\nimport { Logger } from \"../../Misc/logger.js\";\n/**\n * Creates the VertexData of the LineSystem\n * @param options an object used to set the following optional parameters for the LineSystem, required but can be empty\n *  - lines an array of lines, each line being an array of successive Vector3\n *  - colors an array of line colors, each of the line colors being an array of successive Color4, one per line point\n * @param options.lines\n * @param options.colors\n * @returns the VertexData of the LineSystem\n */\nexport function CreateLineSystemVertexData(options) {\n    const indices = [];\n    const positions = [];\n    const lines = options.lines;\n    const colors = options.colors;\n    const vertexColors = [];\n    let idx = 0;\n    for (let l = 0; l < lines.length; l++) {\n        const points = lines[l];\n        for (let index = 0; index < points.length; index++) {\n            positions.push(points[index].x, points[index].y, points[index].z);\n            if (colors) {\n                const color = colors[l];\n                vertexColors.push(color[index].r, color[index].g, color[index].b, color[index].a);\n            }\n            if (index > 0) {\n                indices.push(idx - 1);\n                indices.push(idx);\n            }\n            idx++;\n        }\n    }\n    const vertexData = new VertexData();\n    vertexData.indices = indices;\n    vertexData.positions = positions;\n    if (colors) {\n        vertexData.colors = vertexColors;\n    }\n    return vertexData;\n}\n/**\n * Create the VertexData for a DashedLines\n * @param options an object used to set the following optional parameters for the DashedLines, required but can be empty\n *  - points an array successive Vector3\n *  - dashSize the size of the dashes relative to the dash number, optional, default 3\n *  - gapSize the size of the gap between two successive dashes relative to the dash number, optional, default 1\n *  - dashNb the intended total number of dashes, optional, default 200\n * @param options.points\n * @param options.dashSize\n * @param options.gapSize\n * @param options.dashNb\n * @returns the VertexData for the DashedLines\n */\nexport function CreateDashedLinesVertexData(options) {\n    const dashSize = options.dashSize || 3;\n    const gapSize = options.gapSize || 1;\n    const dashNb = options.dashNb || 200;\n    const points = options.points;\n    const positions = new Array();\n    const indices = new Array();\n    const curvect = Vector3.Zero();\n    let lg = 0;\n    let nb = 0;\n    let shft = 0;\n    let dashshft = 0;\n    let curshft = 0;\n    let idx = 0;\n    let i = 0;\n    for (i = 0; i < points.length - 1; i++) {\n        points[i + 1].subtractToRef(points[i], curvect);\n        lg += curvect.length();\n    }\n    shft = lg / dashNb;\n    dashshft = (dashSize * shft) / (dashSize + gapSize);\n    for (i = 0; i < points.length - 1; i++) {\n        points[i + 1].subtractToRef(points[i], curvect);\n        nb = Math.floor(curvect.length() / shft);\n        curvect.normalize();\n        for (let j = 0; j < nb; j++) {\n            curshft = shft * j;\n            positions.push(points[i].x + curshft * curvect.x, points[i].y + curshft * curvect.y, points[i].z + curshft * curvect.z);\n            positions.push(points[i].x + (curshft + dashshft) * curvect.x, points[i].y + (curshft + dashshft) * curvect.y, points[i].z + (curshft + dashshft) * curvect.z);\n            indices.push(idx, idx + 1);\n            idx += 2;\n        }\n    }\n    // Result\n    const vertexData = new VertexData();\n    vertexData.positions = positions;\n    vertexData.indices = indices;\n    return vertexData;\n}\n/**\n * Creates a line system mesh. A line system is a pool of many lines gathered in a single mesh\n * * A line system mesh is considered as a parametric shape since it has no predefined original shape. Its shape is determined by the passed array of lines as an input parameter\n * * Like every other parametric shape, it is dynamically updatable by passing an existing instance of LineSystem to this static function\n * * The parameter `lines` is an array of lines, each line being an array of successive Vector3\n * * The optional parameter `instance` is an instance of an existing LineSystem object to be updated with the passed `lines` parameter\n * * The optional parameter `colors` is an array of line colors, each line colors being an array of successive Color4, one per line point\n * * The optional parameter `useVertexAlpha` is to be set to `false` (default `true`) when you don't need the alpha blending (faster)\n * * The optional parameter `material` is the material to use to draw the lines if provided. If not, a default material will be created\n * * Updating a simple Line mesh, you just need to update every line in the `lines` array : https://doc.babylonjs.com/features/featuresDeepDive/mesh/dynamicMeshMorph#lines-and-dashedlines\n * * When updating an instance, remember that only line point positions can change, not the number of points, neither the number of lines\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param#line-system\n * @param name defines the name of the new line system\n * @param options defines the options used to create the line system\n * @param options.lines\n * @param options.updatable\n * @param options.instance\n * @param options.colors\n * @param options.useVertexAlpha\n * @param options.material\n * @param scene defines the hosting scene\n * @returns a new line system mesh\n */\nexport function CreateLineSystem(name, options, scene) {\n    const instance = options.instance;\n    const lines = options.lines;\n    const colors = options.colors;\n    if (instance) {\n        // lines update\n        const positions = instance.getVerticesData(VertexBuffer.PositionKind);\n        let vertexColor;\n        let lineColors;\n        if (colors) {\n            vertexColor = instance.getVerticesData(VertexBuffer.ColorKind);\n        }\n        let i = 0;\n        let c = 0;\n        for (let l = 0; l < lines.length; l++) {\n            const points = lines[l];\n            for (let p = 0; p < points.length; p++) {\n                positions[i] = points[p].x;\n                positions[i + 1] = points[p].y;\n                positions[i + 2] = points[p].z;\n                if (colors && vertexColor) {\n                    lineColors = colors[l];\n                    vertexColor[c] = lineColors[p].r;\n                    vertexColor[c + 1] = lineColors[p].g;\n                    vertexColor[c + 2] = lineColors[p].b;\n                    vertexColor[c + 3] = lineColors[p].a;\n                    c += 4;\n                }\n                i += 3;\n            }\n        }\n        instance.updateVerticesData(VertexBuffer.PositionKind, positions, false, false);\n        if (colors && vertexColor) {\n            instance.updateVerticesData(VertexBuffer.ColorKind, vertexColor, false, false);\n        }\n        return instance;\n    }\n    // line system creation\n    const useVertexColor = colors ? true : false;\n    const lineSystem = new LinesMesh(name, scene, null, undefined, undefined, useVertexColor, options.useVertexAlpha, options.material);\n    const vertexData = CreateLineSystemVertexData(options);\n    vertexData.applyToMesh(lineSystem, options.updatable);\n    return lineSystem;\n}\n/**\n * Creates a line mesh\n * A line mesh is considered as a parametric shape since it has no predefined original shape. Its shape is determined by the passed array of points as an input parameter\n * * Like every other parametric shape, it is dynamically updatable by passing an existing instance of LineMesh to this static function\n * * The parameter `points` is an array successive Vector3\n * * The optional parameter `instance` is an instance of an existing LineMesh object to be updated with the passed `points` parameter : https://doc.babylonjs.com/features/featuresDeepDive/mesh/dynamicMeshMorph#lines-and-dashedlines\n * * The optional parameter `colors` is an array of successive Color4, one per line point\n * * The optional parameter `useVertexAlpha` is to be set to `false` (default `true`) when you don't need alpha blending (faster)\n * * The optional parameter `material` is the material to use to draw the lines if provided. If not, a default material will be created\n * * When updating an instance, remember that only point positions can change, not the number of points\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param#lines\n * @param name defines the name of the new line system\n * @param options defines the options used to create the line system\n * @param options.points\n * @param options.updatable\n * @param options.instance\n * @param options.colors\n * @param options.useVertexAlpha\n * @param options.material\n * @param scene defines the hosting scene\n * @returns a new line mesh\n */\nexport function CreateLines(name, options, scene = null) {\n    const colors = options.colors ? [options.colors] : null;\n    const lines = CreateLineSystem(name, { lines: [options.points], updatable: options.updatable, instance: options.instance, colors: colors, useVertexAlpha: options.useVertexAlpha, material: options.material }, scene);\n    return lines;\n}\n/**\n * Creates a dashed line mesh\n * * A dashed line mesh is considered as a parametric shape since it has no predefined original shape. Its shape is determined by the passed array of points as an input parameter\n * * Like every other parametric shape, it is dynamically updatable by passing an existing instance of LineMesh to this static function\n * * The parameter `points` is an array successive Vector3\n * * The parameter `dashNb` is the intended total number of dashes (positive integer, default 200)\n * * The parameter `dashSize` is the size of the dashes relatively the dash number (positive float, default 3)\n * * The parameter `gapSize` is the size of the gap between two successive dashes relatively the dash number (positive float, default 1)\n * * The optional parameter `instance` is an instance of an existing LineMesh object to be updated with the passed `points` parameter : https://doc.babylonjs.com/features/featuresDeepDive/mesh/dynamicMeshMorph#lines-and-dashedlines\n * * The optional parameter `useVertexAlpha` is to be set to `false` (default `true`) when you don't need the alpha blending (faster)\n * * The optional parameter `material` is the material to use to draw the lines if provided. If not, a default material will be created\n * * When updating an instance, remember that only point positions can change, not the number of points\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\n * @param name defines the name of the mesh\n * @param options defines the options used to create the mesh\n * @param options.points\n * @param options.dashSize\n * @param options.gapSize\n * @param options.dashNb\n * @param options.updatable\n * @param options.instance\n * @param options.useVertexAlpha\n * @param options.material\n * @param scene defines the hosting scene\n * @returns the dashed line mesh\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param#dashed-lines\n */\nexport function CreateDashedLines(name, options, scene = null) {\n    const points = options.points;\n    const instance = options.instance;\n    const gapSize = options.gapSize || 1;\n    const dashSize = options.dashSize || 3;\n    if (instance) {\n        //  dashed lines update\n        const positionFunction = (positions) => {\n            const curvect = Vector3.Zero();\n            const nbSeg = positions.length / 6;\n            let lg = 0;\n            let nb = 0;\n            let shft = 0;\n            let dashshft = 0;\n            let curshft = 0;\n            let p = 0;\n            let i = 0;\n            let j = 0;\n            for (i = 0; i < points.length - 1; i++) {\n                points[i + 1].subtractToRef(points[i], curvect);\n                lg += curvect.length();\n            }\n            shft = lg / nbSeg;\n            const dashSize = instance._creationDataStorage.dashSize;\n            const gapSize = instance._creationDataStorage.gapSize;\n            dashshft = (dashSize * shft) / (dashSize + gapSize);\n            for (i = 0; i < points.length - 1; i++) {\n                points[i + 1].subtractToRef(points[i], curvect);\n                nb = Math.floor(curvect.length() / shft);\n                curvect.normalize();\n                j = 0;\n                while (j < nb && p < positions.length) {\n                    curshft = shft * j;\n                    positions[p] = points[i].x + curshft * curvect.x;\n                    positions[p + 1] = points[i].y + curshft * curvect.y;\n                    positions[p + 2] = points[i].z + curshft * curvect.z;\n                    positions[p + 3] = points[i].x + (curshft + dashshft) * curvect.x;\n                    positions[p + 4] = points[i].y + (curshft + dashshft) * curvect.y;\n                    positions[p + 5] = points[i].z + (curshft + dashshft) * curvect.z;\n                    p += 6;\n                    j++;\n                }\n            }\n            while (p < positions.length) {\n                positions[p] = points[i].x;\n                positions[p + 1] = points[i].y;\n                positions[p + 2] = points[i].z;\n                p += 3;\n            }\n        };\n        if (options.dashNb || options.dashSize || options.gapSize || options.useVertexAlpha || options.material) {\n            Logger.Warn(\"You have used an option other than points with the instance option. Please be aware that these other options will be ignored.\");\n        }\n        instance.updateMeshPositions(positionFunction, false);\n        return instance;\n    }\n    // dashed lines creation\n    const dashedLines = new LinesMesh(name, scene, null, undefined, undefined, undefined, options.useVertexAlpha, options.material);\n    const vertexData = CreateDashedLinesVertexData(options);\n    vertexData.applyToMesh(dashedLines, options.updatable);\n    dashedLines._creationDataStorage = new _CreationDataStorage();\n    dashedLines._creationDataStorage.dashSize = dashSize;\n    dashedLines._creationDataStorage.gapSize = gapSize;\n    return dashedLines;\n}\n/**\n * Class containing static functions to help procedurally build meshes\n * @deprecated use the functions directly from the module\n */\nexport const LinesBuilder = {\n    CreateDashedLines,\n    CreateLineSystem,\n    CreateLines,\n};\nVertexData.CreateLineSystem = CreateLineSystemVertexData;\nVertexData.CreateDashedLines = CreateDashedLinesVertexData;\nMesh.CreateLines = (name, points, scene = null, updatable = false, instance = null) => {\n    const options = {\n        points,\n        updatable,\n        instance,\n    };\n    return CreateLines(name, options, scene);\n};\nMesh.CreateDashedLines = (name, points, dashSize, gapSize, dashNb, scene = null, updatable, instance) => {\n    const options = {\n        points,\n        dashSize,\n        gapSize,\n        dashNb,\n        updatable,\n        instance,\n    };\n    return CreateDashedLines(name, options, scene);\n};\n//# sourceMappingURL=linesBuilder.js.map","import { Mesh } from \"../mesh.js\";\nimport { VertexData } from \"../mesh.vertexData.js\";\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions.js\";\n/**\n * Creates the VertexData for a Plane\n * @param options an object used to set the following optional parameters for the plane, required but can be empty\n * * size sets the width and height of the plane to the value of size, optional default 1\n * * width sets the width (x direction) of the plane, overwrites the width set by size, optional, default size\n * * height sets the height (y direction) of the plane, overwrites the height set by size, optional, default size\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\n * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\n * @param options.size\n * @param options.width\n * @param options.height\n * @param options.sideOrientation\n * @param options.frontUVs\n * @param options.backUVs\n * @returns the VertexData of the box\n */\nexport function CreatePlaneVertexData(options) {\n    const indices = [];\n    const positions = [];\n    const normals = [];\n    const uvs = [];\n    const width = options.width || options.size || 1;\n    const height = options.height || options.size || 1;\n    const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\n    // Vertices\n    const halfWidth = width / 2.0;\n    const halfHeight = height / 2.0;\n    positions.push(-halfWidth, -halfHeight, 0);\n    normals.push(0, 0, -1.0);\n    uvs.push(0.0, CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 : 0.0);\n    positions.push(halfWidth, -halfHeight, 0);\n    normals.push(0, 0, -1.0);\n    uvs.push(1.0, CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 : 0.0);\n    positions.push(halfWidth, halfHeight, 0);\n    normals.push(0, 0, -1.0);\n    uvs.push(1.0, CompatibilityOptions.UseOpenGLOrientationForUV ? 0.0 : 1.0);\n    positions.push(-halfWidth, halfHeight, 0);\n    normals.push(0, 0, -1.0);\n    uvs.push(0.0, CompatibilityOptions.UseOpenGLOrientationForUV ? 0.0 : 1.0);\n    // Indices\n    indices.push(0);\n    indices.push(1);\n    indices.push(2);\n    indices.push(0);\n    indices.push(2);\n    indices.push(3);\n    // Sides\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\n    // Result\n    const vertexData = new VertexData();\n    vertexData.indices = indices;\n    vertexData.positions = positions;\n    vertexData.normals = normals;\n    vertexData.uvs = uvs;\n    return vertexData;\n}\n/**\n * Creates a plane mesh\n * * The parameter `size` sets the size (float) of both sides of the plane at once (default 1)\n * * You can set some different plane dimensions by using the parameters `width` and `height` (both by default have the same value of `size`)\n * * The parameter `sourcePlane` is a Plane instance. It builds a mesh plane from a Math plane\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#side-orientation\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\n * @param name defines the name of the mesh\n * @param options defines the options used to create the mesh\n * @param options.size\n * @param options.width\n * @param options.height\n * @param options.sideOrientation\n * @param options.frontUVs\n * @param options.backUVs\n * @param options.updatable\n * @param options.sourcePlane\n * @param scene defines the hosting scene\n * @returns the plane mesh\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#plane\n */\nexport function CreatePlane(name, options = {}, scene = null) {\n    const plane = new Mesh(name, scene);\n    options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\n    plane._originalBuilderSideOrientation = options.sideOrientation;\n    const vertexData = CreatePlaneVertexData(options);\n    vertexData.applyToMesh(plane, options.updatable);\n    if (options.sourcePlane) {\n        plane.translate(options.sourcePlane.normal, -options.sourcePlane.d);\n        plane.setDirection(options.sourcePlane.normal.scale(-1));\n    }\n    return plane;\n}\n/**\n * Class containing static functions to help procedurally build meshes\n * @deprecated use the function directly from the module\n */\nexport const PlaneBuilder = {\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    CreatePlane,\n};\nVertexData.CreatePlane = CreatePlaneVertexData;\nMesh.CreatePlane = (name, size, scene, updatable, sideOrientation) => {\n    const options = {\n        size,\n        width: size,\n        height: size,\n        sideOrientation,\n        updatable,\n    };\n    return CreatePlane(name, options, scene);\n};\n//# sourceMappingURL=planeBuilder.js.map","import { Vector2, Vector4 } from \"../../Maths/math.vector.js\";\nimport { Color4 } from \"../../Maths/math.color.js\";\nimport { Mesh } from \"../mesh.js\";\nimport { VertexData } from \"../mesh.vertexData.js\";\nimport { PolygonMeshBuilder } from \"../polygonMesh.js\";\nimport { VertexBuffer } from \"../../Buffers/buffer.js\";\nimport { EngineStore } from \"../../Engines/engineStore.js\";\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions.js\";\n/**\n * Creates the VertexData for an irregular Polygon in the XoZ plane using a mesh built by polygonTriangulation.build()\n * All parameters are provided by CreatePolygon as needed\n * @param polygon a mesh built from polygonTriangulation.build()\n * @param sideOrientation takes the values Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n * @param fUV an array of Vector4 elements used to set different images to the top, rings and bottom respectively\n * @param fColors an array of Color3 elements used to set different colors to the top, rings and bottom respectively\n * @param frontUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\n * @param backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\n * @param wrp a boolean, default false, when true and fUVs used texture is wrapped around all sides, when false texture is applied side\n * @returns the VertexData of the Polygon\n */\nexport function CreatePolygonVertexData(polygon, sideOrientation, fUV, fColors, frontUVs, backUVs, wrp) {\n    const faceUV = fUV || new Array(3);\n    const faceColors = fColors;\n    const colors = [];\n    const wrap = wrp || false;\n    // default face colors and UV if undefined\n    for (let f = 0; f < 3; f++) {\n        if (faceUV[f] === undefined) {\n            faceUV[f] = new Vector4(0, 0, 1, 1);\n        }\n        if (faceColors && faceColors[f] === undefined) {\n            faceColors[f] = new Color4(1, 1, 1, 1);\n        }\n    }\n    const positions = polygon.getVerticesData(VertexBuffer.PositionKind);\n    const normals = polygon.getVerticesData(VertexBuffer.NormalKind);\n    const uvs = polygon.getVerticesData(VertexBuffer.UVKind);\n    const indices = polygon.getIndices();\n    const startIndex = positions.length / 9;\n    let disp = 0;\n    let distX = 0;\n    let distZ = 0;\n    let dist = 0;\n    let totalLen = 0;\n    const cumulate = [0];\n    if (wrap) {\n        for (let idx = startIndex; idx < positions.length / 3; idx += 4) {\n            distX = positions[3 * (idx + 2)] - positions[3 * idx];\n            distZ = positions[3 * (idx + 2) + 2] - positions[3 * idx + 2];\n            dist = Math.sqrt(distX * distX + distZ * distZ);\n            totalLen += dist;\n            cumulate.push(totalLen);\n        }\n    }\n    // set face colours and textures\n    let idx = 0;\n    let face = 0;\n    for (let index = 0; index < normals.length; index += 3) {\n        //Edge Face  no. 1\n        if (Math.abs(normals[index + 1]) < 0.001) {\n            face = 1;\n        }\n        //Top Face  no. 0\n        if (Math.abs(normals[index + 1] - 1) < 0.001) {\n            face = 0;\n        }\n        //Bottom Face  no. 2\n        if (Math.abs(normals[index + 1] + 1) < 0.001) {\n            face = 2;\n        }\n        idx = index / 3;\n        if (face === 1) {\n            disp = idx - startIndex;\n            if (disp % 4 < 1.5) {\n                if (wrap) {\n                    uvs[2 * idx] = faceUV[face].x + ((faceUV[face].z - faceUV[face].x) * cumulate[Math.floor(disp / 4)]) / totalLen;\n                }\n                else {\n                    uvs[2 * idx] = faceUV[face].x;\n                }\n            }\n            else {\n                if (wrap) {\n                    uvs[2 * idx] = faceUV[face].x + ((faceUV[face].z - faceUV[face].x) * cumulate[Math.floor(disp / 4) + 1]) / totalLen;\n                }\n                else {\n                    uvs[2 * idx] = faceUV[face].z;\n                }\n            }\n            if (disp % 2 === 0) {\n                uvs[2 * idx + 1] = CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 - faceUV[face].w : faceUV[face].w;\n            }\n            else {\n                uvs[2 * idx + 1] = CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 - faceUV[face].y : faceUV[face].y;\n            }\n        }\n        else {\n            uvs[2 * idx] = (1 - uvs[2 * idx]) * faceUV[face].x + uvs[2 * idx] * faceUV[face].z;\n            uvs[2 * idx + 1] = (1 - uvs[2 * idx + 1]) * faceUV[face].y + uvs[2 * idx + 1] * faceUV[face].w;\n            if (CompatibilityOptions.UseOpenGLOrientationForUV) {\n                uvs[2 * idx + 1] = 1.0 - uvs[2 * idx + 1];\n            }\n        }\n        if (faceColors) {\n            colors.push(faceColors[face].r, faceColors[face].g, faceColors[face].b, faceColors[face].a);\n        }\n    }\n    // sides\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, frontUVs, backUVs);\n    // Result\n    const vertexData = new VertexData();\n    vertexData.indices = indices;\n    vertexData.positions = positions;\n    vertexData.normals = normals;\n    vertexData.uvs = uvs;\n    if (faceColors) {\n        const totalColors = sideOrientation === VertexData.DOUBLESIDE ? colors.concat(colors) : colors;\n        vertexData.colors = totalColors;\n    }\n    return vertexData;\n}\n/**\n * Creates a polygon mesh\n * The polygon's shape will depend on the input parameters and is constructed parallel to a ground mesh\n * * The parameter `shape` is a required array of successive Vector3 representing the corners of the polygon in th XoZ plane, that is y = 0 for all vectors\n * * You can set the mesh side orientation with the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4)\n * * Remember you can only change the shape positions, not their number when updating a polygon\n * @param name defines the name of the mesh\n * @param options defines the options used to create the mesh\n * @param options.shape\n * @param options.holes\n * @param options.depth\n * @param options.smoothingThreshold\n * @param options.faceUV\n * @param options.faceColors\n * @param options.updatable\n * @param options.sideOrientation\n * @param options.frontUVs\n * @param options.backUVs\n * @param options.wrap\n * @param scene defines the hosting scene\n * @param earcutInjection can be used to inject your own earcut reference\n * @returns the polygon mesh\n */\nexport function CreatePolygon(name, options, scene = null, earcutInjection = earcut) {\n    options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\n    const shape = options.shape;\n    const holes = options.holes || [];\n    const depth = options.depth || 0;\n    const smoothingThreshold = options.smoothingThreshold || 2;\n    const contours = [];\n    let hole = [];\n    for (let i = 0; i < shape.length; i++) {\n        contours[i] = new Vector2(shape[i].x, shape[i].z);\n    }\n    const epsilon = 0.00000001;\n    if (contours[0].equalsWithEpsilon(contours[contours.length - 1], epsilon)) {\n        contours.pop();\n    }\n    const polygonTriangulation = new PolygonMeshBuilder(name, contours, scene || EngineStore.LastCreatedScene, earcutInjection);\n    for (let hNb = 0; hNb < holes.length; hNb++) {\n        hole = [];\n        for (let hPoint = 0; hPoint < holes[hNb].length; hPoint++) {\n            hole.push(new Vector2(holes[hNb][hPoint].x, holes[hNb][hPoint].z));\n        }\n        polygonTriangulation.addHole(hole);\n    }\n    //updatability is set during applyToMesh; setting to true in triangulation build produces errors\n    const polygon = polygonTriangulation.build(false, depth, smoothingThreshold);\n    polygon._originalBuilderSideOrientation = options.sideOrientation;\n    const vertexData = CreatePolygonVertexData(polygon, options.sideOrientation, options.faceUV, options.faceColors, options.frontUVs, options.backUVs, options.wrap);\n    vertexData.applyToMesh(polygon, options.updatable);\n    return polygon;\n}\n/**\n * Creates an extruded polygon mesh, with depth in the Y direction.\n * * You can set different colors and different images to the top, bottom and extruded side by using the parameters `faceColors` (an array of 3 Color3 elements) and `faceUV` (an array of 3 Vector4 elements)\n * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/texturePerBoxFace\n * @param name defines the name of the mesh\n * @param options defines the options used to create the mesh\n * @param options.shape\n * @param options.holes\n * @param options.depth\n * @param options.faceUV\n * @param options.faceColors\n * @param options.updatable\n * @param options.sideOrientation\n * @param options.frontUVs\n * @param options.backUVs\n * @param options.wrap\n * @param scene defines the hosting scene\n * @param earcutInjection can be used to inject your own earcut reference\n * @returns the polygon mesh\n */\nexport function ExtrudePolygon(name, options, scene = null, earcutInjection = earcut) {\n    return CreatePolygon(name, options, scene, earcutInjection);\n}\n/**\n * Class containing static functions to help procedurally build meshes\n * @deprecated use the functions directly from the module\n */\nexport const PolygonBuilder = {\n    ExtrudePolygon,\n    CreatePolygon,\n};\nVertexData.CreatePolygon = CreatePolygonVertexData;\nMesh.CreatePolygon = (name, shape, scene, holes, updatable, sideOrientation, earcutInjection = earcut) => {\n    const options = {\n        shape: shape,\n        holes: holes,\n        updatable: updatable,\n        sideOrientation: sideOrientation,\n    };\n    return CreatePolygon(name, options, scene, earcutInjection);\n};\nMesh.ExtrudePolygon = (name, shape, depth, scene, holes, updatable, sideOrientation, earcutInjection = earcut) => {\n    const options = {\n        shape: shape,\n        holes: holes,\n        depth: depth,\n        updatable: updatable,\n        sideOrientation: sideOrientation,\n    };\n    return ExtrudePolygon(name, options, scene, earcutInjection);\n};\n//# sourceMappingURL=polygonBuilder.js.map","import { Vector4 } from \"../../Maths/math.vector.js\";\nimport { Color4 } from \"../../Maths/math.color.js\";\nimport { Mesh } from \"../mesh.js\";\nimport { VertexData } from \"../mesh.vertexData.js\";\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions.js\";\n// inspired from // http://stemkoski.github.io/Three.js/Polyhedra.html\n/**\n * Creates the VertexData for a Polyhedron\n * @param options an object used to set the following optional parameters for the polyhedron, required but can be empty\n * * type provided types are:\n *  * 0 : Tetrahedron, 1 : Octahedron, 2 : Dodecahedron, 3 : Icosahedron, 4 : Rhombicuboctahedron, 5 : Triangular Prism, 6 : Pentagonal Prism, 7 : Hexagonal Prism, 8 : Square Pyramid (J1)\n *  * 9 : Pentagonal Pyramid (J2), 10 : Triangular Dipyramid (J12), 11 : Pentagonal Dipyramid (J13), 12 : Elongated Square Dipyramid (J15), 13 : Elongated Pentagonal Dipyramid (J16), 14 : Elongated Pentagonal Cupola (J20)\n * * size the size of the IcoSphere, optional default 1\n * * sizeX allows stretching in the x direction, optional, default size\n * * sizeY allows stretching in the y direction, optional, default size\n * * sizeZ allows stretching in the z direction, optional, default size\n * * custom a number that overwrites the type to create from an extended set of polyhedron from https://www.babylonjs-playground.com/#21QRSK#15 with minimised editor\n * * faceUV an array of Vector4 elements used to set different images to the top, rings and bottom respectively\n * * faceColors an array of Color3 elements used to set different colors to the top, rings and bottom respectively\n * * flat when true creates a flat shaded mesh, optional, default true\n * * subdivisions increasing the subdivisions increases the number of faces, optional, default 4\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\n * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\n * @param options.type\n * @param options.size\n * @param options.sizeX\n * @param options.sizeY\n * @param options.sizeZ\n * @param options.custom\n * @param options.faceUV\n * @param options.faceColors\n * @param options.flat\n * @param options.sideOrientation\n * @param options.frontUVs\n * @param options.backUVs\n * @returns the VertexData of the Polyhedron\n */\nexport function CreatePolyhedronVertexData(options) {\n    // provided polyhedron types :\n    // 0 : Tetrahedron, 1 : Octahedron, 2 : Dodecahedron, 3 : Icosahedron, 4 : Rhombicuboctahedron, 5 : Triangular Prism, 6 : Pentagonal Prism, 7 : Hexagonal Prism, 8 : Square Pyramid (J1)\n    // 9 : Pentagonal Pyramid (J2), 10 : Triangular Dipyramid (J12), 11 : Pentagonal Dipyramid (J13), 12 : Elongated Square Dipyramid (J15), 13 : Elongated Pentagonal Dipyramid (J16), 14 : Elongated Pentagonal Cupola (J20)\n    const polyhedra = [];\n    polyhedra[0] = {\n        vertex: [\n            [0, 0, 1.732051],\n            [1.632993, 0, -0.5773503],\n            [-0.8164966, 1.414214, -0.5773503],\n            [-0.8164966, -1.414214, -0.5773503],\n        ],\n        face: [\n            [0, 1, 2],\n            [0, 2, 3],\n            [0, 3, 1],\n            [1, 3, 2],\n        ],\n    };\n    polyhedra[1] = {\n        vertex: [\n            [0, 0, 1.414214],\n            [1.414214, 0, 0],\n            [0, 1.414214, 0],\n            [-1.414214, 0, 0],\n            [0, -1.414214, 0],\n            [0, 0, -1.414214],\n        ],\n        face: [\n            [0, 1, 2],\n            [0, 2, 3],\n            [0, 3, 4],\n            [0, 4, 1],\n            [1, 4, 5],\n            [1, 5, 2],\n            [2, 5, 3],\n            [3, 5, 4],\n        ],\n    };\n    polyhedra[2] = {\n        vertex: [\n            [0, 0, 1.070466],\n            [0.7136442, 0, 0.7978784],\n            [-0.3568221, 0.618034, 0.7978784],\n            [-0.3568221, -0.618034, 0.7978784],\n            [0.7978784, 0.618034, 0.3568221],\n            [0.7978784, -0.618034, 0.3568221],\n            [-0.9341724, 0.381966, 0.3568221],\n            [0.1362939, 1, 0.3568221],\n            [0.1362939, -1, 0.3568221],\n            [-0.9341724, -0.381966, 0.3568221],\n            [0.9341724, 0.381966, -0.3568221],\n            [0.9341724, -0.381966, -0.3568221],\n            [-0.7978784, 0.618034, -0.3568221],\n            [-0.1362939, 1, -0.3568221],\n            [-0.1362939, -1, -0.3568221],\n            [-0.7978784, -0.618034, -0.3568221],\n            [0.3568221, 0.618034, -0.7978784],\n            [0.3568221, -0.618034, -0.7978784],\n            [-0.7136442, 0, -0.7978784],\n            [0, 0, -1.070466],\n        ],\n        face: [\n            [0, 1, 4, 7, 2],\n            [0, 2, 6, 9, 3],\n            [0, 3, 8, 5, 1],\n            [1, 5, 11, 10, 4],\n            [2, 7, 13, 12, 6],\n            [3, 9, 15, 14, 8],\n            [4, 10, 16, 13, 7],\n            [5, 8, 14, 17, 11],\n            [6, 12, 18, 15, 9],\n            [10, 11, 17, 19, 16],\n            [12, 13, 16, 19, 18],\n            [14, 15, 18, 19, 17],\n        ],\n    };\n    polyhedra[3] = {\n        vertex: [\n            [0, 0, 1.175571],\n            [1.051462, 0, 0.5257311],\n            [0.3249197, 1, 0.5257311],\n            [-0.8506508, 0.618034, 0.5257311],\n            [-0.8506508, -0.618034, 0.5257311],\n            [0.3249197, -1, 0.5257311],\n            [0.8506508, 0.618034, -0.5257311],\n            [0.8506508, -0.618034, -0.5257311],\n            [-0.3249197, 1, -0.5257311],\n            [-1.051462, 0, -0.5257311],\n            [-0.3249197, -1, -0.5257311],\n            [0, 0, -1.175571],\n        ],\n        face: [\n            [0, 1, 2],\n            [0, 2, 3],\n            [0, 3, 4],\n            [0, 4, 5],\n            [0, 5, 1],\n            [1, 5, 7],\n            [1, 7, 6],\n            [1, 6, 2],\n            [2, 6, 8],\n            [2, 8, 3],\n            [3, 8, 9],\n            [3, 9, 4],\n            [4, 9, 10],\n            [4, 10, 5],\n            [5, 10, 7],\n            [6, 7, 11],\n            [6, 11, 8],\n            [7, 10, 11],\n            [8, 11, 9],\n            [9, 11, 10],\n        ],\n    };\n    polyhedra[4] = {\n        vertex: [\n            [0, 0, 1.070722],\n            [0.7148135, 0, 0.7971752],\n            [-0.104682, 0.7071068, 0.7971752],\n            [-0.6841528, 0.2071068, 0.7971752],\n            [-0.104682, -0.7071068, 0.7971752],\n            [0.6101315, 0.7071068, 0.5236279],\n            [1.04156, 0.2071068, 0.1367736],\n            [0.6101315, -0.7071068, 0.5236279],\n            [-0.3574067, 1, 0.1367736],\n            [-0.7888348, -0.5, 0.5236279],\n            [-0.9368776, 0.5, 0.1367736],\n            [-0.3574067, -1, 0.1367736],\n            [0.3574067, 1, -0.1367736],\n            [0.9368776, -0.5, -0.1367736],\n            [0.7888348, 0.5, -0.5236279],\n            [0.3574067, -1, -0.1367736],\n            [-0.6101315, 0.7071068, -0.5236279],\n            [-1.04156, -0.2071068, -0.1367736],\n            [-0.6101315, -0.7071068, -0.5236279],\n            [0.104682, 0.7071068, -0.7971752],\n            [0.6841528, -0.2071068, -0.7971752],\n            [0.104682, -0.7071068, -0.7971752],\n            [-0.7148135, 0, -0.7971752],\n            [0, 0, -1.070722],\n        ],\n        face: [\n            [0, 2, 3],\n            [1, 6, 5],\n            [4, 9, 11],\n            [7, 15, 13],\n            [8, 16, 10],\n            [12, 14, 19],\n            [17, 22, 18],\n            [20, 21, 23],\n            [0, 1, 5, 2],\n            [0, 3, 9, 4],\n            [0, 4, 7, 1],\n            [1, 7, 13, 6],\n            [2, 5, 12, 8],\n            [2, 8, 10, 3],\n            [3, 10, 17, 9],\n            [4, 11, 15, 7],\n            [5, 6, 14, 12],\n            [6, 13, 20, 14],\n            [8, 12, 19, 16],\n            [9, 17, 18, 11],\n            [10, 16, 22, 17],\n            [11, 18, 21, 15],\n            [13, 15, 21, 20],\n            [14, 20, 23, 19],\n            [16, 19, 23, 22],\n            [18, 22, 23, 21],\n        ],\n    };\n    polyhedra[5] = {\n        vertex: [\n            [0, 0, 1.322876],\n            [1.309307, 0, 0.1889822],\n            [-0.9819805, 0.8660254, 0.1889822],\n            [0.1636634, -1.299038, 0.1889822],\n            [0.3273268, 0.8660254, -0.9449112],\n            [-0.8183171, -0.4330127, -0.9449112],\n        ],\n        face: [\n            [0, 3, 1],\n            [2, 4, 5],\n            [0, 1, 4, 2],\n            [0, 2, 5, 3],\n            [1, 3, 5, 4],\n        ],\n    };\n    polyhedra[6] = {\n        vertex: [\n            [0, 0, 1.159953],\n            [1.013464, 0, 0.5642542],\n            [-0.3501431, 0.9510565, 0.5642542],\n            [-0.7715208, -0.6571639, 0.5642542],\n            [0.6633206, 0.9510565, -0.03144481],\n            [0.8682979, -0.6571639, -0.3996071],\n            [-1.121664, 0.2938926, -0.03144481],\n            [-0.2348831, -1.063314, -0.3996071],\n            [0.5181548, 0.2938926, -0.9953061],\n            [-0.5850262, -0.112257, -0.9953061],\n        ],\n        face: [\n            [0, 1, 4, 2],\n            [0, 2, 6, 3],\n            [1, 5, 8, 4],\n            [3, 6, 9, 7],\n            [5, 7, 9, 8],\n            [0, 3, 7, 5, 1],\n            [2, 4, 8, 9, 6],\n        ],\n    };\n    polyhedra[7] = {\n        vertex: [\n            [0, 0, 1.118034],\n            [0.8944272, 0, 0.6708204],\n            [-0.2236068, 0.8660254, 0.6708204],\n            [-0.7826238, -0.4330127, 0.6708204],\n            [0.6708204, 0.8660254, 0.2236068],\n            [1.006231, -0.4330127, -0.2236068],\n            [-1.006231, 0.4330127, 0.2236068],\n            [-0.6708204, -0.8660254, -0.2236068],\n            [0.7826238, 0.4330127, -0.6708204],\n            [0.2236068, -0.8660254, -0.6708204],\n            [-0.8944272, 0, -0.6708204],\n            [0, 0, -1.118034],\n        ],\n        face: [\n            [0, 1, 4, 2],\n            [0, 2, 6, 3],\n            [1, 5, 8, 4],\n            [3, 6, 10, 7],\n            [5, 9, 11, 8],\n            [7, 10, 11, 9],\n            [0, 3, 7, 9, 5, 1],\n            [2, 4, 8, 11, 10, 6],\n        ],\n    };\n    polyhedra[8] = {\n        vertex: [\n            [-0.729665, 0.670121, 0.319155],\n            [-0.655235, -0.29213, -0.754096],\n            [-0.093922, -0.607123, 0.537818],\n            [0.702196, 0.595691, 0.485187],\n            [0.776626, -0.36656, -0.588064],\n        ],\n        face: [\n            [1, 4, 2],\n            [0, 1, 2],\n            [3, 0, 2],\n            [4, 3, 2],\n            [4, 1, 0, 3],\n        ],\n    };\n    polyhedra[9] = {\n        vertex: [\n            [-0.868849, -0.100041, 0.61257],\n            [-0.329458, 0.976099, 0.28078],\n            [-0.26629, -0.013796, -0.477654],\n            [-0.13392, -1.034115, 0.229829],\n            [0.738834, 0.707117, -0.307018],\n            [0.859683, -0.535264, -0.338508],\n        ],\n        face: [\n            [3, 0, 2],\n            [5, 3, 2],\n            [4, 5, 2],\n            [1, 4, 2],\n            [0, 1, 2],\n            [0, 3, 5, 4, 1],\n        ],\n    };\n    polyhedra[10] = {\n        vertex: [\n            [-0.610389, 0.243975, 0.531213],\n            [-0.187812, -0.48795, -0.664016],\n            [-0.187812, 0.9759, -0.664016],\n            [0.187812, -0.9759, 0.664016],\n            [0.798201, 0.243975, 0.132803],\n        ],\n        face: [\n            [1, 3, 0],\n            [3, 4, 0],\n            [3, 1, 4],\n            [0, 2, 1],\n            [0, 4, 2],\n            [2, 4, 1],\n        ],\n    };\n    polyhedra[11] = {\n        vertex: [\n            [-1.028778, 0.392027, -0.048786],\n            [-0.640503, -0.646161, 0.621837],\n            [-0.125162, -0.395663, -0.540059],\n            [0.004683, 0.888447, -0.651988],\n            [0.125161, 0.395663, 0.540059],\n            [0.632925, -0.791376, 0.433102],\n            [1.031672, 0.157063, -0.354165],\n        ],\n        face: [\n            [3, 2, 0],\n            [2, 1, 0],\n            [2, 5, 1],\n            [0, 4, 3],\n            [0, 1, 4],\n            [4, 1, 5],\n            [2, 3, 6],\n            [3, 4, 6],\n            [5, 2, 6],\n            [4, 5, 6],\n        ],\n    };\n    polyhedra[12] = {\n        vertex: [\n            [-0.669867, 0.334933, -0.529576],\n            [-0.669867, 0.334933, 0.529577],\n            [-0.4043, 1.212901, 0],\n            [-0.334933, -0.669867, -0.529576],\n            [-0.334933, -0.669867, 0.529577],\n            [0.334933, 0.669867, -0.529576],\n            [0.334933, 0.669867, 0.529577],\n            [0.4043, -1.212901, 0],\n            [0.669867, -0.334933, -0.529576],\n            [0.669867, -0.334933, 0.529577],\n        ],\n        face: [\n            [8, 9, 7],\n            [6, 5, 2],\n            [3, 8, 7],\n            [5, 0, 2],\n            [4, 3, 7],\n            [0, 1, 2],\n            [9, 4, 7],\n            [1, 6, 2],\n            [9, 8, 5, 6],\n            [8, 3, 0, 5],\n            [3, 4, 1, 0],\n            [4, 9, 6, 1],\n        ],\n    };\n    polyhedra[13] = {\n        vertex: [\n            [-0.931836, 0.219976, -0.264632],\n            [-0.636706, 0.318353, 0.692816],\n            [-0.613483, -0.735083, -0.264632],\n            [-0.326545, 0.979634, 0],\n            [-0.318353, -0.636706, 0.692816],\n            [-0.159176, 0.477529, -0.856368],\n            [0.159176, -0.477529, -0.856368],\n            [0.318353, 0.636706, 0.692816],\n            [0.326545, -0.979634, 0],\n            [0.613482, 0.735082, -0.264632],\n            [0.636706, -0.318353, 0.692816],\n            [0.931835, -0.219977, -0.264632],\n        ],\n        face: [\n            [11, 10, 8],\n            [7, 9, 3],\n            [6, 11, 8],\n            [9, 5, 3],\n            [2, 6, 8],\n            [5, 0, 3],\n            [4, 2, 8],\n            [0, 1, 3],\n            [10, 4, 8],\n            [1, 7, 3],\n            [10, 11, 9, 7],\n            [11, 6, 5, 9],\n            [6, 2, 0, 5],\n            [2, 4, 1, 0],\n            [4, 10, 7, 1],\n        ],\n    };\n    polyhedra[14] = {\n        vertex: [\n            [-0.93465, 0.300459, -0.271185],\n            [-0.838689, -0.260219, -0.516017],\n            [-0.711319, 0.717591, 0.128359],\n            [-0.710334, -0.156922, 0.080946],\n            [-0.599799, 0.556003, -0.725148],\n            [-0.503838, -0.004675, -0.969981],\n            [-0.487004, 0.26021, 0.48049],\n            [-0.460089, -0.750282, -0.512622],\n            [-0.376468, 0.973135, -0.325605],\n            [-0.331735, -0.646985, 0.084342],\n            [-0.254001, 0.831847, 0.530001],\n            [-0.125239, -0.494738, -0.966586],\n            [0.029622, 0.027949, 0.730817],\n            [0.056536, -0.982543, -0.262295],\n            [0.08085, 1.087391, 0.076037],\n            [0.125583, -0.532729, 0.485984],\n            [0.262625, 0.599586, 0.780328],\n            [0.391387, -0.726999, -0.716259],\n            [0.513854, -0.868287, 0.139347],\n            [0.597475, 0.85513, 0.326364],\n            [0.641224, 0.109523, 0.783723],\n            [0.737185, -0.451155, 0.538891],\n            [0.848705, -0.612742, -0.314616],\n            [0.976075, 0.365067, 0.32976],\n            [1.072036, -0.19561, 0.084927],\n        ],\n        face: [\n            [15, 18, 21],\n            [12, 20, 16],\n            [6, 10, 2],\n            [3, 0, 1],\n            [9, 7, 13],\n            [2, 8, 4, 0],\n            [0, 4, 5, 1],\n            [1, 5, 11, 7],\n            [7, 11, 17, 13],\n            [13, 17, 22, 18],\n            [18, 22, 24, 21],\n            [21, 24, 23, 20],\n            [20, 23, 19, 16],\n            [16, 19, 14, 10],\n            [10, 14, 8, 2],\n            [15, 9, 13, 18],\n            [12, 15, 21, 20],\n            [6, 12, 16, 10],\n            [3, 6, 2, 0],\n            [9, 3, 1, 7],\n            [9, 15, 12, 6, 3],\n            [22, 17, 11, 5, 4, 8, 14, 19, 23, 24],\n        ],\n    };\n    const type = options.type && (options.type < 0 || options.type >= polyhedra.length) ? 0 : options.type || 0;\n    const size = options.size;\n    const sizeX = options.sizeX || size || 1;\n    const sizeY = options.sizeY || size || 1;\n    const sizeZ = options.sizeZ || size || 1;\n    const data = options.custom || polyhedra[type];\n    const nbfaces = data.face.length;\n    const faceUV = options.faceUV || new Array(nbfaces);\n    const faceColors = options.faceColors;\n    const flat = options.flat === undefined ? true : options.flat;\n    const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\n    const positions = new Array();\n    const indices = new Array();\n    const normals = new Array();\n    const uvs = new Array();\n    const colors = new Array();\n    let index = 0;\n    let faceIdx = 0; // face cursor in the array \"indexes\"\n    const indexes = new Array();\n    let i = 0;\n    let f = 0;\n    let u, v, ang, x, y, tmp;\n    // default face colors and UV if undefined\n    if (flat) {\n        for (f = 0; f < nbfaces; f++) {\n            if (faceColors && faceColors[f] === undefined) {\n                faceColors[f] = new Color4(1, 1, 1, 1);\n            }\n            if (faceUV && faceUV[f] === undefined) {\n                faceUV[f] = new Vector4(0, 0, 1, 1);\n            }\n        }\n    }\n    if (!flat) {\n        for (i = 0; i < data.vertex.length; i++) {\n            positions.push(data.vertex[i][0] * sizeX, data.vertex[i][1] * sizeY, data.vertex[i][2] * sizeZ);\n            uvs.push(0, CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 : 0);\n        }\n        for (f = 0; f < nbfaces; f++) {\n            for (i = 0; i < data.face[f].length - 2; i++) {\n                indices.push(data.face[f][0], data.face[f][i + 2], data.face[f][i + 1]);\n            }\n        }\n    }\n    else {\n        for (f = 0; f < nbfaces; f++) {\n            const fl = data.face[f].length; // number of vertices of the current face\n            ang = (2 * Math.PI) / fl;\n            x = 0.5 * Math.tan(ang / 2);\n            y = 0.5;\n            // positions, uvs, colors\n            for (i = 0; i < fl; i++) {\n                // positions\n                positions.push(data.vertex[data.face[f][i]][0] * sizeX, data.vertex[data.face[f][i]][1] * sizeY, data.vertex[data.face[f][i]][2] * sizeZ);\n                indexes.push(index);\n                index++;\n                // uvs\n                u = faceUV[f].x + (faceUV[f].z - faceUV[f].x) * (0.5 + x);\n                v = faceUV[f].y + (faceUV[f].w - faceUV[f].y) * (y - 0.5);\n                uvs.push(u, CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 - v : v);\n                tmp = x * Math.cos(ang) - y * Math.sin(ang);\n                y = x * Math.sin(ang) + y * Math.cos(ang);\n                x = tmp;\n                // colors\n                if (faceColors) {\n                    colors.push(faceColors[f].r, faceColors[f].g, faceColors[f].b, faceColors[f].a);\n                }\n            }\n            // indices from indexes\n            for (i = 0; i < fl - 2; i++) {\n                indices.push(indexes[0 + faceIdx], indexes[i + 2 + faceIdx], indexes[i + 1 + faceIdx]);\n            }\n            faceIdx += fl;\n        }\n    }\n    VertexData.ComputeNormals(positions, indices, normals);\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\n    const vertexData = new VertexData();\n    vertexData.positions = positions;\n    vertexData.indices = indices;\n    vertexData.normals = normals;\n    vertexData.uvs = uvs;\n    if (faceColors && flat) {\n        vertexData.colors = colors;\n    }\n    return vertexData;\n}\n/**\n * Creates a polyhedron mesh\n * * The parameter `type` (positive integer, max 14, default 0) sets the polyhedron type to build among the 15 embbeded types. Please refer to the type sheet in the tutorial to choose the wanted type\n * * The parameter `size` (positive float, default 1) sets the polygon size\n * * You can overwrite the `size` on each dimension bu using the parameters `sizeX`, `sizeY` or `sizeZ` (positive floats, default to `size` value)\n * * You can build other polyhedron types than the 15 embbeded ones by setting the parameter `custom` (`polyhedronObject`, default null). If you set the parameter `custom`, this overrides the parameter `type`\n * * A `polyhedronObject` is a formatted javascript object. You'll find a full file with pre-set polyhedra here : https://github.com/BabylonJS/Extensions/tree/master/Polyhedron\n * * You can set the color and the UV of each side of the polyhedron with the parameters `faceColors` (Color4, default `(1, 1, 1, 1)`) and faceUV (Vector4, default `(0, 0, 1, 1)`)\n * * To understand how to set `faceUV` or `faceColors`, please read this by considering the right number of faces of your polyhedron, instead of only 6 for the box : https://doc.babylonjs.com/features/featuresDeepDive/materials/using/texturePerBoxFace\n * * The parameter `flat` (boolean, default true). If set to false, it gives the polyhedron a single global face, so less vertices and shared normals. In this case, `faceColors` and `faceUV` are ignored\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#side-orientation\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\n * @param name defines the name of the mesh\n * @param options defines the options used to create the mesh\n * @param options.type\n * @param options.size\n * @param options.sizeX\n * @param options.sizeY\n * @param options.sizeZ\n * @param options.custom\n * @param options.faceUV\n * @param options.faceColors\n * @param options.flat\n * @param options.updatable\n * @param options.sideOrientation\n * @param options.frontUVs\n * @param options.backUVs\n * @param scene defines the hosting scene\n * @returns the polyhedron mesh\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/polyhedra\n */\nexport function CreatePolyhedron(name, options = {}, scene = null) {\n    const polyhedron = new Mesh(name, scene);\n    options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\n    polyhedron._originalBuilderSideOrientation = options.sideOrientation;\n    const vertexData = CreatePolyhedronVertexData(options);\n    vertexData.applyToMesh(polyhedron, options.updatable);\n    return polyhedron;\n}\n/**\n * Class containing static functions to help procedurally build meshes\n * @deprecated use the function directly from the module\n */\nexport const PolyhedronBuilder = {\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    CreatePolyhedron,\n};\nVertexData.CreatePolyhedron = CreatePolyhedronVertexData;\nMesh.CreatePolyhedron = (name, options, scene) => {\n    return CreatePolyhedron(name, options, scene);\n};\n//# sourceMappingURL=polyhedronBuilder.js.map","import { TmpVectors } from \"../../Maths/math.vector.js\";\nimport { Mesh, _CreationDataStorage } from \"../mesh.js\";\nimport { VertexBuffer } from \"../../Buffers/buffer.js\";\nimport { VertexData } from \"../mesh.vertexData.js\";\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions.js\";\n/**\n * Creates the VertexData for a Ribbon\n * @param options an object used to set the following optional parameters for the ribbon, required but can be empty\n * * pathArray array of paths, each of which an array of successive Vector3\n * * closeArray creates a seam between the first and the last paths of the pathArray, optional, default false\n * * closePath creates a seam between the first and the last points of each path of the path array, optional, default false\n * * offset a positive integer, only used when pathArray contains a single path (offset = 10 means the point 1 is joined to the point 11), default rounded half size of the pathArray length\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\n * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\n * * invertUV swaps in the U and V coordinates when applying a texture, optional, default false\n * * uvs a linear array, of length 2 * number of vertices, of custom UV values, optional\n * * colors a linear array, of length 4 * number of vertices, of custom color values, optional\n * @param options.pathArray\n * @param options.closeArray\n * @param options.closePath\n * @param options.offset\n * @param options.sideOrientation\n * @param options.frontUVs\n * @param options.backUVs\n * @param options.invertUV\n * @param options.uvs\n * @param options.colors\n * @returns the VertexData of the ribbon\n */\nexport function CreateRibbonVertexData(options) {\n    let pathArray = options.pathArray;\n    const closeArray = options.closeArray || false;\n    const closePath = options.closePath || false;\n    const invertUV = options.invertUV || false;\n    const defaultOffset = Math.floor(pathArray[0].length / 2);\n    let offset = options.offset || defaultOffset;\n    offset = offset > defaultOffset ? defaultOffset : Math.floor(offset); // offset max allowed : defaultOffset\n    const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\n    const customUV = options.uvs;\n    const customColors = options.colors;\n    const positions = [];\n    const indices = [];\n    const normals = [];\n    const uvs = [];\n    const us = []; // us[path_id] = [uDist1, uDist2, uDist3 ... ] distances between points on path path_id\n    const vs = []; // vs[i] = [vDist1, vDist2, vDist3, ... ] distances between points i of consecutive paths from pathArray\n    const uTotalDistance = []; // uTotalDistance[p] : total distance of path p\n    const vTotalDistance = []; //  vTotalDistance[i] : total distance between points i of first and last path from pathArray\n    let minlg; // minimal length among all paths from pathArray\n    const lg = []; // array of path lengths : nb of vertex per path\n    const idx = []; // array of path indexes : index of each path (first vertex) in the total vertex number\n    let p; // path iterator\n    let i; // point iterator\n    let j; // point iterator\n    // if single path in pathArray\n    if (pathArray.length < 2) {\n        const ar1 = [];\n        const ar2 = [];\n        for (i = 0; i < pathArray[0].length - offset; i++) {\n            ar1.push(pathArray[0][i]);\n            ar2.push(pathArray[0][i + offset]);\n        }\n        pathArray = [ar1, ar2];\n    }\n    // positions and horizontal distances (u)\n    let idc = 0;\n    const closePathCorr = closePath ? 1 : 0; // the final index will be +1 if closePath\n    let path;\n    let l;\n    minlg = pathArray[0].length;\n    let vectlg;\n    let dist;\n    for (p = 0; p < pathArray.length; p++) {\n        uTotalDistance[p] = 0;\n        us[p] = [0];\n        path = pathArray[p];\n        l = path.length;\n        minlg = minlg < l ? minlg : l;\n        j = 0;\n        while (j < l) {\n            positions.push(path[j].x, path[j].y, path[j].z);\n            if (j > 0) {\n                vectlg = path[j].subtract(path[j - 1]).length();\n                dist = vectlg + uTotalDistance[p];\n                us[p].push(dist);\n                uTotalDistance[p] = dist;\n            }\n            j++;\n        }\n        if (closePath) {\n            // an extra hidden vertex is added in the \"positions\" array\n            j--;\n            positions.push(path[0].x, path[0].y, path[0].z);\n            vectlg = path[j].subtract(path[0]).length();\n            dist = vectlg + uTotalDistance[p];\n            us[p].push(dist);\n            uTotalDistance[p] = dist;\n        }\n        lg[p] = l + closePathCorr;\n        idx[p] = idc;\n        idc += l + closePathCorr;\n    }\n    // vertical distances (v)\n    let path1;\n    let path2;\n    let vertex1 = null;\n    let vertex2 = null;\n    for (i = 0; i < minlg + closePathCorr; i++) {\n        vTotalDistance[i] = 0;\n        vs[i] = [0];\n        for (p = 0; p < pathArray.length - 1; p++) {\n            path1 = pathArray[p];\n            path2 = pathArray[p + 1];\n            if (i === minlg) {\n                // closePath\n                vertex1 = path1[0];\n                vertex2 = path2[0];\n            }\n            else {\n                vertex1 = path1[i];\n                vertex2 = path2[i];\n            }\n            vectlg = vertex2.subtract(vertex1).length();\n            dist = vectlg + vTotalDistance[i];\n            vs[i].push(dist);\n            vTotalDistance[i] = dist;\n        }\n        if (closeArray && vertex2 && vertex1) {\n            path1 = pathArray[p];\n            path2 = pathArray[0];\n            if (i === minlg) {\n                // closePath\n                vertex2 = path2[0];\n            }\n            vectlg = vertex2.subtract(vertex1).length();\n            dist = vectlg + vTotalDistance[i];\n            vTotalDistance[i] = dist;\n        }\n    }\n    // uvs\n    let u;\n    let v;\n    if (customUV) {\n        for (p = 0; p < customUV.length; p++) {\n            uvs.push(customUV[p].x, CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 - customUV[p].y : customUV[p].y);\n        }\n    }\n    else {\n        for (p = 0; p < pathArray.length; p++) {\n            for (i = 0; i < minlg + closePathCorr; i++) {\n                u = uTotalDistance[p] != 0.0 ? us[p][i] / uTotalDistance[p] : 0.0;\n                v = vTotalDistance[i] != 0.0 ? vs[i][p] / vTotalDistance[i] : 0.0;\n                if (invertUV) {\n                    uvs.push(v, u);\n                }\n                else {\n                    uvs.push(u, CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 - v : v);\n                }\n            }\n        }\n    }\n    // indices\n    p = 0; // path index\n    let pi = 0; // positions array index\n    let l1 = lg[p] - 1; // path1 length\n    let l2 = lg[p + 1] - 1; // path2 length\n    let min = l1 < l2 ? l1 : l2; // current path stop index\n    let shft = idx[1] - idx[0]; // shift\n    const path1nb = closeArray ? lg.length : lg.length - 1; // number of path1 to iterate\ton\n    while (pi <= min && p < path1nb) {\n        //  stay under min and don't go over next to last path\n        // draw two triangles between path1 (p1) and path2 (p2) : (p1.pi, p2.pi, p1.pi+1) and (p2.pi+1, p1.pi+1, p2.pi) clockwise\n        indices.push(pi, pi + shft, pi + 1);\n        indices.push(pi + shft + 1, pi + 1, pi + shft);\n        pi += 1;\n        if (pi === min) {\n            // if end of one of two consecutive paths reached, go to next existing path\n            p++;\n            if (p === lg.length - 1) {\n                // last path of pathArray reached <=> closeArray == true\n                shft = idx[0] - idx[p];\n                l1 = lg[p] - 1;\n                l2 = lg[0] - 1;\n            }\n            else {\n                shft = idx[p + 1] - idx[p];\n                l1 = lg[p] - 1;\n                l2 = lg[p + 1] - 1;\n            }\n            pi = idx[p];\n            min = l1 < l2 ? l1 + pi : l2 + pi;\n        }\n    }\n    // normals\n    VertexData.ComputeNormals(positions, indices, normals);\n    if (closePath) {\n        // update both the first and last vertex normals to their average value\n        let indexFirst = 0;\n        let indexLast = 0;\n        for (p = 0; p < pathArray.length; p++) {\n            indexFirst = idx[p] * 3;\n            if (p + 1 < pathArray.length) {\n                indexLast = (idx[p + 1] - 1) * 3;\n            }\n            else {\n                indexLast = normals.length - 3;\n            }\n            normals[indexFirst] = (normals[indexFirst] + normals[indexLast]) * 0.5;\n            normals[indexFirst + 1] = (normals[indexFirst + 1] + normals[indexLast + 1]) * 0.5;\n            normals[indexFirst + 2] = (normals[indexFirst + 2] + normals[indexLast + 2]) * 0.5;\n            normals[indexLast] = normals[indexFirst];\n            normals[indexLast + 1] = normals[indexFirst + 1];\n            normals[indexLast + 2] = normals[indexFirst + 2];\n        }\n    }\n    // sides\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\n    // Colors\n    let colors = null;\n    if (customColors) {\n        colors = new Float32Array(customColors.length * 4);\n        for (let c = 0; c < customColors.length; c++) {\n            colors[c * 4] = customColors[c].r;\n            colors[c * 4 + 1] = customColors[c].g;\n            colors[c * 4 + 2] = customColors[c].b;\n            colors[c * 4 + 3] = customColors[c].a;\n        }\n    }\n    // Result\n    const vertexData = new VertexData();\n    const positions32 = new Float32Array(positions);\n    const normals32 = new Float32Array(normals);\n    const uvs32 = new Float32Array(uvs);\n    vertexData.indices = indices;\n    vertexData.positions = positions32;\n    vertexData.normals = normals32;\n    vertexData.uvs = uvs32;\n    if (colors) {\n        vertexData.set(colors, VertexBuffer.ColorKind);\n    }\n    if (closePath) {\n        vertexData._idx = idx;\n    }\n    return vertexData;\n}\n/**\n * Creates a ribbon mesh. The ribbon is a parametric shape.  It has no predefined shape. Its final shape will depend on the input parameters\n * * The parameter `pathArray` is a required array of paths, what are each an array of successive Vector3. The pathArray parameter depicts the ribbon geometry\n * * The parameter `closeArray` (boolean, default false) creates a seam between the first and the last paths of the path array\n * * The parameter `closePath` (boolean, default false) creates a seam between the first and the last points of each path of the path array\n * * The parameter `offset` (positive integer, default : rounded half size of the pathArray length), is taken in account only if the `pathArray` is containing a single path\n * * It's the offset to join the points from the same path. Ex : offset = 10 means the point 1 is joined to the point 11\n * * The optional parameter `instance` is an instance of an existing Ribbon object to be updated with the passed `pathArray` parameter : https://doc.babylonjs.com/features/featuresDeepDive/mesh/dynamicMeshMorph#ribbon\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#side-orientation\n * * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture\n * * The parameter `uvs` is an optional flat array of `Vector2` to update/set each ribbon vertex with its own custom UV values instead of the computed ones\n * * The parameters `colors` is an optional flat array of `Color4` to set/update each ribbon vertex with its own custom color values\n * * Note that if you use the parameters `uvs` or `colors`, the passed arrays must be populated with the right number of elements, it is to say the number of ribbon vertices. Remember that if you set `closePath` to `true`, there's one extra vertex per path in the geometry\n * * Moreover, you can use the parameter `color` with `instance` (to update the ribbon), only if you previously used it at creation time\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\n * @param name defines the name of the mesh\n * @param options defines the options used to create the mesh\n * @param options.pathArray\n * @param options.closeArray\n * @param options.closePath\n * @param options.offset\n * @param options.updatable\n * @param options.sideOrientation\n * @param options.frontUVs\n * @param options.backUVs\n * @param options.instance\n * @param options.invertUV\n * @param options.uvs\n * @param options.colors\n * @param scene defines the hosting scene\n * @returns the ribbon mesh\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param/ribbon_extra\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param\n */\nexport function CreateRibbon(name, options, scene = null) {\n    const pathArray = options.pathArray;\n    const closeArray = options.closeArray;\n    const closePath = options.closePath;\n    const sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\n    const instance = options.instance;\n    const updatable = options.updatable;\n    if (instance) {\n        // existing ribbon instance update\n        // positionFunction : ribbon case\n        // only pathArray and sideOrientation parameters are taken into account for positions update\n        const minimum = TmpVectors.Vector3[0].setAll(Number.MAX_VALUE);\n        const maximum = TmpVectors.Vector3[1].setAll(-Number.MAX_VALUE);\n        const positionFunction = (positions) => {\n            let minlg = pathArray[0].length;\n            const mesh = instance;\n            let i = 0;\n            const ns = mesh._originalBuilderSideOrientation === Mesh.DOUBLESIDE ? 2 : 1;\n            for (let si = 1; si <= ns; ++si) {\n                for (let p = 0; p < pathArray.length; ++p) {\n                    const path = pathArray[p];\n                    const l = path.length;\n                    minlg = minlg < l ? minlg : l;\n                    for (let j = 0; j < minlg; ++j) {\n                        const pathPoint = path[j];\n                        positions[i] = pathPoint.x;\n                        positions[i + 1] = pathPoint.y;\n                        positions[i + 2] = pathPoint.z;\n                        minimum.minimizeInPlaceFromFloats(pathPoint.x, pathPoint.y, pathPoint.z);\n                        maximum.maximizeInPlaceFromFloats(pathPoint.x, pathPoint.y, pathPoint.z);\n                        i += 3;\n                    }\n                    if (mesh._creationDataStorage && mesh._creationDataStorage.closePath) {\n                        const pathPoint = path[0];\n                        positions[i] = pathPoint.x;\n                        positions[i + 1] = pathPoint.y;\n                        positions[i + 2] = pathPoint.z;\n                        i += 3;\n                    }\n                }\n            }\n        };\n        const positions = instance.getVerticesData(VertexBuffer.PositionKind);\n        positionFunction(positions);\n        if (instance.hasBoundingInfo) {\n            instance.getBoundingInfo().reConstruct(minimum, maximum, instance._worldMatrix);\n        }\n        else {\n            instance.buildBoundingInfo(minimum, maximum, instance._worldMatrix);\n        }\n        instance.updateVerticesData(VertexBuffer.PositionKind, positions, false, false);\n        if (options.colors) {\n            const colors = instance.getVerticesData(VertexBuffer.ColorKind);\n            for (let c = 0, colorIndex = 0; c < options.colors.length; c++, colorIndex += 4) {\n                const color = options.colors[c];\n                colors[colorIndex] = color.r;\n                colors[colorIndex + 1] = color.g;\n                colors[colorIndex + 2] = color.b;\n                colors[colorIndex + 3] = color.a;\n            }\n            instance.updateVerticesData(VertexBuffer.ColorKind, colors, false, false);\n        }\n        if (options.uvs) {\n            const uvs = instance.getVerticesData(VertexBuffer.UVKind);\n            for (let i = 0; i < options.uvs.length; i++) {\n                uvs[i * 2] = options.uvs[i].x;\n                uvs[i * 2 + 1] = CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 - options.uvs[i].y : options.uvs[i].y;\n            }\n            instance.updateVerticesData(VertexBuffer.UVKind, uvs, false, false);\n        }\n        if (!instance.areNormalsFrozen || instance.isFacetDataEnabled) {\n            const indices = instance.getIndices();\n            const normals = instance.getVerticesData(VertexBuffer.NormalKind);\n            const params = instance.isFacetDataEnabled ? instance.getFacetDataParameters() : null;\n            VertexData.ComputeNormals(positions, indices, normals, params);\n            if (instance._creationDataStorage && instance._creationDataStorage.closePath) {\n                let indexFirst = 0;\n                let indexLast = 0;\n                for (let p = 0; p < pathArray.length; p++) {\n                    indexFirst = instance._creationDataStorage.idx[p] * 3;\n                    if (p + 1 < pathArray.length) {\n                        indexLast = (instance._creationDataStorage.idx[p + 1] - 1) * 3;\n                    }\n                    else {\n                        indexLast = normals.length - 3;\n                    }\n                    normals[indexFirst] = (normals[indexFirst] + normals[indexLast]) * 0.5;\n                    normals[indexFirst + 1] = (normals[indexFirst + 1] + normals[indexLast + 1]) * 0.5;\n                    normals[indexFirst + 2] = (normals[indexFirst + 2] + normals[indexLast + 2]) * 0.5;\n                    normals[indexLast] = normals[indexFirst];\n                    normals[indexLast + 1] = normals[indexFirst + 1];\n                    normals[indexLast + 2] = normals[indexFirst + 2];\n                }\n            }\n            if (!instance.areNormalsFrozen) {\n                instance.updateVerticesData(VertexBuffer.NormalKind, normals, false, false);\n            }\n        }\n        return instance;\n    }\n    else {\n        // new ribbon creation\n        const ribbon = new Mesh(name, scene);\n        ribbon._originalBuilderSideOrientation = sideOrientation;\n        ribbon._creationDataStorage = new _CreationDataStorage();\n        const vertexData = CreateRibbonVertexData(options);\n        if (closePath) {\n            ribbon._creationDataStorage.idx = vertexData._idx;\n        }\n        ribbon._creationDataStorage.closePath = closePath;\n        ribbon._creationDataStorage.closeArray = closeArray;\n        vertexData.applyToMesh(ribbon, updatable);\n        return ribbon;\n    }\n}\n/**\n * Class containing static functions to help procedurally build meshes\n * @deprecated use CreateRibbon directly\n */\nexport const RibbonBuilder = {\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    CreateRibbon,\n};\nVertexData.CreateRibbon = CreateRibbonVertexData;\nMesh.CreateRibbon = (name, pathArray, closeArray = false, closePath, offset, scene, updatable = false, sideOrientation, instance) => {\n    return CreateRibbon(name, {\n        pathArray: pathArray,\n        closeArray: closeArray,\n        closePath: closePath,\n        offset: offset,\n        updatable: updatable,\n        sideOrientation: sideOrientation,\n        instance: instance,\n    }, scene);\n};\n//# sourceMappingURL=ribbonBuilder.js.map","import { Vector3, TmpVectors, Matrix } from \"../../Maths/math.vector.js\";\nimport { Mesh } from \"../mesh.js\";\nimport { CreateRibbon } from \"./ribbonBuilder.js\";\nimport { Path3D } from \"../../Maths/math.path.js\";\n/**\n * Creates an extruded shape mesh. The extrusion is a parametric shape. It has no predefined shape. Its final shape will depend on the input parameters.\n * * The parameter `shape` is a required array of successive Vector3. This array depicts the shape to be extruded in its local space : the shape must be designed in the xOy plane and will be extruded along the Z axis.\n * * The parameter `path` is a required array of successive Vector3. This is the axis curve the shape is extruded along.\n * * The parameter `rotation` (float, default 0 radians) is the angle value to rotate the shape each step (each path point), from the former step (so rotation added each step) along the curve.\n * * The parameter `scale` (float, default 1) is the value to scale the shape.\n * * The parameter `closeShape` (boolean, default false) closes the shape when true, since v5.0.0.\n * * The parameter `closePath` (boolean, default false) closes the path when true and no caps, since v5.0.0.\n * * The parameter `cap` sets the way the extruded shape is capped. Possible values : BABYLON.Mesh.NO_CAP (default), BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL\n * * The optional parameter `instance` is an instance of an existing ExtrudedShape object to be updated with the passed `shape`, `path`, `scale` or `rotation` parameters : https://doc.babylonjs.com/features/featuresDeepDive/mesh/dynamicMeshMorph#extruded-shape\n * * Remember you can only change the shape or path point positions, not their number when updating an extruded shape.\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#side-orientation\n * * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture.\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\n * * The optional parameter `firstNormal` (Vector3) defines the direction of the first normal of the supplied path. Consider using this for any path that is straight, and particular for paths in the xy plane.\n * * The optional `adjustFrame` (boolean, default false) will cause the internally generated Path3D tangents, normals, and binormals to be adjusted so that a) they are always well-defined, and b) they do not reverse from one path point to the next. This prevents the extruded shape from being flipped and/or rotated with resulting mesh self-intersections. This is primarily useful for straight paths that can reverse direction.\n * @param name defines the name of the mesh\n * @param options defines the options used to create the mesh\n * @param options.shape\n * @param options.path\n * @param options.scale\n * @param options.rotation\n * @param options.closeShape\n * @param options.closePath\n * @param options.cap\n * @param options.updatable\n * @param options.sideOrientation\n * @param options.frontUVs\n * @param options.backUVs\n * @param options.instance\n * @param options.invertUV\n * @param options.firstNormal\n * @param options.adjustFrame\n * @param scene defines the hosting scene\n * @returns the extruded shape mesh\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param#extruded-shapes\n */\nexport function ExtrudeShape(name, options, scene = null) {\n    const path = options.path;\n    const shape = options.shape;\n    const scale = options.scale || 1;\n    const rotation = options.rotation || 0;\n    const cap = options.cap === 0 ? 0 : options.cap || Mesh.NO_CAP;\n    const updatable = options.updatable;\n    const sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\n    const instance = options.instance || null;\n    const invertUV = options.invertUV || false;\n    const closeShape = options.closeShape || false;\n    const closePath = options.closePath || false;\n    return _ExtrudeShapeGeneric(name, shape, path, scale, rotation, null, null, closePath, closeShape, cap, false, scene, updatable ? true : false, sideOrientation, instance, invertUV, options.frontUVs || null, options.backUVs || null, options.firstNormal || null, options.adjustFrame ? true : false);\n}\n/**\n * Creates an custom extruded shape mesh.\n * The custom extrusion is a parametric shape. It has no predefined shape. Its final shape will depend on the input parameters.\n * * The parameter `shape` is a required array of successive Vector3. This array depicts the shape to be extruded in its local space : the shape must be designed in the xOy plane and will be extruded along the Z axis.\n * * The parameter `path` is a required array of successive Vector3. This is the axis curve the shape is extruded along.\n * * The parameter `rotationFunction` (JS function) is a custom Javascript function called on each path point. This function is passed the position i of the point in the path and the distance of this point from the beginning of the path\n * * It must returns a float value that will be the rotation in radians applied to the shape on each path point.\n * * The parameter `scaleFunction` (JS function) is a custom Javascript function called on each path point. This function is passed the position i of the point in the path and the distance of this point from the beginning of the path\n * * It must returns a float value that will be the scale value applied to the shape on each path point\n * * The parameter `closeShape` (boolean, default false) closes the shape when true, since v5.0.0.\n * * The parameter `closePath` (boolean, default false) closes the path when true and no caps, since v5.0.0.\n * * The parameter `ribbonClosePath` (boolean, default false) forces the extrusion underlying ribbon to close all the paths in its `pathArray` - depreciated in favor of closeShape\n * * The parameter `ribbonCloseArray` (boolean, default false) forces the extrusion underlying ribbon to close its `pathArray` - depreciated in favor of closePath\n * * The parameter `cap` sets the way the extruded shape is capped. Possible values : BABYLON.Mesh.NO_CAP (default), BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL\n * * The optional parameter `instance` is an instance of an existing ExtrudedShape object to be updated with the passed `shape`, `path`, `scale` or `rotation` parameters : https://doc.babylonjs.com/features/featuresDeepDive/mesh/dynamicMeshMorph#extruded-shape\n * * Remember you can only change the shape or path point positions, not their number when updating an extruded shape\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#side-orientation\n * * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\n * * The optional parameter `firstNormal` (Vector3) defines the direction of the first normal of the supplied path. It should be supplied when the path is in the xy plane, and particularly if these sections are straight, because the underlying Path3D object will pick a normal in the xy plane that causes the extrusion to be collapsed into the plane. This should be used for any path that is straight.\n * * The optional `adjustFrame` (boolean, default false) will cause the internally generated Path3D tangents, normals, and binormals to be adjusted so that a) they are always well-defined, and b) they do not reverse from one path point to the next. This prevents the extruded shape from being flipped and/or rotated with resulting mesh self-intersections. This is primarily useful for straight paths that can reverse direction.\n * @param name defines the name of the mesh\n * @param options defines the options used to create the mesh\n * @param options.shape\n * @param options.path\n * @param options.scaleFunction\n * @param options.rotationFunction\n * @param options.ribbonCloseArray\n * @param options.ribbonClosePath\n * @param options.closeShape\n * @param options.closePath\n * @param options.cap\n * @param options.updatable\n * @param options.sideOrientation\n * @param options.frontUVs\n * @param options.backUVs\n * @param options.instance\n * @param options.invertUV\n * @param options.firstNormal\n * @param options.adjustFrame\n * @param scene defines the hosting scene\n * @returns the custom extruded shape mesh\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param#custom-extruded-shapes\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param#extruded-shapes\n */\nexport function ExtrudeShapeCustom(name, options, scene = null) {\n    const path = options.path;\n    const shape = options.shape;\n    const scaleFunction = options.scaleFunction ||\n        (() => {\n            return 1;\n        });\n    const rotationFunction = options.rotationFunction ||\n        (() => {\n            return 0;\n        });\n    const ribbonCloseArray = options.closePath || options.ribbonCloseArray || false;\n    const ribbonClosePath = options.closeShape || options.ribbonClosePath || false;\n    const cap = options.cap === 0 ? 0 : options.cap || Mesh.NO_CAP;\n    const updatable = options.updatable;\n    const firstNormal = options.firstNormal || null;\n    const adjustFrame = options.adjustFrame || false;\n    const sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\n    const instance = options.instance;\n    const invertUV = options.invertUV || false;\n    return _ExtrudeShapeGeneric(name, shape, path, null, null, scaleFunction, rotationFunction, ribbonCloseArray, ribbonClosePath, cap, true, scene, updatable ? true : false, sideOrientation, instance || null, invertUV, options.frontUVs || null, options.backUVs || null, firstNormal, adjustFrame);\n}\nfunction _ExtrudeShapeGeneric(name, shape, curve, scale, rotation, scaleFunction, rotateFunction, rbCA, rbCP, cap, custom, scene, updtbl, side, instance, invertUV, frontUVs, backUVs, firstNormal, adjustFrame) {\n    // extrusion geometry\n    const extrusionPathArray = (shape, curve, path3D, shapePaths, scale, rotation, scaleFunction, rotateFunction, cap, custom, adjustFrame) => {\n        const tangents = path3D.getTangents();\n        const normals = path3D.getNormals();\n        const binormals = path3D.getBinormals();\n        const distances = path3D.getDistances();\n        if (adjustFrame) {\n            /* fix tangents,normals, binormals */\n            for (let i = 0; i < tangents.length; i++) {\n                if (tangents[i].x == 0 && tangents[i].y == 0 && tangents[i].z == 0) {\n                    tangents[i].copyFrom(tangents[i - 1]);\n                }\n                if (normals[i].x == 0 && normals[i].y == 0 && normals[i].z == 0) {\n                    normals[i].copyFrom(normals[i - 1]);\n                }\n                if (binormals[i].x == 0 && binormals[i].y == 0 && binormals[i].z == 0) {\n                    binormals[i].copyFrom(binormals[i - 1]);\n                }\n                if (i > 0) {\n                    let v = tangents[i - 1];\n                    if (Vector3.Dot(v, tangents[i]) < 0) {\n                        tangents[i].scaleInPlace(-1);\n                    }\n                    v = normals[i - 1];\n                    if (Vector3.Dot(v, normals[i]) < 0) {\n                        normals[i].scaleInPlace(-1);\n                    }\n                    v = binormals[i - 1];\n                    if (Vector3.Dot(v, binormals[i]) < 0) {\n                        binormals[i].scaleInPlace(-1);\n                    }\n                }\n            }\n        }\n        let angle = 0;\n        const returnScale = () => {\n            return scale !== null ? scale : 1;\n        };\n        const returnRotation = () => {\n            return rotation !== null ? rotation : 0;\n        };\n        const rotate = custom && rotateFunction ? rotateFunction : returnRotation;\n        const scl = custom && scaleFunction ? scaleFunction : returnScale;\n        let index = cap === Mesh.NO_CAP || cap === Mesh.CAP_END ? 0 : 2;\n        const rotationMatrix = TmpVectors.Matrix[0];\n        for (let i = 0; i < curve.length; i++) {\n            const shapePath = new Array();\n            const angleStep = rotate(i, distances[i]);\n            const scaleRatio = scl(i, distances[i]);\n            Matrix.RotationAxisToRef(tangents[i], angle, rotationMatrix);\n            for (let p = 0; p < shape.length; p++) {\n                const planed = tangents[i].scale(shape[p].z).add(normals[i].scale(shape[p].x)).add(binormals[i].scale(shape[p].y));\n                const rotated = Vector3.Zero();\n                Vector3.TransformCoordinatesToRef(planed, rotationMatrix, rotated);\n                rotated.scaleInPlace(scaleRatio).addInPlace(curve[i]);\n                shapePath[p] = rotated;\n            }\n            shapePaths[index] = shapePath;\n            angle += angleStep;\n            index++;\n        }\n        // cap\n        const capPath = (shapePath) => {\n            const pointCap = Array();\n            const barycenter = Vector3.Zero();\n            let i;\n            for (i = 0; i < shapePath.length; i++) {\n                barycenter.addInPlace(shapePath[i]);\n            }\n            barycenter.scaleInPlace(1.0 / shapePath.length);\n            for (i = 0; i < shapePath.length; i++) {\n                pointCap.push(barycenter);\n            }\n            return pointCap;\n        };\n        switch (cap) {\n            case Mesh.NO_CAP:\n                break;\n            case Mesh.CAP_START:\n                shapePaths[0] = capPath(shapePaths[2]);\n                shapePaths[1] = shapePaths[2];\n                break;\n            case Mesh.CAP_END:\n                shapePaths[index] = shapePaths[index - 1];\n                shapePaths[index + 1] = capPath(shapePaths[index - 1]);\n                break;\n            case Mesh.CAP_ALL:\n                shapePaths[0] = capPath(shapePaths[2]);\n                shapePaths[1] = shapePaths[2];\n                shapePaths[index] = shapePaths[index - 1];\n                shapePaths[index + 1] = capPath(shapePaths[index - 1]);\n                break;\n            default:\n                break;\n        }\n        return shapePaths;\n    };\n    let path3D;\n    let pathArray;\n    if (instance) {\n        // instance update\n        const storage = instance._creationDataStorage;\n        path3D = firstNormal ? storage.path3D.update(curve, firstNormal) : storage.path3D.update(curve);\n        pathArray = extrusionPathArray(shape, curve, storage.path3D, storage.pathArray, scale, rotation, scaleFunction, rotateFunction, storage.cap, custom, adjustFrame);\n        instance = CreateRibbon(\"\", { pathArray, closeArray: false, closePath: false, offset: 0, updatable: false, sideOrientation: 0, instance }, scene || undefined);\n        return instance;\n    }\n    // extruded shape creation\n    path3D = firstNormal ? new Path3D(curve, firstNormal) : new Path3D(curve);\n    const newShapePaths = new Array();\n    cap = cap < 0 || cap > 3 ? 0 : cap;\n    pathArray = extrusionPathArray(shape, curve, path3D, newShapePaths, scale, rotation, scaleFunction, rotateFunction, cap, custom, adjustFrame);\n    const extrudedGeneric = CreateRibbon(name, {\n        pathArray: pathArray,\n        closeArray: rbCA,\n        closePath: rbCP,\n        updatable: updtbl,\n        sideOrientation: side,\n        invertUV: invertUV,\n        frontUVs: frontUVs || undefined,\n        backUVs: backUVs || undefined,\n    }, scene);\n    extrudedGeneric._creationDataStorage.pathArray = pathArray;\n    extrudedGeneric._creationDataStorage.path3D = path3D;\n    extrudedGeneric._creationDataStorage.cap = cap;\n    return extrudedGeneric;\n}\n/**\n * Class containing static functions to help procedurally build meshes\n * @deprecated please use the functions directly from the module\n */\nexport const ShapeBuilder = {\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    ExtrudeShape,\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    ExtrudeShapeCustom,\n};\nMesh.ExtrudeShape = (name, shape, path, scale, rotation, cap, scene = null, updatable, sideOrientation, instance) => {\n    const options = {\n        shape: shape,\n        path: path,\n        scale: scale,\n        rotation: rotation,\n        cap: cap === 0 ? 0 : cap || Mesh.NO_CAP,\n        sideOrientation: sideOrientation,\n        instance: instance,\n        updatable: updatable,\n    };\n    return ExtrudeShape(name, options, scene);\n};\nMesh.ExtrudeShapeCustom = (name, shape, path, scaleFunction, rotationFunction, ribbonCloseArray, ribbonClosePath, cap, scene, updatable, sideOrientation, instance) => {\n    const options = {\n        shape: shape,\n        path: path,\n        scaleFunction: scaleFunction,\n        rotationFunction: rotationFunction,\n        ribbonCloseArray: ribbonCloseArray,\n        ribbonClosePath: ribbonClosePath,\n        cap: cap === 0 ? 0 : cap || Mesh.NO_CAP,\n        sideOrientation: sideOrientation,\n        instance: instance,\n        updatable: updatable,\n    };\n    return ExtrudeShapeCustom(name, options, scene);\n};\n//# sourceMappingURL=shapeBuilder.js.map","import { Vector3, Matrix } from \"../../Maths/math.vector.js\";\nimport { Mesh } from \"../mesh.js\";\nimport { VertexData } from \"../mesh.vertexData.js\";\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions.js\";\n/**\n * Creates the VertexData for an ellipsoid, defaults to a sphere\n * @param options an object used to set the following optional parameters for the box, required but can be empty\n * * segments sets the number of horizontal strips optional, default 32\n * * diameter sets the axes dimensions, diameterX, diameterY and diameterZ to the value of diameter, optional default 1\n * * diameterX sets the diameterX (x direction) of the ellipsoid, overwrites the diameterX set by diameter, optional, default diameter\n * * diameterY sets the diameterY (y direction) of the ellipsoid, overwrites the diameterY set by diameter, optional, default diameter\n * * diameterZ sets the diameterZ (z direction) of the ellipsoid, overwrites the diameterZ set by diameter, optional, default diameter\n * * arc a number from 0 to 1, to create an unclosed ellipsoid based on the fraction of the circumference (latitude) given by the arc value, optional, default 1\n * * slice a number from 0 to 1, to create an unclosed ellipsoid based on the fraction of the height (latitude) given by the arc value, optional, default 1\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\n * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\n * @param options.segments\n * @param options.diameter\n * @param options.diameterX\n * @param options.diameterY\n * @param options.diameterZ\n * @param options.arc\n * @param options.slice\n * @param options.sideOrientation\n * @param options.frontUVs\n * @param options.backUVs\n * @param options.dedupTopBottomIndices\n * @returns the VertexData of the ellipsoid\n */\nexport function CreateSphereVertexData(options) {\n    const segments = options.segments || 32;\n    const diameterX = options.diameterX || options.diameter || 1;\n    const diameterY = options.diameterY || options.diameter || 1;\n    const diameterZ = options.diameterZ || options.diameter || 1;\n    const arc = options.arc && (options.arc <= 0 || options.arc > 1) ? 1.0 : options.arc || 1.0;\n    const slice = options.slice && options.slice <= 0 ? 1.0 : options.slice || 1.0;\n    const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\n    const dedupTopBottomIndices = !!options.dedupTopBottomIndices;\n    const radius = new Vector3(diameterX / 2, diameterY / 2, diameterZ / 2);\n    const totalZRotationSteps = 2 + segments;\n    const totalYRotationSteps = 2 * totalZRotationSteps;\n    const indices = [];\n    const positions = [];\n    const normals = [];\n    const uvs = [];\n    for (let zRotationStep = 0; zRotationStep <= totalZRotationSteps; zRotationStep++) {\n        const normalizedZ = zRotationStep / totalZRotationSteps;\n        const angleZ = normalizedZ * Math.PI * slice;\n        for (let yRotationStep = 0; yRotationStep <= totalYRotationSteps; yRotationStep++) {\n            const normalizedY = yRotationStep / totalYRotationSteps;\n            const angleY = normalizedY * Math.PI * 2 * arc;\n            const rotationZ = Matrix.RotationZ(-angleZ);\n            const rotationY = Matrix.RotationY(angleY);\n            const afterRotZ = Vector3.TransformCoordinates(Vector3.Up(), rotationZ);\n            const complete = Vector3.TransformCoordinates(afterRotZ, rotationY);\n            const vertex = complete.multiply(radius);\n            const normal = complete.divide(radius).normalize();\n            positions.push(vertex.x, vertex.y, vertex.z);\n            normals.push(normal.x, normal.y, normal.z);\n            uvs.push(normalizedY, CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 - normalizedZ : normalizedZ);\n        }\n        if (zRotationStep > 0) {\n            const verticesCount = positions.length / 3;\n            for (let firstIndex = verticesCount - 2 * (totalYRotationSteps + 1); firstIndex + totalYRotationSteps + 2 < verticesCount; firstIndex++) {\n                if (dedupTopBottomIndices) {\n                    if (zRotationStep > 1) {\n                        indices.push(firstIndex);\n                        indices.push(firstIndex + 1);\n                        indices.push(firstIndex + totalYRotationSteps + 1);\n                    }\n                    if (zRotationStep < totalZRotationSteps || slice < 1.0) {\n                        indices.push(firstIndex + totalYRotationSteps + 1);\n                        indices.push(firstIndex + 1);\n                        indices.push(firstIndex + totalYRotationSteps + 2);\n                    }\n                }\n                else {\n                    indices.push(firstIndex);\n                    indices.push(firstIndex + 1);\n                    indices.push(firstIndex + totalYRotationSteps + 1);\n                    indices.push(firstIndex + totalYRotationSteps + 1);\n                    indices.push(firstIndex + 1);\n                    indices.push(firstIndex + totalYRotationSteps + 2);\n                }\n            }\n        }\n    }\n    // Sides\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\n    // Result\n    const vertexData = new VertexData();\n    vertexData.indices = indices;\n    vertexData.positions = positions;\n    vertexData.normals = normals;\n    vertexData.uvs = uvs;\n    return vertexData;\n}\n/**\n * Creates a sphere mesh\n * * The parameter `diameter` sets the diameter size (float) of the sphere (default 1)\n * * You can set some different sphere dimensions, for instance to build an ellipsoid, by using the parameters `diameterX`, `diameterY` and `diameterZ` (all by default have the same value of `diameter`)\n * * The parameter `segments` sets the sphere number of horizontal stripes (positive integer, default 32)\n * * You can create an unclosed sphere with the parameter `arc` (positive float, default 1), valued between 0 and 1, what is the ratio of the circumference (latitude) : 2 x PI x ratio\n * * You can create an unclosed sphere on its height with the parameter `slice` (positive float, default1), valued between 0 and 1, what is the height ratio (longitude)\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#side-orientation\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\n * @param name defines the name of the mesh\n * @param options defines the options used to create the mesh\n * @param options.segments\n * @param options.diameter\n * @param options.diameterX\n * @param options.diameterY\n * @param options.diameterZ\n * @param options.arc\n * @param options.slice\n * @param options.sideOrientation\n * @param options.frontUVs\n * @param options.backUVs\n * @param options.updatable\n * @param scene defines the hosting scene\n * @returns the sphere mesh\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#sphere\n */\nexport function CreateSphere(name, options = {}, scene = null) {\n    const sphere = new Mesh(name, scene);\n    options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\n    sphere._originalBuilderSideOrientation = options.sideOrientation;\n    const vertexData = CreateSphereVertexData(options);\n    vertexData.applyToMesh(sphere, options.updatable);\n    return sphere;\n}\n/**\n * Class containing static functions to help procedurally build meshes\n * @deprecated use CreateSphere directly\n */\nexport const SphereBuilder = {\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    CreateSphere,\n};\nVertexData.CreateSphere = CreateSphereVertexData;\nMesh.CreateSphere = (name, segments, diameter, scene, updatable, sideOrientation) => {\n    const options = {\n        segments: segments,\n        diameterX: diameter,\n        diameterY: diameter,\n        diameterZ: diameter,\n        sideOrientation: sideOrientation,\n        updatable: updatable,\n    };\n    return CreateSphere(name, options, scene);\n};\n//# sourceMappingURL=sphereBuilder.js.map","import { Matrix, Vector3, Vector4 } from \"../../Maths/math.vector.js\";\nimport { Color4 } from \"../../Maths/math.color.js\";\nimport { Mesh } from \"../mesh.js\";\nimport { VertexData } from \"../mesh.vertexData.js\";\nimport { CreateTiledPlaneVertexData } from \"./tiledPlaneBuilder.js\";\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions.js\";\n/**\n * Creates the VertexData for a tiled box\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set/tiled_box\n * @param options an object used to set the following optional parameters for the tiled box, required but can be empty\n * * pattern sets the rotation or reflection pattern for the tiles,\n * * size of the box\n * * width of the box, overwrites size\n * * height of the box, overwrites size\n * * depth of the box, overwrites size\n * * tileSize sets the size of a tile\n * * tileWidth sets the tile width and overwrites tileSize\n * * tileHeight sets the tile width and overwrites tileSize\n * * faceUV an array of 6 Vector4 elements used to set different images to each box side\n * * faceColors an array of 6 Color3 elements used to set different colors to each box side\n * * alignHorizontal places whole tiles aligned to the center, left or right of a row\n * * alignVertical places whole tiles aligned to the center, left or right of a column\n * @param options.pattern\n * @param options.size\n * @param options.width\n * @param options.height\n * @param options.depth\n * @param options.tileSize\n * @param options.tileWidth\n * @param options.tileHeight\n * @param options.faceUV\n * @param options.faceColors\n * @param options.alignHorizontal\n * @param options.alignVertical\n * @param options.sideOrientation\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n * @returns the VertexData of the TiledBox\n */\nexport function CreateTiledBoxVertexData(options) {\n    const nbFaces = 6;\n    const faceUV = options.faceUV || new Array(6);\n    const faceColors = options.faceColors;\n    const flipTile = options.pattern || Mesh.NO_FLIP;\n    const width = options.width || options.size || 1;\n    const height = options.height || options.size || 1;\n    const depth = options.depth || options.size || 1;\n    const tileWidth = options.tileWidth || options.tileSize || 1;\n    const tileHeight = options.tileHeight || options.tileSize || 1;\n    const alignH = options.alignHorizontal || 0;\n    const alignV = options.alignVertical || 0;\n    const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\n    // default face colors and UV if undefined\n    for (let f = 0; f < nbFaces; f++) {\n        if (faceUV[f] === undefined) {\n            faceUV[f] = new Vector4(0, 0, 1, 1);\n        }\n        if (faceColors && faceColors[f] === undefined) {\n            faceColors[f] = new Color4(1, 1, 1, 1);\n        }\n    }\n    const halfWidth = width / 2;\n    const halfHeight = height / 2;\n    const halfDepth = depth / 2;\n    const faceVertexData = [];\n    for (let f = 0; f < 2; f++) {\n        //front and back\n        faceVertexData[f] = CreateTiledPlaneVertexData({\n            pattern: flipTile,\n            tileWidth: tileWidth,\n            tileHeight: tileHeight,\n            width: width,\n            height: height,\n            alignVertical: alignV,\n            alignHorizontal: alignH,\n            sideOrientation: sideOrientation,\n        });\n    }\n    for (let f = 2; f < 4; f++) {\n        //sides\n        faceVertexData[f] = CreateTiledPlaneVertexData({\n            pattern: flipTile,\n            tileWidth: tileWidth,\n            tileHeight: tileHeight,\n            width: depth,\n            height: height,\n            alignVertical: alignV,\n            alignHorizontal: alignH,\n            sideOrientation: sideOrientation,\n        });\n    }\n    let baseAlignV = alignV;\n    if (alignV === Mesh.BOTTOM) {\n        baseAlignV = Mesh.TOP;\n    }\n    else if (alignV === Mesh.TOP) {\n        baseAlignV = Mesh.BOTTOM;\n    }\n    for (let f = 4; f < 6; f++) {\n        //top and bottom\n        faceVertexData[f] = CreateTiledPlaneVertexData({\n            pattern: flipTile,\n            tileWidth: tileWidth,\n            tileHeight: tileHeight,\n            width: width,\n            height: depth,\n            alignVertical: baseAlignV,\n            alignHorizontal: alignH,\n            sideOrientation: sideOrientation,\n        });\n    }\n    let positions = [];\n    let normals = [];\n    let uvs = [];\n    let indices = [];\n    const colors = [];\n    const facePositions = [];\n    const faceNormals = [];\n    const newFaceUV = [];\n    let lu = 0;\n    let li = 0;\n    for (let f = 0; f < nbFaces; f++) {\n        const len = faceVertexData[f].positions.length;\n        facePositions[f] = [];\n        faceNormals[f] = [];\n        for (let p = 0; p < len / 3; p++) {\n            facePositions[f].push(new Vector3(faceVertexData[f].positions[3 * p], faceVertexData[f].positions[3 * p + 1], faceVertexData[f].positions[3 * p + 2]));\n            faceNormals[f].push(new Vector3(faceVertexData[f].normals[3 * p], faceVertexData[f].normals[3 * p + 1], faceVertexData[f].normals[3 * p + 2]));\n        }\n        // uvs\n        lu = faceVertexData[f].uvs.length;\n        newFaceUV[f] = [];\n        for (let i = 0; i < lu; i += 2) {\n            newFaceUV[f][i] = faceUV[f].x + (faceUV[f].z - faceUV[f].x) * faceVertexData[f].uvs[i];\n            newFaceUV[f][i + 1] = faceUV[f].y + (faceUV[f].w - faceUV[f].y) * faceVertexData[f].uvs[i + 1];\n            if (CompatibilityOptions.UseOpenGLOrientationForUV) {\n                newFaceUV[f][i + 1] = 1.0 - newFaceUV[f][i + 1];\n            }\n        }\n        uvs = uvs.concat(newFaceUV[f]);\n        indices = indices.concat(faceVertexData[f].indices.map((x) => x + li));\n        li += facePositions[f].length;\n        if (faceColors) {\n            for (let c = 0; c < 4; c++) {\n                colors.push(faceColors[f].r, faceColors[f].g, faceColors[f].b, faceColors[f].a);\n            }\n        }\n    }\n    const vec0 = new Vector3(0, 0, halfDepth);\n    const mtrx0 = Matrix.RotationY(Math.PI);\n    positions = facePositions[0]\n        .map((entry) => Vector3.TransformNormal(entry, mtrx0).add(vec0))\n        .map((entry) => [entry.x, entry.y, entry.z])\n        .reduce((accumulator, currentValue) => accumulator.concat(currentValue), []);\n    normals = faceNormals[0]\n        .map((entry) => Vector3.TransformNormal(entry, mtrx0))\n        .map((entry) => [entry.x, entry.y, entry.z])\n        .reduce((accumulator, currentValue) => accumulator.concat(currentValue), []);\n    positions = positions.concat(facePositions[1]\n        .map((entry) => entry.subtract(vec0))\n        .map((entry) => [entry.x, entry.y, entry.z])\n        .reduce((accumulator, currentValue) => accumulator.concat(currentValue), []));\n    normals = normals.concat(faceNormals[1].map((entry) => [entry.x, entry.y, entry.z]).reduce((accumulator, currentValue) => accumulator.concat(currentValue), []));\n    const vec2 = new Vector3(halfWidth, 0, 0);\n    const mtrx2 = Matrix.RotationY(-Math.PI / 2);\n    positions = positions.concat(facePositions[2]\n        .map((entry) => Vector3.TransformNormal(entry, mtrx2).add(vec2))\n        .map((entry) => [entry.x, entry.y, entry.z])\n        .reduce((accumulator, currentValue) => accumulator.concat(currentValue), []));\n    normals = normals.concat(faceNormals[2]\n        .map((entry) => Vector3.TransformNormal(entry, mtrx2))\n        .map((entry) => [entry.x, entry.y, entry.z])\n        .reduce((accumulator, currentValue) => accumulator.concat(currentValue), []));\n    const mtrx3 = Matrix.RotationY(Math.PI / 2);\n    positions = positions.concat(facePositions[3]\n        .map((entry) => Vector3.TransformNormal(entry, mtrx3).subtract(vec2))\n        .map((entry) => [entry.x, entry.y, entry.z])\n        .reduce((accumulator, currentValue) => accumulator.concat(currentValue), []));\n    normals = normals.concat(faceNormals[3]\n        .map((entry) => Vector3.TransformNormal(entry, mtrx3))\n        .map((entry) => [entry.x, entry.y, entry.z])\n        .reduce((accumulator, currentValue) => accumulator.concat(currentValue), []));\n    const vec4 = new Vector3(0, halfHeight, 0);\n    const mtrx4 = Matrix.RotationX(Math.PI / 2);\n    positions = positions.concat(facePositions[4]\n        .map((entry) => Vector3.TransformNormal(entry, mtrx4).add(vec4))\n        .map((entry) => [entry.x, entry.y, entry.z])\n        .reduce((accumulator, currentValue) => accumulator.concat(currentValue), []));\n    normals = normals.concat(faceNormals[4]\n        .map((entry) => Vector3.TransformNormal(entry, mtrx4))\n        .map((entry) => [entry.x, entry.y, entry.z])\n        .reduce((accumulator, currentValue) => accumulator.concat(currentValue), []));\n    const mtrx5 = Matrix.RotationX(-Math.PI / 2);\n    positions = positions.concat(facePositions[5]\n        .map((entry) => Vector3.TransformNormal(entry, mtrx5).subtract(vec4))\n        .map((entry) => [entry.x, entry.y, entry.z])\n        .reduce((accumulator, currentValue) => accumulator.concat(currentValue), []));\n    normals = normals.concat(faceNormals[5]\n        .map((entry) => Vector3.TransformNormal(entry, mtrx5))\n        .map((entry) => [entry.x, entry.y, entry.z])\n        .reduce((accumulator, currentValue) => accumulator.concat(currentValue), []));\n    // sides\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs);\n    // Result\n    const vertexData = new VertexData();\n    vertexData.indices = indices;\n    vertexData.positions = positions;\n    vertexData.normals = normals;\n    vertexData.uvs = uvs;\n    if (faceColors) {\n        const totalColors = sideOrientation === VertexData.DOUBLESIDE ? colors.concat(colors) : colors;\n        vertexData.colors = totalColors;\n    }\n    return vertexData;\n}\n/**\n * Creates a tiled box mesh\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set/tiled_box\n * @param name defines the name of the mesh\n * @param options an object used to set the following optional parameters for the tiled box, required but can be empty\n * * pattern sets the rotation or reflection pattern for the tiles,\n * * size of the box\n * * width of the box, overwrites size\n * * height of the box, overwrites size\n * * depth of the box, overwrites size\n * * tileSize sets the size of a tile\n * * tileWidth sets the tile width and overwrites tileSize\n * * tileHeight sets the tile width and overwrites tileSize\n * * faceUV an array of 6 Vector4 elements used to set different images to each box side\n * * faceColors an array of 6 Color3 elements used to set different colors to each box side\n * * alignHorizontal places whole tiles aligned to the center, left or right of a row\n * * alignVertical places whole tiles aligned to the center, left or right of a column\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n * @param options.pattern\n * @param options.width\n * @param options.height\n * @param options.depth\n * @param options.tileSize\n * @param options.tileWidth\n * @param options.tileHeight\n * @param options.alignHorizontal\n * @param options.alignVertical\n * @param options.faceUV\n * @param options.faceColors\n * @param options.sideOrientation\n * @param options.updatable\n * @param scene defines the hosting scene\n * @returns the box mesh\n */\nexport function CreateTiledBox(name, options, scene = null) {\n    const box = new Mesh(name, scene);\n    options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\n    box._originalBuilderSideOrientation = options.sideOrientation;\n    const vertexData = CreateTiledBoxVertexData(options);\n    vertexData.applyToMesh(box, options.updatable);\n    return box;\n}\n/**\n * Class containing static functions to help procedurally build meshes\n * @deprecated use CreateTiledBox instead\n */\nexport const TiledBoxBuilder = {\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    CreateTiledBox,\n};\nVertexData.CreateTiledBox = CreateTiledBoxVertexData;\n//# sourceMappingURL=tiledBoxBuilder.js.map","import { Mesh } from \"../mesh.js\";\nimport { VertexData } from \"../mesh.vertexData.js\";\n/**\n * Creates the VertexData for a tiled plane\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set/tiled_plane\n * @param options an object used to set the following optional parameters for the tiled plane, required but can be empty\n * * pattern a limited pattern arrangement depending on the number\n * * size of the box\n * * width of the box, overwrites size\n * * height of the box, overwrites size\n * * tileSize sets the width, height and depth of the tile to the value of size, optional default 1\n * * tileWidth sets the width (x direction) of the tile, overwrites the width set by size, optional, default size\n * * tileHeight sets the height (y direction) of the tile, overwrites the height set by size, optional, default size\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n * * alignHorizontal places whole tiles aligned to the center, left or right of a row\n * * alignVertical places whole tiles aligned to the center, left or right of a column\n * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\n * @param options.pattern\n * @param options.tileSize\n * @param options.tileWidth\n * @param options.tileHeight\n * @param options.size\n * @param options.width\n * @param options.height\n * @param options.alignHorizontal\n * @param options.alignVertical\n * @param options.sideOrientation\n * @param options.frontUVs\n * @param options.backUVs\n * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\n * @returns the VertexData of the tiled plane\n */\nexport function CreateTiledPlaneVertexData(options) {\n    const flipTile = options.pattern || Mesh.NO_FLIP;\n    const tileWidth = options.tileWidth || options.tileSize || 1;\n    const tileHeight = options.tileHeight || options.tileSize || 1;\n    const alignH = options.alignHorizontal || 0;\n    const alignV = options.alignVertical || 0;\n    const width = options.width || options.size || 1;\n    const tilesX = Math.floor(width / tileWidth);\n    let offsetX = width - tilesX * tileWidth;\n    const height = options.height || options.size || 1;\n    const tilesY = Math.floor(height / tileHeight);\n    let offsetY = height - tilesY * tileHeight;\n    const halfWidth = (tileWidth * tilesX) / 2;\n    const halfHeight = (tileHeight * tilesY) / 2;\n    let adjustX = 0;\n    let adjustY = 0;\n    let startX = 0;\n    let startY = 0;\n    let endX = 0;\n    let endY = 0;\n    //Part Tiles\n    if (offsetX > 0 || offsetY > 0) {\n        startX = -halfWidth;\n        startY = -halfHeight;\n        endX = halfWidth;\n        endY = halfHeight;\n        switch (alignH) {\n            case Mesh.CENTER:\n                offsetX /= 2;\n                startX -= offsetX;\n                endX += offsetX;\n                break;\n            case Mesh.LEFT:\n                endX += offsetX;\n                adjustX = -offsetX / 2;\n                break;\n            case Mesh.RIGHT:\n                startX -= offsetX;\n                adjustX = offsetX / 2;\n                break;\n        }\n        switch (alignV) {\n            case Mesh.CENTER:\n                offsetY /= 2;\n                startY -= offsetY;\n                endY += offsetY;\n                break;\n            case Mesh.BOTTOM:\n                endY += offsetY;\n                adjustY = -offsetY / 2;\n                break;\n            case Mesh.TOP:\n                startY -= offsetY;\n                adjustY = offsetY / 2;\n                break;\n        }\n    }\n    const positions = [];\n    const normals = [];\n    const uvBase = [];\n    uvBase[0] = [0, 0, 1, 0, 1, 1, 0, 1];\n    uvBase[1] = [0, 0, 1, 0, 1, 1, 0, 1];\n    if (flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.ROTATE_ROW) {\n        uvBase[1] = [1, 1, 0, 1, 0, 0, 1, 0];\n    }\n    if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.FLIP_ROW) {\n        uvBase[1] = [1, 0, 0, 0, 0, 1, 1, 1];\n    }\n    if (flipTile === Mesh.FLIP_N_ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_ROW) {\n        uvBase[1] = [0, 1, 1, 1, 1, 0, 0, 0];\n    }\n    let uvs = [];\n    const colors = [];\n    const indices = [];\n    let index = 0;\n    for (let y = 0; y < tilesY; y++) {\n        for (let x = 0; x < tilesX; x++) {\n            positions.push(-halfWidth + x * tileWidth + adjustX, -halfHeight + y * tileHeight + adjustY, 0);\n            positions.push(-halfWidth + (x + 1) * tileWidth + adjustX, -halfHeight + y * tileHeight + adjustY, 0);\n            positions.push(-halfWidth + (x + 1) * tileWidth + adjustX, -halfHeight + (y + 1) * tileHeight + adjustY, 0);\n            positions.push(-halfWidth + x * tileWidth + adjustX, -halfHeight + (y + 1) * tileHeight + adjustY, 0);\n            indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);\n            if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_TILE) {\n                uvs = uvs.concat(uvBase[((x % 2) + (y % 2)) % 2]);\n            }\n            else if (flipTile === Mesh.FLIP_ROW || flipTile === Mesh.ROTATE_ROW || flipTile === Mesh.FLIP_N_ROTATE_ROW) {\n                uvs = uvs.concat(uvBase[y % 2]);\n            }\n            else {\n                uvs = uvs.concat(uvBase[0]);\n            }\n            colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);\n            normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);\n            index += 4;\n        }\n    }\n    //Part Tiles\n    if (offsetX > 0 || offsetY > 0) {\n        const partialBottomRow = offsetY > 0 && (alignV === Mesh.CENTER || alignV === Mesh.TOP);\n        const partialTopRow = offsetY > 0 && (alignV === Mesh.CENTER || alignV === Mesh.BOTTOM);\n        const partialLeftCol = offsetX > 0 && (alignH === Mesh.CENTER || alignH === Mesh.RIGHT);\n        const partialRightCol = offsetX > 0 && (alignH === Mesh.CENTER || alignH === Mesh.LEFT);\n        let uvPart = [];\n        let a, b, c, d;\n        //corners\n        if (partialBottomRow && partialLeftCol) {\n            //bottom left corner\n            positions.push(startX + adjustX, startY + adjustY, 0);\n            positions.push(-halfWidth + adjustX, startY + adjustY, 0);\n            positions.push(-halfWidth + adjustX, startY + offsetY + adjustY, 0);\n            positions.push(startX + adjustX, startY + offsetY + adjustY, 0);\n            indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);\n            index += 4;\n            a = 1 - offsetX / tileWidth;\n            b = 1 - offsetY / tileHeight;\n            c = 1;\n            d = 1;\n            uvPart = [a, b, c, b, c, d, a, d];\n            if (flipTile === Mesh.ROTATE_ROW) {\n                uvPart = [1 - a, 1 - b, 1 - c, 1 - b, 1 - c, 1 - d, 1 - a, 1 - d];\n            }\n            if (flipTile === Mesh.FLIP_ROW) {\n                uvPart = [1 - a, b, 1 - c, b, 1 - c, d, 1 - a, d];\n            }\n            if (flipTile === Mesh.FLIP_N_ROTATE_ROW) {\n                uvPart = [a, 1 - b, c, 1 - b, c, 1 - d, a, 1 - d];\n            }\n            uvs = uvs.concat(uvPart);\n            colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);\n            normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);\n        }\n        if (partialBottomRow && partialRightCol) {\n            //bottom right corner\n            positions.push(halfWidth + adjustX, startY + adjustY, 0);\n            positions.push(endX + adjustX, startY + adjustY, 0);\n            positions.push(endX + adjustX, startY + offsetY + adjustY, 0);\n            positions.push(halfWidth + adjustX, startY + offsetY + adjustY, 0);\n            indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);\n            index += 4;\n            a = 0;\n            b = 1 - offsetY / tileHeight;\n            c = offsetX / tileWidth;\n            d = 1;\n            uvPart = [a, b, c, b, c, d, a, d];\n            if (flipTile === Mesh.ROTATE_ROW || (flipTile === Mesh.ROTATE_TILE && tilesX % 2 === 0)) {\n                uvPart = [1 - a, 1 - b, 1 - c, 1 - b, 1 - c, 1 - d, 1 - a, 1 - d];\n            }\n            if (flipTile === Mesh.FLIP_ROW || (flipTile === Mesh.FLIP_TILE && tilesX % 2 === 0)) {\n                uvPart = [1 - a, b, 1 - c, b, 1 - c, d, 1 - a, d];\n            }\n            if (flipTile === Mesh.FLIP_N_ROTATE_ROW || (flipTile === Mesh.FLIP_N_ROTATE_TILE && tilesX % 2 === 0)) {\n                uvPart = [a, 1 - b, c, 1 - b, c, 1 - d, a, 1 - d];\n            }\n            uvs = uvs.concat(uvPart);\n            colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);\n            normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);\n        }\n        if (partialTopRow && partialLeftCol) {\n            //top left corner\n            positions.push(startX + adjustX, halfHeight + adjustY, 0);\n            positions.push(-halfWidth + adjustX, halfHeight + adjustY, 0);\n            positions.push(-halfWidth + adjustX, endY + adjustY, 0);\n            positions.push(startX + adjustX, endY + adjustY, 0);\n            indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);\n            index += 4;\n            a = 1 - offsetX / tileWidth;\n            b = 0;\n            c = 1;\n            d = offsetY / tileHeight;\n            uvPart = [a, b, c, b, c, d, a, d];\n            if ((flipTile === Mesh.ROTATE_ROW && tilesY % 2 === 1) || (flipTile === Mesh.ROTATE_TILE && tilesY % 1 === 0)) {\n                uvPart = [1 - a, 1 - b, 1 - c, 1 - b, 1 - c, 1 - d, 1 - a, 1 - d];\n            }\n            if ((flipTile === Mesh.FLIP_ROW && tilesY % 2 === 1) || (flipTile === Mesh.FLIP_TILE && tilesY % 2 === 0)) {\n                uvPart = [1 - a, b, 1 - c, b, 1 - c, d, 1 - a, d];\n            }\n            if ((flipTile === Mesh.FLIP_N_ROTATE_ROW && tilesY % 2 === 1) || (flipTile === Mesh.FLIP_N_ROTATE_TILE && tilesY % 2 === 0)) {\n                uvPart = [a, 1 - b, c, 1 - b, c, 1 - d, a, 1 - d];\n            }\n            uvs = uvs.concat(uvPart);\n            colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);\n            normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);\n        }\n        if (partialTopRow && partialRightCol) {\n            //top right corner\n            positions.push(halfWidth + adjustX, halfHeight + adjustY, 0);\n            positions.push(endX + adjustX, halfHeight + adjustY, 0);\n            positions.push(endX + adjustX, endY + adjustY, 0);\n            positions.push(halfWidth + adjustX, endY + adjustY, 0);\n            indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);\n            index += 4;\n            a = 0;\n            b = 0;\n            c = offsetX / tileWidth;\n            d = offsetY / tileHeight;\n            uvPart = [a, b, c, b, c, d, a, d];\n            if ((flipTile === Mesh.ROTATE_ROW && tilesY % 2 === 1) || (flipTile === Mesh.ROTATE_TILE && (tilesY + tilesX) % 2 === 1)) {\n                uvPart = [1 - a, 1 - b, 1 - c, 1 - b, 1 - c, 1 - d, 1 - a, 1 - d];\n            }\n            if ((flipTile === Mesh.FLIP_ROW && tilesY % 2 === 1) || (flipTile === Mesh.FLIP_TILE && (tilesY + tilesX) % 2 === 1)) {\n                uvPart = [1 - a, b, 1 - c, b, 1 - c, d, 1 - a, d];\n            }\n            if ((flipTile === Mesh.FLIP_N_ROTATE_ROW && tilesY % 2 === 1) || (flipTile === Mesh.FLIP_N_ROTATE_TILE && (tilesY + tilesX) % 2 === 1)) {\n                uvPart = [a, 1 - b, c, 1 - b, c, 1 - d, a, 1 - d];\n            }\n            uvs = uvs.concat(uvPart);\n            colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);\n            normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);\n        }\n        //part rows\n        if (partialBottomRow) {\n            const uvBaseBR = [];\n            a = 0;\n            b = 1 - offsetY / tileHeight;\n            c = 1;\n            d = 1;\n            uvBaseBR[0] = [a, b, c, b, c, d, a, d];\n            uvBaseBR[1] = [a, b, c, b, c, d, a, d];\n            if (flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.ROTATE_ROW) {\n                uvBaseBR[1] = [1 - a, 1 - b, 1 - c, 1 - b, 1 - c, 1 - d, 1 - a, 1 - d];\n            }\n            if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.FLIP_ROW) {\n                uvBaseBR[1] = [1 - a, b, 1 - c, b, 1 - c, d, 1 - a, d];\n            }\n            if (flipTile === Mesh.FLIP_N_ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_ROW) {\n                uvBaseBR[1] = [a, 1 - b, c, 1 - b, c, 1 - d, a, 1 - d];\n            }\n            for (let x = 0; x < tilesX; x++) {\n                positions.push(-halfWidth + x * tileWidth + adjustX, startY + adjustY, 0);\n                positions.push(-halfWidth + (x + 1) * tileWidth + adjustX, startY + adjustY, 0);\n                positions.push(-halfWidth + (x + 1) * tileWidth + adjustX, startY + offsetY + adjustY, 0);\n                positions.push(-halfWidth + x * tileWidth + adjustX, startY + offsetY + adjustY, 0);\n                indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);\n                index += 4;\n                if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_TILE) {\n                    uvs = uvs.concat(uvBaseBR[(x + 1) % 2]);\n                }\n                else if (flipTile === Mesh.FLIP_ROW || flipTile === Mesh.ROTATE_ROW || flipTile === Mesh.FLIP_N_ROTATE_ROW) {\n                    uvs = uvs.concat(uvBaseBR[1]);\n                }\n                else {\n                    uvs = uvs.concat(uvBaseBR[0]);\n                }\n                colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);\n                normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);\n            }\n        }\n        if (partialTopRow) {\n            const uvBaseTR = [];\n            a = 0;\n            b = 0;\n            c = 1;\n            d = offsetY / tileHeight;\n            uvBaseTR[0] = [a, b, c, b, c, d, a, d];\n            uvBaseTR[1] = [a, b, c, b, c, d, a, d];\n            if (flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.ROTATE_ROW) {\n                uvBaseTR[1] = [1 - a, 1 - b, 1 - c, 1 - b, 1 - c, 1 - d, 1 - a, 1 - d];\n            }\n            if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.FLIP_ROW) {\n                uvBaseTR[1] = [1 - a, b, 1 - c, b, 1 - c, d, 1 - a, d];\n            }\n            if (flipTile === Mesh.FLIP_N_ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_ROW) {\n                uvBaseTR[1] = [a, 1 - b, c, 1 - b, c, 1 - d, a, 1 - d];\n            }\n            for (let x = 0; x < tilesX; x++) {\n                positions.push(-halfWidth + x * tileWidth + adjustX, endY - offsetY + adjustY, 0);\n                positions.push(-halfWidth + (x + 1) * tileWidth + adjustX, endY - offsetY + adjustY, 0);\n                positions.push(-halfWidth + (x + 1) * tileWidth + adjustX, endY + adjustY, 0);\n                positions.push(-halfWidth + x * tileWidth + adjustX, endY + adjustY, 0);\n                indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);\n                index += 4;\n                if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_TILE) {\n                    uvs = uvs.concat(uvBaseTR[(x + tilesY) % 2]);\n                }\n                else if (flipTile === Mesh.FLIP_ROW || flipTile === Mesh.ROTATE_ROW || flipTile === Mesh.FLIP_N_ROTATE_ROW) {\n                    uvs = uvs.concat(uvBaseTR[tilesY % 2]);\n                }\n                else {\n                    uvs = uvs.concat(uvBaseTR[0]);\n                }\n                colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);\n                normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);\n            }\n        }\n        if (partialLeftCol) {\n            const uvBaseLC = [];\n            a = 1 - offsetX / tileWidth;\n            b = 0;\n            c = 1;\n            d = 1;\n            uvBaseLC[0] = [a, b, c, b, c, d, a, d];\n            uvBaseLC[1] = [a, b, c, b, c, d, a, d];\n            if (flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.ROTATE_ROW) {\n                uvBaseLC[1] = [1 - a, 1 - b, 1 - c, 1 - b, 1 - c, 1 - d, 1 - a, 1 - d];\n            }\n            if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.FLIP_ROW) {\n                uvBaseLC[1] = [1 - a, b, 1 - c, b, 1 - c, d, 1 - a, d];\n            }\n            if (flipTile === Mesh.FLIP_N_ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_ROW) {\n                uvBaseLC[1] = [a, 1 - b, c, 1 - b, c, 1 - d, a, 1 - d];\n            }\n            for (let y = 0; y < tilesY; y++) {\n                positions.push(startX + adjustX, -halfHeight + y * tileHeight + adjustY, 0);\n                positions.push(startX + offsetX + adjustX, -halfHeight + y * tileHeight + adjustY, 0);\n                positions.push(startX + offsetX + adjustX, -halfHeight + (y + 1) * tileHeight + adjustY, 0);\n                positions.push(startX + adjustX, -halfHeight + (y + 1) * tileHeight + adjustY, 0);\n                indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);\n                index += 4;\n                if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_TILE) {\n                    uvs = uvs.concat(uvBaseLC[(y + 1) % 2]);\n                }\n                else if (flipTile === Mesh.FLIP_ROW || flipTile === Mesh.ROTATE_ROW || flipTile === Mesh.FLIP_N_ROTATE_ROW) {\n                    uvs = uvs.concat(uvBaseLC[y % 2]);\n                }\n                else {\n                    uvs = uvs.concat(uvBaseLC[0]);\n                }\n                colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);\n                normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);\n            }\n        }\n        if (partialRightCol) {\n            const uvBaseRC = [];\n            a = 0;\n            b = 0;\n            c = offsetX / tileHeight;\n            d = 1;\n            uvBaseRC[0] = [a, b, c, b, c, d, a, d];\n            uvBaseRC[1] = [a, b, c, b, c, d, a, d];\n            if (flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.ROTATE_ROW) {\n                uvBaseRC[1] = [1 - a, 1 - b, 1 - c, 1 - b, 1 - c, 1 - d, 1 - a, 1 - d];\n            }\n            if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.FLIP_ROW) {\n                uvBaseRC[1] = [1 - a, b, 1 - c, b, 1 - c, d, 1 - a, d];\n            }\n            if (flipTile === Mesh.FLIP_N_ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_ROW) {\n                uvBaseRC[1] = [a, 1 - b, c, 1 - b, c, 1 - d, a, 1 - d];\n            }\n            for (let y = 0; y < tilesY; y++) {\n                positions.push(endX - offsetX + adjustX, -halfHeight + y * tileHeight + adjustY, 0);\n                positions.push(endX + adjustX, -halfHeight + y * tileHeight + adjustY, 0);\n                positions.push(endX + adjustX, -halfHeight + (y + 1) * tileHeight + adjustY, 0);\n                positions.push(endX - offsetX + adjustX, -halfHeight + (y + 1) * tileHeight + adjustY, 0);\n                indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);\n                index += 4;\n                if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_TILE) {\n                    uvs = uvs.concat(uvBaseRC[(y + tilesX) % 2]);\n                }\n                else if (flipTile === Mesh.FLIP_ROW || flipTile === Mesh.ROTATE_ROW || flipTile === Mesh.FLIP_N_ROTATE_ROW) {\n                    uvs = uvs.concat(uvBaseRC[y % 2]);\n                }\n                else {\n                    uvs = uvs.concat(uvBaseRC[0]);\n                }\n                colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);\n                normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);\n            }\n        }\n    }\n    const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\n    // sides\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\n    // Result\n    const vertexData = new VertexData();\n    vertexData.indices = indices;\n    vertexData.positions = positions;\n    vertexData.normals = normals;\n    vertexData.uvs = uvs;\n    const totalColors = sideOrientation === VertexData.DOUBLESIDE ? colors.concat(colors) : colors;\n    vertexData.colors = totalColors;\n    return vertexData;\n}\n/**\n * Creates a tiled plane mesh\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set/tiled_plane\n * @param name defines the name of the mesh\n * @param options an object used to set the following optional parameters for the tiled plane, required but can be empty\n * * pattern a limited pattern arrangement depending on the number\n * * size of the box\n * * width of the box, overwrites size\n * * height of the box, overwrites size\n * * tileSize sets the width, height and depth of the tile to the value of size, optional default 1\n * * tileWidth sets the width (x direction) of the tile, overwrites the width set by size, optional, default size\n * * tileHeight sets the height (y direction) of the tile, overwrites the height set by size, optional, default size\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n * * alignHorizontal places whole tiles aligned to the center, left or right of a row\n * * alignVertical places whole tiles aligned to the center, left or right of a column\n * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\n * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\n * @param options.pattern\n * @param options.tileSize\n * @param options.tileWidth\n * @param options.tileHeight\n * @param options.size\n * @param options.width\n * @param options.height\n * @param options.alignHorizontal\n * @param options.alignVertical\n * @param options.sideOrientation\n * @param options.frontUVs\n * @param options.backUVs\n * @param options.updatable\n * @param scene defines the hosting scene\n * @returns the box mesh\n */\nexport function CreateTiledPlane(name, options, scene = null) {\n    const plane = new Mesh(name, scene);\n    options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\n    plane._originalBuilderSideOrientation = options.sideOrientation;\n    const vertexData = CreateTiledPlaneVertexData(options);\n    vertexData.applyToMesh(plane, options.updatable);\n    return plane;\n}\n/**\n * Class containing static functions to help procedurally build meshes\n * @deprecated use CreateTiledPlane instead\n */\nexport const TiledPlaneBuilder = {\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    CreateTiledPlane,\n};\nVertexData.CreateTiledPlane = CreateTiledPlaneVertexData;\n//# sourceMappingURL=tiledPlaneBuilder.js.map","import { Matrix, Vector3, Vector2 } from \"../../Maths/math.vector.js\";\nimport { Mesh } from \"../mesh.js\";\nimport { VertexData } from \"../mesh.vertexData.js\";\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions.js\";\n/**\n * Creates the VertexData for a torus\n * @param options an object used to set the following optional parameters for the box, required but can be empty\n * * diameter the diameter of the torus, optional default 1\n * * thickness the diameter of the tube forming the torus, optional default 0.5\n * * tessellation the number of prism sides, 3 for a triangular prism, optional, default 24\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\n * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\n * @param options.diameter\n * @param options.thickness\n * @param options.tessellation\n * @param options.sideOrientation\n * @param options.frontUVs\n * @param options.backUVs\n * @returns the VertexData of the torus\n */\nexport function CreateTorusVertexData(options) {\n    const indices = [];\n    const positions = [];\n    const normals = [];\n    const uvs = [];\n    const diameter = options.diameter || 1;\n    const thickness = options.thickness || 0.5;\n    const tessellation = options.tessellation || 16;\n    const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\n    const stride = tessellation + 1;\n    for (let i = 0; i <= tessellation; i++) {\n        const u = i / tessellation;\n        const outerAngle = (i * Math.PI * 2.0) / tessellation - Math.PI / 2.0;\n        const transform = Matrix.Translation(diameter / 2.0, 0, 0).multiply(Matrix.RotationY(outerAngle));\n        for (let j = 0; j <= tessellation; j++) {\n            const v = 1 - j / tessellation;\n            const innerAngle = (j * Math.PI * 2.0) / tessellation + Math.PI;\n            const dx = Math.cos(innerAngle);\n            const dy = Math.sin(innerAngle);\n            // Create a vertex.\n            let normal = new Vector3(dx, dy, 0);\n            let position = normal.scale(thickness / 2);\n            const textureCoordinate = new Vector2(u, v);\n            position = Vector3.TransformCoordinates(position, transform);\n            normal = Vector3.TransformNormal(normal, transform);\n            positions.push(position.x, position.y, position.z);\n            normals.push(normal.x, normal.y, normal.z);\n            uvs.push(textureCoordinate.x, CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 - textureCoordinate.y : textureCoordinate.y);\n            // And create indices for two triangles.\n            const nextI = (i + 1) % stride;\n            const nextJ = (j + 1) % stride;\n            indices.push(i * stride + j);\n            indices.push(i * stride + nextJ);\n            indices.push(nextI * stride + j);\n            indices.push(i * stride + nextJ);\n            indices.push(nextI * stride + nextJ);\n            indices.push(nextI * stride + j);\n        }\n    }\n    // Sides\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\n    // Result\n    const vertexData = new VertexData();\n    vertexData.indices = indices;\n    vertexData.positions = positions;\n    vertexData.normals = normals;\n    vertexData.uvs = uvs;\n    return vertexData;\n}\n/**\n * Creates a torus mesh\n * * The parameter `diameter` sets the diameter size (float) of the torus (default 1)\n * * The parameter `thickness` sets the diameter size of the tube of the torus (float, default 0.5)\n * * The parameter `tessellation` sets the number of torus sides (positive integer, default 16)\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#side-orientation\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\n * @param name defines the name of the mesh\n * @param options defines the options used to create the mesh\n * @param options.diameter\n * @param options.thickness\n * @param options.tessellation\n * @param options.updatable\n * @param options.sideOrientation\n * @param options.frontUVs\n * @param options.backUVs\n * @param scene defines the hosting scene\n * @returns the torus mesh\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#torus\n */\nexport function CreateTorus(name, options = {}, scene) {\n    const torus = new Mesh(name, scene);\n    options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\n    torus._originalBuilderSideOrientation = options.sideOrientation;\n    const vertexData = CreateTorusVertexData(options);\n    vertexData.applyToMesh(torus, options.updatable);\n    return torus;\n}\n/**\n * Class containing static functions to help procedurally build meshes\n * @deprecated use CreateTorus instead\n */\nexport const TorusBuilder = {\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    CreateTorus,\n};\nVertexData.CreateTorus = CreateTorusVertexData;\nMesh.CreateTorus = (name, diameter, thickness, tessellation, scene, updatable, sideOrientation) => {\n    const options = {\n        diameter,\n        thickness,\n        tessellation,\n        sideOrientation,\n        updatable,\n    };\n    return CreateTorus(name, options, scene);\n};\n//# sourceMappingURL=torusBuilder.js.map","import { Vector3 } from \"../../Maths/math.vector.js\";\nimport { Mesh } from \"../mesh.js\";\nimport { VertexData } from \"../mesh.vertexData.js\";\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions.js\";\n// based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3D/src/away3d/primitives/TorusKnot.as?spec=svn2473&r=2473\n/**\n * Creates the VertexData for a TorusKnot\n * @param options an object used to set the following optional parameters for the TorusKnot, required but can be empty\n * * radius the radius of the torus knot, optional, default 2\n * * tube the thickness of the tube, optional, default 0.5\n * * radialSegments the number of sides on each tube segments, optional, default 32\n * * tubularSegments the number of tubes to decompose the knot into, optional, default 32\n * * p the number of windings around the z axis, optional,  default 2\n * * q the number of windings around the x axis, optional,  default 3\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\n * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\n * @param options.radius\n * @param options.tube\n * @param options.radialSegments\n * @param options.tubularSegments\n * @param options.p\n * @param options.q\n * @param options.sideOrientation\n * @param options.frontUVs\n * @param options.backUVs\n * @returns the VertexData of the Torus Knot\n */\nexport function CreateTorusKnotVertexData(options) {\n    const indices = new Array();\n    const positions = new Array();\n    const normals = new Array();\n    const uvs = new Array();\n    const radius = options.radius || 2;\n    const tube = options.tube || 0.5;\n    const radialSegments = options.radialSegments || 32;\n    const tubularSegments = options.tubularSegments || 32;\n    const p = options.p || 2;\n    const q = options.q || 3;\n    const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\n    // Helper\n    const getPos = (angle) => {\n        const cu = Math.cos(angle);\n        const su = Math.sin(angle);\n        const quOverP = (q / p) * angle;\n        const cs = Math.cos(quOverP);\n        const tx = radius * (2 + cs) * 0.5 * cu;\n        const ty = radius * (2 + cs) * su * 0.5;\n        const tz = radius * Math.sin(quOverP) * 0.5;\n        return new Vector3(tx, ty, tz);\n    };\n    // Vertices\n    let i;\n    let j;\n    for (i = 0; i <= radialSegments; i++) {\n        const modI = i % radialSegments;\n        const u = (modI / radialSegments) * 2 * p * Math.PI;\n        const p1 = getPos(u);\n        const p2 = getPos(u + 0.01);\n        const tang = p2.subtract(p1);\n        let n = p2.add(p1);\n        const bitan = Vector3.Cross(tang, n);\n        n = Vector3.Cross(bitan, tang);\n        bitan.normalize();\n        n.normalize();\n        for (j = 0; j < tubularSegments; j++) {\n            const modJ = j % tubularSegments;\n            const v = (modJ / tubularSegments) * 2 * Math.PI;\n            const cx = -tube * Math.cos(v);\n            const cy = tube * Math.sin(v);\n            positions.push(p1.x + cx * n.x + cy * bitan.x);\n            positions.push(p1.y + cx * n.y + cy * bitan.y);\n            positions.push(p1.z + cx * n.z + cy * bitan.z);\n            uvs.push(i / radialSegments);\n            uvs.push(CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 - j / tubularSegments : j / tubularSegments);\n        }\n    }\n    for (i = 0; i < radialSegments; i++) {\n        for (j = 0; j < tubularSegments; j++) {\n            const jNext = (j + 1) % tubularSegments;\n            const a = i * tubularSegments + j;\n            const b = (i + 1) * tubularSegments + j;\n            const c = (i + 1) * tubularSegments + jNext;\n            const d = i * tubularSegments + jNext;\n            indices.push(d);\n            indices.push(b);\n            indices.push(a);\n            indices.push(d);\n            indices.push(c);\n            indices.push(b);\n        }\n    }\n    // Normals\n    VertexData.ComputeNormals(positions, indices, normals);\n    // Sides\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\n    // Result\n    const vertexData = new VertexData();\n    vertexData.indices = indices;\n    vertexData.positions = positions;\n    vertexData.normals = normals;\n    vertexData.uvs = uvs;\n    return vertexData;\n}\n/**\n * Creates a torus knot mesh\n * * The parameter `radius` sets the global radius size (float) of the torus knot (default 2)\n * * The parameter `radialSegments` sets the number of sides on each tube segments (positive integer, default 32)\n * * The parameter `tubularSegments` sets the number of tubes to decompose the knot into (positive integer, default 32)\n * * The parameters `p` and `q` are the number of windings on each axis (positive integers, default 2 and 3)\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#side-orientation\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\n * @param name defines the name of the mesh\n * @param options defines the options used to create the mesh\n * @param options.radius\n * @param options.tube\n * @param options.radialSegments\n * @param options.tubularSegments\n * @param options.p\n * @param options.q\n * @param options.updatable\n * @param options.sideOrientation\n * @param options.frontUVs\n * @param options.backUVs\n * @param scene defines the hosting scene\n * @returns the torus knot mesh\n * @see  https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#torus-knot\n */\nexport function CreateTorusKnot(name, options = {}, scene) {\n    const torusKnot = new Mesh(name, scene);\n    options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\n    torusKnot._originalBuilderSideOrientation = options.sideOrientation;\n    const vertexData = CreateTorusKnotVertexData(options);\n    vertexData.applyToMesh(torusKnot, options.updatable);\n    return torusKnot;\n}\n/**\n * Class containing static functions to help procedurally build meshes\n * @deprecated use CreateTorusKnot instead\n */\nexport const TorusKnotBuilder = {\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    CreateTorusKnot,\n};\nVertexData.CreateTorusKnot = CreateTorusKnotVertexData;\nMesh.CreateTorusKnot = (name, radius, tube, radialSegments, tubularSegments, p, q, scene, updatable, sideOrientation) => {\n    const options = {\n        radius,\n        tube,\n        radialSegments,\n        tubularSegments,\n        p,\n        q,\n        sideOrientation,\n        updatable,\n    };\n    return CreateTorusKnot(name, options, scene);\n};\n//# sourceMappingURL=torusKnotBuilder.js.map","import { Vector3, TmpVectors, Matrix } from \"../../Maths/math.vector.js\";\nimport { Mesh } from \"../mesh.js\";\nimport { CreateRibbon } from \"./ribbonBuilder.js\";\nimport { Path3D } from \"../../Maths/math.path.js\";\n/**\n * Creates a tube mesh.\n * The tube is a parametric shape. It has no predefined shape. Its final shape will depend on the input parameters\n * * The parameter `path` is a required array of successive Vector3. It is the curve used as the axis of the tube\n * * The parameter `radius` (positive float, default 1) sets the tube radius size\n * * The parameter `tessellation` (positive float, default 64) is the number of sides on the tubular surface\n * * The parameter `radiusFunction` (javascript function, default null) is a vanilla javascript function. If it is not null, it overrides the parameter `radius`\n * * This function is called on each point of the tube path and is passed the index `i` of the i-th point and the distance of this point from the first point of the path. It must return a radius value (positive float)\n * * The parameter `arc` (positive float, maximum 1, default 1) is the ratio to apply to the tube circumference : 2 x PI x arc\n * * The parameter `cap` sets the way the extruded shape is capped. Possible values : BABYLON.Mesh.NO_CAP (default), BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL\n * * The optional parameter `instance` is an instance of an existing Tube object to be updated with the passed `pathArray` parameter. The `path`Array HAS to have the SAME number of points as the previous one: https://doc.babylonjs.com/features/featuresDeepDive/mesh/dynamicMeshMorph#tube\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#side-orientation\n * * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created. The NUMBER of points CAN'T CHANGE, only their positions.\n * @param name defines the name of the mesh\n * @param options defines the options used to create the mesh\n * @param options.path\n * @param options.radius\n * @param options.tessellation\n * @param options.radiusFunction\n * @param options.cap\n * @param options.arc\n * @param options.updatable\n * @param options.sideOrientation\n * @param options.frontUVs\n * @param options.backUVs\n * @param options.instance\n * @param options.invertUV\n * @param scene defines the hosting scene\n * @returns the tube mesh\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#tube\n */\nexport function CreateTube(name, options, scene = null) {\n    const path = options.path;\n    let instance = options.instance;\n    let radius = 1.0;\n    if (options.radius !== undefined) {\n        radius = options.radius;\n    }\n    else if (instance) {\n        radius = instance._creationDataStorage.radius;\n    }\n    const tessellation = options.tessellation || 64 | 0;\n    const radiusFunction = options.radiusFunction || null;\n    let cap = options.cap || Mesh.NO_CAP;\n    const invertUV = options.invertUV || false;\n    const updatable = options.updatable;\n    const sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\n    options.arc = options.arc && (options.arc <= 0.0 || options.arc > 1.0) ? 1.0 : options.arc || 1.0;\n    // tube geometry\n    const tubePathArray = (path, path3D, circlePaths, radius, tessellation, radiusFunction, cap, arc) => {\n        const tangents = path3D.getTangents();\n        const normals = path3D.getNormals();\n        const distances = path3D.getDistances();\n        const pi2 = Math.PI * 2;\n        const step = (pi2 / tessellation) * arc;\n        const returnRadius = () => radius;\n        const radiusFunctionFinal = radiusFunction || returnRadius;\n        let circlePath;\n        let rad;\n        let normal;\n        let rotated;\n        const rotationMatrix = TmpVectors.Matrix[0];\n        let index = cap === Mesh.NO_CAP || cap === Mesh.CAP_END ? 0 : 2;\n        for (let i = 0; i < path.length; i++) {\n            rad = radiusFunctionFinal(i, distances[i]); // current radius\n            circlePath = Array(); // current circle array\n            normal = normals[i]; // current normal\n            for (let t = 0; t < tessellation; t++) {\n                Matrix.RotationAxisToRef(tangents[i], step * t, rotationMatrix);\n                rotated = circlePath[t] ? circlePath[t] : Vector3.Zero();\n                Vector3.TransformCoordinatesToRef(normal, rotationMatrix, rotated);\n                rotated.scaleInPlace(rad).addInPlace(path[i]);\n                circlePath[t] = rotated;\n            }\n            circlePaths[index] = circlePath;\n            index++;\n        }\n        // cap\n        const capPath = (nbPoints, pathIndex) => {\n            const pointCap = Array();\n            for (let i = 0; i < nbPoints; i++) {\n                pointCap.push(path[pathIndex]);\n            }\n            return pointCap;\n        };\n        switch (cap) {\n            case Mesh.NO_CAP:\n                break;\n            case Mesh.CAP_START:\n                circlePaths[0] = capPath(tessellation, 0);\n                circlePaths[1] = circlePaths[2].slice(0);\n                break;\n            case Mesh.CAP_END:\n                circlePaths[index] = circlePaths[index - 1].slice(0);\n                circlePaths[index + 1] = capPath(tessellation, path.length - 1);\n                break;\n            case Mesh.CAP_ALL:\n                circlePaths[0] = capPath(tessellation, 0);\n                circlePaths[1] = circlePaths[2].slice(0);\n                circlePaths[index] = circlePaths[index - 1].slice(0);\n                circlePaths[index + 1] = capPath(tessellation, path.length - 1);\n                break;\n            default:\n                break;\n        }\n        return circlePaths;\n    };\n    let path3D;\n    let pathArray;\n    if (instance) {\n        // tube update\n        const storage = instance._creationDataStorage;\n        const arc = options.arc || storage.arc;\n        path3D = storage.path3D.update(path);\n        pathArray = tubePathArray(path, path3D, storage.pathArray, radius, storage.tessellation, radiusFunction, storage.cap, arc);\n        instance = CreateRibbon(\"\", { pathArray: pathArray, instance: instance });\n        // Update mode, no need to recreate the storage.\n        storage.path3D = path3D;\n        storage.pathArray = pathArray;\n        storage.arc = arc;\n        storage.radius = radius;\n        return instance;\n    }\n    // tube creation\n    path3D = new Path3D(path);\n    const newPathArray = new Array();\n    cap = cap < 0 || cap > 3 ? 0 : cap;\n    pathArray = tubePathArray(path, path3D, newPathArray, radius, tessellation, radiusFunction, cap, options.arc);\n    const tube = CreateRibbon(name, {\n        pathArray: pathArray,\n        closePath: true,\n        closeArray: false,\n        updatable: updatable,\n        sideOrientation: sideOrientation,\n        invertUV: invertUV,\n        frontUVs: options.frontUVs,\n        backUVs: options.backUVs,\n    }, scene);\n    tube._creationDataStorage.pathArray = pathArray;\n    tube._creationDataStorage.path3D = path3D;\n    tube._creationDataStorage.tessellation = tessellation;\n    tube._creationDataStorage.cap = cap;\n    tube._creationDataStorage.arc = options.arc;\n    tube._creationDataStorage.radius = radius;\n    return tube;\n}\n/**\n * Class containing static functions to help procedurally build meshes\n * @deprecated use CreateTube directly\n */\nexport const TubeBuilder = {\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    CreateTube,\n};\nMesh.CreateTube = (name, path, radius, tessellation, radiusFunction, cap, scene, updatable, sideOrientation, instance) => {\n    const options = {\n        path: path,\n        radius: radius,\n        tessellation: tessellation,\n        radiusFunction: radiusFunction,\n        arc: 1,\n        cap: cap,\n        updatable: updatable,\n        sideOrientation: sideOrientation,\n        instance: instance,\n    };\n    return CreateTube(name, options, scene);\n};\n//# sourceMappingURL=tubeBuilder.js.map","/* eslint-disable @typescript-eslint/naming-convention */\nimport { Tools } from \"../../Misc/tools.js\";\nimport { AutoReleaseWorkerPool } from \"../../Misc/workerPool.js\";\nimport { VertexData } from \"../../Meshes/mesh.vertexData.js\";\nfunction createDecoderAsync(wasmBinary) {\n    return new Promise((resolve) => {\n        DracoDecoderModule({ wasmBinary: wasmBinary }).then((module) => {\n            resolve({ module: module });\n        });\n    });\n}\nfunction decodeMesh(decoderModule, dataView, attributes, onIndicesData, onAttributeData, dividers) {\n    const buffer = new decoderModule.DecoderBuffer();\n    buffer.Init(dataView, dataView.byteLength);\n    const decoder = new decoderModule.Decoder();\n    let geometry;\n    let status;\n    try {\n        const type = decoder.GetEncodedGeometryType(buffer);\n        switch (type) {\n            case decoderModule.TRIANGULAR_MESH:\n                geometry = new decoderModule.Mesh();\n                status = decoder.DecodeBufferToMesh(buffer, geometry);\n                break;\n            case decoderModule.POINT_CLOUD:\n                geometry = new decoderModule.PointCloud();\n                status = decoder.DecodeBufferToPointCloud(buffer, geometry);\n                break;\n            default:\n                throw new Error(`Invalid geometry type ${type}`);\n        }\n        if (!status.ok() || !geometry.ptr) {\n            throw new Error(status.error_msg());\n        }\n        if (type === decoderModule.TRIANGULAR_MESH) {\n            const numFaces = geometry.num_faces();\n            const numIndices = numFaces * 3;\n            const byteLength = numIndices * 4;\n            const ptr = decoderModule._malloc(byteLength);\n            try {\n                decoder.GetTrianglesUInt32Array(geometry, byteLength, ptr);\n                const indices = new Uint32Array(numIndices);\n                indices.set(new Uint32Array(decoderModule.HEAPF32.buffer, ptr, numIndices));\n                onIndicesData(indices);\n            }\n            finally {\n                decoderModule._free(ptr);\n            }\n        }\n        const processAttribute = (kind, attribute, divider = 1) => {\n            const numComponents = attribute.num_components();\n            const numPoints = geometry.num_points();\n            const numValues = numPoints * numComponents;\n            const byteLength = numValues * Float32Array.BYTES_PER_ELEMENT;\n            const ptr = decoderModule._malloc(byteLength);\n            try {\n                decoder.GetAttributeDataArrayForAllPoints(geometry, attribute, decoderModule.DT_FLOAT32, byteLength, ptr);\n                const values = new Float32Array(decoderModule.HEAPF32.buffer, ptr, numValues);\n                if (kind === \"color\" && numComponents === 3) {\n                    const babylonData = new Float32Array(numPoints * 4);\n                    for (let i = 0, j = 0; i < babylonData.length; i += 4, j += numComponents) {\n                        babylonData[i + 0] = values[j + 0];\n                        babylonData[i + 1] = values[j + 1];\n                        babylonData[i + 2] = values[j + 2];\n                        babylonData[i + 3] = 1;\n                    }\n                    onAttributeData(kind, babylonData);\n                }\n                else {\n                    const babylonData = new Float32Array(numValues);\n                    babylonData.set(new Float32Array(decoderModule.HEAPF32.buffer, ptr, numValues));\n                    if (divider !== 1) {\n                        for (let i = 0; i < babylonData.length; i++) {\n                            babylonData[i] = babylonData[i] / divider;\n                        }\n                    }\n                    onAttributeData(kind, babylonData);\n                }\n            }\n            finally {\n                decoderModule._free(ptr);\n            }\n        };\n        if (attributes) {\n            for (const kind in attributes) {\n                const id = attributes[kind];\n                const attribute = decoder.GetAttributeByUniqueId(geometry, id);\n                const divider = (dividers && dividers[kind]) || 1;\n                processAttribute(kind, attribute, divider);\n            }\n        }\n        else {\n            const nativeAttributeTypes = {\n                position: \"POSITION\",\n                normal: \"NORMAL\",\n                color: \"COLOR\",\n                uv: \"TEX_COORD\",\n            };\n            for (const kind in nativeAttributeTypes) {\n                const id = decoder.GetAttributeId(geometry, decoderModule[nativeAttributeTypes[kind]]);\n                if (id !== -1) {\n                    const attribute = decoder.GetAttribute(geometry, id);\n                    processAttribute(kind, attribute);\n                }\n            }\n        }\n    }\n    finally {\n        if (geometry) {\n            decoderModule.destroy(geometry);\n        }\n        decoderModule.destroy(decoder);\n        decoderModule.destroy(buffer);\n    }\n}\n/**\n * The worker function that gets converted to a blob url to pass into a worker.\n */\nfunction worker() {\n    let decoderPromise;\n    onmessage = (event) => {\n        const data = event.data;\n        switch (data.id) {\n            case \"init\": {\n                const decoder = data.decoder;\n                if (decoder.url) {\n                    importScripts(decoder.url);\n                    decoderPromise = DracoDecoderModule({ wasmBinary: decoder.wasmBinary });\n                }\n                postMessage(\"done\");\n                break;\n            }\n            case \"decodeMesh\": {\n                if (!decoderPromise) {\n                    throw new Error(\"Draco decoder module is not available\");\n                }\n                decoderPromise.then((decoder) => {\n                    decodeMesh(decoder, data.dataView, data.attributes, (indices) => {\n                        postMessage({ id: \"indices\", value: indices }, [indices.buffer]);\n                    }, (kind, data) => {\n                        postMessage({ id: kind, value: data }, [data.buffer]);\n                    });\n                    postMessage(\"done\");\n                });\n                break;\n            }\n        }\n    };\n}\n/**\n * Draco compression (https://google.github.io/draco/)\n *\n * This class wraps the Draco module.\n *\n * **Encoder**\n *\n * The encoder is not currently implemented.\n *\n * **Decoder**\n *\n * By default, the configuration points to a copy of the Draco decoder files for glTF from the babylon.js preview cdn https://preview.babylonjs.com/draco_wasm_wrapper_gltf.js.\n *\n * To update the configuration, use the following code:\n * ```javascript\n *     DracoCompression.Configuration = {\n *         decoder: {\n *             wasmUrl: \"<url to the WebAssembly library>\",\n *             wasmBinaryUrl: \"<url to the WebAssembly binary>\",\n *             fallbackUrl: \"<url to the fallback JavaScript library>\",\n *         }\n *     };\n * ```\n *\n * Draco has two versions, one for WebAssembly and one for JavaScript. The decoder configuration can be set to only support WebAssembly or only support the JavaScript version.\n * Decoding will automatically fallback to the JavaScript version if WebAssembly version is not configured or if WebAssembly is not supported by the browser.\n * Use `DracoCompression.DecoderAvailable` to determine if the decoder configuration is available for the current context.\n *\n * To decode Draco compressed data, get the default DracoCompression object and call decodeMeshAsync:\n * ```javascript\n *     var vertexData = await DracoCompression.Default.decodeMeshAsync(data);\n * ```\n *\n * @see https://playground.babylonjs.com/#DMZIBD#0\n */\nexport class DracoCompression {\n    /**\n     * Returns true if the decoder configuration is available.\n     */\n    static get DecoderAvailable() {\n        const decoder = DracoCompression.Configuration.decoder;\n        return !!((decoder.wasmUrl && decoder.wasmBinaryUrl && typeof WebAssembly === \"object\") || decoder.fallbackUrl);\n    }\n    static GetDefaultNumWorkers() {\n        if (typeof navigator !== \"object\" || !navigator.hardwareConcurrency) {\n            return 1;\n        }\n        // Use 50% of the available logical processors but capped at 4.\n        return Math.min(Math.floor(navigator.hardwareConcurrency * 0.5), 4);\n    }\n    /**\n     * Default instance for the draco compression object.\n     */\n    static get Default() {\n        if (!DracoCompression._Default) {\n            DracoCompression._Default = new DracoCompression();\n        }\n        return DracoCompression._Default;\n    }\n    /**\n     * Constructor\n     * @param numWorkers The number of workers for async operations. Specify `0` to disable web workers and run synchronously in the current context.\n     */\n    constructor(numWorkers = DracoCompression.DefaultNumWorkers) {\n        const decoder = DracoCompression.Configuration.decoder;\n        const decoderInfo = decoder.wasmUrl && decoder.wasmBinaryUrl && typeof WebAssembly === \"object\"\n            ? {\n                url: Tools.GetAbsoluteUrl(decoder.wasmUrl),\n                wasmBinaryPromise: Tools.LoadFileAsync(Tools.GetAbsoluteUrl(decoder.wasmBinaryUrl)),\n            }\n            : {\n                url: Tools.GetAbsoluteUrl(decoder.fallbackUrl),\n                wasmBinaryPromise: Promise.resolve(undefined),\n            };\n        if (numWorkers && typeof Worker === \"function\" && typeof URL === \"function\") {\n            this._workerPoolPromise = decoderInfo.wasmBinaryPromise.then((decoderWasmBinary) => {\n                const workerContent = `${decodeMesh}(${worker})()`;\n                const workerBlobUrl = URL.createObjectURL(new Blob([workerContent], { type: \"application/javascript\" }));\n                return new AutoReleaseWorkerPool(numWorkers, () => {\n                    return new Promise((resolve, reject) => {\n                        const worker = new Worker(workerBlobUrl);\n                        const onError = (error) => {\n                            worker.removeEventListener(\"error\", onError);\n                            worker.removeEventListener(\"message\", onMessage);\n                            reject(error);\n                        };\n                        const onMessage = (message) => {\n                            if (message.data === \"done\") {\n                                worker.removeEventListener(\"error\", onError);\n                                worker.removeEventListener(\"message\", onMessage);\n                                resolve(worker);\n                            }\n                        };\n                        worker.addEventListener(\"error\", onError);\n                        worker.addEventListener(\"message\", onMessage);\n                        worker.postMessage({\n                            id: \"init\",\n                            decoder: {\n                                url: decoderInfo.url,\n                                wasmBinary: decoderWasmBinary,\n                            },\n                        });\n                    });\n                });\n            });\n        }\n        else {\n            this._decoderModulePromise = decoderInfo.wasmBinaryPromise.then((decoderWasmBinary) => {\n                if (!decoderInfo.url) {\n                    throw new Error(\"Draco decoder module is not available\");\n                }\n                return Tools.LoadScriptAsync(decoderInfo.url).then(() => {\n                    return createDecoderAsync(decoderWasmBinary);\n                });\n            });\n        }\n    }\n    /**\n     * Stop all async operations and release resources.\n     */\n    dispose() {\n        if (this._workerPoolPromise) {\n            this._workerPoolPromise.then((workerPool) => {\n                workerPool.dispose();\n            });\n        }\n        delete this._workerPoolPromise;\n        delete this._decoderModulePromise;\n    }\n    /**\n     * Returns a promise that resolves when ready. Call this manually to ensure draco compression is ready before use.\n     * @returns a promise that resolves when ready\n     */\n    whenReadyAsync() {\n        if (this._workerPoolPromise) {\n            return this._workerPoolPromise.then(() => { });\n        }\n        if (this._decoderModulePromise) {\n            return this._decoderModulePromise.then(() => { });\n        }\n        return Promise.resolve();\n    }\n    /**\n     * Decode Draco compressed mesh data to vertex data.\n     * @param data The ArrayBuffer or ArrayBufferView for the Draco compression data\n     * @param attributes A map of attributes from vertex buffer kinds to Draco unique ids\n     * @param dividers a list of optional dividers for normalization\n     * @returns A promise that resolves with the decoded vertex data\n     */\n    decodeMeshAsync(data, attributes, dividers) {\n        const dataView = data instanceof ArrayBuffer ? new Uint8Array(data) : data;\n        if (this._workerPoolPromise) {\n            return this._workerPoolPromise.then((workerPool) => {\n                return new Promise((resolve, reject) => {\n                    workerPool.push((worker, onComplete) => {\n                        const vertexData = new VertexData();\n                        const onError = (error) => {\n                            worker.removeEventListener(\"error\", onError);\n                            worker.removeEventListener(\"message\", onMessage);\n                            reject(error);\n                            onComplete();\n                        };\n                        const onMessage = (message) => {\n                            if (message.data === \"done\") {\n                                worker.removeEventListener(\"error\", onError);\n                                worker.removeEventListener(\"message\", onMessage);\n                                resolve(vertexData);\n                                onComplete();\n                            }\n                            else if (message.data.id === \"indices\") {\n                                vertexData.indices = message.data.value;\n                            }\n                            else {\n                                // check normalization\n                                const divider = dividers && dividers[message.data.id] ? dividers[message.data.id] : 1;\n                                if (divider !== 1) {\n                                    // normalize\n                                    for (let i = 0; i < message.data.value.length; i++) {\n                                        message.data.value[i] = message.data.value[i] / divider;\n                                    }\n                                }\n                                vertexData.set(message.data.value, message.data.id);\n                            }\n                        };\n                        worker.addEventListener(\"error\", onError);\n                        worker.addEventListener(\"message\", onMessage);\n                        const dataViewCopy = new Uint8Array(dataView.byteLength);\n                        dataViewCopy.set(new Uint8Array(dataView.buffer, dataView.byteOffset, dataView.byteLength));\n                        worker.postMessage({ id: \"decodeMesh\", dataView: dataViewCopy, attributes: attributes }, [dataViewCopy.buffer]);\n                    });\n                });\n            });\n        }\n        if (this._decoderModulePromise) {\n            return this._decoderModulePromise.then((decoder) => {\n                const vertexData = new VertexData();\n                decodeMesh(decoder.module, dataView, attributes, (indices) => {\n                    vertexData.indices = indices;\n                }, (kind, data) => {\n                    vertexData.set(data, kind);\n                }, dividers);\n                return vertexData;\n            });\n        }\n        throw new Error(\"Draco decoder module is not available\");\n    }\n}\n/**\n * The configuration. Defaults to the following urls:\n * - wasmUrl: \"https://preview.babylonjs.com/draco_wasm_wrapper_gltf.js\"\n * - wasmBinaryUrl: \"https://preview.babylonjs.com/draco_decoder_gltf.wasm\"\n * - fallbackUrl: \"https://preview.babylonjs.com/draco_decoder_gltf.js\"\n */\nDracoCompression.Configuration = {\n    decoder: {\n        wasmUrl: \"https://preview.babylonjs.com/draco_wasm_wrapper_gltf.js\",\n        wasmBinaryUrl: \"https://preview.babylonjs.com/draco_decoder_gltf.wasm\",\n        fallbackUrl: \"https://preview.babylonjs.com/draco_decoder_gltf.js\",\n    },\n};\n/**\n * Default number of workers to create when creating the draco compression object.\n */\nDracoCompression.DefaultNumWorkers = DracoCompression.GetDefaultNumWorkers();\nDracoCompression._Default = null;\n//# sourceMappingURL=dracoCompression.js.map","import { Tools } from \"../../Misc/tools.js\";\n/**\n * Meshopt compression (https://github.com/zeux/meshoptimizer)\n *\n * This class wraps the meshopt library from https://github.com/zeux/meshoptimizer/tree/master/js.\n *\n * **Encoder**\n *\n * The encoder is not currently implemented.\n *\n * **Decoder**\n *\n * By default, the configuration points to a copy of the meshopt files on the Babylon.js preview CDN (e.g. https://preview.babylonjs.com/meshopt_decoder.js).\n *\n * To update the configuration, use the following code:\n * ```javascript\n *     MeshoptCompression.Configuration = {\n *         decoder: {\n *             url: \"<url to the meshopt decoder library>\"\n *         }\n *     };\n * ```\n */\nexport class MeshoptCompression {\n    /**\n     * Default instance for the meshoptimizer object.\n     */\n    static get Default() {\n        if (!MeshoptCompression._Default) {\n            MeshoptCompression._Default = new MeshoptCompression();\n        }\n        return MeshoptCompression._Default;\n    }\n    /**\n     * Constructor\n     */\n    constructor() {\n        const decoder = MeshoptCompression.Configuration.decoder;\n        this._decoderModulePromise = Tools.LoadScriptAsync(Tools.GetAbsoluteUrl(decoder.url)).then(() => {\n            // Wait for WebAssembly compilation before resolving promise\n            return MeshoptDecoder.ready;\n        });\n    }\n    /**\n     * Stop all async operations and release resources.\n     */\n    dispose() {\n        delete this._decoderModulePromise;\n    }\n    /**\n     * Decode meshopt data.\n     * @see https://github.com/zeux/meshoptimizer/tree/master/js#decoder\n     * @param source The input data.\n     * @param count The number of elements.\n     * @param stride The stride in bytes.\n     * @param mode The compression mode.\n     * @param filter The compression filter.\n     * @returns a Promise<Uint8Array> that resolves to the decoded data\n     */\n    decodeGltfBufferAsync(source, count, stride, mode, filter) {\n        return this._decoderModulePromise.then(() => {\n            const result = new Uint8Array(count * stride);\n            MeshoptDecoder.decodeGltfBuffer(result, count, stride, source, mode, filter);\n            return result;\n        });\n    }\n}\n/**\n * The configuration. Defaults to the following:\n * ```javascript\n * decoder: {\n *   url: \"https://preview.babylonjs.com/meshopt_decoder.js\"\n * }\n * ```\n */\nMeshoptCompression.Configuration = {\n    decoder: {\n        url: \"https://preview.babylonjs.com/meshopt_decoder.js\",\n    },\n};\nMeshoptCompression._Default = null;\n//# sourceMappingURL=meshoptCompression.js.map","import { DataBuffer } from \"../../Buffers/dataBuffer.js\";\n/** @internal */\nexport class WebGLDataBuffer extends DataBuffer {\n    constructor(resource) {\n        super();\n        this._buffer = resource;\n    }\n    get underlyingResource() {\n        return this._buffer;\n    }\n}\n//# sourceMappingURL=webGLDataBuffer.js.map","import { DataBuffer } from \"../../Buffers/dataBuffer.js\";\n/** @internal */\nexport class WebGPUDataBuffer extends DataBuffer {\n    constructor(resource) {\n        super();\n        this._buffer = resource;\n    }\n    get underlyingResource() {\n        return this._buffer;\n    }\n}\n//# sourceMappingURL=webgpuDataBuffer.js.map","import { Observable } from \"../Misc/observable.js\";\nimport { ScenePerformancePriority } from \"../scene.js\";\nimport { Quaternion, Matrix, Vector3, TmpVectors } from \"../Maths/math.vector.js\";\nimport { Engine } from \"../Engines/engine.js\";\nimport { VertexBuffer } from \"../Buffers/buffer.js\";\nimport { VertexData } from \"../Meshes/mesh.vertexData.js\";\nimport { TransformNode } from \"../Meshes/transformNode.js\";\nimport { PickingInfo } from \"../Collisions/pickingInfo.js\";\nimport { BoundingInfo } from \"../Culling/boundingInfo.js\";\n\nimport { UniformBuffer } from \"../Materials/uniformBuffer.js\";\nimport { _MeshCollisionData } from \"../Collisions/meshCollisionData.js\";\nimport { _WarnImport } from \"../Misc/devTools.js\";\nimport { extractMinAndMax } from \"../Maths/math.functions.js\";\nimport { Color3, Color4 } from \"../Maths/math.color.js\";\nimport { Epsilon } from \"../Maths/math.constants.js\";\nimport { Axis } from \"../Maths/math.axis.js\";\nimport { RegisterClass } from \"../Misc/typeStore.js\";\n/** @internal */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nclass _FacetDataStorage {\n    constructor() {\n        this.facetNb = 0; // facet number\n        this.partitioningSubdivisions = 10; // number of subdivisions per axis in the partitioning space\n        this.partitioningBBoxRatio = 1.01; // the partitioning array space is by default 1% bigger than the bounding box\n        this.facetDataEnabled = false; // is the facet data feature enabled on this mesh ?\n        this.facetParameters = {}; // keep a reference to the object parameters to avoid memory re-allocation\n        this.bbSize = Vector3.Zero(); // bbox size approximated for facet data\n        this.subDiv = {\n            // actual number of subdivisions per axis for ComputeNormals()\n            max: 1,\n            // eslint-disable-next-line @typescript-eslint/naming-convention\n            X: 1,\n            // eslint-disable-next-line @typescript-eslint/naming-convention\n            Y: 1,\n            // eslint-disable-next-line @typescript-eslint/naming-convention\n            Z: 1,\n        };\n        this.facetDepthSort = false; // is the facet depth sort to be computed\n        this.facetDepthSortEnabled = false; // is the facet depth sort initialized\n    }\n}\n/**\n * @internal\n **/\n// eslint-disable-next-line @typescript-eslint/naming-convention\nclass _InternalAbstractMeshDataInfo {\n    constructor() {\n        this._hasVertexAlpha = false;\n        this._useVertexColors = true;\n        this._numBoneInfluencers = 4;\n        this._applyFog = true;\n        this._receiveShadows = false;\n        this._facetData = new _FacetDataStorage();\n        this._visibility = 1.0;\n        this._skeleton = null;\n        this._layerMask = 0x0fffffff;\n        this._computeBonesUsingShaders = true;\n        this._isActive = false;\n        this._onlyForInstances = false;\n        this._isActiveIntermediate = false;\n        this._onlyForInstancesIntermediate = false;\n        this._actAsRegularMesh = false;\n        this._currentLOD = null;\n        this._currentLODIsUpToDate = false;\n        this._collisionRetryCount = 3;\n        this._morphTargetManager = null;\n        this._renderingGroupId = 0;\n        this._bakedVertexAnimationManager = null;\n        this._material = null;\n        this._positions = null;\n        this._pointerOverDisableMeshTesting = false;\n        // Collisions\n        this._meshCollisionData = new _MeshCollisionData();\n        this._enableDistantPicking = false;\n    }\n}\n/**\n * Class used to store all common mesh properties\n */\nexport class AbstractMesh extends TransformNode {\n    /**\n     * No billboard\n     */\n    static get BILLBOARDMODE_NONE() {\n        return TransformNode.BILLBOARDMODE_NONE;\n    }\n    /** Billboard on X axis */\n    static get BILLBOARDMODE_X() {\n        return TransformNode.BILLBOARDMODE_X;\n    }\n    /** Billboard on Y axis */\n    static get BILLBOARDMODE_Y() {\n        return TransformNode.BILLBOARDMODE_Y;\n    }\n    /** Billboard on Z axis */\n    static get BILLBOARDMODE_Z() {\n        return TransformNode.BILLBOARDMODE_Z;\n    }\n    /** Billboard on all axes */\n    static get BILLBOARDMODE_ALL() {\n        return TransformNode.BILLBOARDMODE_ALL;\n    }\n    /** Billboard on using position instead of orientation */\n    static get BILLBOARDMODE_USE_POSITION() {\n        return TransformNode.BILLBOARDMODE_USE_POSITION;\n    }\n    /**\n     * Gets the number of facets in the mesh\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/facetData#what-is-a-mesh-facet\n     */\n    get facetNb() {\n        return this._internalAbstractMeshDataInfo._facetData.facetNb;\n    }\n    /**\n     * Gets or set the number (integer) of subdivisions per axis in the partitioning space\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/facetData#tweaking-the-partitioning\n     */\n    get partitioningSubdivisions() {\n        return this._internalAbstractMeshDataInfo._facetData.partitioningSubdivisions;\n    }\n    set partitioningSubdivisions(nb) {\n        this._internalAbstractMeshDataInfo._facetData.partitioningSubdivisions = nb;\n    }\n    /**\n     * The ratio (float) to apply to the bounding box size to set to the partitioning space.\n     * Ex : 1.01 (default) the partitioning space is 1% bigger than the bounding box\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/facetData#tweaking-the-partitioning\n     */\n    get partitioningBBoxRatio() {\n        return this._internalAbstractMeshDataInfo._facetData.partitioningBBoxRatio;\n    }\n    set partitioningBBoxRatio(ratio) {\n        this._internalAbstractMeshDataInfo._facetData.partitioningBBoxRatio = ratio;\n    }\n    /**\n     * Gets or sets a boolean indicating that the facets must be depth sorted on next call to `updateFacetData()`.\n     * Works only for updatable meshes.\n     * Doesn't work with multi-materials\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/facetData#facet-depth-sort\n     */\n    get mustDepthSortFacets() {\n        return this._internalAbstractMeshDataInfo._facetData.facetDepthSort;\n    }\n    set mustDepthSortFacets(sort) {\n        this._internalAbstractMeshDataInfo._facetData.facetDepthSort = sort;\n    }\n    /**\n     * The location (Vector3) where the facet depth sort must be computed from.\n     * By default, the active camera position.\n     * Used only when facet depth sort is enabled\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/facetData#facet-depth-sort\n     */\n    get facetDepthSortFrom() {\n        return this._internalAbstractMeshDataInfo._facetData.facetDepthSortFrom;\n    }\n    set facetDepthSortFrom(location) {\n        this._internalAbstractMeshDataInfo._facetData.facetDepthSortFrom = location;\n    }\n    /** number of collision detection tries. Change this value if not all collisions are detected and handled properly */\n    get collisionRetryCount() {\n        return this._internalAbstractMeshDataInfo._collisionRetryCount;\n    }\n    set collisionRetryCount(retryCount) {\n        this._internalAbstractMeshDataInfo._collisionRetryCount = retryCount;\n    }\n    /**\n     * gets a boolean indicating if facetData is enabled\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/facetData#what-is-a-mesh-facet\n     */\n    get isFacetDataEnabled() {\n        return this._internalAbstractMeshDataInfo._facetData.facetDataEnabled;\n    }\n    /**\n     * Gets or sets the morph target manager\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/morphTargets\n     */\n    get morphTargetManager() {\n        return this._internalAbstractMeshDataInfo._morphTargetManager;\n    }\n    set morphTargetManager(value) {\n        if (this._internalAbstractMeshDataInfo._morphTargetManager === value) {\n            return;\n        }\n        this._internalAbstractMeshDataInfo._morphTargetManager = value;\n        this._syncGeometryWithMorphTargetManager();\n    }\n    /**\n     * Gets or sets the baked vertex animation manager\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/baked_texture_animations\n     */\n    get bakedVertexAnimationManager() {\n        return this._internalAbstractMeshDataInfo._bakedVertexAnimationManager;\n    }\n    set bakedVertexAnimationManager(value) {\n        if (this._internalAbstractMeshDataInfo._bakedVertexAnimationManager === value) {\n            return;\n        }\n        this._internalAbstractMeshDataInfo._bakedVertexAnimationManager = value;\n        this._markSubMeshesAsAttributesDirty();\n    }\n    /** @internal */\n    _syncGeometryWithMorphTargetManager() { }\n    /**\n     * @internal\n     */\n    _updateNonUniformScalingState(value) {\n        if (!super._updateNonUniformScalingState(value)) {\n            return false;\n        }\n        this._markSubMeshesAsMiscDirty();\n        return true;\n    }\n    /** Set a function to call when this mesh collides with another one */\n    set onCollide(callback) {\n        if (this._internalAbstractMeshDataInfo._meshCollisionData._onCollideObserver) {\n            this.onCollideObservable.remove(this._internalAbstractMeshDataInfo._meshCollisionData._onCollideObserver);\n        }\n        this._internalAbstractMeshDataInfo._meshCollisionData._onCollideObserver = this.onCollideObservable.add(callback);\n    }\n    /** Set a function to call when the collision's position changes */\n    set onCollisionPositionChange(callback) {\n        if (this._internalAbstractMeshDataInfo._meshCollisionData._onCollisionPositionChangeObserver) {\n            this.onCollisionPositionChangeObservable.remove(this._internalAbstractMeshDataInfo._meshCollisionData._onCollisionPositionChangeObserver);\n        }\n        this._internalAbstractMeshDataInfo._meshCollisionData._onCollisionPositionChangeObserver = this.onCollisionPositionChangeObservable.add(callback);\n    }\n    /**\n     * Gets or sets mesh visibility between 0 and 1 (default is 1)\n     */\n    get visibility() {\n        return this._internalAbstractMeshDataInfo._visibility;\n    }\n    /**\n     * Gets or sets mesh visibility between 0 and 1 (default is 1)\n     */\n    set visibility(value) {\n        if (this._internalAbstractMeshDataInfo._visibility === value) {\n            return;\n        }\n        const oldValue = this._internalAbstractMeshDataInfo._visibility;\n        this._internalAbstractMeshDataInfo._visibility = value;\n        if ((oldValue === 1 && value !== 1) || (oldValue !== 1 && value === 1)) {\n            this._markSubMeshesAsMiscDirty();\n        }\n    }\n    /**\n     * Gets or sets the property which disables the test that is checking that the mesh under the pointer is the same than the previous time we tested for it (default: false).\n     * Set this property to true if you want thin instances picking to be reported accurately when moving over the mesh.\n     * Note that setting this property to true will incur some performance penalties when dealing with pointer events for this mesh so use it sparingly.\n     */\n    get pointerOverDisableMeshTesting() {\n        return this._internalAbstractMeshDataInfo._pointerOverDisableMeshTesting;\n    }\n    set pointerOverDisableMeshTesting(disable) {\n        this._internalAbstractMeshDataInfo._pointerOverDisableMeshTesting = disable;\n    }\n    /**\n     * Specifies the rendering group id for this mesh (0 by default)\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/advanced/transparent_rendering#rendering-groups\n     */\n    get renderingGroupId() {\n        return this._internalAbstractMeshDataInfo._renderingGroupId;\n    }\n    set renderingGroupId(value) {\n        this._internalAbstractMeshDataInfo._renderingGroupId = value;\n    }\n    /** Gets or sets current material */\n    get material() {\n        return this._internalAbstractMeshDataInfo._material;\n    }\n    set material(value) {\n        if (this._internalAbstractMeshDataInfo._material === value) {\n            return;\n        }\n        // remove from material mesh map id needed\n        if (this._internalAbstractMeshDataInfo._material && this._internalAbstractMeshDataInfo._material.meshMap) {\n            this._internalAbstractMeshDataInfo._material.meshMap[this.uniqueId] = undefined;\n        }\n        this._internalAbstractMeshDataInfo._material = value;\n        if (value && value.meshMap) {\n            value.meshMap[this.uniqueId] = this;\n        }\n        if (this.onMaterialChangedObservable.hasObservers()) {\n            this.onMaterialChangedObservable.notifyObservers(this);\n        }\n        if (!this.subMeshes) {\n            return;\n        }\n        this.resetDrawCache();\n        this._unBindEffect();\n    }\n    /**\n     * Gets the material used to render the mesh in a specific render pass\n     * @param renderPassId render pass id\n     * @returns material used for the render pass. If no specific material is used for this render pass, undefined is returned (meaning mesh.material is used for this pass)\n     */\n    getMaterialForRenderPass(renderPassId) {\n        var _a;\n        return (_a = this._internalAbstractMeshDataInfo._materialForRenderPass) === null || _a === void 0 ? void 0 : _a[renderPassId];\n    }\n    /**\n     * Sets the material to be used to render the mesh in a specific render pass\n     * @param renderPassId render pass id\n     * @param material material to use for this render pass. If undefined is passed, no specific material will be used for this render pass but the regular material will be used instead (mesh.material)\n     */\n    setMaterialForRenderPass(renderPassId, material) {\n        this.resetDrawCache(renderPassId);\n        if (!this._internalAbstractMeshDataInfo._materialForRenderPass) {\n            this._internalAbstractMeshDataInfo._materialForRenderPass = [];\n        }\n        this._internalAbstractMeshDataInfo._materialForRenderPass[renderPassId] = material;\n    }\n    /**\n     * Gets or sets a boolean indicating that this mesh can receive realtime shadows\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/lights/shadows\n     */\n    get receiveShadows() {\n        return this._internalAbstractMeshDataInfo._receiveShadows;\n    }\n    set receiveShadows(value) {\n        if (this._internalAbstractMeshDataInfo._receiveShadows === value) {\n            return;\n        }\n        this._internalAbstractMeshDataInfo._receiveShadows = value;\n        this._markSubMeshesAsLightDirty();\n    }\n    /** Gets or sets a boolean indicating that this mesh contains vertex color data with alpha values */\n    get hasVertexAlpha() {\n        return this._internalAbstractMeshDataInfo._hasVertexAlpha;\n    }\n    set hasVertexAlpha(value) {\n        if (this._internalAbstractMeshDataInfo._hasVertexAlpha === value) {\n            return;\n        }\n        this._internalAbstractMeshDataInfo._hasVertexAlpha = value;\n        this._markSubMeshesAsAttributesDirty();\n        this._markSubMeshesAsMiscDirty();\n    }\n    /** Gets or sets a boolean indicating that this mesh needs to use vertex color data to render (if this kind of vertex data is available in the geometry) */\n    get useVertexColors() {\n        return this._internalAbstractMeshDataInfo._useVertexColors;\n    }\n    set useVertexColors(value) {\n        if (this._internalAbstractMeshDataInfo._useVertexColors === value) {\n            return;\n        }\n        this._internalAbstractMeshDataInfo._useVertexColors = value;\n        this._markSubMeshesAsAttributesDirty();\n    }\n    /**\n     * Gets or sets a boolean indicating that bone animations must be computed by the CPU (false by default)\n     */\n    get computeBonesUsingShaders() {\n        return this._internalAbstractMeshDataInfo._computeBonesUsingShaders;\n    }\n    set computeBonesUsingShaders(value) {\n        if (this._internalAbstractMeshDataInfo._computeBonesUsingShaders === value) {\n            return;\n        }\n        this._internalAbstractMeshDataInfo._computeBonesUsingShaders = value;\n        this._markSubMeshesAsAttributesDirty();\n    }\n    /** Gets or sets the number of allowed bone influences per vertex (4 by default) */\n    get numBoneInfluencers() {\n        return this._internalAbstractMeshDataInfo._numBoneInfluencers;\n    }\n    set numBoneInfluencers(value) {\n        if (this._internalAbstractMeshDataInfo._numBoneInfluencers === value) {\n            return;\n        }\n        this._internalAbstractMeshDataInfo._numBoneInfluencers = value;\n        this._markSubMeshesAsAttributesDirty();\n    }\n    /** Gets or sets a boolean indicating that this mesh will allow fog to be rendered on it (true by default) */\n    get applyFog() {\n        return this._internalAbstractMeshDataInfo._applyFog;\n    }\n    set applyFog(value) {\n        if (this._internalAbstractMeshDataInfo._applyFog === value) {\n            return;\n        }\n        this._internalAbstractMeshDataInfo._applyFog = value;\n        this._markSubMeshesAsMiscDirty();\n    }\n    /** When enabled, decompose picking matrices for better precision with large values for mesh position and scling */\n    get enableDistantPicking() {\n        return this._internalAbstractMeshDataInfo._enableDistantPicking;\n    }\n    set enableDistantPicking(value) {\n        this._internalAbstractMeshDataInfo._enableDistantPicking = value;\n    }\n    /**\n     * Gets or sets the current layer mask (default is 0x0FFFFFFF)\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/layerMasksAndMultiCam\n     */\n    get layerMask() {\n        return this._internalAbstractMeshDataInfo._layerMask;\n    }\n    set layerMask(value) {\n        if (value === this._internalAbstractMeshDataInfo._layerMask) {\n            return;\n        }\n        this._internalAbstractMeshDataInfo._layerMask = value;\n        this._resyncLightSources();\n    }\n    /**\n     * Gets or sets a collision mask used to mask collisions (default is -1).\n     * A collision between A and B will happen if A.collisionGroup & b.collisionMask !== 0\n     */\n    get collisionMask() {\n        return this._internalAbstractMeshDataInfo._meshCollisionData._collisionMask;\n    }\n    set collisionMask(mask) {\n        this._internalAbstractMeshDataInfo._meshCollisionData._collisionMask = !isNaN(mask) ? mask : -1;\n    }\n    /**\n     * Gets or sets a collision response flag (default is true).\n     * when collisionResponse is false, events are still triggered but colliding entity has no response\n     * This helps creating trigger volume when user wants collision feedback events but not position/velocity\n     * to respond to the collision.\n     */\n    get collisionResponse() {\n        return this._internalAbstractMeshDataInfo._meshCollisionData._collisionResponse;\n    }\n    set collisionResponse(response) {\n        this._internalAbstractMeshDataInfo._meshCollisionData._collisionResponse = response;\n    }\n    /**\n     * Gets or sets the current collision group mask (-1 by default).\n     * A collision between A and B will happen if A.collisionGroup & b.collisionMask !== 0\n     */\n    get collisionGroup() {\n        return this._internalAbstractMeshDataInfo._meshCollisionData._collisionGroup;\n    }\n    set collisionGroup(mask) {\n        this._internalAbstractMeshDataInfo._meshCollisionData._collisionGroup = !isNaN(mask) ? mask : -1;\n    }\n    /**\n     * Gets or sets current surrounding meshes (null by default).\n     *\n     * By default collision detection is tested against every mesh in the scene.\n     * It is possible to set surroundingMeshes to a defined list of meshes and then only these specified\n     * meshes will be tested for the collision.\n     *\n     * Note: if set to an empty array no collision will happen when this mesh is moved.\n     */\n    get surroundingMeshes() {\n        return this._internalAbstractMeshDataInfo._meshCollisionData._surroundingMeshes;\n    }\n    set surroundingMeshes(meshes) {\n        this._internalAbstractMeshDataInfo._meshCollisionData._surroundingMeshes = meshes;\n    }\n    /** Gets the list of lights affecting that mesh */\n    get lightSources() {\n        return this._lightSources;\n    }\n    /** @internal */\n    get _positions() {\n        return null;\n    }\n    /**\n     * Gets or sets a skeleton to apply skinning transformations\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/bonesSkeletons\n     */\n    set skeleton(value) {\n        const skeleton = this._internalAbstractMeshDataInfo._skeleton;\n        if (skeleton && skeleton.needInitialSkinMatrix) {\n            skeleton._unregisterMeshWithPoseMatrix(this);\n        }\n        if (value && value.needInitialSkinMatrix) {\n            value._registerMeshWithPoseMatrix(this);\n        }\n        this._internalAbstractMeshDataInfo._skeleton = value;\n        if (!this._internalAbstractMeshDataInfo._skeleton) {\n            this._bonesTransformMatrices = null;\n        }\n        this._markSubMeshesAsAttributesDirty();\n    }\n    get skeleton() {\n        return this._internalAbstractMeshDataInfo._skeleton;\n    }\n    // Constructor\n    /**\n     * Creates a new AbstractMesh\n     * @param name defines the name of the mesh\n     * @param scene defines the hosting scene\n     */\n    constructor(name, scene = null) {\n        super(name, scene, false);\n        // Internal data\n        /** @internal */\n        this._internalAbstractMeshDataInfo = new _InternalAbstractMeshDataInfo();\n        /** @internal */\n        this._waitingMaterialId = null;\n        /**\n         * The culling strategy to use to check whether the mesh must be rendered or not.\n         * This value can be changed at any time and will be used on the next render mesh selection.\n         * The possible values are :\n         * - AbstractMesh.CULLINGSTRATEGY_STANDARD\n         * - AbstractMesh.CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY\n         * - AbstractMesh.CULLINGSTRATEGY_OPTIMISTIC_INCLUSION\n         * - AbstractMesh.CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY\n         * Please read each static variable documentation to get details about the culling process.\n         * */\n        this.cullingStrategy = AbstractMesh.CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY;\n        // Events\n        /**\n         * An event triggered when this mesh collides with another one\n         */\n        this.onCollideObservable = new Observable();\n        /**\n         * An event triggered when the collision's position changes\n         */\n        this.onCollisionPositionChangeObservable = new Observable();\n        /**\n         * An event triggered when material is changed\n         */\n        this.onMaterialChangedObservable = new Observable();\n        // Properties\n        /**\n         * Gets or sets the orientation for POV movement & rotation\n         */\n        this.definedFacingForward = true;\n        /** @internal */\n        this._occlusionQuery = null;\n        /** @internal */\n        this._renderingGroup = null;\n        /** Gets or sets the alpha index used to sort transparent meshes\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/advanced/transparent_rendering#alpha-index\n         */\n        this.alphaIndex = Number.MAX_VALUE;\n        /**\n         * Gets or sets a boolean indicating if the mesh is visible (renderable). Default is true\n         */\n        this.isVisible = true;\n        /**\n         * Gets or sets a boolean indicating if the mesh can be picked (by scene.pick for instance or through actions). Default is true\n         */\n        this.isPickable = true;\n        /**\n         * Gets or sets a boolean indicating if the mesh can be near picked. Default is false\n         */\n        this.isNearPickable = false;\n        /**\n         * Gets or sets a boolean indicating if the mesh can be near grabbed. Default is false\n         */\n        this.isNearGrabbable = false;\n        /** Gets or sets a boolean indicating that bounding boxes of subMeshes must be rendered as well (false by default) */\n        this.showSubMeshesBoundingBox = false;\n        /** Gets or sets a boolean indicating if the mesh must be considered as a ray blocker for lens flares (false by default)\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/environment/lenseFlare\n         */\n        this.isBlocker = false;\n        /**\n         * Gets or sets a boolean indicating that pointer move events must be supported on this mesh (false by default)\n         */\n        this.enablePointerMoveEvents = false;\n        /** Defines color to use when rendering outline */\n        this.outlineColor = Color3.Red();\n        /** Define width to use when rendering outline */\n        this.outlineWidth = 0.02;\n        /** Defines color to use when rendering overlay */\n        this.overlayColor = Color3.Red();\n        /** Defines alpha to use when rendering overlay */\n        this.overlayAlpha = 0.5;\n        /** Gets or sets a boolean indicating that internal octree (if available) can be used to boost submeshes selection (true by default) */\n        this.useOctreeForRenderingSelection = true;\n        /** Gets or sets a boolean indicating that internal octree (if available) can be used to boost submeshes picking (true by default) */\n        this.useOctreeForPicking = true;\n        /** Gets or sets a boolean indicating that internal octree (if available) can be used to boost submeshes collision (true by default) */\n        this.useOctreeForCollisions = true;\n        /**\n         * True if the mesh must be rendered in any case (this will shortcut the frustum clipping phase)\n         */\n        this.alwaysSelectAsActiveMesh = false;\n        /**\n         * Gets or sets a boolean indicating that the bounding info does not need to be kept in sync (for performance reason)\n         */\n        this.doNotSyncBoundingInfo = false;\n        /**\n         * Gets or sets the current action manager\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/events/actions\n         */\n        this.actionManager = null;\n        /**\n         * Gets or sets the ellipsoid used to impersonate this mesh when using collision engine (default is (0.5, 1, 0.5))\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_collisions\n         */\n        this.ellipsoid = new Vector3(0.5, 1, 0.5);\n        /**\n         * Gets or sets the ellipsoid offset used to impersonate this mesh when using collision engine (default is (0, 0, 0))\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_collisions\n         */\n        this.ellipsoidOffset = new Vector3(0, 0, 0);\n        // Edges\n        /**\n         * Defines edge width used when edgesRenderer is enabled\n         * @see https://www.babylonjs-playground.com/#10OJSG#13\n         */\n        this.edgesWidth = 1;\n        /**\n         * Defines edge color used when edgesRenderer is enabled\n         * @see https://www.babylonjs-playground.com/#10OJSG#13\n         */\n        this.edgesColor = new Color4(1, 0, 0, 1);\n        /** @internal */\n        this._edgesRenderer = null;\n        /** @internal */\n        this._masterMesh = null;\n        this._boundingInfo = null;\n        this._boundingInfoIsDirty = true;\n        /** @internal */\n        this._renderId = 0;\n        /** @internal */\n        this._intersectionsInProgress = new Array();\n        /** @internal */\n        this._unIndexed = false;\n        /** @internal */\n        this._lightSources = new Array();\n        // Loading properties\n        /** @internal */\n        this._waitingData = {\n            lods: null,\n            actions: null,\n            freezeWorldMatrix: null,\n        };\n        /** @internal */\n        this._bonesTransformMatrices = null;\n        /** @internal */\n        this._transformMatrixTexture = null;\n        /**\n         * An event triggered when the mesh is rebuilt.\n         */\n        this.onRebuildObservable = new Observable();\n        this._onCollisionPositionChange = (collisionId, newPosition, collidedMesh = null) => {\n            newPosition.subtractToRef(this._internalAbstractMeshDataInfo._meshCollisionData._oldPositionForCollisions, this._internalAbstractMeshDataInfo._meshCollisionData._diffPositionForCollisions);\n            if (this._internalAbstractMeshDataInfo._meshCollisionData._diffPositionForCollisions.length() > Engine.CollisionsEpsilon) {\n                this.position.addInPlace(this._internalAbstractMeshDataInfo._meshCollisionData._diffPositionForCollisions);\n            }\n            if (collidedMesh) {\n                this.onCollideObservable.notifyObservers(collidedMesh);\n            }\n            this.onCollisionPositionChangeObservable.notifyObservers(this.position);\n        };\n        scene = this.getScene();\n        scene.addMesh(this);\n        this._resyncLightSources();\n        // Mesh Uniform Buffer.\n        this._uniformBuffer = new UniformBuffer(this.getScene().getEngine(), undefined, undefined, name, !this.getScene().getEngine().isWebGPU);\n        this._buildUniformLayout();\n        switch (scene.performancePriority) {\n            case ScenePerformancePriority.Aggressive:\n                this.doNotSyncBoundingInfo = true;\n            // eslint-disable-next-line no-fallthrough\n            case ScenePerformancePriority.Intermediate:\n                this.alwaysSelectAsActiveMesh = true;\n                this.isPickable = false;\n                break;\n        }\n    }\n    _buildUniformLayout() {\n        this._uniformBuffer.addUniform(\"world\", 16);\n        this._uniformBuffer.addUniform(\"visibility\", 1);\n        this._uniformBuffer.create();\n    }\n    /**\n     * Transfer the mesh values to its UBO.\n     * @param world The world matrix associated with the mesh\n     */\n    transferToEffect(world) {\n        const ubo = this._uniformBuffer;\n        ubo.updateMatrix(\"world\", world);\n        ubo.updateFloat(\"visibility\", this._internalAbstractMeshDataInfo._visibility);\n        ubo.update();\n    }\n    /**\n     * Gets the mesh uniform buffer.\n     * @returns the uniform buffer of the mesh.\n     */\n    getMeshUniformBuffer() {\n        return this._uniformBuffer;\n    }\n    /**\n     * Returns the string \"AbstractMesh\"\n     * @returns \"AbstractMesh\"\n     */\n    getClassName() {\n        return \"AbstractMesh\";\n    }\n    /**\n     * Gets a string representation of the current mesh\n     * @param fullDetails defines a boolean indicating if full details must be included\n     * @returns a string representation of the current mesh\n     */\n    toString(fullDetails) {\n        let ret = \"Name: \" + this.name + \", isInstance: \" + (this.getClassName() !== \"InstancedMesh\" ? \"YES\" : \"NO\");\n        ret += \", # of submeshes: \" + (this.subMeshes ? this.subMeshes.length : 0);\n        const skeleton = this._internalAbstractMeshDataInfo._skeleton;\n        if (skeleton) {\n            ret += \", skeleton: \" + skeleton.name;\n        }\n        if (fullDetails) {\n            ret += \", billboard mode: \" + [\"NONE\", \"X\", \"Y\", null, \"Z\", null, null, \"ALL\"][this.billboardMode];\n            ret += \", freeze wrld mat: \" + (this._isWorldMatrixFrozen || this._waitingData.freezeWorldMatrix ? \"YES\" : \"NO\");\n        }\n        return ret;\n    }\n    /**\n     * @internal\n     */\n    _getEffectiveParent() {\n        if (this._masterMesh && this.billboardMode !== TransformNode.BILLBOARDMODE_NONE) {\n            return this._masterMesh;\n        }\n        return super._getEffectiveParent();\n    }\n    /**\n     * @internal\n     */\n    _getActionManagerForTrigger(trigger, initialCall = true) {\n        if (this.actionManager && (initialCall || this.actionManager.isRecursive)) {\n            if (trigger) {\n                if (this.actionManager.hasSpecificTrigger(trigger)) {\n                    return this.actionManager;\n                }\n            }\n            else {\n                return this.actionManager;\n            }\n        }\n        if (!this.parent) {\n            return null;\n        }\n        return this.parent._getActionManagerForTrigger(trigger, false);\n    }\n    /**\n     * @internal\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _rebuild(dispose = false) {\n        this.onRebuildObservable.notifyObservers(this);\n        if (this._occlusionQuery !== null) {\n            this._occlusionQuery = null;\n        }\n        if (!this.subMeshes) {\n            return;\n        }\n        for (const subMesh of this.subMeshes) {\n            subMesh._rebuild();\n        }\n    }\n    /** @internal */\n    _resyncLightSources() {\n        this._lightSources.length = 0;\n        for (const light of this.getScene().lights) {\n            if (!light.isEnabled()) {\n                continue;\n            }\n            if (light.canAffectMesh(this)) {\n                this._lightSources.push(light);\n            }\n        }\n        this._markSubMeshesAsLightDirty();\n    }\n    /**\n     * @internal\n     */\n    _resyncLightSource(light) {\n        const isIn = light.isEnabled() && light.canAffectMesh(this);\n        const index = this._lightSources.indexOf(light);\n        let removed = false;\n        if (index === -1) {\n            if (!isIn) {\n                return;\n            }\n            this._lightSources.push(light);\n        }\n        else {\n            if (isIn) {\n                return;\n            }\n            removed = true;\n            this._lightSources.splice(index, 1);\n        }\n        this._markSubMeshesAsLightDirty(removed);\n    }\n    /** @internal */\n    _unBindEffect() {\n        for (const subMesh of this.subMeshes) {\n            subMesh.setEffect(null);\n        }\n    }\n    /**\n     * @internal\n     */\n    _removeLightSource(light, dispose) {\n        const index = this._lightSources.indexOf(light);\n        if (index === -1) {\n            return;\n        }\n        this._lightSources.splice(index, 1);\n        this._markSubMeshesAsLightDirty(dispose);\n    }\n    _markSubMeshesAsDirty(func) {\n        if (!this.subMeshes) {\n            return;\n        }\n        for (const subMesh of this.subMeshes) {\n            for (let i = 0; i < subMesh._drawWrappers.length; ++i) {\n                const drawWrapper = subMesh._drawWrappers[i];\n                if (!drawWrapper || !drawWrapper.defines || !drawWrapper.defines.markAllAsDirty) {\n                    continue;\n                }\n                func(drawWrapper.defines);\n            }\n        }\n    }\n    /**\n     * @internal\n     */\n    _markSubMeshesAsLightDirty(dispose = false) {\n        this._markSubMeshesAsDirty((defines) => defines.markAsLightDirty(dispose));\n    }\n    /** @internal */\n    _markSubMeshesAsAttributesDirty() {\n        this._markSubMeshesAsDirty((defines) => defines.markAsAttributesDirty());\n    }\n    /** @internal */\n    _markSubMeshesAsMiscDirty() {\n        this._markSubMeshesAsDirty((defines) => defines.markAsMiscDirty());\n    }\n    /**\n     * Flag the AbstractMesh as dirty (Forcing it to update everything)\n     * @param property if set to \"rotation\" the objects rotationQuaternion will be set to null\n     * @returns this AbstractMesh\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    markAsDirty(property) {\n        this._currentRenderId = Number.MAX_VALUE;\n        this._isDirty = true;\n        return this;\n    }\n    /**\n     * Resets the draw wrappers cache for all submeshes of this abstract mesh\n     * @param passId If provided, releases only the draw wrapper corresponding to this render pass id\n     */\n    resetDrawCache(passId) {\n        if (!this.subMeshes) {\n            return;\n        }\n        for (const subMesh of this.subMeshes) {\n            subMesh.resetDrawCache(passId);\n        }\n    }\n    // Methods\n    /**\n     * Returns true if the mesh is blocked. Implemented by child classes\n     */\n    get isBlocked() {\n        return false;\n    }\n    /**\n     * Returns the mesh itself by default. Implemented by child classes\n     * @param camera defines the camera to use to pick the right LOD level\n     * @returns the currentAbstractMesh\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    getLOD(camera) {\n        return this;\n    }\n    /**\n     * Returns 0 by default. Implemented by child classes\n     * @returns an integer\n     */\n    getTotalVertices() {\n        return 0;\n    }\n    /**\n     * Returns a positive integer : the total number of indices in this mesh geometry.\n     * @returns the number of indices or zero if the mesh has no geometry.\n     */\n    getTotalIndices() {\n        return 0;\n    }\n    /**\n     * Returns null by default. Implemented by child classes\n     * @returns null\n     */\n    getIndices() {\n        return null;\n    }\n    /**\n     * Returns the array of the requested vertex data kind. Implemented by child classes\n     * @param kind defines the vertex data kind to use\n     * @returns null\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    getVerticesData(kind) {\n        return null;\n    }\n    /**\n     * Sets the vertex data of the mesh geometry for the requested `kind`.\n     * If the mesh has no geometry, a new Geometry object is set to the mesh and then passed this vertex data.\n     * Note that a new underlying VertexBuffer object is created each call.\n     * If the `kind` is the `PositionKind`, the mesh BoundingInfo is renewed, so the bounding box and sphere, and the mesh World Matrix is recomputed.\n     * @param kind defines vertex data kind:\n     * * VertexBuffer.PositionKind\n     * * VertexBuffer.UVKind\n     * * VertexBuffer.UV2Kind\n     * * VertexBuffer.UV3Kind\n     * * VertexBuffer.UV4Kind\n     * * VertexBuffer.UV5Kind\n     * * VertexBuffer.UV6Kind\n     * * VertexBuffer.ColorKind\n     * * VertexBuffer.MatricesIndicesKind\n     * * VertexBuffer.MatricesIndicesExtraKind\n     * * VertexBuffer.MatricesWeightsKind\n     * * VertexBuffer.MatricesWeightsExtraKind\n     * @param data defines the data source\n     * @param updatable defines if the data must be flagged as updatable (or static)\n     * @param stride defines the vertex stride (size of an entire vertex). Can be null and in this case will be deduced from vertex data kind\n     * @returns the current mesh\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    setVerticesData(kind, data, updatable, stride) {\n        return this;\n    }\n    /**\n     * Updates the existing vertex data of the mesh geometry for the requested `kind`.\n     * If the mesh has no geometry, it is simply returned as it is.\n     * @param kind defines vertex data kind:\n     * * VertexBuffer.PositionKind\n     * * VertexBuffer.UVKind\n     * * VertexBuffer.UV2Kind\n     * * VertexBuffer.UV3Kind\n     * * VertexBuffer.UV4Kind\n     * * VertexBuffer.UV5Kind\n     * * VertexBuffer.UV6Kind\n     * * VertexBuffer.ColorKind\n     * * VertexBuffer.MatricesIndicesKind\n     * * VertexBuffer.MatricesIndicesExtraKind\n     * * VertexBuffer.MatricesWeightsKind\n     * * VertexBuffer.MatricesWeightsExtraKind\n     * @param data defines the data source\n     * @param updateExtends If `kind` is `PositionKind` and if `updateExtends` is true, the mesh BoundingInfo is renewed, so the bounding box and sphere, and the mesh World Matrix is recomputed\n     * @param makeItUnique If true, a new global geometry is created from this data and is set to the mesh\n     * @returns the current mesh\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    updateVerticesData(kind, data, updateExtends, makeItUnique) {\n        return this;\n    }\n    /**\n     * Sets the mesh indices,\n     * If the mesh has no geometry, a new Geometry object is created and set to the mesh.\n     * @param indices Expects an array populated with integers or a typed array (Int32Array, Uint32Array, Uint16Array)\n     * @param totalVertices Defines the total number of vertices\n     * @returns the current mesh\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    setIndices(indices, totalVertices) {\n        return this;\n    }\n    /**\n     * Gets a boolean indicating if specific vertex data is present\n     * @param kind defines the vertex data kind to use\n     * @returns true is data kind is present\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    isVerticesDataPresent(kind) {\n        return false;\n    }\n    /**\n     * Returns the mesh BoundingInfo object or creates a new one and returns if it was undefined.\n     * Note that it returns a shallow bounding of the mesh (i.e. it does not include children).\n     * To get the full bounding of all children, call `getHierarchyBoundingVectors` instead.\n     * @returns a BoundingInfo\n     */\n    getBoundingInfo() {\n        if (this._masterMesh) {\n            return this._masterMesh.getBoundingInfo();\n        }\n        if (this._boundingInfoIsDirty) {\n            this._boundingInfoIsDirty = false;\n            // this._boundingInfo is being created if undefined\n            this._updateBoundingInfo();\n        }\n        // cannot be null.\n        return this._boundingInfo;\n    }\n    /**\n     * Overwrite the current bounding info\n     * @param boundingInfo defines the new bounding info\n     * @returns the current mesh\n     */\n    setBoundingInfo(boundingInfo) {\n        this._boundingInfo = boundingInfo;\n        return this;\n    }\n    /**\n     * Returns true if there is already a bounding info\n     */\n    get hasBoundingInfo() {\n        return this._boundingInfo !== null;\n    }\n    /**\n     * Creates a new bounding info for the mesh\n     * @param minimum min vector of the bounding box/sphere\n     * @param maximum max vector of the bounding box/sphere\n     * @param worldMatrix defines the new world matrix\n     * @returns the new bounding info\n     */\n    buildBoundingInfo(minimum, maximum, worldMatrix) {\n        this._boundingInfo = new BoundingInfo(minimum, maximum, worldMatrix);\n        return this._boundingInfo;\n    }\n    /**\n     * Uniformly scales the mesh to fit inside of a unit cube (1 X 1 X 1 units)\n     * @param includeDescendants Use the hierarchy's bounding box instead of the mesh's bounding box. Default is false\n     * @param ignoreRotation ignore rotation when computing the scale (ie. object will be axis aligned). Default is false\n     * @param predicate predicate that is passed in to getHierarchyBoundingVectors when selecting which object should be included when scaling\n     * @returns the current mesh\n     */\n    normalizeToUnitCube(includeDescendants = true, ignoreRotation = false, predicate) {\n        return super.normalizeToUnitCube(includeDescendants, ignoreRotation, predicate);\n    }\n    /** Gets a boolean indicating if this mesh has skinning data and an attached skeleton */\n    get useBones() {\n        return ((this.skeleton &&\n            this.getScene().skeletonsEnabled &&\n            this.isVerticesDataPresent(VertexBuffer.MatricesIndicesKind) &&\n            this.isVerticesDataPresent(VertexBuffer.MatricesWeightsKind)));\n    }\n    /** @internal */\n    _preActivate() { }\n    /**\n     * @internal\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _preActivateForIntermediateRendering(renderId) { }\n    /**\n     * @internal\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _activate(renderId, intermediateRendering) {\n        this._renderId = renderId;\n        return true;\n    }\n    /** @internal */\n    _postActivate() {\n        // Do nothing\n    }\n    /** @internal */\n    _freeze() {\n        // Do nothing\n    }\n    /** @internal */\n    _unFreeze() {\n        // Do nothing\n    }\n    /**\n     * Gets the current world matrix\n     * @returns a Matrix\n     */\n    getWorldMatrix() {\n        if (this._masterMesh && this.billboardMode === TransformNode.BILLBOARDMODE_NONE) {\n            return this._masterMesh.getWorldMatrix();\n        }\n        return super.getWorldMatrix();\n    }\n    /** @internal */\n    _getWorldMatrixDeterminant() {\n        if (this._masterMesh) {\n            return this._masterMesh._getWorldMatrixDeterminant();\n        }\n        return super._getWorldMatrixDeterminant();\n    }\n    /**\n     * Gets a boolean indicating if this mesh is an instance or a regular mesh\n     */\n    get isAnInstance() {\n        return false;\n    }\n    /**\n     * Gets a boolean indicating if this mesh has instances\n     */\n    get hasInstances() {\n        return false;\n    }\n    /**\n     * Gets a boolean indicating if this mesh has thin instances\n     */\n    get hasThinInstances() {\n        return false;\n    }\n    // ================================== Point of View Movement =================================\n    /**\n     * Perform relative position change from the point of view of behind the front of the mesh.\n     * This is performed taking into account the meshes current rotation, so you do not have to care.\n     * Supports definition of mesh facing forward or backward {@link definedFacingForwardSearch | See definedFacingForwardSearch }.\n     * @param amountRight defines the distance on the right axis\n     * @param amountUp defines the distance on the up axis\n     * @param amountForward defines the distance on the forward axis\n     * @returns the current mesh\n     */\n    movePOV(amountRight, amountUp, amountForward) {\n        this.position.addInPlace(this.calcMovePOV(amountRight, amountUp, amountForward));\n        return this;\n    }\n    /**\n     * Calculate relative position change from the point of view of behind the front of the mesh.\n     * This is performed taking into account the meshes current rotation, so you do not have to care.\n     * Supports definition of mesh facing forward or backward {@link definedFacingForwardSearch | See definedFacingForwardSearch }.\n     * @param amountRight defines the distance on the right axis\n     * @param amountUp defines the distance on the up axis\n     * @param amountForward defines the distance on the forward axis\n     * @returns the new displacement vector\n     */\n    calcMovePOV(amountRight, amountUp, amountForward) {\n        const rotMatrix = new Matrix();\n        const rotQuaternion = this.rotationQuaternion ? this.rotationQuaternion : Quaternion.RotationYawPitchRoll(this.rotation.y, this.rotation.x, this.rotation.z);\n        rotQuaternion.toRotationMatrix(rotMatrix);\n        const translationDelta = Vector3.Zero();\n        const defForwardMult = this.definedFacingForward ? -1 : 1;\n        Vector3.TransformCoordinatesFromFloatsToRef(amountRight * defForwardMult, amountUp, amountForward * defForwardMult, rotMatrix, translationDelta);\n        return translationDelta;\n    }\n    // ================================== Point of View Rotation =================================\n    /**\n     * Perform relative rotation change from the point of view of behind the front of the mesh.\n     * Supports definition of mesh facing forward or backward {@link definedFacingForwardSearch | See definedFacingForwardSearch }.\n     * @param flipBack defines the flip\n     * @param twirlClockwise defines the twirl\n     * @param tiltRight defines the tilt\n     * @returns the current mesh\n     */\n    rotatePOV(flipBack, twirlClockwise, tiltRight) {\n        this.rotation.addInPlace(this.calcRotatePOV(flipBack, twirlClockwise, tiltRight));\n        return this;\n    }\n    /**\n     * Calculate relative rotation change from the point of view of behind the front of the mesh.\n     * Supports definition of mesh facing forward or backward {@link definedFacingForwardSearch | See definedFacingForwardSearch }.\n     * @param flipBack defines the flip\n     * @param twirlClockwise defines the twirl\n     * @param tiltRight defines the tilt\n     * @returns the new rotation vector\n     */\n    calcRotatePOV(flipBack, twirlClockwise, tiltRight) {\n        const defForwardMult = this.definedFacingForward ? 1 : -1;\n        return new Vector3(flipBack * defForwardMult, twirlClockwise, tiltRight * defForwardMult);\n    }\n    /**\n     * This method recomputes and sets a new BoundingInfo to the mesh unless it is locked.\n     * This means the mesh underlying bounding box and sphere are recomputed.\n     * @param applySkeleton defines whether to apply the skeleton before computing the bounding info\n     * @param applyMorph  defines whether to apply the morph target before computing the bounding info\n     * @returns the current mesh\n     */\n    refreshBoundingInfo(applySkeleton = false, applyMorph = false) {\n        if (this._boundingInfo && this._boundingInfo.isLocked) {\n            return this;\n        }\n        this._refreshBoundingInfo(this._getPositionData(applySkeleton, applyMorph), null);\n        return this;\n    }\n    /**\n     * @internal\n     */\n    _refreshBoundingInfo(data, bias) {\n        if (data) {\n            const extend = extractMinAndMax(data, 0, this.getTotalVertices(), bias);\n            if (this._boundingInfo) {\n                this._boundingInfo.reConstruct(extend.minimum, extend.maximum);\n            }\n            else {\n                this._boundingInfo = new BoundingInfo(extend.minimum, extend.maximum);\n            }\n        }\n        if (this.subMeshes) {\n            for (let index = 0; index < this.subMeshes.length; index++) {\n                this.subMeshes[index].refreshBoundingInfo(data);\n            }\n        }\n        this._updateBoundingInfo();\n    }\n    /**\n     * Internal function to get buffer data and possibly apply morphs and normals\n     * @param applySkeleton\n     * @param applyMorph\n     * @param data\n     * @param kind the kind of data you want. Can be Normal or Position\n     */\n    _getData(applySkeleton = false, applyMorph = false, data, kind = VertexBuffer.PositionKind) {\n        data = data !== null && data !== void 0 ? data : this.getVerticesData(kind).slice();\n        if (data && applyMorph && this.morphTargetManager) {\n            let faceIndexCount = 0;\n            let positionIndex = 0;\n            for (let vertexCount = 0; vertexCount < data.length; vertexCount++) {\n                for (let targetCount = 0; targetCount < this.morphTargetManager.numTargets; targetCount++) {\n                    const targetMorph = this.morphTargetManager.getTarget(targetCount);\n                    const influence = targetMorph.influence;\n                    if (influence > 0.0) {\n                        const morphTargetPositions = targetMorph.getPositions();\n                        if (morphTargetPositions) {\n                            data[vertexCount] += (morphTargetPositions[vertexCount] - data[vertexCount]) * influence;\n                        }\n                    }\n                }\n                faceIndexCount++;\n                if (kind === VertexBuffer.PositionKind) {\n                    if (this._positions && faceIndexCount === 3) {\n                        // We want to merge into positions every 3 indices starting (but not 0)\n                        faceIndexCount = 0;\n                        const index = positionIndex * 3;\n                        this._positions[positionIndex++].copyFromFloats(data[index], data[index + 1], data[index + 2]);\n                    }\n                }\n            }\n        }\n        if (data && applySkeleton && this.skeleton) {\n            const matricesIndicesData = this.getVerticesData(VertexBuffer.MatricesIndicesKind);\n            const matricesWeightsData = this.getVerticesData(VertexBuffer.MatricesWeightsKind);\n            if (matricesWeightsData && matricesIndicesData) {\n                const needExtras = this.numBoneInfluencers > 4;\n                const matricesIndicesExtraData = needExtras ? this.getVerticesData(VertexBuffer.MatricesIndicesExtraKind) : null;\n                const matricesWeightsExtraData = needExtras ? this.getVerticesData(VertexBuffer.MatricesWeightsExtraKind) : null;\n                const skeletonMatrices = this.skeleton.getTransformMatrices(this);\n                const tempVector = TmpVectors.Vector3[0];\n                const finalMatrix = TmpVectors.Matrix[0];\n                const tempMatrix = TmpVectors.Matrix[1];\n                let matWeightIdx = 0;\n                for (let index = 0; index < data.length; index += 3, matWeightIdx += 4) {\n                    finalMatrix.reset();\n                    let inf;\n                    let weight;\n                    for (inf = 0; inf < 4; inf++) {\n                        weight = matricesWeightsData[matWeightIdx + inf];\n                        if (weight > 0) {\n                            Matrix.FromFloat32ArrayToRefScaled(skeletonMatrices, Math.floor(matricesIndicesData[matWeightIdx + inf] * 16), weight, tempMatrix);\n                            finalMatrix.addToSelf(tempMatrix);\n                        }\n                    }\n                    if (needExtras) {\n                        for (inf = 0; inf < 4; inf++) {\n                            weight = matricesWeightsExtraData[matWeightIdx + inf];\n                            if (weight > 0) {\n                                Matrix.FromFloat32ArrayToRefScaled(skeletonMatrices, Math.floor(matricesIndicesExtraData[matWeightIdx + inf] * 16), weight, tempMatrix);\n                                finalMatrix.addToSelf(tempMatrix);\n                            }\n                        }\n                    }\n                    if (kind === VertexBuffer.NormalKind) {\n                        Vector3.TransformNormalFromFloatsToRef(data[index], data[index + 1], data[index + 2], finalMatrix, tempVector);\n                    }\n                    else {\n                        Vector3.TransformCoordinatesFromFloatsToRef(data[index], data[index + 1], data[index + 2], finalMatrix, tempVector);\n                    }\n                    tempVector.toArray(data, index);\n                    if (kind === VertexBuffer.PositionKind && this._positions) {\n                        this._positions[index / 3].copyFrom(tempVector);\n                    }\n                }\n            }\n        }\n        return data;\n    }\n    /**\n     * Get the normals vertex data and optionally apply skeleton and morphing.\n     * @param applySkeleton defines whether to apply the skeleton\n     * @param applyMorph  defines whether to apply the morph target\n     * @returns the normals data\n     */\n    getNormalsData(applySkeleton = false, applyMorph = false) {\n        return this._getData(applySkeleton, applyMorph, null, VertexBuffer.NormalKind);\n    }\n    /**\n     * Get the position vertex data and optionally apply skeleton and morphing.\n     * @param applySkeleton defines whether to apply the skeleton\n     * @param applyMorph  defines whether to apply the morph target\n     * @param data defines the position data to apply the skeleton and morph to\n     * @returns the position data\n     */\n    getPositionData(applySkeleton = false, applyMorph = false, data) {\n        return this._getData(applySkeleton, applyMorph, data, VertexBuffer.PositionKind);\n    }\n    /**\n     * @internal\n     */\n    _getPositionData(applySkeleton, applyMorph) {\n        var _a;\n        let data = this.getVerticesData(VertexBuffer.PositionKind);\n        if (this._internalAbstractMeshDataInfo._positions) {\n            this._internalAbstractMeshDataInfo._positions = null;\n        }\n        if (data && ((applySkeleton && this.skeleton) || (applyMorph && this.morphTargetManager))) {\n            data = data.slice();\n            this._generatePointsArray();\n            if (this._positions) {\n                const pos = this._positions;\n                this._internalAbstractMeshDataInfo._positions = new Array(pos.length);\n                for (let i = 0; i < pos.length; i++) {\n                    this._internalAbstractMeshDataInfo._positions[i] = ((_a = pos[i]) === null || _a === void 0 ? void 0 : _a.clone()) || new Vector3();\n                }\n            }\n            return this.getPositionData(applySkeleton, applyMorph, data);\n        }\n        return data;\n    }\n    /** @internal */\n    _updateBoundingInfo() {\n        if (this._boundingInfo) {\n            this._boundingInfo.update(this.worldMatrixFromCache);\n        }\n        else {\n            this._boundingInfo = new BoundingInfo(Vector3.Zero(), Vector3.Zero(), this.worldMatrixFromCache);\n        }\n        this._updateSubMeshesBoundingInfo(this.worldMatrixFromCache);\n        return this;\n    }\n    /**\n     * @internal\n     */\n    _updateSubMeshesBoundingInfo(matrix) {\n        if (!this.subMeshes) {\n            return this;\n        }\n        const count = this.subMeshes.length;\n        for (let subIndex = 0; subIndex < count; subIndex++) {\n            const subMesh = this.subMeshes[subIndex];\n            if (count > 1 || !subMesh.IsGlobal) {\n                subMesh.updateBoundingInfo(matrix);\n            }\n        }\n        return this;\n    }\n    /** @internal */\n    _afterComputeWorldMatrix() {\n        if (this.doNotSyncBoundingInfo) {\n            return;\n        }\n        // Bounding info\n        this._boundingInfoIsDirty = true;\n    }\n    /**\n     * Returns `true` if the mesh is within the frustum defined by the passed array of planes.\n     * A mesh is in the frustum if its bounding box intersects the frustum\n     * @param frustumPlanes defines the frustum to test\n     * @returns true if the mesh is in the frustum planes\n     */\n    isInFrustum(frustumPlanes) {\n        return this.getBoundingInfo().isInFrustum(frustumPlanes, this.cullingStrategy);\n    }\n    /**\n     * Returns `true` if the mesh is completely in the frustum defined be the passed array of planes.\n     * A mesh is completely in the frustum if its bounding box it completely inside the frustum.\n     * @param frustumPlanes defines the frustum to test\n     * @returns true if the mesh is completely in the frustum planes\n     */\n    isCompletelyInFrustum(frustumPlanes) {\n        return this.getBoundingInfo().isCompletelyInFrustum(frustumPlanes);\n    }\n    /**\n     * True if the mesh intersects another mesh or a SolidParticle object\n     * @param mesh defines a target mesh or SolidParticle to test\n     * @param precise Unless the parameter `precise` is set to `true` the intersection is computed according to Axis Aligned Bounding Boxes (AABB), else according to OBB (Oriented BBoxes)\n     * @param includeDescendants Can be set to true to test if the mesh defined in parameters intersects with the current mesh or any child meshes\n     * @returns true if there is an intersection\n     */\n    intersectsMesh(mesh, precise = false, includeDescendants) {\n        const boundingInfo = this.getBoundingInfo();\n        const otherBoundingInfo = mesh.getBoundingInfo();\n        if (boundingInfo.intersects(otherBoundingInfo, precise)) {\n            return true;\n        }\n        if (includeDescendants) {\n            for (const child of this.getChildMeshes()) {\n                if (child.intersectsMesh(mesh, precise, true)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    /**\n     * Returns true if the passed point (Vector3) is inside the mesh bounding box\n     * @param point defines the point to test\n     * @returns true if there is an intersection\n     */\n    intersectsPoint(point) {\n        return this.getBoundingInfo().intersectsPoint(point);\n    }\n    // Collisions\n    /**\n     * Gets or sets a boolean indicating that this mesh can be used in the collision engine\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_collisions\n     */\n    get checkCollisions() {\n        return this._internalAbstractMeshDataInfo._meshCollisionData._checkCollisions;\n    }\n    set checkCollisions(collisionEnabled) {\n        this._internalAbstractMeshDataInfo._meshCollisionData._checkCollisions = collisionEnabled;\n    }\n    /**\n     * Gets Collider object used to compute collisions (not physics)\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_collisions\n     */\n    get collider() {\n        return this._internalAbstractMeshDataInfo._meshCollisionData._collider;\n    }\n    /**\n     * Move the mesh using collision engine\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_collisions\n     * @param displacement defines the requested displacement vector\n     * @returns the current mesh\n     */\n    moveWithCollisions(displacement) {\n        const globalPosition = this.getAbsolutePosition();\n        globalPosition.addToRef(this.ellipsoidOffset, this._internalAbstractMeshDataInfo._meshCollisionData._oldPositionForCollisions);\n        const coordinator = this.getScene().collisionCoordinator;\n        if (!this._internalAbstractMeshDataInfo._meshCollisionData._collider) {\n            this._internalAbstractMeshDataInfo._meshCollisionData._collider = coordinator.createCollider();\n        }\n        this._internalAbstractMeshDataInfo._meshCollisionData._collider._radius = this.ellipsoid;\n        coordinator.getNewPosition(this._internalAbstractMeshDataInfo._meshCollisionData._oldPositionForCollisions, displacement, this._internalAbstractMeshDataInfo._meshCollisionData._collider, this.collisionRetryCount, this, this._onCollisionPositionChange, this.uniqueId);\n        return this;\n    }\n    // Collisions\n    /**\n     * @internal\n     */\n    _collideForSubMesh(subMesh, transformMatrix, collider) {\n        var _a;\n        this._generatePointsArray();\n        if (!this._positions) {\n            return this;\n        }\n        // Transformation\n        if (!subMesh._lastColliderWorldVertices || !subMesh._lastColliderTransformMatrix.equals(transformMatrix)) {\n            subMesh._lastColliderTransformMatrix = transformMatrix.clone();\n            subMesh._lastColliderWorldVertices = [];\n            subMesh._trianglePlanes = [];\n            const start = subMesh.verticesStart;\n            const end = subMesh.verticesStart + subMesh.verticesCount;\n            for (let i = start; i < end; i++) {\n                subMesh._lastColliderWorldVertices.push(Vector3.TransformCoordinates(this._positions[i], transformMatrix));\n            }\n        }\n        // Collide\n        collider._collide(subMesh._trianglePlanes, subMesh._lastColliderWorldVertices, this.getIndices(), subMesh.indexStart, subMesh.indexStart + subMesh.indexCount, subMesh.verticesStart, !!subMesh.getMaterial(), this, this._shouldConvertRHS(), ((_a = subMesh.getMaterial()) === null || _a === void 0 ? void 0 : _a.fillMode) === 7);\n        return this;\n    }\n    /**\n     * @internal\n     */\n    _processCollisionsForSubMeshes(collider, transformMatrix) {\n        const subMeshes = this._scene.getCollidingSubMeshCandidates(this, collider);\n        const len = subMeshes.length;\n        for (let index = 0; index < len; index++) {\n            const subMesh = subMeshes.data[index];\n            // Bounding test\n            if (len > 1 && !subMesh._checkCollision(collider)) {\n                continue;\n            }\n            this._collideForSubMesh(subMesh, transformMatrix, collider);\n        }\n        return this;\n    }\n    /** @internal */\n    _shouldConvertRHS() {\n        return false;\n    }\n    /**\n     * @internal\n     */\n    _checkCollision(collider) {\n        // Bounding box test\n        if (!this.getBoundingInfo()._checkCollision(collider)) {\n            return this;\n        }\n        // Transformation matrix\n        const collisionsScalingMatrix = TmpVectors.Matrix[0];\n        const collisionsTransformMatrix = TmpVectors.Matrix[1];\n        Matrix.ScalingToRef(1.0 / collider._radius.x, 1.0 / collider._radius.y, 1.0 / collider._radius.z, collisionsScalingMatrix);\n        this.worldMatrixFromCache.multiplyToRef(collisionsScalingMatrix, collisionsTransformMatrix);\n        this._processCollisionsForSubMeshes(collider, collisionsTransformMatrix);\n        return this;\n    }\n    // Picking\n    /** @internal */\n    _generatePointsArray() {\n        return false;\n    }\n    /**\n     * Checks if the passed Ray intersects with the mesh\n     * @param ray defines the ray to use\n     * @param fastCheck defines if fast mode (but less precise) must be used (false by default)\n     * @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected\n     * @param onlyBoundingInfo defines a boolean indicating if picking should only happen using bounding info (false by default)\n     * @param worldToUse defines the world matrix to use to get the world coordinate of the intersection point\n     * @param skipBoundingInfo a boolean indicating if we should skip the bounding info check\n     * @returns the picking info\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/interactions/mesh_intersect\n     */\n    intersects(ray, fastCheck, trianglePredicate, onlyBoundingInfo = false, worldToUse, skipBoundingInfo = false) {\n        const pickingInfo = new PickingInfo();\n        const intersectionThreshold = this.getClassName() === \"InstancedLinesMesh\" || this.getClassName() === \"LinesMesh\" ? this.intersectionThreshold : 0;\n        const boundingInfo = this.getBoundingInfo();\n        if (!this.subMeshes) {\n            return pickingInfo;\n        }\n        if (!skipBoundingInfo &&\n            (!ray.intersectsSphere(boundingInfo.boundingSphere, intersectionThreshold) || !ray.intersectsBox(boundingInfo.boundingBox, intersectionThreshold))) {\n            return pickingInfo;\n        }\n        if (onlyBoundingInfo) {\n            pickingInfo.hit = skipBoundingInfo ? false : true;\n            pickingInfo.pickedMesh = skipBoundingInfo ? null : this;\n            pickingInfo.distance = skipBoundingInfo ? 0 : Vector3.Distance(ray.origin, boundingInfo.boundingSphere.center);\n            pickingInfo.subMeshId = 0;\n            return pickingInfo;\n        }\n        if (!this._generatePointsArray()) {\n            return pickingInfo;\n        }\n        let intersectInfo = null;\n        const subMeshes = this._scene.getIntersectingSubMeshCandidates(this, ray);\n        const len = subMeshes.length;\n        // Check if all submeshes are using a material that don't allow picking (point/lines rendering)\n        // if no submesh can be picked that way, then fallback to BBox picking\n        let anySubmeshSupportIntersect = false;\n        for (let index = 0; index < len; index++) {\n            const subMesh = subMeshes.data[index];\n            const material = subMesh.getMaterial();\n            if (!material) {\n                continue;\n            }\n            if (material.fillMode == 7 ||\n                material.fillMode == 0 ||\n                material.fillMode == 1 ||\n                material.fillMode == 2 ||\n                material.fillMode == 4) {\n                anySubmeshSupportIntersect = true;\n                break;\n            }\n        }\n        // no sub mesh support intersection, fallback to BBox that has already be done\n        if (!anySubmeshSupportIntersect) {\n            pickingInfo.hit = true;\n            pickingInfo.pickedMesh = this;\n            pickingInfo.distance = Vector3.Distance(ray.origin, boundingInfo.boundingSphere.center);\n            pickingInfo.subMeshId = -1;\n            return pickingInfo;\n        }\n        // at least 1 submesh supports intersection, keep going\n        for (let index = 0; index < len; index++) {\n            const subMesh = subMeshes.data[index];\n            // Bounding test\n            if (len > 1 && !subMesh.canIntersects(ray)) {\n                continue;\n            }\n            const currentIntersectInfo = subMesh.intersects(ray, this._positions, this.getIndices(), fastCheck, trianglePredicate);\n            if (currentIntersectInfo) {\n                if (fastCheck || !intersectInfo || currentIntersectInfo.distance < intersectInfo.distance) {\n                    intersectInfo = currentIntersectInfo;\n                    intersectInfo.subMeshId = index;\n                    if (fastCheck) {\n                        break;\n                    }\n                }\n            }\n        }\n        if (intersectInfo) {\n            // Get picked point\n            const world = worldToUse !== null && worldToUse !== void 0 ? worldToUse : this.getWorldMatrix();\n            const worldOrigin = TmpVectors.Vector3[0];\n            const direction = TmpVectors.Vector3[1];\n            Vector3.TransformCoordinatesToRef(ray.origin, world, worldOrigin);\n            ray.direction.scaleToRef(intersectInfo.distance, direction);\n            const worldDirection = Vector3.TransformNormal(direction, world);\n            const pickedPoint = worldDirection.addInPlace(worldOrigin);\n            // Return result\n            pickingInfo.hit = true;\n            pickingInfo.distance = Vector3.Distance(worldOrigin, pickedPoint);\n            pickingInfo.pickedPoint = pickedPoint;\n            pickingInfo.pickedMesh = this;\n            pickingInfo.bu = intersectInfo.bu || 0;\n            pickingInfo.bv = intersectInfo.bv || 0;\n            pickingInfo.subMeshFaceId = intersectInfo.faceId;\n            pickingInfo.faceId = intersectInfo.faceId + subMeshes.data[intersectInfo.subMeshId].indexStart / (this.getClassName().indexOf(\"LinesMesh\") !== -1 ? 2 : 3);\n            pickingInfo.subMeshId = intersectInfo.subMeshId;\n            return pickingInfo;\n        }\n        return pickingInfo;\n    }\n    /**\n     * Clones the current mesh\n     * @param name defines the mesh name\n     * @param newParent defines the new mesh parent\n     * @param doNotCloneChildren defines a boolean indicating that children must not be cloned (false by default)\n     * @returns the new mesh\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    clone(name, newParent, doNotCloneChildren) {\n        return null;\n    }\n    /**\n     * Disposes all the submeshes of the current meshnp\n     * @returns the current mesh\n     */\n    releaseSubMeshes() {\n        if (this.subMeshes) {\n            while (this.subMeshes.length) {\n                this.subMeshes[0].dispose();\n            }\n        }\n        else {\n            this.subMeshes = new Array();\n        }\n        return this;\n    }\n    /**\n     * Releases resources associated with this abstract mesh.\n     * @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)\n     * @param disposeMaterialAndTextures Set to true to also dispose referenced materials and textures (false by default)\n     */\n    dispose(doNotRecurse, disposeMaterialAndTextures = false) {\n        let index;\n        // mesh map release.\n        if (this._scene.useMaterialMeshMap) {\n            // remove from material mesh map id needed\n            if (this._internalAbstractMeshDataInfo._material && this._internalAbstractMeshDataInfo._material.meshMap) {\n                this._internalAbstractMeshDataInfo._material.meshMap[this.uniqueId] = undefined;\n            }\n        }\n        // Smart Array Retainers.\n        this.getScene().freeActiveMeshes();\n        this.getScene().freeRenderingGroups();\n        // Action manager\n        if (this.actionManager !== undefined && this.actionManager !== null) {\n            this.actionManager.dispose();\n            this.actionManager = null;\n        }\n        // Skeleton\n        this._internalAbstractMeshDataInfo._skeleton = null;\n        if (this._transformMatrixTexture) {\n            this._transformMatrixTexture.dispose();\n            this._transformMatrixTexture = null;\n        }\n        // Intersections in progress\n        for (index = 0; index < this._intersectionsInProgress.length; index++) {\n            const other = this._intersectionsInProgress[index];\n            const pos = other._intersectionsInProgress.indexOf(this);\n            other._intersectionsInProgress.splice(pos, 1);\n        }\n        this._intersectionsInProgress.length = 0;\n        // Lights\n        const lights = this.getScene().lights;\n        lights.forEach((light) => {\n            let meshIndex = light.includedOnlyMeshes.indexOf(this);\n            if (meshIndex !== -1) {\n                light.includedOnlyMeshes.splice(meshIndex, 1);\n            }\n            meshIndex = light.excludedMeshes.indexOf(this);\n            if (meshIndex !== -1) {\n                light.excludedMeshes.splice(meshIndex, 1);\n            }\n            // Shadow generators\n            const generators = light.getShadowGenerators();\n            if (generators) {\n                const iterator = generators.values();\n                for (let key = iterator.next(); key.done !== true; key = iterator.next()) {\n                    const generator = key.value;\n                    const shadowMap = generator.getShadowMap();\n                    if (shadowMap && shadowMap.renderList) {\n                        meshIndex = shadowMap.renderList.indexOf(this);\n                        if (meshIndex !== -1) {\n                            shadowMap.renderList.splice(meshIndex, 1);\n                        }\n                    }\n                }\n            }\n        });\n        // SubMeshes\n        if (this.getClassName() !== \"InstancedMesh\" || this.getClassName() !== \"InstancedLinesMesh\") {\n            this.releaseSubMeshes();\n        }\n        // Query\n        const engine = this.getScene().getEngine();\n        if (this._occlusionQuery !== null) {\n            this.isOcclusionQueryInProgress = false;\n            engine.deleteQuery(this._occlusionQuery);\n            this._occlusionQuery = null;\n        }\n        // Engine\n        engine.wipeCaches();\n        // Remove from scene\n        this.getScene().removeMesh(this);\n        if (this._parentContainer) {\n            const index = this._parentContainer.meshes.indexOf(this);\n            if (index > -1) {\n                this._parentContainer.meshes.splice(index, 1);\n            }\n            this._parentContainer = null;\n        }\n        if (disposeMaterialAndTextures) {\n            if (this.material) {\n                if (this.material.getClassName() === \"MultiMaterial\") {\n                    this.material.dispose(false, true, true);\n                }\n                else {\n                    this.material.dispose(false, true);\n                }\n            }\n        }\n        if (!doNotRecurse) {\n            // Particles\n            for (index = 0; index < this.getScene().particleSystems.length; index++) {\n                if (this.getScene().particleSystems[index].emitter === this) {\n                    this.getScene().particleSystems[index].dispose();\n                    index--;\n                }\n            }\n        }\n        // facet data\n        if (this._internalAbstractMeshDataInfo._facetData.facetDataEnabled) {\n            this.disableFacetData();\n        }\n        this._uniformBuffer.dispose();\n        this.onAfterWorldMatrixUpdateObservable.clear();\n        this.onCollideObservable.clear();\n        this.onCollisionPositionChangeObservable.clear();\n        this.onRebuildObservable.clear();\n        super.dispose(doNotRecurse, disposeMaterialAndTextures);\n    }\n    /**\n     * Adds the passed mesh as a child to the current mesh\n     * @param mesh defines the child mesh\n     * @param preserveScalingSign if true, keep scaling sign of child. Otherwise, scaling sign might change.\n     * @returns the current mesh\n     */\n    addChild(mesh, preserveScalingSign = false) {\n        mesh.setParent(this, preserveScalingSign);\n        return this;\n    }\n    /**\n     * Removes the passed mesh from the current mesh children list\n     * @param mesh defines the child mesh\n     * @param preserveScalingSign if true, keep scaling sign of child. Otherwise, scaling sign might change.\n     * @returns the current mesh\n     */\n    removeChild(mesh, preserveScalingSign = false) {\n        mesh.setParent(null, preserveScalingSign);\n        return this;\n    }\n    // Facet data\n    /** @internal */\n    _initFacetData() {\n        const data = this._internalAbstractMeshDataInfo._facetData;\n        if (!data.facetNormals) {\n            data.facetNormals = new Array();\n        }\n        if (!data.facetPositions) {\n            data.facetPositions = new Array();\n        }\n        if (!data.facetPartitioning) {\n            data.facetPartitioning = new Array();\n        }\n        data.facetNb = (this.getIndices().length / 3) | 0;\n        data.partitioningSubdivisions = data.partitioningSubdivisions ? data.partitioningSubdivisions : 10; // default nb of partitioning subdivisions = 10\n        data.partitioningBBoxRatio = data.partitioningBBoxRatio ? data.partitioningBBoxRatio : 1.01; // default ratio 1.01 = the partitioning is 1% bigger than the bounding box\n        for (let f = 0; f < data.facetNb; f++) {\n            data.facetNormals[f] = Vector3.Zero();\n            data.facetPositions[f] = Vector3.Zero();\n        }\n        data.facetDataEnabled = true;\n        return this;\n    }\n    /**\n     * Updates the mesh facetData arrays and the internal partitioning when the mesh is morphed or updated.\n     * This method can be called within the render loop.\n     * You don't need to call this method by yourself in the render loop when you update/morph a mesh with the methods CreateXXX() as they automatically manage this computation\n     * @returns the current mesh\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/facetData\n     */\n    updateFacetData() {\n        const data = this._internalAbstractMeshDataInfo._facetData;\n        if (!data.facetDataEnabled) {\n            this._initFacetData();\n        }\n        const positions = this.getVerticesData(VertexBuffer.PositionKind);\n        const indices = this.getIndices();\n        const normals = this.getVerticesData(VertexBuffer.NormalKind);\n        const bInfo = this.getBoundingInfo();\n        if (data.facetDepthSort && !data.facetDepthSortEnabled) {\n            // init arrays, matrix and sort function on first call\n            data.facetDepthSortEnabled = true;\n            if (indices instanceof Uint16Array) {\n                data.depthSortedIndices = new Uint16Array(indices);\n            }\n            else if (indices instanceof Uint32Array) {\n                data.depthSortedIndices = new Uint32Array(indices);\n            }\n            else {\n                let needs32bits = false;\n                for (let i = 0; i < indices.length; i++) {\n                    if (indices[i] > 65535) {\n                        needs32bits = true;\n                        break;\n                    }\n                }\n                if (needs32bits) {\n                    data.depthSortedIndices = new Uint32Array(indices);\n                }\n                else {\n                    data.depthSortedIndices = new Uint16Array(indices);\n                }\n            }\n            data.facetDepthSortFunction = function (f1, f2) {\n                return f2.sqDistance - f1.sqDistance;\n            };\n            if (!data.facetDepthSortFrom) {\n                const camera = this.getScene().activeCamera;\n                data.facetDepthSortFrom = camera ? camera.position : Vector3.Zero();\n            }\n            data.depthSortedFacets = [];\n            for (let f = 0; f < data.facetNb; f++) {\n                const depthSortedFacet = { ind: f * 3, sqDistance: 0.0 };\n                data.depthSortedFacets.push(depthSortedFacet);\n            }\n            data.invertedMatrix = Matrix.Identity();\n            data.facetDepthSortOrigin = Vector3.Zero();\n        }\n        data.bbSize.x = bInfo.maximum.x - bInfo.minimum.x > Epsilon ? bInfo.maximum.x - bInfo.minimum.x : Epsilon;\n        data.bbSize.y = bInfo.maximum.y - bInfo.minimum.y > Epsilon ? bInfo.maximum.y - bInfo.minimum.y : Epsilon;\n        data.bbSize.z = bInfo.maximum.z - bInfo.minimum.z > Epsilon ? bInfo.maximum.z - bInfo.minimum.z : Epsilon;\n        let bbSizeMax = data.bbSize.x > data.bbSize.y ? data.bbSize.x : data.bbSize.y;\n        bbSizeMax = bbSizeMax > data.bbSize.z ? bbSizeMax : data.bbSize.z;\n        data.subDiv.max = data.partitioningSubdivisions;\n        data.subDiv.X = Math.floor((data.subDiv.max * data.bbSize.x) / bbSizeMax); // adjust the number of subdivisions per axis\n        data.subDiv.Y = Math.floor((data.subDiv.max * data.bbSize.y) / bbSizeMax); // according to each bbox size per axis\n        data.subDiv.Z = Math.floor((data.subDiv.max * data.bbSize.z) / bbSizeMax);\n        data.subDiv.X = data.subDiv.X < 1 ? 1 : data.subDiv.X; // at least one subdivision\n        data.subDiv.Y = data.subDiv.Y < 1 ? 1 : data.subDiv.Y;\n        data.subDiv.Z = data.subDiv.Z < 1 ? 1 : data.subDiv.Z;\n        // set the parameters for ComputeNormals()\n        data.facetParameters.facetNormals = this.getFacetLocalNormals();\n        data.facetParameters.facetPositions = this.getFacetLocalPositions();\n        data.facetParameters.facetPartitioning = this.getFacetLocalPartitioning();\n        data.facetParameters.bInfo = bInfo;\n        data.facetParameters.bbSize = data.bbSize;\n        data.facetParameters.subDiv = data.subDiv;\n        data.facetParameters.ratio = this.partitioningBBoxRatio;\n        data.facetParameters.depthSort = data.facetDepthSort;\n        if (data.facetDepthSort && data.facetDepthSortEnabled) {\n            this.computeWorldMatrix(true);\n            this._worldMatrix.invertToRef(data.invertedMatrix);\n            Vector3.TransformCoordinatesToRef(data.facetDepthSortFrom, data.invertedMatrix, data.facetDepthSortOrigin);\n            data.facetParameters.distanceTo = data.facetDepthSortOrigin;\n        }\n        data.facetParameters.depthSortedFacets = data.depthSortedFacets;\n        if (normals) {\n            VertexData.ComputeNormals(positions, indices, normals, data.facetParameters);\n        }\n        if (data.facetDepthSort && data.facetDepthSortEnabled) {\n            data.depthSortedFacets.sort(data.facetDepthSortFunction);\n            const l = (data.depthSortedIndices.length / 3) | 0;\n            for (let f = 0; f < l; f++) {\n                const sind = data.depthSortedFacets[f].ind;\n                data.depthSortedIndices[f * 3] = indices[sind];\n                data.depthSortedIndices[f * 3 + 1] = indices[sind + 1];\n                data.depthSortedIndices[f * 3 + 2] = indices[sind + 2];\n            }\n            this.updateIndices(data.depthSortedIndices, undefined, true);\n        }\n        return this;\n    }\n    /**\n     * Returns the facetLocalNormals array.\n     * The normals are expressed in the mesh local spac\n     * @returns an array of Vector3\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/facetData\n     */\n    getFacetLocalNormals() {\n        const facetData = this._internalAbstractMeshDataInfo._facetData;\n        if (!facetData.facetNormals) {\n            this.updateFacetData();\n        }\n        return facetData.facetNormals;\n    }\n    /**\n     * Returns the facetLocalPositions array.\n     * The facet positions are expressed in the mesh local space\n     * @returns an array of Vector3\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/facetData\n     */\n    getFacetLocalPositions() {\n        const facetData = this._internalAbstractMeshDataInfo._facetData;\n        if (!facetData.facetPositions) {\n            this.updateFacetData();\n        }\n        return facetData.facetPositions;\n    }\n    /**\n     * Returns the facetLocalPartitioning array\n     * @returns an array of array of numbers\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/facetData\n     */\n    getFacetLocalPartitioning() {\n        const facetData = this._internalAbstractMeshDataInfo._facetData;\n        if (!facetData.facetPartitioning) {\n            this.updateFacetData();\n        }\n        return facetData.facetPartitioning;\n    }\n    /**\n     * Returns the i-th facet position in the world system.\n     * This method allocates a new Vector3 per call\n     * @param i defines the facet index\n     * @returns a new Vector3\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/facetData\n     */\n    getFacetPosition(i) {\n        const pos = Vector3.Zero();\n        this.getFacetPositionToRef(i, pos);\n        return pos;\n    }\n    /**\n     * Sets the reference Vector3 with the i-th facet position in the world system\n     * @param i defines the facet index\n     * @param ref defines the target vector\n     * @returns the current mesh\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/facetData\n     */\n    getFacetPositionToRef(i, ref) {\n        const localPos = this.getFacetLocalPositions()[i];\n        const world = this.getWorldMatrix();\n        Vector3.TransformCoordinatesToRef(localPos, world, ref);\n        return this;\n    }\n    /**\n     * Returns the i-th facet normal in the world system.\n     * This method allocates a new Vector3 per call\n     * @param i defines the facet index\n     * @returns a new Vector3\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/facetData\n     */\n    getFacetNormal(i) {\n        const norm = Vector3.Zero();\n        this.getFacetNormalToRef(i, norm);\n        return norm;\n    }\n    /**\n     * Sets the reference Vector3 with the i-th facet normal in the world system\n     * @param i defines the facet index\n     * @param ref defines the target vector\n     * @returns the current mesh\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/facetData\n     */\n    getFacetNormalToRef(i, ref) {\n        const localNorm = this.getFacetLocalNormals()[i];\n        Vector3.TransformNormalToRef(localNorm, this.getWorldMatrix(), ref);\n        return this;\n    }\n    /**\n     * Returns the facets (in an array) in the same partitioning block than the one the passed coordinates are located (expressed in the mesh local system)\n     * @param x defines x coordinate\n     * @param y defines y coordinate\n     * @param z defines z coordinate\n     * @returns the array of facet indexes\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/facetData\n     */\n    getFacetsAtLocalCoordinates(x, y, z) {\n        const bInfo = this.getBoundingInfo();\n        const data = this._internalAbstractMeshDataInfo._facetData;\n        const ox = Math.floor(((x - bInfo.minimum.x * data.partitioningBBoxRatio) * data.subDiv.X * data.partitioningBBoxRatio) / data.bbSize.x);\n        const oy = Math.floor(((y - bInfo.minimum.y * data.partitioningBBoxRatio) * data.subDiv.Y * data.partitioningBBoxRatio) / data.bbSize.y);\n        const oz = Math.floor(((z - bInfo.minimum.z * data.partitioningBBoxRatio) * data.subDiv.Z * data.partitioningBBoxRatio) / data.bbSize.z);\n        if (ox < 0 || ox > data.subDiv.max || oy < 0 || oy > data.subDiv.max || oz < 0 || oz > data.subDiv.max) {\n            return null;\n        }\n        return data.facetPartitioning[ox + data.subDiv.max * oy + data.subDiv.max * data.subDiv.max * oz];\n    }\n    /**\n     * Returns the closest mesh facet index at (x,y,z) World coordinates, null if not found\n     * @param x defines x coordinate\n     * @param y defines y coordinate\n     * @param z defines z coordinate\n     * @param projected sets as the (x,y,z) world projection on the facet\n     * @param checkFace if true (default false), only the facet \"facing\" to (x,y,z) or only the ones \"turning their backs\", according to the parameter \"facing\" are returned\n     * @param facing if facing and checkFace are true, only the facet \"facing\" to (x, y, z) are returned : positive dot (x, y, z) * facet position. If facing si false and checkFace is true, only the facet \"turning their backs\" to (x, y, z) are returned : negative dot (x, y, z) * facet position\n     * @returns the face index if found (or null instead)\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/facetData\n     */\n    getClosestFacetAtCoordinates(x, y, z, projected, checkFace = false, facing = true) {\n        const world = this.getWorldMatrix();\n        const invMat = TmpVectors.Matrix[5];\n        world.invertToRef(invMat);\n        const invVect = TmpVectors.Vector3[8];\n        Vector3.TransformCoordinatesFromFloatsToRef(x, y, z, invMat, invVect); // transform (x,y,z) to coordinates in the mesh local space\n        const closest = this.getClosestFacetAtLocalCoordinates(invVect.x, invVect.y, invVect.z, projected, checkFace, facing);\n        if (projected) {\n            // transform the local computed projected vector to world coordinates\n            Vector3.TransformCoordinatesFromFloatsToRef(projected.x, projected.y, projected.z, world, projected);\n        }\n        return closest;\n    }\n    /**\n     * Returns the closest mesh facet index at (x,y,z) local coordinates, null if not found\n     * @param x defines x coordinate\n     * @param y defines y coordinate\n     * @param z defines z coordinate\n     * @param projected sets as the (x,y,z) local projection on the facet\n     * @param checkFace if true (default false), only the facet \"facing\" to (x,y,z) or only the ones \"turning their backs\", according to the parameter \"facing\" are returned\n     * @param facing if facing and checkFace are true, only the facet \"facing\" to (x, y, z) are returned : positive dot (x, y, z) * facet position. If facing si false and checkFace is true, only the facet \"turning their backs\" to (x, y, z) are returned : negative dot (x, y, z) * facet position\n     * @returns the face index if found (or null instead)\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/facetData\n     */\n    getClosestFacetAtLocalCoordinates(x, y, z, projected, checkFace = false, facing = true) {\n        let closest = null;\n        let tmpx = 0.0;\n        let tmpy = 0.0;\n        let tmpz = 0.0;\n        let d = 0.0; // tmp dot facet normal * facet position\n        let t0 = 0.0;\n        let projx = 0.0;\n        let projy = 0.0;\n        let projz = 0.0;\n        // Get all the facets in the same partitioning block than (x, y, z)\n        const facetPositions = this.getFacetLocalPositions();\n        const facetNormals = this.getFacetLocalNormals();\n        const facetsInBlock = this.getFacetsAtLocalCoordinates(x, y, z);\n        if (!facetsInBlock) {\n            return null;\n        }\n        // Get the closest facet to (x, y, z)\n        let shortest = Number.MAX_VALUE; // init distance vars\n        let tmpDistance = shortest;\n        let fib; // current facet in the block\n        let norm; // current facet normal\n        let p0; // current facet barycenter position\n        // loop on all the facets in the current partitioning block\n        for (let idx = 0; idx < facetsInBlock.length; idx++) {\n            fib = facetsInBlock[idx];\n            norm = facetNormals[fib];\n            p0 = facetPositions[fib];\n            d = (x - p0.x) * norm.x + (y - p0.y) * norm.y + (z - p0.z) * norm.z;\n            if (!checkFace || (checkFace && facing && d >= 0.0) || (checkFace && !facing && d <= 0.0)) {\n                // compute (x,y,z) projection on the facet = (projx, projy, projz)\n                d = norm.x * p0.x + norm.y * p0.y + norm.z * p0.z;\n                t0 = -(norm.x * x + norm.y * y + norm.z * z - d) / (norm.x * norm.x + norm.y * norm.y + norm.z * norm.z);\n                projx = x + norm.x * t0;\n                projy = y + norm.y * t0;\n                projz = z + norm.z * t0;\n                tmpx = projx - x;\n                tmpy = projy - y;\n                tmpz = projz - z;\n                tmpDistance = tmpx * tmpx + tmpy * tmpy + tmpz * tmpz; // compute length between (x, y, z) and its projection on the facet\n                if (tmpDistance < shortest) {\n                    // just keep the closest facet to (x, y, z)\n                    shortest = tmpDistance;\n                    closest = fib;\n                    if (projected) {\n                        projected.x = projx;\n                        projected.y = projy;\n                        projected.z = projz;\n                    }\n                }\n            }\n        }\n        return closest;\n    }\n    /**\n     * Returns the object \"parameter\" set with all the expected parameters for facetData computation by ComputeNormals()\n     * @returns the parameters\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/facetData\n     */\n    getFacetDataParameters() {\n        return this._internalAbstractMeshDataInfo._facetData.facetParameters;\n    }\n    /**\n     * Disables the feature FacetData and frees the related memory\n     * @returns the current mesh\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/facetData\n     */\n    disableFacetData() {\n        const facetData = this._internalAbstractMeshDataInfo._facetData;\n        if (facetData.facetDataEnabled) {\n            facetData.facetDataEnabled = false;\n            facetData.facetPositions = new Array();\n            facetData.facetNormals = new Array();\n            facetData.facetPartitioning = new Array();\n            facetData.facetParameters = null;\n            facetData.depthSortedIndices = new Uint32Array(0);\n        }\n        return this;\n    }\n    /**\n     * Updates the AbstractMesh indices array\n     * @param indices defines the data source\n     * @param offset defines the offset in the index buffer where to store the new data (can be null)\n     * @param gpuMemoryOnly defines a boolean indicating that only the GPU memory must be updated leaving the CPU version of the indices unchanged (false by default)\n     * @returns the current mesh\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    updateIndices(indices, offset, gpuMemoryOnly = false) {\n        return this;\n    }\n    /**\n     * Creates new normals data for the mesh\n     * @param updatable defines if the normal vertex buffer must be flagged as updatable\n     * @returns the current mesh\n     */\n    createNormals(updatable) {\n        const positions = this.getVerticesData(VertexBuffer.PositionKind);\n        const indices = this.getIndices();\n        let normals;\n        if (this.isVerticesDataPresent(VertexBuffer.NormalKind)) {\n            normals = this.getVerticesData(VertexBuffer.NormalKind);\n        }\n        else {\n            normals = [];\n        }\n        VertexData.ComputeNormals(positions, indices, normals, { useRightHandedSystem: this.getScene().useRightHandedSystem });\n        this.setVerticesData(VertexBuffer.NormalKind, normals, updatable);\n        return this;\n    }\n    /**\n     * Align the mesh with a normal\n     * @param normal defines the normal to use\n     * @param upDirection can be used to redefined the up vector to use (will use the (0, 1, 0) by default)\n     * @returns the current mesh\n     */\n    alignWithNormal(normal, upDirection) {\n        if (!upDirection) {\n            upDirection = Axis.Y;\n        }\n        const axisX = TmpVectors.Vector3[0];\n        const axisZ = TmpVectors.Vector3[1];\n        Vector3.CrossToRef(upDirection, normal, axisZ);\n        Vector3.CrossToRef(normal, axisZ, axisX);\n        if (this.rotationQuaternion) {\n            Quaternion.RotationQuaternionFromAxisToRef(axisX, normal, axisZ, this.rotationQuaternion);\n        }\n        else {\n            Vector3.RotationFromAxisToRef(axisX, normal, axisZ, this.rotation);\n        }\n        return this;\n    }\n    /** @internal */\n    _checkOcclusionQuery() {\n        // Will be replaced by correct code if Occlusion queries are referenced\n        return false;\n    }\n    /**\n     * Disables the mesh edge rendering mode\n     * @returns the currentAbstractMesh\n     */\n    disableEdgesRendering() {\n        throw _WarnImport(\"EdgesRenderer\");\n    }\n    /**\n     * Enables the edge rendering mode on the mesh.\n     * This mode makes the mesh edges visible\n     * @param epsilon defines the maximal distance between two angles to detect a face\n     * @param checkVerticesInsteadOfIndices indicates that we should check vertex list directly instead of faces\n     * @param options options to the edge renderer\n     * @returns the currentAbstractMesh\n     * @see https://www.babylonjs-playground.com/#19O9TU#0\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    enableEdgesRendering(epsilon, checkVerticesInsteadOfIndices, options) {\n        throw _WarnImport(\"EdgesRenderer\");\n    }\n    /**\n     * This function returns all of the particle systems in the scene that use the mesh as an emitter.\n     * @returns an array of particle systems in the scene that use the mesh as an emitter\n     */\n    getConnectedParticleSystems() {\n        return this._scene.particleSystems.filter((particleSystem) => particleSystem.emitter === this);\n    }\n}\n/** No occlusion */\nAbstractMesh.OCCLUSION_TYPE_NONE = 0;\n/** Occlusion set to optimistic */\nAbstractMesh.OCCLUSION_TYPE_OPTIMISTIC = 1;\n/** Occlusion set to strict */\nAbstractMesh.OCCLUSION_TYPE_STRICT = 2;\n/** Use an accurate occlusion algorithm */\nAbstractMesh.OCCLUSION_ALGORITHM_TYPE_ACCURATE = 0;\n/** Use a conservative occlusion algorithm */\nAbstractMesh.OCCLUSION_ALGORITHM_TYPE_CONSERVATIVE = 1;\n/** Default culling strategy : this is an exclusion test and it's the more accurate.\n *  Test order :\n *  Is the bounding sphere outside the frustum ?\n *  If not, are the bounding box vertices outside the frustum ?\n *  It not, then the cullable object is in the frustum.\n */\nAbstractMesh.CULLINGSTRATEGY_STANDARD = 0;\n/** Culling strategy : Bounding Sphere Only.\n *  This is an exclusion test. It's faster than the standard strategy because the bounding box is not tested.\n *  It's also less accurate than the standard because some not visible objects can still be selected.\n *  Test : is the bounding sphere outside the frustum ?\n *  If not, then the cullable object is in the frustum.\n */\nAbstractMesh.CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY = 1;\n/** Culling strategy : Optimistic Inclusion.\n *  This in an inclusion test first, then the standard exclusion test.\n *  This can be faster when a cullable object is expected to be almost always in the camera frustum.\n *  This could also be a little slower than the standard test when the tested object center is not the frustum but one of its bounding box vertex is still inside.\n *  Anyway, it's as accurate as the standard strategy.\n *  Test :\n *  Is the cullable object bounding sphere center in the frustum ?\n *  If not, apply the default culling strategy.\n */\nAbstractMesh.CULLINGSTRATEGY_OPTIMISTIC_INCLUSION = 2;\n/** Culling strategy : Optimistic Inclusion then Bounding Sphere Only.\n *  This in an inclusion test first, then the bounding sphere only exclusion test.\n *  This can be the fastest test when a cullable object is expected to be almost always in the camera frustum.\n *  This could also be a little slower than the BoundingSphereOnly strategy when the tested object center is not in the frustum but its bounding sphere still intersects it.\n *  It's less accurate than the standard strategy and as accurate as the BoundingSphereOnly strategy.\n *  Test :\n *  Is the cullable object bounding sphere center in the frustum ?\n *  If not, apply the Bounding Sphere Only strategy. No Bounding Box is tested here.\n */\nAbstractMesh.CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY = 3;\nRegisterClass(\"BABYLON.AbstractMesh\", AbstractMesh);\n//# sourceMappingURL=abstractMesh.js.map"],"names":["Space","Coordinate","Axis","X","Y","Z","Color3","constructor","r","g","b","this","toString","getClassName","getHashCode","hash","toArray","array","index","fromArray","offset","FromArrayToRef","toColor4","alpha","Color4","asArray","toLuminance","multiply","otherColor","multiplyToRef","result","equals","equalsFloats","scale","scaleInPlace","scaleToRef","scaleAndAddToRef","clampToRef","min","max","add","addToRef","subtract","subtractToRef","clone","copyFrom","source","copyFromFloats","set","toHexString","intR","Math","round","intG","intB","toLinearSpace","convertedColor","toLinearSpaceToRef","toHSV","toHSVToRef","h","s","v","dm","pow","toGammaSpace","toGammaSpaceToRef","static","hue","saturation","value","chroma","x","abs","m","HSVtoRGBToRef","hex","substring","length","parseInt","FromInts","start","end","amount","LerpToRef","left","right","value1","tangent1","value2","tangent2","squared","cubed","part1","part2","part3","part4","time","Black","Hermite1stDerivativeToRef","t2","BlackReadOnly","_BlackReadOnly","random","a","addInPlace","color","returnAsColor3","intA","color3","colors","count","colors4","newIndex","TmpColors","ToGammaSpace","ToLinearSpace","PHI","sqrt","Epsilon","Frustum","transform","frustumPlanes","push","GetPlanesToRef","frustumPlane","normal","y","z","d","normalize","GetNearPlaneToRef","GetFarPlaneToRef","GetLeftPlaneToRef","GetRightPlaneToRef","GetTopPlaneToRef","GetBottomPlaneToRef","MathHelpers","positions","indices","indexStart","indexCount","minimum","maximum","minimizeInPlaceFromFloats","maximizeInPlaceFromFloats","stride","extractMinAndMaxIndexed","bias","Number","MAX_VALUE","extractMinAndMax","Array","isArray","_IsoVector","floor","rotate60About","other","rotateNeg60About","rotate120","n","rotateNeg120","toCartesianOrigin","origin","isoGridSize","point","Orientation","Angle","radians","_radians","PI","degrees","delta","theta","atan2","Arc2","startPoint","midPoint","endPoint","temp","startToMid","midToEnd","det","centerPoint","radius","startAngle","BetweenTwoPoints","a1","a2","a3","orientation","CW","CCW","angle","FromDegrees","Path2","_points","_length","closed","addLineTo","newPoint","previousPoint","addArcTo","midX","midY","endX","endY","numberOfSegments","arc","increment","currentAngle","i","cos","sin","close","lastPoint","getPoints","getPointAtLengthPosition","normalizedLengthPosition","lengthPosition","previousOffset","j","bToA","nextOffset","dir","localOffset","Path3D","path","firstNormal","raw","alignTangentsWithPath","_curve","_distances","_tangents","_normals","_binormals","_pointAtData","id","previousPointArrayIndex","position","subPosition","interpolateReady","interpolationMatrix","p","_raw","_alignTangentsWithPath","_compute","getCurve","getTangents","getNormals","getBinormals","getDistances","getPointAt","_updatePointAtData","getTangentAt","interpolated","getNormalAt","getBinormalAt","getDistanceAt","getPreviousPointIndexAt","getSubPositionAt","getClosestPositionTo","target","smallestDistance","closestPosition","tangent","subLength","distance","slice","_start","curvePoints","startIndex","endIndex","slicePoints","update","l","_getFirstNonNullVector","tg0","pp0","_normalVector","prev","cur","curTang","prevNor","prevBinor","_getLastNonNullVector","NaN","nNVector","nLVector","vt","va","normal0","tgl","interpolateTNB","_updateInterpolationMatrix","_setPointAtData","currentPoint","currentLength","targetLength","diff","parentIndex","tangentFrom","normalFrom","binormalFrom","tangentTo","normalTo","binormalTo","quatFrom","quatTo","toRotationMatrix","Curve3","v0","v1","v2","nbPoints","bez","equation","t","val0","val1","val2","v3","val3","p1","t1","p2","nSeg","hermite","step","points","catmullRom","pointsCount","c","totalPoints","prototype","apply","first","second","third","steps","fullCircle","vec1","vec2","vec3","zAxis","len4","len1_sq","lengthSquared","len2_sq","len3_sq","len4_sq","center","xAxis","yAxis","dStep","equalsWithEpsilon","_computeLength","continue","curve","continuedPoints","Plane","norm","magnitude","transformation","invertedMatrix","_TmpMatrix","invertToRef","normalX","normalY","normalZ","finalD","dotCoordinate","copyFromPoints","point1","point2","point3","x1","y1","z1","x2","y2","z2","yz","xz","xy","pyth","invPyth","isFrontFacingTo","direction","epsilon","signedDistanceTo","Scalar","str","toUpperCase","isNaN","log","LOG2E","log2","Infinity","normalized","current","num","Repeat","tx","from","to","Clamp","maxDelta","Sign","DeltaAngle","MoveTowards","number","percent","TwoPi","HCF","Size","width","height","src","multiplyByFloats","w","surface","otherSize","_ExtractAsInt","replace","Vector2","otherVector","addVector3","subtractInPlace","multiplyInPlace","divide","divideToRef","divideInPlace","negate","negateInPlace","negateToRef","fract","rotateToRef","NormalizeToRef","ZeroReadOnly","_ZeroReadOnly","value3","value4","vector","newVector","len","TransformToRef","p0","sign","DistanceSquared","CenterToRef","ref","segA","segB","l2","Distance","Dot","proj","Zero","Vector3","_x","_isDirty","_y","_z","toQuaternion","Quaternion","RotationYawPitchRoll","addInPlaceFromFloats","subtractFromFloatsToRef","subtractFromFloats","getNormalToRef","acos","phi","applyRotationQuaternionToRef","q","ix","_w","iy","iz","iw","applyRotationQuaternionInPlace","applyRotationQuaternion","projectOnPlane","plane","projectOnPlaneToRef","V","MathTmp","denom","setAll","scaledV","equalsToFloats","minimizeInPlace","maximizeInPlace","isNonUniformWithinEpsilon","absX","absY","absZ","isNonUniform","hasAZeroComponent","normalizeFromLength","reorderInPlace","order","toLowerCase","forEach","val","rotateByQuaternionToRef","quaternion","Matrix","TransformCoordinatesToRef","rotateByQuaternionAroundPointToRef","cross","CrossToRef","normalizeToNew","normalizeToRef","reference","vector0","vector1","axis","size","d0","dot","vNormal","forward","TmpVectors","PitchYawRollToMoveBetweenPointsToRef","slerp","vector0Dir","vector1Dir","vector0Length","vector1Length","scale0","scale1","omega","invSin","goal","deltaTime","lerpTime","SlerpToRef","FromArray","UpReadOnly","_UpReadOnly","DownReadOnly","_DownReadOnly","RightReadOnly","_RightReadOnly","LeftReadOnly","_LeftReadOnly","LeftHandedForwardReadOnly","_LeftHandedForwardReadOnly","RightHandedForwardReadOnly","_RightHandedForwardReadOnly","rightHandedSystem","TransformCoordinatesFromFloatsToRef","rx","ry","rz","rw","TransformNormalToRef","TransformNormalFromFloatsToRef","ClampToRef","world","viewport","ProjectToRef","cw","ch","cx","cy","viewportMatrix","FromValuesToRef","matrix","inDirection","ReflectToRef","tmp","viewportWidth","viewportHeight","Unproject","IdentityReadOnly","view","projection","UnprojectToRef","UnprojectFloatsToRef","sourceX","sourceY","sourceZ","_a","invert","screenSource","isNDCHalfZRange","_UnprojectFromInvertedMatrixToRef","p1p0","p2p0","p2p1","vectorp0","p1p0L","p2p0L","p2p1L","nl","cosA","projVector","projP","s0","s1","s2","edge","e0","e1","tmp2","tmp3","e0proj","e0projL","cosG","triProj","axis1","axis2","axis3","rotation","RotationFromAxisToRef","quat","RotationQuaternionFromAxisToRef","toEulerAnglesToRef","Up","Down","Forward","Right","Left","Vector4","undefined","toVector3","otherQuaternion","q1","conjugateToRef","conjugateInPlace","conjugate","invertInPlace","inv","toEulerAngles","qz","qx","qy","qw","zAxisY","limit","sqw","sqz","sqx","sqy","asin","FromQuaternionToRef","fromRotationMatrix","FromRotationMatrixToRef","data","m11","m12","m13","m21","m22","m23","m31","m32","m33","trace","quat0","quat1","RotationAxisToRef","RotationYawPitchRollToRef","vec","vecFrom","vecTo","yaw","pitch","roll","halfRoll","halfPitch","halfYaw","sinRoll","cosRoll","sinPitch","cosPitch","sinYaw","cosYaw","beta","gamma","RotationAlphaBetaGammaToRef","halfGammaPlusAlpha","halfGammaMinusAlpha","halfBeta","rotMat","FromXYZAxesToRef","up","FromLookDirectionLHToRef","LookDirectionLHToRef","FromLookDirectionRHToRef","LookDirectionRHToRef","Identity","num2","num3","num4","flag","num5","num6","Use64Bits","_m","markAsUpdated","updateFlag","_UpdateFlagSeed","_isIdentity","_isIdentity3x2","_isIdentityDirty","_isIdentity3x2Dirty","_updateIdentityStatus","isIdentity","isIdentityDirty","isIdentity3x2","isIdentity3x2Dirty","isIdentityAs3x2","determinant","m00","m01","m02","m03","m10","m20","m30","det_22_33","det_21_33","det_21_32","det_20_33","det_20_32","det_20_31","reset","resultM","otherM","addToSelf","IdentityToRef","cofact_00","cofact_01","cofact_02","cofact_03","detInv","det_12_33","det_11_33","det_11_32","det_10_33","det_10_32","det_10_31","det_12_23","det_11_23","det_11_22","det_10_23","det_10_22","det_10_21","cofact_10","cofact_11","cofact_12","cofact_13","cofact_20","cofact_21","cofact_22","cofact_23","cofact_30","cofact_31","cofact_32","cofact_33","addAtIndex","multiplyAtIndex","setTranslationFromFloats","addTranslationFromFloats","setTranslation","vector3","getTranslation","getTranslationToRef","removeRotationAndScaling","copyToArray","o","multiplyToArray","tm0","tm1","tm2","tm3","tm4","tm5","tm6","tm7","tm8","tm9","tm10","tm11","tm12","tm13","tm14","tm15","om0","om1","om2","om3","om4","om5","om6","om7","om8","om9","om10","om11","om12","om13","om14","om15","om","decomposeToTransformNode","node","rotationQuaternion","decompose","scaling","translation","preserveScalingNode","signX","signY","signZ","sx","sy","sz","getRow","getRowToRef","rowVector","setRow","row","setRowFromFloats","transpose","TransposeToRef","transposeToRef","toNormalMatrix","getRotationMatrix","getRotationMatrixToRef","toggleModelMatrixHandInPlace","toggleProjectionMatrixHandInPlace","_IdentityReadOnly","initialM11","initialM12","initialM13","initialM14","initialM21","initialM22","initialM23","initialM24","initialM31","initialM32","initialM33","initialM34","initialM41","initialM42","initialM43","initialM44","ComposeToRef","xx","yy","zz","wx","wy","wz","identity","FromValues","zero","RotationXToRef","RotationYToRef","RotationZToRef","c1","Cross","k","ScalingToRef","TranslationToRef","startValue","endValue","gradient","startM","endM","DecomposeLerpToRef","startScale","startRotation","startTranslation","endScale","endRotation","endTranslation","resultScale","resultRotation","resultTranslation","eye","LookAtLHToRef","xSquareLength","ex","ey","ez","LookAtRHToRef","back","znear","zfar","halfZRange","OrthoLHToRef","mtxConvertNDCToHalfZRange","bottom","top","OrthoOffCenterLHToRef","i0","i1","OrthoOffCenterRHToRef","projectionPlaneTilt","rot","tan","fov","aspect","reverseDepthBufferMode","PerspectiveFovLHToRef","isVerticalFovFixed","f","PerspectiveFovRHToRef","rightHanded","rightHandedFactor","upTan","upDegrees","downTan","downDegrees","leftTan","leftDegrees","rightTan","rightDegrees","xScale","yScale","zmin","zmax","arr","Float32Array","rm","mm","ReflectionToRef","temp2","temp3","xaxis","yaxis","zaxis","zw","zx","yw","xw","Viewport","toGlobal","renderWidth","renderHeight","toGlobalToRef","SH3ylmBasisConstants","SH3ylmBasisTrigonometricTerms","applySH3","lm","SHCosKernelConvolution","SphericalHarmonics","preScaled","l00","l1_1","l10","l11","l2_2","l2_1","l20","l21","l22","addLight","deltaSolidAngle","colorVector","convertIncidentRadianceToIrradiance","convertIrradianceToLambertianRadiance","preScaleForRendering","updateFromArray","updateFromFloatsArray","polynomial","SphericalPolynomial","preScaledHarmonics","_harmonics","FromPolynomial","addAmbient","updateFromHarmonics","harmonics","sp","CreateBoxVertexData","options","normals","uvs","depth","wrap","topBaseAt","bottomBaseAt","topIndex","bottomIndex","basePositions","topFaceBase","bottomFaceBase","topFaceOrder","bottomFaceOrder","unshift","pop","flat","concat","scaleArray","reduce","accumulator","currentValue","currentIndex","sideOrientation","faceUV","faceColors","frontUVs","backUVs","vertexData","totalColors","CreateBox","name","scene","box","_originalBuilderSideOrientation","applyToMesh","updatable","CreateCapsuleVertexData","subdivisions","tessellation","capSubdivisions","capDetail","radialSegments","heightSegments","radiusTop","radiusBottom","heightMinusCaps","thetaLength","capsTopSegments","topCapSubdivisions","capsBottomSegments","bottomCapSubdivisions","vertices","indexArray","halfHeight","pi2","vertex","cosAlpha","sinAlpha","coneLength","vl","indexRow","sinA","_radius","u","sinTheta","cosTheta","coneHeight","slope","i2","i3","i4","reverse","vDat","CreateCapsule","capsule","CreateCylinderVertexData","diameterTop","diameter","diameterBottom","hasRings","enclose","cap","surfaceNb","angleStep","ringVertex","ringNormal","ringFirstVertex","ringFirstNormal","quadNormal","ringIdx","cs","e","createCylinderCap","isTop","circleVector","vbase","textureScale","textureCoordinate","CreateCylinder","cylinder","xpAxis","xnAxis","ypAxis","ynAxis","zpAxis","znAxis","DecalVertex","uv","vertexIdx","vertexIdxForBones","localPositionOverride","localNormalOverride","matrixIndicesOverride","matrixWeightsOverride","_b","_c","_d","CreateDecal","sourceMesh","hasSkeleton","skeleton","useLocalComputation","localMode","meshHasOverridenMaterial","overrideMaterialSideOrientation","getIndices","getPositionData","getVerticesData","getNormalsData","localPositions","localNormals","matIndices","matWeights","matIndicesExtra","matWeightsExtra","camera","getScene","activeCamera","cameraWorldTarget","getWorldMatrix","globalPosition","decalWorldMatrix","inverseDecalWorldMatrix","transformMatrix","matricesIndices","matricesWeights","matricesIndicesExtra","matricesWeightsExtra","currentVertexDataIndex","extractDecalVector3","indexId","vertexId","captureUVS","emptyArray","clip","clipSize","indexOf","clipVertices","_e","_f","_g","_h","_j","_k","_l","_o","_p","_q","_r","clipFactor","weights","mat0Index","v0Indices","v0Weights","mat1Index","v1Indices","v1Weights","idx","ind","sumw","v0LocalPositionX","v0LocalPositionY","v0LocalPositionZ","v1LocalPositionX","v1LocalPositionY","v1LocalPositionZ","v0LocalNormalX","v0LocalNormalY","v0LocalNormalZ","interpNormalX","interpNormalY","interpNormalZ","clipResult","total","nV1","nV2","nV3","nV4","v1Out","v2Out","v3Out","oneFaceVertices","faceVertices","cullBackFaces","vIndex","decal","parent","computeWorldMatrix","refreshBoundingInfo","CreateDiscVertexData","vertexNb","CreateDisc","disc","CreateGeodesic","primTri","build","geoOptions","custom","sizeX","sizeY","sizeZ","CreateGoldberg","geodesicData","goldbergData","toGoldbergPolyhedronData","goldberg","minX","maxX","minY","maxY","face","verts","ba","ca","pdata","vCoord","CreateGoldbergVertexData","nbSharedFaces","sharedNodes","nbUnsharedFaces","poleNodes","adjacentFaces","nbFaces","nbFacesAtPole","faceCenters","faceXaxis","faceYaxis","faceZaxis","CreateGroundVertexData","col","subdivisionsX","subdivisionsY","CreateTiledGroundVertexData","xmin","xmax","precision","tileRow","tileCol","tileSize","applyTile","xTileMin","zTileMin","xTileMax","zTileMax","base","rowLength","square","CreateGroundFromHeightMapVertexData","filter","colorFilter","alphaFilter","minHeight","maxHeight","pos","bufferWidth","bufferHeight","buffer","idx1","idx2","idx3","idx4","isVisibleIdx1","isVisibleIdx2","isVisibleIdx3","CreateGround","ground","_setReady","_subdivisionsX","_subdivisionsY","_width","_height","_maxX","_maxZ","_minX","_minZ","CreateTiledGround","tiledGround","CreateGroundFromHeightMap","url","onReady","img","isDisposed","getEngine","resizeImageBitmap","offlineProvider","CreateHemisphere","segments","halfSphere","merged","CreateIcoSphereVertexData","radiusX","radiusY","radiusZ","icoVertices","ico_indices","vertices_unalias_id","ico_vertexuv","island","current_indice","face_vertex_pos","face_vertex_uv","v012","v_id","interp_vertex","c2","pos_x0","pos_x1","pos_interp","vertex_normal","centroid_x0","centroid_x1","uv_x0","uv_x1","uv_interp","CreateIcoSphere","sphere","CreateLathe","shape","paths","invertUV","rotated","pathArray","closeArray","CreateLineSystemVertexData","lines","vertexColors","CreateDashedLinesVertexData","dashSize","gapSize","dashNb","curvect","lg","nb","shft","dashshft","curshft","CreateLineSystem","instance","vertexColor","lineColors","updateVerticesData","useVertexColor","lineSystem","useVertexAlpha","material","CreateLines","CreateDashedLines","positionFunction","nbSeg","_creationDataStorage","updateMeshPositions","dashedLines","CreatePlaneVertexData","halfWidth","CreatePlane","sourcePlane","translate","setDirection","CreatePolygonVertexData","polygon","fUV","fColors","wrp","disp","distX","distZ","dist","totalLen","cumulate","CreatePolygon","earcutInjection","earcut","holes","smoothingThreshold","contours","hole","polygonTriangulation","hNb","hPoint","addHole","ExtrudePolygon","CreatePolyhedronVertexData","polyhedra","type","nbfaces","faceIdx","indexes","ang","fl","CreatePolyhedron","polyhedron","CreateRibbonVertexData","closePath","defaultOffset","customUV","customColors","us","vs","uTotalDistance","vTotalDistance","minlg","ar1","ar2","idc","closePathCorr","vectlg","path1","path2","vertex1","vertex2","pi","l1","path1nb","indexFirst","indexLast","positions32","normals32","uvs32","_idx","CreateRibbon","mesh","ns","si","pathPoint","hasBoundingInfo","getBoundingInfo","reConstruct","_worldMatrix","buildBoundingInfo","colorIndex","areNormalsFrozen","isFacetDataEnabled","params","getFacetDataParameters","ribbon","ExtrudeShape","closeShape","_ExtrudeShapeGeneric","adjustFrame","ExtrudeShapeCustom","scaleFunction","rotationFunction","ribbonCloseArray","ribbonClosePath","rotateFunction","rbCA","rbCP","updtbl","side","extrusionPathArray","path3D","shapePaths","tangents","binormals","distances","rotate","scl","rotationMatrix","shapePath","scaleRatio","planed","capPath","pointCap","barycenter","storage","extrudedGeneric","CreateSphereVertexData","diameterX","diameterY","diameterZ","dedupTopBottomIndices","totalZRotationSteps","totalYRotationSteps","zRotationStep","normalizedZ","angleZ","yRotationStep","normalizedY","angleY","rotationZ","rotationY","afterRotZ","complete","verticesCount","firstIndex","CreateSphere","CreateTiledBoxVertexData","flipTile","pattern","tileWidth","tileHeight","alignH","alignHorizontal","alignV","alignVertical","halfDepth","faceVertexData","baseAlignV","facePositions","faceNormals","newFaceUV","lu","li","map","vec0","mtrx0","entry","mtrx2","mtrx3","vec4","mtrx4","mtrx5","CreateTiledBox","CreateTiledPlaneVertexData","tilesX","offsetX","tilesY","offsetY","adjustX","adjustY","startX","startY","uvBase","partialBottomRow","partialTopRow","partialLeftCol","partialRightCol","uvPart","uvBaseBR","uvBaseTR","uvBaseLC","uvBaseRC","CreateTiledPlane","CreateTorusVertexData","thickness","outerAngle","innerAngle","dx","dy","nextI","nextJ","CreateTorus","torus","CreateTorusKnotVertexData","tube","tubularSegments","getPos","cu","su","quOverP","ty","tz","tang","bitan","jNext","CreateTorusKnot","torusKnot","CreateTube","radiusFunction","tubePathArray","circlePaths","radiusFunctionFinal","circlePath","rad","pathIndex","decodeMesh","decoderModule","dataView","attributes","onIndicesData","onAttributeData","dividers","DecoderBuffer","Init","byteLength","decoder","Decoder","geometry","status","GetEncodedGeometryType","TRIANGULAR_MESH","Mesh","DecodeBufferToMesh","POINT_CLOUD","PointCloud","DecodeBufferToPointCloud","Error","ok","ptr","error_msg","numIndices","num_faces","_malloc","GetTrianglesUInt32Array","Uint32Array","HEAPF32","_free","processAttribute","kind","attribute","divider","numComponents","num_components","numPoints","num_points","numValues","BYTES_PER_ELEMENT","GetAttributeDataArrayForAllPoints","DT_FLOAT32","values","babylonData","GetAttributeByUniqueId","nativeAttributeTypes","GetAttributeId","GetAttribute","destroy","worker","decoderPromise","onmessage","event","importScripts","DracoDecoderModule","wasmBinary","postMessage","then","DracoCompression","DecoderAvailable","Configuration","wasmUrl","wasmBinaryUrl","WebAssembly","fallbackUrl","navigator","hardwareConcurrency","Default","_Default","numWorkers","DefaultNumWorkers","decoderInfo","wasmBinaryPromise","Promise","resolve","Worker","URL","_workerPoolPromise","decoderWasmBinary","workerContent","workerBlobUrl","createObjectURL","Blob","reject","onError","error","removeEventListener","onMessage","message","addEventListener","_decoderModulePromise","module","dispose","workerPool","whenReadyAsync","decodeMeshAsync","ArrayBuffer","Uint8Array","onComplete","dataViewCopy","byteOffset","GetDefaultNumWorkers","MeshoptCompression","MeshoptDecoder","ready","decodeGltfBufferAsync","mode","decodeGltfBuffer","WebGLDataBuffer","resource","super","_buffer","underlyingResource","WebGPUDataBuffer","_FacetDataStorage","facetNb","partitioningSubdivisions","partitioningBBoxRatio","facetDataEnabled","facetParameters","bbSize","subDiv","facetDepthSort","facetDepthSortEnabled","_InternalAbstractMeshDataInfo","_hasVertexAlpha","_useVertexColors","_numBoneInfluencers","_applyFog","_receiveShadows","_facetData","_visibility","_skeleton","_layerMask","_computeBonesUsingShaders","_isActive","_onlyForInstances","_isActiveIntermediate","_onlyForInstancesIntermediate","_actAsRegularMesh","_currentLOD","_currentLODIsUpToDate","_collisionRetryCount","_morphTargetManager","_renderingGroupId","_bakedVertexAnimationManager","_material","_positions","_pointerOverDisableMeshTesting","_meshCollisionData","_enableDistantPicking","AbstractMesh","BILLBOARDMODE_NONE","BILLBOARDMODE_X","BILLBOARDMODE_Y","BILLBOARDMODE_Z","BILLBOARDMODE_ALL","BILLBOARDMODE_USE_POSITION","_internalAbstractMeshDataInfo","ratio","mustDepthSortFacets","sort","facetDepthSortFrom","location","collisionRetryCount","retryCount","morphTargetManager","_syncGeometryWithMorphTargetManager","bakedVertexAnimationManager","_markSubMeshesAsAttributesDirty","_updateNonUniformScalingState","_markSubMeshesAsMiscDirty","onCollide","callback","_onCollideObserver","onCollideObservable","remove","onCollisionPositionChange","_onCollisionPositionChangeObserver","onCollisionPositionChangeObservable","visibility","oldValue","pointerOverDisableMeshTesting","disable","renderingGroupId","meshMap","uniqueId","onMaterialChangedObservable","hasObservers","notifyObservers","subMeshes","resetDrawCache","_unBindEffect","getMaterialForRenderPass","renderPassId","_materialForRenderPass","setMaterialForRenderPass","receiveShadows","_markSubMeshesAsLightDirty","hasVertexAlpha","useVertexColors","computeBonesUsingShaders","numBoneInfluencers","applyFog","enableDistantPicking","layerMask","_resyncLightSources","collisionMask","_collisionMask","mask","collisionResponse","_collisionResponse","response","collisionGroup","_collisionGroup","surroundingMeshes","_surroundingMeshes","meshes","lightSources","_lightSources","needInitialSkinMatrix","_unregisterMeshWithPoseMatrix","_registerMeshWithPoseMatrix","_bonesTransformMatrices","_waitingMaterialId","cullingStrategy","CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY","definedFacingForward","_occlusionQuery","_renderingGroup","alphaIndex","isVisible","isPickable","isNearPickable","isNearGrabbable","showSubMeshesBoundingBox","isBlocker","enablePointerMoveEvents","outlineColor","outlineWidth","overlayColor","overlayAlpha","useOctreeForRenderingSelection","useOctreeForPicking","useOctreeForCollisions","alwaysSelectAsActiveMesh","doNotSyncBoundingInfo","actionManager","ellipsoid","ellipsoidOffset","edgesWidth","edgesColor","_edgesRenderer","_masterMesh","_boundingInfo","_boundingInfoIsDirty","_renderId","_intersectionsInProgress","_unIndexed","_waitingData","lods","actions","freezeWorldMatrix","_transformMatrixTexture","onRebuildObservable","_onCollisionPositionChange","collisionId","newPosition","collidedMesh","_oldPositionForCollisions","_diffPositionForCollisions","addMesh","_uniformBuffer","isWebGPU","_buildUniformLayout","performancePriority","addUniform","create","transferToEffect","ubo","updateMatrix","updateFloat","getMeshUniformBuffer","fullDetails","ret","billboardMode","_isWorldMatrixFrozen","_getEffectiveParent","_getActionManagerForTrigger","trigger","initialCall","isRecursive","hasSpecificTrigger","_rebuild","subMesh","light","lights","isEnabled","canAffectMesh","_resyncLightSource","isIn","removed","splice","setEffect","_removeLightSource","_markSubMeshesAsDirty","func","_drawWrappers","drawWrapper","defines","markAllAsDirty","markAsLightDirty","markAsAttributesDirty","markAsMiscDirty","markAsDirty","property","_currentRenderId","passId","isBlocked","getLOD","getTotalVertices","getTotalIndices","setVerticesData","updateExtends","makeItUnique","setIndices","totalVertices","isVerticesDataPresent","_updateBoundingInfo","setBoundingInfo","boundingInfo","worldMatrix","normalizeToUnitCube","includeDescendants","ignoreRotation","predicate","useBones","skeletonsEnabled","_preActivate","_preActivateForIntermediateRendering","renderId","_activate","intermediateRendering","_postActivate","_freeze","_unFreeze","_getWorldMatrixDeterminant","isAnInstance","hasInstances","hasThinInstances","movePOV","amountRight","amountUp","amountForward","calcMovePOV","rotMatrix","translationDelta","defForwardMult","rotatePOV","flipBack","twirlClockwise","tiltRight","calcRotatePOV","applySkeleton","applyMorph","isLocked","_refreshBoundingInfo","_getPositionData","extend","_getData","faceIndexCount","positionIndex","vertexCount","targetCount","numTargets","targetMorph","getTarget","influence","morphTargetPositions","getPositions","matricesIndicesData","matricesWeightsData","needExtras","matricesIndicesExtraData","matricesWeightsExtraData","skeletonMatrices","getTransformMatrices","tempVector","finalMatrix","tempMatrix","matWeightIdx","inf","weight","_generatePointsArray","worldMatrixFromCache","_updateSubMeshesBoundingInfo","subIndex","IsGlobal","updateBoundingInfo","_afterComputeWorldMatrix","isInFrustum","isCompletelyInFrustum","intersectsMesh","precise","otherBoundingInfo","intersects","child","getChildMeshes","intersectsPoint","checkCollisions","_checkCollisions","collisionEnabled","collider","_collider","moveWithCollisions","displacement","getAbsolutePosition","coordinator","collisionCoordinator","createCollider","getNewPosition","_collideForSubMesh","_lastColliderWorldVertices","_lastColliderTransformMatrix","_trianglePlanes","verticesStart","_collide","getMaterial","_shouldConvertRHS","fillMode","_processCollisionsForSubMeshes","_scene","getCollidingSubMeshCandidates","_checkCollision","collisionsScalingMatrix","collisionsTransformMatrix","ray","fastCheck","trianglePredicate","onlyBoundingInfo","worldToUse","skipBoundingInfo","pickingInfo","intersectionThreshold","intersectsSphere","boundingSphere","intersectsBox","boundingBox","hit","pickedMesh","subMeshId","intersectInfo","getIntersectingSubMeshCandidates","anySubmeshSupportIntersect","canIntersects","currentIntersectInfo","worldOrigin","pickedPoint","bu","bv","subMeshFaceId","faceId","newParent","doNotCloneChildren","releaseSubMeshes","doNotRecurse","disposeMaterialAndTextures","useMaterialMeshMap","freeActiveMeshes","freeRenderingGroups","meshIndex","includedOnlyMeshes","excludedMeshes","generators","getShadowGenerators","iterator","key","next","done","shadowMap","getShadowMap","renderList","engine","isOcclusionQueryInProgress","deleteQuery","wipeCaches","removeMesh","_parentContainer","particleSystems","emitter","disableFacetData","onAfterWorldMatrixUpdateObservable","clear","addChild","preserveScalingSign","setParent","removeChild","_initFacetData","facetNormals","facetPositions","facetPartitioning","updateFacetData","bInfo","Uint16Array","depthSortedIndices","needs32bits","facetDepthSortFunction","f1","f2","sqDistance","depthSortedFacets","depthSortedFacet","facetDepthSortOrigin","bbSizeMax","getFacetLocalNormals","getFacetLocalPositions","getFacetLocalPartitioning","depthSort","distanceTo","sind","updateIndices","facetData","getFacetPosition","getFacetPositionToRef","localPos","getFacetNormal","getFacetNormalToRef","localNorm","getFacetsAtLocalCoordinates","ox","oy","oz","getClosestFacetAtCoordinates","projected","checkFace","facing","invMat","invVect","closest","getClosestFacetAtLocalCoordinates","tmpx","tmpy","tmpz","t0","projx","projy","projz","facetsInBlock","fib","shortest","tmpDistance","gpuMemoryOnly","createNormals","useRightHandedSystem","alignWithNormal","upDirection","axisX","axisZ","_checkOcclusionQuery","disableEdgesRendering","enableEdgesRendering","checkVerticesInsteadOfIndices","getConnectedParticleSystems","particleSystem","OCCLUSION_TYPE_NONE","OCCLUSION_TYPE_OPTIMISTIC","OCCLUSION_TYPE_STRICT","OCCLUSION_ALGORITHM_TYPE_ACCURATE","OCCLUSION_ALGORITHM_TYPE_CONSERVATIVE","CULLINGSTRATEGY_STANDARD","CULLINGSTRATEGY_OPTIMISTIC_INCLUSION","CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY"],"sourceRoot":""}