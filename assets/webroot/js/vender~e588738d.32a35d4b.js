"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[906],{28674:(t,e,s)=>{s.d(e,{Bn:()=>o,zz:()=>c});var i=s(58095),r=s(72739),n=s(48154),a=s(89223);class o{constructor(){this.cartesian=[],this.vertices=[],this.max=[],this.min=[],this.closestTo=[],this.innerFacets=[],this.isoVecsABOB=[],this.isoVecsOBOA=[],this.isoVecsBAOA=[],this.vertexTypes=[],this.IDATA=new h("icosahedron","Regular",[[0,n.Q_,-1],[-n.Q_,1,0],[-1,0,-n.Q_],[1,0,-n.Q_],[n.Q_,1,0],[0,n.Q_,1],[-1,0,n.Q_],[-n.Q_,-1,0],[0,-n.Q_,-1],[n.Q_,-1,0],[1,0,n.Q_],[0,-n.Q_,1]],[[0,2,1],[0,3,2],[0,4,3],[0,5,4],[0,1,5],[7,6,1],[8,7,2],[9,8,3],[10,9,4],[6,10,5],[2,7,1],[3,8,2],[4,9,3],[5,10,4],[1,6,5],[11,6,7],[11,7,8],[11,8,9],[11,9,10],[11,10,6]])}setIndices(){let t=12;const e={},s=this.m,i=this.n;let n,o,h,c,l,d=s,u=1,f=0;0!==i&&(d=r.R.HCF(s,i)),u=s/d,f=i/d;const g=a.a.Zero(),_=new a.a(s,i),p=new a.a(-i,s+i),m=a.a.Zero(),x=a.a.Zero(),I=a.a.Zero();let y,M,v,D,b=[];const B=[],A=this.vertByDist,S=(s,i,r,n)=>{y=s+"|"+r,M=i+"|"+n,y in e||M in e?y in e&&!(M in e)?e[M]=e[y]:M in e&&!(y in e)&&(e[y]=e[M]):(e[y]=t,e[M]=t,t++),A[r][0]>2?B[e[y]]=[-A[r][0],A[r][1],e[y]]:B[e[y]]=[b[A[r][0]],A[r][1],e[y]]};this.IDATA.edgematch=[[1,"B"],[2,"B"],[3,"B"],[4,"B"],[0,"B"],[10,"O",14,"A"],[11,"O",10,"A"],[12,"O",11,"A"],[13,"O",12,"A"],[14,"O",13,"A"],[0,"O"],[1,"O"],[2,"O"],[3,"O"],[4,"O"],[19,"B",5,"A"],[15,"B",6,"A"],[16,"B",7,"A"],[17,"B",8,"A"],[18,"B",9,"A"]];for(let r=0;r<20;r++){if(b=this.IDATA.face[r],h=b[2],c=b[1],l=b[0],v=g.x+"|"+g.y,y=r+"|"+v,y in e||(e[y]=h,B[h]=[b[A[v][0]],A[v][1]]),v=_.x+"|"+_.y,y=r+"|"+v,y in e||(e[y]=c,B[c]=[b[A[v][0]],A[v][1]]),v=p.x+"|"+p.y,y=r+"|"+v,y in e||(e[y]=l,B[l]=[b[A[v][0]],A[v][1]]),n=this.IDATA.edgematch[r][0],o=this.IDATA.edgematch[r][1],"B"===o)for(let t=1;t<d;t++)x.x=s-t*(u+f),x.y=i+t*u,I.x=-t*f,I.y=t*(u+f),v=x.x+"|"+x.y,D=I.x+"|"+I.y,S(r,n,v,D);if("O"===o)for(let t=1;t<d;t++)I.x=-t*f,I.y=t*(u+f),m.x=t*u,m.y=t*f,v=I.x+"|"+I.y,D=m.x+"|"+m.y,S(r,n,v,D);if(n=this.IDATA.edgematch[r][2],o=this.IDATA.edgematch[r][3],o&&"A"===o)for(let t=1;t<d;t++)m.x=t*u,m.y=t*f,x.x=s-(d-t)*(u+f),x.y=i+(d-t)*u,v=m.x+"|"+m.y,D=x.x+"|"+x.y,S(r,n,v,D);for(let s=0;s<this.vertices.length;s++)v=this.vertices[s].x+"|"+this.vertices[s].y,y=r+"|"+v,y in e||(e[y]=t++,A[v][0]>2?B[e[y]]=[-A[v][0],A[v][1],e[y]]:B[e[y]]=[b[A[v][0]],A[v][1],e[y]])}this.closestTo=B,this.vecToidx=e}calcCoeffs(){const t=this.m,e=this.n,s=Math.sqrt(3)/3,i=t*t+e*e+t*e;this.coau=(t+e)/i,this.cobu=-e/i,this.coav=-s*(t-e)/i,this.cobv=s*(2*t+e)/i}createInnerFacets(){const t=this.m,e=this.n;for(let s=0;s<e+t+1;s++)for(let t=this.min[s];t<this.max[s]+1;t++)t<this.max[s]&&t<this.max[s+1]+1&&this.innerFacets.push(["|"+t+"|"+s,"|"+t+"|"+(s+1),"|"+(t+1)+"|"+s]),s>0&&t<this.max[s-1]&&t+1<this.max[s]+1&&this.innerFacets.push(["|"+t+"|"+s,"|"+(t+1)+"|"+s,"|"+(t+1)+"|"+(s-1)])}edgeVecsABOB(){const t=this.m,e=this.n,s=new a.a(-e,t+e);for(let i=1;i<t+e;i++){const t=new a.a(this.min[i],i),e=new a.a(this.min[i-1],i-1),r=new a.a(this.min[i+1],i+1),n=t.clone(),o=e.clone(),h=r.clone();n.rotate60About(s),o.rotate60About(s),h.rotate60About(s);const c=new a.a(this.max[n.y],n.y),l=new a.a(this.max[n.y-1],n.y-1),d=new a.a(this.max[n.y-1]-1,n.y-1);n.x===c.x&&n.y===c.y||(n.x!==l.x?(this.vertexTypes.push([1,0,0]),this.isoVecsABOB.push([t,l,d]),this.vertexTypes.push([1,0,0]),this.isoVecsABOB.push([t,d,c])):n.y===h.y?(this.vertexTypes.push([1,1,0]),this.isoVecsABOB.push([t,e,l]),this.vertexTypes.push([1,0,1]),this.isoVecsABOB.push([t,l,r])):(this.vertexTypes.push([1,1,0]),this.isoVecsABOB.push([t,e,l]),this.vertexTypes.push([1,0,0]),this.isoVecsABOB.push([t,l,c])))}}mapABOBtoOBOA(){const t=new a.a(0,0);for(let e=0;e<this.isoVecsABOB.length;e++){const s=[];for(let i=0;i<3;i++)t.x=this.isoVecsABOB[e][i].x,t.y=this.isoVecsABOB[e][i].y,0===this.vertexTypes[e][i]&&t.rotateNeg120(this.m,this.n),s.push(t.clone());this.isoVecsOBOA.push(s)}}mapABOBtoBAOA(){const t=new a.a(0,0);for(let e=0;e<this.isoVecsABOB.length;e++){const s=[];for(let i=0;i<3;i++)t.x=this.isoVecsABOB[e][i].x,t.y=this.isoVecsABOB[e][i].y,1===this.vertexTypes[e][i]&&t.rotate120(this.m,this.n),s.push(t.clone());this.isoVecsBAOA.push(s)}}MapToFace(t,e){const s=this.IDATA.face[t],r=s[2],n=s[1],a=s[0],o=i.P.FromArray(this.IDATA.vertex[r]),h=i.P.FromArray(this.IDATA.vertex[n]),c=i.P.FromArray(this.IDATA.vertex[a]),l=h.subtract(o),d=c.subtract(o),u=l.scale(this.coau).add(d.scale(this.cobu)),f=l.scale(this.coav).add(d.scale(this.cobv)),g=[];let _,p=i.jp.Vector3[0];for(let s=0;s<this.cartesian.length;s++)p=u.scale(this.cartesian[s].x).add(f.scale(this.cartesian[s].y)).add(o),g[s]=[p.x,p.y,p.z],_=t+"|"+this.vertices[s].x+"|"+this.vertices[s].y,e.vertex[this.vecToidx[_]]=[p.x,p.y,p.z]}build(t,e){const s=new Array,i=a.a.Zero(),n=new a.a(t,e),o=new a.a(-e,t+e);s.push(i,n,o);for(let i=e;i<t+1;i++)for(let e=0;e<t+1-i;e++)s.push(new a.a(e,i));if(e>0){const i=r.R.HCF(t,e),n=t/i,o=e/i;for(let r=1;r<i;r++)s.push(new a.a(r*n,r*o)),s.push(new a.a(-r*o,r*(n+o))),s.push(new a.a(t-r*(n+o),e+r*n));const h=t/e;for(let i=1;i<e;i++)for(let r=0;r<i*h;r++)s.push(new a.a(r,i)),s.push(new a.a(r,i).rotate120(t,e)),s.push(new a.a(r,i).rotateNeg120(t,e))}s.sort(((t,e)=>t.x-e.x)),s.sort(((t,e)=>t.y-e.y));const h=new Array(t+e+1),c=new Array(t+e+1);for(let t=0;t<h.length;t++)h[t]=1/0,c[t]=-1/0;let l=0,d=0;const u=s.length;for(let t=0;t<u;t++)d=s[t].x,l=s[t].y,h[l]=Math.min(d,h[l]),c[l]=Math.max(d,c[l]);const f=(s,i)=>{const r=s.clone();return"A"===i&&r.rotateNeg120(t,e),"B"===i&&r.rotate120(t,e),r.x<0?r.y:r.x+r.y},g=[],_=[],p=[],m=[],x={},I=[];let y=-1,M=-1;for(let t=0;t<u;t++)g[t]=s[t].toCartesianOrigin(new a.a(0,0),.5),_[t]=f(s[t],"O"),p[t]=f(s[t],"A"),m[t]=f(s[t],"B"),_[t]===p[t]&&p[t]===m[t]?(y=3,M=_[t]):_[t]===p[t]?(y=4,M=_[t]):p[t]===m[t]?(y=5,M=p[t]):m[t]===_[t]&&(y=6,M=_[t]),_[t]<p[t]&&_[t]<m[t]&&(y=2,M=_[t]),p[t]<_[t]&&p[t]<m[t]&&(y=1,M=p[t]),m[t]<p[t]&&m[t]<_[t]&&(y=0,M=m[t]),I.push([y,M,s[t].x,s[t].y]);I.sort(((t,e)=>t[2]-e[2])),I.sort(((t,e)=>t[3]-e[3])),I.sort(((t,e)=>t[1]-e[1])),I.sort(((t,e)=>t[0]-e[0]));for(let t=0;t<I.length;t++)x[I[t][2]+"|"+I[t][3]]=[I[t][0],I[t][1],t];return this.m=t,this.n=e,this.vertices=s,this.vertByDist=x,this.cartesian=g,this.min=h,this.max=c,this}}class h{constructor(t,e,s,i){this.name=t,this.category=e,this.vertex=s,this.face=i}}class c extends h{innerToData(t,e){for(let s=0;s<e.innerFacets.length;s++)this.face.push(e.innerFacets[s].map((s=>e.vecToidx[t+s])))}mapABOBtoDATA(t,e){const s=e.IDATA.edgematch[t][0];for(let i=0;i<e.isoVecsABOB.length;i++){const r=[];for(let n=0;n<3;n++)0===e.vertexTypes[i][n]?r.push(t+"|"+e.isoVecsABOB[i][n].x+"|"+e.isoVecsABOB[i][n].y):r.push(s+"|"+e.isoVecsABOB[i][n].x+"|"+e.isoVecsABOB[i][n].y);this.face.push([e.vecToidx[r[0]],e.vecToidx[r[1]],e.vecToidx[r[2]]])}}mapOBOAtoDATA(t,e){const s=e.IDATA.edgematch[t][0];for(let i=0;i<e.isoVecsOBOA.length;i++){const r=[];for(let n=0;n<3;n++)1===e.vertexTypes[i][n]?r.push(t+"|"+e.isoVecsOBOA[i][n].x+"|"+e.isoVecsOBOA[i][n].y):r.push(s+"|"+e.isoVecsOBOA[i][n].x+"|"+e.isoVecsOBOA[i][n].y);this.face.push([e.vecToidx[r[0]],e.vecToidx[r[1]],e.vecToidx[r[2]]])}}mapBAOAtoDATA(t,e){const s=e.IDATA.edgematch[t][2];for(let i=0;i<e.isoVecsBAOA.length;i++){const r=[];for(let n=0;n<3;n++)1===e.vertexTypes[i][n]?r.push(t+"|"+e.isoVecsBAOA[i][n].x+"|"+e.isoVecsBAOA[i][n].y):r.push(s+"|"+e.isoVecsBAOA[i][n].x+"|"+e.isoVecsBAOA[i][n].y);this.face.push([e.vecToidx[r[0]],e.vecToidx[r[1]],e.vecToidx[r[2]]])}}orderData(t){const e=[];for(let t=0;t<13;t++)e[t]=[];const s=t.closestTo;for(let t=0;t<s.length;t++)s[t][0]>-1?s[t][1]>0&&e[s[t][0]].push([t,s[t][1]]):e[12].push([t,s[t][0]]);const i=[];for(let t=0;t<12;t++)i[t]=t;let r=12;for(let t=0;t<12;t++){e[t].sort(((t,e)=>t[1]-e[1]));for(let s=0;s<e[t].length;s++)i[e[t][s][0]]=r++}for(let t=0;t<e[12].length;t++)i[e[12][t][0]]=r++;for(let t=0;t<this.vertex.length;t++)this.vertex[t].push(i[t]);this.vertex.sort(((t,e)=>t[3]-e[3]));for(let t=0;t<this.vertex.length;t++)this.vertex[t].pop();for(let t=0;t<this.face.length;t++)for(let e=0;e<this.face[t].length;e++)this.face[t][e]=i[this.face[t][e]];this.sharedNodes=e[12].length,this.poleNodes=this.vertex.length-this.sharedNodes}setOrder(t,e){const s=[],i=[];let r=e.pop();i.push(r);let n=this.face[r].indexOf(t);n=(n+2)%3;let a=this.face[r][n];s.push(a);let o=0;for(;e.length>0;)r=e[o],this.face[r].indexOf(a)>-1?(n=(this.face[r].indexOf(a)+1)%3,a=this.face[r][n],s.push(a),i.push(r),e.splice(o,1),o=0):o++;return this.adjacentFaces.push(s),i}toGoldbergPolyhedronData(){const t=new h("GeoDual","Goldberg",[],[]);t.name="GD dual";const e=this.vertex.length,s=new Array(e);for(let t=0;t<e;t++)s[t]=[];for(let t=0;t<this.face.length;t++)for(let e=0;e<3;e++)s[this.face[t][e]].push(t);let i=0,r=0,n=0,a=[],o=[];this.adjacentFaces=[];for(let e=0;e<s.length;e++)t.face[e]=this.setOrder(e,s[e].concat([])),s[e].forEach((e=>{i=0,r=0,n=0,a=this.face[e];for(let t=0;t<3;t++)o=this.vertex[a[t]],i+=o[0],r+=o[1],n+=o[2];t.vertex[e]=[i/3,r/3,n/3]}));return t}static BuildGeodesicData(t){const e=new c("Geodesic-m-n","Geodesic",[[0,n.Q_,-1],[-n.Q_,1,0],[-1,0,-n.Q_],[1,0,-n.Q_],[n.Q_,1,0],[0,n.Q_,1],[-1,0,n.Q_],[-n.Q_,-1,0],[0,-n.Q_,-1],[n.Q_,-1,0],[1,0,n.Q_],[0,-n.Q_,1]],[]);t.setIndices(),t.calcCoeffs(),t.createInnerFacets(),t.edgeVecsABOB(),t.mapABOBtoOBOA(),t.mapABOBtoBAOA();for(let s=0;s<t.IDATA.face.length;s++)t.MapToFace(s,e),e.innerToData(s,t),"B"===t.IDATA.edgematch[s][1]&&e.mapABOBtoDATA(s,t),"O"===t.IDATA.edgematch[s][1]&&e.mapOBOAtoDATA(s,t),"A"===t.IDATA.edgematch[s][3]&&e.mapBAOAtoDATA(s,t);e.orderData(t);return e.vertex=e.vertex.map((function(t){const e=t[0],s=t[1],i=t[2],r=Math.sqrt(e*e+s*s+i*i);return t[0]*=1/r,t[1]*=1/r,t[2]*=1/r,t})),e}}},63946:(t,e,s)=>{s.d(e,{Z:()=>_});var i=s(58095),r=s(15631),n=s(89209),a=s(72208),o=s(68345),h=s(43824),c=s(91859),l=s(13514),d=s(20163),u=s(93701),f=s(15210),g=s(47884);class _{get boundingBias(){return this._boundingBias}set boundingBias(t){this._boundingBias?this._boundingBias.copyFrom(t):this._boundingBias=t.clone(),this._updateBoundingInfo(!0,null)}static CreateGeometryForMesh(t){const e=new _(_.RandomId(),t.getScene());return e.applyToMesh(t),e}get meshes(){return this._meshes}constructor(t,e,s,i=!1,r=null){this.delayLoadState=0,this._totalVertices=0,this._isDisposed=!1,this._indexBufferIsUpdatable=!1,this._positionsCache=[],this._parentContainer=null,this.useBoundingInfoFromGeometry=!1,this._scene=e||f.l.LastCreatedScene,this._scene&&(this.id=t,this.uniqueId=this._scene.getUniqueId(),this._engine=this._scene.getEngine(),this._meshes=[],this._vertexBuffers={},this._indices=[],this._updatable=i,s?this.setAllVerticesData(s,i):this._totalVertices=0,this._engine.getCaps().vertexArrayObject&&(this._vertexArrayObjects={}),r&&(this.applyToMesh(r),r.computeWorldMatrix(!0)))}get extend(){return this._extend}getScene(){return this._scene}getEngine(){return this._engine}isReady(){return 1===this.delayLoadState||0===this.delayLoadState}get doNotSerialize(){for(let t=0;t<this._meshes.length;t++)if(!this._meshes[t].doNotSerialize)return!1;return!0}_rebuild(){this._vertexArrayObjects&&(this._vertexArrayObjects={}),0!==this._meshes.length&&this._indices&&(this._indexBuffer=this._engine.createIndexBuffer(this._indices,this._updatable));for(const t in this._vertexBuffers){this._vertexBuffers[t]._rebuild()}}setAllVerticesData(t,e){t.applyToGeometry(this,e),this._notifyUpdate()}setVerticesData(t,e,s=!1,i){s&&Array.isArray(e)&&(e=new Float32Array(e));const r=new a.o(this._engine,e,t,s,0===this._meshes.length,i);this.setVerticesBuffer(r)}removeVerticesData(t){this._vertexBuffers[t]&&(this._vertexBuffers[t].dispose(),delete this._vertexBuffers[t]),this._vertexArrayObjects&&this._disposeVertexArrayObjects()}setVerticesBuffer(t,e=null,s=!0){const i=t.getKind();this._vertexBuffers[i]&&s&&this._vertexBuffers[i].dispose(),t._buffer&&t._buffer._increaseReferences(),this._vertexBuffers[i]=t;const r=this._meshes,n=r.length;if(i===a.o.PositionKind){const s=t.getData();null!=e?this._totalVertices=e:null!=s&&(this._totalVertices=s.length/(t.type===a.o.BYTE?t.byteStride:t.byteStride/4)),this._updateExtend(s),this._resetPointsArrayCache();for(let t=0;t<n;t++){const e=r[t];e.buildBoundingInfo(this._extend.minimum,this._extend.maximum),e._createGlobalSubMesh(e.isUnIndexed),e.computeWorldMatrix(!0),e.synchronizeInstances()}}this._notifyUpdate(i)}updateVerticesDataDirectly(t,e,s,i=!1){const r=this.getVertexBuffer(t);r&&(r.updateDirectly(e,s,i),this._notifyUpdate(t))}updateVerticesData(t,e,s=!1){const i=this.getVertexBuffer(t);i&&(i.update(e),t===a.o.PositionKind&&this._updateBoundingInfo(s,e),this._notifyUpdate(t))}_updateBoundingInfo(t,e){if(t&&this._updateExtend(e),this._resetPointsArrayCache(),t){const t=this._meshes;for(const e of t){e.hasBoundingInfo?e.getBoundingInfo().reConstruct(this._extend.minimum,this._extend.maximum):e.buildBoundingInfo(this._extend.minimum,this._extend.maximum);const t=e.subMeshes;for(const e of t)e.refreshBoundingInfo()}}}_bind(t,e,s,i){if(!t)return;void 0===e&&(e=this._indexBuffer);const r=this.getVertexBuffers();if(!r)return;if(e!=this._indexBuffer||!this._vertexArrayObjects&&!i)return void this._engine.bindBuffers(r,e,t,s);const n=i||this._vertexArrayObjects;n[t.key]||(n[t.key]=this._engine.recordVertexArrayObject(r,e,t,s)),this._engine.bindVertexArrayObject(n[t.key],e)}getTotalVertices(){return this.isReady()?this._totalVertices:0}getVerticesData(t,e,s){const i=this.getVertexBuffer(t);return i?i.getFloatData(this._totalVertices,s||e&&1!==this._meshes.length):null}isVertexBufferUpdatable(t){const e=this._vertexBuffers[t];return!!e&&e.isUpdatable()}getVertexBuffer(t){return this.isReady()?this._vertexBuffers[t]:null}getVertexBuffers(){return this.isReady()?this._vertexBuffers:null}isVerticesDataPresent(t){return this._vertexBuffers?void 0!==this._vertexBuffers[t]:!!this._delayInfo&&-1!==this._delayInfo.indexOf(t)}getVerticesDataKinds(){const t=[];let e;if(!this._vertexBuffers&&this._delayInfo)for(e in this._delayInfo)t.push(e);else for(e in this._vertexBuffers)t.push(e);return t}updateIndices(t,e,s=!1){if(this._indexBuffer)if(this._indexBufferIsUpdatable){const i=t.length!==this._indices.length;if(s||(this._indices=t.slice()),this._engine.updateDynamicIndexBuffer(this._indexBuffer,t,e),i)for(const t of this._meshes)t._createGlobalSubMesh(!0)}else this.setIndices(t,null,!0)}setIndices(t,e=null,s=!1){this._indexBuffer&&this._engine._releaseBuffer(this._indexBuffer),this._indices=t,this._indexBufferIsUpdatable=s,0!==this._meshes.length&&this._indices&&(this._indexBuffer=this._engine.createIndexBuffer(this._indices,s)),null!=e&&(this._totalVertices=e);for(const t of this._meshes)t._createGlobalSubMesh(!0),t.synchronizeInstances();this._notifyUpdate()}getTotalIndices(){return this.isReady()?this._indices.length:0}getIndices(t,e){if(!this.isReady())return null;const s=this._indices;return e||t&&1!==this._meshes.length?s.slice():s}getIndexBuffer(){return this.isReady()?this._indexBuffer:null}_releaseVertexArrayObject(t=null){t&&this._vertexArrayObjects&&this._vertexArrayObjects[t.key]&&(this._engine.releaseVertexArrayObject(this._vertexArrayObjects[t.key]),delete this._vertexArrayObjects[t.key])}releaseForMesh(t,e){const s=this._meshes,i=s.indexOf(t);-1!==i&&(s.splice(i,1),this._vertexArrayObjects&&t._invalidateInstanceVertexArrayObject(),t._geometry=null,0===s.length&&e&&this.dispose())}applyToMesh(t){if(t._geometry===this)return;const e=t._geometry;e&&e.releaseForMesh(t),this._vertexArrayObjects&&t._invalidateInstanceVertexArrayObject();const s=this._meshes;t._geometry=this,t._internalAbstractMeshDataInfo._positions=null,this._scene.pushGeometry(this),s.push(t),this.isReady()?this._applyToMesh(t):this._boundingInfo&&t.setBoundingInfo(this._boundingInfo)}_updateExtend(t=null){if(this.useBoundingInfoFromGeometry&&this._boundingInfo)this._extend={minimum:this._boundingInfo.minimum.clone(),maximum:this._boundingInfo.maximum.clone()};else{if(!t&&!(t=this.getVerticesData(a.o.PositionKind)))return;this._extend=(0,u.k)(t,0,this._totalVertices,this.boundingBias,3)}}_applyToMesh(t){const e=this._meshes.length;for(const s in this._vertexBuffers)1===e&&this._vertexBuffers[s].create(),s===a.o.PositionKind&&(this._extend||this._updateExtend(),t.buildBoundingInfo(this._extend.minimum,this._extend.maximum),t._createGlobalSubMesh(t.isUnIndexed),t._updateBoundingInfo());1===e&&this._indices&&this._indices.length>0&&(this._indexBuffer=this._engine.createIndexBuffer(this._indices,this._updatable)),t._syncGeometryWithMorphTargetManager(),t.synchronizeInstances()}_notifyUpdate(t){this.onGeometryUpdated&&this.onGeometryUpdated(this,t),this._vertexArrayObjects&&this._disposeVertexArrayObjects();for(const t of this._meshes)t._markSubMeshesAsAttributesDirty()}load(t,e){2!==this.delayLoadState&&(this.isReady()?e&&e():(this.delayLoadState=2,this._queueLoad(t,e)))}_queueLoad(t,e){this.delayLoadingFile&&(t.addPendingData(this),t._loadFile(this.delayLoadingFile,(s=>{if(!this._delayLoadingFunction)return;this._delayLoadingFunction(JSON.parse(s),this),this.delayLoadState=1,this._delayInfo=[],t.removePendingData(this);const i=this._meshes,r=i.length;for(let t=0;t<r;t++)this._applyToMesh(i[t]);e&&e()}),void 0,!0))}toLeftHanded(){const t=this.getIndices(!1);if(null!=t&&t.length>0){for(let e=0;e<t.length;e+=3){const s=t[e+0];t[e+0]=t[e+2],t[e+2]=s}this.setIndices(t)}const e=this.getVerticesData(a.o.PositionKind,!1);if(null!=e&&e.length>0){for(let t=0;t<e.length;t+=3)e[t+2]=-e[t+2];this.setVerticesData(a.o.PositionKind,e,!1)}const s=this.getVerticesData(a.o.NormalKind,!1);if(null!=s&&s.length>0){for(let t=0;t<s.length;t+=3)s[t+2]=-s[t+2];this.setVerticesData(a.o.NormalKind,s,!1)}}_resetPointsArrayCache(){this._positions=null}_generatePointsArray(){if(this._positions)return!0;const t=this.getVerticesData(a.o.PositionKind);if(!t||0===t.length)return!1;for(let e=3*this._positionsCache.length,s=this._positionsCache.length;e<t.length;e+=3,++s)this._positionsCache[s]=i.P.FromArray(t,e);for(let e=0,s=0;e<t.length;e+=3,++s)this._positionsCache[s].set(t[0+e],t[1+e],t[2+e]);return this._positionsCache.length=t.length/3,this._positions=this._positionsCache,!0}isDisposed(){return this._isDisposed}_disposeVertexArrayObjects(){if(this._vertexArrayObjects){for(const t in this._vertexArrayObjects)this._engine.releaseVertexArrayObject(this._vertexArrayObjects[t]);this._vertexArrayObjects={};const t=this._meshes,e=t.length;for(let s=0;s<e;s++)t[s]._invalidateInstanceVertexArrayObject()}}dispose(){const t=this._meshes,e=t.length;let s;for(s=0;s<e;s++)this.releaseForMesh(t[s]);this._meshes.length=0,this._disposeVertexArrayObjects();for(const t in this._vertexBuffers)this._vertexBuffers[t].dispose();if(this._vertexBuffers={},this._totalVertices=0,this._indexBuffer&&this._engine._releaseBuffer(this._indexBuffer),this._indexBuffer=null,this._indices=[],this.delayLoadState=0,this.delayLoadingFile=null,this._delayLoadingFunction=null,this._delayInfo=[],this._boundingInfo=null,this._scene.removeGeometry(this),this._parentContainer){const t=this._parentContainer.geometries.indexOf(this);t>-1&&this._parentContainer.geometries.splice(t,1),this._parentContainer=null}this._isDisposed=!0}copy(t){const e=new n.x;e.indices=[];const s=this.getIndices();if(s)for(let t=0;t<s.length;t++)e.indices.push(s[t]);let i,r=!1,a=!1;for(i in this._vertexBuffers){const t=this.getVerticesData(i);if(t&&(t instanceof Float32Array?e.set(new Float32Array(t),i):e.set(t.slice(0),i),!a)){const t=this.getVertexBuffer(i);t&&(r=t.isUpdatable(),a=!r)}}const o=new _(t,this._scene,e,r);for(i in o.delayLoadState=this.delayLoadState,o.delayLoadingFile=this.delayLoadingFile,o._delayLoadingFunction=this._delayLoadingFunction,this._delayInfo)o._delayInfo=o._delayInfo||[],o._delayInfo.push(i);return o._boundingInfo=new c.j(this._extend.minimum,this._extend.maximum),o}serialize(){const t={};return t.id=this.id,t.uniqueId=this.uniqueId,t.updatable=this._updatable,d.$&&d.$.HasTags(this)&&(t.tags=d.$.GetTags(this)),t}_toNumberArray(t){return Array.isArray(t)?t:Array.prototype.slice.call(t)}clearCachedData(){this._indices=[],this._resetPointsArrayCache();for(const t in this._vertexBuffers)Object.prototype.hasOwnProperty.call(this._vertexBuffers,t)&&(this._vertexBuffers[t]._buffer._data=null)}serializeVerticeData(){const t=this.serialize();return this.isVerticesDataPresent(a.o.PositionKind)&&(t.positions=this._toNumberArray(this.getVerticesData(a.o.PositionKind)),this.isVertexBufferUpdatable(a.o.PositionKind)&&(t.positions._updatable=!0)),this.isVerticesDataPresent(a.o.NormalKind)&&(t.normals=this._toNumberArray(this.getVerticesData(a.o.NormalKind)),this.isVertexBufferUpdatable(a.o.NormalKind)&&(t.normals._updatable=!0)),this.isVerticesDataPresent(a.o.TangentKind)&&(t.tangents=this._toNumberArray(this.getVerticesData(a.o.TangentKind)),this.isVertexBufferUpdatable(a.o.TangentKind)&&(t.tangents._updatable=!0)),this.isVerticesDataPresent(a.o.UVKind)&&(t.uvs=this._toNumberArray(this.getVerticesData(a.o.UVKind)),this.isVertexBufferUpdatable(a.o.UVKind)&&(t.uvs._updatable=!0)),this.isVerticesDataPresent(a.o.UV2Kind)&&(t.uv2s=this._toNumberArray(this.getVerticesData(a.o.UV2Kind)),this.isVertexBufferUpdatable(a.o.UV2Kind)&&(t.uv2s._updatable=!0)),this.isVerticesDataPresent(a.o.UV3Kind)&&(t.uv3s=this._toNumberArray(this.getVerticesData(a.o.UV3Kind)),this.isVertexBufferUpdatable(a.o.UV3Kind)&&(t.uv3s._updatable=!0)),this.isVerticesDataPresent(a.o.UV4Kind)&&(t.uv4s=this._toNumberArray(this.getVerticesData(a.o.UV4Kind)),this.isVertexBufferUpdatable(a.o.UV4Kind)&&(t.uv4s._updatable=!0)),this.isVerticesDataPresent(a.o.UV5Kind)&&(t.uv5s=this._toNumberArray(this.getVerticesData(a.o.UV5Kind)),this.isVertexBufferUpdatable(a.o.UV5Kind)&&(t.uv5s._updatable=!0)),this.isVerticesDataPresent(a.o.UV6Kind)&&(t.uv6s=this._toNumberArray(this.getVerticesData(a.o.UV6Kind)),this.isVertexBufferUpdatable(a.o.UV6Kind)&&(t.uv6s._updatable=!0)),this.isVerticesDataPresent(a.o.ColorKind)&&(t.colors=this._toNumberArray(this.getVerticesData(a.o.ColorKind)),this.isVertexBufferUpdatable(a.o.ColorKind)&&(t.colors._updatable=!0)),this.isVerticesDataPresent(a.o.MatricesIndicesKind)&&(t.matricesIndices=this._toNumberArray(this.getVerticesData(a.o.MatricesIndicesKind)),t.matricesIndices._isExpanded=!0,this.isVertexBufferUpdatable(a.o.MatricesIndicesKind)&&(t.matricesIndices._updatable=!0)),this.isVerticesDataPresent(a.o.MatricesWeightsKind)&&(t.matricesWeights=this._toNumberArray(this.getVerticesData(a.o.MatricesWeightsKind)),this.isVertexBufferUpdatable(a.o.MatricesWeightsKind)&&(t.matricesWeights._updatable=!0)),t.indices=this._toNumberArray(this.getIndices()),t}static ExtractFromMesh(t,e){const s=t._geometry;return s?s.copy(e):null}static RandomId(){return l.w1.RandomId()}static _GetGeometryByLoadedUniqueId(t,e){for(let s=0;s<e.geometries.length;s++)if(e.geometries[s]._loadedUniqueId===t)return e.geometries[s];return null}static _ImportGeometry(t,e){const s=e.getScene(),i=t.geometryUniqueId,n=t.geometryId;if(i||n){const t=i?this._GetGeometryByLoadedUniqueId(i,s):s.getGeometryById(n);t&&t.applyToMesh(e)}else if(t instanceof ArrayBuffer){const s=e._binaryInfo;if(s.positionsAttrDesc&&s.positionsAttrDesc.count>0){const i=new Float32Array(t,s.positionsAttrDesc.offset,s.positionsAttrDesc.count);e.setVerticesData(a.o.PositionKind,i,!1)}if(s.normalsAttrDesc&&s.normalsAttrDesc.count>0){const i=new Float32Array(t,s.normalsAttrDesc.offset,s.normalsAttrDesc.count);e.setVerticesData(a.o.NormalKind,i,!1)}if(s.tangetsAttrDesc&&s.tangetsAttrDesc.count>0){const i=new Float32Array(t,s.tangetsAttrDesc.offset,s.tangetsAttrDesc.count);e.setVerticesData(a.o.TangentKind,i,!1)}if(s.uvsAttrDesc&&s.uvsAttrDesc.count>0){const i=new Float32Array(t,s.uvsAttrDesc.offset,s.uvsAttrDesc.count);if(g.e.UseOpenGLOrientationForUV)for(let t=1;t<i.length;t+=2)i[t]=1-i[t];e.setVerticesData(a.o.UVKind,i,!1)}if(s.uvs2AttrDesc&&s.uvs2AttrDesc.count>0){const i=new Float32Array(t,s.uvs2AttrDesc.offset,s.uvs2AttrDesc.count);if(g.e.UseOpenGLOrientationForUV)for(let t=1;t<i.length;t+=2)i[t]=1-i[t];e.setVerticesData(a.o.UV2Kind,i,!1)}if(s.uvs3AttrDesc&&s.uvs3AttrDesc.count>0){const i=new Float32Array(t,s.uvs3AttrDesc.offset,s.uvs3AttrDesc.count);if(g.e.UseOpenGLOrientationForUV)for(let t=1;t<i.length;t+=2)i[t]=1-i[t];e.setVerticesData(a.o.UV3Kind,i,!1)}if(s.uvs4AttrDesc&&s.uvs4AttrDesc.count>0){const i=new Float32Array(t,s.uvs4AttrDesc.offset,s.uvs4AttrDesc.count);if(g.e.UseOpenGLOrientationForUV)for(let t=1;t<i.length;t+=2)i[t]=1-i[t];e.setVerticesData(a.o.UV4Kind,i,!1)}if(s.uvs5AttrDesc&&s.uvs5AttrDesc.count>0){const i=new Float32Array(t,s.uvs5AttrDesc.offset,s.uvs5AttrDesc.count);if(g.e.UseOpenGLOrientationForUV)for(let t=1;t<i.length;t+=2)i[t]=1-i[t];e.setVerticesData(a.o.UV5Kind,i,!1)}if(s.uvs6AttrDesc&&s.uvs6AttrDesc.count>0){const i=new Float32Array(t,s.uvs6AttrDesc.offset,s.uvs6AttrDesc.count);if(g.e.UseOpenGLOrientationForUV)for(let t=1;t<i.length;t+=2)i[t]=1-i[t];e.setVerticesData(a.o.UV6Kind,i,!1)}if(s.colorsAttrDesc&&s.colorsAttrDesc.count>0){const i=new Float32Array(t,s.colorsAttrDesc.offset,s.colorsAttrDesc.count);e.setVerticesData(a.o.ColorKind,i,!1,s.colorsAttrDesc.stride)}if(s.matricesIndicesAttrDesc&&s.matricesIndicesAttrDesc.count>0){const i=new Int32Array(t,s.matricesIndicesAttrDesc.offset,s.matricesIndicesAttrDesc.count),r=[];for(let t=0;t<i.length;t++){const e=i[t];r.push(255&e),r.push((65280&e)>>8),r.push((16711680&e)>>16),r.push(e>>24&255)}e.setVerticesData(a.o.MatricesIndicesKind,r,!1)}if(s.matricesIndicesExtraAttrDesc&&s.matricesIndicesExtraAttrDesc.count>0){const i=new Int32Array(t,s.matricesIndicesExtraAttrDesc.offset,s.matricesIndicesExtraAttrDesc.count),r=[];for(let t=0;t<i.length;t++){const e=i[t];r.push(255&e),r.push((65280&e)>>8),r.push((16711680&e)>>16),r.push(e>>24&255)}e.setVerticesData(a.o.MatricesIndicesExtraKind,r,!1)}if(s.matricesWeightsAttrDesc&&s.matricesWeightsAttrDesc.count>0){const i=new Float32Array(t,s.matricesWeightsAttrDesc.offset,s.matricesWeightsAttrDesc.count);e.setVerticesData(a.o.MatricesWeightsKind,i,!1)}if(s.indicesAttrDesc&&s.indicesAttrDesc.count>0){const i=new Int32Array(t,s.indicesAttrDesc.offset,s.indicesAttrDesc.count);e.setIndices(i,null)}if(s.subMeshesAttrDesc&&s.subMeshesAttrDesc.count>0){const i=new Int32Array(t,s.subMeshesAttrDesc.offset,5*s.subMeshesAttrDesc.count);e.subMeshes=[];for(let t=0;t<s.subMeshesAttrDesc.count;t++){const s=i[5*t+0],r=i[5*t+1],n=i[5*t+2],a=i[5*t+3],h=i[5*t+4];o.P.AddToMesh(s,r,n,a,h,e)}}}else if(t.positions&&t.normals&&t.indices){if(e.setVerticesData(a.o.PositionKind,t.positions,t.positions._updatable),e.setVerticesData(a.o.NormalKind,t.normals,t.normals._updatable),t.tangents&&e.setVerticesData(a.o.TangentKind,t.tangents,t.tangents._updatable),t.uvs&&e.setVerticesData(a.o.UVKind,t.uvs,t.uvs._updatable),t.uvs2&&e.setVerticesData(a.o.UV2Kind,t.uvs2,t.uvs2._updatable),t.uvs3&&e.setVerticesData(a.o.UV3Kind,t.uvs3,t.uvs3._updatable),t.uvs4&&e.setVerticesData(a.o.UV4Kind,t.uvs4,t.uvs4._updatable),t.uvs5&&e.setVerticesData(a.o.UV5Kind,t.uvs5,t.uvs5._updatable),t.uvs6&&e.setVerticesData(a.o.UV6Kind,t.uvs6,t.uvs6._updatable),t.colors&&e.setVerticesData(a.o.ColorKind,r.HE.CheckColors4(t.colors,t.positions.length/3),t.colors._updatable),t.matricesIndices)if(t.matricesIndices._isExpanded)delete t.matricesIndices._isExpanded,e.setVerticesData(a.o.MatricesIndicesKind,t.matricesIndices,t.matricesIndices._updatable);else{const s=[];for(let e=0;e<t.matricesIndices.length;e++){const i=t.matricesIndices[e];s.push(255&i),s.push((65280&i)>>8),s.push((16711680&i)>>16),s.push(i>>24&255)}e.setVerticesData(a.o.MatricesIndicesKind,s,t.matricesIndices._updatable)}if(t.matricesIndicesExtra)if(t.matricesIndicesExtra._isExpanded)delete t.matricesIndices._isExpanded,e.setVerticesData(a.o.MatricesIndicesExtraKind,t.matricesIndicesExtra,t.matricesIndicesExtra._updatable);else{const s=[];for(let e=0;e<t.matricesIndicesExtra.length;e++){const i=t.matricesIndicesExtra[e];s.push(255&i),s.push((65280&i)>>8),s.push((16711680&i)>>16),s.push(i>>24&255)}e.setVerticesData(a.o.MatricesIndicesExtraKind,s,t.matricesIndicesExtra._updatable)}t.matricesWeights&&(_._CleanMatricesWeights(t,e),e.setVerticesData(a.o.MatricesWeightsKind,t.matricesWeights,t.matricesWeights._updatable)),t.matricesWeightsExtra&&e.setVerticesData(a.o.MatricesWeightsExtraKind,t.matricesWeightsExtra,t.matricesWeights._updatable),e.setIndices(t.indices,null)}if(t.subMeshes){e.subMeshes=[];for(let s=0;s<t.subMeshes.length;s++){const i=t.subMeshes[s];o.P.AddToMesh(i.materialIndex,i.verticesStart,i.verticesCount,i.indexStart,i.indexCount,e)}}e._shouldGenerateFlatShading&&(e.convertToFlatShadedMesh(),e._shouldGenerateFlatShading=!1),e.computeWorldMatrix(!0),s.onMeshImportedObservable.notifyObservers(e)}static _CleanMatricesWeights(t,e){const s=.001;if(!h.Z.CleanBoneMatrixWeights)return;let i=0;if(!(t.skeletonId>-1))return;{const s=e.getScene().getLastSkeletonById(t.skeletonId);if(!s)return;i=s.bones.length}const r=e.getVerticesData(a.o.MatricesIndicesKind),n=e.getVerticesData(a.o.MatricesIndicesExtraKind),o=t.matricesWeights,c=t.matricesWeightsExtra,l=t.numBoneInfluencer,d=o.length;for(let t=0;t<d;t+=4){let e=0,a=-1;for(let i=0;i<4;i++){const r=o[t+i];e+=r,r<s&&a<0&&(a=i)}if(c)for(let i=0;i<4;i++){const r=c[t+i];e+=r,r<s&&a<0&&(a=i+4)}if((a<0||a>l-1)&&(a=l-1),e>s){const s=1/e;for(let e=0;e<4;e++)o[t+e]*=s;if(c)for(let e=0;e<4;e++)c[t+e]*=s}else a>=4?(c[t+a-4]=1-e,n[t+a-4]=i):(o[t+a]=1-e,r[t+a]=i)}e.setVerticesData(a.o.MatricesIndicesKind,r),t.matricesWeightsExtra&&e.setVerticesData(a.o.MatricesIndicesExtraKind,n)}static Parse(t,e,s){const r=new _(t.id,e,void 0,t.updatable);return r._loadedUniqueId=t.uniqueId,d.$&&d.$.AddTagsTo(r,t.tags),t.delayLoadingFile?(r.delayLoadState=4,r.delayLoadingFile=s+t.delayLoadingFile,r._boundingInfo=new c.j(i.P.FromArray(t.boundingBoxMinimum),i.P.FromArray(t.boundingBoxMaximum)),r._delayInfo=[],t.hasUVs&&r._delayInfo.push(a.o.UVKind),t.hasUVs2&&r._delayInfo.push(a.o.UV2Kind),t.hasUVs3&&r._delayInfo.push(a.o.UV3Kind),t.hasUVs4&&r._delayInfo.push(a.o.UV4Kind),t.hasUVs5&&r._delayInfo.push(a.o.UV5Kind),t.hasUVs6&&r._delayInfo.push(a.o.UV6Kind),t.hasColors&&r._delayInfo.push(a.o.ColorKind),t.hasMatricesIndices&&r._delayInfo.push(a.o.MatricesIndicesKind),t.hasMatricesWeights&&r._delayInfo.push(a.o.MatricesWeightsKind),r._delayLoadingFunction=n.x.ImportVertexData):n.x.ImportVertexData(t,r),e.pushGeometry(r,!0),r}}},41234:(t,e,s)=>{s.d(e,{R:()=>h});var i=s(58095),r=s(72208),n=s(91243),a=s(15631),o=s(84318);n.Kj._GoldbergMeshParser=(t,e)=>h.Parse(t,e);class h extends n.Kj{constructor(){super(...arguments),this.goldbergData={faceColors:[],faceCenters:[],faceZaxis:[],faceXaxis:[],faceYaxis:[],nbSharedFaces:0,nbUnsharedFaces:0,nbFaces:0,nbFacesAtPole:0,adjacentFaces:[]}}relatedGoldbergFace(t,e){return void 0===e?(t>this.goldbergData.nbUnsharedFaces-1&&(o.Y.Warn("Maximum number of unshared faces used"),t=this.goldbergData.nbUnsharedFaces-1),this.goldbergData.nbUnsharedFaces+t):(t>11&&(o.Y.Warn("Last pole used"),t=11),e>this.goldbergData.nbFacesAtPole-1&&(o.Y.Warn("Maximum number of faces at a pole used"),e=this.goldbergData.nbFacesAtPole-1),12+t*this.goldbergData.nbFacesAtPole+e)}_changeGoldbergFaceColors(t){for(let e=0;e<t.length;e++){const s=t[e][0],i=t[e][1],r=t[e][2];for(let t=s;t<i+1;t++)this.goldbergData.faceColors[t]=r}const e=[];for(let t=0;t<12;t++)for(let s=0;s<5;s++)e.push(this.goldbergData.faceColors[t].r,this.goldbergData.faceColors[t].g,this.goldbergData.faceColors[t].b,this.goldbergData.faceColors[t].a);for(let t=12;t<this.goldbergData.faceColors.length;t++)for(let s=0;s<6;s++)e.push(this.goldbergData.faceColors[t].r,this.goldbergData.faceColors[t].g,this.goldbergData.faceColors[t].b,this.goldbergData.faceColors[t].a);return e}setGoldbergFaceColors(t){const e=this._changeGoldbergFaceColors(t);this.setVerticesData(r.o.ColorKind,e)}updateGoldbergFaceColors(t){const e=this._changeGoldbergFaceColors(t);this.updateVerticesData(r.o.ColorKind,e)}_changeGoldbergFaceUVs(t){const e=this.getVerticesData(r.o.UVKind);for(let s=0;s<t.length;s++){const i=t[s][0],r=t[s][1],n=t[s][2],a=t[s][3],o=t[s][4],h=[],c=[];let l,d;for(let t=0;t<5;t++)l=n.x+a*Math.cos(o+t*Math.PI/2.5),d=n.y+a*Math.sin(o+t*Math.PI/2.5),l<0&&(l=0),l>1&&(l=1),h.push(l,d);for(let t=0;t<6;t++)l=n.x+a*Math.cos(o+t*Math.PI/3),d=n.y+a*Math.sin(o+t*Math.PI/3),l<0&&(l=0),l>1&&(l=1),c.push(l,d);for(let t=i;t<Math.min(12,r+1);t++)for(let s=0;s<5;s++)e[10*t+2*s]=h[2*s],e[10*t+2*s+1]=h[2*s+1];for(let t=Math.max(12,i);t<r+1;t++)for(let s=0;s<6;s++)e[12*t-24+2*s]=c[2*s],e[12*t-23+2*s]=c[2*s+1]}return e}setGoldbergFaceUVs(t){const e=this._changeGoldbergFaceUVs(t);this.setVerticesData(r.o.UVKind,e)}updateGoldbergFaceUVs(t){const e=this._changeGoldbergFaceUVs(t);this.updateVerticesData(r.o.UVKind,e)}placeOnGoldbergFaceAt(t,e,s){const r=i.P.RotationFromAxis(this.goldbergData.faceXaxis[e],this.goldbergData.faceYaxis[e],this.goldbergData.faceZaxis[e]);t.rotation=r,t.position=this.goldbergData.faceCenters[e].add(this.goldbergData.faceXaxis[e].scale(s.x)).add(this.goldbergData.faceYaxis[e].scale(s.y)).add(this.goldbergData.faceZaxis[e].scale(s.z))}serialize(t){super.serialize(t),t.type="GoldbergMesh";const e={};if(e.adjacentFaces=this.goldbergData.adjacentFaces,e.nbSharedFaces=this.goldbergData.nbSharedFaces,e.nbUnsharedFaces=this.goldbergData.nbUnsharedFaces,e.nbFaces=this.goldbergData.nbFaces,e.nbFacesAtPole=this.goldbergData.nbFacesAtPole,this.goldbergData.faceColors){e.faceColors=[];for(const t of this.goldbergData.faceColors)e.faceColors.push(t.asArray())}if(this.goldbergData.faceCenters){e.faceCenters=[];for(const t of this.goldbergData.faceCenters)e.faceCenters.push(t.asArray())}if(this.goldbergData.faceZaxis){e.faceZaxis=[];for(const t of this.goldbergData.faceZaxis)e.faceZaxis.push(t.asArray())}if(this.goldbergData.faceYaxis){e.faceYaxis=[];for(const t of this.goldbergData.faceYaxis)e.faceYaxis.push(t.asArray())}if(this.goldbergData.faceXaxis){e.faceXaxis=[];for(const t of this.goldbergData.faceXaxis)e.faceXaxis.push(t.asArray())}t.goldbergData=e}static Parse(t,e){const s=t.goldbergData;s.faceColors=s.faceColors.map((t=>a.HE.FromArray(t))),s.faceCenters=s.faceCenters.map((t=>i.P.FromArray(t))),s.faceZaxis=s.faceZaxis.map((t=>i.P.FromArray(t))),s.faceXaxis=s.faceXaxis.map((t=>i.P.FromArray(t))),s.faceYaxis=s.faceYaxis.map((t=>i.P.FromArray(t)));const r=new h(t.name,e);return r.goldbergData=s,r}}},66378:(t,e,s)=>{s.d(e,{E:()=>a});var i=s(58095),r=s(72208),n=s(91243);n.Kj._GroundMeshParser=(t,e)=>a.Parse(t,e);class a extends n.Kj{constructor(t,e){super(t,e),this.generateOctree=!1}getClassName(){return"GroundMesh"}get subdivisions(){return Math.min(this._subdivisionsX,this._subdivisionsY)}get subdivisionsX(){return this._subdivisionsX}get subdivisionsY(){return this._subdivisionsY}optimize(t,e=32){this._subdivisionsX=t,this._subdivisionsY=t,this.subdivide(t);const s=this;s.createOrUpdateSubmeshesOctree&&s.createOrUpdateSubmeshesOctree(e)}getHeightAtCoordinates(t,e){const s=this.getWorldMatrix(),r=i.jp.Matrix[5];s.invertToRef(r);const n=i.jp.Vector3[8];if(i.P.TransformCoordinatesFromFloatsToRef(t,0,e,r,n),t=n.x,e=n.z,t<this._minX||t>=this._maxX||e<=this._minZ||e>this._maxZ)return this.position.y;this._heightQuads&&0!=this._heightQuads.length||(this._initHeightQuads(),this._computeHeightQuads());const a=this._getFacetAt(t,e),o=-(a.x*t+a.z*e+a.w)/a.y;return i.P.TransformCoordinatesFromFloatsToRef(0,o,0,s,n),n.y}getNormalAtCoordinates(t,e){const s=new i.P(0,1,0);return this.getNormalAtCoordinatesToRef(t,e,s),s}getNormalAtCoordinatesToRef(t,e,s){const r=this.getWorldMatrix(),n=i.jp.Matrix[5];r.invertToRef(n);const a=i.jp.Vector3[8];if(i.P.TransformCoordinatesFromFloatsToRef(t,0,e,n,a),t=a.x,e=a.z,t<this._minX||t>this._maxX||e<this._minZ||e>this._maxZ)return this;this._heightQuads&&0!=this._heightQuads.length||(this._initHeightQuads(),this._computeHeightQuads());const o=this._getFacetAt(t,e);return i.P.TransformNormalFromFloatsToRef(o.x,o.y,o.z,r,s),this}updateCoordinateHeights(){return this._heightQuads&&0!=this._heightQuads.length||this._initHeightQuads(),this._computeHeightQuads(),this}_getFacetAt(t,e){const s=Math.floor((t+this._maxX)*this._subdivisionsX/this._width),i=Math.floor(-(e+this._maxZ)*this._subdivisionsY/this._height+this._subdivisionsY),r=this._heightQuads[i*this._subdivisionsX+s];let n;return n=e<r.slope.x*t+r.slope.y?r.facet1:r.facet2,n}_initHeightQuads(){const t=this._subdivisionsX,e=this._subdivisionsY;this._heightQuads=new Array;for(let s=0;s<e;s++)for(let e=0;e<t;e++){const r={slope:i.FM.Zero(),facet1:new i.Lt(0,0,0,0),facet2:new i.Lt(0,0,0,0)};this._heightQuads[s*t+e]=r}return this}_computeHeightQuads(){const t=this.getVerticesData(r.o.PositionKind);if(!t)return this;const e=i.jp.Vector3[3],s=i.jp.Vector3[2],n=i.jp.Vector3[1],a=i.jp.Vector3[0],o=i.jp.Vector3[4],h=i.jp.Vector3[5],c=i.jp.Vector3[6],l=i.jp.Vector3[7],d=i.jp.Vector3[8];let u=0,f=0,g=0,_=0,p=0,m=0,x=0;const I=this._subdivisionsX,y=this._subdivisionsY;for(let r=0;r<y;r++)for(let y=0;y<I;y++){u=3*y,f=r*(I+1)*3,g=(r+1)*(I+1)*3,e.x=t[f+u],e.y=t[f+u+1],e.z=t[f+u+2],s.x=t[f+u+3],s.y=t[f+u+4],s.z=t[f+u+5],n.x=t[g+u],n.y=t[g+u+1],n.z=t[g+u+2],a.x=t[g+u+3],a.y=t[g+u+4],a.z=t[g+u+5],_=(a.z-e.z)/(a.x-e.x),p=e.z-_*e.x,s.subtractToRef(e,o),n.subtractToRef(e,h),a.subtractToRef(e,c),i.P.CrossToRef(c,h,l),i.P.CrossToRef(o,c,d),l.normalize(),d.normalize(),m=-(l.x*e.x+l.y*e.y+l.z*e.z),x=-(d.x*s.x+d.y*s.y+d.z*s.z);const M=this._heightQuads[r*I+y];M.slope.copyFromFloats(_,p),M.facet1.copyFromFloats(l.x,l.y,l.z,m),M.facet2.copyFromFloats(d.x,d.y,d.z,x)}return this}serialize(t){super.serialize(t),t.subdivisionsX=this._subdivisionsX,t.subdivisionsY=this._subdivisionsY,t.minX=this._minX,t.maxX=this._maxX,t.minZ=this._minZ,t.maxZ=this._maxZ,t.width=this._width,t.height=this._height}static Parse(t,e){const s=new a(t.name,e);return s._subdivisionsX=t.subdivisionsX||1,s._subdivisionsY=t.subdivisionsY||1,s._minX=t.minX,s._maxX=t.maxX,s._minZ=t.minZ,s._maxZ=t.maxZ,s._width=t.width,s._height=t.height,s}}},78821:(t,e,s)=>{s.d(e,{eW:()=>v.eW,Jl:()=>i.J});s(71419);var i=s(19488),r=s(58095),n=s(72208),a=s(68345),o=s(91243);s(15631);class h{constructor(t,e){this.normal=t,this.w=e}static FromPoints(t,e,s){const i=s.subtract(t),n=e.subtract(t);if(0===i.lengthSquared()||0===n.lengthSquared())return null;const a=r.P.Normalize(r.P.Cross(i,n));return new h(a,r.P.Dot(a,t))}clone(){return new h(this.normal.clone(),this.w)}flip(){this.normal.scaleInPlace(-1),this.w=-this.w}splitPolygon(t,e,s,i,n){let a=0;const o=[];let l,d;for(l=0;l<t.vertices.length;l++){d=r.P.Dot(this.normal,t.vertices[l].pos)-this.w;const e=d<-h.EPSILON?2:d>h.EPSILON?1:0;a|=e,o.push(e)}switch(a){case 0:(r.P.Dot(this.normal,t.plane.normal)>0?e:s).push(t);break;case 1:i.push(t);break;case 2:n.push(t);break;case 3:{const e=[],s=[];for(l=0;l<t.vertices.length;l++){const i=(l+1)%t.vertices.length,n=o[l],a=o[i],h=t.vertices[l],c=t.vertices[i];if(2!==n&&e.push(h),1!==n&&s.push(2!==n?h.clone():h),3==(n|a)){d=(this.w-r.P.Dot(this.normal,h.pos))/r.P.Dot(this.normal,c.pos.subtract(h.pos));const t=h.interpolate(c,d);e.push(t),s.push(t.clone())}}let a;e.length>=3&&(a=new c(e,t.shared),a.plane&&i.push(a)),s.length>=3&&(a=new c(s,t.shared),a.plane&&n.push(a));break}}}}h.EPSILON=1e-5;class c{constructor(t,e){this.vertices=t,this.shared=e,this.plane=h.FromPoints(t[0].pos,t[1].pos,t[2].pos)}clone(){const t=this.vertices.map((t=>t.clone()));return new c(t,this.shared)}flip(){this.vertices.reverse().map((t=>{t.flip()})),this.plane.flip()}}s(63946),s(66378),s(41234),s(89209);s(63003),s(37852),s(85737);var l,d=s(13514),u=s(48154);class f{constructor(){this.running=!1,this._simplificationArray=[]}addTask(t){this._simplificationArray.push(t)}executeNext(){const t=this._simplificationArray.pop();t?(this.running=!0,this.runSimplification(t)):this.running=!1}runSimplification(t){if(t.parallelProcessing)t.settings.forEach((e=>{this._getSimplifier(t).simplify(e,(s=>{void 0!==e.distance&&t.mesh.addLODLevel(e.distance,s),s.isVisible=!0,e.quality===t.settings[t.settings.length-1].quality&&t.successCallback&&t.successCallback(),this.executeNext()}))}));else{const e=this._getSimplifier(t),s=(s,i)=>{e.simplify(s,(e=>{void 0!==s.distance&&t.mesh.addLODLevel(s.distance,e),e.isVisible=!0,i()}))};d.$g.Run(t.settings.length,(e=>{s(t.settings[e.index],(()=>{e.executeNext()}))}),(()=>{t.successCallback&&t.successCallback(),this.executeNext()}))}}_getSimplifier(t){return t.simplificationType,l.QUADRATIC,new x(t.mesh)}}!function(t){t[t.QUADRATIC=0]="QUADRATIC"}(l||(l={}));class g{constructor(t){this._vertices=t,this.error=new Array(4),this.deleted=!1,this.isDirty=!1,this.deletePending=!1,this.borderFactor=0}}class _{constructor(t,e){this.position=t,this.id=e,this.isBorder=!0,this.q=new p,this.triangleCount=0,this.triangleStart=0,this.originalOffsets=[]}updatePosition(t){this.position.copyFrom(t)}}class p{constructor(t){this.data=new Array(10);for(let e=0;e<10;++e)t&&t[e]?this.data[e]=t[e]:this.data[e]=0}det(t,e,s,i,r,n,a,o,h){return this.data[t]*this.data[r]*this.data[h]+this.data[s]*this.data[i]*this.data[o]+this.data[e]*this.data[n]*this.data[a]-this.data[s]*this.data[r]*this.data[a]-this.data[t]*this.data[n]*this.data[o]-this.data[e]*this.data[i]*this.data[h]}addInPlace(t){for(let e=0;e<10;++e)this.data[e]+=t.data[e]}addArrayInPlace(t){for(let e=0;e<10;++e)this.data[e]+=t[e]}add(t){const e=new p;for(let s=0;s<10;++s)e.data[s]=this.data[s]+t.data[s];return e}static FromData(t,e,s,i){return new p(p.DataFromNumbers(t,e,s,i))}static DataFromNumbers(t,e,s,i){return[t*t,t*e,t*s,t*i,e*e,e*s,e*i,s*s,s*i,i*i]}}class m{constructor(t,e){this.vertexId=t,this.triangleId=e}}class x{constructor(t){this._mesh=t,this.syncIterations=5e3,this.aggressiveness=7,this.decimationIterations=100,this.boundingBoxEpsilon=u.kn}simplify(t,e){this._initDecimatedMesh(),d.$g.Run(this._mesh.subMeshes.length,(e=>{this._initWithMesh(e.index,(()=>{this._runDecimation(t,e.index,(()=>{e.executeNext()}))}),t.optimizeMesh)}),(()=>{setTimeout((()=>{e(this._reconstructedMesh)}),0)}))}_runDecimation(t,e,s){const i=~~(this._triangles.length*t.quality);let n=0;const a=this._triangles.length,o=(t,e)=>{setTimeout((()=>{t%5==0&&this._updateMesh(0===t);for(let t=0;t<this._triangles.length;++t)this._triangles[t].isDirty=!1;const s=1e-9*Math.pow(t+3,this.aggressiveness);d.$g.SyncAsyncForLoop(this._triangles.length,this.syncIterations,(t=>{const e=~~((this._triangles.length/2+t)%this._triangles.length),i=this._triangles[e];if(i&&!(i.error[3]>s||i.deleted||i.isDirty))for(let t=0;t<3;++t)if(i.error[t]<s){const e=[],s=[],a=i._vertices[t],o=i._vertices[(t+1)%3];if(a.isBorder||o.isBorder)continue;const h=r.P.Zero();this._calculateError(a,o,h);const c=new Array;if(this._isFlipped(a,o,h,e,c))continue;if(this._isFlipped(o,a,h,s,c))continue;if(e.indexOf(!0)<0||s.indexOf(!0)<0)continue;const l=new Array;if(c.forEach((t=>{-1===l.indexOf(t)&&(t.deletePending=!0,l.push(t))})),l.length%2!=0)continue;a.q=o.q.add(a.q),a.updatePosition(h);const d=this._references.length;n=this._updateTriangles(a,a,e,n),n=this._updateTriangles(a,o,s,n);const u=this._references.length-d;if(u<=a.triangleCount){if(u)for(let t=0;t<u;t++)this._references[a.triangleStart+t]=this._references[d+t]}else a.triangleStart=d;a.triangleCount=u;break}}),e,(()=>a-n<=i))}),0)};d.$g.Run(this.decimationIterations,(t=>{a-n<=i?t.breakLoop():o(t.index,(()=>{t.executeNext()}))}),(()=>{setTimeout((()=>{this._reconstructMesh(e),s()}),0)}))}_initWithMesh(t,e,s){this._vertices=[],this._triangles=[];const i=this._mesh.getVerticesData(n.o.PositionKind),a=this._mesh.getIndices(),o=this._mesh.subMeshes[t],h=t=>{if(s)for(let e=0;e<this._vertices.length;++e)if(this._vertices[e].position.equalsWithEpsilon(t,1e-4))return this._vertices[e];return null},c=[],l=o.verticesCount;d.$g.SyncAsyncForLoop(l,this.syncIterations/4>>0,(t=>{if(!i)return;const e=t+o.verticesStart,s=r.P.FromArray(i,3*e),n=h(s)||new _(s,this._vertices.length);n.originalOffsets.push(e),n.id===this._vertices.length&&this._vertices.push(n),c.push(n.id)}),(()=>{d.$g.SyncAsyncForLoop(o.indexCount/3,this.syncIterations,(t=>{if(!a)return;const e=3*(o.indexStart/3+t),s=a[e+0],i=a[e+1],r=a[e+2],n=this._vertices[c[s-o.verticesStart]],h=this._vertices[c[i-o.verticesStart]],l=this._vertices[c[r-o.verticesStart]],d=new g([n,h,l]);d.originalOffset=e,this._triangles.push(d)}),(()=>{this._init(e)}))}))}_init(t){d.$g.SyncAsyncForLoop(this._triangles.length,this.syncIterations,(t=>{const e=this._triangles[t];e.normal=r.P.Cross(e._vertices[1].position.subtract(e._vertices[0].position),e._vertices[2].position.subtract(e._vertices[0].position)).normalize();for(let t=0;t<3;t++)e._vertices[t].q.addArrayInPlace(p.DataFromNumbers(e.normal.x,e.normal.y,e.normal.z,-r.P.Dot(e.normal,e._vertices[0].position)))}),(()=>{d.$g.SyncAsyncForLoop(this._triangles.length,this.syncIterations,(t=>{const e=this._triangles[t];for(let t=0;t<3;++t)e.error[t]=this._calculateError(e._vertices[t],e._vertices[(t+1)%3]);e.error[3]=Math.min(e.error[0],e.error[1],e.error[2])}),(()=>{t()}))}))}_reconstructMesh(t){const e=[];let s,i,r;for(s=0;s<this._vertices.length;++s)this._vertices[s].triangleCount=0;for(s=0;s<this._triangles.length;++s)if(!this._triangles[s].deleted){for(i=this._triangles[s],r=0;r<3;++r)i._vertices[r].triangleCount=1;e.push(i)}const o=this._reconstructedMesh.getVerticesData(n.o.PositionKind)||[],h=this._reconstructedMesh.getVerticesData(n.o.NormalKind)||[],c=this._reconstructedMesh.getVerticesData(n.o.UVKind)||[],l=this._reconstructedMesh.getVerticesData(n.o.ColorKind)||[],d=this._mesh.getVerticesData(n.o.NormalKind),u=this._mesh.getVerticesData(n.o.UVKind),f=this._mesh.getVerticesData(n.o.ColorKind);let g=0;for(s=0;s<this._vertices.length;++s){const t=this._vertices[s];t.id=g,t.triangleCount&&t.originalOffsets.forEach((e=>{o.push(t.position.x),o.push(t.position.y),o.push(t.position.z),d&&d.length&&(h.push(d[3*e]),h.push(d[3*e+1]),h.push(d[3*e+2])),u&&u.length&&(c.push(u[2*e]),c.push(u[2*e+1])),f&&f.length&&(l.push(f[4*e]),l.push(f[4*e+1]),l.push(f[4*e+2]),l.push(f[4*e+3])),++g}))}const _=this._reconstructedMesh.getTotalIndices(),p=this._reconstructedMesh.getTotalVertices(),m=this._reconstructedMesh.subMeshes;this._reconstructedMesh.subMeshes=[];const x=this._reconstructedMesh.getIndices(),I=this._mesh.getIndices();for(s=0;s<e.length;++s)i=e[s],[0,1,2].forEach((t=>{const e=I[i.originalOffset+t];let s=i._vertices[t].originalOffsets.indexOf(e);s<0&&(s=0),x.push(i._vertices[t].id+s+p)}));this._reconstructedMesh.setIndices(x),this._reconstructedMesh.setVerticesData(n.o.PositionKind,o),h.length>0&&this._reconstructedMesh.setVerticesData(n.o.NormalKind,h),c.length>0&&this._reconstructedMesh.setVerticesData(n.o.UVKind,c),l.length>0&&this._reconstructedMesh.setVerticesData(n.o.ColorKind,l);const y=this._mesh.subMeshes[t];t>0&&(this._reconstructedMesh.subMeshes=[],m.forEach((t=>{a.P.AddToMesh(t.materialIndex,t.verticesStart,t.verticesCount,t.indexStart,t.indexCount,t.getMesh())})),a.P.AddToMesh(y.materialIndex,p,g,_,3*e.length,this._reconstructedMesh))}_initDecimatedMesh(){this._reconstructedMesh=new o.Kj(this._mesh.name+"Decimated",this._mesh.getScene()),this._reconstructedMesh.material=this._mesh.material,this._reconstructedMesh.parent=this._mesh.parent,this._reconstructedMesh.isVisible=!1,this._reconstructedMesh.renderingGroupId=this._mesh.renderingGroupId}_isFlipped(t,e,s,i,n){for(let a=0;a<t.triangleCount;++a){const o=this._triangles[this._references[t.triangleStart+a].triangleId];if(o.deleted)continue;const h=this._references[t.triangleStart+a].vertexId,c=o._vertices[(h+1)%3],l=o._vertices[(h+2)%3];if(c===e||l===e){i[a]=!0,n.push(o);continue}let d=c.position.subtract(s);d=d.normalize();let u=l.position.subtract(s);if(u=u.normalize(),Math.abs(r.P.Dot(d,u))>.999)return!0;const f=r.P.Cross(d,u).normalize();if(i[a]=!1,r.P.Dot(f,o.normal)<.2)return!0}return!1}_updateTriangles(t,e,s,i){let r=i;for(let i=0;i<e.triangleCount;++i){const n=this._references[e.triangleStart+i],a=this._triangles[n.triangleId];a.deleted||(s[i]&&a.deletePending?(a.deleted=!0,r++):(a._vertices[n.vertexId]=t,a.isDirty=!0,a.error[0]=this._calculateError(a._vertices[0],a._vertices[1])+a.borderFactor/2,a.error[1]=this._calculateError(a._vertices[1],a._vertices[2])+a.borderFactor/2,a.error[2]=this._calculateError(a._vertices[2],a._vertices[0])+a.borderFactor/2,a.error[3]=Math.min(a.error[0],a.error[1],a.error[2]),this._references.push(n)))}return r}_identifyBorder(){for(let t=0;t<this._vertices.length;++t){const e=[],s=[],i=this._vertices[t];let r;for(r=0;r<i.triangleCount;++r){const t=this._triangles[this._references[i.triangleStart+r].triangleId];for(let i=0;i<3;i++){let r=0;const n=t._vertices[i];for(;r<e.length&&s[r]!==n.id;)++r;r===e.length?(e.push(1),s.push(n.id)):e[r]++}}for(r=0;r<e.length;++r)1===e[r]?this._vertices[s[r]].isBorder=!0:this._vertices[s[r]].isBorder=!1}}_updateMesh(t=!1){let e,s,i,r;if(!t){const t=[];for(e=0;e<this._triangles.length;++e)this._triangles[e].deleted||t.push(this._triangles[e]);this._triangles=t}for(e=0;e<this._vertices.length;++e)this._vertices[e].triangleCount=0,this._vertices[e].triangleStart=0;for(e=0;e<this._triangles.length;++e)for(s=this._triangles[e],i=0;i<3;++i)r=s._vertices[i],r.triangleCount++;let n=0;for(e=0;e<this._vertices.length;++e)this._vertices[e].triangleStart=n,n+=this._vertices[e].triangleCount,this._vertices[e].triangleCount=0;const a=new Array(3*this._triangles.length);for(e=0;e<this._triangles.length;++e)for(s=this._triangles[e],i=0;i<3;++i)r=s._vertices[i],a[r.triangleStart+r.triangleCount]=new m(i,e),r.triangleCount++;this._references=a,t&&this._identifyBorder()}_vertexError(t,e){const s=e.x,i=e.y,r=e.z;return t.data[0]*s*s+2*t.data[1]*s*i+2*t.data[2]*s*r+2*t.data[3]*s+t.data[4]*i*i+2*t.data[5]*i*r+2*t.data[6]*i+t.data[7]*r*r+2*t.data[8]*r+t.data[9]}_calculateError(t,e,s){const i=t.q.add(e.q),n=t.isBorder&&e.isBorder;let a=0;const o=i.det(0,1,2,1,4,5,2,5,7);if(0===o||n){const n=t.position.add(e.position).divide(new r.P(2,2,2)),o=this._vertexError(i,t.position),h=this._vertexError(i,e.position),c=this._vertexError(i,n);a=Math.min(o,h,c),a===o?s&&s.copyFrom(t.position):a===h?s&&s.copyFrom(e.position):s&&s.copyFrom(n)}else s||(s=r.P.Zero()),s.x=-1/o*i.det(1,2,3,4,5,6,5,7,8),s.y=1/o*i.det(0,2,3,1,5,6,2,7,8),s.z=-1/o*i.det(0,1,3,1,4,6,2,5,8),a=this._vertexError(i,s);return a}}var I=s(65273),y=s(85627);Object.defineProperty(I.x.prototype,"simplificationQueue",{get:function(){if(!this._simplificationQueue){this._simplificationQueue=new f;let t=this._getComponent(y.l.NAME_SIMPLIFICATIONQUEUE);t||(t=new M(this),this._addComponent(t))}return this._simplificationQueue},set:function(t){this._simplificationQueue=t},enumerable:!0,configurable:!0}),o.Kj.prototype.simplify=function(t,e=!0,s=l.QUADRATIC,i){return this.getScene().simplificationQueue.addTask({settings:t,parallelProcessing:e,mesh:this,simplificationType:s,successCallback:i}),this};class M{constructor(t){this.name=y.l.NAME_SIMPLIFICATIONQUEUE,this.scene=t}register(){this.scene._beforeCameraUpdateStage.registerStep(y.l.STEP_BEFORECAMERAUPDATE_SIMPLIFICATIONQUEUE,this,this._beforeCameraUpdate)}rebuild(){}dispose(){}_beforeCameraUpdate(){this.scene._simplificationQueue&&!this.scene._simplificationQueue.running&&this.scene._simplificationQueue.executeNext()}}s(86230),s(28674),s(39318),s(62659),s(30700);var v=s(42080);s(21254),s(84157),s(83236)},63003:(t,e,s)=>{s.d(e,{S:()=>l});var i=s(58095),r=s(84318),n=s(71419),a=s(91243),o=s(1101),h=s(30700),c=s(72208);a.Kj._instancedMeshFactory=(t,e)=>{const s=new l(t,e);if(e.instancedBuffers){s.instancedBuffers={};for(const t in e.instancedBuffers)s.instancedBuffers[t]=e.instancedBuffers[t]}return s};class l extends n.x{constructor(t,e){super(t,e.getScene()),this._indexInSourceMeshInstanceArray=-1,this._distanceToCamera=0,e.addInstance(this),this._sourceMesh=e,this._unIndexed=e._unIndexed,this.position.copyFrom(e.position),this.rotation.copyFrom(e.rotation),this.scaling.copyFrom(e.scaling),e.rotationQuaternion&&(this.rotationQuaternion=e.rotationQuaternion.clone()),this.animations=e.animations.slice();for(const t of e.getAnimationRanges())null!=t&&this.createAnimationRange(t.name,t.from,t.to);this.infiniteDistance=e.infiniteDistance,this.setPivotMatrix(e.getPivotMatrix()),this.refreshBoundingInfo(!0,!0),this._syncSubMeshes()}getClassName(){return"InstancedMesh"}get lightSources(){return this._sourceMesh._lightSources}_resyncLightSources(){}_resyncLightSource(){}_removeLightSource(){}get receiveShadows(){return this._sourceMesh.receiveShadows}get material(){return this._sourceMesh.material}get visibility(){return this._sourceMesh.visibility}get skeleton(){return this._sourceMesh.skeleton}get renderingGroupId(){return this._sourceMesh.renderingGroupId}set renderingGroupId(t){this._sourceMesh&&t!==this._sourceMesh.renderingGroupId&&r.Y.Warn("Note - setting renderingGroupId of an instanced mesh has no effect on the scene")}getTotalVertices(){return this._sourceMesh?this._sourceMesh.getTotalVertices():0}getTotalIndices(){return this._sourceMesh.getTotalIndices()}get sourceMesh(){return this._sourceMesh}createInstance(t){return this._sourceMesh.createInstance(t)}isReady(t=!1){return this._sourceMesh.isReady(t,!0)}getVerticesData(t,e){return this._sourceMesh.getVerticesData(t,e)}setVerticesData(t,e,s,i){return this.sourceMesh&&this.sourceMesh.setVerticesData(t,e,s,i),this.sourceMesh}updateVerticesData(t,e,s,i){return this.sourceMesh&&this.sourceMesh.updateVerticesData(t,e,s,i),this.sourceMesh}setIndices(t,e=null){return this.sourceMesh&&this.sourceMesh.setIndices(t,e),this.sourceMesh}isVerticesDataPresent(t){return this._sourceMesh.isVerticesDataPresent(t)}getIndices(){return this._sourceMesh.getIndices()}get _positions(){return this._sourceMesh._positions}refreshBoundingInfo(t=!1,e=!1){if(this.hasBoundingInfo&&this.getBoundingInfo().isLocked)return this;const s=this._sourceMesh.geometry?this._sourceMesh.geometry.boundingBias:null;return this._refreshBoundingInfo(this._sourceMesh._getPositionData(t,e),s),this}_preActivate(){return this._currentLOD&&this._currentLOD._preActivate(),this}_activate(t,e){if(super._activate(t,e),this._sourceMesh.subMeshes||r.Y.Warn("Instances should only be created for meshes with geometry."),this._currentLOD){if(this._currentLOD._getWorldMatrixDeterminant()>=0!=this._getWorldMatrixDeterminant()>=0)return this._internalAbstractMeshDataInfo._actAsRegularMesh=!0,!0;if(this._internalAbstractMeshDataInfo._actAsRegularMesh=!1,this._currentLOD._registerInstanceForRenderId(this,t),e){if(!this._currentLOD._internalAbstractMeshDataInfo._isActiveIntermediate)return this._currentLOD._internalAbstractMeshDataInfo._onlyForInstancesIntermediate=!0,!0}else if(!this._currentLOD._internalAbstractMeshDataInfo._isActive)return this._currentLOD._internalAbstractMeshDataInfo._onlyForInstances=!0,!0}return!1}_postActivate(){this._sourceMesh.edgesShareWithInstances&&this._sourceMesh._edgesRenderer&&this._sourceMesh._edgesRenderer.isEnabled&&this._sourceMesh._renderingGroup?(this._sourceMesh._renderingGroup._edgesRenderers.pushNoDuplicate(this._sourceMesh._edgesRenderer),this._sourceMesh._edgesRenderer.customInstances.push(this.getWorldMatrix())):this._edgesRenderer&&this._edgesRenderer.isEnabled&&this._sourceMesh._renderingGroup&&this._sourceMesh._renderingGroup._edgesRenderers.push(this._edgesRenderer)}getWorldMatrix(){if(this._currentLOD&&this._currentLOD.billboardMode!==h.Y.BILLBOARDMODE_NONE&&this._currentLOD._masterMesh!==this){this._billboardWorldMatrix||(this._billboardWorldMatrix=new i.y3);const t=this._currentLOD._masterMesh;return this._currentLOD._masterMesh=this,i.jp.Vector3[7].copyFrom(this._currentLOD.position),this._currentLOD.position.set(0,0,0),this._billboardWorldMatrix.copyFrom(this._currentLOD.computeWorldMatrix(!0)),this._currentLOD.position.copyFrom(i.jp.Vector3[7]),this._currentLOD._masterMesh=t,this._billboardWorldMatrix}return super.getWorldMatrix()}get isAnInstance(){return!0}getLOD(t){if(!t)return this;const e=this.sourceMesh.getLODLevels();if(e&&0!==e.length){const e=this.getBoundingInfo();this._currentLOD=this.sourceMesh.getLOD(t,e.boundingSphere)}else this._currentLOD=this.sourceMesh;return this._currentLOD}_preActivateForIntermediateRendering(t){return this.sourceMesh._preActivateForIntermediateRendering(t)}_syncSubMeshes(){if(this.releaseSubMeshes(),this._sourceMesh.subMeshes)for(let t=0;t<this._sourceMesh.subMeshes.length;t++)this._sourceMesh.subMeshes[t].clone(this,this._sourceMesh);return this}_generatePointsArray(){return this._sourceMesh._generatePointsArray()}_updateBoundingInfo(){return this.hasBoundingInfo?this.getBoundingInfo().update(this.worldMatrixFromCache):this.buildBoundingInfo(this.absolutePosition,this.absolutePosition,this.worldMatrixFromCache),this._updateSubMeshesBoundingInfo(this.worldMatrixFromCache),this}clone(t,e=null,s,i){const r=(i||this._sourceMesh).createInstance(t);if(o.j.DeepCopy(this,r,["name","subMeshes","uniqueId","parent","lightSources","receiveShadows","material","visibility","skeleton","sourceMesh","isAnInstance","facetNb","isFacetDataEnabled","isBlocked","useBones","hasInstances","collider","edgesRenderer","forward","up","right","absolutePosition","absoluteScaling","absoluteRotationQuaternion","isWorldMatrixFrozen","nonUniformScaling","behaviors","worldMatrixFromCache","hasThinInstances","hasBoundingInfo"],[]),this.refreshBoundingInfo(),e&&(r.parent=e),!s)for(let t=0;t<this.getScene().meshes.length;t++){const e=this.getScene().meshes[t];e.parent===this&&e.clone(e.name,r)}return r.computeWorldMatrix(!0),this.onClonedObservable.notifyObservers(r),r}dispose(t,e=!1){this._sourceMesh.removeInstance(this),super.dispose(t,e)}_serializeAsParent(t){super._serializeAsParent(t),t.parentId=this._sourceMesh.uniqueId,t.parentInstanceIndex=this._indexInSourceMeshInstanceArray}instantiateHierarchy(t=null,e,s){const i=this.clone("Clone of "+(this.name||this.id),t||this.parent,!0,e&&e.newSourcedMesh);i&&s&&s(this,i);for(const t of this.getChildTransformNodes(!0))t.instantiateHierarchy(i,e,s);return i}}a.Kj.prototype.registerInstancedBuffer=function(t,e){var s,i;if(null===(i=null===(s=this._userInstancedBuffersStorage)||void 0===s?void 0:s.vertexBuffers[t])||void 0===i||i.dispose(),!this.instancedBuffers){this.instancedBuffers={};for(const t of this.instances)t.instancedBuffers={};this._userInstancedBuffersStorage||(this._userInstancedBuffersStorage={data:{},vertexBuffers:{},strides:{},sizes:{},vertexArrayObjects:this.getEngine().getCaps().vertexArrayObject?{}:void 0})}this.instancedBuffers[t]=null,this._userInstancedBuffersStorage.strides[t]=e,this._userInstancedBuffersStorage.sizes[t]=32*e,this._userInstancedBuffersStorage.data[t]=new Float32Array(this._userInstancedBuffersStorage.sizes[t]),this._userInstancedBuffersStorage.vertexBuffers[t]=new c.o(this.getEngine(),this._userInstancedBuffersStorage.data[t],t,!0,!1,e,!0);for(const e of this.instances)e.instancedBuffers[t]=null;this._invalidateInstanceVertexArrayObject(),this._markSubMeshesAsAttributesDirty()},a.Kj.prototype._processInstancedBuffers=function(t,e){const s=t?t.length:0;for(const i in this.instancedBuffers){let r=this._userInstancedBuffersStorage.sizes[i];const n=this._userInstancedBuffersStorage.strides[i],a=(s+1)*n;for(;r<a;)r*=2;this._userInstancedBuffersStorage.data[i].length!=r&&(this._userInstancedBuffersStorage.data[i]=new Float32Array(r),this._userInstancedBuffersStorage.sizes[i]=r,this._userInstancedBuffersStorage.vertexBuffers[i]&&(this._userInstancedBuffersStorage.vertexBuffers[i].dispose(),this._userInstancedBuffersStorage.vertexBuffers[i]=null));const o=this._userInstancedBuffersStorage.data[i];let h=0;if(e){const t=this.instancedBuffers[i];t.toArray?t.toArray(o,h):t.copyToArray?t.copyToArray(o,h):o[h]=t,h+=n}for(let e=0;e<s;e++){const s=t[e].instancedBuffers[i];s.toArray?s.toArray(o,h):s.copyToArray?s.copyToArray(o,h):o[h]=s,h+=n}this._userInstancedBuffersStorage.vertexBuffers[i]?this._userInstancedBuffersStorage.vertexBuffers[i].updateDirectly(o,0):(this._userInstancedBuffersStorage.vertexBuffers[i]=new c.o(this.getEngine(),this._userInstancedBuffersStorage.data[i],i,!0,!1,n,!0),this._invalidateInstanceVertexArrayObject())}},a.Kj.prototype._invalidateInstanceVertexArrayObject=function(){if(this._userInstancedBuffersStorage&&void 0!==this._userInstancedBuffersStorage.vertexArrayObjects){for(const t in this._userInstancedBuffersStorage.vertexArrayObjects)this.getEngine().releaseVertexArrayObject(this._userInstancedBuffersStorage.vertexArrayObjects[t]);this._userInstancedBuffersStorage.vertexArrayObjects={}}},a.Kj.prototype._disposeInstanceSpecificData=function(){for(this._instanceDataStorage.instancesBuffer&&(this._instanceDataStorage.instancesBuffer.dispose(),this._instanceDataStorage.instancesBuffer=null);this.instances.length;)this.instances[0].dispose();for(const t in this.instancedBuffers)this._userInstancedBuffersStorage.vertexBuffers[t]&&this._userInstancedBuffersStorage.vertexBuffers[t].dispose();this._invalidateInstanceVertexArrayObject(),this.instancedBuffers={}}},37852:(t,e,s)=>{s.d(e,{E:()=>l,_:()=>c});var i=s(15631),r=s(72208),n=s(91243),a=s(63003),o=s(98163),h=s(54067);s(77018),s(81654);n.Kj._LinesMeshParser=(t,e)=>c.Parse(t,e);class c extends n.Kj{_isShaderMaterial(t){return"ShaderMaterial"===t.getClassName()}constructor(t,e=null,s=null,n=null,a,o,c,l){super(t,e,s,n,a),this.useVertexColor=o,this.useVertexAlpha=c,this.color=new i.Wo(1,1,1),this.alpha=1,n&&(this.color=n.color.clone(),this.alpha=n.alpha,this.useVertexColor=n.useVertexColor,this.useVertexAlpha=n.useVertexAlpha),this.intersectionThreshold=.1;const d={attributes:[r.o.PositionKind],uniforms:["world","viewProjection"],needAlphaBlending:!0,defines:[],useClipPlane:null};!1===c?d.needAlphaBlending=!1:d.defines.push("#define VERTEXALPHA"),o?(d.defines.push("#define VERTEXCOLOR"),d.attributes.push(r.o.ColorKind)):(d.uniforms.push("color"),this._color4=new i.HE),l?this.material=l:(this.material=new h.j("colorShader",this.getScene(),"color",d,!1),this.material.doNotSerialize=!0)}isReady(){return!!this._lineMaterial.isReady(this,!!this._userInstancedBuffersStorage)&&super.isReady()}getClassName(){return"LinesMesh"}get material(){return this._lineMaterial}set material(t){this._lineMaterial=t,this._lineMaterial.fillMode=o.F.LineListDrawMode}get checkCollisions(){return!1}set checkCollisions(t){}_bind(t,e){if(!this._geometry)return this;const s=this.isUnIndexed?null:this._geometry.getIndexBuffer();if(this._userInstancedBuffersStorage?this._geometry._bind(e,s,this._userInstancedBuffersStorage.vertexBuffers,this._userInstancedBuffersStorage.vertexArrayObjects):this._geometry._bind(e,s),!this.useVertexColor&&this._isShaderMaterial(this._lineMaterial)){const{r:t,g:e,b:s}=this.color;this._color4.set(t,e,s,this.alpha),this._lineMaterial.setColor4("color",this._color4)}return this}_draw(t,e,s){if(!this._geometry||!this._geometry.getVertexBuffers()||!this._unIndexed&&!this._geometry.getIndexBuffer())return this;const i=this.getScene().getEngine();return this._unIndexed?i.drawArraysType(o.F.LineListDrawMode,t.verticesStart,t.verticesCount,s):i.drawElementsType(o.F.LineListDrawMode,t.indexStart,t.indexCount,s),this}dispose(t,e=!1,s){s||this._lineMaterial.dispose(!1,!1,!0),super.dispose(t)}clone(t,e=null,s){return new c(t,this.getScene(),e,this,s)}createInstance(t){const e=new l(t,this);if(this.instancedBuffers){e.instancedBuffers={};for(const t in this.instancedBuffers)e.instancedBuffers[t]=this.instancedBuffers[t]}return e}serialize(t){super.serialize(t),t.color=this.color.asArray(),t.alpha=this.alpha}static Parse(t,e){const s=new c(t.name,e);return s.color=i.Wo.FromArray(t.color),s.alpha=t.alpha,s}}class l extends a.S{constructor(t,e){super(t,e),this.intersectionThreshold=e.intersectionThreshold}getClassName(){return"InstancedLinesMesh"}}},91243:(t,e,s)=>{s.d(e,{Kj:()=>w,gW:()=>S});var i=s(62897),r=s(13514),n=s(1101),a=s(20163),o=s(24539),h=s(2055),c=s(65273),l=s(58095),d=s(15631),u=s(17834),f=s(72208),g=s(89209),_=s(63946),p=s(71419),m=s(68345),x=s(98163),I=s(91855),y=s(43824),M=s(96969),v=s(84318),D=s(48620),b=s(77851),B=s(85627),A=s(62659);class S{}class V{constructor(){this.visibleInstances={},this.batchCache=new P,this.batchCacheReplacementModeInFrozenMode=new P,this.instancesBufferSize=2048}}class P{constructor(){this.mustReturn=!1,this.visibleInstances=new Array,this.renderSelf=new Array,this.hardwareInstancedRendering=new Array}}class T{constructor(){this.instancesCount=0,this.matrixBuffer=null,this.previousMatrixBuffer=null,this.matrixBufferSize=512,this.matrixData=null,this.boundingVectors=[],this.worldMatrices=null}}class C{constructor(){this._areNormalsFrozen=!1,this._source=null,this.meshMap=null,this._preActivateId=-1,this._LODLevels=new Array,this._useLODScreenCoverage=!1,this._effectiveMaterial=null,this._forcedInstanceCount=0}}class w extends p.x{static _GetDefaultSideOrientation(t){return t||w.FRONTSIDE}get useLODScreenCoverage(){return this._internalMeshDataInfo._useLODScreenCoverage}set useLODScreenCoverage(t){this._internalMeshDataInfo._useLODScreenCoverage=t,this._sortLODLevels()}get computeBonesUsingShaders(){return this._internalAbstractMeshDataInfo._computeBonesUsingShaders}set computeBonesUsingShaders(t){this._internalAbstractMeshDataInfo._computeBonesUsingShaders!==t&&(t&&this._internalMeshDataInfo._sourcePositions&&(this.setVerticesData(f.o.PositionKind,this._internalMeshDataInfo._sourcePositions,!0),this._internalMeshDataInfo._sourceNormals&&this.setVerticesData(f.o.NormalKind,this._internalMeshDataInfo._sourceNormals,!0),this._internalMeshDataInfo._sourcePositions=null,this._internalMeshDataInfo._sourceNormals=null),this._internalAbstractMeshDataInfo._computeBonesUsingShaders=t,this._markSubMeshesAsAttributesDirty())}get onBeforeRenderObservable(){return this._internalMeshDataInfo._onBeforeRenderObservable||(this._internalMeshDataInfo._onBeforeRenderObservable=new i.y$),this._internalMeshDataInfo._onBeforeRenderObservable}get onBeforeBindObservable(){return this._internalMeshDataInfo._onBeforeBindObservable||(this._internalMeshDataInfo._onBeforeBindObservable=new i.y$),this._internalMeshDataInfo._onBeforeBindObservable}get onAfterRenderObservable(){return this._internalMeshDataInfo._onAfterRenderObservable||(this._internalMeshDataInfo._onAfterRenderObservable=new i.y$),this._internalMeshDataInfo._onAfterRenderObservable}get onBetweenPassObservable(){return this._internalMeshDataInfo._onBetweenPassObservable||(this._internalMeshDataInfo._onBetweenPassObservable=new i.y$),this._internalMeshDataInfo._onBetweenPassObservable}get onBeforeDrawObservable(){return this._internalMeshDataInfo._onBeforeDrawObservable||(this._internalMeshDataInfo._onBeforeDrawObservable=new i.y$),this._internalMeshDataInfo._onBeforeDrawObservable}set onBeforeDraw(t){this._onBeforeDrawObserver&&this.onBeforeDrawObservable.remove(this._onBeforeDrawObserver),this._onBeforeDrawObserver=this.onBeforeDrawObservable.add(t)}get hasInstances(){return this.instances.length>0}get hasThinInstances(){var t;return(null!==(t=this._thinInstanceDataStorage.instancesCount)&&void 0!==t?t:0)>0}get forcedInstanceCount(){return this._internalMeshDataInfo._forcedInstanceCount}set forcedInstanceCount(t){this._internalMeshDataInfo._forcedInstanceCount=t}get source(){return this._internalMeshDataInfo._source}get cloneMeshMap(){return this._internalMeshDataInfo.meshMap}get isUnIndexed(){return this._unIndexed}set isUnIndexed(t){this._unIndexed!==t&&(this._unIndexed=t,this._markSubMeshesAsAttributesDirty())}get worldMatrixInstancedBuffer(){return this._instanceDataStorage.instancesData}get previousWorldMatrixInstancedBuffer(){return this._instanceDataStorage.instancesPreviousData}get manualUpdateOfWorldMatrixInstancedBuffer(){return this._instanceDataStorage.manualUpdate}set manualUpdateOfWorldMatrixInstancedBuffer(t){this._instanceDataStorage.manualUpdate=t}get manualUpdateOfPreviousWorldMatrixInstancedBuffer(){return this._instanceDataStorage.previousManualUpdate}set manualUpdateOfPreviousWorldMatrixInstancedBuffer(t){this._instanceDataStorage.previousManualUpdate=t}get forceWorldMatrixInstancedBufferUpdate(){return this._instanceDataStorage.forceMatrixUpdates}set forceWorldMatrixInstancedBufferUpdate(t){this._instanceDataStorage.forceMatrixUpdates=t}constructor(t,e=null,s=null,r=null,o,h=!0){if(super(t,e),this._internalMeshDataInfo=new C,this.delayLoadState=0,this.instances=new Array,this._creationDataStorage=null,this._geometry=null,this._instanceDataStorage=new V,this._thinInstanceDataStorage=new T,this._shouldGenerateFlatShading=!1,this._originalBuilderSideOrientation=w.DEFAULTSIDE,this.overrideMaterialSideOrientation=null,this.ignoreCameraMaxZ=!1,e=this.getScene(),this._onBeforeDraw=(t,e,s)=>{t&&s&&(this._uniformBuffer?this.transferToEffect(e):s.bindOnlyWorldMatrix(e))},r){if(r._geometry&&r._geometry.applyToMesh(this),n.j.DeepCopy(r,this,["name","material","skeleton","instances","parent","uniqueId","source","metadata","morphTargetManager","hasInstances","worldMatrixInstancedBuffer","previousWorldMatrixInstancedBuffer","hasLODLevels","geometry","isBlocked","areNormalsFrozen","facetNb","isFacetDataEnabled","lightSources","useBones","isAnInstance","collider","edgesRenderer","forward","up","right","absolutePosition","absoluteScaling","absoluteRotationQuaternion","isWorldMatrixFrozen","nonUniformScaling","behaviors","worldMatrixFromCache","hasThinInstances","cloneMeshMap","hasBoundingInfo"],["_poseMatrix"]),this._internalMeshDataInfo._source=r,e.useClonedMeshMap&&(r._internalMeshDataInfo.meshMap||(r._internalMeshDataInfo.meshMap={}),r._internalMeshDataInfo.meshMap[this.uniqueId]=this),this._originalBuilderSideOrientation=r._originalBuilderSideOrientation,this._creationDataStorage=r._creationDataStorage,r._ranges){const t=r._ranges;for(const e in t)Object.prototype.hasOwnProperty.call(t,e)&&t[e]&&this.createAnimationRange(e,t[e].from,t[e].to)}if(r.metadata&&r.metadata.clone?this.metadata=r.metadata.clone():this.metadata=r.metadata,this._internalMetadata=r._internalMetadata,a.$&&a.$.HasTags(r)&&a.$.AddTagsTo(this,a.$.GetTags(r,!0)),this.setEnabled(r.isEnabled(!1)),this.parent=r.parent,this.setPivotMatrix(r.getPivotMatrix()),this.id=t+"."+r.id,this.material=r.material,!o){const e=r.getDescendants(!0);for(let s=0;s<e.length;s++){const i=e[s];i.clone&&i.clone(t+"."+i.name,this)}}if(r.morphTargetManager&&(this.morphTargetManager=r.morphTargetManager),e.getPhysicsEngine){const t=e.getPhysicsEngine();if(h&&t&&1===t.getPluginVersion()){const e=t.getImpostorForPhysicsObject(r);e&&(this.physicsImpostor=e.clone(this))}}for(let t=0;t<e.particleSystems.length;t++){const s=e.particleSystems[t];s.emitter===r&&s.clone(s.name,this)}this.skeleton=r.skeleton,this.refreshBoundingInfo(!0,!0),this.computeWorldMatrix(!0)}null!==s&&(this.parent=s),this._instanceDataStorage.hardwareInstancedRendering=this.getEngine().getCaps().instancedArrays,this._internalMeshDataInfo._onMeshReadyObserverAdded=t=>{t.unregisterOnNextCall=!0,this.isReady(!0)?this.onMeshReadyObservable.notifyObservers(this):this._internalMeshDataInfo._checkReadinessObserver||(this._internalMeshDataInfo._checkReadinessObserver=this._scene.onBeforeRenderObservable.add((()=>{this.isReady(!0)&&(this._scene.onBeforeRenderObservable.remove(this._internalMeshDataInfo._checkReadinessObserver),this._internalMeshDataInfo._checkReadinessObserver=null,this.onMeshReadyObservable.notifyObservers(this))})))},this.onMeshReadyObservable=new i.y$(this._internalMeshDataInfo._onMeshReadyObserverAdded),r&&r.onClonedObservable.notifyObservers(this)}instantiateHierarchy(t=null,e,s){const i=0===this.getTotalVertices()||e&&e.doNotInstantiate&&(!0===e.doNotInstantiate||e.doNotInstantiate(this))?this.clone("Clone of "+(this.name||this.id),t||this.parent,!0):this.createInstance("instance of "+(this.name||this.id));i.parent=t||this.parent,i.position=this.position.clone(),i.scaling=this.scaling.clone(),this.rotationQuaternion?i.rotationQuaternion=this.rotationQuaternion.clone():i.rotation=this.rotation.clone(),s&&s(this,i);for(const t of this.getChildTransformNodes(!0))"InstancedMesh"===t.getClassName()&&"Mesh"===i.getClassName()&&t.sourceMesh===this?t.instantiateHierarchy(i,{doNotInstantiate:e&&e.doNotInstantiate||!1,newSourcedMesh:i},s):t.instantiateHierarchy(i,e,s);return i}getClassName(){return"Mesh"}get _isMesh(){return!0}toString(t){let e=super.toString(t);if(e+=", n vertices: "+this.getTotalVertices(),e+=", parent: "+(this._waitingParentId?this._waitingParentId:this.parent?this.parent.name:"NONE"),this.animations)for(let s=0;s<this.animations.length;s++)e+=", animation[0]: "+this.animations[s].toString(t);if(t)if(this._geometry){const t=this.getIndices(),s=this.getVerticesData(f.o.PositionKind);s&&t&&(e+=", flat shading: "+(s.length/3===t.length?"YES":"NO"))}else e+=", flat shading: UNKNOWN";return e}_unBindEffect(){super._unBindEffect();for(const t of this.instances)t._unBindEffect()}get hasLODLevels(){return this._internalMeshDataInfo._LODLevels.length>0}getLODLevels(){return this._internalMeshDataInfo._LODLevels}_sortLODLevels(){const t=this._internalMeshDataInfo._useLODScreenCoverage?-1:1;this._internalMeshDataInfo._LODLevels.sort(((e,s)=>e.distanceOrScreenCoverage<s.distanceOrScreenCoverage?t:e.distanceOrScreenCoverage>s.distanceOrScreenCoverage?-t:0))}addLODLevel(t,e){if(e&&e._masterMesh)return v.Y.Warn("You cannot use a mesh as LOD level twice"),this;const s=new A.g(t,e);return this._internalMeshDataInfo._LODLevels.push(s),e&&(e._masterMesh=this),this._sortLODLevels(),this}getLODLevelAtDistance(t){const e=this._internalMeshDataInfo;for(let s=0;s<e._LODLevels.length;s++){const i=e._LODLevels[s];if(i.distanceOrScreenCoverage===t)return i.mesh}return null}removeLODLevel(t){const e=this._internalMeshDataInfo;for(let s=0;s<e._LODLevels.length;s++)e._LODLevels[s].mesh===t&&(e._LODLevels.splice(s,1),t&&(t._masterMesh=null));return this._sortLODLevels(),this}getLOD(t,e){const s=this._internalMeshDataInfo;if(!s._LODLevels||0===s._LODLevels.length)return this;const i=e||this.getBoundingInfo().boundingSphere,r=t.mode===h.V.ORTHOGRAPHIC_CAMERA?t.minZ:i.centerWorld.subtract(t.globalPosition).length();let n=r,a=1;if(s._useLODScreenCoverage){const e=t.screenArea;let s=i.radiusWorld*t.minZ/r;s=s*s*Math.PI,n=s/e,a=-1}if(a*s._LODLevels[s._LODLevels.length-1].distanceOrScreenCoverage>a*n)return this.onLODLevelSelection&&this.onLODLevelSelection(n,this,this),this;for(let t=0;t<s._LODLevels.length;t++){const e=s._LODLevels[t];if(a*e.distanceOrScreenCoverage<a*n){if(e.mesh){if(4===e.mesh.delayLoadState)return e.mesh._checkDelayState(),this;if(2===e.mesh.delayLoadState)return this;e.mesh._preActivate(),e.mesh._updateSubMeshesBoundingInfo(this.worldMatrixFromCache)}return this.onLODLevelSelection&&this.onLODLevelSelection(n,this,e.mesh),e.mesh}}return this.onLODLevelSelection&&this.onLODLevelSelection(n,this,this),this}get geometry(){return this._geometry}getTotalVertices(){return null===this._geometry||void 0===this._geometry?0:this._geometry.getTotalVertices()}getVerticesData(t,e,s){var i,r;if(!this._geometry)return null;let n=null===(r=null===(i=this._userInstancedBuffersStorage)||void 0===i?void 0:i.vertexBuffers[t])||void 0===r?void 0:r.getFloatData(this._geometry.getTotalVertices(),s||e&&1!==this._geometry.meshes.length);return n||(n=this._geometry.getVerticesData(t,e,s)),n}getVertexBuffer(t){var e,s;return this._geometry?null!==(s=null===(e=this._userInstancedBuffersStorage)||void 0===e?void 0:e.vertexBuffers[t])&&void 0!==s?s:this._geometry.getVertexBuffer(t):null}isVerticesDataPresent(t){var e;return this._geometry?void 0!==(null===(e=this._userInstancedBuffersStorage)||void 0===e?void 0:e.vertexBuffers[t])||this._geometry.isVerticesDataPresent(t):!!this._delayInfo&&-1!==this._delayInfo.indexOf(t)}isVertexBufferUpdatable(t){var e,s;return this._geometry?(null===(s=null===(e=this._userInstancedBuffersStorage)||void 0===e?void 0:e.vertexBuffers[t])||void 0===s?void 0:s.isUpdatable())||this._geometry.isVertexBufferUpdatable(t):!!this._delayInfo&&-1!==this._delayInfo.indexOf(t)}getVerticesDataKinds(){if(!this._geometry){const t=new Array;return this._delayInfo&&this._delayInfo.forEach((function(e){t.push(e)})),t}const t=this._geometry.getVerticesDataKinds();if(this._userInstancedBuffersStorage)for(const e in this._userInstancedBuffersStorage.vertexBuffers)t.push(e);return t}getTotalIndices(){return this._geometry?this._geometry.getTotalIndices():0}getIndices(t,e){return this._geometry?this._geometry.getIndices(t,e):[]}get isBlocked(){return null!==this._masterMesh&&void 0!==this._masterMesh}isReady(t=!1,e=!1){var s,i,r,n,a,o;if(2===this.delayLoadState)return!1;if(!super.isReady(t))return!1;if(!this.subMeshes||0===this.subMeshes.length)return!0;if(!t)return!0;const h=this.getEngine(),c=this.getScene(),l=e||h.getCaps().instancedArrays&&(this.instances.length>0||this.hasThinInstances);this.computeWorldMatrix();const d=this.material||c.defaultMaterial;if(d)if(d._storeEffectOnSubMeshes)for(const t of this.subMeshes){const e=t.getMaterial();if(e)if(e._storeEffectOnSubMeshes){if(!e.isReadyForSubMesh(this,t,l))return!1}else if(!e.isReady(this,l))return!1}else if(!d.isReady(this,l))return!1;const u=h.currentRenderPassId;for(const t of this.lightSources){const e=t.getShadowGenerators();if(!e)continue;const c=e.values();for(let t=c.next();!0!==t.done;t=c.next()){const e=t.value;if(e&&(!(null===(s=e.getShadowMap())||void 0===s?void 0:s.renderList)||(null===(i=e.getShadowMap())||void 0===i?void 0:i.renderList)&&-1!==(null===(n=null===(r=e.getShadowMap())||void 0===r?void 0:r.renderList)||void 0===n?void 0:n.indexOf(this)))){e.getShadowMap()&&(h.currentRenderPassId=e.getShadowMap().renderPassId);for(const t of this.subMeshes)if(!e.isReady(t,l,null!==(o=null===(a=t.getMaterial())||void 0===a?void 0:a.needAlphaBlendingForMesh(this))&&void 0!==o&&o))return h.currentRenderPassId=u,!1;h.currentRenderPassId=u}}}for(const t of this._internalMeshDataInfo._LODLevels)if(t.mesh&&!t.mesh.isReady(l))return!1;return!0}get areNormalsFrozen(){return this._internalMeshDataInfo._areNormalsFrozen}freezeNormals(){return this._internalMeshDataInfo._areNormalsFrozen=!0,this}unfreezeNormals(){return this._internalMeshDataInfo._areNormalsFrozen=!1,this}set overridenInstanceCount(t){this._instanceDataStorage.overridenInstanceCount=t}_preActivate(){const t=this._internalMeshDataInfo,e=this.getScene().getRenderId();return t._preActivateId===e||(t._preActivateId=e,this._instanceDataStorage.visibleInstances=null),this}_preActivateForIntermediateRendering(t){return this._instanceDataStorage.visibleInstances&&(this._instanceDataStorage.visibleInstances.intermediateDefaultRenderId=t),this}_registerInstanceForRenderId(t,e){return this._instanceDataStorage.visibleInstances||(this._instanceDataStorage.visibleInstances={defaultRenderId:e,selfDefaultRenderId:this._renderId}),this._instanceDataStorage.visibleInstances[e]||(void 0!==this._instanceDataStorage.previousRenderId&&this._instanceDataStorage.isFrozen&&(this._instanceDataStorage.visibleInstances[this._instanceDataStorage.previousRenderId]=null),this._instanceDataStorage.previousRenderId=e,this._instanceDataStorage.visibleInstances[e]=new Array),this._instanceDataStorage.visibleInstances[e].push(t),this}_afterComputeWorldMatrix(){super._afterComputeWorldMatrix(),this.hasThinInstances&&(this.doNotSyncBoundingInfo||this.thinInstanceRefreshBoundingInfo(!1))}_postActivate(){this.edgesShareWithInstances&&this.edgesRenderer&&this.edgesRenderer.isEnabled&&this._renderingGroup&&(this._renderingGroup._edgesRenderers.pushNoDuplicate(this.edgesRenderer),this.edgesRenderer.customInstances.push(this.getWorldMatrix()))}refreshBoundingInfo(t=!1,e=!1){if(this.hasBoundingInfo&&this.getBoundingInfo().isLocked)return this;const s=this.geometry?this.geometry.boundingBias:null;return this._refreshBoundingInfo(this._getPositionData(t,e),s),this}_createGlobalSubMesh(t){const e=this.getTotalVertices();if(!e||!this.getIndices())return null;if(this.subMeshes&&this.subMeshes.length>0){const s=this.getIndices();if(!s)return null;const i=s.length;let r=!1;if(t)r=!0;else for(const t of this.subMeshes){if(t.indexStart+t.indexCount>i){r=!0;break}if(t.verticesStart+t.verticesCount>e){r=!0;break}}if(!r)return this.subMeshes[0]}return this.releaseSubMeshes(),new m.P(0,0,e,0,this.getTotalIndices(),this)}subdivide(t){if(t<1)return;const e=this.getTotalIndices();let s=e/t|0,i=0;for(;s%3!=0;)s++;this.releaseSubMeshes();for(let r=0;r<t&&!(i>=e);r++)m.P.CreateFromIndices(0,i,r===t-1?e-i:s,this),i+=s;this.synchronizeInstances()}setVerticesData(t,e,s=!1,i){if(this._geometry)this._geometry.setVerticesData(t,e,s,i);else{const i=new g.x;i.set(e,t);const r=this.getScene();new _.Z(_.Z.RandomId(),r,i,s,this)}return this}removeVerticesData(t){this._geometry&&this._geometry.removeVerticesData(t)}markVerticesDataAsUpdatable(t,e=!0){const s=this.getVertexBuffer(t);s&&s.isUpdatable()!==e&&this.setVerticesData(t,this.getVerticesData(t),e)}setVerticesBuffer(t,e=!0){return this._geometry||(this._geometry=_.Z.CreateGeometryForMesh(this)),this._geometry.setVerticesBuffer(t,null,e),this}updateVerticesData(t,e,s,i){return this._geometry?(i?(this.makeGeometryUnique(),this.updateVerticesData(t,e,s,!1)):this._geometry.updateVerticesData(t,e,s),this):this}updateMeshPositions(t,e=!0){const s=this.getVerticesData(f.o.PositionKind);if(!s)return this;if(t(s),this.updateVerticesData(f.o.PositionKind,s,!1,!1),e){const t=this.getIndices(),e=this.getVerticesData(f.o.NormalKind);if(!e)return this;g.x.ComputeNormals(s,t,e),this.updateVerticesData(f.o.NormalKind,e,!1,!1)}return this}makeGeometryUnique(){if(!this._geometry)return this;if(1===this._geometry.meshes.length)return this;const t=this._geometry,e=this._geometry.copy(_.Z.RandomId());return t.releaseForMesh(this,!0),e.applyToMesh(this),this}setIndices(t,e=null,s=!1){if(this._geometry)this._geometry.setIndices(t,e,s);else{const e=new g.x;e.indices=t;const i=this.getScene();new _.Z(_.Z.RandomId(),i,e,s,this)}return this}updateIndices(t,e,s=!1){return this._geometry?(this._geometry.updateIndices(t,e,s),this):this}toLeftHanded(){return this._geometry?(this._geometry.toLeftHanded(),this):this}_bind(t,e,s){if(!this._geometry)return this;const i=this.getScene().getEngine();let r;if(this.morphTargetManager&&this.morphTargetManager.isUsingTextureForTargets&&this.morphTargetManager._bind(e),this._unIndexed)r=null;else switch(s){case x.F.PointFillMode:r=null;break;case x.F.WireFrameFillMode:r=t._getLinesIndexBuffer(this.getIndices(),i);break;default:case x.F.TriangleFillMode:r=this._geometry.getIndexBuffer()}return!this._userInstancedBuffersStorage||this.hasThinInstances?this._geometry._bind(e,r):this._geometry._bind(e,r,this._userInstancedBuffersStorage.vertexBuffers,this._userInstancedBuffersStorage.vertexArrayObjects),this}_draw(t,e,s){if(!this._geometry||!this._geometry.getVertexBuffers()||!this._unIndexed&&!this._geometry.getIndexBuffer())return this;this._internalMeshDataInfo._onBeforeDrawObservable&&this._internalMeshDataInfo._onBeforeDrawObservable.notifyObservers(this);const i=this.getScene().getEngine();return this._unIndexed||e==x.F.PointFillMode?i.drawArraysType(e,t.verticesStart,t.verticesCount,this.forcedInstanceCount||s):e==x.F.WireFrameFillMode?i.drawElementsType(e,0,t._linesIndexCount,this.forcedInstanceCount||s):i.drawElementsType(e,t.indexStart,t.indexCount,this.forcedInstanceCount||s),this}registerBeforeRender(t){return this.onBeforeRenderObservable.add(t),this}unregisterBeforeRender(t){return this.onBeforeRenderObservable.removeCallback(t),this}registerAfterRender(t){return this.onAfterRenderObservable.add(t),this}unregisterAfterRender(t){return this.onAfterRenderObservable.removeCallback(t),this}_getInstancesRenderList(t,e=!1){if(this._instanceDataStorage.isFrozen){if(e)return this._instanceDataStorage.batchCacheReplacementModeInFrozenMode.hardwareInstancedRendering[t]=!1,this._instanceDataStorage.batchCacheReplacementModeInFrozenMode.renderSelf[t]=!0,this._instanceDataStorage.batchCacheReplacementModeInFrozenMode;if(this._instanceDataStorage.previousBatch)return this._instanceDataStorage.previousBatch}const s=this.getScene(),i=s._isInIntermediateRendering(),r=i?this._internalAbstractMeshDataInfo._onlyForInstancesIntermediate:this._internalAbstractMeshDataInfo._onlyForInstances,n=this._instanceDataStorage.batchCache;if(n.mustReturn=!1,n.renderSelf[t]=e||!r&&this.isEnabled()&&this.isVisible,n.visibleInstances[t]=null,this._instanceDataStorage.visibleInstances&&!e){const e=this._instanceDataStorage.visibleInstances,r=s.getRenderId(),a=i?e.intermediateDefaultRenderId:e.defaultRenderId;n.visibleInstances[t]=e[r],!n.visibleInstances[t]&&a&&(n.visibleInstances[t]=e[a])}return n.hardwareInstancedRendering[t]=!e&&this._instanceDataStorage.hardwareInstancedRendering&&null!==n.visibleInstances[t]&&void 0!==n.visibleInstances[t],this._instanceDataStorage.previousBatch=n,n}_renderWithInstances(t,e,s,i,r){var n;const a=s.visibleInstances[t._id],o=a?a.length:0,h=this._instanceDataStorage,c=h.instancesBufferSize;let d=h.instancesBuffer,u=h.instancesPreviousBuffer;const g=16*(o+1)*4;for(;h.instancesBufferSize<g;)h.instancesBufferSize*=2;h.instancesData&&c==h.instancesBufferSize||(h.instancesData=new Float32Array(h.instancesBufferSize/4)),(this._scene.needsPreviousWorldMatrices&&!h.instancesPreviousData||c!=h.instancesBufferSize)&&(h.instancesPreviousData=new Float32Array(h.instancesBufferSize/4));let _=0,p=0;const m=s.renderSelf[t._id],x=!d||c!==h.instancesBufferSize||this._scene.needsPreviousWorldMatrices&&!h.instancesPreviousBuffer;if(this._instanceDataStorage.manualUpdate||h.isFrozen&&!x)p=(m?1:0)+o;else{const e=this.getWorldMatrix();if(m&&(this._scene.needsPreviousWorldMatrices&&(h.masterMeshPreviousWorldMatrix?(h.masterMeshPreviousWorldMatrix.copyToArray(h.instancesPreviousData,_),h.masterMeshPreviousWorldMatrix.copyFrom(e)):(h.masterMeshPreviousWorldMatrix=e.clone(),h.masterMeshPreviousWorldMatrix.copyToArray(h.instancesPreviousData,_))),e.copyToArray(h.instancesData,_),_+=16,p++),a){if(w.INSTANCEDMESH_SORT_TRANSPARENT&&this._scene.activeCamera&&(null===(n=t.getMaterial())||void 0===n?void 0:n.needAlphaBlendingForMesh(t.getRenderingMesh()))){const t=this._scene.activeCamera.globalPosition;for(let e=0;e<a.length;e++){const s=a[e];s._distanceToCamera=l.P.Distance(s.getBoundingInfo().boundingSphere.centerWorld,t)}a.sort(((t,e)=>t._distanceToCamera>e._distanceToCamera?-1:t._distanceToCamera<e._distanceToCamera?1:0))}for(let t=0;t<a.length;t++){const e=a[t],s=e.getWorldMatrix();s.copyToArray(h.instancesData,_),this._scene.needsPreviousWorldMatrices&&(e._previousWorldMatrix?(e._previousWorldMatrix.copyToArray(h.instancesPreviousData,_),e._previousWorldMatrix.copyFrom(s)):(e._previousWorldMatrix=s.clone(),e._previousWorldMatrix.copyToArray(h.instancesPreviousData,_))),_+=16,p++}}}return x?(d&&d.dispose(),u&&u.dispose(),d=new f.l(r,h.instancesData,!0,16,!1,!0),h.instancesBuffer=d,this._userInstancedBuffersStorage||(this._userInstancedBuffersStorage={data:{},vertexBuffers:{},strides:{},sizes:{},vertexArrayObjects:this.getEngine().getCaps().vertexArrayObject?{}:void 0}),this._userInstancedBuffersStorage.vertexBuffers.world0=d.createVertexBuffer("world0",0,4),this._userInstancedBuffersStorage.vertexBuffers.world1=d.createVertexBuffer("world1",4,4),this._userInstancedBuffersStorage.vertexBuffers.world2=d.createVertexBuffer("world2",8,4),this._userInstancedBuffersStorage.vertexBuffers.world3=d.createVertexBuffer("world3",12,4),this._scene.needsPreviousWorldMatrices&&(u=new f.l(r,h.instancesPreviousData,!0,16,!1,!0),h.instancesPreviousBuffer=u,this._userInstancedBuffersStorage.vertexBuffers.previousWorld0=u.createVertexBuffer("previousWorld0",0,4),this._userInstancedBuffersStorage.vertexBuffers.previousWorld1=u.createVertexBuffer("previousWorld1",4,4),this._userInstancedBuffersStorage.vertexBuffers.previousWorld2=u.createVertexBuffer("previousWorld2",8,4),this._userInstancedBuffersStorage.vertexBuffers.previousWorld3=u.createVertexBuffer("previousWorld3",12,4)),this._invalidateInstanceVertexArrayObject()):this._instanceDataStorage.isFrozen&&!this._instanceDataStorage.forceMatrixUpdates||(d.updateDirectly(h.instancesData,0,p),!this._scene.needsPreviousWorldMatrices||this._instanceDataStorage.manualUpdate&&!this._instanceDataStorage.previousManualUpdate||u.updateDirectly(h.instancesPreviousData,0,p)),this._processInstancedBuffers(a,m),this.getScene()._activeIndices.addCount(t.indexCount*p,!1),r._currentDrawContext&&(r._currentDrawContext.useInstancing=!0),this._bind(t,i,e),this._draw(t,e,p),!this._scene.needsPreviousWorldMatrices||x||!this._instanceDataStorage.manualUpdate||this._instanceDataStorage.isFrozen&&!this._instanceDataStorage.forceMatrixUpdates||this._instanceDataStorage.previousManualUpdate||u.updateDirectly(h.instancesData,0,p),r.unbindInstanceAttributes(),this}_renderWithThinInstances(t,e,s,i){var r,n;const a=null!==(n=null===(r=this._thinInstanceDataStorage)||void 0===r?void 0:r.instancesCount)&&void 0!==n?n:0;this.getScene()._activeIndices.addCount(t.indexCount*a,!1),i._currentDrawContext&&(i._currentDrawContext.useInstancing=!0),this._bind(t,s,e),this._draw(t,e,a),this._scene.needsPreviousWorldMatrices&&!this._thinInstanceDataStorage.previousMatrixData&&this._thinInstanceDataStorage.matrixData&&(this._thinInstanceDataStorage.previousMatrixBuffer?this._thinInstanceDataStorage.previousMatrixBuffer.updateDirectly(this._thinInstanceDataStorage.matrixData,0,a):this._thinInstanceDataStorage.previousMatrixBuffer=this._thinInstanceCreateMatrixBuffer("previousWorld",this._thinInstanceDataStorage.matrixData,!1)),i.unbindInstanceAttributes()}_processInstancedBuffers(t,e){}_processRendering(t,e,s,i,r,n,a,o){const h=this.getScene(),c=h.getEngine();if(n&&e.getRenderingMesh().hasThinInstances)return this._renderWithThinInstances(e,i,s,c),this;if(n)this._renderWithInstances(e,i,r,s,c);else{c._currentDrawContext&&(c._currentDrawContext.useInstancing=!1);let s=0;r.renderSelf[e._id]&&(a&&a(!1,t.getWorldMatrix(),o),s++,this._draw(e,i,this._instanceDataStorage.overridenInstanceCount));const n=r.visibleInstances[e._id];if(n){const t=n.length;s+=t;for(let s=0;s<t;s++){const t=n[s].getWorldMatrix();a&&a(!0,t,o),this._draw(e,i)}}h._activeIndices.addCount(e.indexCount*s,!1)}return this}_rebuild(t=!1){if(this._instanceDataStorage.instancesBuffer&&(t&&this._instanceDataStorage.instancesBuffer.dispose(),this._instanceDataStorage.instancesBuffer=null),this._userInstancedBuffersStorage){for(const e in this._userInstancedBuffersStorage.vertexBuffers){const s=this._userInstancedBuffersStorage.vertexBuffers[e];s&&(t&&s.dispose(),this._userInstancedBuffersStorage.vertexBuffers[e]=null)}this._userInstancedBuffersStorage.vertexArrayObjects&&(this._userInstancedBuffersStorage.vertexArrayObjects={})}this._internalMeshDataInfo._effectiveMaterial=null,super._rebuild(t)}_freeze(){if(this.subMeshes){for(let t=0;t<this.subMeshes.length;t++)this._getInstancesRenderList(t);this._internalMeshDataInfo._effectiveMaterial=null,this._instanceDataStorage.isFrozen=!0}}_unFreeze(){this._instanceDataStorage.isFrozen=!1,this._instanceDataStorage.previousBatch=null}render(t,e,s){var i,r,n;const a=this.getScene();if(this._internalAbstractMeshDataInfo._isActiveIntermediate?this._internalAbstractMeshDataInfo._isActiveIntermediate=!1:this._internalAbstractMeshDataInfo._isActive=!1,this._checkOcclusionQuery()&&!this._occlusionDataStorage.forceRenderingWhenOccluded)return this;const o=this._getInstancesRenderList(t._id,!!s);if(o.mustReturn)return this;if(!this._geometry||!this._geometry.getVertexBuffers()||!this._unIndexed&&!this._geometry.getIndexBuffer())return this;const h=a.getEngine();let l=0,d=null;this.ignoreCameraMaxZ&&a.activeCamera&&!a._isInIntermediateRendering()&&(l=a.activeCamera.maxZ,d=a.activeCamera,a.activeCamera.maxZ=0,a.updateTransformMatrix(!0)),this._internalMeshDataInfo._onBeforeRenderObservable&&this._internalMeshDataInfo._onBeforeRenderObservable.notifyObservers(this);const u=t.getRenderingMesh(),f=o.hardwareInstancedRendering[t._id]||u.hasThinInstances||!!this._userInstancedBuffersStorage&&!t.getMesh()._internalAbstractMeshDataInfo._actAsRegularMesh,g=this._instanceDataStorage,_=t.getMaterial();if(!_)return d&&(d.maxZ=l,a.updateTransformMatrix(!0)),this;if(g.isFrozen&&this._internalMeshDataInfo._effectiveMaterial&&this._internalMeshDataInfo._effectiveMaterial===_){if(_._storeEffectOnSubMeshes&&!(null===(i=t.effect)||void 0===i?void 0:i._wasPreviouslyReady)||!_._storeEffectOnSubMeshes&&!(null===(r=_.getEffect())||void 0===r?void 0:r._wasPreviouslyReady))return d&&(d.maxZ=l,a.updateTransformMatrix(!0)),this}else{if(_._storeEffectOnSubMeshes){if(!_.isReadyForSubMesh(this,t,f))return d&&(d.maxZ=l,a.updateTransformMatrix(!0)),this}else if(!_.isReady(this,f))return d&&(d.maxZ=l,a.updateTransformMatrix(!0)),this;this._internalMeshDataInfo._effectiveMaterial=_}let p;e&&h.setAlphaMode(this._internalMeshDataInfo._effectiveMaterial.alphaMode),p=this._internalMeshDataInfo._effectiveMaterial._storeEffectOnSubMeshes?t._drawWrapper:this._internalMeshDataInfo._effectiveMaterial._getDrawWrapper();const m=null!==(n=null==p?void 0:p.effect)&&void 0!==n?n:null;for(const e of a._beforeRenderingMeshStage)e.action(this,t,o,m);if(!p||!m)return d&&(d.maxZ=l,a.updateTransformMatrix(!0)),this;const I=s||this;let y;if(g.isFrozen||!this._internalMeshDataInfo._effectiveMaterial.backFaceCulling&&null===this.overrideMaterialSideOrientation)y=g.sideOrientation;else{const t=I._getWorldMatrixDeterminant();y=this.overrideMaterialSideOrientation,null==y&&(y=this._internalMeshDataInfo._effectiveMaterial.sideOrientation),t<0&&(y=y===x.F.ClockWiseSideOrientation?x.F.CounterClockWiseSideOrientation:x.F.ClockWiseSideOrientation),g.sideOrientation=y}const M=this._internalMeshDataInfo._effectiveMaterial._preBind(p,y);this._internalMeshDataInfo._effectiveMaterial.forceDepthWrite&&h.setDepthWrite(!0);const v=a.forcePointsCloud?x.F.PointFillMode:a.forceWireframe?x.F.WireFrameFillMode:this._internalMeshDataInfo._effectiveMaterial.fillMode;this._internalMeshDataInfo._onBeforeBindObservable&&this._internalMeshDataInfo._onBeforeBindObservable.notifyObservers(this),f||this._bind(t,m,v);const D=this._internalMeshDataInfo._effectiveMaterial,b=I.getWorldMatrix();D._storeEffectOnSubMeshes?D.bindForSubMesh(b,this,t):D.bind(b,this),!D.backFaceCulling&&D.separateCullingPass&&(h.setState(!0,D.zOffset,!1,!M,D.cullBackFaces,D.stencil,D.zOffsetUnits),this._processRendering(this,t,m,v,o,f,this._onBeforeDraw,this._internalMeshDataInfo._effectiveMaterial),h.setState(!0,D.zOffset,!1,M,D.cullBackFaces,D.stencil,D.zOffsetUnits),this._internalMeshDataInfo._onBetweenPassObservable&&this._internalMeshDataInfo._onBetweenPassObservable.notifyObservers(t)),this._processRendering(this,t,m,v,o,f,this._onBeforeDraw,this._internalMeshDataInfo._effectiveMaterial),this._internalMeshDataInfo._effectiveMaterial.unbind();for(const e of a._afterRenderingMeshStage)e.action(this,t,o,m);return this._internalMeshDataInfo._onAfterRenderObservable&&this._internalMeshDataInfo._onAfterRenderObservable.notifyObservers(this),d&&(d.maxZ=l,a.updateTransformMatrix(!0)),a.performancePriority!==c.a.Aggressive||g.isFrozen||this._freeze(),this}cleanMatrixWeights(){this.isVerticesDataPresent(f.o.MatricesWeightsKind)&&(this.isVerticesDataPresent(f.o.MatricesWeightsExtraKind)?this._normalizeSkinWeightsAndExtra():this._normalizeSkinFourWeights())}_normalizeSkinFourWeights(){const t=this.getVerticesData(f.o.MatricesWeightsKind),e=t.length;for(let s=0;s<e;s+=4){const e=t[s]+t[s+1]+t[s+2]+t[s+3];if(0===e)t[s]=1;else{const i=1/e;t[s]*=i,t[s+1]*=i,t[s+2]*=i,t[s+3]*=i}}this.setVerticesData(f.o.MatricesWeightsKind,t)}_normalizeSkinWeightsAndExtra(){const t=this.getVerticesData(f.o.MatricesWeightsExtraKind),e=this.getVerticesData(f.o.MatricesWeightsKind),s=e.length;for(let i=0;i<s;i+=4){let s=e[i]+e[i+1]+e[i+2]+e[i+3];if(s+=t[i]+t[i+1]+t[i+2]+t[i+3],0===s)e[i]=1;else{const r=1/s;e[i]*=r,e[i+1]*=r,e[i+2]*=r,e[i+3]*=r,t[i]*=r,t[i+1]*=r,t[i+2]*=r,t[i+3]*=r}}this.setVerticesData(f.o.MatricesWeightsKind,e),this.setVerticesData(f.o.MatricesWeightsKind,t)}validateSkinning(){const t=this.getVerticesData(f.o.MatricesWeightsExtraKind),e=this.getVerticesData(f.o.MatricesWeightsKind);if(null===e||null==this.skeleton)return{skinned:!1,valid:!0,report:"not skinned"};const s=e.length;let i=0,r=0,n=0,a=0;const o=null===t?4:8,h=new Array;for(let t=0;t<=o;t++)h[t]=0;for(let c=0;c<s;c+=4){let s=e[c],l=s,d=0===l?0:1;for(let r=1;r<o;r++){const n=r<4?e[c+r]:t[c+r-4];n>s&&i++,0!==n&&d++,l+=n,s=n}if(h[d]++,d>n&&(n=d),0===l)r++;else{const s=1/l;let i=0;for(let r=0;r<o;r++)i+=r<4?Math.abs(e[c+r]-e[c+r]*s):Math.abs(t[c+r-4]-t[c+r-4]*s);i>.001&&a++}}const c=this.skeleton.bones.length,l=this.getVerticesData(f.o.MatricesIndicesKind),d=this.getVerticesData(f.o.MatricesIndicesExtraKind);let u=0;for(let t=0;t<s;t+=4)for(let e=0;e<o;e++){const s=e<4?l[t+e]:d[t+e-4];(s>=c||s<0)&&u++}return{skinned:!0,valid:0===r&&0===a&&0===u,report:"Number of Weights = "+s/4+"\nMaximum influences = "+n+"\nMissing Weights = "+r+"\nNot Sorted = "+i+"\nNot Normalized = "+a+"\nWeightCounts = ["+h+"]\nNumber of bones = "+c+"\nBad Bone Indices = "+u}}_checkDelayState(){const t=this.getScene();return this._geometry?this._geometry.load(t):4===this.delayLoadState&&(this.delayLoadState=2,this._queueLoad(t)),this}_queueLoad(t){t.addPendingData(this);const e=-1!==this.delayLoadingFile.indexOf(".babylonbinarymeshdata");return r.w1.LoadFile(this.delayLoadingFile,(e=>{e instanceof ArrayBuffer?this._delayLoadingFunction(e,this):this._delayLoadingFunction(JSON.parse(e),this),this.instances.forEach((t=>{t.refreshBoundingInfo(),t._syncSubMeshes()})),this.delayLoadState=1,t.removePendingData(this)}),(()=>{}),t.offlineProvider,e),this}isInFrustum(t){return 2!==this.delayLoadState&&(!!super.isInFrustum(t)&&(this._checkDelayState(),!0))}setMaterialById(t){const e=this.getScene().materials;let s;for(s=e.length-1;s>-1;s--)if(e[s].id===t)return this.material=e[s],this;const i=this.getScene().multiMaterials;for(s=i.length-1;s>-1;s--)if(i[s].id===t)return this.material=i[s],this;return this}getAnimatables(){const t=new Array;return this.material&&t.push(this.material),this.skeleton&&t.push(this.skeleton),t}bakeTransformIntoVertices(t){if(!this.isVerticesDataPresent(f.o.PositionKind))return this;const e=this.subMeshes.splice(0);this._resetPointsArrayCache();let s=this.getVerticesData(f.o.PositionKind);const i=l.P.Zero();let r;for(r=0;r<s.length;r+=3)l.P.TransformCoordinatesFromFloatsToRef(s[r],s[r+1],s[r+2],t,i).toArray(s,r);if(this.setVerticesData(f.o.PositionKind,s,this.getVertexBuffer(f.o.PositionKind).isUpdatable()),this.isVerticesDataPresent(f.o.NormalKind)){for(s=this.getVerticesData(f.o.NormalKind),r=0;r<s.length;r+=3)l.P.TransformNormalFromFloatsToRef(s[r],s[r+1],s[r+2],t,i).normalize().toArray(s,r);this.setVerticesData(f.o.NormalKind,s,this.getVertexBuffer(f.o.NormalKind).isUpdatable())}return t.determinant()<0&&this.flipFaces(),this.releaseSubMeshes(),this.subMeshes=e,this}bakeCurrentTransformIntoVertices(t=!0){return this.bakeTransformIntoVertices(this.computeWorldMatrix(!0)),this.resetLocalMatrix(t),this}get _positions(){return this._internalAbstractMeshDataInfo._positions?this._internalAbstractMeshDataInfo._positions:this._geometry?this._geometry._positions:null}_resetPointsArrayCache(){return this._geometry&&this._geometry._resetPointsArrayCache(),this}_generatePointsArray(){return!!this._geometry&&this._geometry._generatePointsArray()}clone(t="",e=null,s,i=!0){return new w(t,this.getScene(),e,this,s,i)}dispose(t,e=!1){this.morphTargetManager=null,this._geometry&&this._geometry.releaseForMesh(this,!0);const s=this._internalMeshDataInfo;if(s._onBeforeDrawObservable&&s._onBeforeDrawObservable.clear(),s._onBeforeBindObservable&&s._onBeforeBindObservable.clear(),s._onBeforeRenderObservable&&s._onBeforeRenderObservable.clear(),s._onAfterRenderObservable&&s._onAfterRenderObservable.clear(),s._onBetweenPassObservable&&s._onBetweenPassObservable.clear(),this._scene.useClonedMeshMap){if(s.meshMap)for(const t in s.meshMap){const e=s.meshMap[t];e&&(e._internalMeshDataInfo._source=null,s.meshMap[t]=void 0)}s._source&&s._source._internalMeshDataInfo.meshMap&&(s._source._internalMeshDataInfo.meshMap[this.uniqueId]=void 0)}else{const t=this.getScene().meshes;for(const e of t){const t=e;t._internalMeshDataInfo&&t._internalMeshDataInfo._source&&t._internalMeshDataInfo._source===this&&(t._internalMeshDataInfo._source=null)}}s._source=null,this._disposeInstanceSpecificData(),this._disposeThinInstanceSpecificData(),this._internalMeshDataInfo._checkReadinessObserver&&this._scene.onBeforeRenderObservable.remove(this._internalMeshDataInfo._checkReadinessObserver),super.dispose(t,e)}_disposeInstanceSpecificData(){}_disposeThinInstanceSpecificData(){}_invalidateInstanceVertexArrayObject(){}applyDisplacementMap(t,e,s,i,n,a,o=!1){const h=this.getScene();return r.w1.LoadImage(t,(t=>{const r=t.width,h=t.height,c=this.getEngine().createCanvas(r,h).getContext("2d");c.drawImage(t,0,0);const l=c.getImageData(0,0,r,h).data;this.applyDisplacementMapFromBuffer(l,r,h,e,s,n,a,o),i&&i(this)}),(()=>{}),h.offlineProvider),this}applyDisplacementMapFromBuffer(t,e,s,i,r,n,a,o=!1){if(!this.isVerticesDataPresent(f.o.PositionKind)||!this.isVerticesDataPresent(f.o.NormalKind)||!this.isVerticesDataPresent(f.o.UVKind))return v.Y.Warn("Cannot call applyDisplacementMap: Given mesh is not complete. Position, Normal or UV are missing"),this;const h=this.getVerticesData(f.o.PositionKind,!0,!0),c=this.getVerticesData(f.o.NormalKind),d=this.getVerticesData(f.o.UVKind);let u=l.P.Zero();const _=l.P.Zero(),p=l.FM.Zero();n=n||l.FM.Zero(),a=a||new l.FM(1,1);for(let o=0;o<h.length;o+=3){l.P.FromArrayToRef(h,o,u),l.P.FromArrayToRef(c,o,_),l.FM.FromArrayToRef(d,o/3*2,p);const f=4*((Math.abs(p.x*a.x+n.x%1)*(e-1)%e|0)+(Math.abs(p.y*a.y+n.y%1)*(s-1)%s|0)*e),g=.3*(t[f]/255)+.59*(t[f+1]/255)+.11*(t[f+2]/255);_.normalize(),_.scaleInPlace(i+(r-i)*g),u=u.add(_),u.toArray(h,o)}return g.x.ComputeNormals(h,this.getIndices(),c),o?(this.setVerticesData(f.o.PositionKind,h),this.setVerticesData(f.o.NormalKind,c),this.setVerticesData(f.o.UVKind,d)):(this.updateVerticesData(f.o.PositionKind,h),this.updateVerticesData(f.o.NormalKind,c)),this}convertToFlatShadedMesh(){const t=this.getVerticesDataKinds(),e={},s={},i={};let r,n,a=!1;for(r=0;r<t.length;r++){n=t[r];const o=this.getVertexBuffer(n),h=o.getData();(h instanceof Array||h instanceof Float32Array)&&0===h.length||(n!==f.o.NormalKind?(e[n]=o,s[n]=this.getVerticesData(n),i[n]=[]):(a=o.isUpdatable(),t.splice(r,1),r--))}const o=this.subMeshes.slice(0),h=this.getIndices(),c=this.getTotalIndices();let d;for(d=0;d<c;d++){const a=h[d];for(r=0;r<t.length;r++){if(n=t[r],!e[n])continue;const o=e[n].getStrideSize();for(let t=0;t<o;t++)i[n].push(s[n][a*o+t])}}const u=[],g=i[f.o.PositionKind];let _;for(_=this.getScene().useRightHandedSystem?1===this.overrideMaterialSideOrientation:0===this.overrideMaterialSideOrientation,d=0;d<c;d+=3){h[d]=d,h[d+1]=d+1,h[d+2]=d+2;const t=l.P.FromArray(g,3*d),e=l.P.FromArray(g,3*(d+1)),s=l.P.FromArray(g,3*(d+2)),i=t.subtract(e),r=s.subtract(e),n=l.P.Normalize(l.P.Cross(i,r));_&&n.scaleInPlace(-1);for(let t=0;t<3;t++)u.push(n.x),u.push(n.y),u.push(n.z)}for(this.setIndices(h),this.setVerticesData(f.o.NormalKind,u,a),r=0;r<t.length;r++)n=t[r],i[n]&&this.setVerticesData(n,i[n],e[n].isUpdatable());this.releaseSubMeshes();for(let t=0;t<o.length;t++){const e=o[t];m.P.AddToMesh(e.materialIndex,e.indexStart,e.indexCount,e.indexStart,e.indexCount,this)}return this.synchronizeInstances(),this}convertToUnIndexedMesh(){const t=this.getVerticesDataKinds(),e={},s={},i={};let r,n;for(r=0;r<t.length;r++){n=t[r];const a=this.getVertexBuffer(n);e[n]=a,s[n]=e[n].getData(),i[n]=[]}const a=this.subMeshes.slice(0),o=this.getIndices(),h=this.getTotalIndices();let c;for(c=0;c<h;c++){const a=o[c];for(r=0;r<t.length;r++){n=t[r];const o=e[n].getStrideSize();for(let t=0;t<o;t++)i[n].push(s[n][a*o+t])}}for(c=0;c<h;c+=3)o[c]=c,o[c+1]=c+1,o[c+2]=c+2;for(this.setIndices(o),r=0;r<t.length;r++)n=t[r],this.setVerticesData(n,i[n],e[n].isUpdatable(),e[n].getStrideSize());this.releaseSubMeshes();for(let t=0;t<a.length;t++){const e=a[t];m.P.AddToMesh(e.materialIndex,e.indexStart,e.indexCount,e.indexStart,e.indexCount,this)}return this._unIndexed=!0,this.synchronizeInstances(),this}flipFaces(t=!1){const e=g.x.ExtractFromMesh(this);let s;if(t&&this.isVerticesDataPresent(f.o.NormalKind)&&e.normals)for(s=0;s<e.normals.length;s++)e.normals[s]*=-1;if(e.indices){let t;for(s=0;s<e.indices.length;s+=3)t=e.indices[s+1],e.indices[s+1]=e.indices[s+2],e.indices[s+2]=t}return e.applyToMesh(this,this.isVertexBufferUpdatable(f.o.PositionKind)),this}increaseVertices(t=1){const e=g.x.ExtractFromMesh(this),s=e.indices&&!Array.isArray(e.indices)&&Array.from?Array.from(e.indices):e.indices,i=e.positions&&!Array.isArray(e.positions)&&Array.from?Array.from(e.positions):e.positions,r=e.uvs&&!Array.isArray(e.uvs)&&Array.from?Array.from(e.uvs):e.uvs,n=e.normals&&!Array.isArray(e.normals)&&Array.from?Array.from(e.normals):e.normals;if(s&&i){e.indices=s,e.positions=i,r&&(e.uvs=r),n&&(e.normals=n);const a=t+1,o=new Array;for(let t=0;t<a+1;t++)o[t]=new Array;let h,c;const d=new l.P(0,0,0),u=new l.P(0,0,0),g=new l.FM(0,0),_=new Array,p=new Array,m=new Array;let x,I,y,M=i.length;r&&(I=r.length),n&&(y=n.length);for(let t=0;t<s.length;t+=3){p[0]=s[t],p[1]=s[t+1],p[2]=s[t+2];for(let t=0;t<3;t++)if(h=p[t],c=p[(t+1)%3],void 0===m[h]&&void 0===m[c]?(m[h]=new Array,m[c]=new Array):(void 0===m[h]&&(m[h]=new Array),void 0===m[c]&&(m[c]=new Array)),void 0===m[h][c]&&void 0===m[c][h]){m[h][c]=[],d.x=(i[3*c]-i[3*h])/a,d.y=(i[3*c+1]-i[3*h+1])/a,d.z=(i[3*c+2]-i[3*h+2])/a,n&&(u.x=(n[3*c]-n[3*h])/a,u.y=(n[3*c+1]-n[3*h+1])/a,u.z=(n[3*c+2]-n[3*h+2])/a),r&&(g.x=(r[2*c]-r[2*h])/a,g.y=(r[2*c+1]-r[2*h+1])/a),m[h][c].push(h);for(let t=1;t<a;t++)m[h][c].push(i.length/3),i[M++]=i[3*h]+t*d.x,i[M++]=i[3*h+1]+t*d.y,i[M++]=i[3*h+2]+t*d.z,n&&(n[y++]=n[3*h]+t*u.x,n[y++]=n[3*h+1]+t*u.y,n[y++]=n[3*h+2]+t*u.z),r&&(r[I++]=r[2*h]+t*g.x,r[I++]=r[2*h+1]+t*g.y);m[h][c].push(c),m[c][h]=new Array,x=m[h][c].length;for(let t=0;t<x;t++)m[c][h][t]=m[h][c][x-1-t]}o[0][0]=s[t],o[1][0]=m[s[t]][s[t+1]][1],o[1][1]=m[s[t]][s[t+2]][1];for(let e=2;e<a;e++){o[e][0]=m[s[t]][s[t+1]][e],o[e][e]=m[s[t]][s[t+2]][e],d.x=(i[3*o[e][e]]-i[3*o[e][0]])/e,d.y=(i[3*o[e][e]+1]-i[3*o[e][0]+1])/e,d.z=(i[3*o[e][e]+2]-i[3*o[e][0]+2])/e,n&&(u.x=(n[3*o[e][e]]-n[3*o[e][0]])/e,u.y=(n[3*o[e][e]+1]-n[3*o[e][0]+1])/e,u.z=(n[3*o[e][e]+2]-n[3*o[e][0]+2])/e),r&&(g.x=(r[2*o[e][e]]-r[2*o[e][0]])/e,g.y=(r[2*o[e][e]+1]-r[2*o[e][0]+1])/e);for(let t=1;t<e;t++)o[e][t]=i.length/3,i[M++]=i[3*o[e][0]]+t*d.x,i[M++]=i[3*o[e][0]+1]+t*d.y,i[M++]=i[3*o[e][0]+2]+t*d.z,n&&(n[y++]=n[3*o[e][0]]+t*u.x,n[y++]=n[3*o[e][0]+1]+t*u.y,n[y++]=n[3*o[e][0]+2]+t*u.z),r&&(r[I++]=r[2*o[e][0]]+t*g.x,r[I++]=r[2*o[e][0]+1]+t*g.y)}o[a]=m[s[t+1]][s[t+2]],_.push(o[0][0],o[1][0],o[1][1]);for(let t=1;t<a;t++){let e;for(e=0;e<t;e++)_.push(o[t][e],o[t+1][e],o[t+1][e+1]),_.push(o[t][e],o[t+1][e+1],o[t][e+1]);_.push(o[t][e],o[t+1][e],o[t+1][e+1])}}e.indices=_,e.applyToMesh(this,this.isVertexBufferUpdatable(f.o.PositionKind))}else v.Y.Warn("Couldn't increase number of vertices : VertexData must contain at least indices and positions")}forceSharedVertices(){const t=g.x.ExtractFromMesh(this),e=t.uvs,s=t.indices,i=t.positions,r=t.colors,n=t.matricesIndices,a=t.matricesWeights,o=t.matricesIndicesExtra,h=t.matricesWeightsExtra;if(void 0===s||void 0===i||null===s||null===i)v.Y.Warn("VertexData contains empty entries");else{const c=new Array,l=new Array,d=new Array,u=new Array,_=new Array,p=new Array,m=new Array,x=new Array;let I=new Array,y=0;const M={};let v,D;for(let t=0;t<s.length;t+=3){D=[s[t],s[t+1],s[t+2]],I=new Array;for(let t=0;t<3;t++){I[t]="";for(let e=0;e<3;e++)Math.abs(i[3*D[t]+e])<1e-8&&(i[3*D[t]+e]=0),I[t]+=i[3*D[t]+e]+"|"}if(I[0]!=I[1]&&I[0]!=I[2]&&I[1]!=I[2])for(let t=0;t<3;t++){if(v=M[I[t]],void 0===v){M[I[t]]=y,v=y++;for(let e=0;e<3;e++)c.push(i[3*D[t]+e]);if(null!=r)for(let e=0;e<4;e++)u.push(r[4*D[t]+e]);if(null!=e)for(let s=0;s<2;s++)d.push(e[2*D[t]+s]);if(null!=n)for(let e=0;e<4;e++)_.push(n[4*D[t]+e]);if(null!=a)for(let e=0;e<4;e++)p.push(a[4*D[t]+e]);if(null!=o)for(let e=0;e<4;e++)m.push(o[4*D[t]+e]);if(null!=h)for(let e=0;e<4;e++)x.push(h[4*D[t]+e])}l.push(v)}}const b=new Array;g.x.ComputeNormals(c,l,b),t.positions=c,t.indices=l,t.normals=b,null!=e&&(t.uvs=d),null!=r&&(t.colors=u),null!=n&&(t.matricesIndices=_),null!=a&&(t.matricesWeights=p),null!=o&&(t.matricesIndicesExtra=m),null!=a&&(t.matricesWeightsExtra=x),t.applyToMesh(this,this.isVertexBufferUpdatable(f.o.PositionKind))}}static _instancedMeshFactory(t,e){throw(0,b.S)("InstancedMesh")}static _PhysicsImpostorParser(t,e,s){throw(0,b.S)("PhysicsImpostor")}createInstance(t){return w._instancedMeshFactory(t,this)}synchronizeInstances(){for(let t=0;t<this.instances.length;t++){this.instances[t]._syncSubMeshes()}return this}optimizeIndices(t){const e=this.getIndices(),s=this.getVerticesData(f.o.PositionKind);if(!s||!e)return this;const i=new Array;for(let t=0;t<s.length;t+=3)i.push(l.P.FromArray(s,t));const n=new Array;return r.$g.SyncAsyncForLoop(i.length,40,(t=>{const e=i.length-1-t,s=i[e];for(let t=0;t<e;++t){const r=i[t];if(s.equals(r)){n[e]=t;break}}}),(()=>{for(let t=0;t<e.length;++t)e[t]=n[e[t]]||e[t];const s=this.subMeshes.slice(0);this.setIndices(e),this.subMeshes=s,t&&t(this)})),this}serialize(t={}){t.name=this.name,t.id=this.id,t.uniqueId=this.uniqueId,t.type=this.getClassName(),a.$&&a.$.HasTags(this)&&(t.tags=a.$.GetTags(this)),t.position=this.position.asArray(),this.rotationQuaternion?t.rotationQuaternion=this.rotationQuaternion.asArray():this.rotation&&(t.rotation=this.rotation.asArray()),t.scaling=this.scaling.asArray(),this._postMultiplyPivotMatrix?t.pivotMatrix=this.getPivotMatrix().asArray():t.localMatrix=this.getPivotMatrix().asArray(),t.isEnabled=this.isEnabled(!1),t.isVisible=this.isVisible,t.infiniteDistance=this.infiniteDistance,t.pickable=this.isPickable,t.receiveShadows=this.receiveShadows,t.billboardMode=this.billboardMode,t.visibility=this.visibility,t.checkCollisions=this.checkCollisions,t.isBlocker=this.isBlocker,t.overrideMaterialSideOrientation=this.overrideMaterialSideOrientation,this.parent&&this.parent._serializeAsParent(t),t.isUnIndexed=this.isUnIndexed;const e=this._geometry;if(e&&this.subMeshes){t.geometryUniqueId=e.uniqueId,t.geometryId=e.id,t.subMeshes=[];for(let e=0;e<this.subMeshes.length;e++){const s=this.subMeshes[e];t.subMeshes.push({materialIndex:s.materialIndex,verticesStart:s.verticesStart,verticesCount:s.verticesCount,indexStart:s.indexStart,indexCount:s.indexCount})}}if(this.material?this.material.doNotSerialize||(t.materialUniqueId=this.material.uniqueId,t.materialId=this.material.id):(this.material=null,t.materialUniqueId=this._scene.defaultMaterial.uniqueId,t.materialId=this._scene.defaultMaterial.id),this.morphTargetManager&&(t.morphTargetManagerId=this.morphTargetManager.uniqueId),this.skeleton&&(t.skeletonId=this.skeleton.id,t.numBoneInfluencers=this.numBoneInfluencers),this.getScene()._getComponent(B.l.NAME_PHYSICSENGINE)){const e=this.getPhysicsImpostor();e&&(t.physicsMass=e.getParam("mass"),t.physicsFriction=e.getParam("friction"),t.physicsRestitution=e.getParam("mass"),t.physicsImpostor=e.type)}this.metadata&&(t.metadata=this.metadata),t.instances=[];for(let e=0;e<this.instances.length;e++){const s=this.instances[e];if(s.doNotSerialize)continue;const i={name:s.name,id:s.id,isEnabled:s.isEnabled(!1),isVisible:s.isVisible,isPickable:s.isPickable,checkCollisions:s.checkCollisions,position:s.position.asArray(),scaling:s.scaling.asArray()};if(s.parent&&s.parent._serializeAsParent(i),s.rotationQuaternion?i.rotationQuaternion=s.rotationQuaternion.asArray():s.rotation&&(i.rotation=s.rotation.asArray()),this.getScene()._getComponent(B.l.NAME_PHYSICSENGINE)){const t=s.getPhysicsImpostor();t&&(i.physicsMass=t.getParam("mass"),i.physicsFriction=t.getParam("friction"),i.physicsRestitution=t.getParam("mass"),i.physicsImpostor=t.type)}s.metadata&&(i.metadata=s.metadata),s.actionManager&&(i.actions=s.actionManager.serialize(s.name)),t.instances.push(i),M.p4.AppendSerializedAnimations(s,i),i.ranges=s.serializeAnimationRanges()}if(this._thinInstanceDataStorage.instancesCount&&this._thinInstanceDataStorage.matrixData&&(t.thinInstances={instancesCount:this._thinInstanceDataStorage.instancesCount,matrixData:Array.from(this._thinInstanceDataStorage.matrixData),matrixBufferSize:this._thinInstanceDataStorage.matrixBufferSize,enablePicking:this.thinInstanceEnablePicking},this._userThinInstanceBuffersStorage)){const e={data:{},sizes:{},strides:{}};for(const t in this._userThinInstanceBuffersStorage.data)e.data[t]=Array.from(this._userThinInstanceBuffersStorage.data[t]),e.sizes[t]=this._userThinInstanceBuffersStorage.sizes[t],e.strides[t]=this._userThinInstanceBuffersStorage.strides[t];t.thinInstances.userThinInstance=e}return M.p4.AppendSerializedAnimations(this,t),t.ranges=this.serializeAnimationRanges(),t.layerMask=this.layerMask,t.alphaIndex=this.alphaIndex,t.hasVertexAlpha=this.hasVertexAlpha,t.overlayAlpha=this.overlayAlpha,t.overlayColor=this.overlayColor.asArray(),t.renderOverlay=this.renderOverlay,t.applyFog=this.applyFog,this.actionManager&&(t.actions=this.actionManager.serialize(this.name)),t}_syncGeometryWithMorphTargetManager(){if(!this.geometry)return;this._markSubMeshesAsAttributesDirty();const t=this._internalAbstractMeshDataInfo._morphTargetManager;if(t&&t.vertexCount){if(t.vertexCount!==this.getTotalVertices())return v.Y.Error("Mesh is incompatible with morph targets. Targets and mesh must all have the same vertices count."),void(this.morphTargetManager=null);if(t.isUsingTextureForTargets)return;for(let e=0;e<t.numInfluencers;e++){const s=t.getActiveTarget(e),i=s.getPositions();if(!i)return void v.Y.Error("Invalid morph target. Target must have positions.");this.geometry.setVerticesData(f.o.PositionKind+e,i,!1,3);const r=s.getNormals();r&&this.geometry.setVerticesData(f.o.NormalKind+e,r,!1,3);const n=s.getTangents();n&&this.geometry.setVerticesData(f.o.TangentKind+e,n,!1,3);const a=s.getUVs();a&&this.geometry.setVerticesData(f.o.UVKind+"_"+e,a,!1,2)}}else{let t=0;for(;this.geometry.isVerticesDataPresent(f.o.PositionKind+t);)this.geometry.removeVerticesData(f.o.PositionKind+t),this.geometry.isVerticesDataPresent(f.o.NormalKind+t)&&this.geometry.removeVerticesData(f.o.NormalKind+t),this.geometry.isVerticesDataPresent(f.o.TangentKind+t)&&this.geometry.removeVerticesData(f.o.TangentKind+t),this.geometry.isVerticesDataPresent(f.o.UVKind+t)&&this.geometry.removeVerticesData(f.o.UVKind+"_"+t),t++}}static Parse(t,e,s){let i;if(i=t.type&&"LinesMesh"===t.type?w._LinesMeshParser(t,e):t.type&&"GroundMesh"===t.type?w._GroundMeshParser(t,e):t.type&&"GoldbergMesh"===t.type?w._GoldbergMeshParser(t,e):new w(t.name,e),i.id=t.id,i._waitingParsedUniqueId=t.uniqueId,a.$&&a.$.AddTagsTo(i,t.tags),i.position=l.P.FromArray(t.position),void 0!==t.metadata&&(i.metadata=t.metadata),t.rotationQuaternion?i.rotationQuaternion=l._f.FromArray(t.rotationQuaternion):t.rotation&&(i.rotation=l.P.FromArray(t.rotation)),i.scaling=l.P.FromArray(t.scaling),t.localMatrix?i.setPreTransformMatrix(l.y3.FromArray(t.localMatrix)):t.pivotMatrix&&i.setPivotMatrix(l.y3.FromArray(t.pivotMatrix)),i.setEnabled(t.isEnabled),i.isVisible=t.isVisible,i.infiniteDistance=t.infiniteDistance,i.showBoundingBox=t.showBoundingBox,i.showSubMeshesBoundingBox=t.showSubMeshesBoundingBox,void 0!==t.applyFog&&(i.applyFog=t.applyFog),void 0!==t.pickable&&(i.isPickable=t.pickable),void 0!==t.alphaIndex&&(i.alphaIndex=t.alphaIndex),i.receiveShadows=t.receiveShadows,void 0!==t.billboardMode&&(i.billboardMode=t.billboardMode),void 0!==t.visibility&&(i.visibility=t.visibility),i.checkCollisions=t.checkCollisions,i.overrideMaterialSideOrientation=t.overrideMaterialSideOrientation,void 0!==t.isBlocker&&(i.isBlocker=t.isBlocker),i._shouldGenerateFlatShading=t.useFlatShading,t.freezeWorldMatrix&&(i._waitingData.freezeWorldMatrix=t.freezeWorldMatrix),void 0!==t.parentId&&(i._waitingParentId=t.parentId),void 0!==t.parentInstanceIndex&&(i._waitingParentInstanceIndex=t.parentInstanceIndex),void 0!==t.actions&&(i._waitingData.actions=t.actions),void 0!==t.overlayAlpha&&(i.overlayAlpha=t.overlayAlpha),void 0!==t.overlayColor&&(i.overlayColor=d.Wo.FromArray(t.overlayColor)),void 0!==t.renderOverlay&&(i.renderOverlay=t.renderOverlay),i.isUnIndexed=!!t.isUnIndexed,i.hasVertexAlpha=t.hasVertexAlpha,t.delayLoadingFile?(i.delayLoadState=4,i.delayLoadingFile=s+t.delayLoadingFile,i.buildBoundingInfo(l.P.FromArray(t.boundingBoxMinimum),l.P.FromArray(t.boundingBoxMaximum)),t._binaryInfo&&(i._binaryInfo=t._binaryInfo),i._delayInfo=[],t.hasUVs&&i._delayInfo.push(f.o.UVKind),t.hasUVs2&&i._delayInfo.push(f.o.UV2Kind),t.hasUVs3&&i._delayInfo.push(f.o.UV3Kind),t.hasUVs4&&i._delayInfo.push(f.o.UV4Kind),t.hasUVs5&&i._delayInfo.push(f.o.UV5Kind),t.hasUVs6&&i._delayInfo.push(f.o.UV6Kind),t.hasColors&&i._delayInfo.push(f.o.ColorKind),t.hasMatricesIndices&&i._delayInfo.push(f.o.MatricesIndicesKind),t.hasMatricesWeights&&i._delayInfo.push(f.o.MatricesWeightsKind),i._delayLoadingFunction=_.Z._ImportGeometry,y.Z.ForceFullSceneLoadingForIncremental&&i._checkDelayState()):_.Z._ImportGeometry(t,i),t.materialUniqueId?i._waitingMaterialId=t.materialUniqueId:t.materialId&&(i._waitingMaterialId=t.materialId),t.morphTargetManagerId>-1&&(i.morphTargetManager=e.getMorphTargetManagerById(t.morphTargetManagerId)),void 0!==t.skeletonId&&null!==t.skeletonId&&(i.skeleton=e.getLastSkeletonById(t.skeletonId),t.numBoneInfluencers&&(i.numBoneInfluencers=t.numBoneInfluencers)),t.animations){for(let e=0;e<t.animations.length;e++){const s=t.animations[e],r=(0,D.q)("BABYLON.Animation");r&&i.animations.push(r.Parse(s))}u.N.ParseAnimationRanges(i,t,e)}if(t.autoAnimate&&e.beginAnimation(i,t.autoAnimateFrom,t.autoAnimateTo,t.autoAnimateLoop,t.autoAnimateSpeed||1),t.layerMask&&!isNaN(t.layerMask)?i.layerMask=Math.abs(parseInt(t.layerMask)):i.layerMask=268435455,t.physicsImpostor&&w._PhysicsImpostorParser(e,i,t),t.lodMeshIds&&(i._waitingData.lods={ids:t.lodMeshIds,distances:t.lodDistances?t.lodDistances:null,coverages:t.lodCoverages?t.lodCoverages:null}),t.instances)for(let s=0;s<t.instances.length;s++){const r=t.instances[s],n=i.createInstance(r.name);if(r.id&&(n.id=r.id),a.$&&(r.tags?a.$.AddTagsTo(n,r.tags):a.$.AddTagsTo(n,t.tags)),n.position=l.P.FromArray(r.position),void 0!==r.metadata&&(n.metadata=r.metadata),void 0!==r.parentId&&(n._waitingParentId=r.parentId),void 0!==r.parentInstanceIndex&&(n._waitingParentInstanceIndex=r.parentInstanceIndex),void 0!==r.isEnabled&&null!==r.isEnabled&&n.setEnabled(r.isEnabled),void 0!==r.isVisible&&null!==r.isVisible&&(n.isVisible=r.isVisible),void 0!==r.isPickable&&null!==r.isPickable&&(n.isPickable=r.isPickable),r.rotationQuaternion?n.rotationQuaternion=l._f.FromArray(r.rotationQuaternion):r.rotation&&(n.rotation=l.P.FromArray(r.rotation)),n.scaling=l.P.FromArray(r.scaling),null!=r.checkCollisions&&null!=r.checkCollisions&&(n.checkCollisions=r.checkCollisions),null!=r.pickable&&null!=r.pickable&&(n.isPickable=r.pickable),null!=r.showBoundingBox&&null!=r.showBoundingBox&&(n.showBoundingBox=r.showBoundingBox),null!=r.showSubMeshesBoundingBox&&null!=r.showSubMeshesBoundingBox&&(n.showSubMeshesBoundingBox=r.showSubMeshesBoundingBox),null!=r.alphaIndex&&null!=r.showSubMeshesBoundingBox&&(n.alphaIndex=r.alphaIndex),r.physicsImpostor&&w._PhysicsImpostorParser(e,n,r),void 0!==r.actions&&(n._waitingData.actions=r.actions),r.animations){for(let t=0;t<r.animations.length;t++){const e=r.animations[t],s=(0,D.q)("BABYLON.Animation");s&&n.animations.push(s.Parse(e))}u.N.ParseAnimationRanges(n,r,e),r.autoAnimate&&e.beginAnimation(n,r.autoAnimateFrom,r.autoAnimateTo,r.autoAnimateLoop,r.autoAnimateSpeed||1)}}if(t.thinInstances){const e=t.thinInstances;if(i.thinInstanceEnablePicking=!!e.enablePicking,e.matrixData?(i.thinInstanceSetBuffer("matrix",new Float32Array(e.matrixData),16,!1),i._thinInstanceDataStorage.matrixBufferSize=e.matrixBufferSize,i._thinInstanceDataStorage.instancesCount=e.instancesCount):i._thinInstanceDataStorage.matrixBufferSize=e.matrixBufferSize,t.thinInstances.userThinInstance){const e=t.thinInstances.userThinInstance;for(const t in e.data)i.thinInstanceSetBuffer(t,new Float32Array(e.data[t]),e.strides[t],!1),i._userThinInstanceBuffersStorage.sizes[t]=e.sizes[t]}}return i}setPositionsForCPUSkinning(){const t=this._internalMeshDataInfo;if(!t._sourcePositions){const e=this.getVerticesData(f.o.PositionKind);if(!e)return t._sourcePositions;t._sourcePositions=new Float32Array(e),this.isVertexBufferUpdatable(f.o.PositionKind)||this.setVerticesData(f.o.PositionKind,e,!0)}return t._sourcePositions}setNormalsForCPUSkinning(){const t=this._internalMeshDataInfo;if(!t._sourceNormals){const e=this.getVerticesData(f.o.NormalKind);if(!e)return t._sourceNormals;t._sourceNormals=new Float32Array(e),this.isVertexBufferUpdatable(f.o.NormalKind)||this.setVerticesData(f.o.NormalKind,e,!0)}return t._sourceNormals}applySkeleton(t){if(!this.geometry)return this;if(this.geometry._softwareSkinningFrameId==this.getScene().getFrameId())return this;if(this.geometry._softwareSkinningFrameId=this.getScene().getFrameId(),!this.isVerticesDataPresent(f.o.PositionKind))return this;if(!this.isVerticesDataPresent(f.o.MatricesIndicesKind))return this;if(!this.isVerticesDataPresent(f.o.MatricesWeightsKind))return this;const e=this.isVerticesDataPresent(f.o.NormalKind),s=this._internalMeshDataInfo;if(!s._sourcePositions){const t=this.subMeshes.slice();this.setPositionsForCPUSkinning(),this.subMeshes=t}e&&!s._sourceNormals&&this.setNormalsForCPUSkinning();let i=this.getVerticesData(f.o.PositionKind);if(!i)return this;i instanceof Float32Array||(i=new Float32Array(i));let r=this.getVerticesData(f.o.NormalKind);if(e){if(!r)return this;r instanceof Float32Array||(r=new Float32Array(r))}const n=this.getVerticesData(f.o.MatricesIndicesKind),a=this.getVerticesData(f.o.MatricesWeightsKind);if(!a||!n)return this;const o=this.numBoneInfluencers>4,h=o?this.getVerticesData(f.o.MatricesIndicesExtraKind):null,c=o?this.getVerticesData(f.o.MatricesWeightsExtraKind):null,d=t.getTransformMatrices(this),u=l.P.Zero(),g=new l.y3,_=new l.y3;let p,m=0;for(let t=0;t<i.length;t+=3,m+=4){let f;for(p=0;p<4;p++)f=a[m+p],f>0&&(l.y3.FromFloat32ArrayToRefScaled(d,Math.floor(16*n[m+p]),f,_),g.addToSelf(_));if(o)for(p=0;p<4;p++)f=c[m+p],f>0&&(l.y3.FromFloat32ArrayToRefScaled(d,Math.floor(16*h[m+p]),f,_),g.addToSelf(_));l.P.TransformCoordinatesFromFloatsToRef(s._sourcePositions[t],s._sourcePositions[t+1],s._sourcePositions[t+2],g,u),u.toArray(i,t),e&&(l.P.TransformNormalFromFloatsToRef(s._sourceNormals[t],s._sourceNormals[t+1],s._sourceNormals[t+2],g,u),u.toArray(r,t)),g.reset()}return this.updateVerticesData(f.o.PositionKind,i),e&&this.updateVerticesData(f.o.NormalKind,r),this}static MinMax(t){let e=null,s=null;return t.forEach((function(t){const i=t.getBoundingInfo().boundingBox;e&&s?(e.minimizeInPlace(i.minimumWorld),s.maximizeInPlace(i.maximumWorld)):(e=i.minimumWorld,s=i.maximumWorld)})),e&&s?{min:e,max:s}:{min:l.P.Zero(),max:l.P.Zero()}}static Center(t){const e=t instanceof Array?w.MinMax(t):t;return l.P.Center(e.min,e.max)}static MergeMeshes(t,e=!0,s,i,r,n){return(0,o.s3)(w._MergeMeshesCoroutine(t,e,s,i,r,n,!1))}static MergeMeshesAsync(t,e=!0,s,i,r,n){return(0,o.sM)(w._MergeMeshesCoroutine(t,e,s,i,r,n,!0),(0,o.KO)())}static*_MergeMeshesCoroutine(t,e=!0,s,i,r,n,a){if(0===(t=t.filter(Boolean)).length)return null;let o;if(!s){let e=0;for(o=0;o<t.length;o++)if(e+=t[o].getTotalVertices(),e>=65536)return v.Y.Warn("Cannot merge meshes because resulting mesh will have more than 65536 vertices. Please use allow32BitsIndices = true to use 32 bits indices"),null}n&&(r=!1);const h=new Array,c=new Array,l=new Array,d=t[0].overrideMaterialSideOrientation;for(o=0;o<t.length;o++){const e=t[o];if(e.isAnInstance)return v.Y.Warn("Cannot merge instance meshes."),null;if(d!==e.overrideMaterialSideOrientation)return v.Y.Warn("Cannot merge meshes with different overrideMaterialSideOrientation values."),null;if(r&&l.push(e.getTotalIndices()),n)if(e.material){const t=e.material;if(t instanceof I.G){for(let e=0;e<t.subMaterials.length;e++)h.indexOf(t.subMaterials[e])<0&&h.push(t.subMaterials[e]);for(let s=0;s<e.subMeshes.length;s++)c.push(h.indexOf(t.subMaterials[e.subMeshes[s].materialIndex])),l.push(e.subMeshes[s].indexCount)}else{h.indexOf(t)<0&&h.push(t);for(let s=0;s<e.subMeshes.length;s++)c.push(h.indexOf(t)),l.push(e.subMeshes[s].indexCount)}}else for(let t=0;t<e.subMeshes.length;t++)c.push(0),l.push(e.subMeshes[t].indexCount)}const u=t[0],f=t=>{const e=t.computeWorldMatrix(!0);return[g.x.ExtractFromMesh(t,!1,!1),e]},[_,p]=f(u);a&&(yield);const x=new Array(t.length-1);for(let e=1;e<t.length;e++)x[e-1]=f(t[e]),a&&(yield);const y=_._mergeCoroutine(p,x,s,a,!e);let M=y.next();for(;!M.done;)a&&(yield),M=y.next();const D=M.value;i||(i=new w(u.name+"_merged",u.getScene()));const b=D._applyToCoroutine(i,void 0,a);let B=b.next();for(;!B.done;)a&&(yield),B=b.next();if(i.checkCollisions=u.checkCollisions,i.overrideMaterialSideOrientation=u.overrideMaterialSideOrientation,e)for(o=0;o<t.length;o++)t[o].dispose();if(r||n){i.releaseSubMeshes(),o=0;let t=0;for(;o<l.length;)m.P.CreateFromIndices(0,t,l[o],i,void 0,!1),t+=l[o],o++;for(const t of i.subMeshes)t.refreshBoundingInfo();i.computeWorldMatrix(!0)}if(n){const t=new I.G(u.name+"_merged",u.getScene());t.subMaterials=h;for(let t=0;t<i.subMeshes.length;t++)i.subMeshes[t].materialIndex=c[t];i.material=t}else i.material=u.material;return i}addInstance(t){t._indexInSourceMeshInstanceArray=this.instances.length,this.instances.push(t)}removeInstance(t){const e=t._indexInSourceMeshInstanceArray;if(-1!=e){if(e!==this.instances.length-1){const t=this.instances[this.instances.length-1];this.instances[e]=t,t._indexInSourceMeshInstanceArray=e}t._indexInSourceMeshInstanceArray=-1,this.instances.pop()}}_shouldConvertRHS(){return this.overrideMaterialSideOrientation===x.F.CounterClockWiseSideOrientation}}w.FRONTSIDE=g.x.FRONTSIDE,w.BACKSIDE=g.x.BACKSIDE,w.DOUBLESIDE=g.x.DOUBLESIDE,w.DEFAULTSIDE=g.x.DEFAULTSIDE,w.NO_CAP=0,w.CAP_START=1,w.CAP_END=2,w.CAP_ALL=3,w.NO_FLIP=0,w.FLIP_TILE=1,w.ROTATE_TILE=2,w.FLIP_ROW=3,w.ROTATE_ROW=4,w.FLIP_N_ROTATE_TILE=5,w.FLIP_N_ROTATE_ROW=6,w.CENTER=0,w.LEFT=1,w.RIGHT=2,w.TOP=3,w.BOTTOM=4,w.INSTANCEDMESH_SORT_TRANSPARENT=!1,w._GroundMeshParser=(t,e)=>{throw(0,b.S)("GroundMesh")},w._GoldbergMeshParser=(t,e)=>{throw(0,b.S)("GoldbergMesh")},w._LinesMeshParser=(t,e)=>{throw(0,b.S)("LinesMesh")},(0,D.H)("BABYLON.Mesh",w),w.prototype.setMaterialByID=function(t){return this.setMaterialById(t)},w.CreateDisc=w.CreateDisc||(()=>{throw new Error("Import MeshBuilder to populate this function")}),w.CreateBox=w.CreateBox||(()=>{throw new Error("Import MeshBuilder to populate this function")}),w.CreateSphere=w.CreateSphere||(()=>{throw new Error("Import MeshBuilder to populate this function")}),w.CreateCylinder=w.CreateCylinder||(()=>{throw new Error("Import MeshBuilder to populate this function")}),w.CreateTorusKnot=w.CreateTorusKnot||(()=>{throw new Error("Import MeshBuilder to populate this function")}),w.CreateTorus=w.CreateTorus||(()=>{throw new Error("Import MeshBuilder to populate this function")}),w.CreatePlane=w.CreatePlane||(()=>{throw new Error("Import MeshBuilder to populate this function")}),w.CreateGround=w.CreateGround||(()=>{throw new Error("Import MeshBuilder to populate this function")}),w.CreateTiledGround=w.CreateTiledGround||(()=>{throw new Error("Import MeshBuilder to populate this function")}),w.CreateGroundFromHeightMap=w.CreateGroundFromHeightMap||(()=>{throw new Error("Import MeshBuilder to populate this function")}),w.CreateTube=w.CreateTube||(()=>{throw new Error("Import MeshBuilder to populate this function")}),w.CreatePolyhedron=w.CreatePolyhedron||(()=>{throw new Error("Import MeshBuilder to populate this function")}),w.CreateIcoSphere=w.CreateIcoSphere||(()=>{throw new Error("Import MeshBuilder to populate this function")}),w.CreateDecal=w.CreateDecal||(()=>{throw new Error("Import MeshBuilder to populate this function")}),w.CreateCapsule=w.CreateCapsule||(()=>{throw new Error("Import MeshBuilder to populate this function")}),w.ExtendToGoldberg=w.ExtendToGoldberg||(()=>{throw new Error("Import MeshBuilder to populate this function")})},89209:(t,e,s)=>{s.d(e,{x:()=>u});var i=s(72433),r=s(58095),n=s(72208),a=s(77851),o=s(15631),h=s(84318),c=s(96969),l=s(24539),d=s(46223);class u{constructor(){this._applyTo=(0,l.vp)(this._applyToCoroutine.bind(this))}set(t,e){switch(t.length||h.Y.Warn(`Setting vertex data kind '${e}' with an empty array`),e){case n.o.PositionKind:this.positions=t;break;case n.o.NormalKind:this.normals=t;break;case n.o.TangentKind:this.tangents=t;break;case n.o.UVKind:this.uvs=t;break;case n.o.UV2Kind:this.uvs2=t;break;case n.o.UV3Kind:this.uvs3=t;break;case n.o.UV4Kind:this.uvs4=t;break;case n.o.UV5Kind:this.uvs5=t;break;case n.o.UV6Kind:this.uvs6=t;break;case n.o.ColorKind:this.colors=t;break;case n.o.MatricesIndicesKind:this.matricesIndices=t;break;case n.o.MatricesWeightsKind:this.matricesWeights=t;break;case n.o.MatricesIndicesExtraKind:this.matricesIndicesExtra=t;break;case n.o.MatricesWeightsExtraKind:this.matricesWeightsExtra=t}}applyToMesh(t,e){return this._applyTo(t,e,!1),this}applyToGeometry(t,e){return this._applyTo(t,e,!1),this}updateMesh(t){return this._update(t),this}updateGeometry(t){return this._update(t),this}*_applyToCoroutine(t,e=!1,s){return this.positions&&(t.setVerticesData(n.o.PositionKind,this.positions,e),s&&(yield)),this.normals&&(t.setVerticesData(n.o.NormalKind,this.normals,e),s&&(yield)),this.tangents&&(t.setVerticesData(n.o.TangentKind,this.tangents,e),s&&(yield)),this.uvs&&(t.setVerticesData(n.o.UVKind,this.uvs,e),s&&(yield)),this.uvs2&&(t.setVerticesData(n.o.UV2Kind,this.uvs2,e),s&&(yield)),this.uvs3&&(t.setVerticesData(n.o.UV3Kind,this.uvs3,e),s&&(yield)),this.uvs4&&(t.setVerticesData(n.o.UV4Kind,this.uvs4,e),s&&(yield)),this.uvs5&&(t.setVerticesData(n.o.UV5Kind,this.uvs5,e),s&&(yield)),this.uvs6&&(t.setVerticesData(n.o.UV6Kind,this.uvs6,e),s&&(yield)),this.colors&&(t.setVerticesData(n.o.ColorKind,this.colors,e),s&&(yield)),this.matricesIndices&&(t.setVerticesData(n.o.MatricesIndicesKind,this.matricesIndices,e),s&&(yield)),this.matricesWeights&&(t.setVerticesData(n.o.MatricesWeightsKind,this.matricesWeights,e),s&&(yield)),this.matricesIndicesExtra&&(t.setVerticesData(n.o.MatricesIndicesExtraKind,this.matricesIndicesExtra,e),s&&(yield)),this.matricesWeightsExtra&&(t.setVerticesData(n.o.MatricesWeightsExtraKind,this.matricesWeightsExtra,e),s&&(yield)),this.indices?(t.setIndices(this.indices,null,e),s&&(yield)):t.setIndices([],null),this}_update(t,e,s){return this.positions&&t.updateVerticesData(n.o.PositionKind,this.positions,e,s),this.normals&&t.updateVerticesData(n.o.NormalKind,this.normals,e,s),this.tangents&&t.updateVerticesData(n.o.TangentKind,this.tangents,e,s),this.uvs&&t.updateVerticesData(n.o.UVKind,this.uvs,e,s),this.uvs2&&t.updateVerticesData(n.o.UV2Kind,this.uvs2,e,s),this.uvs3&&t.updateVerticesData(n.o.UV3Kind,this.uvs3,e,s),this.uvs4&&t.updateVerticesData(n.o.UV4Kind,this.uvs4,e,s),this.uvs5&&t.updateVerticesData(n.o.UV5Kind,this.uvs5,e,s),this.uvs6&&t.updateVerticesData(n.o.UV6Kind,this.uvs6,e,s),this.colors&&t.updateVerticesData(n.o.ColorKind,this.colors,e,s),this.matricesIndices&&t.updateVerticesData(n.o.MatricesIndicesKind,this.matricesIndices,e,s),this.matricesWeights&&t.updateVerticesData(n.o.MatricesWeightsKind,this.matricesWeights,e,s),this.matricesIndicesExtra&&t.updateVerticesData(n.o.MatricesIndicesExtraKind,this.matricesIndicesExtra,e,s),this.matricesWeightsExtra&&t.updateVerticesData(n.o.MatricesWeightsExtraKind,this.matricesWeightsExtra,e,s),this.indices&&t.setIndices(this.indices,null),this}static _TransformVector3Coordinates(t,e,s=0,i=t.length){const n=r.jp.Vector3[0],a=r.jp.Vector3[1];for(let o=s;o<s+i;o+=3)r.P.FromArrayToRef(t,o,n),r.P.TransformCoordinatesToRef(n,e,a),t[o]=a.x,t[o+1]=a.y,t[o+2]=a.z}static _TransformVector3Normals(t,e,s=0,i=t.length){const n=r.jp.Vector3[0],a=r.jp.Vector3[1];for(let o=s;o<s+i;o+=3)r.P.FromArrayToRef(t,o,n),r.P.TransformNormalToRef(n,e,a),t[o]=a.x,t[o+1]=a.y,t[o+2]=a.z}static _TransformVector4Normals(t,e,s=0,i=t.length){const n=r.jp.Vector4[0],a=r.jp.Vector4[1];for(let o=s;o<s+i;o+=4)r.Lt.FromArrayToRef(t,o,n),r.Lt.TransformNormalToRef(n,e,a),t[o]=a.x,t[o+1]=a.y,t[o+2]=a.z,t[o+3]=a.w}static _FlipFaces(t,e=0,s=t.length){for(let i=e;i<e+s;i+=3){const e=t[i+1];t[i+1]=t[i+2],t[i+2]=e}}transform(t){const e=t.determinant()<0;return this.positions&&u._TransformVector3Coordinates(this.positions,t),this.normals&&u._TransformVector3Normals(this.normals,t),this.tangents&&u._TransformVector4Normals(this.tangents,t),e&&this.indices&&u._FlipFaces(this.indices),this}merge(t,e=!1,s=!1){const i=Array.isArray(t)?t.map((t=>[t,void 0])):[[t,void 0]];return(0,l.s3)(this._mergeCoroutine(void 0,i,e,!1,s))}*_mergeCoroutine(t,e,s=!1,i,r){var a,o,h,c;this._validate();const l=e.map((t=>t[0]));for(const t of l)if(t._validate(),!this.normals!=!t.normals||!this.tangents!=!t.tangents||!this.uvs!=!t.uvs||!this.uvs2!=!t.uvs2||!this.uvs3!=!t.uvs3||!this.uvs4!=!t.uvs4||!this.uvs5!=!t.uvs5||!this.uvs6!=!t.uvs6||!this.colors!=!t.colors||!this.matricesIndices!=!t.matricesIndices||!this.matricesWeights!=!t.matricesWeights||!this.matricesIndicesExtra!=!t.matricesIndicesExtra||!this.matricesWeightsExtra!=!t.matricesWeightsExtra)throw new Error("Cannot merge vertex data that do not have the same set of attributes");const d=l.reduce(((t,e)=>{var s,i;return t+(null!==(i=null===(s=e.indices)||void 0===s?void 0:s.length)&&void 0!==i?i:0)}),null!==(o=null===(a=this.indices)||void 0===a?void 0:a.length)&&void 0!==o?o:0);let f=r||l.some((t=>t.indices===this.indices))?null===(h=this.indices)||void 0===h?void 0:h.slice():this.indices;if(d>0){let r=null!==(c=null==f?void 0:f.length)&&void 0!==c?c:0;if(f||(f=new Array(d)),f.length!==d){if(Array.isArray(f))f.length=d;else{const t=s||f instanceof Uint32Array?new Uint32Array(d):new Uint16Array(d);t.set(f),f=t}t&&t.determinant()<0&&u._FlipFaces(f,0,r)}let n=this.positions?this.positions.length/3:0;for(const[t,s]of e)if(t.indices){for(let e=0;e<t.indices.length;e++)f[r+e]=t.indices[e]+n;s&&s.determinant()<0&&u._FlipFaces(f,r,t.indices.length),n+=t.positions.length/3,r+=t.indices.length,i&&(yield)}}return this.indices=f,this.positions=u._MergeElement(n.o.PositionKind,this.positions,t,e.map((t=>[t[0].positions,t[1]]))),i&&(yield),this.normals=u._MergeElement(n.o.NormalKind,this.normals,t,e.map((t=>[t[0].normals,t[1]]))),i&&(yield),this.tangents=u._MergeElement(n.o.TangentKind,this.tangents,t,e.map((t=>[t[0].tangents,t[1]]))),i&&(yield),this.uvs=u._MergeElement(n.o.UVKind,this.uvs,t,e.map((t=>[t[0].uvs,t[1]]))),i&&(yield),this.uvs2=u._MergeElement(n.o.UV2Kind,this.uvs2,t,e.map((t=>[t[0].uvs2,t[1]]))),i&&(yield),this.uvs3=u._MergeElement(n.o.UV3Kind,this.uvs3,t,e.map((t=>[t[0].uvs3,t[1]]))),i&&(yield),this.uvs4=u._MergeElement(n.o.UV4Kind,this.uvs4,t,e.map((t=>[t[0].uvs4,t[1]]))),i&&(yield),this.uvs5=u._MergeElement(n.o.UV5Kind,this.uvs5,t,e.map((t=>[t[0].uvs5,t[1]]))),i&&(yield),this.uvs6=u._MergeElement(n.o.UV6Kind,this.uvs6,t,e.map((t=>[t[0].uvs6,t[1]]))),i&&(yield),this.colors=u._MergeElement(n.o.ColorKind,this.colors,t,e.map((t=>[t[0].colors,t[1]]))),i&&(yield),this.matricesIndices=u._MergeElement(n.o.MatricesIndicesKind,this.matricesIndices,t,e.map((t=>[t[0].matricesIndices,t[1]]))),i&&(yield),this.matricesWeights=u._MergeElement(n.o.MatricesWeightsKind,this.matricesWeights,t,e.map((t=>[t[0].matricesWeights,t[1]]))),i&&(yield),this.matricesIndicesExtra=u._MergeElement(n.o.MatricesIndicesExtraKind,this.matricesIndicesExtra,t,e.map((t=>[t[0].matricesIndicesExtra,t[1]]))),i&&(yield),this.matricesWeightsExtra=u._MergeElement(n.o.MatricesWeightsExtraKind,this.matricesWeightsExtra,t,e.map((t=>[t[0].matricesWeightsExtra,t[1]]))),this}static _MergeElement(t,e,s,i){const r=i.filter((t=>null!==t[0]&&void 0!==t[0]));if(!e&&0==r.length)return e;if(!e)return this._MergeElement(t,r[0][0],r[0][1],r.slice(1));const a=r.reduce(((t,e)=>t+e[0].length),e.length),o=t===n.o.PositionKind?u._TransformVector3Coordinates:t===n.o.NormalKind?u._TransformVector3Normals:t===n.o.TangentKind?u._TransformVector4Normals:()=>{};if(e instanceof Float32Array){const t=new Float32Array(a);t.set(e),s&&o(t,s,0,e.length);let i=e.length;for(const[e,s]of r)t.set(e,i),s&&o(t,s,i,e.length),i+=e.length;return t}{const t=new Array(a);for(let s=0;s<e.length;s++)t[s]=e[s];s&&o(t,s,0,e.length);let i=e.length;for(const[e,s]of r){for(let s=0;s<e.length;s++)t[i+s]=e[s];s&&o(t,s,i,e.length),i+=e.length}return t}}_validate(){if(!this.positions)throw new d.LH("Positions are required",d.SM.MeshInvalidPositionsError);const t=(t,e)=>{const s=n.o.DeduceStride(t);if(e.length%s!=0)throw new Error("The "+t+"s array count must be a multiple of "+s);return e.length/s},e=t(n.o.PositionKind,this.positions),s=(s,i)=>{const r=t(s,i);if(r!==e)throw new Error("The "+s+"s element count ("+r+") does not match the positions count ("+e+")")};this.normals&&s(n.o.NormalKind,this.normals),this.tangents&&s(n.o.TangentKind,this.tangents),this.uvs&&s(n.o.UVKind,this.uvs),this.uvs2&&s(n.o.UV2Kind,this.uvs2),this.uvs3&&s(n.o.UV3Kind,this.uvs3),this.uvs4&&s(n.o.UV4Kind,this.uvs4),this.uvs5&&s(n.o.UV5Kind,this.uvs5),this.uvs6&&s(n.o.UV6Kind,this.uvs6),this.colors&&s(n.o.ColorKind,this.colors),this.matricesIndices&&s(n.o.MatricesIndicesKind,this.matricesIndices),this.matricesWeights&&s(n.o.MatricesWeightsKind,this.matricesWeights),this.matricesIndicesExtra&&s(n.o.MatricesIndicesExtraKind,this.matricesIndicesExtra),this.matricesWeightsExtra&&s(n.o.MatricesWeightsExtraKind,this.matricesWeightsExtra)}serialize(){const t={};return this.positions&&(t.positions=this.positions),this.normals&&(t.normals=this.normals),this.tangents&&(t.tangents=this.tangents),this.uvs&&(t.uvs=this.uvs),this.uvs2&&(t.uvs2=this.uvs2),this.uvs3&&(t.uvs3=this.uvs3),this.uvs4&&(t.uvs4=this.uvs4),this.uvs5&&(t.uvs5=this.uvs5),this.uvs6&&(t.uvs6=this.uvs6),this.colors&&(t.colors=this.colors),this.matricesIndices&&(t.matricesIndices=this.matricesIndices,t.matricesIndices._isExpanded=!0),this.matricesWeights&&(t.matricesWeights=this.matricesWeights),this.matricesIndicesExtra&&(t.matricesIndicesExtra=this.matricesIndicesExtra,t.matricesIndicesExtra._isExpanded=!0),this.matricesWeightsExtra&&(t.matricesWeightsExtra=this.matricesWeightsExtra),t.indices=this.indices,t}static ExtractFromMesh(t,e,s){return u._ExtractFrom(t,e,s)}static ExtractFromGeometry(t,e,s){return u._ExtractFrom(t,e,s)}static _ExtractFrom(t,e,s){const i=new u;return t.isVerticesDataPresent(n.o.PositionKind)&&(i.positions=t.getVerticesData(n.o.PositionKind,e,s)),t.isVerticesDataPresent(n.o.NormalKind)&&(i.normals=t.getVerticesData(n.o.NormalKind,e,s)),t.isVerticesDataPresent(n.o.TangentKind)&&(i.tangents=t.getVerticesData(n.o.TangentKind,e,s)),t.isVerticesDataPresent(n.o.UVKind)&&(i.uvs=t.getVerticesData(n.o.UVKind,e,s)),t.isVerticesDataPresent(n.o.UV2Kind)&&(i.uvs2=t.getVerticesData(n.o.UV2Kind,e,s)),t.isVerticesDataPresent(n.o.UV3Kind)&&(i.uvs3=t.getVerticesData(n.o.UV3Kind,e,s)),t.isVerticesDataPresent(n.o.UV4Kind)&&(i.uvs4=t.getVerticesData(n.o.UV4Kind,e,s)),t.isVerticesDataPresent(n.o.UV5Kind)&&(i.uvs5=t.getVerticesData(n.o.UV5Kind,e,s)),t.isVerticesDataPresent(n.o.UV6Kind)&&(i.uvs6=t.getVerticesData(n.o.UV6Kind,e,s)),t.isVerticesDataPresent(n.o.ColorKind)&&(i.colors=t.getVerticesData(n.o.ColorKind,e,s)),t.isVerticesDataPresent(n.o.MatricesIndicesKind)&&(i.matricesIndices=t.getVerticesData(n.o.MatricesIndicesKind,e,s)),t.isVerticesDataPresent(n.o.MatricesWeightsKind)&&(i.matricesWeights=t.getVerticesData(n.o.MatricesWeightsKind,e,s)),t.isVerticesDataPresent(n.o.MatricesIndicesExtraKind)&&(i.matricesIndicesExtra=t.getVerticesData(n.o.MatricesIndicesExtraKind,e,s)),t.isVerticesDataPresent(n.o.MatricesWeightsExtraKind)&&(i.matricesWeightsExtra=t.getVerticesData(n.o.MatricesWeightsExtraKind,e,s)),i.indices=t.getIndices(e,s),i}static CreateRibbon(t){throw(0,a.S)("ribbonBuilder")}static CreateBox(t){throw(0,a.S)("boxBuilder")}static CreateTiledBox(t){throw(0,a.S)("tiledBoxBuilder")}static CreateTiledPlane(t){throw(0,a.S)("tiledPlaneBuilder")}static CreateSphere(t){throw(0,a.S)("sphereBuilder")}static CreateCylinder(t){throw(0,a.S)("cylinderBuilder")}static CreateTorus(t){throw(0,a.S)("torusBuilder")}static CreateLineSystem(t){throw(0,a.S)("linesBuilder")}static CreateDashedLines(t){throw(0,a.S)("linesBuilder")}static CreateGround(t){throw(0,a.S)("groundBuilder")}static CreateTiledGround(t){throw(0,a.S)("groundBuilder")}static CreateGroundFromHeightMap(t){throw(0,a.S)("groundBuilder")}static CreatePlane(t){throw(0,a.S)("planeBuilder")}static CreateDisc(t){throw(0,a.S)("discBuilder")}static CreatePolygon(t,e,s,i,r,n,o){throw(0,a.S)("polygonBuilder")}static CreateIcoSphere(t){throw(0,a.S)("icoSphereBuilder")}static CreatePolyhedron(t){throw(0,a.S)("polyhedronBuilder")}static CreateCapsule(t={orientation:r.P.Up(),subdivisions:2,tessellation:16,height:1,radius:.25,capSubdivisions:6}){throw(0,a.S)("capsuleBuilder")}static CreateTorusKnot(t){throw(0,a.S)("torusKnotBuilder")}static ComputeNormals(t,e,s,i){let n=0,a=0,o=0,h=0,c=0,l=0,d=0,u=0,f=0,g=0,_=0,p=0,m=0,x=0,I=0,y=0,M=0,v=0,D=0,b=0,B=!1,A=!1,S=!1,V=!1,P=1,T=0,C=null;i&&(B=!!i.facetNormals,A=!!i.facetPositions,S=!!i.facetPartitioning,P=!0===i.useRightHandedSystem?-1:1,T=i.ratio||0,V=!!i.depthSort,C=i.distanceTo,V&&void 0===C&&(C=r.P.Zero()));let w=0,O=0,F=0,R=0;for(S&&i&&i.bbSize&&(w=i.subDiv.X*T/i.bbSize.x,O=i.subDiv.Y*T/i.bbSize.y,F=i.subDiv.Z*T/i.bbSize.z,R=i.subDiv.max*i.subDiv.max,i.facetPartitioning.length=0),n=0;n<t.length;n++)s[n]=0;const E=e.length/3|0;for(n=0;n<E;n++){if(p=3*e[3*n],m=p+1,x=p+2,I=3*e[3*n+1],y=I+1,M=I+2,v=3*e[3*n+2],D=v+1,b=v+2,a=t[p]-t[I],o=t[m]-t[y],h=t[x]-t[M],c=t[v]-t[I],l=t[D]-t[y],d=t[b]-t[M],u=P*(o*d-h*l),f=P*(h*c-a*d),g=P*(a*l-o*c),_=Math.sqrt(u*u+f*f+g*g),_=0===_?1:_,u/=_,f/=_,g/=_,B&&i&&(i.facetNormals[n].x=u,i.facetNormals[n].y=f,i.facetNormals[n].z=g),A&&i&&(i.facetPositions[n].x=(t[p]+t[I]+t[v])/3,i.facetPositions[n].y=(t[m]+t[y]+t[D])/3,i.facetPositions[n].z=(t[x]+t[M]+t[b])/3),S&&i){const e=Math.floor((i.facetPositions[n].x-i.bInfo.minimum.x*T)*w),s=Math.floor((i.facetPositions[n].y-i.bInfo.minimum.y*T)*O),r=Math.floor((i.facetPositions[n].z-i.bInfo.minimum.z*T)*F),a=Math.floor((t[p]-i.bInfo.minimum.x*T)*w),o=Math.floor((t[m]-i.bInfo.minimum.y*T)*O),h=Math.floor((t[x]-i.bInfo.minimum.z*T)*F),c=Math.floor((t[I]-i.bInfo.minimum.x*T)*w),l=Math.floor((t[y]-i.bInfo.minimum.y*T)*O),d=Math.floor((t[M]-i.bInfo.minimum.z*T)*F),u=Math.floor((t[v]-i.bInfo.minimum.x*T)*w),f=Math.floor((t[D]-i.bInfo.minimum.y*T)*O),g=Math.floor((t[b]-i.bInfo.minimum.z*T)*F),_=a+i.subDiv.max*o+R*h,B=c+i.subDiv.max*l+R*d,A=u+i.subDiv.max*f+R*g,S=e+i.subDiv.max*s+R*r;i.facetPartitioning[S]=i.facetPartitioning[S]?i.facetPartitioning[S]:new Array,i.facetPartitioning[_]=i.facetPartitioning[_]?i.facetPartitioning[_]:new Array,i.facetPartitioning[B]=i.facetPartitioning[B]?i.facetPartitioning[B]:new Array,i.facetPartitioning[A]=i.facetPartitioning[A]?i.facetPartitioning[A]:new Array,i.facetPartitioning[_].push(n),B!=_&&i.facetPartitioning[B].push(n),A!=B&&A!=_&&i.facetPartitioning[A].push(n),S!=_&&S!=B&&S!=A&&i.facetPartitioning[S].push(n)}if(V&&i&&i.facetPositions){const t=i.depthSortedFacets[n];t.ind=3*n,t.sqDistance=r.P.DistanceSquared(i.facetPositions[n],C)}s[p]+=u,s[m]+=f,s[x]+=g,s[I]+=u,s[y]+=f,s[M]+=g,s[v]+=u,s[D]+=f,s[b]+=g}for(n=0;n<s.length/3;n++)u=s[3*n],f=s[3*n+1],g=s[3*n+2],_=Math.sqrt(u*u+f*f+g*g),_=0===_?1:_,u/=_,f/=_,g/=_,s[3*n]=u,s[3*n+1]=f,s[3*n+2]=g}static _ComputeSides(t,e,s,i,n,a,o){const h=s.length,c=i.length;let l,d;switch(t=t||u.DEFAULTSIDE){case u.FRONTSIDE:break;case u.BACKSIDE:for(l=0;l<h;l+=3){const t=s[l];s[l]=s[l+2],s[l+2]=t}for(d=0;d<c;d++)i[d]=-i[d];break;case u.DOUBLESIDE:{const t=e.length,u=t/3;for(let s=0;s<t;s++)e[t+s]=e[s];for(l=0;l<h;l+=3)s[l+h]=s[l+2]+u,s[l+1+h]=s[l+1]+u,s[l+2+h]=s[l]+u;for(d=0;d<c;d++)i[c+d]=-i[d];const f=n.length;let g=0;for(g=0;g<f;g++)n[g+f]=n[g];for(a=a||new r.Lt(0,0,1,1),o=o||new r.Lt(0,0,1,1),g=0,l=0;l<f/2;l++)n[g]=a.x+(a.z-a.x)*n[g],n[g+1]=a.y+(a.w-a.y)*n[g+1],n[g+f]=o.x+(o.z-o.x)*n[g+f],n[g+f+1]=o.y+(o.w-o.y)*n[g+f+1],g+=2;break}}}static ImportVertexData(t,e){const s=new u,i=t.positions;i&&s.set(i,n.o.PositionKind);const r=t.normals;r&&s.set(r,n.o.NormalKind);const a=t.tangents;a&&s.set(a,n.o.TangentKind);const h=t.uvs;h&&s.set(h,n.o.UVKind);const c=t.uv2s;c&&s.set(c,n.o.UV2Kind);const l=t.uv3s;l&&s.set(l,n.o.UV3Kind);const d=t.uv4s;d&&s.set(d,n.o.UV4Kind);const f=t.uv5s;f&&s.set(f,n.o.UV5Kind);const g=t.uv6s;g&&s.set(g,n.o.UV6Kind);const _=t.colors;_&&s.set(o.HE.CheckColors4(_,i.length/3),n.o.ColorKind);const p=t.matricesIndices;p&&s.set(p,n.o.MatricesIndicesKind);const m=t.matricesWeights;m&&s.set(m,n.o.MatricesWeightsKind);const x=t.indices;x&&(s.indices=x),e.setAllVerticesData(s,t.updatable)}}u.FRONTSIDE=0,u.BACKSIDE=1,u.DOUBLESIDE=2,u.DEFAULTSIDE=0,(0,i.gn)([c.G6.filter(((...[t])=>!Array.isArray(t)))],u,"_TransformVector3Coordinates",null),(0,i.gn)([c.G6.filter(((...[t])=>!Array.isArray(t)))],u,"_TransformVector3Normals",null),(0,i.gn)([c.G6.filter(((...[t])=>!Array.isArray(t)))],u,"_TransformVector4Normals",null),(0,i.gn)([c.G6.filter(((...[t])=>!Array.isArray(t)))],u,"_FlipFaces",null)},85737:(t,e,s)=>{s.d(e,{V:()=>B});var i=s(48236),r=s(42620),n=s(8451),a=s(10149),o=s(48087),h=s(62845),c=s(49353),l=s(93471),d=s(9866),u=s(52590),f=s(75159),g=s(89202),_=s(46719),p=s(89234),m=s(41525),x=s(42387),I=s(57891),y=s(75298),M=s(96907),v=s(6588),D=s(76926),b=s(21784);const B={CreateBox:n.NR,CreateTiledBox:a.cQ,CreateSphere:o.Qk,CreateDisc:r.uH,CreateIcoSphere:y.Au,CreateRibbon:i.LY,CreateCylinder:h.wf,CreateTorus:c.eu,CreateTorusKnot:l.eB,CreateLineSystem:d.xW,CreateLines:d.nL,CreateDashedLines:d.Gz,ExtrudeShape:f.Gc,ExtrudeShapeCustom:f.bC,CreateLathe:g.O,CreateTiledPlane:p.KA,CreatePlane:_.pT,CreateGround:m.$6,CreateTiledGround:m.DG,CreateGroundFromHeightMap:m.W,CreatePolygon:u.a4,ExtrudePolygon:u.Yo,CreateTube:x._,CreatePolyhedron:I.sh,CreateGeodesic:D.M,CreateGoldberg:b._,CreateDecal:M.t,CreateCapsule:v.iz}},62659:(t,e,s)=>{s.d(e,{g:()=>i});class i{constructor(t,e){this.distanceOrScreenCoverage=t,this.mesh=e}}},86230:(t,e,s)=>{s.d(e,{z:()=>f});var i=s(84318),r=s(58095),n=s(72208),a=s(91243),o=s(89209),h=s(74742),c=s(48154),l=s(15210);class d extends r.FM{constructor(t,e){super(t.x,t.y),this.index=e}}class u{constructor(){this.elements=new Array}add(t){const e=new Array;return t.forEach((t=>{const s=new d(t,this.elements.length);e.push(s),this.elements.push(s)})),e}computeBounds(){const t=new r.FM(this.elements[0].x,this.elements[0].y),e=new r.FM(this.elements[0].x,this.elements[0].y);return this.elements.forEach((s=>{s.x<t.x?t.x=s.x:s.x>e.x&&(e.x=s.x),s.y<t.y?t.y=s.y:s.y>e.y&&(e.y=s.y)})),{min:t,max:e,width:e.x-t.x,height:e.y-t.y}}}class f{_addToepoint(t){for(const e of t)this._epoints.push(e.x,e.y)}constructor(t,e,s,r=earcut){let n;this._points=new u,this._outlinepoints=new u,this._holes=new Array,this._epoints=new Array,this._eholes=new Array,this.bjsEarcut=r,this._name=t,this._scene=s||l.l.LastCreatedScene,n=e instanceof h.ZZ?e.getPoints():e,this._addToepoint(n),this._points.add(n),this._outlinepoints.add(n),void 0===this.bjsEarcut&&i.Y.Warn("Earcut was not found, the polygon will not be built.")}addHole(t){this._points.add(t);const e=new u;return e.add(t),this._holes.push(e),this._eholes.push(this._epoints.length/2),this._addToepoint(t),this}build(t=!1,e=0,s=2){const i=new a.Kj(this._name,this._scene),r=this.buildVertexData(e,s);return i.setVerticesData(n.o.PositionKind,r.positions,t),i.setVerticesData(n.o.NormalKind,r.normals,t),i.setVerticesData(n.o.UVKind,r.uvs,t),i.setIndices(r.indices),i}buildVertexData(t=0,e=2){const s=new o.x,i=new Array,r=new Array,n=new Array,a=this._points.computeBounds();this._points.elements.forEach((t=>{i.push(0,1,0),r.push(t.x,0,t.y),n.push((t.x-a.min.x)/a.width,(t.y-a.min.y)/a.height)}));const h=new Array,c=this.bjsEarcut(this._epoints,this._eholes,2);for(let t=0;t<c.length;t++)h.push(c[t]);if(t>0){const s=r.length/3;this._points.elements.forEach((e=>{i.push(0,-1,0),r.push(e.x,-t,e.y),n.push(1-(e.x-a.min.x)/a.width,1-(e.y-a.min.y)/a.height)}));const o=h.length;for(let t=0;t<o;t+=3){const e=h[t+0],i=h[t+1],r=h[t+2];h.push(r+s),h.push(i+s),h.push(e+s)}this._addSide(r,i,n,h,a,this._outlinepoints,t,!1,e),this._holes.forEach((s=>{this._addSide(r,i,n,h,a,s,t,!0,e)}))}return s.indices=h,s.positions=r,s.normals=i,s.uvs=n,s}_addSide(t,e,s,i,n,a,o,h,l){let d=t.length/3,u=0;for(let f=0;f<a.elements.length;f++){const g=a.elements[f],_=a.elements[(f+1)%a.elements.length];t.push(g.x,0,g.y),t.push(g.x,-o,g.y),t.push(_.x,0,_.y),t.push(_.x,-o,_.y);const p=a.elements[(f+a.elements.length-1)%a.elements.length],m=a.elements[(f+2)%a.elements.length];let x=new r.P(-(_.y-g.y),0,_.x-g.x),I=new r.P(-(g.y-p.y),0,g.x-p.x),y=new r.P(-(m.y-_.y),0,m.x-_.x);h||(x=x.scale(-1),I=I.scale(-1),y=y.scale(-1));const M=x.normalizeToNew();let v=I.normalizeToNew(),D=y.normalizeToNew();const b=r.P.Dot(v,M);v=b>l?b<c.kn-1?new r.P(g.x,0,g.y).subtract(new r.P(_.x,0,_.y)).normalize():I.add(x).normalize():M;const B=r.P.Dot(y,x);D=B>l?B<c.kn-1?new r.P(_.x,0,_.y).subtract(new r.P(g.x,0,g.y)).normalize():y.add(x).normalize():M,s.push(u/n.width,0),s.push(u/n.width,1),u+=x.length(),s.push(u/n.width,0),s.push(u/n.width,1),e.push(v.x,v.y,v.z),e.push(v.x,v.y,v.z),e.push(D.x,D.y,D.z),e.push(D.x,D.y,D.z),h?(i.push(d),i.push(d+2),i.push(d+1),i.push(d+1),i.push(d+2),i.push(d+3)):(i.push(d),i.push(d+1),i.push(d+2),i.push(d+1),i.push(d+3),i.push(d+2)),d+=4}}}},68345:(t,e,s)=>{s.d(e,{P:()=>h});var i=s(72208),r=s(94184),n=s(91859),a=s(93701),o=s(67759);class h{get materialDefines(){var t;return this._mainDrawWrapperOverride?this._mainDrawWrapperOverride.defines:null===(t=this._getDrawWrapper())||void 0===t?void 0:t.defines}set materialDefines(t){var e;(null!==(e=this._mainDrawWrapperOverride)&&void 0!==e?e:this._getDrawWrapper(void 0,!0)).defines=t}_getDrawWrapper(t,e=!1){t=null!=t?t:this._engine.currentRenderPassId;let s=this._drawWrappers[t];return!s&&e&&(this._drawWrappers[t]=s=new o.q(this._mesh.getScene().getEngine())),s}_removeDrawWrapper(t,e=!0){var s;e&&(null===(s=this._drawWrappers[t])||void 0===s||s.dispose()),this._drawWrappers[t]=void 0}get effect(){var t,e;return this._mainDrawWrapperOverride?this._mainDrawWrapperOverride.effect:null!==(e=null===(t=this._getDrawWrapper())||void 0===t?void 0:t.effect)&&void 0!==e?e:null}get _drawWrapper(){var t;return null!==(t=this._mainDrawWrapperOverride)&&void 0!==t?t:this._getDrawWrapper(void 0,!0)}get _drawWrapperOverride(){return this._mainDrawWrapperOverride}_setMainDrawWrapperOverride(t){this._mainDrawWrapperOverride=t}setEffect(t,e=null,s,i=!0){const r=this._drawWrapper;r.setEffect(t,e,i),void 0!==s&&(r.materialContext=s),t||(r.defines=null,r.materialContext=void 0)}resetDrawCache(t){if(this._drawWrappers){if(void 0!==t)return void this._removeDrawWrapper(t);for(const t of this._drawWrappers)null==t||t.dispose()}this._drawWrappers=[]}static AddToMesh(t,e,s,i,r,n,a,o=!0){return new h(t,e,s,i,r,n,a,o)}constructor(t,e,s,i,r,n,a,o=!0,h=!0){this.materialIndex=t,this.verticesStart=e,this.verticesCount=s,this.indexStart=i,this.indexCount=r,this._mainDrawWrapperOverride=null,this._linesIndexCount=0,this._linesIndexBuffer=null,this._lastColliderWorldVertices=null,this._lastColliderTransformMatrix=null,this._wasDispatched=!1,this._renderId=0,this._alphaIndex=0,this._distanceToCamera=0,this._currentMaterial=null,this._mesh=n,this._renderingMesh=a||n,h&&n.subMeshes.push(this),this._engine=this._mesh.getScene().getEngine(),this.resetDrawCache(),this._trianglePlanes=[],this._id=n.subMeshes.length-1,o&&(this.refreshBoundingInfo(),n.computeWorldMatrix(!0))}get IsGlobal(){return 0===this.verticesStart&&this.verticesCount===this._mesh.getTotalVertices()&&0===this.indexStart&&this.indexCount===this._mesh.getTotalIndices()}getBoundingInfo(){return this.IsGlobal?this._mesh.getBoundingInfo():this._boundingInfo}setBoundingInfo(t){return this._boundingInfo=t,this}getMesh(){return this._mesh}getRenderingMesh(){return this._renderingMesh}getReplacementMesh(){return this._mesh._internalAbstractMeshDataInfo._actAsRegularMesh?this._mesh:null}getEffectiveMesh(){const t=this._mesh._internalAbstractMeshDataInfo._actAsRegularMesh?this._mesh:null;return t||this._renderingMesh}getMaterial(t=!0){var e;const s=null!==(e=this._renderingMesh.getMaterialForRenderPass(this._engine.currentRenderPassId))&&void 0!==e?e:this._renderingMesh.material;if(!s)return t?this._mesh.getScene().defaultMaterial:null;if(this._isMultiMaterial(s)){const t=s.getSubMaterial(this.materialIndex);return this._currentMaterial!==t&&(this._currentMaterial=t,this.resetDrawCache()),t}return s}_isMultiMaterial(t){return void 0!==t.getSubMaterial}refreshBoundingInfo(t=null){if(this._lastColliderWorldVertices=null,this.IsGlobal||!this._renderingMesh||!this._renderingMesh.geometry)return this;if(t||(t=this._renderingMesh.getVerticesData(i.o.PositionKind)),!t)return this._boundingInfo=this._mesh.getBoundingInfo(),this;const e=this._renderingMesh.getIndices();let s;if(0===this.indexStart&&this.indexCount===e.length){const t=this._renderingMesh.getBoundingInfo();s={minimum:t.minimum.clone(),maximum:t.maximum.clone()}}else s=(0,a.y)(t,e,this.indexStart,this.indexCount,this._renderingMesh.geometry.boundingBias);return this._boundingInfo?this._boundingInfo.reConstruct(s.minimum,s.maximum):this._boundingInfo=new n.j(s.minimum,s.maximum),this}_checkCollision(t){return this.getBoundingInfo()._checkCollision(t)}updateBoundingInfo(t){let e=this.getBoundingInfo();return e||(this.refreshBoundingInfo(),e=this.getBoundingInfo()),e&&e.update(t),this}isInFrustum(t){const e=this.getBoundingInfo();return!!e&&e.isInFrustum(t,this._mesh.cullingStrategy)}isCompletelyInFrustum(t){const e=this.getBoundingInfo();return!!e&&e.isCompletelyInFrustum(t)}render(t){return this._renderingMesh.render(this,t,this._mesh._internalAbstractMeshDataInfo._actAsRegularMesh?this._mesh:void 0),this}_getLinesIndexBuffer(t,e){if(!this._linesIndexBuffer){const s=[];for(let e=this.indexStart;e<this.indexStart+this.indexCount;e+=3)s.push(t[e],t[e+1],t[e+1],t[e+2],t[e+2],t[e]);this._linesIndexBuffer=e.createIndexBuffer(s),this._linesIndexCount=s.length}return this._linesIndexBuffer}canIntersects(t){const e=this.getBoundingInfo();return!!e&&t.intersectsBox(e.boundingBox)}intersects(t,e,s,i,r){const n=this.getMaterial();if(!n)return null;let a=3,o=!1;switch(n.fillMode){case 3:case 5:case 6:case 8:return null;case 7:a=1,o=!0}return 4===n.fillMode?s.length?this._intersectLines(t,e,s,this._mesh.intersectionThreshold,i):this._intersectUnIndexedLines(t,e,s,this._mesh.intersectionThreshold,i):!s.length&&this._mesh._unIndexed?this._intersectUnIndexedTriangles(t,e,s,i,r):this._intersectTriangles(t,e,s,a,o,i,r)}_intersectLines(t,e,s,i,n){let a=null;for(let o=this.indexStart;o<this.indexStart+this.indexCount;o+=2){const h=e[s[o]],c=e[s[o+1]],l=t.intersectionSegment(h,c,i);if(!(l<0)&&((n||!a||l<a.distance)&&(a=new r.c(null,null,l),a.faceId=o/2,n)))break}return a}_intersectUnIndexedLines(t,e,s,i,n){let a=null;for(let s=this.verticesStart;s<this.verticesStart+this.verticesCount;s+=2){const o=e[s],h=e[s+1],c=t.intersectionSegment(o,h,i);if(!(c<0)&&((n||!a||c<a.distance)&&(a=new r.c(null,null,c),a.faceId=s/2,n)))break}return a}_intersectTriangles(t,e,s,i,r,n,a){let o=null,h=-1;for(let c=this.indexStart;c<this.indexStart+this.indexCount-(3-i);c+=i){h++;const i=s[c],l=s[c+1],d=s[c+2];if(r&&4294967295===d){c+=2;continue}const u=e[i],f=e[l],g=e[d];if(!u||!f||!g)continue;if(a&&!a(u,f,g,t,i,l,d))continue;const _=t.intersectsTriangle(u,f,g);if(_){if(_.distance<0)continue;if((n||!o||_.distance<o.distance)&&(o=_,o.faceId=h,n))break}}return o}_intersectUnIndexedTriangles(t,e,s,i,r){let n=null;for(let s=this.verticesStart;s<this.verticesStart+this.verticesCount;s+=3){const a=e[s],o=e[s+1],h=e[s+2];if(r&&!r(a,o,h,t,-1,-1,-1))continue;const c=t.intersectsTriangle(a,o,h);if(c){if(c.distance<0)continue;if((i||!n||c.distance<n.distance)&&(n=c,n.faceId=s/3,i))break}}return n}_rebuild(){this._linesIndexBuffer&&(this._linesIndexBuffer=null)}clone(t,e){const s=new h(this.materialIndex,this.verticesStart,this.verticesCount,this.indexStart,this.indexCount,t,e,!1);if(!this.IsGlobal){const t=this.getBoundingInfo();if(!t)return s;s._boundingInfo=new n.j(t.minimum,t.maximum)}return s}dispose(){this._linesIndexBuffer&&(this._mesh.getScene().getEngine()._releaseBuffer(this._linesIndexBuffer),this._linesIndexBuffer=null);const t=this._mesh.subMeshes.indexOf(this);this._mesh.subMeshes.splice(t,1),this.resetDrawCache()}getClassName(){return"SubMesh"}static CreateFromIndices(t,e,s,i,r,n=!0){let a=Number.MAX_VALUE,o=-Number.MAX_VALUE;const c=(r||i).getIndices();for(let t=e;t<e+s;t++){const e=c[t];e<a&&(a=e),e>o&&(o=e)}return new h(t,a,o-a+1,e,s,i,r,n)}}},39318:(t,e,s)=>{var i=s(58095),r=s(68345);r.P.prototype._projectOnTrianglesToRef=function(t,e,s,r,n,a){const o=i.jp.Vector3[0],h=i.jp.Vector3[1];let c=1/0;for(let a=this.indexStart;a<this.indexStart+this.indexCount-(3-r);a+=r){const r=s[a],l=s[a+1],d=s[a+2];if(n&&4294967295===d){a+=2;continue}const u=e[r],f=e[l],g=e[d];if(!u||!f||!g)continue;const _=i.P.ProjectOnTriangleToRef(t,u,f,g,h);_<c&&(o.copyFrom(h),c=_)}return a.copyFrom(o),c},r.P.prototype._projectOnUnIndexedTrianglesToRef=function(t,e,s,r){const n=i.jp.Vector3[0],a=i.jp.Vector3[1];let o=1/0;for(let s=this.verticesStart;s<this.verticesStart+this.verticesCount;s+=3){const r=e[s],h=e[s+1],c=e[s+2],l=i.P.ProjectOnTriangleToRef(t,r,h,c,a);l<o&&(n.copyFrom(a),o=l)}return r.copyFrom(n),o},r.P.prototype.projectToRef=function(t,e,s,i){const r=this.getMaterial();if(!r)return-1;let n=3,a=!1;switch(r.fillMode){case 3:case 5:case 6:case 8:return-1;case 7:n=1,a=!0}return 4===r.fillMode?-1:!s.length&&this._mesh._unIndexed?this._projectOnUnIndexedTrianglesToRef(t,e,s,i):this._projectOnTrianglesToRef(t,e,s,n,a,i)}},83236:(t,e,s)=>{var i=s(91243),r=s(72208),n=s(58095),a=s(84318);i.Kj.prototype.thinInstanceAdd=function(t,e=!0){if(!this.getScene().getEngine().getCaps().instancedArrays)return a.Y.Error("Thin Instances are not supported on this device as Instanced Array extension not supported"),-1;this._thinInstanceUpdateBufferSize("matrix",Array.isArray(t)?t.length:1);const s=this._thinInstanceDataStorage.instancesCount;if(Array.isArray(t))for(let s=0;s<t.length;++s)this.thinInstanceSetMatrixAt(this._thinInstanceDataStorage.instancesCount++,t[s],s===t.length-1&&e);else this.thinInstanceSetMatrixAt(this._thinInstanceDataStorage.instancesCount++,t,e);return s},i.Kj.prototype.thinInstanceAddSelf=function(t=!0){return this.thinInstanceAdd(n.y3.IdentityReadOnly,t)},i.Kj.prototype.thinInstanceRegisterAttribute=function(t,e){t===r.o.ColorKind&&(t=r.o.ColorInstanceKind),this.removeVerticesData(t),this._thinInstanceInitializeUserStorage(),this._userThinInstanceBuffersStorage.strides[t]=e,this._userThinInstanceBuffersStorage.sizes[t]=e*Math.max(32,this._thinInstanceDataStorage.instancesCount),this._userThinInstanceBuffersStorage.data[t]=new Float32Array(this._userThinInstanceBuffersStorage.sizes[t]),this._userThinInstanceBuffersStorage.vertexBuffers[t]=new r.o(this.getEngine(),this._userThinInstanceBuffersStorage.data[t],t,!0,!1,e,!0),this.setVerticesBuffer(this._userThinInstanceBuffersStorage.vertexBuffers[t])},i.Kj.prototype.thinInstanceSetMatrixAt=function(t,e,s=!0){if(!this._thinInstanceDataStorage.matrixData||t>=this._thinInstanceDataStorage.instancesCount)return!1;const i=this._thinInstanceDataStorage.matrixData;return e.copyToArray(i,16*t),this._thinInstanceDataStorage.worldMatrices&&(this._thinInstanceDataStorage.worldMatrices[t]=e),s&&(this.thinInstanceBufferUpdated("matrix"),this.doNotSyncBoundingInfo||this.thinInstanceRefreshBoundingInfo(!1)),!0},i.Kj.prototype.thinInstanceSetAttributeAt=function(t,e,s,i=!0){return t===r.o.ColorKind&&(t=r.o.ColorInstanceKind),!(!this._userThinInstanceBuffersStorage||!this._userThinInstanceBuffersStorage.data[t]||e>=this._thinInstanceDataStorage.instancesCount)&&(this._thinInstanceUpdateBufferSize(t,0),this._userThinInstanceBuffersStorage.data[t].set(s,e*this._userThinInstanceBuffersStorage.strides[t]),i&&this.thinInstanceBufferUpdated(t),!0)},Object.defineProperty(i.Kj.prototype,"thinInstanceCount",{get:function(){return this._thinInstanceDataStorage.instancesCount},set:function(t){var e,s;const i=null!==(e=this._thinInstanceDataStorage.matrixData)&&void 0!==e?e:null===(s=this.source)||void 0===s?void 0:s._thinInstanceDataStorage.matrixData;t<=(i?i.length/16:0)&&(this._thinInstanceDataStorage.instancesCount=t)},enumerable:!0,configurable:!0}),i.Kj.prototype._thinInstanceCreateMatrixBuffer=function(t,e,s=!1){t===r.o.ColorKind&&(t=r.o.ColorInstanceKind);const i=new r.l(this.getEngine(),e,!s,16,!1,!0);for(let e=0;e<4;e++)this.setVerticesBuffer(i.createVertexBuffer(t+e,4*e,4));return i},i.Kj.prototype.thinInstanceSetBuffer=function(t,e,s=0,i=!1){var n,a,o;s=s||16,"matrix"===t?(null===(n=this._thinInstanceDataStorage.matrixBuffer)||void 0===n||n.dispose(),this._thinInstanceDataStorage.matrixBuffer=null,this._thinInstanceDataStorage.matrixBufferSize=e?e.length:32*s,this._thinInstanceDataStorage.matrixData=e,this._thinInstanceDataStorage.worldMatrices=null,null!==e?(this._thinInstanceDataStorage.instancesCount=e.length/s,this._thinInstanceDataStorage.matrixBuffer=this._thinInstanceCreateMatrixBuffer("world",e,i),this.doNotSyncBoundingInfo||this.thinInstanceRefreshBoundingInfo(!1)):(this._thinInstanceDataStorage.instancesCount=0,this.doNotSyncBoundingInfo||this.refreshBoundingInfo())):"previousMatrix"===t?(null===(a=this._thinInstanceDataStorage.previousMatrixBuffer)||void 0===a||a.dispose(),this._thinInstanceDataStorage.previousMatrixBuffer=null,this._thinInstanceDataStorage.previousMatrixData=e,null!==e&&(this._thinInstanceDataStorage.previousMatrixBuffer=this._thinInstanceCreateMatrixBuffer("previousWorld",e,i))):(t===r.o.ColorKind&&(t=r.o.ColorInstanceKind),null===e?(null===(o=this._userThinInstanceBuffersStorage)||void 0===o?void 0:o.data[t])&&(this.removeVerticesData(t),delete this._userThinInstanceBuffersStorage.data[t],delete this._userThinInstanceBuffersStorage.strides[t],delete this._userThinInstanceBuffersStorage.sizes[t],delete this._userThinInstanceBuffersStorage.vertexBuffers[t]):(this._thinInstanceInitializeUserStorage(),this._userThinInstanceBuffersStorage.data[t]=e,this._userThinInstanceBuffersStorage.strides[t]=s,this._userThinInstanceBuffersStorage.sizes[t]=e.length,this._userThinInstanceBuffersStorage.vertexBuffers[t]=new r.o(this.getEngine(),e,t,!i,!1,s,!0),this.setVerticesBuffer(this._userThinInstanceBuffersStorage.vertexBuffers[t])))},i.Kj.prototype.thinInstanceBufferUpdated=function(t){var e,s,i;"matrix"===t?null===(e=this._thinInstanceDataStorage.matrixBuffer)||void 0===e||e.updateDirectly(this._thinInstanceDataStorage.matrixData,0,this._thinInstanceDataStorage.instancesCount):"previousMatrix"===t?null===(s=this._thinInstanceDataStorage.previousMatrixBuffer)||void 0===s||s.updateDirectly(this._thinInstanceDataStorage.previousMatrixData,0,this._thinInstanceDataStorage.instancesCount):(t===r.o.ColorKind&&(t=r.o.ColorInstanceKind),(null===(i=this._userThinInstanceBuffersStorage)||void 0===i?void 0:i.vertexBuffers[t])&&this._userThinInstanceBuffersStorage.vertexBuffers[t].updateDirectly(this._userThinInstanceBuffersStorage.data[t],0))},i.Kj.prototype.thinInstancePartialBufferUpdate=function(t,e,s){var i;"matrix"===t?this._thinInstanceDataStorage.matrixBuffer&&this._thinInstanceDataStorage.matrixBuffer.updateDirectly(e,s):(t===r.o.ColorKind&&(t=r.o.ColorInstanceKind),(null===(i=this._userThinInstanceBuffersStorage)||void 0===i?void 0:i.vertexBuffers[t])&&this._userThinInstanceBuffersStorage.vertexBuffers[t].updateDirectly(e,s))},i.Kj.prototype.thinInstanceGetWorldMatrices=function(){if(!this._thinInstanceDataStorage.matrixData||!this._thinInstanceDataStorage.matrixBuffer)return[];const t=this._thinInstanceDataStorage.matrixData;if(!this._thinInstanceDataStorage.worldMatrices){this._thinInstanceDataStorage.worldMatrices=new Array;for(let e=0;e<this._thinInstanceDataStorage.instancesCount;++e)this._thinInstanceDataStorage.worldMatrices[e]=n.y3.FromArray(t,16*e)}return this._thinInstanceDataStorage.worldMatrices},i.Kj.prototype.thinInstanceRefreshBoundingInfo=function(t=!1,e=!1,s=!1){if(!this._thinInstanceDataStorage.matrixData||!this._thinInstanceDataStorage.matrixBuffer)return;const i=this._thinInstanceDataStorage.boundingVectors;t&&(i.length=0,this.refreshBoundingInfo(e,s));const r=this.getBoundingInfo(),a=this._thinInstanceDataStorage.matrixData;if(0===i.length)for(let t=0;t<r.boundingBox.vectors.length;++t)i.push(r.boundingBox.vectors[t].clone());n.jp.Vector3[0].setAll(Number.POSITIVE_INFINITY),n.jp.Vector3[1].setAll(Number.NEGATIVE_INFINITY);for(let t=0;t<this._thinInstanceDataStorage.instancesCount;++t){n.y3.FromArrayToRef(a,16*t,n.jp.Matrix[0]);for(let t=0;t<i.length;++t)n.P.TransformCoordinatesToRef(i[t],n.jp.Matrix[0],n.jp.Vector3[2]),n.jp.Vector3[0].minimizeInPlace(n.jp.Vector3[2]),n.jp.Vector3[1].maximizeInPlace(n.jp.Vector3[2])}r.reConstruct(n.jp.Vector3[0],n.jp.Vector3[1]),this._updateBoundingInfo()},i.Kj.prototype._thinInstanceUpdateBufferSize=function(t,e=1){var s,i,n;t===r.o.ColorKind&&(t=r.o.ColorInstanceKind);const a="matrix"===t;if(!(a||this._userThinInstanceBuffersStorage&&this._userThinInstanceBuffersStorage.strides[t]))return;const o=a?16:this._userThinInstanceBuffersStorage.strides[t],h=a?this._thinInstanceDataStorage.matrixBufferSize:this._userThinInstanceBuffersStorage.sizes[t];let c=a?this._thinInstanceDataStorage.matrixData:this._userThinInstanceBuffersStorage.data[t];const l=(this._thinInstanceDataStorage.instancesCount+e)*o;let d=h;for(;d<l;)d*=2;if(!c||h!=d){if(c){const t=new Float32Array(d);t.set(c,0),c=t}else c=new Float32Array(d);a?(null===(s=this._thinInstanceDataStorage.matrixBuffer)||void 0===s||s.dispose(),this._thinInstanceDataStorage.matrixBuffer=this._thinInstanceCreateMatrixBuffer("world",c,!1),this._thinInstanceDataStorage.matrixData=c,this._thinInstanceDataStorage.matrixBufferSize=d,this._scene.needsPreviousWorldMatrices&&!this._thinInstanceDataStorage.previousMatrixData&&(null===(i=this._thinInstanceDataStorage.previousMatrixBuffer)||void 0===i||i.dispose(),this._thinInstanceDataStorage.previousMatrixBuffer=this._thinInstanceCreateMatrixBuffer("previousWorld",c,!1))):(null===(n=this._userThinInstanceBuffersStorage.vertexBuffers[t])||void 0===n||n.dispose(),this._userThinInstanceBuffersStorage.data[t]=c,this._userThinInstanceBuffersStorage.sizes[t]=d,this._userThinInstanceBuffersStorage.vertexBuffers[t]=new r.o(this.getEngine(),c,t,!0,!1,o,!0),this.setVerticesBuffer(this._userThinInstanceBuffersStorage.vertexBuffers[t]))}},i.Kj.prototype._thinInstanceInitializeUserStorage=function(){this._userThinInstanceBuffersStorage||(this._userThinInstanceBuffersStorage={data:{},sizes:{},vertexBuffers:{},strides:{}})},i.Kj.prototype._disposeThinInstanceSpecificData=function(){var t;(null===(t=this._thinInstanceDataStorage)||void 0===t?void 0:t.matrixBuffer)&&(this._thinInstanceDataStorage.matrixBuffer.dispose(),this._thinInstanceDataStorage.matrixBuffer=null)}},30700:(t,e,s)=>{s.d(e,{Y:()=>c});var i=s(72433),r=s(96969),n=s(62897),a=s(58095),o=s(17834),h=s(43048);class c extends o.N{get billboardMode(){return this._billboardMode}set billboardMode(t){this._billboardMode!==t&&(this._billboardMode=t,this._cache.useBillboardPosition=0!=(this._billboardMode&c.BILLBOARDMODE_USE_POSITION),this._computeUseBillboardPath())}get preserveParentRotationForBillboard(){return this._preserveParentRotationForBillboard}set preserveParentRotationForBillboard(t){t!==this._preserveParentRotationForBillboard&&(this._preserveParentRotationForBillboard=t,this._computeUseBillboardPath())}_computeUseBillboardPath(){this._cache.useBillboardPath=this._billboardMode!==c.BILLBOARDMODE_NONE&&!this.preserveParentRotationForBillboard}get infiniteDistance(){return this._infiniteDistance}set infiniteDistance(t){this._infiniteDistance!==t&&(this._infiniteDistance=t)}constructor(t,e=null,s=!0){super(t,e),this._forward=new a.P(0,0,1),this._up=new a.P(0,1,0),this._right=new a.P(1,0,0),this._position=a.P.Zero(),this._rotation=a.P.Zero(),this._rotationQuaternion=null,this._scaling=a.P.One(),this._transformToBoneReferal=null,this._isAbsoluteSynced=!1,this._billboardMode=c.BILLBOARDMODE_NONE,this._preserveParentRotationForBillboard=!1,this.scalingDeterminant=1,this._infiniteDistance=!1,this.ignoreNonUniformScaling=!1,this.reIntegrateRotationIntoRotationQuaternion=!1,this._poseMatrix=null,this._localMatrix=a.y3.Zero(),this._usePivotMatrix=!1,this._absolutePosition=a.P.Zero(),this._absoluteScaling=a.P.Zero(),this._absoluteRotationQuaternion=a._f.Identity(),this._pivotMatrix=a.y3.Identity(),this._postMultiplyPivotMatrix=!1,this._isWorldMatrixFrozen=!1,this._indexInSceneTransformNodesArray=-1,this.onAfterWorldMatrixUpdateObservable=new n.y$,this._nonUniformScaling=!1,s&&this.getScene().addTransformNode(this)}getClassName(){return"TransformNode"}get position(){return this._position}set position(t){this._position=t,this._isDirty=!0}isUsingPivotMatrix(){return this._usePivotMatrix}get rotation(){return this._rotation}set rotation(t){this._rotation=t,this._rotationQuaternion=null,this._isDirty=!0}get scaling(){return this._scaling}set scaling(t){this._scaling=t,this._isDirty=!0}get rotationQuaternion(){return this._rotationQuaternion}set rotationQuaternion(t){this._rotationQuaternion=t,t&&this._rotation.setAll(0),this._isDirty=!0}get forward(){return a.P.TransformNormalFromFloatsToRef(0,0,this.getScene().useRightHandedSystem?-1:1,this.getWorldMatrix(),this._forward),this._forward.normalize()}get up(){return a.P.TransformNormalFromFloatsToRef(0,1,0,this.getWorldMatrix(),this._up),this._up.normalize()}get right(){return a.P.TransformNormalFromFloatsToRef(this.getScene().useRightHandedSystem?-1:1,0,0,this.getWorldMatrix(),this._right),this._right.normalize()}updatePoseMatrix(t){return this._poseMatrix?(this._poseMatrix.copyFrom(t),this):(this._poseMatrix=t.clone(),this)}getPoseMatrix(){return this._poseMatrix||(this._poseMatrix=a.y3.Identity()),this._poseMatrix}_isSynchronized(){const t=this._cache;return this._billboardMode===t.billboardMode&&this._billboardMode===c.BILLBOARDMODE_NONE&&(!t.pivotMatrixUpdated&&(!this._infiniteDistance&&(!this._position._isDirty&&(!this._scaling._isDirty&&!(this._rotationQuaternion&&this._rotationQuaternion._isDirty||this._rotation._isDirty)))))}_initCache(){super._initCache();const t=this._cache;t.localMatrixUpdated=!1,t.billboardMode=-1,t.infiniteDistance=!1,t.useBillboardPosition=!1,t.useBillboardPath=!1}get absolutePosition(){return this.getAbsolutePosition()}get absoluteScaling(){return this._syncAbsoluteScalingAndRotation(),this._absoluteScaling}get absoluteRotationQuaternion(){return this._syncAbsoluteScalingAndRotation(),this._absoluteRotationQuaternion}setPreTransformMatrix(t){return this.setPivotMatrix(t,!1)}setPivotMatrix(t,e=!0){return this._pivotMatrix.copyFrom(t),this._usePivotMatrix=!this._pivotMatrix.isIdentity(),this._cache.pivotMatrixUpdated=!0,this._postMultiplyPivotMatrix=e,this._postMultiplyPivotMatrix&&(this._pivotMatrixInverse?this._pivotMatrix.invertToRef(this._pivotMatrixInverse):this._pivotMatrixInverse=a.y3.Invert(this._pivotMatrix)),this}getPivotMatrix(){return this._pivotMatrix}instantiateHierarchy(t=null,e,s){const i=this.clone("Clone of "+(this.name||this.id),t||this.parent,!0);i&&s&&s(this,i);for(const t of this.getChildTransformNodes(!0))t.instantiateHierarchy(i,e,s);return i}freezeWorldMatrix(t=null,e=!1){return t?e?(this._rotation.setAll(0),this._rotationQuaternion=this._rotationQuaternion||a._f.Identity(),t.decompose(this._scaling,this._rotationQuaternion,this._position),this.computeWorldMatrix(!0)):(this._worldMatrix=t,this._absolutePosition.copyFromFloats(this._worldMatrix.m[12],this._worldMatrix.m[13],this._worldMatrix.m[14]),this._afterComputeWorldMatrix()):(this._isWorldMatrixFrozen=!1,this.computeWorldMatrix(!0)),this._isDirty=!1,this._isWorldMatrixFrozen=!0,this}unfreezeWorldMatrix(){return this._isWorldMatrixFrozen=!1,this.computeWorldMatrix(!0),this}get isWorldMatrixFrozen(){return this._isWorldMatrixFrozen}getAbsolutePosition(){return this.computeWorldMatrix(),this._absolutePosition}setAbsolutePosition(t){if(!t)return this;let e,s,i;if(void 0===t.x){if(arguments.length<3)return this;e=arguments[0],s=arguments[1],i=arguments[2]}else e=t.x,s=t.y,i=t.z;if(this.parent){const t=a.jp.Matrix[0];this.parent.getWorldMatrix().invertToRef(t),a.P.TransformCoordinatesFromFloatsToRef(e,s,i,t,this.position)}else this.position.x=e,this.position.y=s,this.position.z=i;return this._absolutePosition.copyFrom(t),this}setPositionWithLocalVector(t){return this.computeWorldMatrix(),this.position=a.P.TransformNormal(t,this._localMatrix),this}getPositionExpressedInLocalSpace(){this.computeWorldMatrix();const t=a.jp.Matrix[0];return this._localMatrix.invertToRef(t),a.P.TransformNormal(this.position,t)}locallyTranslate(t){return this.computeWorldMatrix(!0),this.position=a.P.TransformCoordinates(t,this._localMatrix),this}lookAt(t,e=0,s=0,i=0,r=h.T.LOCAL){const n=c._LookAtVectorCache,o=r===h.T.LOCAL?this.position:this.getAbsolutePosition();if(t.subtractToRef(o,n),this.setDirection(n,e,s,i),r===h.T.WORLD&&this.parent)if(this.rotationQuaternion){const t=a.jp.Matrix[0];this.rotationQuaternion.toRotationMatrix(t);const e=a.jp.Matrix[1];this.parent.getWorldMatrix().getRotationMatrixToRef(e),e.invert(),t.multiplyToRef(e,t),this.rotationQuaternion.fromRotationMatrix(t)}else{const t=a.jp.Quaternion[0];a._f.FromEulerVectorToRef(this.rotation,t);const e=a.jp.Matrix[0];t.toRotationMatrix(e);const s=a.jp.Matrix[1];this.parent.getWorldMatrix().getRotationMatrixToRef(s),s.invert(),e.multiplyToRef(s,e),t.fromRotationMatrix(e),t.toEulerAnglesToRef(this.rotation)}return this}getDirection(t){const e=a.P.Zero();return this.getDirectionToRef(t,e),e}getDirectionToRef(t,e){return a.P.TransformNormalToRef(t,this.getWorldMatrix(),e),this}setDirection(t,e=0,s=0,i=0){const r=-Math.atan2(t.z,t.x)+Math.PI/2,n=Math.sqrt(t.x*t.x+t.z*t.z),o=-Math.atan2(t.y,n);return this.rotationQuaternion?a._f.RotationYawPitchRollToRef(r+e,o+s,i,this.rotationQuaternion):(this.rotation.x=o+s,this.rotation.y=r+e,this.rotation.z=i),this}setPivotPoint(t,e=h.T.LOCAL){0==this.getScene().getRenderId()&&this.computeWorldMatrix(!0);const s=this.getWorldMatrix();if(e==h.T.WORLD){const e=a.jp.Matrix[0];s.invertToRef(e),t=a.P.TransformCoordinates(t,e)}return this.setPivotMatrix(a.y3.Translation(-t.x,-t.y,-t.z),!0)}getPivotPoint(){const t=a.P.Zero();return this.getPivotPointToRef(t),t}getPivotPointToRef(t){return t.x=-this._pivotMatrix.m[12],t.y=-this._pivotMatrix.m[13],t.z=-this._pivotMatrix.m[14],this}getAbsolutePivotPoint(){const t=a.P.Zero();return this.getAbsolutePivotPointToRef(t),t}getAbsolutePivotPointToRef(t){return this.getPivotPointToRef(t),a.P.TransformCoordinatesToRef(t,this.getWorldMatrix(),t),this}markAsDirty(t){if(this._isDirty)return this;if(this._children)for(const e of this._children)e.markAsDirty(t);return super.markAsDirty(t)}setParent(t,e=!1,s=!1){if(!t&&!this.parent)return this;const i=a.jp.Quaternion[0],r=a.jp.Vector3[0],n=a.jp.Vector3[1],o=a.jp.Matrix[1];a.y3.IdentityToRef(o);const h=a.jp.Matrix[0];this.computeWorldMatrix(!0);let l=this.rotationQuaternion;return l||(l=c._TmpRotation,a._f.RotationYawPitchRollToRef(this._rotation.y,this._rotation.x,this._rotation.z,l)),a.y3.ComposeToRef(this.scaling,l,this.position,h),this.parent&&h.multiplyToRef(this.parent.computeWorldMatrix(!0),h),t&&(t.computeWorldMatrix(!0).invertToRef(o),h.multiplyToRef(o,h)),h.decompose(n,i,r,e?this:void 0),this.rotationQuaternion?this.rotationQuaternion.copyFrom(i):i.toEulerAnglesToRef(this.rotation),this.scaling.copyFrom(n),this.position.copyFrom(r),this.parent=t,s&&this.setPivotMatrix(a.y3.Identity()),this}get nonUniformScaling(){return this._nonUniformScaling}_updateNonUniformScalingState(t){return this._nonUniformScaling!==t&&(this._nonUniformScaling=t,!0)}attachToBone(t,e){return this._currentParentWhenAttachingToBone=this.parent,this._transformToBoneReferal=e,this.parent=t,t.getSkeleton().prepare(),t.getWorldMatrix().determinant()<0&&(this.scalingDeterminant*=-1),this}detachFromBone(t=!1){return this.parent?(this.parent.getWorldMatrix().determinant()<0&&(this.scalingDeterminant*=-1),this._transformToBoneReferal=null,this.parent=t?this._currentParentWhenAttachingToBone:null,this):(t&&(this.parent=this._currentParentWhenAttachingToBone),this)}rotate(t,e,s){let i;if(t.normalize(),this.rotationQuaternion||(this.rotationQuaternion=this.rotation.toQuaternion(),this.rotation.setAll(0)),s&&s!==h.T.LOCAL){if(this.parent){const e=a.jp.Matrix[0];this.parent.getWorldMatrix().invertToRef(e),t=a.P.TransformNormal(t,e)}i=a._f.RotationAxisToRef(t,e,c._RotationAxisCache),i.multiplyToRef(this.rotationQuaternion,this.rotationQuaternion)}else i=a._f.RotationAxisToRef(t,e,c._RotationAxisCache),this.rotationQuaternion.multiplyToRef(i,this.rotationQuaternion);return this}rotateAround(t,e,s){e.normalize(),this.rotationQuaternion||(this.rotationQuaternion=a._f.RotationYawPitchRoll(this.rotation.y,this.rotation.x,this.rotation.z),this.rotation.setAll(0));const i=a.jp.Vector3[0],r=a.jp.Vector3[1],n=a.jp.Vector3[2],o=a.jp.Quaternion[0],h=a.jp.Matrix[0],c=a.jp.Matrix[1],l=a.jp.Matrix[2],d=a.jp.Matrix[3];return t.subtractToRef(this.position,i),a.y3.TranslationToRef(i.x,i.y,i.z,h),a.y3.TranslationToRef(-i.x,-i.y,-i.z,c),a.y3.RotationAxisToRef(e,s,l),c.multiplyToRef(l,d),d.multiplyToRef(h,d),d.decompose(r,o,n),this.position.addInPlace(n),o.multiplyToRef(this.rotationQuaternion,this.rotationQuaternion),this}translate(t,e,s){const i=t.scale(e);if(s&&s!==h.T.LOCAL)this.setAbsolutePosition(this.getAbsolutePosition().add(i));else{const t=this.getPositionExpressedInLocalSpace().add(i);this.setPositionWithLocalVector(t)}return this}addRotation(t,e,s){let i;this.rotationQuaternion?i=this.rotationQuaternion:(i=a.jp.Quaternion[1],a._f.RotationYawPitchRollToRef(this.rotation.y,this.rotation.x,this.rotation.z,i));const r=a.jp.Quaternion[0];return a._f.RotationYawPitchRollToRef(e,t,s,r),i.multiplyInPlace(r),this.rotationQuaternion||i.toEulerAnglesToRef(this.rotation),this}_getEffectiveParent(){return this.parent}isWorldMatrixCameraDependent(){return this._infiniteDistance&&!this.parent||this._billboardMode!==c.BILLBOARDMODE_NONE&&!this.preserveParentRotationForBillboard}computeWorldMatrix(t=!1,e=null){if(this._isWorldMatrixFrozen&&!this._isDirty)return this._worldMatrix;const s=this.getScene().getRenderId();if(!this._isDirty&&!t&&(this._currentRenderId===s||this.isSynchronized()))return this._currentRenderId=s,this._worldMatrix;e=e||this.getScene().activeCamera,this._updateCache();const i=this._cache;i.pivotMatrixUpdated=!1,i.billboardMode=this.billboardMode,i.infiniteDistance=this.infiniteDistance,i.parent=this._parentNode,this._currentRenderId=s,this._childUpdateId+=1,this._isDirty=!1,this._position._isDirty=!1,this._rotation._isDirty=!1,this._scaling._isDirty=!1;const r=this._getEffectiveParent(),n=c._TmpScaling;let o,h=this._position;if(this._infiniteDistance&&!this.parent&&e){const t=e.getWorldMatrix(),s=new a.P(t.m[12],t.m[13],t.m[14]);h=c._TmpTranslation,h.copyFromFloats(this._position.x+s.x,this._position.y+s.y,this._position.z+s.z)}if(n.copyFromFloats(this._scaling.x*this.scalingDeterminant,this._scaling.y*this.scalingDeterminant,this._scaling.z*this.scalingDeterminant),this._rotationQuaternion){if(this._rotationQuaternion._isDirty=!1,o=this._rotationQuaternion,this.reIntegrateRotationIntoRotationQuaternion){this.rotation.lengthSquared()&&(this._rotationQuaternion.multiplyInPlace(a._f.RotationYawPitchRoll(this._rotation.y,this._rotation.x,this._rotation.z)),this._rotation.copyFromFloats(0,0,0))}}else o=c._TmpRotation,a._f.RotationYawPitchRollToRef(this._rotation.y,this._rotation.x,this._rotation.z,o);if(this._usePivotMatrix){const t=a.jp.Matrix[1];a.y3.ScalingToRef(n.x,n.y,n.z,t);const e=a.jp.Matrix[0];o.toRotationMatrix(e),this._pivotMatrix.multiplyToRef(t,a.jp.Matrix[4]),a.jp.Matrix[4].multiplyToRef(e,this._localMatrix),this._postMultiplyPivotMatrix&&this._localMatrix.multiplyToRef(this._pivotMatrixInverse,this._localMatrix),this._localMatrix.addTranslationFromFloats(h.x,h.y,h.z)}else a.y3.ComposeToRef(n,o,h,this._localMatrix);if(r&&r.getWorldMatrix){if(t&&r.computeWorldMatrix(t),i.useBillboardPath){this._transformToBoneReferal?r.getWorldMatrix().multiplyToRef(this._transformToBoneReferal.getWorldMatrix(),a.jp.Matrix[7]):a.jp.Matrix[7].copyFrom(r.getWorldMatrix());const t=a.jp.Vector3[5],e=a.jp.Vector3[6],s=a.jp.Quaternion[0];a.jp.Matrix[7].decompose(e,s,t),a.y3.ScalingToRef(e.x,e.y,e.z,a.jp.Matrix[7]),a.jp.Matrix[7].setTranslation(t),c.BillboardUseParentOrientation&&(this._position.applyRotationQuaternionToRef(s,t),this._localMatrix.setTranslation(t)),this._localMatrix.multiplyToRef(a.jp.Matrix[7],this._worldMatrix)}else this._transformToBoneReferal?(this._localMatrix.multiplyToRef(r.getWorldMatrix(),a.jp.Matrix[6]),a.jp.Matrix[6].multiplyToRef(this._transformToBoneReferal.getWorldMatrix(),this._worldMatrix)):this._localMatrix.multiplyToRef(r.getWorldMatrix(),this._worldMatrix);this._markSyncedWithParent()}else this._worldMatrix.copyFrom(this._localMatrix);if(i.useBillboardPath&&e&&this.billboardMode&&!i.useBillboardPosition){const t=a.jp.Vector3[0];if(this._worldMatrix.getTranslationToRef(t),a.jp.Matrix[1].copyFrom(e.getViewMatrix()),a.jp.Matrix[1].setTranslationFromFloats(0,0,0),a.jp.Matrix[1].invertToRef(a.jp.Matrix[0]),(this.billboardMode&c.BILLBOARDMODE_ALL)!==c.BILLBOARDMODE_ALL){a.jp.Matrix[0].decompose(void 0,a.jp.Quaternion[0],void 0);const t=a.jp.Vector3[1];a.jp.Quaternion[0].toEulerAnglesToRef(t),(this.billboardMode&c.BILLBOARDMODE_X)!==c.BILLBOARDMODE_X&&(t.x=0),(this.billboardMode&c.BILLBOARDMODE_Y)!==c.BILLBOARDMODE_Y&&(t.y=0),(this.billboardMode&c.BILLBOARDMODE_Z)!==c.BILLBOARDMODE_Z&&(t.z=0),a.y3.RotationYawPitchRollToRef(t.y,t.x,t.z,a.jp.Matrix[0])}this._worldMatrix.setTranslationFromFloats(0,0,0),this._worldMatrix.multiplyToRef(a.jp.Matrix[0],this._worldMatrix),this._worldMatrix.setTranslation(a.jp.Vector3[0])}else if(i.useBillboardPath&&e&&i.useBillboardPosition){const t=a.jp.Vector3[0];this._worldMatrix.getTranslationToRef(t);const s=e.globalPosition;this._worldMatrix.invertToRef(a.jp.Matrix[1]);const i=a.jp.Vector3[1];a.P.TransformCoordinatesToRef(s,a.jp.Matrix[1],i),i.normalize();const r=-Math.atan2(i.z,i.x)+Math.PI/2,n=Math.sqrt(i.x*i.x+i.z*i.z),o=-Math.atan2(i.y,n);if(a._f.RotationYawPitchRollToRef(r,o,0,a.jp.Quaternion[0]),(this.billboardMode&c.BILLBOARDMODE_ALL)!==c.BILLBOARDMODE_ALL){const t=a.jp.Vector3[1];a.jp.Quaternion[0].toEulerAnglesToRef(t),(this.billboardMode&c.BILLBOARDMODE_X)!==c.BILLBOARDMODE_X&&(t.x=0),(this.billboardMode&c.BILLBOARDMODE_Y)!==c.BILLBOARDMODE_Y&&(t.y=0),(this.billboardMode&c.BILLBOARDMODE_Z)!==c.BILLBOARDMODE_Z&&(t.z=0),a.y3.RotationYawPitchRollToRef(t.y,t.x,t.z,a.jp.Matrix[0])}else a.y3.FromQuaternionToRef(a.jp.Quaternion[0],a.jp.Matrix[0]);this._worldMatrix.setTranslationFromFloats(0,0,0),this._worldMatrix.multiplyToRef(a.jp.Matrix[0],this._worldMatrix),this._worldMatrix.setTranslation(a.jp.Vector3[0])}return this.ignoreNonUniformScaling?this._updateNonUniformScalingState(!1):this._scaling.isNonUniformWithinEpsilon(1e-6)?this._updateNonUniformScalingState(!0):r&&r._nonUniformScaling?this._updateNonUniformScalingState(r._nonUniformScaling):this._updateNonUniformScalingState(!1),this._afterComputeWorldMatrix(),this._absolutePosition.copyFromFloats(this._worldMatrix.m[12],this._worldMatrix.m[13],this._worldMatrix.m[14]),this._isAbsoluteSynced=!1,this.onAfterWorldMatrixUpdateObservable.notifyObservers(this),this._poseMatrix||(this._poseMatrix=a.y3.Invert(this._worldMatrix)),this._worldMatrixDeterminantIsDirty=!0,this._worldMatrix}resetLocalMatrix(t=!0){if(this.computeWorldMatrix(),t){const t=this.getChildren();for(let e=0;e<t.length;++e){const s=t[e];if(s){s.computeWorldMatrix();const t=a.jp.Matrix[0];s._localMatrix.multiplyToRef(this._localMatrix,t);const e=a.jp.Quaternion[0];t.decompose(s.scaling,e,s.position),s.rotationQuaternion?s.rotationQuaternion.copyFrom(e):e.toEulerAnglesToRef(s.rotation)}}}this.scaling.copyFromFloats(1,1,1),this.position.copyFromFloats(0,0,0),this.rotation.copyFromFloats(0,0,0),this.rotationQuaternion&&(this.rotationQuaternion=a._f.Identity()),this._worldMatrix=a.y3.Identity()}_afterComputeWorldMatrix(){}registerAfterWorldMatrixUpdate(t){return this.onAfterWorldMatrixUpdateObservable.add(t),this}unregisterAfterWorldMatrixUpdate(t){return this.onAfterWorldMatrixUpdateObservable.removeCallback(t),this}getPositionInCameraSpace(t=null){return t||(t=this.getScene().activeCamera),a.P.TransformCoordinates(this.getAbsolutePosition(),t.getViewMatrix())}getDistanceToCamera(t=null){return t||(t=this.getScene().activeCamera),this.getAbsolutePosition().subtract(t.globalPosition).length()}clone(t,e,s){const i=r.p4.Clone((()=>new c(t,this.getScene())),this);if(i.name=t,i.id=t,e&&(i.parent=e),!s){const e=this.getDescendants(!0);for(let s=0;s<e.length;s++){const r=e[s];r.clone&&r.clone(t+"."+r.name,i)}}return i}serialize(t){const e=r.p4.Serialize(this,t);return e.type=this.getClassName(),e.uniqueId=this.uniqueId,this.parent&&this.parent._serializeAsParent(e),e.localMatrix=this.getPivotMatrix().asArray(),e.isEnabled=this.isEnabled(),e}static Parse(t,e,s){const i=r.p4.Parse((()=>new c(t.name,e)),t,e,s);return t.localMatrix?i.setPreTransformMatrix(a.y3.FromArray(t.localMatrix)):t.pivotMatrix&&i.setPivotMatrix(a.y3.FromArray(t.pivotMatrix)),i.setEnabled(t.isEnabled),i._waitingParsedUniqueId=t.uniqueId,void 0!==t.parentId&&(i._waitingParentId=t.parentId),void 0!==t.parentInstanceIndex&&(i._waitingParentInstanceIndex=t.parentInstanceIndex),i}getChildTransformNodes(t,e){const s=[];return this._getDescendants(s,t,(t=>(!e||e(t))&&t instanceof c)),s}dispose(t,e=!1){if(this.getScene().stopAnimation(this),this.getScene().removeTransformNode(this),this._parentContainer){const t=this._parentContainer.transformNodes.indexOf(this);t>-1&&this._parentContainer.transformNodes.splice(t,1),this._parentContainer=null}if(this.onAfterWorldMatrixUpdateObservable.clear(),t){const t=this.getChildTransformNodes(!0);for(const e of t)e.parent=null,e.computeWorldMatrix(!0)}super.dispose(t,e)}normalizeToUnitCube(t=!0,e=!1,s){let i=null,r=null;e&&(this.rotationQuaternion?(r=this.rotationQuaternion.clone(),this.rotationQuaternion.copyFromFloats(0,0,0,1)):this.rotation&&(i=this.rotation.clone(),this.rotation.copyFromFloats(0,0,0)));const n=this.getHierarchyBoundingVectors(t,s),a=n.max.subtract(n.min),o=Math.max(a.x,a.y,a.z);if(0===o)return this;const h=1/o;return this.scaling.scaleInPlace(h),e&&(this.rotationQuaternion&&r?this.rotationQuaternion.copyFrom(r):this.rotation&&i&&this.rotation.copyFrom(i)),this}_syncAbsoluteScalingAndRotation(){this._isAbsoluteSynced||(this._worldMatrix.decompose(this._absoluteScaling,this._absoluteRotationQuaternion),this._isAbsoluteSynced=!0)}}c.BILLBOARDMODE_NONE=0,c.BILLBOARDMODE_X=1,c.BILLBOARDMODE_Y=2,c.BILLBOARDMODE_Z=4,c.BILLBOARDMODE_ALL=7,c.BILLBOARDMODE_USE_POSITION=128,c.BillboardUseParentOrientation=!1,c._TmpRotation=a._f.Zero(),c._TmpScaling=a.P.Zero(),c._TmpTranslation=a.P.Zero(),c._LookAtVectorCache=new a.P(0,0,0),c._RotationAxisCache=new a._f,(0,i.gn)([(0,r.hd)("position")],c.prototype,"_position",void 0),(0,i.gn)([(0,r.hd)("rotation")],c.prototype,"_rotation",void 0),(0,i.gn)([(0,r.mv)("rotationQuaternion")],c.prototype,"_rotationQuaternion",void 0),(0,i.gn)([(0,r.hd)("scaling")],c.prototype,"_scaling",void 0),(0,i.gn)([(0,r.qC)("billboardMode")],c.prototype,"_billboardMode",void 0),(0,i.gn)([(0,r.qC)()],c.prototype,"scalingDeterminant",void 0),(0,i.gn)([(0,r.qC)("infiniteDistance")],c.prototype,"_infiniteDistance",void 0),(0,i.gn)([(0,r.qC)()],c.prototype,"ignoreNonUniformScaling",void 0),(0,i.gn)([(0,r.qC)()],c.prototype,"reIntegrateRotationIntoRotationQuaternion",void 0)}}]);