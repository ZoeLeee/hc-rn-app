{"version":3,"file":"js/vender~640e94a9.ea3d6bfe.js","mappings":"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","sources":["webpack:///../../../node_modules/base64-js/index.js","webpack:///../../../node_modules/buffer/index.js","webpack:///../../../node_modules/@babylonjs/loaders/OBJ/mtlFileLoader.js","webpack:///../../../node_modules/@babylonjs/loaders/OBJ/solidParser.js","webpack:///../../../node_modules/@babylonjs/loaders/OBJ/objFileLoader.js","webpack:///../../../node_modules/@babylonjs/loaders/STL/stlFileLoader.js","webpack:///../../../node_modules/@babylonjs/loaders/glTF/2.0/glTFLoaderAnimation.js","webpack:///../../../node_modules/@babylonjs/loaders/glTF/2.0/glTFLoader.js","webpack:///../../../node_modules/@babylonjs/loaders/glTF/2.0/Extensions/EXT_lights_image_based.js","webpack:///../../../node_modules/@babylonjs/loaders/glTF/2.0/Extensions/EXT_mesh_gpu_instancing.js","webpack:///../../../node_modules/@babylonjs/loaders/glTF/2.0/Extensions/EXT_meshopt_compression.js","webpack:///../../../node_modules/@babylonjs/loaders/glTF/2.0/Extensions/EXT_texture_webp.js","webpack:///../../../node_modules/@babylonjs/loaders/glTF/2.0/Extensions/KHR_draco_mesh_compression.js","webpack:///../../../node_modules/@babylonjs/loaders/glTF/2.0/Extensions/KHR_lights_punctual.js","webpack:///../../../node_modules/@babylonjs/loaders/glTF/2.0/Extensions/KHR_materials_pbrSpecularGlossiness.js","webpack:///../../../node_modules/@babylonjs/loaders/glTF/2.0/Extensions/KHR_materials_unlit.js","webpack:///../../../node_modules/@babylonjs/loaders/glTF/2.0/Extensions/KHR_materials_clearcoat.js","webpack:///../../../node_modules/@babylonjs/loaders/glTF/2.0/Extensions/KHR_materials_iridescence.js","webpack:///../../../node_modules/@babylonjs/loaders/glTF/2.0/Extensions/KHR_materials_emissive_strength.js","webpack:///../../../node_modules/@babylonjs/loaders/glTF/2.0/Extensions/KHR_materials_sheen.js","webpack:///../../../node_modules/@babylonjs/loaders/glTF/2.0/Extensions/KHR_materials_specular.js","webpack:///../../../node_modules/@babylonjs/loaders/glTF/2.0/Extensions/KHR_materials_ior.js","webpack:///../../../node_modules/@babylonjs/loaders/glTF/2.0/Extensions/KHR_materials_variants.js","webpack:///../../../node_modules/@babylonjs/loaders/glTF/2.0/Extensions/KHR_materials_transmission.js","webpack:///../../../node_modules/@babylonjs/loaders/glTF/2.0/Extensions/KHR_materials_translucency.js","webpack:///../../../node_modules/@babylonjs/loaders/glTF/2.0/Extensions/KHR_materials_volume.js","webpack:///../../../node_modules/@babylonjs/loaders/glTF/2.0/Extensions/KHR_mesh_quantization.js","webpack:///../../../node_modules/@babylonjs/loaders/glTF/2.0/Extensions/KHR_texture_basisu.js","webpack:///../../../node_modules/@babylonjs/loaders/glTF/2.0/Extensions/KHR_texture_transform.js","webpack:///../../../node_modules/@babylonjs/loaders/glTF/2.0/Extensions/KHR_xmp_json_ld.js","webpack:///../../../node_modules/@babylonjs/loaders/glTF/2.0/Extensions/KHR_animation_pointer.data.js","webpack:///../../../node_modules/@babylonjs/loaders/glTF/2.0/Extensions/KHR_animation_pointer.js","webpack:///../../../node_modules/@babylonjs/loaders/glTF/2.0/Extensions/MSFT_audio_emitter.js","webpack:///../../../node_modules/@babylonjs/loaders/glTF/2.0/Extensions/MSFT_lod.js","webpack:///../../../node_modules/@babylonjs/loaders/glTF/2.0/Extensions/MSFT_minecraftMesh.js","webpack:///../../../node_modules/@babylonjs/loaders/glTF/2.0/Extensions/MSFT_sRGBFactors.js","webpack:///../../../node_modules/@babylonjs/loaders/glTF/2.0/Extensions/ExtrasAsMetadata.js","webpack:///../../../node_modules/@babylonjs/loaders/glTF/glTFFileLoader.js","webpack:///../../../node_modules/@babylonjs/loaders/glTF/glTFValidation.js","webpack:///../../../node_modules/@babylonjs/loaders/glTF/1.0/glTFLoaderInterfaces.js","webpack:///../../../node_modules/@babylonjs/loaders/glTF/1.0/glTFLoaderUtils.js","webpack:///../../../node_modules/@babylonjs/loaders/glTF/1.0/glTFLoader.js","webpack:///../../../node_modules/@babylonjs/loaders/glTF/1.0/glTFBinaryExtension.js","webpack:///../../../node_modules/@babylonjs/loaders/glTF/1.0/glTFMaterialsCommonExtension.js","webpack:///../../../node_modules/@babylonjs/materials/grid/grid.fragment.js","webpack:///../../../node_modules/@babylonjs/materials/grid/gridMaterial.js","webpack:///../../../node_modules/@babylonjs/materials/sky/sky.fragment.js","webpack:///../../../node_modules/@babylonjs/materials/sky/sky.vertex.js","webpack:///../../../node_modules/@babylonjs/materials/sky/skyMaterial.js","webpack:///../../../node_modules/@babylonjs/materials/water/water.fragment.js","webpack:///../../../node_modules/@babylonjs/materials/water/water.vertex.js","webpack:///../../../node_modules/@babylonjs/materials/water/waterMaterial.js"],"sourcesContent":["'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n","/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nconst base64 = require('base64-js')\nconst ieee754 = require('ieee754')\nconst customInspectSymbol =\n  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation\n    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation\n    : null\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\nconst K_MAX_LENGTH = 0x7fffffff\nexports.kMaxLength = K_MAX_LENGTH\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n *               implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * We report that the browser does not support typed arrays if the are not subclassable\n * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n * for __proto__ and has a buggy typed array implementation.\n */\nBuffer.TYPED_ARRAY_SUPPORT = typedArraySupport()\n\nif (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&\n    typeof console.error === 'function') {\n  console.error(\n    'This browser lacks typed array (Uint8Array) support which is required by ' +\n    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'\n  )\n}\n\nfunction typedArraySupport () {\n  // Can typed array instances can be augmented?\n  try {\n    const arr = new Uint8Array(1)\n    const proto = { foo: function () { return 42 } }\n    Object.setPrototypeOf(proto, Uint8Array.prototype)\n    Object.setPrototypeOf(arr, proto)\n    return arr.foo() === 42\n  } catch (e) {\n    return false\n  }\n}\n\nObject.defineProperty(Buffer.prototype, 'parent', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.buffer\n  }\n})\n\nObject.defineProperty(Buffer.prototype, 'offset', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.byteOffset\n  }\n})\n\nfunction createBuffer (length) {\n  if (length > K_MAX_LENGTH) {\n    throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"')\n  }\n  // Return an augmented `Uint8Array` instance\n  const buf = new Uint8Array(length)\n  Object.setPrototypeOf(buf, Buffer.prototype)\n  return buf\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new TypeError(\n        'The \"string\" argument must be of type string. Received type number'\n      )\n    }\n    return allocUnsafe(arg)\n  }\n  return from(arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\nfunction from (value, encodingOrOffset, length) {\n  if (typeof value === 'string') {\n    return fromString(value, encodingOrOffset)\n  }\n\n  if (ArrayBuffer.isView(value)) {\n    return fromArrayView(value)\n  }\n\n  if (value == null) {\n    throw new TypeError(\n      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n      'or Array-like Object. Received type ' + (typeof value)\n    )\n  }\n\n  if (isInstance(value, ArrayBuffer) ||\n      (value && isInstance(value.buffer, ArrayBuffer))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof SharedArrayBuffer !== 'undefined' &&\n      (isInstance(value, SharedArrayBuffer) ||\n      (value && isInstance(value.buffer, SharedArrayBuffer)))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'number') {\n    throw new TypeError(\n      'The \"value\" argument must not be of type number. Received type number'\n    )\n  }\n\n  const valueOf = value.valueOf && value.valueOf()\n  if (valueOf != null && valueOf !== value) {\n    return Buffer.from(valueOf, encodingOrOffset, length)\n  }\n\n  const b = fromObject(value)\n  if (b) return b\n\n  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&\n      typeof value[Symbol.toPrimitive] === 'function') {\n    return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length)\n  }\n\n  throw new TypeError(\n    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n    'or Array-like Object. Received type ' + (typeof value)\n  )\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(value, encodingOrOffset, length)\n}\n\n// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n// https://github.com/feross/buffer/pull/148\nObject.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)\nObject.setPrototypeOf(Buffer, Uint8Array)\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be of type number')\n  } else if (size < 0) {\n    throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"')\n  }\n}\n\nfunction alloc (size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpreted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(size).fill(fill, encoding)\n      : createBuffer(size).fill(fill)\n  }\n  return createBuffer(size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(size, fill, encoding)\n}\n\nfunction allocUnsafe (size) {\n  assertSize(size)\n  return createBuffer(size < 0 ? 0 : checked(size) | 0)\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(size)\n}\n\nfunction fromString (string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('Unknown encoding: ' + encoding)\n  }\n\n  const length = byteLength(string, encoding) | 0\n  let buf = createBuffer(length)\n\n  const actual = buf.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    buf = buf.slice(0, actual)\n  }\n\n  return buf\n}\n\nfunction fromArrayLike (array) {\n  const length = array.length < 0 ? 0 : checked(array.length) | 0\n  const buf = createBuffer(length)\n  for (let i = 0; i < length; i += 1) {\n    buf[i] = array[i] & 255\n  }\n  return buf\n}\n\nfunction fromArrayView (arrayView) {\n  if (isInstance(arrayView, Uint8Array)) {\n    const copy = new Uint8Array(arrayView)\n    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)\n  }\n  return fromArrayLike(arrayView)\n}\n\nfunction fromArrayBuffer (array, byteOffset, length) {\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\"offset\" is outside of buffer bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\"length\" is outside of buffer bounds')\n  }\n\n  let buf\n  if (byteOffset === undefined && length === undefined) {\n    buf = new Uint8Array(array)\n  } else if (length === undefined) {\n    buf = new Uint8Array(array, byteOffset)\n  } else {\n    buf = new Uint8Array(array, byteOffset, length)\n  }\n\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(buf, Buffer.prototype)\n\n  return buf\n}\n\nfunction fromObject (obj) {\n  if (Buffer.isBuffer(obj)) {\n    const len = checked(obj.length) | 0\n    const buf = createBuffer(len)\n\n    if (buf.length === 0) {\n      return buf\n    }\n\n    obj.copy(buf, 0, 0, len)\n    return buf\n  }\n\n  if (obj.length !== undefined) {\n    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\n      return createBuffer(0)\n    }\n    return fromArrayLike(obj)\n  }\n\n  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n    return fromArrayLike(obj.data)\n  }\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= K_MAX_LENGTH) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return b != null && b._isBuffer === true &&\n    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false\n}\n\nBuffer.compare = function compare (a, b) {\n  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)\n  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError(\n      'The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array'\n    )\n  }\n\n  if (a === b) return 0\n\n  let x = a.length\n  let y = b.length\n\n  for (let i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!Array.isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  let i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  const buffer = Buffer.allocUnsafe(length)\n  let pos = 0\n  for (i = 0; i < list.length; ++i) {\n    let buf = list[i]\n    if (isInstance(buf, Uint8Array)) {\n      if (pos + buf.length > buffer.length) {\n        if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf)\n        buf.copy(buffer, pos)\n      } else {\n        Uint8Array.prototype.set.call(\n          buffer,\n          buf,\n          pos\n        )\n      }\n    } else if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    } else {\n      buf.copy(buffer, pos)\n    }\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    throw new TypeError(\n      'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. ' +\n      'Received type ' + typeof string\n    )\n  }\n\n  const len = string.length\n  const mustMatch = (arguments.length > 2 && arguments[2] === true)\n  if (!mustMatch && len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  let loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) {\n          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8\n        }\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  let loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n// to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n// reliably in a browserify context because there could be multiple different\n// copies of the 'buffer' package in use. This method works even for Buffer\n// instances that were created from another copy of the `buffer` package.\n// See: https://github.com/feross/buffer/issues/154\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  const i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  const len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (let i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  const len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (let i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  const len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (let i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  const length = this.length\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.toLocaleString = Buffer.prototype.toString\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  let str = ''\n  const max = exports.INSPECT_MAX_BYTES\n  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()\n  if (this.length > max) str += ' ... '\n  return '<Buffer ' + str + '>'\n}\nif (customInspectSymbol) {\n  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (isInstance(target, Uint8Array)) {\n    target = Buffer.from(target, target.offset, target.byteLength)\n  }\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError(\n      'The \"target\" argument must be one of type Buffer or Uint8Array. ' +\n      'Received type ' + (typeof target)\n    )\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  let x = thisEnd - thisStart\n  let y = end - start\n  const len = Math.min(x, y)\n\n  const thisCopy = this.slice(thisStart, thisEnd)\n  const targetCopy = target.slice(start, end)\n\n  for (let i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset // Coerce to Number.\n  if (numberIsNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  let indexSize = 1\n  let arrLength = arr.length\n  let valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  let i\n  if (dir) {\n    let foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      let found = true\n      for (let j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  const remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  const strLen = string.length\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  let i\n  for (i = 0; i < length; ++i) {\n    const parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (numberIsNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset >>> 0\n    if (isFinite(length)) {\n      length = length >>> 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  const remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  let loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return asciiWrite(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  const res = []\n\n  let i = start\n  while (i < end) {\n    const firstByte = buf[i]\n    let codePoint = null\n    let bytesPerSequence = (firstByte > 0xEF)\n      ? 4\n      : (firstByte > 0xDF)\n          ? 3\n          : (firstByte > 0xBF)\n              ? 2\n              : 1\n\n    if (i + bytesPerSequence <= end) {\n      let secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nconst MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  const len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  let res = ''\n  let i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  let ret = ''\n  end = Math.min(buf.length, end)\n\n  for (let i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  let ret = ''\n  end = Math.min(buf.length, end)\n\n  for (let i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  const len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  let out = ''\n  for (let i = start; i < end; ++i) {\n    out += hexSliceLookupTable[buf[i]]\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  const bytes = buf.slice(start, end)\n  let res = ''\n  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)\n  for (let i = 0; i < bytes.length - 1; i += 2) {\n    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  const len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  const newBuf = this.subarray(start, end)\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(newBuf, Buffer.prototype)\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUintLE =\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let val = this[offset]\n  let mul = 1\n  let i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUintBE =\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  let val = this[offset + --byteLength]\n  let mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUint8 =\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUint16LE =\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUint16BE =\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUint32LE =\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUint32BE =\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const lo = first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24\n\n  const hi = this[++offset] +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    last * 2 ** 24\n\n  return BigInt(lo) + (BigInt(hi) << BigInt(32))\n})\n\nBuffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const hi = first * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset]\n\n  const lo = this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last\n\n  return (BigInt(hi) << BigInt(32)) + BigInt(lo)\n})\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let val = this[offset]\n  let mul = 1\n  let i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let i = byteLength\n  let mul = 1\n  let val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  const val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  const val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const val = this[offset + 4] +\n    this[offset + 5] * 2 ** 8 +\n    this[offset + 6] * 2 ** 16 +\n    (last << 24) // Overflow\n\n  return (BigInt(val) << BigInt(32)) +\n    BigInt(first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24)\n})\n\nBuffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const val = (first << 24) + // Overflow\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset]\n\n  return (BigInt(val) << BigInt(32)) +\n    BigInt(this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last)\n})\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUintLE =\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  let mul = 1\n  let i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUintBE =\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  let i = byteLength - 1\n  let mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUint8 =\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeUint16LE =\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint16BE =\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint32LE =\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset + 3] = (value >>> 24)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 1] = (value >>> 8)\n  this[offset] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeUint32BE =\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nfunction wrtBigUInt64LE (buf, value, offset, min, max) {\n  checkIntBI(value, min, max, buf, offset, 7)\n\n  let lo = Number(value & BigInt(0xffffffff))\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  return offset\n}\n\nfunction wrtBigUInt64BE (buf, value, offset, min, max) {\n  checkIntBI(value, min, max, buf, offset, 7)\n\n  let lo = Number(value & BigInt(0xffffffff))\n  buf[offset + 7] = lo\n  lo = lo >> 8\n  buf[offset + 6] = lo\n  lo = lo >> 8\n  buf[offset + 5] = lo\n  lo = lo >> 8\n  buf[offset + 4] = lo\n  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))\n  buf[offset + 3] = hi\n  hi = hi >> 8\n  buf[offset + 2] = hi\n  hi = hi >> 8\n  buf[offset + 1] = hi\n  hi = hi >> 8\n  buf[offset] = hi\n  return offset + 8\n}\n\nBuffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE (value, offset = 0) {\n  return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n})\n\nBuffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE (value, offset = 0) {\n  return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n})\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    const limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  let i = 0\n  let mul = 1\n  let sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    const limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  let i = byteLength - 1\n  let mul = 1\n  let sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 3] = (value >>> 24)\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE (value, offset = 0) {\n  return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n})\n\nBuffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE (value, offset = 0) {\n  return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n})\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  const len = end - start\n\n  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {\n    // Use built-in when available, missing from IE11\n    this.copyWithin(targetStart, start, end)\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, end),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n    if (val.length === 1) {\n      const code = val.charCodeAt(0)\n      if ((encoding === 'utf8' && code < 128) ||\n          encoding === 'latin1') {\n        // Fast path: If `val` fits into a single byte, use that numeric value.\n        val = code\n      }\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  } else if (typeof val === 'boolean') {\n    val = Number(val)\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  let i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    const bytes = Buffer.isBuffer(val)\n      ? val\n      : Buffer.from(val, encoding)\n    const len = bytes.length\n    if (len === 0) {\n      throw new TypeError('The value \"' + val +\n        '\" is invalid for argument \"value\"')\n    }\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// CUSTOM ERRORS\n// =============\n\n// Simplified versions from Node, changed for Buffer-only usage\nconst errors = {}\nfunction E (sym, getMessage, Base) {\n  errors[sym] = class NodeError extends Base {\n    constructor () {\n      super()\n\n      Object.defineProperty(this, 'message', {\n        value: getMessage.apply(this, arguments),\n        writable: true,\n        configurable: true\n      })\n\n      // Add the error code to the name to include it in the stack trace.\n      this.name = `${this.name} [${sym}]`\n      // Access the stack to generate the error message including the error code\n      // from the name.\n      this.stack // eslint-disable-line no-unused-expressions\n      // Reset the name to the actual name.\n      delete this.name\n    }\n\n    get code () {\n      return sym\n    }\n\n    set code (value) {\n      Object.defineProperty(this, 'code', {\n        configurable: true,\n        enumerable: true,\n        value,\n        writable: true\n      })\n    }\n\n    toString () {\n      return `${this.name} [${sym}]: ${this.message}`\n    }\n  }\n}\n\nE('ERR_BUFFER_OUT_OF_BOUNDS',\n  function (name) {\n    if (name) {\n      return `${name} is outside of buffer bounds`\n    }\n\n    return 'Attempt to access memory outside buffer bounds'\n  }, RangeError)\nE('ERR_INVALID_ARG_TYPE',\n  function (name, actual) {\n    return `The \"${name}\" argument must be of type number. Received type ${typeof actual}`\n  }, TypeError)\nE('ERR_OUT_OF_RANGE',\n  function (str, range, input) {\n    let msg = `The value of \"${str}\" is out of range.`\n    let received = input\n    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {\n      received = addNumericalSeparator(String(input))\n    } else if (typeof input === 'bigint') {\n      received = String(input)\n      if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {\n        received = addNumericalSeparator(received)\n      }\n      received += 'n'\n    }\n    msg += ` It must be ${range}. Received ${received}`\n    return msg\n  }, RangeError)\n\nfunction addNumericalSeparator (val) {\n  let res = ''\n  let i = val.length\n  const start = val[0] === '-' ? 1 : 0\n  for (; i >= start + 4; i -= 3) {\n    res = `_${val.slice(i - 3, i)}${res}`\n  }\n  return `${val.slice(0, i)}${res}`\n}\n\n// CHECK FUNCTIONS\n// ===============\n\nfunction checkBounds (buf, offset, byteLength) {\n  validateNumber(offset, 'offset')\n  if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {\n    boundsError(offset, buf.length - (byteLength + 1))\n  }\n}\n\nfunction checkIntBI (value, min, max, buf, offset, byteLength) {\n  if (value > max || value < min) {\n    const n = typeof min === 'bigint' ? 'n' : ''\n    let range\n    if (byteLength > 3) {\n      if (min === 0 || min === BigInt(0)) {\n        range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`\n      } else {\n        range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` +\n                `${(byteLength + 1) * 8 - 1}${n}`\n      }\n    } else {\n      range = `>= ${min}${n} and <= ${max}${n}`\n    }\n    throw new errors.ERR_OUT_OF_RANGE('value', range, value)\n  }\n  checkBounds(buf, offset, byteLength)\n}\n\nfunction validateNumber (value, name) {\n  if (typeof value !== 'number') {\n    throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value)\n  }\n}\n\nfunction boundsError (value, length, type) {\n  if (Math.floor(value) !== value) {\n    validateNumber(value, type)\n    throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value)\n  }\n\n  if (length < 0) {\n    throw new errors.ERR_BUFFER_OUT_OF_BOUNDS()\n  }\n\n  throw new errors.ERR_OUT_OF_RANGE(type || 'offset',\n                                    `>= ${type ? 1 : 0} and <= ${length}`,\n                                    value)\n}\n\n// HELPER FUNCTIONS\n// ================\n\nconst INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node takes equal signs as end of the Base64 encoding\n  str = str.split('=')[0]\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = str.trim().replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  let codePoint\n  const length = string.length\n  let leadSurrogate = null\n  const bytes = []\n\n  for (let i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  const byteArray = []\n  for (let i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  let c, hi, lo\n  const byteArray = []\n  for (let i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  let i\n  for (i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\n// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass\n// the `instanceof` check but they should be treated as of that type.\n// See: https://github.com/feross/buffer/issues/166\nfunction isInstance (obj, type) {\n  return obj instanceof type ||\n    (obj != null && obj.constructor != null && obj.constructor.name != null &&\n      obj.constructor.name === type.name)\n}\nfunction numberIsNaN (obj) {\n  // For IE11 support\n  return obj !== obj // eslint-disable-line no-self-compare\n}\n\n// Create lookup table for `toString('hex')`\n// See: https://github.com/feross/buffer/issues/219\nconst hexSliceLookupTable = (function () {\n  const alphabet = '0123456789abcdef'\n  const table = new Array(256)\n  for (let i = 0; i < 16; ++i) {\n    const i16 = i * 16\n    for (let j = 0; j < 16; ++j) {\n      table[i16 + j] = alphabet[i] + alphabet[j]\n    }\n  }\n  return table\n})()\n\n// Return not function with Error if BigInt not supported\nfunction defineBigIntMethod (fn) {\n  return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn\n}\n\nfunction BufferBigIntNotDefined () {\n  throw new Error('BigInt not supported')\n}\n","import { Color3 } from \"@babylonjs/core/Maths/math.color.js\";\nimport { Texture } from \"@babylonjs/core/Materials/Textures/texture.js\";\nimport { StandardMaterial } from \"@babylonjs/core/Materials/standardMaterial.js\";\n/**\n * Class reading and parsing the MTL file bundled with the obj file.\n */\nexport class MTLFileLoader {\n    constructor() {\n        /**\n         * All material loaded from the mtl will be set here\n         */\n        this.materials = [];\n    }\n    /**\n     * This function will read the mtl file and create each material described inside\n     * This function could be improve by adding :\n     * -some component missing (Ni, Tf...)\n     * -including the specific options available\n     *\n     * @param scene defines the scene the material will be created in\n     * @param data defines the mtl data to parse\n     * @param rootUrl defines the rooturl to use in order to load relative dependencies\n     * @param assetContainer defines the asset container to store the material in (can be null)\n     */\n    parseMTL(scene, data, rootUrl, assetContainer) {\n        if (data instanceof ArrayBuffer) {\n            return;\n        }\n        //Split the lines from the file\n        const lines = data.split(\"\\n\");\n        // whitespace char ie: [ \\t\\r\\n\\f]\n        const delimiter_pattern = /\\s+/;\n        //Array with RGB colors\n        let color;\n        //New material\n        let material = null;\n        //Look at each line\n        for (let i = 0; i < lines.length; i++) {\n            const line = lines[i].trim();\n            // Blank line or comment\n            if (line.length === 0 || line.charAt(0) === \"#\") {\n                continue;\n            }\n            //Get the first parameter (keyword)\n            const pos = line.indexOf(\" \");\n            let key = pos >= 0 ? line.substring(0, pos) : line;\n            key = key.toLowerCase();\n            //Get the data following the key\n            const value = pos >= 0 ? line.substring(pos + 1).trim() : \"\";\n            //This mtl keyword will create the new material\n            if (key === \"newmtl\") {\n                //Check if it is the first material.\n                // Materials specifications are described after this keyword.\n                if (material) {\n                    //Add the previous material in the material array.\n                    this.materials.push(material);\n                }\n                //Create a new material.\n                // value is the name of the material read in the mtl file\n                scene._blockEntityCollection = !!assetContainer;\n                material = new StandardMaterial(value, scene);\n                material._parentContainer = assetContainer;\n                scene._blockEntityCollection = false;\n            }\n            else if (key === \"kd\" && material) {\n                // Diffuse color (color under white light) using RGB values\n                //value  = \"r g b\"\n                color = value.split(delimiter_pattern, 3).map(parseFloat);\n                //color = [r,g,b]\n                //Set tghe color into the material\n                material.diffuseColor = Color3.FromArray(color);\n            }\n            else if (key === \"ka\" && material) {\n                // Ambient color (color under shadow) using RGB values\n                //value = \"r g b\"\n                color = value.split(delimiter_pattern, 3).map(parseFloat);\n                //color = [r,g,b]\n                //Set tghe color into the material\n                material.ambientColor = Color3.FromArray(color);\n            }\n            else if (key === \"ks\" && material) {\n                // Specular color (color when light is reflected from shiny surface) using RGB values\n                //value = \"r g b\"\n                color = value.split(delimiter_pattern, 3).map(parseFloat);\n                //color = [r,g,b]\n                //Set the color into the material\n                material.specularColor = Color3.FromArray(color);\n            }\n            else if (key === \"ke\" && material) {\n                // Emissive color using RGB values\n                color = value.split(delimiter_pattern, 3).map(parseFloat);\n                material.emissiveColor = Color3.FromArray(color);\n            }\n            else if (key === \"ns\" && material) {\n                //value = \"Integer\"\n                material.specularPower = parseFloat(value);\n            }\n            else if (key === \"d\" && material) {\n                //d is dissolve for current material. It mean alpha for BABYLON\n                material.alpha = parseFloat(value);\n                //Texture\n                //This part can be improved by adding the possible options of texture\n            }\n            else if (key === \"map_ka\" && material) {\n                // ambient texture map with a loaded image\n                //We must first get the folder of the image\n                material.ambientTexture = MTLFileLoader._GetTexture(rootUrl, value, scene);\n            }\n            else if (key === \"map_kd\" && material) {\n                // Diffuse texture map with a loaded image\n                material.diffuseTexture = MTLFileLoader._GetTexture(rootUrl, value, scene);\n            }\n            else if (key === \"map_ks\" && material) {\n                // Specular texture map with a loaded image\n                //We must first get the folder of the image\n                material.specularTexture = MTLFileLoader._GetTexture(rootUrl, value, scene);\n            }\n            else if (key === \"map_ns\") {\n                //Specular\n                //Specular highlight component\n                //We must first get the folder of the image\n                //\n                //Not supported by BABYLON\n                //\n                //    continue;\n            }\n            else if (key === \"map_bump\" && material) {\n                //The bump texture\n                const values = value.split(delimiter_pattern);\n                const bumpMultiplierIndex = values.indexOf(\"-bm\");\n                let bumpMultiplier = null;\n                if (bumpMultiplierIndex >= 0) {\n                    bumpMultiplier = values[bumpMultiplierIndex + 1];\n                    values.splice(bumpMultiplierIndex, 2); // remove\n                }\n                material.bumpTexture = MTLFileLoader._GetTexture(rootUrl, values.join(\" \"), scene);\n                if (material.bumpTexture && bumpMultiplier !== null) {\n                    material.bumpTexture.level = parseFloat(bumpMultiplier);\n                }\n            }\n            else if (key === \"map_d\" && material) {\n                // The dissolve of the material\n                material.opacityTexture = MTLFileLoader._GetTexture(rootUrl, value, scene);\n                //Options for illumination\n            }\n            else if (key === \"illum\") {\n                //Illumination\n                if (value === \"0\") {\n                    //That mean Kd == Kd\n                }\n                else if (value === \"1\") {\n                    //Color on and Ambient on\n                }\n                else if (value === \"2\") {\n                    //Highlight on\n                }\n                else if (value === \"3\") {\n                    //Reflection on and Ray trace on\n                }\n                else if (value === \"4\") {\n                    //Transparency: Glass on, Reflection: Ray trace on\n                }\n                else if (value === \"5\") {\n                    //Reflection: Fresnel on and Ray trace on\n                }\n                else if (value === \"6\") {\n                    //Transparency: Refraction on, Reflection: Fresnel off and Ray trace on\n                }\n                else if (value === \"7\") {\n                    //Transparency: Refraction on, Reflection: Fresnel on and Ray trace on\n                }\n                else if (value === \"8\") {\n                    //Reflection on and Ray trace off\n                }\n                else if (value === \"9\") {\n                    //Transparency: Glass on, Reflection: Ray trace off\n                }\n                else if (value === \"10\") {\n                    //Casts shadows onto invisible surfaces\n                }\n            }\n            else {\n                // console.log(\"Unhandled expression at line : \" + i +'\\n' + \"with value : \" + line);\n            }\n        }\n        //At the end of the file, add the last material\n        if (material) {\n            this.materials.push(material);\n        }\n    }\n    /**\n     * Gets the texture for the material.\n     *\n     * If the material is imported from input file,\n     * We sanitize the url to ensure it takes the texture from aside the material.\n     *\n     * @param rootUrl The root url to load from\n     * @param value The value stored in the mtl\n     * @param scene\n     * @returns The Texture\n     */\n    static _GetTexture(rootUrl, value, scene) {\n        if (!value) {\n            return null;\n        }\n        let url = rootUrl;\n        // Load from input file.\n        if (rootUrl === \"file:\") {\n            let lastDelimiter = value.lastIndexOf(\"\\\\\");\n            if (lastDelimiter === -1) {\n                lastDelimiter = value.lastIndexOf(\"/\");\n            }\n            if (lastDelimiter > -1) {\n                url += value.substr(lastDelimiter + 1);\n            }\n            else {\n                url += value;\n            }\n        }\n        // Not from input file.\n        else {\n            url += value;\n        }\n        return new Texture(url, scene, false, MTLFileLoader.INVERT_TEXTURE_Y);\n    }\n}\n/**\n * Invert Y-Axis of referenced textures on load\n */\nMTLFileLoader.INVERT_TEXTURE_Y = true;\n//# sourceMappingURL=mtlFileLoader.js.map","import { VertexBuffer } from \"@babylonjs/core/Buffers/buffer.js\";\nimport { StandardMaterial } from \"@babylonjs/core/Materials/standardMaterial.js\";\nimport { Color3, Color4 } from \"@babylonjs/core/Maths/math.color.js\";\nimport { Vector2, Vector3 } from \"@babylonjs/core/Maths/math.vector.js\";\nimport { Geometry } from \"@babylonjs/core/Meshes/geometry.js\";\nimport { Mesh } from \"@babylonjs/core/Meshes/mesh.js\";\nimport { VertexData } from \"@babylonjs/core/Meshes/mesh.vertexData.js\";\n/**\n * Class used to load mesh data from OBJ content\n */\nexport class SolidParser {\n    /**\n     * Creates a new SolidParser\n     * @param materialToUse defines the array to fill with the list of materials to use (it will be filled by the parse function)\n     * @param babylonMeshesArray defines the array to fill with the list of loaded meshes (it will be filled by the parse function)\n     * @param loadingOptions defines the loading options to use\n     */\n    constructor(materialToUse, babylonMeshesArray, loadingOptions) {\n        this._positions = []; //values for the positions of vertices\n        this._normals = []; //Values for the normals\n        this._uvs = []; //Values for the textures\n        this._colors = [];\n        this._meshesFromObj = []; //[mesh] Contains all the obj meshes\n        this._indicesForBabylon = []; //The list of indices for VertexData\n        this._wrappedPositionForBabylon = []; //The list of position in vectors\n        this._wrappedUvsForBabylon = []; //Array with all value of uvs to match with the indices\n        this._wrappedColorsForBabylon = []; // Array with all color values to match with the indices\n        this._wrappedNormalsForBabylon = []; //Array with all value of normals to match with the indices\n        this._tuplePosNorm = []; //Create a tuple with indice of Position, Normal, UV  [pos, norm, uvs]\n        this._curPositionInIndices = 0;\n        this._hasMeshes = false; //Meshes are defined in the file\n        this._unwrappedPositionsForBabylon = []; //Value of positionForBabylon w/o Vector3() [x,y,z]\n        this._unwrappedColorsForBabylon = []; // Value of colorForBabylon w/o Color4() [r,g,b,a]\n        this._unwrappedNormalsForBabylon = []; //Value of normalsForBabylon w/o Vector3()  [x,y,z]\n        this._unwrappedUVForBabylon = []; //Value of uvsForBabylon w/o Vector3()      [x,y,z]\n        this._triangles = []; //Indices from new triangles coming from polygons\n        this._materialNameFromObj = \"\"; //The name of the current material\n        this._objMeshName = \"\"; //The name of the current obj mesh\n        this._increment = 1; //Id for meshes created by the multimaterial\n        this._isFirstMaterial = true;\n        this._grayColor = new Color4(0.5, 0.5, 0.5, 1);\n        this._materialToUse = materialToUse;\n        this._babylonMeshesArray = babylonMeshesArray;\n        this._loadingOptions = loadingOptions;\n    }\n    /**\n     * Search for obj in the given array.\n     * This function is called to check if a couple of data already exists in an array.\n     *\n     * If found, returns the index of the founded tuple index. Returns -1 if not found\n     * @param arr Array<{ normals: Array<number>, idx: Array<number> }>\n     * @param obj Array<number>\n     * @returns {boolean}\n     */\n    _isInArray(arr, obj) {\n        if (!arr[obj[0]]) {\n            arr[obj[0]] = { normals: [], idx: [] };\n        }\n        const idx = arr[obj[0]].normals.indexOf(obj[1]);\n        return idx === -1 ? -1 : arr[obj[0]].idx[idx];\n    }\n    _isInArrayUV(arr, obj) {\n        if (!arr[obj[0]]) {\n            arr[obj[0]] = { normals: [], idx: [], uv: [] };\n        }\n        const idx = arr[obj[0]].normals.indexOf(obj[1]);\n        if (idx != 1 && obj[2] === arr[obj[0]].uv[idx]) {\n            return arr[obj[0]].idx[idx];\n        }\n        return -1;\n    }\n    /**\n     * This function set the data for each triangle.\n     * Data are position, normals and uvs\n     * If a tuple of (position, normal) is not set, add the data into the corresponding array\n     * If the tuple already exist, add only their indice\n     *\n     * @param indicePositionFromObj Integer The index in positions array\n     * @param indiceUvsFromObj Integer The index in uvs array\n     * @param indiceNormalFromObj Integer The index in normals array\n     * @param positionVectorFromOBJ Vector3 The value of position at index objIndice\n     * @param textureVectorFromOBJ Vector3 The value of uvs\n     * @param normalsVectorFromOBJ Vector3 The value of normals at index objNormale\n     * @param positionColorsFromOBJ\n     */\n    _setData(indicePositionFromObj, indiceUvsFromObj, indiceNormalFromObj, positionVectorFromOBJ, textureVectorFromOBJ, normalsVectorFromOBJ, positionColorsFromOBJ) {\n        //Check if this tuple already exists in the list of tuples\n        let _index;\n        if (this._loadingOptions.optimizeWithUV) {\n            _index = this._isInArrayUV(this._tuplePosNorm, [indicePositionFromObj, indiceNormalFromObj, indiceUvsFromObj]);\n        }\n        else {\n            _index = this._isInArray(this._tuplePosNorm, [indicePositionFromObj, indiceNormalFromObj]);\n        }\n        //If it not exists\n        if (_index === -1) {\n            //Add an new indice.\n            //The array of indices is only an array with his length equal to the number of triangles - 1.\n            //We add vertices data in this order\n            this._indicesForBabylon.push(this._wrappedPositionForBabylon.length);\n            //Push the position of vertice for Babylon\n            //Each element is a Vector3(x,y,z)\n            this._wrappedPositionForBabylon.push(positionVectorFromOBJ);\n            //Push the uvs for Babylon\n            //Each element is a Vector3(u,v)\n            this._wrappedUvsForBabylon.push(textureVectorFromOBJ);\n            //Push the normals for Babylon\n            //Each element is a Vector3(x,y,z)\n            this._wrappedNormalsForBabylon.push(normalsVectorFromOBJ);\n            if (positionColorsFromOBJ !== undefined) {\n                //Push the colors for Babylon\n                //Each element is a BABYLON.Color4(r,g,b,a)\n                this._wrappedColorsForBabylon.push(positionColorsFromOBJ);\n            }\n            //Add the tuple in the comparison list\n            this._tuplePosNorm[indicePositionFromObj].normals.push(indiceNormalFromObj);\n            this._tuplePosNorm[indicePositionFromObj].idx.push(this._curPositionInIndices++);\n            if (this._loadingOptions.optimizeWithUV) {\n                this._tuplePosNorm[indicePositionFromObj].uv.push(indiceUvsFromObj);\n            }\n        }\n        else {\n            //The tuple already exists\n            //Add the index of the already existing tuple\n            //At this index we can get the value of position, normal, color and uvs of vertex\n            this._indicesForBabylon.push(_index);\n        }\n    }\n    /**\n     * Transform Vector() and BABYLON.Color() objects into numbers in an array\n     */\n    _unwrapData() {\n        //Every array has the same length\n        for (let l = 0; l < this._wrappedPositionForBabylon.length; l++) {\n            //Push the x, y, z values of each element in the unwrapped array\n            this._unwrappedPositionsForBabylon.push(this._wrappedPositionForBabylon[l].x, this._wrappedPositionForBabylon[l].y, this._wrappedPositionForBabylon[l].z);\n            this._unwrappedNormalsForBabylon.push(this._wrappedNormalsForBabylon[l].x, this._wrappedNormalsForBabylon[l].y, this._wrappedNormalsForBabylon[l].z);\n            this._unwrappedUVForBabylon.push(this._wrappedUvsForBabylon[l].x, this._wrappedUvsForBabylon[l].y); //z is an optional value not supported by BABYLON\n            if (this._loadingOptions.importVertexColors) {\n                //Push the r, g, b, a values of each element in the unwrapped array\n                this._unwrappedColorsForBabylon.push(this._wrappedColorsForBabylon[l].r, this._wrappedColorsForBabylon[l].g, this._wrappedColorsForBabylon[l].b, this._wrappedColorsForBabylon[l].a);\n            }\n        }\n        // Reset arrays for the next new meshes\n        this._wrappedPositionForBabylon.length = 0;\n        this._wrappedNormalsForBabylon.length = 0;\n        this._wrappedUvsForBabylon.length = 0;\n        this._wrappedColorsForBabylon.length = 0;\n        this._tuplePosNorm.length = 0;\n        this._curPositionInIndices = 0;\n    }\n    /**\n     * Create triangles from polygons\n     * It is important to notice that a triangle is a polygon\n     * We get 5 patterns of face defined in OBJ File :\n     * facePattern1 = [\"1\",\"2\",\"3\",\"4\",\"5\",\"6\"]\n     * facePattern2 = [\"1/1\",\"2/2\",\"3/3\",\"4/4\",\"5/5\",\"6/6\"]\n     * facePattern3 = [\"1/1/1\",\"2/2/2\",\"3/3/3\",\"4/4/4\",\"5/5/5\",\"6/6/6\"]\n     * facePattern4 = [\"1//1\",\"2//2\",\"3//3\",\"4//4\",\"5//5\",\"6//6\"]\n     * facePattern5 = [\"-1/-1/-1\",\"-2/-2/-2\",\"-3/-3/-3\",\"-4/-4/-4\",\"-5/-5/-5\",\"-6/-6/-6\"]\n     * Each pattern is divided by the same method\n     * @param faces Array[String] The indices of elements\n     * @param v Integer The variable to increment\n     */\n    _getTriangles(faces, v) {\n        //Work for each element of the array\n        for (let faceIndex = v; faceIndex < faces.length - 1; faceIndex++) {\n            //Add on the triangle variable the indexes to obtain triangles\n            this._triangles.push(faces[0], faces[faceIndex], faces[faceIndex + 1]);\n        }\n        //Result obtained after 2 iterations:\n        //Pattern1 => triangle = [\"1\",\"2\",\"3\",\"1\",\"3\",\"4\"];\n        //Pattern2 => triangle = [\"1/1\",\"2/2\",\"3/3\",\"1/1\",\"3/3\",\"4/4\"];\n        //Pattern3 => triangle = [\"1/1/1\",\"2/2/2\",\"3/3/3\",\"1/1/1\",\"3/3/3\",\"4/4/4\"];\n        //Pattern4 => triangle = [\"1//1\",\"2//2\",\"3//3\",\"1//1\",\"3//3\",\"4//4\"];\n        //Pattern5 => triangle = [\"-1/-1/-1\",\"-2/-2/-2\",\"-3/-3/-3\",\"-1/-1/-1\",\"-3/-3/-3\",\"-4/-4/-4\"];\n    }\n    /**\n     * Create triangles and push the data for each polygon for the pattern 1\n     * In this pattern we get vertice positions\n     * @param face\n     * @param v\n     */\n    _setDataForCurrentFaceWithPattern1(face, v) {\n        //Get the indices of triangles for each polygon\n        this._getTriangles(face, v);\n        //For each element in the triangles array.\n        //This var could contains 1 to an infinity of triangles\n        for (let k = 0; k < this._triangles.length; k++) {\n            // Set position indice\n            const indicePositionFromObj = parseInt(this._triangles[k]) - 1;\n            this._setData(indicePositionFromObj, 0, 0, // In the pattern 1, normals and uvs are not defined\n            this._positions[indicePositionFromObj], // Get the vectors data\n            Vector2.Zero(), Vector3.Up(), // Create default vectors\n            this._loadingOptions.importVertexColors ? this._colors[indicePositionFromObj] : undefined);\n        }\n        //Reset variable for the next line\n        this._triangles.length = 0;\n    }\n    /**\n     * Create triangles and push the data for each polygon for the pattern 2\n     * In this pattern we get vertice positions and uvsu\n     * @param face\n     * @param v\n     */\n    _setDataForCurrentFaceWithPattern2(face, v) {\n        //Get the indices of triangles for each polygon\n        this._getTriangles(face, v);\n        for (let k = 0; k < this._triangles.length; k++) {\n            //triangle[k] = \"1/1\"\n            //Split the data for getting position and uv\n            const point = this._triangles[k].split(\"/\"); // [\"1\", \"1\"]\n            //Set position indice\n            const indicePositionFromObj = parseInt(point[0]) - 1;\n            //Set uv indice\n            const indiceUvsFromObj = parseInt(point[1]) - 1;\n            this._setData(indicePositionFromObj, indiceUvsFromObj, 0, //Default value for normals\n            this._positions[indicePositionFromObj], //Get the values for each element\n            this._uvs[indiceUvsFromObj], Vector3.Up(), //Default value for normals\n            this._loadingOptions.importVertexColors ? this._colors[indicePositionFromObj] : undefined);\n        }\n        //Reset variable for the next line\n        this._triangles.length = 0;\n    }\n    /**\n     * Create triangles and push the data for each polygon for the pattern 3\n     * In this pattern we get vertice positions, uvs and normals\n     * @param face\n     * @param v\n     */\n    _setDataForCurrentFaceWithPattern3(face, v) {\n        //Get the indices of triangles for each polygon\n        this._getTriangles(face, v);\n        for (let k = 0; k < this._triangles.length; k++) {\n            //triangle[k] = \"1/1/1\"\n            //Split the data for getting position, uv, and normals\n            const point = this._triangles[k].split(\"/\"); // [\"1\", \"1\", \"1\"]\n            // Set position indice\n            const indicePositionFromObj = parseInt(point[0]) - 1;\n            // Set uv indice\n            const indiceUvsFromObj = parseInt(point[1]) - 1;\n            // Set normal indice\n            const indiceNormalFromObj = parseInt(point[2]) - 1;\n            this._setData(indicePositionFromObj, indiceUvsFromObj, indiceNormalFromObj, this._positions[indicePositionFromObj], this._uvs[indiceUvsFromObj], this._normals[indiceNormalFromObj] //Set the vector for each component\n            );\n        }\n        //Reset variable for the next line\n        this._triangles.length = 0;\n    }\n    /**\n     * Create triangles and push the data for each polygon for the pattern 4\n     * In this pattern we get vertice positions and normals\n     * @param face\n     * @param v\n     */\n    _setDataForCurrentFaceWithPattern4(face, v) {\n        this._getTriangles(face, v);\n        for (let k = 0; k < this._triangles.length; k++) {\n            //triangle[k] = \"1//1\"\n            //Split the data for getting position and normals\n            const point = this._triangles[k].split(\"//\"); // [\"1\", \"1\"]\n            // We check indices, and normals\n            const indicePositionFromObj = parseInt(point[0]) - 1;\n            const indiceNormalFromObj = parseInt(point[1]) - 1;\n            this._setData(indicePositionFromObj, 1, //Default value for uv\n            indiceNormalFromObj, this._positions[indicePositionFromObj], //Get each vector of data\n            Vector2.Zero(), this._normals[indiceNormalFromObj], this._loadingOptions.importVertexColors ? this._colors[indicePositionFromObj] : undefined);\n        }\n        //Reset variable for the next line\n        this._triangles.length = 0;\n    }\n    /*\n     * Create triangles and push the data for each polygon for the pattern 3\n     * In this pattern we get vertice positions, uvs and normals\n     * @param face\n     * @param v\n     */\n    _setDataForCurrentFaceWithPattern5(face, v) {\n        //Get the indices of triangles for each polygon\n        this._getTriangles(face, v);\n        for (let k = 0; k < this._triangles.length; k++) {\n            //triangle[k] = \"-1/-1/-1\"\n            //Split the data for getting position, uv, and normals\n            const point = this._triangles[k].split(\"/\"); // [\"-1\", \"-1\", \"-1\"]\n            // Set position indice\n            const indicePositionFromObj = this._positions.length + parseInt(point[0]);\n            // Set uv indice\n            const indiceUvsFromObj = this._uvs.length + parseInt(point[1]);\n            // Set normal indice\n            const indiceNormalFromObj = this._normals.length + parseInt(point[2]);\n            this._setData(indicePositionFromObj, indiceUvsFromObj, indiceNormalFromObj, this._positions[indicePositionFromObj], this._uvs[indiceUvsFromObj], this._normals[indiceNormalFromObj], //Set the vector for each component\n            this._loadingOptions.importVertexColors ? this._colors[indicePositionFromObj] : undefined);\n        }\n        //Reset variable for the next line\n        this._triangles.length = 0;\n    }\n    _addPreviousObjMesh() {\n        //Check if it is not the first mesh. Otherwise we don't have data.\n        if (this._meshesFromObj.length > 0) {\n            //Get the previous mesh for applying the data about the faces\n            //=> in obj file, faces definition append after the name of the mesh\n            this._handledMesh = this._meshesFromObj[this._meshesFromObj.length - 1];\n            //Set the data into Array for the mesh\n            this._unwrapData();\n            // Reverse tab. Otherwise face are displayed in the wrong sens\n            this._indicesForBabylon.reverse();\n            //Set the information for the mesh\n            //Slice the array to avoid rewriting because of the fact this is the same var which be rewrited\n            this._handledMesh.indices = this._indicesForBabylon.slice();\n            this._handledMesh.positions = this._unwrappedPositionsForBabylon.slice();\n            this._handledMesh.normals = this._unwrappedNormalsForBabylon.slice();\n            this._handledMesh.uvs = this._unwrappedUVForBabylon.slice();\n            if (this._loadingOptions.importVertexColors) {\n                this._handledMesh.colors = this._unwrappedColorsForBabylon.slice();\n            }\n            //Reset the array for the next mesh\n            this._indicesForBabylon.length = 0;\n            this._unwrappedPositionsForBabylon.length = 0;\n            this._unwrappedColorsForBabylon.length = 0;\n            this._unwrappedNormalsForBabylon.length = 0;\n            this._unwrappedUVForBabylon.length = 0;\n        }\n    }\n    _optimizeNormals(mesh) {\n        const positions = mesh.getVerticesData(VertexBuffer.PositionKind);\n        const normals = mesh.getVerticesData(VertexBuffer.NormalKind);\n        const mapVertices = {};\n        if (!positions || !normals) {\n            return;\n        }\n        for (let i = 0; i < positions.length / 3; i++) {\n            const x = positions[i * 3 + 0];\n            const y = positions[i * 3 + 1];\n            const z = positions[i * 3 + 2];\n            const key = x + \"_\" + y + \"_\" + z;\n            let lst = mapVertices[key];\n            if (!lst) {\n                lst = [];\n                mapVertices[key] = lst;\n            }\n            lst.push(i);\n        }\n        const normal = new Vector3();\n        for (const key in mapVertices) {\n            const lst = mapVertices[key];\n            if (lst.length < 2) {\n                continue;\n            }\n            const v0Idx = lst[0];\n            for (let i = 1; i < lst.length; ++i) {\n                const vIdx = lst[i];\n                normals[v0Idx * 3 + 0] += normals[vIdx * 3 + 0];\n                normals[v0Idx * 3 + 1] += normals[vIdx * 3 + 1];\n                normals[v0Idx * 3 + 2] += normals[vIdx * 3 + 2];\n            }\n            normal.copyFromFloats(normals[v0Idx * 3 + 0], normals[v0Idx * 3 + 1], normals[v0Idx * 3 + 2]);\n            normal.normalize();\n            for (let i = 0; i < lst.length; ++i) {\n                const vIdx = lst[i];\n                normals[vIdx * 3 + 0] = normal.x;\n                normals[vIdx * 3 + 1] = normal.y;\n                normals[vIdx * 3 + 2] = normal.z;\n            }\n        }\n        mesh.setVerticesData(VertexBuffer.NormalKind, normals);\n    }\n    /**\n     * Function used to parse an OBJ string\n     * @param meshesNames defines the list of meshes to load (all if not defined)\n     * @param data defines the OBJ string\n     * @param scene defines the hosting scene\n     * @param assetContainer defines the asset container to load data in\n     * @param onFileToLoadFound defines a callback that will be called if a MTL file is found\n     */\n    parse(meshesNames, data, scene, assetContainer, onFileToLoadFound) {\n        var _a;\n        // Split the file into lines\n        const lines = data.split(\"\\n\");\n        // Look at each line\n        for (let i = 0; i < lines.length; i++) {\n            const line = lines[i].trim().replace(/\\s\\s/g, \" \");\n            let result;\n            // Comment or newLine\n            if (line.length === 0 || line.charAt(0) === \"#\") {\n                continue;\n                //Get information about one position possible for the vertices\n            }\n            else if (SolidParser.VertexPattern.test(line)) {\n                result = line.match(/[^ ]+/g); // match will return non-null due to passing regex pattern\n                // Value of result with line: \"v 1.0 2.0 3.0\"\n                // [\"v\", \"1.0\", \"2.0\", \"3.0\"]\n                // Create a Vector3 with the position x, y, z\n                this._positions.push(new Vector3(parseFloat(result[1]), parseFloat(result[2]), parseFloat(result[3])));\n                if (this._loadingOptions.importVertexColors) {\n                    if (result.length >= 7) {\n                        const r = parseFloat(result[4]);\n                        const g = parseFloat(result[5]);\n                        const b = parseFloat(result[6]);\n                        this._colors.push(new Color4(r > 1 ? r / 255 : r, g > 1 ? g / 255 : g, b > 1 ? b / 255 : b, result.length === 7 || result[7] === undefined ? 1 : parseFloat(result[7])));\n                    }\n                    else {\n                        // TODO: maybe push NULL and if all are NULL to skip (and remove grayColor var).\n                        this._colors.push(this._grayColor);\n                    }\n                }\n            }\n            else if ((result = SolidParser.NormalPattern.exec(line)) !== null) {\n                //Create a Vector3 with the normals x, y, z\n                //Value of result\n                // [\"vn 1.0 2.0 3.0\", \"1.0\", \"2.0\", \"3.0\"]\n                //Add the Vector in the list of normals\n                this._normals.push(new Vector3(parseFloat(result[1]), parseFloat(result[2]), parseFloat(result[3])));\n            }\n            else if ((result = SolidParser.UVPattern.exec(line)) !== null) {\n                //Create a Vector2 with the normals u, v\n                //Value of result\n                // [\"vt 0.1 0.2 0.3\", \"0.1\", \"0.2\"]\n                //Add the Vector in the list of uvs\n                this._uvs.push(new Vector2(parseFloat(result[1]) * this._loadingOptions.UVScaling.x, parseFloat(result[2]) * this._loadingOptions.UVScaling.y));\n                //Identify patterns of faces\n                //Face could be defined in different type of pattern\n            }\n            else if ((result = SolidParser.FacePattern3.exec(line)) !== null) {\n                //Value of result:\n                //[\"f 1/1/1 2/2/2 3/3/3\", \"1/1/1 2/2/2 3/3/3\"...]\n                //Set the data for this face\n                this._setDataForCurrentFaceWithPattern3(result[1].trim().split(\" \"), // [\"1/1/1\", \"2/2/2\", \"3/3/3\"]\n                1);\n            }\n            else if ((result = SolidParser.FacePattern4.exec(line)) !== null) {\n                //Value of result:\n                //[\"f 1//1 2//2 3//3\", \"1//1 2//2 3//3\"...]\n                //Set the data for this face\n                this._setDataForCurrentFaceWithPattern4(result[1].trim().split(\" \"), // [\"1//1\", \"2//2\", \"3//3\"]\n                1);\n            }\n            else if ((result = SolidParser.FacePattern5.exec(line)) !== null) {\n                //Value of result:\n                //[\"f -1/-1/-1 -2/-2/-2 -3/-3/-3\", \"-1/-1/-1 -2/-2/-2 -3/-3/-3\"...]\n                //Set the data for this face\n                this._setDataForCurrentFaceWithPattern5(result[1].trim().split(\" \"), // [\"-1/-1/-1\", \"-2/-2/-2\", \"-3/-3/-3\"]\n                1);\n            }\n            else if ((result = SolidParser.FacePattern2.exec(line)) !== null) {\n                //Value of result:\n                //[\"f 1/1 2/2 3/3\", \"1/1 2/2 3/3\"...]\n                //Set the data for this face\n                this._setDataForCurrentFaceWithPattern2(result[1].trim().split(\" \"), // [\"1/1\", \"2/2\", \"3/3\"]\n                1);\n            }\n            else if ((result = SolidParser.FacePattern1.exec(line)) !== null) {\n                //Value of result\n                //[\"f 1 2 3\", \"1 2 3\"...]\n                //Set the data for this face\n                this._setDataForCurrentFaceWithPattern1(result[1].trim().split(\" \"), // [\"1\", \"2\", \"3\"]\n                1);\n                // Define a mesh or an object\n                // Each time this keyword is analysed, create a new Object with all data for creating a babylonMesh\n            }\n            else if (SolidParser.GroupDescriptor.test(line) || SolidParser.ObjectDescriptor.test(line)) {\n                // Create a new mesh corresponding to the name of the group.\n                // Definition of the mesh\n                const objMesh = {\n                    name: line.substring(2).trim(),\n                    indices: undefined,\n                    positions: undefined,\n                    normals: undefined,\n                    uvs: undefined,\n                    colors: undefined,\n                    materialName: this._materialNameFromObj,\n                };\n                this._addPreviousObjMesh();\n                //Push the last mesh created with only the name\n                this._meshesFromObj.push(objMesh);\n                //Set this variable to indicate that now meshesFromObj has objects defined inside\n                this._hasMeshes = true;\n                this._isFirstMaterial = true;\n                this._increment = 1;\n                //Keyword for applying a material\n            }\n            else if (SolidParser.UseMtlDescriptor.test(line)) {\n                //Get the name of the material\n                this._materialNameFromObj = line.substring(7).trim();\n                //If this new material is in the same mesh\n                if (!this._isFirstMaterial || !this._hasMeshes) {\n                    //Set the data for the previous mesh\n                    this._addPreviousObjMesh();\n                    //Create a new mesh\n                    const objMesh = \n                    //Set the name of the current obj mesh\n                    {\n                        name: (this._objMeshName || \"mesh\") + \"_mm\" + this._increment.toString(),\n                        indices: undefined,\n                        positions: undefined,\n                        normals: undefined,\n                        uvs: undefined,\n                        colors: undefined,\n                        materialName: this._materialNameFromObj,\n                    };\n                    this._increment++;\n                    //If meshes are already defined\n                    this._meshesFromObj.push(objMesh);\n                    this._hasMeshes = true;\n                }\n                //Set the material name if the previous line define a mesh\n                if (this._hasMeshes && this._isFirstMaterial) {\n                    //Set the material name to the previous mesh (1 material per mesh)\n                    this._meshesFromObj[this._meshesFromObj.length - 1].materialName = this._materialNameFromObj;\n                    this._isFirstMaterial = false;\n                }\n                // Keyword for loading the mtl file\n            }\n            else if (SolidParser.MtlLibGroupDescriptor.test(line)) {\n                // Get the name of mtl file\n                onFileToLoadFound(line.substring(7).trim());\n                // Apply smoothing\n            }\n            else if (SolidParser.SmoothDescriptor.test(line)) {\n                // smooth shading => apply smoothing\n                // Today I don't know it work with babylon and with obj.\n                // With the obj file  an integer is set\n            }\n            else {\n                //If there is another possibility\n                console.log(\"Unhandled expression at line : \" + line);\n            }\n        }\n        // At the end of the file, add the last mesh into the meshesFromObj array\n        if (this._hasMeshes) {\n            // Set the data for the last mesh\n            this._handledMesh = this._meshesFromObj[this._meshesFromObj.length - 1];\n            //Reverse indices for displaying faces in the good sense\n            this._indicesForBabylon.reverse();\n            //Get the good array\n            this._unwrapData();\n            //Set array\n            this._handledMesh.indices = this._indicesForBabylon;\n            this._handledMesh.positions = this._unwrappedPositionsForBabylon;\n            this._handledMesh.normals = this._unwrappedNormalsForBabylon;\n            this._handledMesh.uvs = this._unwrappedUVForBabylon;\n            if (this._loadingOptions.importVertexColors) {\n                this._handledMesh.colors = this._unwrappedColorsForBabylon;\n            }\n        }\n        // If any o or g keyword not found, create a mesh with a random id\n        if (!this._hasMeshes) {\n            let newMaterial = null;\n            if (this._indicesForBabylon.length) {\n                // reverse tab of indices\n                this._indicesForBabylon.reverse();\n                //Get positions normals uvs\n                this._unwrapData();\n            }\n            else {\n                // There is no indices in the file. We will have to switch to point cloud rendering\n                for (const pos of this._positions) {\n                    this._unwrappedPositionsForBabylon.push(pos.x, pos.y, pos.z);\n                }\n                if (this._normals.length) {\n                    for (const normal of this._normals) {\n                        this._unwrappedNormalsForBabylon.push(normal.x, normal.y, normal.z);\n                    }\n                }\n                if (this._uvs.length) {\n                    for (const uv of this._uvs) {\n                        this._unwrappedUVForBabylon.push(uv.x, uv.y);\n                    }\n                }\n                if (this._colors.length) {\n                    for (const color of this._colors) {\n                        this._unwrappedColorsForBabylon.push(color.r, color.g, color.b, color.a);\n                    }\n                }\n                if (!this._materialNameFromObj) {\n                    // Create a material with point cloud on\n                    newMaterial = new StandardMaterial(Geometry.RandomId(), scene);\n                    newMaterial.pointsCloud = true;\n                    this._materialNameFromObj = newMaterial.name;\n                    if (!this._normals.length) {\n                        newMaterial.disableLighting = true;\n                        newMaterial.emissiveColor = Color3.White();\n                    }\n                }\n            }\n            //Set data for one mesh\n            this._meshesFromObj.push({\n                name: Geometry.RandomId(),\n                indices: this._indicesForBabylon,\n                positions: this._unwrappedPositionsForBabylon,\n                colors: this._unwrappedColorsForBabylon,\n                normals: this._unwrappedNormalsForBabylon,\n                uvs: this._unwrappedUVForBabylon,\n                materialName: this._materialNameFromObj,\n                directMaterial: newMaterial,\n            });\n        }\n        //Set data for each mesh\n        for (let j = 0; j < this._meshesFromObj.length; j++) {\n            //check meshesNames (stlFileLoader)\n            if (meshesNames && this._meshesFromObj[j].name) {\n                if (meshesNames instanceof Array) {\n                    if (meshesNames.indexOf(this._meshesFromObj[j].name) === -1) {\n                        continue;\n                    }\n                }\n                else {\n                    if (this._meshesFromObj[j].name !== meshesNames) {\n                        continue;\n                    }\n                }\n            }\n            //Get the current mesh\n            //Set the data with VertexBuffer for each mesh\n            this._handledMesh = this._meshesFromObj[j];\n            //Create a Mesh with the name of the obj mesh\n            scene._blockEntityCollection = !!assetContainer;\n            const babylonMesh = new Mesh(this._meshesFromObj[j].name, scene);\n            babylonMesh._parentContainer = assetContainer;\n            scene._blockEntityCollection = false;\n            //Push the name of the material to an array\n            //This is indispensable for the importMesh function\n            this._materialToUse.push(this._meshesFromObj[j].materialName);\n            if (((_a = this._handledMesh.positions) === null || _a === void 0 ? void 0 : _a.length) === 0) {\n                //Push the mesh into an array\n                this._babylonMeshesArray.push(babylonMesh);\n                continue;\n            }\n            const vertexData = new VertexData(); //The container for the values\n            //Set the data for the babylonMesh\n            vertexData.uvs = this._handledMesh.uvs;\n            vertexData.indices = this._handledMesh.indices;\n            vertexData.positions = this._handledMesh.positions;\n            if (this._loadingOptions.computeNormals) {\n                const normals = new Array();\n                VertexData.ComputeNormals(this._handledMesh.positions, this._handledMesh.indices, normals);\n                vertexData.normals = normals;\n            }\n            else {\n                vertexData.normals = this._handledMesh.normals;\n            }\n            if (this._loadingOptions.importVertexColors) {\n                vertexData.colors = this._handledMesh.colors;\n            }\n            //Set the data from the VertexBuffer to the current Mesh\n            vertexData.applyToMesh(babylonMesh);\n            if (this._loadingOptions.invertY) {\n                babylonMesh.scaling.y *= -1;\n            }\n            if (this._loadingOptions.optimizeNormals) {\n                this._optimizeNormals(babylonMesh);\n            }\n            //Push the mesh into an array\n            this._babylonMeshesArray.push(babylonMesh);\n            if (this._handledMesh.directMaterial) {\n                babylonMesh.material = this._handledMesh.directMaterial;\n            }\n        }\n    }\n}\n// Descriptor\n/** Object descriptor */\nSolidParser.ObjectDescriptor = /^o/;\n/** Group descriptor */\nSolidParser.GroupDescriptor = /^g/;\n/** Material lib descriptor */\nSolidParser.MtlLibGroupDescriptor = /^mtllib /;\n/** Use a material descriptor */\nSolidParser.UseMtlDescriptor = /^usemtl /;\n/** Smooth descriptor */\nSolidParser.SmoothDescriptor = /^s /;\n// Patterns\n/** Pattern used to detect a vertex */\nSolidParser.VertexPattern = /v(\\s+[\\d|.|+|\\-|e|E]+){3,7}/;\n/** Pattern used to detect a normal */\nSolidParser.NormalPattern = /vn(\\s+[\\d|.|+|\\-|e|E]+)( +[\\d|.|+|\\-|e|E]+)( +[\\d|.|+|\\-|e|E]+)/;\n/** Pattern used to detect a UV set */\nSolidParser.UVPattern = /vt(\\s+[\\d|.|+|\\-|e|E]+)( +[\\d|.|+|\\-|e|E]+)/;\n/** Pattern used to detect a first kind of face (f vertex vertex vertex) */\nSolidParser.FacePattern1 = /f\\s+(([\\d]{1,}[\\s]?){3,})+/;\n/** Pattern used to detect a second kind of face (f vertex/uvs vertex/uvs vertex/uvs) */\nSolidParser.FacePattern2 = /f\\s+((([\\d]{1,}\\/[\\d]{1,}[\\s]?){3,})+)/;\n/** Pattern used to detect a third kind of face (f vertex/uvs/normal vertex/uvs/normal vertex/uvs/normal) */\nSolidParser.FacePattern3 = /f\\s+((([\\d]{1,}\\/[\\d]{1,}\\/[\\d]{1,}[\\s]?){3,})+)/;\n/** Pattern used to detect a fourth kind of face (f vertex//normal vertex//normal vertex//normal)*/\nSolidParser.FacePattern4 = /f\\s+((([\\d]{1,}\\/\\/[\\d]{1,}[\\s]?){3,})+)/;\n/** Pattern used to detect a fifth kind of face (f -vertex/-uvs/-normal -vertex/-uvs/-normal -vertex/-uvs/-normal) */\nSolidParser.FacePattern5 = /f\\s+(((-[\\d]{1,}\\/-[\\d]{1,}\\/-[\\d]{1,}[\\s]?){3,})+)/;\n//# sourceMappingURL=solidParser.js.map","import { Vector2 } from \"@babylonjs/core/Maths/math.vector.js\";\nimport { Tools } from \"@babylonjs/core/Misc/tools.js\";\nimport { SceneLoader } from \"@babylonjs/core/Loading/sceneLoader.js\";\nimport { AssetContainer } from \"@babylonjs/core/assetContainer.js\";\nimport { MTLFileLoader } from \"./mtlFileLoader.js\";\nimport { SolidParser } from \"./solidParser.js\";\n/**\n * OBJ file type loader.\n * This is a babylon scene loader plugin.\n */\nexport class OBJFileLoader {\n    /**\n     * Invert Y-Axis of referenced textures on load\n     */\n    static get INVERT_TEXTURE_Y() {\n        return MTLFileLoader.INVERT_TEXTURE_Y;\n    }\n    static set INVERT_TEXTURE_Y(value) {\n        MTLFileLoader.INVERT_TEXTURE_Y = value;\n    }\n    /**\n     * Creates loader for .OBJ files\n     *\n     * @param loadingOptions options for loading and parsing OBJ/MTL files.\n     */\n    constructor(loadingOptions) {\n        /**\n         * Defines the name of the plugin.\n         */\n        this.name = \"obj\";\n        /**\n         * Defines the extension the plugin is able to load.\n         */\n        this.extensions = \".obj\";\n        this._assetContainer = null;\n        this._loadingOptions = loadingOptions || OBJFileLoader._DefaultLoadingOptions;\n    }\n    static get _DefaultLoadingOptions() {\n        return {\n            computeNormals: OBJFileLoader.COMPUTE_NORMALS,\n            optimizeNormals: OBJFileLoader.OPTIMIZE_NORMALS,\n            importVertexColors: OBJFileLoader.IMPORT_VERTEX_COLORS,\n            invertY: OBJFileLoader.INVERT_Y,\n            invertTextureY: OBJFileLoader.INVERT_TEXTURE_Y,\n            // eslint-disable-next-line @typescript-eslint/naming-convention\n            UVScaling: OBJFileLoader.UV_SCALING,\n            materialLoadingFailsSilently: OBJFileLoader.MATERIAL_LOADING_FAILS_SILENTLY,\n            optimizeWithUV: OBJFileLoader.OPTIMIZE_WITH_UV,\n            skipMaterials: OBJFileLoader.SKIP_MATERIALS,\n        };\n    }\n    /**\n     * Calls synchronously the MTL file attached to this obj.\n     * Load function or importMesh function don't enable to load 2 files in the same time asynchronously.\n     * Without this function materials are not displayed in the first frame (but displayed after).\n     * In consequence it is impossible to get material information in your HTML file\n     *\n     * @param url The URL of the MTL file\n     * @param rootUrl defines where to load data from\n     * @param onSuccess Callback function to be called when the MTL file is loaded\n     * @param onFailure\n     */\n    _loadMTL(url, rootUrl, onSuccess, onFailure) {\n        //The complete path to the mtl file\n        const pathOfFile = rootUrl + url;\n        // Loads through the babylon tools to allow fileInput search.\n        Tools.LoadFile(pathOfFile, onSuccess, undefined, undefined, false, (request, exception) => {\n            onFailure(pathOfFile, exception);\n        });\n    }\n    /**\n     * Instantiates a OBJ file loader plugin.\n     * @returns the created plugin\n     */\n    createPlugin() {\n        return new OBJFileLoader(OBJFileLoader._DefaultLoadingOptions);\n    }\n    /**\n     * If the data string can be loaded directly.\n     * @returns if the data can be loaded directly\n     */\n    canDirectLoad() {\n        return false;\n    }\n    /**\n     * Imports one or more meshes from the loaded OBJ data and adds them to the scene\n     * @param meshesNames a string or array of strings of the mesh names that should be loaded from the file\n     * @param scene the scene the meshes should be added to\n     * @param data the OBJ data to load\n     * @param rootUrl root url to load from\n     * @returns a promise containing the loaded meshes, particles, skeletons and animations\n     */\n    importMeshAsync(meshesNames, scene, data, rootUrl) {\n        //get the meshes from OBJ file\n        return this._parseSolid(meshesNames, scene, data, rootUrl).then((meshes) => {\n            return {\n                meshes: meshes,\n                particleSystems: [],\n                skeletons: [],\n                animationGroups: [],\n                transformNodes: [],\n                geometries: [],\n                lights: [],\n            };\n        });\n    }\n    /**\n     * Imports all objects from the loaded OBJ data and adds them to the scene\n     * @param scene the scene the objects should be added to\n     * @param data the OBJ data to load\n     * @param rootUrl root url to load from\n     * @returns a promise which completes when objects have been loaded to the scene\n     */\n    loadAsync(scene, data, rootUrl) {\n        //Get the 3D model\n        return this.importMeshAsync(null, scene, data, rootUrl).then(() => {\n            // return void\n        });\n    }\n    /**\n     * Load into an asset container.\n     * @param scene The scene to load into\n     * @param data The data to import\n     * @param rootUrl The root url for scene and resources\n     * @returns The loaded asset container\n     */\n    loadAssetContainerAsync(scene, data, rootUrl) {\n        const container = new AssetContainer(scene);\n        this._assetContainer = container;\n        return this.importMeshAsync(null, scene, data, rootUrl)\n            .then((result) => {\n            result.meshes.forEach((mesh) => container.meshes.push(mesh));\n            result.meshes.forEach((mesh) => {\n                const material = mesh.material;\n                if (material) {\n                    // Materials\n                    if (container.materials.indexOf(material) == -1) {\n                        container.materials.push(material);\n                        // Textures\n                        const textures = material.getActiveTextures();\n                        textures.forEach((t) => {\n                            if (container.textures.indexOf(t) == -1) {\n                                container.textures.push(t);\n                            }\n                        });\n                    }\n                }\n            });\n            this._assetContainer = null;\n            return container;\n        })\n            .catch((ex) => {\n            this._assetContainer = null;\n            throw ex;\n        });\n    }\n    /**\n     * Read the OBJ file and create an Array of meshes.\n     * Each mesh contains all information given by the OBJ and the MTL file.\n     * i.e. vertices positions and indices, optional normals values, optional UV values, optional material\n     * @param meshesNames defines a string or array of strings of the mesh names that should be loaded from the file\n     * @param scene defines the scene where are displayed the data\n     * @param data defines the content of the obj file\n     * @param rootUrl defines the path to the folder\n     * @returns the list of loaded meshes\n     */\n    _parseSolid(meshesNames, scene, data, rootUrl) {\n        let fileToLoad = \"\"; //The name of the mtlFile to load\n        const materialsFromMTLFile = new MTLFileLoader();\n        const materialToUse = new Array();\n        const babylonMeshesArray = []; //The mesh for babylon\n        // Main function\n        const solidParser = new SolidParser(materialToUse, babylonMeshesArray, this._loadingOptions);\n        solidParser.parse(meshesNames, data, scene, this._assetContainer, (fileName) => {\n            fileToLoad = fileName;\n        });\n        // load the materials\n        const mtlPromises = [];\n        // Check if we have a file to load\n        if (fileToLoad !== \"\" && !this._loadingOptions.skipMaterials) {\n            //Load the file synchronously\n            mtlPromises.push(new Promise((resolve, reject) => {\n                this._loadMTL(fileToLoad, rootUrl, (dataLoaded) => {\n                    try {\n                        //Create materials thanks MTLLoader function\n                        materialsFromMTLFile.parseMTL(scene, dataLoaded, rootUrl, this._assetContainer);\n                        //Look at each material loaded in the mtl file\n                        for (let n = 0; n < materialsFromMTLFile.materials.length; n++) {\n                            //Three variables to get all meshes with the same material\n                            let startIndex = 0;\n                            const _indices = [];\n                            let _index;\n                            //The material from MTL file is used in the meshes loaded\n                            //Push the indice in an array\n                            //Check if the material is not used for another mesh\n                            while ((_index = materialToUse.indexOf(materialsFromMTLFile.materials[n].name, startIndex)) > -1) {\n                                _indices.push(_index);\n                                startIndex = _index + 1;\n                            }\n                            //If the material is not used dispose it\n                            if (_index === -1 && _indices.length === 0) {\n                                //If the material is not needed, remove it\n                                materialsFromMTLFile.materials[n].dispose();\n                            }\n                            else {\n                                for (let o = 0; o < _indices.length; o++) {\n                                    //Apply the material to the Mesh for each mesh with the material\n                                    const mesh = babylonMeshesArray[_indices[o]];\n                                    const material = materialsFromMTLFile.materials[n];\n                                    mesh.material = material;\n                                    if (!mesh.getTotalIndices()) {\n                                        // No indices, we need to turn on point cloud\n                                        material.pointsCloud = true;\n                                    }\n                                }\n                            }\n                        }\n                        resolve();\n                    }\n                    catch (e) {\n                        Tools.Warn(`Error processing MTL file: '${fileToLoad}'`);\n                        if (this._loadingOptions.materialLoadingFailsSilently) {\n                            resolve();\n                        }\n                        else {\n                            reject(e);\n                        }\n                    }\n                }, (pathOfFile, exception) => {\n                    Tools.Warn(`Error downloading MTL file: '${fileToLoad}'`);\n                    if (this._loadingOptions.materialLoadingFailsSilently) {\n                        resolve();\n                    }\n                    else {\n                        reject(exception);\n                    }\n                });\n            }));\n        }\n        //Return an array with all Mesh\n        return Promise.all(mtlPromises).then(() => {\n            return babylonMeshesArray;\n        });\n    }\n}\n/**\n * Defines if UVs are optimized by default during load.\n */\nOBJFileLoader.OPTIMIZE_WITH_UV = true;\n/**\n * Invert model on y-axis (does a model scaling inversion)\n */\nOBJFileLoader.INVERT_Y = false;\n/**\n * Include in meshes the vertex colors available in some OBJ files.  This is not part of OBJ standard.\n */\nOBJFileLoader.IMPORT_VERTEX_COLORS = false;\n/**\n * Compute the normals for the model, even if normals are present in the file.\n */\nOBJFileLoader.COMPUTE_NORMALS = false;\n/**\n * Optimize the normals for the model. Lighting can be uneven if you use OptimizeWithUV = true because new vertices can be created for the same location if they pertain to different faces.\n * Using OptimizehNormals = true will help smoothing the lighting by averaging the normals of those vertices.\n */\nOBJFileLoader.OPTIMIZE_NORMALS = false;\n/**\n * Defines custom scaling of UV coordinates of loaded meshes.\n */\nOBJFileLoader.UV_SCALING = new Vector2(1, 1);\n/**\n * Skip loading the materials even if defined in the OBJ file (materials are ignored).\n */\nOBJFileLoader.SKIP_MATERIALS = false;\n/**\n * When a material fails to load OBJ loader will silently fail and onSuccess() callback will be triggered.\n *\n * Defaults to true for backwards compatibility.\n */\nOBJFileLoader.MATERIAL_LOADING_FAILS_SILENTLY = true;\nif (SceneLoader) {\n    //Add this loader into the register plugin\n    SceneLoader.RegisterPlugin(new OBJFileLoader());\n}\n//# sourceMappingURL=objFileLoader.js.map","import { Tools } from \"@babylonjs/core/Misc/tools.js\";\nimport { VertexBuffer } from \"@babylonjs/core/Buffers/buffer.js\";\nimport { Mesh } from \"@babylonjs/core/Meshes/mesh.js\";\nimport { SceneLoader } from \"@babylonjs/core/Loading/sceneLoader.js\";\nimport { AssetContainer } from \"@babylonjs/core/assetContainer.js\";\n/**\n * STL file type loader.\n * This is a babylon scene loader plugin.\n */\nexport class STLFileLoader {\n    constructor() {\n        /** @internal */\n        this.solidPattern = /solid (\\S*)([\\S\\s]*?)endsolid[ ]*(\\S*)/g;\n        /** @internal */\n        this.facetsPattern = /facet([\\s\\S]*?)endfacet/g;\n        /** @internal */\n        this.normalPattern = /normal[\\s]+([-+]?[0-9]+\\.?[0-9]*([eE][-+]?[0-9]+)?)+[\\s]+([-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?)+[\\s]+([-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?)+/g;\n        /** @internal */\n        this.vertexPattern = /vertex[\\s]+([-+]?[0-9]+\\.?[0-9]*([eE][-+]?[0-9]+)?)+[\\s]+([-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?)+[\\s]+([-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?)+/g;\n        /**\n         * Defines the name of the plugin.\n         */\n        this.name = \"stl\";\n        /**\n         * Defines the extensions the stl loader is able to load.\n         * force data to come in as an ArrayBuffer\n         * we'll convert to string if it looks like it's an ASCII .stl\n         */\n        this.extensions = {\n            \".stl\": { isBinary: true },\n        };\n    }\n    /**\n     * Import meshes into a scene.\n     * @param meshesNames An array of mesh names, a single mesh name, or empty string for all meshes that filter what meshes are imported\n     * @param scene The scene to import into\n     * @param data The data to import\n     * @param rootUrl The root url for scene and resources\n     * @param meshes The meshes array to import into\n     * @returns True if successful or false otherwise\n     */\n    importMesh(meshesNames, scene, data, rootUrl, meshes) {\n        let matches;\n        if (typeof data !== \"string\") {\n            if (this._isBinary(data)) {\n                // binary .stl\n                const babylonMesh = new Mesh(\"stlmesh\", scene);\n                this._parseBinary(babylonMesh, data);\n                if (meshes) {\n                    meshes.push(babylonMesh);\n                }\n                return true;\n            }\n            // ASCII .stl\n            // convert to string\n            const array_buffer = new Uint8Array(data);\n            let str = \"\";\n            for (let i = 0; i < data.byteLength; i++) {\n                str += String.fromCharCode(array_buffer[i]); // implicitly assumes little-endian\n            }\n            data = str;\n        }\n        //if arrived here, data is a string, containing the STLA data.\n        while ((matches = this.solidPattern.exec(data))) {\n            let meshName = matches[1];\n            const meshNameFromEnd = matches[3];\n            if (meshName != meshNameFromEnd) {\n                Tools.Error(\"Error in STL, solid name != endsolid name\");\n                return false;\n            }\n            // check meshesNames\n            if (meshesNames && meshName) {\n                if (meshesNames instanceof Array) {\n                    if (!meshesNames.indexOf(meshName)) {\n                        continue;\n                    }\n                }\n                else {\n                    if (meshName !== meshesNames) {\n                        continue;\n                    }\n                }\n            }\n            // stl mesh name can be empty as well\n            meshName = meshName || \"stlmesh\";\n            const babylonMesh = new Mesh(meshName, scene);\n            this._parseASCII(babylonMesh, matches[2]);\n            if (meshes) {\n                meshes.push(babylonMesh);\n            }\n        }\n        return true;\n    }\n    /**\n     * Load into a scene.\n     * @param scene The scene to load into\n     * @param data The data to import\n     * @param rootUrl The root url for scene and resources\n     * @returns true if successful or false otherwise\n     */\n    load(scene, data, rootUrl) {\n        const result = this.importMesh(null, scene, data, rootUrl, null);\n        return result;\n    }\n    /**\n     * Load into an asset container.\n     * @param scene The scene to load into\n     * @param data The data to import\n     * @param rootUrl The root url for scene and resources\n     * @returns The loaded asset container\n     */\n    loadAssetContainer(scene, data, rootUrl) {\n        const container = new AssetContainer(scene);\n        scene._blockEntityCollection = true;\n        this.importMesh(null, scene, data, rootUrl, container.meshes);\n        scene._blockEntityCollection = false;\n        return container;\n    }\n    _isBinary(data) {\n        // check if file size is correct for binary stl\n        const reader = new DataView(data);\n        // A Binary STL header is 80 bytes, if the data size is not great than\n        // that then it's not a binary STL.\n        if (reader.byteLength <= 80) {\n            return false;\n        }\n        const faceSize = (32 / 8) * 3 + (32 / 8) * 3 * 3 + 16 / 8;\n        const nFaces = reader.getUint32(80, true);\n        if (80 + 32 / 8 + nFaces * faceSize === reader.byteLength) {\n            return true;\n        }\n        // US-ASCII begin with 's', 'o', 'l', 'i', 'd'\n        const ascii = [115, 111, 108, 105, 100];\n        for (let off = 0; off < 5; off++) {\n            if (reader.getUint8(off) !== ascii[off]) {\n                return true;\n            }\n        }\n        return false;\n    }\n    _parseBinary(mesh, data) {\n        const reader = new DataView(data);\n        const faces = reader.getUint32(80, true);\n        const dataOffset = 84;\n        const faceLength = 12 * 4 + 2;\n        let offset = 0;\n        const positions = new Float32Array(faces * 3 * 3);\n        const normals = new Float32Array(faces * 3 * 3);\n        const indices = new Uint32Array(faces * 3);\n        let indicesCount = 0;\n        for (let face = 0; face < faces; face++) {\n            const start = dataOffset + face * faceLength;\n            const normalX = reader.getFloat32(start, true);\n            const normalY = reader.getFloat32(start + 4, true);\n            const normalZ = reader.getFloat32(start + 8, true);\n            for (let i = 1; i <= 3; i++) {\n                const vertexstart = start + i * 12;\n                // ordering is intentional to match ascii import\n                positions[offset] = reader.getFloat32(vertexstart, true);\n                normals[offset] = normalX;\n                if (!STLFileLoader.DO_NOT_ALTER_FILE_COORDINATES) {\n                    positions[offset + 2] = reader.getFloat32(vertexstart + 4, true);\n                    positions[offset + 1] = reader.getFloat32(vertexstart + 8, true);\n                    normals[offset + 2] = normalY;\n                    normals[offset + 1] = normalZ;\n                }\n                else {\n                    positions[offset + 1] = reader.getFloat32(vertexstart + 4, true);\n                    positions[offset + 2] = reader.getFloat32(vertexstart + 8, true);\n                    normals[offset + 1] = normalY;\n                    normals[offset + 2] = normalZ;\n                }\n                offset += 3;\n            }\n            if (STLFileLoader.DO_NOT_ALTER_FILE_COORDINATES) {\n                indices[indicesCount] = indicesCount;\n                indices[indicesCount + 1] = indicesCount + 2;\n                indices[indicesCount + 2] = indicesCount + 1;\n                indicesCount += 3;\n            }\n            else {\n                indices[indicesCount] = indicesCount++;\n                indices[indicesCount] = indicesCount++;\n                indices[indicesCount] = indicesCount++;\n            }\n        }\n        mesh.setVerticesData(VertexBuffer.PositionKind, positions);\n        mesh.setVerticesData(VertexBuffer.NormalKind, normals);\n        mesh.setIndices(indices);\n        mesh.computeWorldMatrix(true);\n    }\n    _parseASCII(mesh, solidData) {\n        const positions = [];\n        const normals = [];\n        const indices = [];\n        let indicesCount = 0;\n        //load facets, ignoring loop as the standard doesn't define it can contain more than vertices\n        let matches;\n        while ((matches = this.facetsPattern.exec(solidData))) {\n            const facet = matches[1];\n            //one normal per face\n            const normalMatches = this.normalPattern.exec(facet);\n            this.normalPattern.lastIndex = 0;\n            if (!normalMatches) {\n                continue;\n            }\n            const normal = [Number(normalMatches[1]), Number(normalMatches[5]), Number(normalMatches[3])];\n            let vertexMatch;\n            while ((vertexMatch = this.vertexPattern.exec(facet))) {\n                if (!STLFileLoader.DO_NOT_ALTER_FILE_COORDINATES) {\n                    positions.push(Number(vertexMatch[1]), Number(vertexMatch[5]), Number(vertexMatch[3]));\n                    normals.push(normal[0], normal[1], normal[2]);\n                }\n                else {\n                    positions.push(Number(vertexMatch[1]), Number(vertexMatch[3]), Number(vertexMatch[5]));\n                    // Flipping the second and third component because inverted\n                    // when normal was declared.\n                    normals.push(normal[0], normal[2], normal[1]);\n                }\n            }\n            if (STLFileLoader.DO_NOT_ALTER_FILE_COORDINATES) {\n                indices.push(indicesCount, indicesCount + 2, indicesCount + 1);\n                indicesCount += 3;\n            }\n            else {\n                indices.push(indicesCount++, indicesCount++, indicesCount++);\n            }\n            this.vertexPattern.lastIndex = 0;\n        }\n        this.facetsPattern.lastIndex = 0;\n        mesh.setVerticesData(VertexBuffer.PositionKind, positions);\n        mesh.setVerticesData(VertexBuffer.NormalKind, normals);\n        mesh.setIndices(indices);\n        mesh.computeWorldMatrix(true);\n    }\n}\n/**\n * Defines if Y and Z axes are swapped or not when loading an STL file.\n * The default is false to maintain backward compatibility. When set to\n * true, coordinates from the STL file are used without change.\n */\nSTLFileLoader.DO_NOT_ALTER_FILE_COORDINATES = false;\nif (SceneLoader) {\n    SceneLoader.RegisterPlugin(new STLFileLoader());\n}\n//# sourceMappingURL=stlFileLoader.js.map","import { Animation } from \"@babylonjs/core/Animations/animation.js\";\nimport { Quaternion, Vector3 } from \"@babylonjs/core/Maths/math.vector.js\";\n/** @internal */\nexport function getVector3(_target, source, offset, scale) {\n    return Vector3.FromArray(source, offset).scaleInPlace(scale);\n}\n/** @internal */\nexport function getQuaternion(_target, source, offset, scale) {\n    return Quaternion.FromArray(source, offset).scaleInPlace(scale);\n}\n/** @internal */\nexport function getWeights(target, source, offset, scale) {\n    const value = new Array(target._numMorphTargets);\n    for (let i = 0; i < value.length; i++) {\n        value[i] = source[offset++] * scale;\n    }\n    return value;\n}\n/** @internal */\nexport class AnimationPropertyInfo {\n    /** @internal */\n    constructor(type, name, getValue, getStride) {\n        this.type = type;\n        this.name = name;\n        this.getValue = getValue;\n        this.getStride = getStride;\n    }\n    _buildAnimation(name, fps, keys) {\n        const babylonAnimation = new Animation(name, this.name, fps, this.type);\n        babylonAnimation.setKeys(keys);\n        return babylonAnimation;\n    }\n}\n/** @internal */\nexport class TransformNodeAnimationPropertyInfo extends AnimationPropertyInfo {\n    /** @internal */\n    buildAnimations(target, name, fps, keys, callback) {\n        callback(target._babylonTransformNode, this._buildAnimation(name, fps, keys));\n    }\n}\n/** @internal */\nexport class WeightAnimationPropertyInfo extends AnimationPropertyInfo {\n    buildAnimations(target, name, fps, keys, callback) {\n        if (target._numMorphTargets) {\n            for (let targetIndex = 0; targetIndex < target._numMorphTargets; targetIndex++) {\n                const babylonAnimation = new Animation(`${name}_${targetIndex}`, this.name, fps, this.type);\n                babylonAnimation.setKeys(keys.map((key) => ({\n                    frame: key.frame,\n                    inTangent: key.inTangent ? key.inTangent[targetIndex] : undefined,\n                    value: key.value[targetIndex],\n                    outTangent: key.outTangent ? key.outTangent[targetIndex] : undefined,\n                    interpolation: key.interpolation,\n                })));\n                if (target._primitiveBabylonMeshes) {\n                    for (const babylonMesh of target._primitiveBabylonMeshes) {\n                        if (babylonMesh.morphTargetManager) {\n                            const morphTarget = babylonMesh.morphTargetManager.getTarget(targetIndex);\n                            const babylonAnimationClone = babylonAnimation.clone();\n                            morphTarget.animations.push(babylonAnimationClone);\n                            callback(morphTarget, babylonAnimationClone);\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n/** @internal */\nexport const nodeAnimationData = {\n    translation: [new TransformNodeAnimationPropertyInfo(Animation.ANIMATIONTYPE_VECTOR3, \"position\", getVector3, () => 3)],\n    rotation: [new TransformNodeAnimationPropertyInfo(Animation.ANIMATIONTYPE_QUATERNION, \"rotationQuaternion\", getQuaternion, () => 4)],\n    scale: [new TransformNodeAnimationPropertyInfo(Animation.ANIMATIONTYPE_VECTOR3, \"scaling\", getVector3, () => 3)],\n    weights: [new WeightAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"influence\", getWeights, (target) => target._numMorphTargets)],\n};\n//# sourceMappingURL=glTFLoaderAnimation.js.map","import { Deferred } from \"@babylonjs/core/Misc/deferred.js\";\nimport { Quaternion, Vector3, Matrix, TmpVectors } from \"@babylonjs/core/Maths/math.vector.js\";\nimport { Color3 } from \"@babylonjs/core/Maths/math.color.js\";\nimport { Tools } from \"@babylonjs/core/Misc/tools.js\";\nimport { Camera } from \"@babylonjs/core/Cameras/camera.js\";\nimport { FreeCamera } from \"@babylonjs/core/Cameras/freeCamera.js\";\nimport { AnimationKeyInterpolation } from \"@babylonjs/core/Animations/animationKey.js\";\nimport { AnimationGroup } from \"@babylonjs/core/Animations/animationGroup.js\";\nimport { Bone } from \"@babylonjs/core/Bones/bone.js\";\nimport { Skeleton } from \"@babylonjs/core/Bones/skeleton.js\";\nimport { Material } from \"@babylonjs/core/Materials/material.js\";\nimport { PBRMaterial } from \"@babylonjs/core/Materials/PBR/pbrMaterial.js\";\nimport { Texture } from \"@babylonjs/core/Materials/Textures/texture.js\";\nimport { TransformNode } from \"@babylonjs/core/Meshes/transformNode.js\";\nimport { Buffer, VertexBuffer } from \"@babylonjs/core/Buffers/buffer.js\";\nimport { Geometry } from \"@babylonjs/core/Meshes/geometry.js\";\nimport { Mesh } from \"@babylonjs/core/Meshes/mesh.js\";\nimport { MorphTarget } from \"@babylonjs/core/Morph/morphTarget.js\";\nimport { MorphTargetManager } from \"@babylonjs/core/Morph/morphTargetManager.js\";\nimport { GLTFFileLoader, GLTFLoaderState, GLTFLoaderCoordinateSystemMode, GLTFLoaderAnimationStartMode } from \"../glTFFileLoader.js\";\nimport { DecodeBase64UrlToBinary, IsBase64DataUrl, LoadFileError } from \"@babylonjs/core/Misc/fileTools.js\";\nimport { Logger } from \"@babylonjs/core/Misc/logger.js\";\nimport { BoundingInfo } from \"@babylonjs/core/Culling/boundingInfo.js\";\nimport { nodeAnimationData } from \"./glTFLoaderAnimation.js\";\n// https://stackoverflow.com/a/48218209\nfunction mergeDeep(...objects) {\n    const isObject = (obj) => obj && typeof obj === \"object\";\n    return objects.reduce((prev, obj) => {\n        Object.keys(obj).forEach((key) => {\n            const pVal = prev[key];\n            const oVal = obj[key];\n            if (Array.isArray(pVal) && Array.isArray(oVal)) {\n                prev[key] = pVal.concat(...oVal);\n            }\n            else if (isObject(pVal) && isObject(oVal)) {\n                prev[key] = mergeDeep(pVal, oVal);\n            }\n            else {\n                prev[key] = oVal;\n            }\n        });\n        return prev;\n    }, {});\n}\n/**\n * Helper class for working with arrays when loading the glTF asset\n */\nexport class ArrayItem {\n    /**\n     * Gets an item from the given array.\n     * @param context The context when loading the asset\n     * @param array The array to get the item from\n     * @param index The index to the array\n     * @returns The array item\n     */\n    static Get(context, array, index) {\n        if (!array || index == undefined || !array[index]) {\n            throw new Error(`${context}: Failed to find index (${index})`);\n        }\n        return array[index];\n    }\n    /**\n     * Assign an `index` field to each item of the given array.\n     * @param array The array of items\n     */\n    static Assign(array) {\n        if (array) {\n            for (let index = 0; index < array.length; index++) {\n                array[index].index = index;\n            }\n        }\n    }\n}\n/**\n * The glTF 2.0 loader\n */\nexport class GLTFLoader {\n    /**\n     * Registers a loader extension.\n     * @param name The name of the loader extension.\n     * @param factory The factory function that creates the loader extension.\n     */\n    static RegisterExtension(name, factory) {\n        if (GLTFLoader.UnregisterExtension(name)) {\n            Logger.Warn(`Extension with the name '${name}' already exists`);\n        }\n        GLTFLoader._RegisteredExtensions[name] = {\n            factory: factory,\n        };\n    }\n    /**\n     * Unregisters a loader extension.\n     * @param name The name of the loader extension.\n     * @returns A boolean indicating whether the extension has been unregistered\n     */\n    static UnregisterExtension(name) {\n        if (!GLTFLoader._RegisteredExtensions[name]) {\n            return false;\n        }\n        delete GLTFLoader._RegisteredExtensions[name];\n        return true;\n    }\n    /**\n     * The object that represents the glTF JSON.\n     */\n    get gltf() {\n        if (!this._gltf) {\n            throw new Error(\"glTF JSON is not available\");\n        }\n        return this._gltf;\n    }\n    /**\n     * The BIN chunk of a binary glTF.\n     */\n    get bin() {\n        return this._bin;\n    }\n    /**\n     * The parent file loader.\n     */\n    get parent() {\n        return this._parent;\n    }\n    /**\n     * The Babylon scene when loading the asset.\n     */\n    get babylonScene() {\n        if (!this._babylonScene) {\n            throw new Error(\"Scene is not available\");\n        }\n        return this._babylonScene;\n    }\n    /**\n     * The root Babylon mesh when loading the asset.\n     */\n    get rootBabylonMesh() {\n        return this._rootBabylonMesh;\n    }\n    /**\n     * @internal\n     */\n    constructor(parent) {\n        /** @internal */\n        this._completePromises = new Array();\n        /** @internal */\n        this._assetContainer = null;\n        /** Storage */\n        this._babylonLights = [];\n        /** @internal */\n        this._disableInstancedMesh = 0;\n        this._extensions = new Array();\n        this._disposed = false;\n        this._rootUrl = null;\n        this._fileName = null;\n        this._uniqueRootUrl = null;\n        this._bin = null;\n        this._rootBabylonMesh = null;\n        this._defaultBabylonMaterialData = {};\n        this._postSceneLoadActions = new Array();\n        this._parent = parent;\n    }\n    /** @internal */\n    dispose() {\n        if (this._disposed) {\n            return;\n        }\n        this._disposed = true;\n        this._completePromises.length = 0;\n        this._extensions.forEach((extension) => extension.dispose && extension.dispose());\n        this._extensions.length = 0;\n        this._gltf = null; // TODO\n        this._bin = null;\n        this._babylonScene = null; // TODO\n        this._rootBabylonMesh = null;\n        this._defaultBabylonMaterialData = {};\n        this._postSceneLoadActions.length = 0;\n        this._parent.dispose();\n    }\n    /**\n     * @internal\n     */\n    importMeshAsync(meshesNames, scene, container, data, rootUrl, onProgress, fileName = \"\") {\n        return Promise.resolve().then(() => {\n            this._babylonScene = scene;\n            this._assetContainer = container;\n            this._loadData(data);\n            let nodes = null;\n            if (meshesNames) {\n                const nodeMap = {};\n                if (this._gltf.nodes) {\n                    for (const node of this._gltf.nodes) {\n                        if (node.name) {\n                            nodeMap[node.name] = node.index;\n                        }\n                    }\n                }\n                const names = meshesNames instanceof Array ? meshesNames : [meshesNames];\n                nodes = names.map((name) => {\n                    const node = nodeMap[name];\n                    if (node === undefined) {\n                        throw new Error(`Failed to find node '${name}'`);\n                    }\n                    return node;\n                });\n            }\n            return this._loadAsync(rootUrl, fileName, nodes, () => {\n                return {\n                    meshes: this._getMeshes(),\n                    particleSystems: [],\n                    skeletons: this._getSkeletons(),\n                    animationGroups: this._getAnimationGroups(),\n                    lights: this._babylonLights,\n                    transformNodes: this._getTransformNodes(),\n                    geometries: this._getGeometries(),\n                };\n            });\n        });\n    }\n    /**\n     * @internal\n     */\n    loadAsync(scene, data, rootUrl, onProgress, fileName = \"\") {\n        return Promise.resolve().then(() => {\n            this._babylonScene = scene;\n            this._loadData(data);\n            return this._loadAsync(rootUrl, fileName, null, () => undefined);\n        });\n    }\n    _loadAsync(rootUrl, fileName, nodes, resultFunc) {\n        return Promise.resolve()\n            .then(() => {\n            this._rootUrl = rootUrl;\n            this._uniqueRootUrl = !rootUrl.startsWith(\"file:\") && fileName ? rootUrl : `${rootUrl}${Date.now()}/`;\n            this._fileName = fileName;\n            this._loadExtensions();\n            this._checkExtensions();\n            const loadingToReadyCounterName = `${GLTFLoaderState[GLTFLoaderState.LOADING]} => ${GLTFLoaderState[GLTFLoaderState.READY]}`;\n            const loadingToCompleteCounterName = `${GLTFLoaderState[GLTFLoaderState.LOADING]} => ${GLTFLoaderState[GLTFLoaderState.COMPLETE]}`;\n            this._parent._startPerformanceCounter(loadingToReadyCounterName);\n            this._parent._startPerformanceCounter(loadingToCompleteCounterName);\n            this._parent._setState(GLTFLoaderState.LOADING);\n            this._extensionsOnLoading();\n            const promises = new Array();\n            // Block the marking of materials dirty until the scene is loaded.\n            const oldBlockMaterialDirtyMechanism = this._babylonScene.blockMaterialDirtyMechanism;\n            this._babylonScene.blockMaterialDirtyMechanism = true;\n            if (!this.parent.loadOnlyMaterials) {\n                if (nodes) {\n                    promises.push(this.loadSceneAsync(\"/nodes\", { nodes: nodes, index: -1 }));\n                }\n                else if (this._gltf.scene != undefined || (this._gltf.scenes && this._gltf.scenes[0])) {\n                    const scene = ArrayItem.Get(`/scene`, this._gltf.scenes, this._gltf.scene || 0);\n                    promises.push(this.loadSceneAsync(`/scenes/${scene.index}`, scene));\n                }\n            }\n            if (!this.parent.skipMaterials && this.parent.loadAllMaterials && this._gltf.materials) {\n                for (let m = 0; m < this._gltf.materials.length; ++m) {\n                    const material = this._gltf.materials[m];\n                    const context = \"/materials/\" + m;\n                    const babylonDrawMode = Material.TriangleFillMode;\n                    promises.push(this._loadMaterialAsync(context, material, null, babylonDrawMode, () => { }));\n                }\n            }\n            // Restore the blocking of material dirty.\n            this._babylonScene.blockMaterialDirtyMechanism = oldBlockMaterialDirtyMechanism;\n            if (this._parent.compileMaterials) {\n                promises.push(this._compileMaterialsAsync());\n            }\n            if (this._parent.compileShadowGenerators) {\n                promises.push(this._compileShadowGeneratorsAsync());\n            }\n            const resultPromise = Promise.all(promises).then(() => {\n                if (this._rootBabylonMesh) {\n                    this._rootBabylonMesh.setEnabled(true);\n                }\n                this._extensionsOnReady();\n                this._parent._setState(GLTFLoaderState.READY);\n                this._startAnimations();\n                return resultFunc();\n            });\n            return resultPromise.then((result) => {\n                this._parent._endPerformanceCounter(loadingToReadyCounterName);\n                Tools.SetImmediate(() => {\n                    if (!this._disposed) {\n                        Promise.all(this._completePromises).then(() => {\n                            this._parent._endPerformanceCounter(loadingToCompleteCounterName);\n                            this._parent._setState(GLTFLoaderState.COMPLETE);\n                            this._parent.onCompleteObservable.notifyObservers(undefined);\n                            this._parent.onCompleteObservable.clear();\n                            this.dispose();\n                        }, (error) => {\n                            this._parent.onErrorObservable.notifyObservers(error);\n                            this._parent.onErrorObservable.clear();\n                            this.dispose();\n                        });\n                    }\n                });\n                return result;\n            });\n        })\n            .catch((error) => {\n            if (!this._disposed) {\n                this._parent.onErrorObservable.notifyObservers(error);\n                this._parent.onErrorObservable.clear();\n                this.dispose();\n            }\n            throw error;\n        });\n    }\n    _loadData(data) {\n        this._gltf = data.json;\n        this._setupData();\n        if (data.bin) {\n            const buffers = this._gltf.buffers;\n            if (buffers && buffers[0] && !buffers[0].uri) {\n                const binaryBuffer = buffers[0];\n                if (binaryBuffer.byteLength < data.bin.byteLength - 3 || binaryBuffer.byteLength > data.bin.byteLength) {\n                    Logger.Warn(`Binary buffer length (${binaryBuffer.byteLength}) from JSON does not match chunk length (${data.bin.byteLength})`);\n                }\n                this._bin = data.bin;\n            }\n            else {\n                Logger.Warn(\"Unexpected BIN chunk\");\n            }\n        }\n    }\n    _setupData() {\n        ArrayItem.Assign(this._gltf.accessors);\n        ArrayItem.Assign(this._gltf.animations);\n        ArrayItem.Assign(this._gltf.buffers);\n        ArrayItem.Assign(this._gltf.bufferViews);\n        ArrayItem.Assign(this._gltf.cameras);\n        ArrayItem.Assign(this._gltf.images);\n        ArrayItem.Assign(this._gltf.materials);\n        ArrayItem.Assign(this._gltf.meshes);\n        ArrayItem.Assign(this._gltf.nodes);\n        ArrayItem.Assign(this._gltf.samplers);\n        ArrayItem.Assign(this._gltf.scenes);\n        ArrayItem.Assign(this._gltf.skins);\n        ArrayItem.Assign(this._gltf.textures);\n        if (this._gltf.nodes) {\n            const nodeParents = {};\n            for (const node of this._gltf.nodes) {\n                if (node.children) {\n                    for (const index of node.children) {\n                        nodeParents[index] = node.index;\n                    }\n                }\n            }\n            const rootNode = this._createRootNode();\n            for (const node of this._gltf.nodes) {\n                const parentIndex = nodeParents[node.index];\n                node.parent = parentIndex === undefined ? rootNode : this._gltf.nodes[parentIndex];\n            }\n        }\n    }\n    _loadExtensions() {\n        for (const name in GLTFLoader._RegisteredExtensions) {\n            const extension = GLTFLoader._RegisteredExtensions[name].factory(this);\n            if (extension.name !== name) {\n                Logger.Warn(`The name of the glTF loader extension instance does not match the registered name: ${extension.name} !== ${name}`);\n            }\n            this._extensions.push(extension);\n            this._parent.onExtensionLoadedObservable.notifyObservers(extension);\n        }\n        this._extensions.sort((a, b) => (a.order || Number.MAX_VALUE) - (b.order || Number.MAX_VALUE));\n        this._parent.onExtensionLoadedObservable.clear();\n    }\n    _checkExtensions() {\n        if (this._gltf.extensionsRequired) {\n            for (const name of this._gltf.extensionsRequired) {\n                const available = this._extensions.some((extension) => extension.name === name && extension.enabled);\n                if (!available) {\n                    throw new Error(`Require extension ${name} is not available`);\n                }\n            }\n        }\n    }\n    _createRootNode() {\n        this._babylonScene._blockEntityCollection = !!this._assetContainer;\n        this._rootBabylonMesh = new Mesh(\"__root__\", this._babylonScene);\n        this._rootBabylonMesh._parentContainer = this._assetContainer;\n        this._babylonScene._blockEntityCollection = false;\n        this._rootBabylonMesh.setEnabled(false);\n        const rootNode = {\n            _babylonTransformNode: this._rootBabylonMesh,\n            index: -1,\n        };\n        switch (this._parent.coordinateSystemMode) {\n            case GLTFLoaderCoordinateSystemMode.AUTO: {\n                if (!this._babylonScene.useRightHandedSystem) {\n                    rootNode.rotation = [0, 1, 0, 0];\n                    rootNode.scale = [1, 1, -1];\n                    GLTFLoader._LoadTransform(rootNode, this._rootBabylonMesh);\n                }\n                break;\n            }\n            case GLTFLoaderCoordinateSystemMode.FORCE_RIGHT_HANDED: {\n                this._babylonScene.useRightHandedSystem = true;\n                break;\n            }\n            default: {\n                throw new Error(`Invalid coordinate system mode (${this._parent.coordinateSystemMode})`);\n            }\n        }\n        this._parent.onMeshLoadedObservable.notifyObservers(this._rootBabylonMesh);\n        return rootNode;\n    }\n    /**\n     * Loads a glTF scene.\n     * @param context The context when loading the asset\n     * @param scene The glTF scene property\n     * @returns A promise that resolves when the load is complete\n     */\n    loadSceneAsync(context, scene) {\n        const extensionPromise = this._extensionsLoadSceneAsync(context, scene);\n        if (extensionPromise) {\n            return extensionPromise;\n        }\n        const promises = new Array();\n        this.logOpen(`${context} ${scene.name || \"\"}`);\n        if (scene.nodes) {\n            for (const index of scene.nodes) {\n                const node = ArrayItem.Get(`${context}/nodes/${index}`, this._gltf.nodes, index);\n                promises.push(this.loadNodeAsync(`/nodes/${node.index}`, node, (babylonMesh) => {\n                    babylonMesh.parent = this._rootBabylonMesh;\n                }));\n            }\n        }\n        for (const action of this._postSceneLoadActions) {\n            action();\n        }\n        promises.push(this._loadAnimationsAsync());\n        this.logClose();\n        return Promise.all(promises).then(() => { });\n    }\n    _forEachPrimitive(node, callback) {\n        if (node._primitiveBabylonMeshes) {\n            for (const babylonMesh of node._primitiveBabylonMeshes) {\n                callback(babylonMesh);\n            }\n        }\n    }\n    _getGeometries() {\n        const geometries = new Array();\n        const nodes = this._gltf.nodes;\n        if (nodes) {\n            for (const node of nodes) {\n                this._forEachPrimitive(node, (babylonMesh) => {\n                    const geometry = babylonMesh.geometry;\n                    if (geometry && geometries.indexOf(geometry) === -1) {\n                        geometries.push(geometry);\n                    }\n                });\n            }\n        }\n        return geometries;\n    }\n    _getMeshes() {\n        const meshes = new Array();\n        // Root mesh is always first, if available.\n        if (this._rootBabylonMesh) {\n            meshes.push(this._rootBabylonMesh);\n        }\n        const nodes = this._gltf.nodes;\n        if (nodes) {\n            for (const node of nodes) {\n                this._forEachPrimitive(node, (babylonMesh) => {\n                    meshes.push(babylonMesh);\n                });\n            }\n        }\n        return meshes;\n    }\n    _getTransformNodes() {\n        const transformNodes = new Array();\n        const nodes = this._gltf.nodes;\n        if (nodes) {\n            for (const node of nodes) {\n                if (node._babylonTransformNode && node._babylonTransformNode.getClassName() === \"TransformNode\") {\n                    transformNodes.push(node._babylonTransformNode);\n                }\n                if (node._babylonTransformNodeForSkin) {\n                    transformNodes.push(node._babylonTransformNodeForSkin);\n                }\n            }\n        }\n        return transformNodes;\n    }\n    _getSkeletons() {\n        const skeletons = new Array();\n        const skins = this._gltf.skins;\n        if (skins) {\n            for (const skin of skins) {\n                if (skin._data) {\n                    skeletons.push(skin._data.babylonSkeleton);\n                }\n            }\n        }\n        return skeletons;\n    }\n    _getAnimationGroups() {\n        const animationGroups = new Array();\n        const animations = this._gltf.animations;\n        if (animations) {\n            for (const animation of animations) {\n                if (animation._babylonAnimationGroup) {\n                    animationGroups.push(animation._babylonAnimationGroup);\n                }\n            }\n        }\n        return animationGroups;\n    }\n    _startAnimations() {\n        switch (this._parent.animationStartMode) {\n            case GLTFLoaderAnimationStartMode.NONE: {\n                // do nothing\n                break;\n            }\n            case GLTFLoaderAnimationStartMode.FIRST: {\n                const babylonAnimationGroups = this._getAnimationGroups();\n                if (babylonAnimationGroups.length !== 0) {\n                    babylonAnimationGroups[0].start(true);\n                }\n                break;\n            }\n            case GLTFLoaderAnimationStartMode.ALL: {\n                const babylonAnimationGroups = this._getAnimationGroups();\n                for (const babylonAnimationGroup of babylonAnimationGroups) {\n                    babylonAnimationGroup.start(true);\n                }\n                break;\n            }\n            default: {\n                Logger.Error(`Invalid animation start mode (${this._parent.animationStartMode})`);\n                return;\n            }\n        }\n    }\n    /**\n     * Loads a glTF node.\n     * @param context The context when loading the asset\n     * @param node The glTF node property\n     * @param assign A function called synchronously after parsing the glTF properties\n     * @returns A promise that resolves with the loaded Babylon mesh when the load is complete\n     */\n    loadNodeAsync(context, node, assign = () => { }) {\n        const extensionPromise = this._extensionsLoadNodeAsync(context, node, assign);\n        if (extensionPromise) {\n            return extensionPromise;\n        }\n        if (node._babylonTransformNode) {\n            throw new Error(`${context}: Invalid recursive node hierarchy`);\n        }\n        const promises = new Array();\n        this.logOpen(`${context} ${node.name || \"\"}`);\n        const loadNode = (babylonTransformNode) => {\n            GLTFLoader.AddPointerMetadata(babylonTransformNode, context);\n            GLTFLoader._LoadTransform(node, babylonTransformNode);\n            if (node.camera != undefined) {\n                const camera = ArrayItem.Get(`${context}/camera`, this._gltf.cameras, node.camera);\n                promises.push(this.loadCameraAsync(`/cameras/${camera.index}`, camera, (babylonCamera) => {\n                    babylonCamera.parent = babylonTransformNode;\n                }));\n            }\n            if (node.children) {\n                for (const index of node.children) {\n                    const childNode = ArrayItem.Get(`${context}/children/${index}`, this._gltf.nodes, index);\n                    promises.push(this.loadNodeAsync(`/nodes/${childNode.index}`, childNode, (childBabylonMesh) => {\n                        childBabylonMesh.parent = babylonTransformNode;\n                    }));\n                }\n            }\n            assign(babylonTransformNode);\n        };\n        if (node.mesh == undefined || node.skin != undefined) {\n            const nodeName = node.name || `node${node.index}`;\n            this._babylonScene._blockEntityCollection = !!this._assetContainer;\n            const transformNode = new TransformNode(nodeName, this._babylonScene);\n            transformNode._parentContainer = this._assetContainer;\n            this._babylonScene._blockEntityCollection = false;\n            if (node.mesh == undefined) {\n                node._babylonTransformNode = transformNode;\n            }\n            else {\n                node._babylonTransformNodeForSkin = transformNode;\n            }\n            loadNode(transformNode);\n        }\n        if (node.mesh != undefined) {\n            if (node.skin == undefined) {\n                const mesh = ArrayItem.Get(`${context}/mesh`, this._gltf.meshes, node.mesh);\n                promises.push(this._loadMeshAsync(`/meshes/${mesh.index}`, node, mesh, loadNode));\n            }\n            else {\n                // See https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins (second implementation note)\n                // This code path will place the skinned mesh as a sibling of the skeleton root node without loading the\n                // transform, which effectively ignores the transform of the skinned mesh, as per spec.\n                const mesh = ArrayItem.Get(`${context}/mesh`, this._gltf.meshes, node.mesh);\n                promises.push(this._loadMeshAsync(`/meshes/${mesh.index}`, node, mesh, (babylonTransformNode) => {\n                    const babylonTransformNodeForSkin = node._babylonTransformNodeForSkin;\n                    // Merge the metadata from the skin node to the skinned mesh in case a loader extension added metadata.\n                    babylonTransformNode.metadata = mergeDeep(babylonTransformNodeForSkin.metadata, babylonTransformNode.metadata || {});\n                    const skin = ArrayItem.Get(`${context}/skin`, this._gltf.skins, node.skin);\n                    promises.push(this._loadSkinAsync(`/skins/${skin.index}`, node, skin, (babylonSkeleton) => {\n                        this._forEachPrimitive(node, (babylonMesh) => {\n                            babylonMesh.skeleton = babylonSkeleton;\n                        });\n                        // Wait until all the nodes are parented before parenting the skinned mesh.\n                        this._postSceneLoadActions.push(() => {\n                            if (skin.skeleton != undefined) {\n                                // Place the skinned mesh node as a sibling of the skeleton root node.\n                                // Handle special case when the parent of the skeleton root is the skinned mesh.\n                                const parentNode = ArrayItem.Get(`/skins/${skin.index}/skeleton`, this._gltf.nodes, skin.skeleton).parent;\n                                if (node.index === parentNode.index) {\n                                    babylonTransformNode.parent = babylonTransformNodeForSkin.parent;\n                                }\n                                else {\n                                    babylonTransformNode.parent = parentNode._babylonTransformNode;\n                                }\n                            }\n                            else {\n                                babylonTransformNode.parent = this._rootBabylonMesh;\n                            }\n                            this._parent.onSkinLoadedObservable.notifyObservers({ node: babylonTransformNodeForSkin, skinnedNode: babylonTransformNode });\n                        });\n                    }));\n                }));\n            }\n        }\n        this.logClose();\n        return Promise.all(promises).then(() => {\n            this._forEachPrimitive(node, (babylonMesh) => {\n                if (babylonMesh.geometry && babylonMesh.geometry.useBoundingInfoFromGeometry) {\n                    // simply apply the world matrices to the bounding info - the extends are already ok\n                    babylonMesh._updateBoundingInfo();\n                }\n                else {\n                    babylonMesh.refreshBoundingInfo(true);\n                }\n            });\n            return node._babylonTransformNode;\n        });\n    }\n    _loadMeshAsync(context, node, mesh, assign) {\n        const primitives = mesh.primitives;\n        if (!primitives || !primitives.length) {\n            throw new Error(`${context}: Primitives are missing`);\n        }\n        if (primitives[0].index == undefined) {\n            ArrayItem.Assign(primitives);\n        }\n        const promises = new Array();\n        this.logOpen(`${context} ${mesh.name || \"\"}`);\n        const name = node.name || `node${node.index}`;\n        if (primitives.length === 1) {\n            const primitive = mesh.primitives[0];\n            promises.push(this._loadMeshPrimitiveAsync(`${context}/primitives/${primitive.index}`, name, node, mesh, primitive, (babylonMesh) => {\n                node._babylonTransformNode = babylonMesh;\n                node._primitiveBabylonMeshes = [babylonMesh];\n            }));\n        }\n        else {\n            this._babylonScene._blockEntityCollection = !!this._assetContainer;\n            node._babylonTransformNode = new TransformNode(name, this._babylonScene);\n            node._babylonTransformNode._parentContainer = this._assetContainer;\n            this._babylonScene._blockEntityCollection = false;\n            node._primitiveBabylonMeshes = [];\n            for (const primitive of primitives) {\n                promises.push(this._loadMeshPrimitiveAsync(`${context}/primitives/${primitive.index}`, `${name}_primitive${primitive.index}`, node, mesh, primitive, (babylonMesh) => {\n                    babylonMesh.parent = node._babylonTransformNode;\n                    node._primitiveBabylonMeshes.push(babylonMesh);\n                }));\n            }\n        }\n        assign(node._babylonTransformNode);\n        this.logClose();\n        return Promise.all(promises).then(() => {\n            return node._babylonTransformNode;\n        });\n    }\n    /**\n     * @internal Define this method to modify the default behavior when loading data for mesh primitives.\n     * @param context The context when loading the asset\n     * @param name The mesh name when loading the asset\n     * @param node The glTF node when loading the asset\n     * @param mesh The glTF mesh when loading the asset\n     * @param primitive The glTF mesh primitive property\n     * @param assign A function called synchronously after parsing the glTF properties\n     * @returns A promise that resolves with the loaded mesh when the load is complete or null if not handled\n     */\n    _loadMeshPrimitiveAsync(context, name, node, mesh, primitive, assign) {\n        const extensionPromise = this._extensionsLoadMeshPrimitiveAsync(context, name, node, mesh, primitive, assign);\n        if (extensionPromise) {\n            return extensionPromise;\n        }\n        this.logOpen(`${context}`);\n        const shouldInstance = this._disableInstancedMesh === 0 && this._parent.createInstances && node.skin == undefined && !mesh.primitives[0].targets;\n        let babylonAbstractMesh;\n        let promise;\n        if (shouldInstance && primitive._instanceData) {\n            this._babylonScene._blockEntityCollection = !!this._assetContainer;\n            babylonAbstractMesh = primitive._instanceData.babylonSourceMesh.createInstance(name);\n            babylonAbstractMesh._parentContainer = this._assetContainer;\n            this._babylonScene._blockEntityCollection = false;\n            promise = primitive._instanceData.promise;\n        }\n        else {\n            const promises = new Array();\n            this._babylonScene._blockEntityCollection = !!this._assetContainer;\n            const babylonMesh = new Mesh(name, this._babylonScene);\n            babylonMesh._parentContainer = this._assetContainer;\n            this._babylonScene._blockEntityCollection = false;\n            babylonMesh.overrideMaterialSideOrientation = this._babylonScene.useRightHandedSystem ? Material.CounterClockWiseSideOrientation : Material.ClockWiseSideOrientation;\n            this._createMorphTargets(context, node, mesh, primitive, babylonMesh);\n            promises.push(this._loadVertexDataAsync(context, primitive, babylonMesh).then((babylonGeometry) => {\n                return this._loadMorphTargetsAsync(context, primitive, babylonMesh, babylonGeometry).then(() => {\n                    if (this._disposed) {\n                        return;\n                    }\n                    this._babylonScene._blockEntityCollection = !!this._assetContainer;\n                    babylonGeometry.applyToMesh(babylonMesh);\n                    babylonGeometry._parentContainer = this._assetContainer;\n                    this._babylonScene._blockEntityCollection = false;\n                });\n            }));\n            const babylonDrawMode = GLTFLoader._GetDrawMode(context, primitive.mode);\n            if (primitive.material == undefined) {\n                let babylonMaterial = this._defaultBabylonMaterialData[babylonDrawMode];\n                if (!babylonMaterial) {\n                    babylonMaterial = this._createDefaultMaterial(\"__GLTFLoader._default\", babylonDrawMode);\n                    this._parent.onMaterialLoadedObservable.notifyObservers(babylonMaterial);\n                    this._defaultBabylonMaterialData[babylonDrawMode] = babylonMaterial;\n                }\n                babylonMesh.material = babylonMaterial;\n            }\n            else if (!this.parent.skipMaterials) {\n                const material = ArrayItem.Get(`${context}/material`, this._gltf.materials, primitive.material);\n                promises.push(this._loadMaterialAsync(`/materials/${material.index}`, material, babylonMesh, babylonDrawMode, (babylonMaterial) => {\n                    babylonMesh.material = babylonMaterial;\n                }));\n            }\n            promise = Promise.all(promises);\n            if (shouldInstance) {\n                primitive._instanceData = {\n                    babylonSourceMesh: babylonMesh,\n                    promise: promise,\n                };\n            }\n            babylonAbstractMesh = babylonMesh;\n        }\n        GLTFLoader.AddPointerMetadata(babylonAbstractMesh, context);\n        this._parent.onMeshLoadedObservable.notifyObservers(babylonAbstractMesh);\n        assign(babylonAbstractMesh);\n        this.logClose();\n        return promise.then(() => {\n            return babylonAbstractMesh;\n        });\n    }\n    _loadVertexDataAsync(context, primitive, babylonMesh) {\n        const extensionPromise = this._extensionsLoadVertexDataAsync(context, primitive, babylonMesh);\n        if (extensionPromise) {\n            return extensionPromise;\n        }\n        const attributes = primitive.attributes;\n        if (!attributes) {\n            throw new Error(`${context}: Attributes are missing`);\n        }\n        const promises = new Array();\n        const babylonGeometry = new Geometry(babylonMesh.name, this._babylonScene);\n        if (primitive.indices == undefined) {\n            babylonMesh.isUnIndexed = true;\n        }\n        else {\n            const accessor = ArrayItem.Get(`${context}/indices`, this._gltf.accessors, primitive.indices);\n            promises.push(this._loadIndicesAccessorAsync(`/accessors/${accessor.index}`, accessor).then((data) => {\n                babylonGeometry.setIndices(data);\n            }));\n        }\n        const loadAttribute = (attribute, kind, callback) => {\n            if (attributes[attribute] == undefined) {\n                return;\n            }\n            babylonMesh._delayInfo = babylonMesh._delayInfo || [];\n            if (babylonMesh._delayInfo.indexOf(kind) === -1) {\n                babylonMesh._delayInfo.push(kind);\n            }\n            const accessor = ArrayItem.Get(`${context}/attributes/${attribute}`, this._gltf.accessors, attributes[attribute]);\n            promises.push(this._loadVertexAccessorAsync(`/accessors/${accessor.index}`, accessor, kind).then((babylonVertexBuffer) => {\n                if (babylonVertexBuffer.getKind() === VertexBuffer.PositionKind && !this.parent.alwaysComputeBoundingBox && !babylonMesh.skeleton) {\n                    const mmin = accessor.min, mmax = accessor.max;\n                    if (mmin !== undefined && mmax !== undefined) {\n                        if (accessor.normalized && accessor.componentType !== 5126 /* AccessorComponentType.FLOAT */) {\n                            let divider = 1;\n                            switch (accessor.componentType) {\n                                case 5120 /* AccessorComponentType.BYTE */:\n                                    divider = 127.0;\n                                    break;\n                                case 5121 /* AccessorComponentType.UNSIGNED_BYTE */:\n                                    divider = 255.0;\n                                    break;\n                                case 5122 /* AccessorComponentType.SHORT */:\n                                    divider = 32767.0;\n                                    break;\n                                case 5123 /* AccessorComponentType.UNSIGNED_SHORT */:\n                                    divider = 65535.0;\n                                    break;\n                            }\n                            for (let i = 0; i < 3; ++i) {\n                                mmin[i] = Math.max(mmin[i] / divider, -1.0);\n                                mmax[i] = Math.max(mmax[i] / divider, -1.0);\n                            }\n                        }\n                        const min = TmpVectors.Vector3[0], max = TmpVectors.Vector3[1];\n                        min.copyFromFloats(...mmin);\n                        max.copyFromFloats(...mmax);\n                        babylonGeometry._boundingInfo = new BoundingInfo(min, max);\n                        babylonGeometry.useBoundingInfoFromGeometry = true;\n                    }\n                }\n                babylonGeometry.setVerticesBuffer(babylonVertexBuffer, accessor.count);\n            }));\n            if (kind == VertexBuffer.MatricesIndicesExtraKind) {\n                babylonMesh.numBoneInfluencers = 8;\n            }\n            if (callback) {\n                callback(accessor);\n            }\n        };\n        loadAttribute(\"POSITION\", VertexBuffer.PositionKind);\n        loadAttribute(\"NORMAL\", VertexBuffer.NormalKind);\n        loadAttribute(\"TANGENT\", VertexBuffer.TangentKind);\n        loadAttribute(\"TEXCOORD_0\", VertexBuffer.UVKind);\n        loadAttribute(\"TEXCOORD_1\", VertexBuffer.UV2Kind);\n        loadAttribute(\"TEXCOORD_2\", VertexBuffer.UV3Kind);\n        loadAttribute(\"TEXCOORD_3\", VertexBuffer.UV4Kind);\n        loadAttribute(\"TEXCOORD_4\", VertexBuffer.UV5Kind);\n        loadAttribute(\"TEXCOORD_5\", VertexBuffer.UV6Kind);\n        loadAttribute(\"JOINTS_0\", VertexBuffer.MatricesIndicesKind);\n        loadAttribute(\"WEIGHTS_0\", VertexBuffer.MatricesWeightsKind);\n        loadAttribute(\"JOINTS_1\", VertexBuffer.MatricesIndicesExtraKind);\n        loadAttribute(\"WEIGHTS_1\", VertexBuffer.MatricesWeightsExtraKind);\n        loadAttribute(\"COLOR_0\", VertexBuffer.ColorKind, (accessor) => {\n            if (accessor.type === \"VEC4\" /* AccessorType.VEC4 */) {\n                babylonMesh.hasVertexAlpha = true;\n            }\n        });\n        return Promise.all(promises).then(() => {\n            return babylonGeometry;\n        });\n    }\n    _createMorphTargets(context, node, mesh, primitive, babylonMesh) {\n        if (!primitive.targets) {\n            return;\n        }\n        if (node._numMorphTargets == undefined) {\n            node._numMorphTargets = primitive.targets.length;\n        }\n        else if (primitive.targets.length !== node._numMorphTargets) {\n            throw new Error(`${context}: Primitives do not have the same number of targets`);\n        }\n        const targetNames = mesh.extras ? mesh.extras.targetNames : null;\n        babylonMesh.morphTargetManager = new MorphTargetManager(babylonMesh.getScene());\n        babylonMesh.morphTargetManager.areUpdatesFrozen = true;\n        for (let index = 0; index < primitive.targets.length; index++) {\n            const weight = node.weights ? node.weights[index] : mesh.weights ? mesh.weights[index] : 0;\n            const name = targetNames ? targetNames[index] : `morphTarget${index}`;\n            babylonMesh.morphTargetManager.addTarget(new MorphTarget(name, weight, babylonMesh.getScene()));\n            // TODO: tell the target whether it has positions, normals, tangents\n        }\n    }\n    _loadMorphTargetsAsync(context, primitive, babylonMesh, babylonGeometry) {\n        if (!primitive.targets) {\n            return Promise.resolve();\n        }\n        const promises = new Array();\n        const morphTargetManager = babylonMesh.morphTargetManager;\n        for (let index = 0; index < morphTargetManager.numTargets; index++) {\n            const babylonMorphTarget = morphTargetManager.getTarget(index);\n            promises.push(this._loadMorphTargetVertexDataAsync(`${context}/targets/${index}`, babylonGeometry, primitive.targets[index], babylonMorphTarget));\n        }\n        return Promise.all(promises).then(() => {\n            morphTargetManager.areUpdatesFrozen = false;\n        });\n    }\n    _loadMorphTargetVertexDataAsync(context, babylonGeometry, attributes, babylonMorphTarget) {\n        const promises = new Array();\n        const loadAttribute = (attribute, kind, setData) => {\n            if (attributes[attribute] == undefined) {\n                return;\n            }\n            const babylonVertexBuffer = babylonGeometry.getVertexBuffer(kind);\n            if (!babylonVertexBuffer) {\n                return;\n            }\n            const accessor = ArrayItem.Get(`${context}/${attribute}`, this._gltf.accessors, attributes[attribute]);\n            promises.push(this._loadFloatAccessorAsync(`/accessors/${accessor.index}`, accessor).then((data) => {\n                setData(babylonVertexBuffer, data);\n            }));\n        };\n        loadAttribute(\"POSITION\", VertexBuffer.PositionKind, (babylonVertexBuffer, data) => {\n            const positions = new Float32Array(data.length);\n            babylonVertexBuffer.forEach(data.length, (value, index) => {\n                positions[index] = data[index] + value;\n            });\n            babylonMorphTarget.setPositions(positions);\n        });\n        loadAttribute(\"NORMAL\", VertexBuffer.NormalKind, (babylonVertexBuffer, data) => {\n            const normals = new Float32Array(data.length);\n            babylonVertexBuffer.forEach(normals.length, (value, index) => {\n                normals[index] = data[index] + value;\n            });\n            babylonMorphTarget.setNormals(normals);\n        });\n        loadAttribute(\"TANGENT\", VertexBuffer.TangentKind, (babylonVertexBuffer, data) => {\n            const tangents = new Float32Array((data.length / 3) * 4);\n            let dataIndex = 0;\n            babylonVertexBuffer.forEach((data.length / 3) * 4, (value, index) => {\n                // Tangent data for morph targets is stored as xyz delta.\n                // The vertexData.tangent is stored as xyzw.\n                // So we need to skip every fourth vertexData.tangent.\n                if ((index + 1) % 4 !== 0) {\n                    tangents[dataIndex] = data[dataIndex] + value;\n                    dataIndex++;\n                }\n            });\n            babylonMorphTarget.setTangents(tangents);\n        });\n        return Promise.all(promises).then(() => { });\n    }\n    static _LoadTransform(node, babylonNode) {\n        // Ignore the TRS of skinned nodes.\n        // See https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins (second implementation note)\n        if (node.skin != undefined) {\n            return;\n        }\n        let position = Vector3.Zero();\n        let rotation = Quaternion.Identity();\n        let scaling = Vector3.One();\n        if (node.matrix) {\n            const matrix = Matrix.FromArray(node.matrix);\n            matrix.decompose(scaling, rotation, position);\n        }\n        else {\n            if (node.translation) {\n                position = Vector3.FromArray(node.translation);\n            }\n            if (node.rotation) {\n                rotation = Quaternion.FromArray(node.rotation);\n            }\n            if (node.scale) {\n                scaling = Vector3.FromArray(node.scale);\n            }\n        }\n        babylonNode.position = position;\n        babylonNode.rotationQuaternion = rotation;\n        babylonNode.scaling = scaling;\n    }\n    _loadSkinAsync(context, node, skin, assign) {\n        const extensionPromise = this._extensionsLoadSkinAsync(context, node, skin);\n        if (extensionPromise) {\n            return extensionPromise;\n        }\n        if (skin._data) {\n            assign(skin._data.babylonSkeleton);\n            return skin._data.promise;\n        }\n        const skeletonId = `skeleton${skin.index}`;\n        this._babylonScene._blockEntityCollection = !!this._assetContainer;\n        const babylonSkeleton = new Skeleton(skin.name || skeletonId, skeletonId, this._babylonScene);\n        babylonSkeleton._parentContainer = this._assetContainer;\n        this._babylonScene._blockEntityCollection = false;\n        this._loadBones(context, skin, babylonSkeleton);\n        const promise = this._loadSkinInverseBindMatricesDataAsync(context, skin).then((inverseBindMatricesData) => {\n            this._updateBoneMatrices(babylonSkeleton, inverseBindMatricesData);\n        });\n        skin._data = {\n            babylonSkeleton: babylonSkeleton,\n            promise: promise,\n        };\n        assign(babylonSkeleton);\n        return promise;\n    }\n    _loadBones(context, skin, babylonSkeleton) {\n        if (skin.skeleton == undefined || this._parent.alwaysComputeSkeletonRootNode) {\n            const rootNode = this._findSkeletonRootNode(`${context}/joints`, skin.joints);\n            if (rootNode) {\n                if (skin.skeleton === undefined) {\n                    skin.skeleton = rootNode.index;\n                }\n                else {\n                    const isParent = (a, b) => {\n                        for (; b.parent; b = b.parent) {\n                            if (b.parent === a) {\n                                return true;\n                            }\n                        }\n                        return false;\n                    };\n                    const skeletonNode = ArrayItem.Get(`${context}/skeleton`, this._gltf.nodes, skin.skeleton);\n                    if (skeletonNode !== rootNode && !isParent(skeletonNode, rootNode)) {\n                        Logger.Warn(`${context}/skeleton: Overriding with nearest common ancestor as skeleton node is not a common root`);\n                        skin.skeleton = rootNode.index;\n                    }\n                }\n            }\n            else {\n                Logger.Warn(`${context}: Failed to find common root`);\n            }\n        }\n        const babylonBones = {};\n        for (const index of skin.joints) {\n            const node = ArrayItem.Get(`${context}/joints/${index}`, this._gltf.nodes, index);\n            this._loadBone(node, skin, babylonSkeleton, babylonBones);\n        }\n    }\n    _findSkeletonRootNode(context, joints) {\n        if (joints.length === 0) {\n            return null;\n        }\n        const paths = {};\n        for (const index of joints) {\n            const path = new Array();\n            let node = ArrayItem.Get(`${context}/${index}`, this._gltf.nodes, index);\n            while (node.index !== -1) {\n                path.unshift(node);\n                node = node.parent;\n            }\n            paths[index] = path;\n        }\n        let rootNode = null;\n        for (let i = 0;; ++i) {\n            let path = paths[joints[0]];\n            if (i >= path.length) {\n                return rootNode;\n            }\n            const node = path[i];\n            for (let j = 1; j < joints.length; ++j) {\n                path = paths[joints[j]];\n                if (i >= path.length || node !== path[i]) {\n                    return rootNode;\n                }\n            }\n            rootNode = node;\n        }\n    }\n    _loadBone(node, skin, babylonSkeleton, babylonBones) {\n        let babylonBone = babylonBones[node.index];\n        if (babylonBone) {\n            return babylonBone;\n        }\n        let parentBabylonBone = null;\n        if (node.index !== skin.skeleton) {\n            if (node.parent && node.parent.index !== -1) {\n                parentBabylonBone = this._loadBone(node.parent, skin, babylonSkeleton, babylonBones);\n            }\n            else if (skin.skeleton !== undefined) {\n                Logger.Warn(`/skins/${skin.index}/skeleton: Skeleton node is not a common root`);\n            }\n        }\n        const boneIndex = skin.joints.indexOf(node.index);\n        babylonBone = new Bone(node.name || `joint${node.index}`, babylonSkeleton, parentBabylonBone, this._getNodeMatrix(node), null, null, boneIndex);\n        babylonBones[node.index] = babylonBone;\n        // Wait until the scene is loaded to ensure the transform nodes are loaded.\n        this._postSceneLoadActions.push(() => {\n            // Link the Babylon bone with the corresponding Babylon transform node.\n            // A glTF joint is a pointer to a glTF node in the glTF node hierarchy similar to Unity3D.\n            babylonBone.linkTransformNode(node._babylonTransformNode);\n        });\n        return babylonBone;\n    }\n    _loadSkinInverseBindMatricesDataAsync(context, skin) {\n        if (skin.inverseBindMatrices == undefined) {\n            return Promise.resolve(null);\n        }\n        const accessor = ArrayItem.Get(`${context}/inverseBindMatrices`, this._gltf.accessors, skin.inverseBindMatrices);\n        return this._loadFloatAccessorAsync(`/accessors/${accessor.index}`, accessor);\n    }\n    _updateBoneMatrices(babylonSkeleton, inverseBindMatricesData) {\n        for (const babylonBone of babylonSkeleton.bones) {\n            const baseMatrix = Matrix.Identity();\n            const boneIndex = babylonBone._index;\n            if (inverseBindMatricesData && boneIndex !== -1) {\n                Matrix.FromArrayToRef(inverseBindMatricesData, boneIndex * 16, baseMatrix);\n                baseMatrix.invertToRef(baseMatrix);\n            }\n            const babylonParentBone = babylonBone.getParent();\n            if (babylonParentBone) {\n                baseMatrix.multiplyToRef(babylonParentBone.getInvertedAbsoluteTransform(), baseMatrix);\n            }\n            babylonBone.updateMatrix(baseMatrix, false, false);\n            babylonBone._updateDifferenceMatrix(undefined, false);\n        }\n    }\n    _getNodeMatrix(node) {\n        return node.matrix\n            ? Matrix.FromArray(node.matrix)\n            : Matrix.Compose(node.scale ? Vector3.FromArray(node.scale) : Vector3.One(), node.rotation ? Quaternion.FromArray(node.rotation) : Quaternion.Identity(), node.translation ? Vector3.FromArray(node.translation) : Vector3.Zero());\n    }\n    /**\n     * Loads a glTF camera.\n     * @param context The context when loading the asset\n     * @param camera The glTF camera property\n     * @param assign A function called synchronously after parsing the glTF properties\n     * @returns A promise that resolves with the loaded Babylon camera when the load is complete\n     */\n    loadCameraAsync(context, camera, assign = () => { }) {\n        const extensionPromise = this._extensionsLoadCameraAsync(context, camera, assign);\n        if (extensionPromise) {\n            return extensionPromise;\n        }\n        const promises = new Array();\n        this.logOpen(`${context} ${camera.name || \"\"}`);\n        this._babylonScene._blockEntityCollection = !!this._assetContainer;\n        const babylonCamera = new FreeCamera(camera.name || `camera${camera.index}`, Vector3.Zero(), this._babylonScene, false);\n        babylonCamera._parentContainer = this._assetContainer;\n        this._babylonScene._blockEntityCollection = false;\n        babylonCamera.ignoreParentScaling = true;\n        camera._babylonCamera = babylonCamera;\n        babylonCamera.rotation = new Vector3(0, Math.PI, 0);\n        switch (camera.type) {\n            case \"perspective\" /* CameraType.PERSPECTIVE */: {\n                const perspective = camera.perspective;\n                if (!perspective) {\n                    throw new Error(`${context}: Camera perspective properties are missing`);\n                }\n                babylonCamera.fov = perspective.yfov;\n                babylonCamera.minZ = perspective.znear;\n                babylonCamera.maxZ = perspective.zfar || 0;\n                break;\n            }\n            case \"orthographic\" /* CameraType.ORTHOGRAPHIC */: {\n                if (!camera.orthographic) {\n                    throw new Error(`${context}: Camera orthographic properties are missing`);\n                }\n                babylonCamera.mode = Camera.ORTHOGRAPHIC_CAMERA;\n                babylonCamera.orthoLeft = -camera.orthographic.xmag;\n                babylonCamera.orthoRight = camera.orthographic.xmag;\n                babylonCamera.orthoBottom = -camera.orthographic.ymag;\n                babylonCamera.orthoTop = camera.orthographic.ymag;\n                babylonCamera.minZ = camera.orthographic.znear;\n                babylonCamera.maxZ = camera.orthographic.zfar;\n                break;\n            }\n            default: {\n                throw new Error(`${context}: Invalid camera type (${camera.type})`);\n            }\n        }\n        GLTFLoader.AddPointerMetadata(babylonCamera, context);\n        this._parent.onCameraLoadedObservable.notifyObservers(babylonCamera);\n        assign(babylonCamera);\n        this.logClose();\n        return Promise.all(promises).then(() => {\n            return babylonCamera;\n        });\n    }\n    _loadAnimationsAsync() {\n        const animations = this._gltf.animations;\n        if (!animations) {\n            return Promise.resolve();\n        }\n        const promises = new Array();\n        for (let index = 0; index < animations.length; index++) {\n            const animation = animations[index];\n            promises.push(this.loadAnimationAsync(`/animations/${animation.index}`, animation).then((animationGroup) => {\n                // Delete the animation group if it ended up not having any animations in it.\n                if (animationGroup.targetedAnimations.length === 0) {\n                    animationGroup.dispose();\n                }\n            }));\n        }\n        return Promise.all(promises).then(() => { });\n    }\n    /**\n     * Loads a glTF animation.\n     * @param context The context when loading the asset\n     * @param animation The glTF animation property\n     * @returns A promise that resolves with the loaded Babylon animation group when the load is complete\n     */\n    loadAnimationAsync(context, animation) {\n        const promise = this._extensionsLoadAnimationAsync(context, animation);\n        if (promise) {\n            return promise;\n        }\n        this._babylonScene._blockEntityCollection = !!this._assetContainer;\n        const babylonAnimationGroup = new AnimationGroup(animation.name || `animation${animation.index}`, this._babylonScene);\n        babylonAnimationGroup._parentContainer = this._assetContainer;\n        this._babylonScene._blockEntityCollection = false;\n        animation._babylonAnimationGroup = babylonAnimationGroup;\n        const promises = new Array();\n        ArrayItem.Assign(animation.channels);\n        ArrayItem.Assign(animation.samplers);\n        for (const channel of animation.channels) {\n            promises.push(this._loadAnimationChannelAsync(`${context}/channels/${channel.index}`, context, animation, channel, (babylonTarget, babylonAnimation) => {\n                babylonTarget.animations = babylonTarget.animations || [];\n                babylonTarget.animations.push(babylonAnimation);\n                babylonAnimationGroup.addTargetedAnimation(babylonAnimation, babylonTarget);\n            }));\n        }\n        return Promise.all(promises).then(() => {\n            babylonAnimationGroup.normalize(0);\n            return babylonAnimationGroup;\n        });\n    }\n    /**\n     * @hidden\n     * Loads a glTF animation channel.\n     * @param context The context when loading the asset\n     * @param animationContext The context of the animation when loading the asset\n     * @param animation The glTF animation property\n     * @param channel The glTF animation channel property\n     * @param onLoad Called for each animation loaded\n     * @returns A void promise that resolves when the load is complete\n     */\n    _loadAnimationChannelAsync(context, animationContext, animation, channel, onLoad) {\n        const promise = this._extensionsLoadAnimationChannelAsync(context, animationContext, animation, channel, onLoad);\n        if (promise) {\n            return promise;\n        }\n        if (channel.target.node == undefined) {\n            return Promise.resolve();\n        }\n        const targetNode = ArrayItem.Get(`${context}/target/node`, this._gltf.nodes, channel.target.node);\n        // Ignore animations that have no animation targets.\n        if ((channel.target.path === \"weights\" /* AnimationChannelTargetPath.WEIGHTS */ && !targetNode._numMorphTargets) ||\n            (channel.target.path !== \"weights\" /* AnimationChannelTargetPath.WEIGHTS */ && !targetNode._babylonTransformNode)) {\n            return Promise.resolve();\n        }\n        let properties;\n        switch (channel.target.path) {\n            case \"translation\" /* AnimationChannelTargetPath.TRANSLATION */: {\n                properties = nodeAnimationData.translation;\n                break;\n            }\n            case \"rotation\" /* AnimationChannelTargetPath.ROTATION */: {\n                properties = nodeAnimationData.rotation;\n                break;\n            }\n            case \"scale\" /* AnimationChannelTargetPath.SCALE */: {\n                properties = nodeAnimationData.scale;\n                break;\n            }\n            case \"weights\" /* AnimationChannelTargetPath.WEIGHTS */: {\n                properties = nodeAnimationData.weights;\n                break;\n            }\n            default: {\n                throw new Error(`${context}/target/path: Invalid value (${channel.target.path})`);\n            }\n        }\n        const targetInfo = {\n            target: targetNode,\n            properties: properties,\n        };\n        return this._loadAnimationChannelFromTargetInfoAsync(context, animationContext, animation, channel, targetInfo, onLoad);\n    }\n    /**\n     * @hidden\n     * Loads a glTF animation channel.\n     * @param context The context when loading the asset\n     * @param animationContext The context of the animation when loading the asset\n     * @param animation The glTF animation property\n     * @param channel The glTF animation channel property\n     * @param targetInfo The glTF target and properties\n     * @param onLoad Called for each animation loaded\n     * @returns A void promise that resolves when the load is complete\n     */\n    _loadAnimationChannelFromTargetInfoAsync(context, animationContext, animation, channel, targetInfo, onLoad) {\n        const fps = this.parent.targetFps;\n        const invfps = 1 / fps;\n        const sampler = ArrayItem.Get(`${context}/sampler`, animation.samplers, channel.sampler);\n        return this._loadAnimationSamplerAsync(`${animationContext}/samplers/${channel.sampler}`, sampler).then((data) => {\n            let numAnimations = 0;\n            // Extract the corresponding values from the read value.\n            // GLTF values may be dispatched to several Babylon properties.\n            // For example, baseColorFactor [`r`, `g`, `b`, `a`] is dispatched to\n            // - albedoColor as Color3(`r`, `g`, `b`)\n            // - alpha as `a`\n            for (const property of targetInfo.properties) {\n                const stride = property.getStride(targetInfo.target);\n                const input = data.input;\n                const output = data.output;\n                const keys = new Array(input.length);\n                let outputOffset = 0;\n                switch (data.interpolation) {\n                    case \"STEP\" /* AnimationSamplerInterpolation.STEP */: {\n                        for (let index = 0; index < input.length; index++) {\n                            const value = property.getValue(targetInfo.target, output, outputOffset, 1);\n                            outputOffset += stride;\n                            keys[index] = {\n                                frame: input[index] * fps,\n                                value: value,\n                                interpolation: AnimationKeyInterpolation.STEP,\n                            };\n                        }\n                        break;\n                    }\n                    case \"CUBICSPLINE\" /* AnimationSamplerInterpolation.CUBICSPLINE */: {\n                        for (let index = 0; index < input.length; index++) {\n                            const inTangent = property.getValue(targetInfo.target, output, outputOffset, invfps);\n                            outputOffset += stride;\n                            const value = property.getValue(targetInfo.target, output, outputOffset, 1);\n                            outputOffset += stride;\n                            const outTangent = property.getValue(targetInfo.target, output, outputOffset, invfps);\n                            outputOffset += stride;\n                            keys[index] = {\n                                frame: input[index] * fps,\n                                inTangent: inTangent,\n                                value: value,\n                                outTangent: outTangent,\n                            };\n                        }\n                        break;\n                    }\n                    case \"LINEAR\" /* AnimationSamplerInterpolation.LINEAR */: {\n                        for (let index = 0; index < input.length; index++) {\n                            const value = property.getValue(targetInfo.target, output, outputOffset, 1);\n                            outputOffset += stride;\n                            keys[index] = {\n                                frame: input[index] * fps,\n                                value: value,\n                            };\n                        }\n                        break;\n                    }\n                }\n                if (outputOffset > 0) {\n                    const name = `${animation.name || `animation${animation.index}`}_channel${channel.index}_${numAnimations}`;\n                    property.buildAnimations(targetInfo.target, name, fps, keys, (babylonAnimatable, babylonAnimation) => {\n                        ++numAnimations;\n                        onLoad(babylonAnimatable, babylonAnimation);\n                    });\n                }\n            }\n        });\n    }\n    _loadAnimationSamplerAsync(context, sampler) {\n        if (sampler._data) {\n            return sampler._data;\n        }\n        const interpolation = sampler.interpolation || \"LINEAR\" /* AnimationSamplerInterpolation.LINEAR */;\n        switch (interpolation) {\n            case \"STEP\" /* AnimationSamplerInterpolation.STEP */:\n            case \"LINEAR\" /* AnimationSamplerInterpolation.LINEAR */:\n            case \"CUBICSPLINE\" /* AnimationSamplerInterpolation.CUBICSPLINE */: {\n                break;\n            }\n            default: {\n                throw new Error(`${context}/interpolation: Invalid value (${sampler.interpolation})`);\n            }\n        }\n        const inputAccessor = ArrayItem.Get(`${context}/input`, this._gltf.accessors, sampler.input);\n        const outputAccessor = ArrayItem.Get(`${context}/output`, this._gltf.accessors, sampler.output);\n        sampler._data = Promise.all([\n            this._loadFloatAccessorAsync(`/accessors/${inputAccessor.index}`, inputAccessor),\n            this._loadFloatAccessorAsync(`/accessors/${outputAccessor.index}`, outputAccessor),\n        ]).then(([inputData, outputData]) => {\n            return {\n                input: inputData,\n                interpolation: interpolation,\n                output: outputData,\n            };\n        });\n        return sampler._data;\n    }\n    /**\n     * Loads a glTF buffer.\n     * @param context The context when loading the asset\n     * @param buffer The glTF buffer property\n     * @param byteOffset The byte offset to use\n     * @param byteLength The byte length to use\n     * @returns A promise that resolves with the loaded data when the load is complete\n     */\n    loadBufferAsync(context, buffer, byteOffset, byteLength) {\n        const extensionPromise = this._extensionsLoadBufferAsync(context, buffer, byteOffset, byteLength);\n        if (extensionPromise) {\n            return extensionPromise;\n        }\n        if (!buffer._data) {\n            if (buffer.uri) {\n                buffer._data = this.loadUriAsync(`${context}/uri`, buffer, buffer.uri);\n            }\n            else {\n                if (!this._bin) {\n                    throw new Error(`${context}: Uri is missing or the binary glTF is missing its binary chunk`);\n                }\n                buffer._data = this._bin.readAsync(0, buffer.byteLength);\n            }\n        }\n        return buffer._data.then((data) => {\n            try {\n                return new Uint8Array(data.buffer, data.byteOffset + byteOffset, byteLength);\n            }\n            catch (e) {\n                throw new Error(`${context}: ${e.message}`);\n            }\n        });\n    }\n    /**\n     * Loads a glTF buffer view.\n     * @param context The context when loading the asset\n     * @param bufferView The glTF buffer view property\n     * @returns A promise that resolves with the loaded data when the load is complete\n     */\n    loadBufferViewAsync(context, bufferView) {\n        const extensionPromise = this._extensionsLoadBufferViewAsync(context, bufferView);\n        if (extensionPromise) {\n            return extensionPromise;\n        }\n        if (bufferView._data) {\n            return bufferView._data;\n        }\n        const buffer = ArrayItem.Get(`${context}/buffer`, this._gltf.buffers, bufferView.buffer);\n        bufferView._data = this.loadBufferAsync(`/buffers/${buffer.index}`, buffer, bufferView.byteOffset || 0, bufferView.byteLength);\n        return bufferView._data;\n    }\n    _loadAccessorAsync(context, accessor, constructor) {\n        if (accessor._data) {\n            return accessor._data;\n        }\n        const numComponents = GLTFLoader._GetNumComponents(context, accessor.type);\n        const byteStride = numComponents * VertexBuffer.GetTypeByteLength(accessor.componentType);\n        const length = numComponents * accessor.count;\n        if (accessor.bufferView == undefined) {\n            accessor._data = Promise.resolve(new constructor(length));\n        }\n        else {\n            const bufferView = ArrayItem.Get(`${context}/bufferView`, this._gltf.bufferViews, accessor.bufferView);\n            accessor._data = this.loadBufferViewAsync(`/bufferViews/${bufferView.index}`, bufferView).then((data) => {\n                if (accessor.componentType === 5126 /* AccessorComponentType.FLOAT */ && !accessor.normalized && (!bufferView.byteStride || bufferView.byteStride === byteStride)) {\n                    return GLTFLoader._GetTypedArray(context, accessor.componentType, data, accessor.byteOffset, length);\n                }\n                else {\n                    const typedArray = new constructor(length);\n                    VertexBuffer.ForEach(data, accessor.byteOffset || 0, bufferView.byteStride || byteStride, numComponents, accessor.componentType, typedArray.length, accessor.normalized || false, (value, index) => {\n                        typedArray[index] = value;\n                    });\n                    return typedArray;\n                }\n            });\n        }\n        if (accessor.sparse) {\n            const sparse = accessor.sparse;\n            accessor._data = accessor._data.then((data) => {\n                const typedArray = data;\n                const indicesBufferView = ArrayItem.Get(`${context}/sparse/indices/bufferView`, this._gltf.bufferViews, sparse.indices.bufferView);\n                const valuesBufferView = ArrayItem.Get(`${context}/sparse/values/bufferView`, this._gltf.bufferViews, sparse.values.bufferView);\n                return Promise.all([\n                    this.loadBufferViewAsync(`/bufferViews/${indicesBufferView.index}`, indicesBufferView),\n                    this.loadBufferViewAsync(`/bufferViews/${valuesBufferView.index}`, valuesBufferView),\n                ]).then(([indicesData, valuesData]) => {\n                    const indices = GLTFLoader._GetTypedArray(`${context}/sparse/indices`, sparse.indices.componentType, indicesData, sparse.indices.byteOffset, sparse.count);\n                    const sparseLength = numComponents * sparse.count;\n                    let values;\n                    if (accessor.componentType === 5126 /* AccessorComponentType.FLOAT */ && !accessor.normalized) {\n                        values = GLTFLoader._GetTypedArray(`${context}/sparse/values`, accessor.componentType, valuesData, sparse.values.byteOffset, sparseLength);\n                    }\n                    else {\n                        const sparseData = GLTFLoader._GetTypedArray(`${context}/sparse/values`, accessor.componentType, valuesData, sparse.values.byteOffset, sparseLength);\n                        values = new constructor(sparseLength);\n                        VertexBuffer.ForEach(sparseData, 0, byteStride, numComponents, accessor.componentType, values.length, accessor.normalized || false, (value, index) => {\n                            values[index] = value;\n                        });\n                    }\n                    let valuesIndex = 0;\n                    for (let indicesIndex = 0; indicesIndex < indices.length; indicesIndex++) {\n                        let dataIndex = indices[indicesIndex] * numComponents;\n                        for (let componentIndex = 0; componentIndex < numComponents; componentIndex++) {\n                            typedArray[dataIndex++] = values[valuesIndex++];\n                        }\n                    }\n                    return typedArray;\n                });\n            });\n        }\n        return accessor._data;\n    }\n    /**\n     * @internal\n     */\n    _loadFloatAccessorAsync(context, accessor) {\n        return this._loadAccessorAsync(context, accessor, Float32Array);\n    }\n    _loadIndicesAccessorAsync(context, accessor) {\n        if (accessor.type !== \"SCALAR\" /* AccessorType.SCALAR */) {\n            throw new Error(`${context}/type: Invalid value ${accessor.type}`);\n        }\n        if (accessor.componentType !== 5121 /* AccessorComponentType.UNSIGNED_BYTE */ &&\n            accessor.componentType !== 5123 /* AccessorComponentType.UNSIGNED_SHORT */ &&\n            accessor.componentType !== 5125 /* AccessorComponentType.UNSIGNED_INT */) {\n            throw new Error(`${context}/componentType: Invalid value ${accessor.componentType}`);\n        }\n        if (accessor._data) {\n            return accessor._data;\n        }\n        if (accessor.sparse) {\n            const constructor = GLTFLoader._GetTypedArrayConstructor(`${context}/componentType`, accessor.componentType);\n            accessor._data = this._loadAccessorAsync(context, accessor, constructor);\n        }\n        else {\n            const bufferView = ArrayItem.Get(`${context}/bufferView`, this._gltf.bufferViews, accessor.bufferView);\n            accessor._data = this.loadBufferViewAsync(`/bufferViews/${bufferView.index}`, bufferView).then((data) => {\n                return GLTFLoader._GetTypedArray(context, accessor.componentType, data, accessor.byteOffset, accessor.count);\n            });\n        }\n        return accessor._data;\n    }\n    _loadVertexBufferViewAsync(bufferView) {\n        if (bufferView._babylonBuffer) {\n            return bufferView._babylonBuffer;\n        }\n        const engine = this._babylonScene.getEngine();\n        bufferView._babylonBuffer = this.loadBufferViewAsync(`/bufferViews/${bufferView.index}`, bufferView).then((data) => {\n            return new Buffer(engine, data, false);\n        });\n        return bufferView._babylonBuffer;\n    }\n    _loadVertexAccessorAsync(context, accessor, kind) {\n        var _a;\n        if ((_a = accessor._babylonVertexBuffer) === null || _a === void 0 ? void 0 : _a[kind]) {\n            return accessor._babylonVertexBuffer[kind];\n        }\n        if (!accessor._babylonVertexBuffer) {\n            accessor._babylonVertexBuffer = {};\n        }\n        const engine = this._babylonScene.getEngine();\n        if (accessor.sparse) {\n            accessor._babylonVertexBuffer[kind] = this._loadFloatAccessorAsync(context, accessor).then((data) => {\n                return new VertexBuffer(engine, data, kind, false);\n            });\n        }\n        // Load joint indices as a float array since the shaders expect float data but glTF uses unsigned byte/short.\n        // This prevents certain platforms (e.g. D3D) from having to convert the data to float on the fly.\n        else if (kind === VertexBuffer.MatricesIndicesKind || kind === VertexBuffer.MatricesIndicesExtraKind) {\n            accessor._babylonVertexBuffer[kind] = this._loadFloatAccessorAsync(context, accessor).then((data) => {\n                return new VertexBuffer(engine, data, kind, false);\n            });\n        }\n        else {\n            const bufferView = ArrayItem.Get(`${context}/bufferView`, this._gltf.bufferViews, accessor.bufferView);\n            accessor._babylonVertexBuffer[kind] = this._loadVertexBufferViewAsync(bufferView).then((babylonBuffer) => {\n                const size = GLTFLoader._GetNumComponents(context, accessor.type);\n                return new VertexBuffer(engine, babylonBuffer, kind, false, false, bufferView.byteStride, false, accessor.byteOffset, size, accessor.componentType, accessor.normalized, true, 1, true);\n            });\n        }\n        return accessor._babylonVertexBuffer[kind];\n    }\n    _loadMaterialMetallicRoughnessPropertiesAsync(context, properties, babylonMaterial) {\n        if (!(babylonMaterial instanceof PBRMaterial)) {\n            throw new Error(`${context}: Material type not supported`);\n        }\n        const promises = new Array();\n        if (properties) {\n            if (properties.baseColorFactor) {\n                babylonMaterial.albedoColor = Color3.FromArray(properties.baseColorFactor);\n                babylonMaterial.alpha = properties.baseColorFactor[3];\n            }\n            else {\n                babylonMaterial.albedoColor = Color3.White();\n            }\n            babylonMaterial.metallic = properties.metallicFactor == undefined ? 1 : properties.metallicFactor;\n            babylonMaterial.roughness = properties.roughnessFactor == undefined ? 1 : properties.roughnessFactor;\n            if (properties.baseColorTexture) {\n                promises.push(this.loadTextureInfoAsync(`${context}/baseColorTexture`, properties.baseColorTexture, (texture) => {\n                    texture.name = `${babylonMaterial.name} (Base Color)`;\n                    babylonMaterial.albedoTexture = texture;\n                }));\n            }\n            if (properties.metallicRoughnessTexture) {\n                properties.metallicRoughnessTexture.nonColorData = true;\n                promises.push(this.loadTextureInfoAsync(`${context}/metallicRoughnessTexture`, properties.metallicRoughnessTexture, (texture) => {\n                    texture.name = `${babylonMaterial.name} (Metallic Roughness)`;\n                    babylonMaterial.metallicTexture = texture;\n                }));\n                babylonMaterial.useMetallnessFromMetallicTextureBlue = true;\n                babylonMaterial.useRoughnessFromMetallicTextureGreen = true;\n                babylonMaterial.useRoughnessFromMetallicTextureAlpha = false;\n            }\n        }\n        return Promise.all(promises).then(() => { });\n    }\n    /**\n     * @internal\n     */\n    _loadMaterialAsync(context, material, babylonMesh, babylonDrawMode, assign = () => { }) {\n        const extensionPromise = this._extensionsLoadMaterialAsync(context, material, babylonMesh, babylonDrawMode, assign);\n        if (extensionPromise) {\n            return extensionPromise;\n        }\n        material._data = material._data || {};\n        let babylonData = material._data[babylonDrawMode];\n        if (!babylonData) {\n            this.logOpen(`${context} ${material.name || \"\"}`);\n            const babylonMaterial = this.createMaterial(context, material, babylonDrawMode);\n            babylonData = {\n                babylonMaterial: babylonMaterial,\n                babylonMeshes: [],\n                promise: this.loadMaterialPropertiesAsync(context, material, babylonMaterial),\n            };\n            material._data[babylonDrawMode] = babylonData;\n            GLTFLoader.AddPointerMetadata(babylonMaterial, context);\n            this._parent.onMaterialLoadedObservable.notifyObservers(babylonMaterial);\n            this.logClose();\n        }\n        if (babylonMesh) {\n            babylonData.babylonMeshes.push(babylonMesh);\n            babylonMesh.onDisposeObservable.addOnce(() => {\n                const index = babylonData.babylonMeshes.indexOf(babylonMesh);\n                if (index !== -1) {\n                    babylonData.babylonMeshes.splice(index, 1);\n                }\n            });\n        }\n        assign(babylonData.babylonMaterial);\n        return babylonData.promise.then(() => {\n            return babylonData.babylonMaterial;\n        });\n    }\n    _createDefaultMaterial(name, babylonDrawMode) {\n        this._babylonScene._blockEntityCollection = !!this._assetContainer;\n        const babylonMaterial = new PBRMaterial(name, this._babylonScene);\n        babylonMaterial._parentContainer = this._assetContainer;\n        this._babylonScene._blockEntityCollection = false;\n        // Moved to mesh so user can change materials on gltf meshes: babylonMaterial.sideOrientation = this._babylonScene.useRightHandedSystem ? Material.CounterClockWiseSideOrientation : Material.ClockWiseSideOrientation;\n        babylonMaterial.fillMode = babylonDrawMode;\n        babylonMaterial.enableSpecularAntiAliasing = true;\n        babylonMaterial.useRadianceOverAlpha = !this._parent.transparencyAsCoverage;\n        babylonMaterial.useSpecularOverAlpha = !this._parent.transparencyAsCoverage;\n        babylonMaterial.transparencyMode = PBRMaterial.PBRMATERIAL_OPAQUE;\n        babylonMaterial.metallic = 1;\n        babylonMaterial.roughness = 1;\n        return babylonMaterial;\n    }\n    /**\n     * Creates a Babylon material from a glTF material.\n     * @param context The context when loading the asset\n     * @param material The glTF material property\n     * @param babylonDrawMode The draw mode for the Babylon material\n     * @returns The Babylon material\n     */\n    createMaterial(context, material, babylonDrawMode) {\n        const extensionPromise = this._extensionsCreateMaterial(context, material, babylonDrawMode);\n        if (extensionPromise) {\n            return extensionPromise;\n        }\n        const name = material.name || `material${material.index}`;\n        const babylonMaterial = this._createDefaultMaterial(name, babylonDrawMode);\n        return babylonMaterial;\n    }\n    /**\n     * Loads properties from a glTF material into a Babylon material.\n     * @param context The context when loading the asset\n     * @param material The glTF material property\n     * @param babylonMaterial The Babylon material\n     * @returns A promise that resolves when the load is complete\n     */\n    loadMaterialPropertiesAsync(context, material, babylonMaterial) {\n        const extensionPromise = this._extensionsLoadMaterialPropertiesAsync(context, material, babylonMaterial);\n        if (extensionPromise) {\n            return extensionPromise;\n        }\n        const promises = new Array();\n        promises.push(this.loadMaterialBasePropertiesAsync(context, material, babylonMaterial));\n        if (material.pbrMetallicRoughness) {\n            promises.push(this._loadMaterialMetallicRoughnessPropertiesAsync(`${context}/pbrMetallicRoughness`, material.pbrMetallicRoughness, babylonMaterial));\n        }\n        this.loadMaterialAlphaProperties(context, material, babylonMaterial);\n        return Promise.all(promises).then(() => { });\n    }\n    /**\n     * Loads the normal, occlusion, and emissive properties from a glTF material into a Babylon material.\n     * @param context The context when loading the asset\n     * @param material The glTF material property\n     * @param babylonMaterial The Babylon material\n     * @returns A promise that resolves when the load is complete\n     */\n    loadMaterialBasePropertiesAsync(context, material, babylonMaterial) {\n        if (!(babylonMaterial instanceof PBRMaterial)) {\n            throw new Error(`${context}: Material type not supported`);\n        }\n        const promises = new Array();\n        babylonMaterial.emissiveColor = material.emissiveFactor ? Color3.FromArray(material.emissiveFactor) : new Color3(0, 0, 0);\n        if (material.doubleSided) {\n            babylonMaterial.backFaceCulling = false;\n            babylonMaterial.twoSidedLighting = true;\n        }\n        if (material.normalTexture) {\n            material.normalTexture.nonColorData = true;\n            promises.push(this.loadTextureInfoAsync(`${context}/normalTexture`, material.normalTexture, (texture) => {\n                texture.name = `${babylonMaterial.name} (Normal)`;\n                babylonMaterial.bumpTexture = texture;\n            }));\n            babylonMaterial.invertNormalMapX = !this._babylonScene.useRightHandedSystem;\n            babylonMaterial.invertNormalMapY = this._babylonScene.useRightHandedSystem;\n            if (material.normalTexture.scale != undefined && babylonMaterial.bumpTexture) {\n                babylonMaterial.bumpTexture.level = material.normalTexture.scale;\n            }\n            babylonMaterial.forceIrradianceInFragment = true;\n        }\n        if (material.occlusionTexture) {\n            material.occlusionTexture.nonColorData = true;\n            promises.push(this.loadTextureInfoAsync(`${context}/occlusionTexture`, material.occlusionTexture, (texture) => {\n                texture.name = `${babylonMaterial.name} (Occlusion)`;\n                babylonMaterial.ambientTexture = texture;\n            }));\n            babylonMaterial.useAmbientInGrayScale = true;\n            if (material.occlusionTexture.strength != undefined) {\n                babylonMaterial.ambientTextureStrength = material.occlusionTexture.strength;\n            }\n        }\n        if (material.emissiveTexture) {\n            promises.push(this.loadTextureInfoAsync(`${context}/emissiveTexture`, material.emissiveTexture, (texture) => {\n                texture.name = `${babylonMaterial.name} (Emissive)`;\n                babylonMaterial.emissiveTexture = texture;\n            }));\n        }\n        return Promise.all(promises).then(() => { });\n    }\n    /**\n     * Loads the alpha properties from a glTF material into a Babylon material.\n     * Must be called after the setting the albedo texture of the Babylon material when the material has an albedo texture.\n     * @param context The context when loading the asset\n     * @param material The glTF material property\n     * @param babylonMaterial The Babylon material\n     */\n    loadMaterialAlphaProperties(context, material, babylonMaterial) {\n        if (!(babylonMaterial instanceof PBRMaterial)) {\n            throw new Error(`${context}: Material type not supported`);\n        }\n        const alphaMode = material.alphaMode || \"OPAQUE\" /* MaterialAlphaMode.OPAQUE */;\n        switch (alphaMode) {\n            case \"OPAQUE\" /* MaterialAlphaMode.OPAQUE */: {\n                babylonMaterial.transparencyMode = PBRMaterial.PBRMATERIAL_OPAQUE;\n                break;\n            }\n            case \"MASK\" /* MaterialAlphaMode.MASK */: {\n                babylonMaterial.transparencyMode = PBRMaterial.PBRMATERIAL_ALPHATEST;\n                babylonMaterial.alphaCutOff = material.alphaCutoff == undefined ? 0.5 : material.alphaCutoff;\n                if (babylonMaterial.albedoTexture) {\n                    babylonMaterial.albedoTexture.hasAlpha = true;\n                }\n                break;\n            }\n            case \"BLEND\" /* MaterialAlphaMode.BLEND */: {\n                babylonMaterial.transparencyMode = PBRMaterial.PBRMATERIAL_ALPHABLEND;\n                if (babylonMaterial.albedoTexture) {\n                    babylonMaterial.albedoTexture.hasAlpha = true;\n                    babylonMaterial.useAlphaFromAlbedoTexture = true;\n                }\n                break;\n            }\n            default: {\n                throw new Error(`${context}/alphaMode: Invalid value (${material.alphaMode})`);\n            }\n        }\n    }\n    /**\n     * Loads a glTF texture info.\n     * @param context The context when loading the asset\n     * @param textureInfo The glTF texture info property\n     * @param assign A function called synchronously after parsing the glTF properties\n     * @returns A promise that resolves with the loaded Babylon texture when the load is complete\n     */\n    loadTextureInfoAsync(context, textureInfo, assign = () => { }) {\n        const extensionPromise = this._extensionsLoadTextureInfoAsync(context, textureInfo, assign);\n        if (extensionPromise) {\n            return extensionPromise;\n        }\n        this.logOpen(`${context}`);\n        if (textureInfo.texCoord >= 6) {\n            throw new Error(`${context}/texCoord: Invalid value (${textureInfo.texCoord})`);\n        }\n        const texture = ArrayItem.Get(`${context}/index`, this._gltf.textures, textureInfo.index);\n        texture._textureInfo = textureInfo;\n        const promise = this._loadTextureAsync(`/textures/${textureInfo.index}`, texture, (babylonTexture) => {\n            babylonTexture.coordinatesIndex = textureInfo.texCoord || 0;\n            GLTFLoader.AddPointerMetadata(babylonTexture, context);\n            this._parent.onTextureLoadedObservable.notifyObservers(babylonTexture);\n            assign(babylonTexture);\n        });\n        this.logClose();\n        return promise;\n    }\n    /**\n     * @internal\n     */\n    _loadTextureAsync(context, texture, assign = () => { }) {\n        const extensionPromise = this._extensionsLoadTextureAsync(context, texture, assign);\n        if (extensionPromise) {\n            return extensionPromise;\n        }\n        this.logOpen(`${context} ${texture.name || \"\"}`);\n        const sampler = texture.sampler == undefined ? GLTFLoader.DefaultSampler : ArrayItem.Get(`${context}/sampler`, this._gltf.samplers, texture.sampler);\n        const image = ArrayItem.Get(`${context}/source`, this._gltf.images, texture.source);\n        const promise = this._createTextureAsync(context, sampler, image, assign, undefined, !texture._textureInfo.nonColorData);\n        this.logClose();\n        return promise;\n    }\n    /**\n     * @internal\n     */\n    _createTextureAsync(context, sampler, image, assign = () => { }, textureLoaderOptions, useSRGBBuffer) {\n        const samplerData = this._loadSampler(`/samplers/${sampler.index}`, sampler);\n        const promises = new Array();\n        const deferred = new Deferred();\n        this._babylonScene._blockEntityCollection = !!this._assetContainer;\n        const textureCreationOptions = {\n            noMipmap: samplerData.noMipMaps,\n            invertY: false,\n            samplingMode: samplerData.samplingMode,\n            onLoad: () => {\n                if (!this._disposed) {\n                    deferred.resolve();\n                }\n            },\n            onError: (message, exception) => {\n                if (!this._disposed) {\n                    deferred.reject(new Error(`${context}: ${exception && exception.message ? exception.message : message || \"Failed to load texture\"}`));\n                }\n            },\n            mimeType: image.mimeType,\n            loaderOptions: textureLoaderOptions,\n            useSRGBBuffer: !!useSRGBBuffer && this._parent.useSRGBBuffers,\n        };\n        const babylonTexture = new Texture(null, this._babylonScene, textureCreationOptions);\n        babylonTexture._parentContainer = this._assetContainer;\n        this._babylonScene._blockEntityCollection = false;\n        promises.push(deferred.promise);\n        promises.push(this.loadImageAsync(`/images/${image.index}`, image).then((data) => {\n            const name = image.uri || `${this._fileName}#image${image.index}`;\n            const dataUrl = `data:${this._uniqueRootUrl}${name}`;\n            babylonTexture.updateURL(dataUrl, data);\n        }));\n        babylonTexture.wrapU = samplerData.wrapU;\n        babylonTexture.wrapV = samplerData.wrapV;\n        assign(babylonTexture);\n        return Promise.all(promises).then(() => {\n            return babylonTexture;\n        });\n    }\n    _loadSampler(context, sampler) {\n        if (!sampler._data) {\n            sampler._data = {\n                noMipMaps: sampler.minFilter === 9728 /* TextureMinFilter.NEAREST */ || sampler.minFilter === 9729 /* TextureMinFilter.LINEAR */,\n                samplingMode: GLTFLoader._GetTextureSamplingMode(context, sampler),\n                wrapU: GLTFLoader._GetTextureWrapMode(`${context}/wrapS`, sampler.wrapS),\n                wrapV: GLTFLoader._GetTextureWrapMode(`${context}/wrapT`, sampler.wrapT),\n            };\n        }\n        return sampler._data;\n    }\n    /**\n     * Loads a glTF image.\n     * @param context The context when loading the asset\n     * @param image The glTF image property\n     * @returns A promise that resolves with the loaded data when the load is complete\n     */\n    loadImageAsync(context, image) {\n        if (!image._data) {\n            this.logOpen(`${context} ${image.name || \"\"}`);\n            if (image.uri) {\n                image._data = this.loadUriAsync(`${context}/uri`, image, image.uri);\n            }\n            else {\n                const bufferView = ArrayItem.Get(`${context}/bufferView`, this._gltf.bufferViews, image.bufferView);\n                image._data = this.loadBufferViewAsync(`/bufferViews/${bufferView.index}`, bufferView);\n            }\n            this.logClose();\n        }\n        return image._data;\n    }\n    /**\n     * Loads a glTF uri.\n     * @param context The context when loading the asset\n     * @param property The glTF property associated with the uri\n     * @param uri The base64 or relative uri\n     * @returns A promise that resolves with the loaded data when the load is complete\n     */\n    loadUriAsync(context, property, uri) {\n        const extensionPromise = this._extensionsLoadUriAsync(context, property, uri);\n        if (extensionPromise) {\n            return extensionPromise;\n        }\n        if (!GLTFLoader._ValidateUri(uri)) {\n            throw new Error(`${context}: '${uri}' is invalid`);\n        }\n        if (IsBase64DataUrl(uri)) {\n            const data = new Uint8Array(DecodeBase64UrlToBinary(uri));\n            this.log(`${context}: Decoded ${uri.substr(0, 64)}... (${data.length} bytes)`);\n            return Promise.resolve(data);\n        }\n        this.log(`${context}: Loading ${uri}`);\n        return this._parent.preprocessUrlAsync(this._rootUrl + uri).then((url) => {\n            return new Promise((resolve, reject) => {\n                this._parent._loadFile(this._babylonScene, url, (data) => {\n                    if (!this._disposed) {\n                        this.log(`${context}: Loaded ${uri} (${data.byteLength} bytes)`);\n                        resolve(new Uint8Array(data));\n                    }\n                }, true, (request) => {\n                    reject(new LoadFileError(`${context}: Failed to load '${uri}'${request ? \": \" + request.status + \" \" + request.statusText : \"\"}`, request));\n                });\n            });\n        });\n    }\n    /**\n     * Adds a JSON pointer to the _internalMetadata of the Babylon object at `<object>._internalMetadata.gltf.pointers`.\n     * @param babylonObject the Babylon object with _internalMetadata\n     * @param pointer the JSON pointer\n     */\n    static AddPointerMetadata(babylonObject, pointer) {\n        babylonObject.metadata = babylonObject.metadata || {};\n        const metadata = (babylonObject._internalMetadata = babylonObject._internalMetadata || {});\n        const gltf = (metadata.gltf = metadata.gltf || {});\n        const pointers = (gltf.pointers = gltf.pointers || []);\n        pointers.push(pointer);\n    }\n    static _GetTextureWrapMode(context, mode) {\n        // Set defaults if undefined\n        mode = mode == undefined ? 10497 /* TextureWrapMode.REPEAT */ : mode;\n        switch (mode) {\n            case 33071 /* TextureWrapMode.CLAMP_TO_EDGE */:\n                return Texture.CLAMP_ADDRESSMODE;\n            case 33648 /* TextureWrapMode.MIRRORED_REPEAT */:\n                return Texture.MIRROR_ADDRESSMODE;\n            case 10497 /* TextureWrapMode.REPEAT */:\n                return Texture.WRAP_ADDRESSMODE;\n            default:\n                Logger.Warn(`${context}: Invalid value (${mode})`);\n                return Texture.WRAP_ADDRESSMODE;\n        }\n    }\n    static _GetTextureSamplingMode(context, sampler) {\n        // Set defaults if undefined\n        const magFilter = sampler.magFilter == undefined ? 9729 /* TextureMagFilter.LINEAR */ : sampler.magFilter;\n        const minFilter = sampler.minFilter == undefined ? 9987 /* TextureMinFilter.LINEAR_MIPMAP_LINEAR */ : sampler.minFilter;\n        if (magFilter === 9729 /* TextureMagFilter.LINEAR */) {\n            switch (minFilter) {\n                case 9728 /* TextureMinFilter.NEAREST */:\n                    return Texture.LINEAR_NEAREST;\n                case 9729 /* TextureMinFilter.LINEAR */:\n                    return Texture.LINEAR_LINEAR;\n                case 9984 /* TextureMinFilter.NEAREST_MIPMAP_NEAREST */:\n                    return Texture.LINEAR_NEAREST_MIPNEAREST;\n                case 9985 /* TextureMinFilter.LINEAR_MIPMAP_NEAREST */:\n                    return Texture.LINEAR_LINEAR_MIPNEAREST;\n                case 9986 /* TextureMinFilter.NEAREST_MIPMAP_LINEAR */:\n                    return Texture.LINEAR_NEAREST_MIPLINEAR;\n                case 9987 /* TextureMinFilter.LINEAR_MIPMAP_LINEAR */:\n                    return Texture.LINEAR_LINEAR_MIPLINEAR;\n                default:\n                    Logger.Warn(`${context}/minFilter: Invalid value (${minFilter})`);\n                    return Texture.LINEAR_LINEAR_MIPLINEAR;\n            }\n        }\n        else {\n            if (magFilter !== 9728 /* TextureMagFilter.NEAREST */) {\n                Logger.Warn(`${context}/magFilter: Invalid value (${magFilter})`);\n            }\n            switch (minFilter) {\n                case 9728 /* TextureMinFilter.NEAREST */:\n                    return Texture.NEAREST_NEAREST;\n                case 9729 /* TextureMinFilter.LINEAR */:\n                    return Texture.NEAREST_LINEAR;\n                case 9984 /* TextureMinFilter.NEAREST_MIPMAP_NEAREST */:\n                    return Texture.NEAREST_NEAREST_MIPNEAREST;\n                case 9985 /* TextureMinFilter.LINEAR_MIPMAP_NEAREST */:\n                    return Texture.NEAREST_LINEAR_MIPNEAREST;\n                case 9986 /* TextureMinFilter.NEAREST_MIPMAP_LINEAR */:\n                    return Texture.NEAREST_NEAREST_MIPLINEAR;\n                case 9987 /* TextureMinFilter.LINEAR_MIPMAP_LINEAR */:\n                    return Texture.NEAREST_LINEAR_MIPLINEAR;\n                default:\n                    Logger.Warn(`${context}/minFilter: Invalid value (${minFilter})`);\n                    return Texture.NEAREST_NEAREST_MIPNEAREST;\n            }\n        }\n    }\n    static _GetTypedArrayConstructor(context, componentType) {\n        switch (componentType) {\n            case 5120 /* AccessorComponentType.BYTE */:\n                return Int8Array;\n            case 5121 /* AccessorComponentType.UNSIGNED_BYTE */:\n                return Uint8Array;\n            case 5122 /* AccessorComponentType.SHORT */:\n                return Int16Array;\n            case 5123 /* AccessorComponentType.UNSIGNED_SHORT */:\n                return Uint16Array;\n            case 5125 /* AccessorComponentType.UNSIGNED_INT */:\n                return Uint32Array;\n            case 5126 /* AccessorComponentType.FLOAT */:\n                return Float32Array;\n            default:\n                throw new Error(`${context}: Invalid component type ${componentType}`);\n        }\n    }\n    static _GetTypedArray(context, componentType, bufferView, byteOffset, length) {\n        const buffer = bufferView.buffer;\n        byteOffset = bufferView.byteOffset + (byteOffset || 0);\n        const constructor = GLTFLoader._GetTypedArrayConstructor(`${context}/componentType`, componentType);\n        const componentTypeLength = VertexBuffer.GetTypeByteLength(componentType);\n        if (byteOffset % componentTypeLength !== 0) {\n            // HACK: Copy the buffer if byte offset is not a multiple of component type byte length.\n            Logger.Warn(`${context}: Copying buffer as byte offset (${byteOffset}) is not a multiple of component type byte length (${componentTypeLength})`);\n            return new constructor(buffer.slice(byteOffset, byteOffset + length * componentTypeLength), 0);\n        }\n        return new constructor(buffer, byteOffset, length);\n    }\n    static _GetNumComponents(context, type) {\n        switch (type) {\n            case \"SCALAR\":\n                return 1;\n            case \"VEC2\":\n                return 2;\n            case \"VEC3\":\n                return 3;\n            case \"VEC4\":\n                return 4;\n            case \"MAT2\":\n                return 4;\n            case \"MAT3\":\n                return 9;\n            case \"MAT4\":\n                return 16;\n        }\n        throw new Error(`${context}: Invalid type (${type})`);\n    }\n    static _ValidateUri(uri) {\n        return Tools.IsBase64(uri) || uri.indexOf(\"..\") === -1;\n    }\n    /**\n     * @internal\n     */\n    static _GetDrawMode(context, mode) {\n        if (mode == undefined) {\n            mode = 4 /* MeshPrimitiveMode.TRIANGLES */;\n        }\n        switch (mode) {\n            case 0 /* MeshPrimitiveMode.POINTS */:\n                return Material.PointListDrawMode;\n            case 1 /* MeshPrimitiveMode.LINES */:\n                return Material.LineListDrawMode;\n            case 2 /* MeshPrimitiveMode.LINE_LOOP */:\n                return Material.LineLoopDrawMode;\n            case 3 /* MeshPrimitiveMode.LINE_STRIP */:\n                return Material.LineStripDrawMode;\n            case 4 /* MeshPrimitiveMode.TRIANGLES */:\n                return Material.TriangleFillMode;\n            case 5 /* MeshPrimitiveMode.TRIANGLE_STRIP */:\n                return Material.TriangleStripDrawMode;\n            case 6 /* MeshPrimitiveMode.TRIANGLE_FAN */:\n                return Material.TriangleFanDrawMode;\n        }\n        throw new Error(`${context}: Invalid mesh primitive mode (${mode})`);\n    }\n    _compileMaterialsAsync() {\n        this._parent._startPerformanceCounter(\"Compile materials\");\n        const promises = new Array();\n        if (this._gltf.materials) {\n            for (const material of this._gltf.materials) {\n                if (material._data) {\n                    for (const babylonDrawMode in material._data) {\n                        const babylonData = material._data[babylonDrawMode];\n                        for (const babylonMesh of babylonData.babylonMeshes) {\n                            // Ensure nonUniformScaling is set if necessary.\n                            babylonMesh.computeWorldMatrix(true);\n                            const babylonMaterial = babylonData.babylonMaterial;\n                            promises.push(babylonMaterial.forceCompilationAsync(babylonMesh));\n                            promises.push(babylonMaterial.forceCompilationAsync(babylonMesh, { useInstances: true }));\n                            if (this._parent.useClipPlane) {\n                                promises.push(babylonMaterial.forceCompilationAsync(babylonMesh, { clipPlane: true }));\n                                promises.push(babylonMaterial.forceCompilationAsync(babylonMesh, { clipPlane: true, useInstances: true }));\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return Promise.all(promises).then(() => {\n            this._parent._endPerformanceCounter(\"Compile materials\");\n        });\n    }\n    _compileShadowGeneratorsAsync() {\n        this._parent._startPerformanceCounter(\"Compile shadow generators\");\n        const promises = new Array();\n        const lights = this._babylonScene.lights;\n        for (const light of lights) {\n            const generator = light.getShadowGenerator();\n            if (generator) {\n                promises.push(generator.forceCompilationAsync());\n            }\n        }\n        return Promise.all(promises).then(() => {\n            this._parent._endPerformanceCounter(\"Compile shadow generators\");\n        });\n    }\n    _forEachExtensions(action) {\n        for (const extension of this._extensions) {\n            if (extension.enabled) {\n                action(extension);\n            }\n        }\n    }\n    _applyExtensions(property, functionName, actionAsync) {\n        for (const extension of this._extensions) {\n            if (extension.enabled) {\n                const id = `${extension.name}.${functionName}`;\n                const loaderProperty = property;\n                loaderProperty._activeLoaderExtensionFunctions = loaderProperty._activeLoaderExtensionFunctions || {};\n                const activeLoaderExtensionFunctions = loaderProperty._activeLoaderExtensionFunctions;\n                if (!activeLoaderExtensionFunctions[id]) {\n                    activeLoaderExtensionFunctions[id] = true;\n                    try {\n                        const result = actionAsync(extension);\n                        if (result) {\n                            return result;\n                        }\n                    }\n                    finally {\n                        delete activeLoaderExtensionFunctions[id];\n                    }\n                }\n            }\n        }\n        return null;\n    }\n    _extensionsOnLoading() {\n        this._forEachExtensions((extension) => extension.onLoading && extension.onLoading());\n    }\n    _extensionsOnReady() {\n        this._forEachExtensions((extension) => extension.onReady && extension.onReady());\n    }\n    _extensionsLoadSceneAsync(context, scene) {\n        return this._applyExtensions(scene, \"loadScene\", (extension) => extension.loadSceneAsync && extension.loadSceneAsync(context, scene));\n    }\n    _extensionsLoadNodeAsync(context, node, assign) {\n        return this._applyExtensions(node, \"loadNode\", (extension) => extension.loadNodeAsync && extension.loadNodeAsync(context, node, assign));\n    }\n    _extensionsLoadCameraAsync(context, camera, assign) {\n        return this._applyExtensions(camera, \"loadCamera\", (extension) => extension.loadCameraAsync && extension.loadCameraAsync(context, camera, assign));\n    }\n    _extensionsLoadVertexDataAsync(context, primitive, babylonMesh) {\n        return this._applyExtensions(primitive, \"loadVertexData\", (extension) => extension._loadVertexDataAsync && extension._loadVertexDataAsync(context, primitive, babylonMesh));\n    }\n    _extensionsLoadMeshPrimitiveAsync(context, name, node, mesh, primitive, assign) {\n        return this._applyExtensions(primitive, \"loadMeshPrimitive\", (extension) => extension._loadMeshPrimitiveAsync && extension._loadMeshPrimitiveAsync(context, name, node, mesh, primitive, assign));\n    }\n    _extensionsLoadMaterialAsync(context, material, babylonMesh, babylonDrawMode, assign) {\n        return this._applyExtensions(material, \"loadMaterial\", (extension) => extension._loadMaterialAsync && extension._loadMaterialAsync(context, material, babylonMesh, babylonDrawMode, assign));\n    }\n    _extensionsCreateMaterial(context, material, babylonDrawMode) {\n        return this._applyExtensions(material, \"createMaterial\", (extension) => extension.createMaterial && extension.createMaterial(context, material, babylonDrawMode));\n    }\n    _extensionsLoadMaterialPropertiesAsync(context, material, babylonMaterial) {\n        return this._applyExtensions(material, \"loadMaterialProperties\", (extension) => extension.loadMaterialPropertiesAsync && extension.loadMaterialPropertiesAsync(context, material, babylonMaterial));\n    }\n    _extensionsLoadTextureInfoAsync(context, textureInfo, assign) {\n        return this._applyExtensions(textureInfo, \"loadTextureInfo\", (extension) => extension.loadTextureInfoAsync && extension.loadTextureInfoAsync(context, textureInfo, assign));\n    }\n    _extensionsLoadTextureAsync(context, texture, assign) {\n        return this._applyExtensions(texture, \"loadTexture\", (extension) => extension._loadTextureAsync && extension._loadTextureAsync(context, texture, assign));\n    }\n    _extensionsLoadAnimationAsync(context, animation) {\n        return this._applyExtensions(animation, \"loadAnimation\", (extension) => extension.loadAnimationAsync && extension.loadAnimationAsync(context, animation));\n    }\n    _extensionsLoadAnimationChannelAsync(context, animationContext, animation, channel, onLoad) {\n        return this._applyExtensions(animation, \"loadAnimationChannel\", (extension) => extension._loadAnimationChannelAsync && extension._loadAnimationChannelAsync(context, animationContext, animation, channel, onLoad));\n    }\n    _extensionsLoadSkinAsync(context, node, skin) {\n        return this._applyExtensions(skin, \"loadSkin\", (extension) => extension._loadSkinAsync && extension._loadSkinAsync(context, node, skin));\n    }\n    _extensionsLoadUriAsync(context, property, uri) {\n        return this._applyExtensions(property, \"loadUri\", (extension) => extension._loadUriAsync && extension._loadUriAsync(context, property, uri));\n    }\n    _extensionsLoadBufferViewAsync(context, bufferView) {\n        return this._applyExtensions(bufferView, \"loadBufferView\", (extension) => extension.loadBufferViewAsync && extension.loadBufferViewAsync(context, bufferView));\n    }\n    _extensionsLoadBufferAsync(context, buffer, byteOffset, byteLength) {\n        return this._applyExtensions(buffer, \"loadBuffer\", (extension) => extension.loadBufferAsync && extension.loadBufferAsync(context, buffer, byteOffset, byteLength));\n    }\n    /**\n     * Helper method called by a loader extension to load an glTF extension.\n     * @param context The context when loading the asset\n     * @param property The glTF property to load the extension from\n     * @param extensionName The name of the extension to load\n     * @param actionAsync The action to run\n     * @returns The promise returned by actionAsync or null if the extension does not exist\n     */\n    static LoadExtensionAsync(context, property, extensionName, actionAsync) {\n        if (!property.extensions) {\n            return null;\n        }\n        const extensions = property.extensions;\n        const extension = extensions[extensionName];\n        if (!extension) {\n            return null;\n        }\n        return actionAsync(`${context}/extensions/${extensionName}`, extension);\n    }\n    /**\n     * Helper method called by a loader extension to load a glTF extra.\n     * @param context The context when loading the asset\n     * @param property The glTF property to load the extra from\n     * @param extensionName The name of the extension to load\n     * @param actionAsync The action to run\n     * @returns The promise returned by actionAsync or null if the extra does not exist\n     */\n    static LoadExtraAsync(context, property, extensionName, actionAsync) {\n        if (!property.extras) {\n            return null;\n        }\n        const extras = property.extras;\n        const extra = extras[extensionName];\n        if (!extra) {\n            return null;\n        }\n        return actionAsync(`${context}/extras/${extensionName}`, extra);\n    }\n    /**\n     * Checks for presence of an extension.\n     * @param name The name of the extension to check\n     * @returns A boolean indicating the presence of the given extension name in `extensionsUsed`\n     */\n    isExtensionUsed(name) {\n        return !!this._gltf.extensionsUsed && this._gltf.extensionsUsed.indexOf(name) !== -1;\n    }\n    /**\n     * Increments the indentation level and logs a message.\n     * @param message The message to log\n     */\n    logOpen(message) {\n        this._parent._logOpen(message);\n    }\n    /**\n     * Decrements the indentation level.\n     */\n    logClose() {\n        this._parent._logClose();\n    }\n    /**\n     * Logs a message\n     * @param message The message to log\n     */\n    log(message) {\n        this._parent._log(message);\n    }\n    /**\n     * Starts a performance counter.\n     * @param counterName The name of the performance counter\n     */\n    startPerformanceCounter(counterName) {\n        this._parent._startPerformanceCounter(counterName);\n    }\n    /**\n     * Ends a performance counter.\n     * @param counterName The name of the performance counter\n     */\n    endPerformanceCounter(counterName) {\n        this._parent._endPerformanceCounter(counterName);\n    }\n}\nGLTFLoader._RegisteredExtensions = {};\n/**\n * The default glTF sampler.\n */\nGLTFLoader.DefaultSampler = { index: -1 };\nGLTFFileLoader._CreateGLTF2Loader = (parent) => new GLTFLoader(parent);\n//# sourceMappingURL=glTFLoader.js.map","import { Scalar } from \"@babylonjs/core/Maths/math.scalar.js\";\nimport { SphericalHarmonics, SphericalPolynomial } from \"@babylonjs/core/Maths/sphericalPolynomial.js\";\nimport { Quaternion, Matrix } from \"@babylonjs/core/Maths/math.vector.js\";\nimport { RawCubeTexture } from \"@babylonjs/core/Materials/Textures/rawCubeTexture.js\";\nimport { GLTFLoader, ArrayItem } from \"../glTFLoader.js\";\nconst NAME = \"EXT_lights_image_based\";\n/**\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Vendor/EXT_lights_image_based/README.md)\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport class EXT_lights_image_based {\n    /**\n     * @internal\n     */\n    constructor(loader) {\n        /**\n         * The name of this extension.\n         */\n        this.name = NAME;\n        this._loader = loader;\n        this.enabled = this._loader.isExtensionUsed(NAME);\n    }\n    /** @internal */\n    dispose() {\n        this._loader = null;\n        delete this._lights;\n    }\n    /** @internal */\n    onLoading() {\n        const extensions = this._loader.gltf.extensions;\n        if (extensions && extensions[this.name]) {\n            const extension = extensions[this.name];\n            this._lights = extension.lights;\n        }\n    }\n    /**\n     * @internal\n     */\n    loadSceneAsync(context, scene) {\n        return GLTFLoader.LoadExtensionAsync(context, scene, this.name, (extensionContext, extension) => {\n            const promises = new Array();\n            promises.push(this._loader.loadSceneAsync(context, scene));\n            this._loader.logOpen(`${extensionContext}`);\n            const light = ArrayItem.Get(`${extensionContext}/light`, this._lights, extension.light);\n            promises.push(this._loadLightAsync(`/extensions/${this.name}/lights/${extension.light}`, light).then((texture) => {\n                this._loader.babylonScene.environmentTexture = texture;\n            }));\n            this._loader.logClose();\n            return Promise.all(promises).then(() => { });\n        });\n    }\n    _loadLightAsync(context, light) {\n        if (!light._loaded) {\n            const promises = new Array();\n            this._loader.logOpen(`${context}`);\n            const imageData = new Array(light.specularImages.length);\n            for (let mipmap = 0; mipmap < light.specularImages.length; mipmap++) {\n                const faces = light.specularImages[mipmap];\n                imageData[mipmap] = new Array(faces.length);\n                for (let face = 0; face < faces.length; face++) {\n                    const specularImageContext = `${context}/specularImages/${mipmap}/${face}`;\n                    this._loader.logOpen(`${specularImageContext}`);\n                    const index = faces[face];\n                    const image = ArrayItem.Get(specularImageContext, this._loader.gltf.images, index);\n                    promises.push(this._loader.loadImageAsync(`/images/${index}`, image).then((data) => {\n                        imageData[mipmap][face] = data;\n                    }));\n                    this._loader.logClose();\n                }\n            }\n            this._loader.logClose();\n            light._loaded = Promise.all(promises).then(() => {\n                const babylonTexture = new RawCubeTexture(this._loader.babylonScene, null, light.specularImageSize);\n                babylonTexture.name = light.name || \"environment\";\n                light._babylonTexture = babylonTexture;\n                if (light.intensity != undefined) {\n                    babylonTexture.level = light.intensity;\n                }\n                if (light.rotation) {\n                    let rotation = Quaternion.FromArray(light.rotation);\n                    // Invert the rotation so that positive rotation is counter-clockwise.\n                    if (!this._loader.babylonScene.useRightHandedSystem) {\n                        rotation = Quaternion.Inverse(rotation);\n                    }\n                    Matrix.FromQuaternionToRef(rotation, babylonTexture.getReflectionTextureMatrix());\n                }\n                if (!light.irradianceCoefficients) {\n                    throw new Error(`${context}: Irradiance coefficients are missing`);\n                }\n                const sphericalHarmonics = SphericalHarmonics.FromArray(light.irradianceCoefficients);\n                sphericalHarmonics.scaleInPlace(light.intensity);\n                sphericalHarmonics.convertIrradianceToLambertianRadiance();\n                const sphericalPolynomial = SphericalPolynomial.FromHarmonics(sphericalHarmonics);\n                // Compute the lod generation scale to fit exactly to the number of levels available.\n                const lodGenerationScale = (imageData.length - 1) / Scalar.Log2(light.specularImageSize);\n                return babylonTexture.updateRGBDAsync(imageData, sphericalPolynomial, lodGenerationScale);\n            });\n        }\n        return light._loaded.then(() => {\n            return light._babylonTexture;\n        });\n    }\n}\nGLTFLoader.RegisterExtension(NAME, (loader) => new EXT_lights_image_based(loader));\n//# sourceMappingURL=EXT_lights_image_based.js.map","import { Vector3, Quaternion, Matrix, TmpVectors } from \"@babylonjs/core/Maths/math.vector.js\";\nimport { GLTFLoader, ArrayItem } from \"../glTFLoader.js\";\nimport \"@babylonjs/core/Meshes/thinInstanceMesh.js\";\nconst NAME = \"EXT_mesh_gpu_instancing\";\n/**\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Vendor/EXT_mesh_gpu_instancing/README.md)\n * [Playground Sample](https://playground.babylonjs.com/#QFIGLW#9)\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport class EXT_mesh_gpu_instancing {\n    /**\n     * @internal\n     */\n    constructor(loader) {\n        /**\n         * The name of this extension.\n         */\n        this.name = NAME;\n        this._loader = loader;\n        this.enabled = this._loader.isExtensionUsed(NAME);\n    }\n    /** @internal */\n    dispose() {\n        this._loader = null;\n    }\n    /**\n     * @internal\n     */\n    loadNodeAsync(context, node, assign) {\n        return GLTFLoader.LoadExtensionAsync(context, node, this.name, (extensionContext, extension) => {\n            this._loader._disableInstancedMesh++;\n            const promise = this._loader.loadNodeAsync(`/nodes/${node.index}`, node, assign);\n            this._loader._disableInstancedMesh--;\n            if (!node._primitiveBabylonMeshes) {\n                return promise;\n            }\n            const promises = new Array();\n            let instanceCount = 0;\n            const loadAttribute = (attribute) => {\n                if (extension.attributes[attribute] == undefined) {\n                    promises.push(Promise.resolve(null));\n                    return;\n                }\n                const accessor = ArrayItem.Get(`${extensionContext}/attributes/${attribute}`, this._loader.gltf.accessors, extension.attributes[attribute]);\n                promises.push(this._loader._loadFloatAccessorAsync(`/accessors/${accessor.bufferView}`, accessor));\n                if (instanceCount === 0) {\n                    instanceCount = accessor.count;\n                }\n                else if (instanceCount !== accessor.count) {\n                    throw new Error(`${extensionContext}/attributes: Instance buffer accessors do not have the same count.`);\n                }\n            };\n            loadAttribute(\"TRANSLATION\");\n            loadAttribute(\"ROTATION\");\n            loadAttribute(\"SCALE\");\n            return promise.then((babylonTransformNode) => {\n                return Promise.all(promises).then(([translationBuffer, rotationBuffer, scaleBuffer]) => {\n                    const matrices = new Float32Array(instanceCount * 16);\n                    TmpVectors.Vector3[0].copyFromFloats(0, 0, 0); // translation\n                    TmpVectors.Quaternion[0].copyFromFloats(0, 0, 0, 1); // rotation\n                    TmpVectors.Vector3[1].copyFromFloats(1, 1, 1); // scale\n                    for (let i = 0; i < instanceCount; ++i) {\n                        translationBuffer && Vector3.FromArrayToRef(translationBuffer, i * 3, TmpVectors.Vector3[0]);\n                        rotationBuffer && Quaternion.FromArrayToRef(rotationBuffer, i * 4, TmpVectors.Quaternion[0]);\n                        scaleBuffer && Vector3.FromArrayToRef(scaleBuffer, i * 3, TmpVectors.Vector3[1]);\n                        Matrix.ComposeToRef(TmpVectors.Vector3[1], TmpVectors.Quaternion[0], TmpVectors.Vector3[0], TmpVectors.Matrix[0]);\n                        TmpVectors.Matrix[0].copyToArray(matrices, i * 16);\n                    }\n                    for (const babylonMesh of node._primitiveBabylonMeshes) {\n                        babylonMesh.thinInstanceSetBuffer(\"matrix\", matrices, 16, true);\n                    }\n                    return babylonTransformNode;\n                });\n            });\n        });\n    }\n}\nGLTFLoader.RegisterExtension(NAME, (loader) => new EXT_mesh_gpu_instancing(loader));\n//# sourceMappingURL=EXT_mesh_gpu_instancing.js.map","import { ArrayItem, GLTFLoader } from \"../glTFLoader.js\";\nimport { MeshoptCompression } from \"@babylonjs/core/Meshes/Compression/meshoptCompression.js\";\nconst NAME = \"EXT_meshopt_compression\";\n/**\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Vendor/EXT_meshopt_compression/README.md)\n *\n * This extension uses a WebAssembly decoder module from https://github.com/zeux/meshoptimizer/tree/master/js\n * @since 5.0.0\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport class EXT_meshopt_compression {\n    /**\n     * @internal\n     */\n    constructor(loader) {\n        /**\n         * The name of this extension.\n         */\n        this.name = NAME;\n        this.enabled = loader.isExtensionUsed(NAME);\n        this._loader = loader;\n    }\n    /** @internal */\n    dispose() {\n        this._loader = null;\n    }\n    /**\n     * @internal\n     */\n    loadBufferViewAsync(context, bufferView) {\n        return GLTFLoader.LoadExtensionAsync(context, bufferView, this.name, (extensionContext, extension) => {\n            const bufferViewMeshopt = bufferView;\n            if (bufferViewMeshopt._meshOptData) {\n                return bufferViewMeshopt._meshOptData;\n            }\n            const buffer = ArrayItem.Get(`${context}/buffer`, this._loader.gltf.buffers, extension.buffer);\n            bufferViewMeshopt._meshOptData = this._loader.loadBufferAsync(`/buffers/${buffer.index}`, buffer, extension.byteOffset || 0, extension.byteLength).then((buffer) => {\n                return MeshoptCompression.Default.decodeGltfBufferAsync(buffer, extension.count, extension.byteStride, extension.mode, extension.filter);\n            });\n            return bufferViewMeshopt._meshOptData;\n        });\n    }\n}\nGLTFLoader.RegisterExtension(NAME, (loader) => new EXT_meshopt_compression(loader));\n//# sourceMappingURL=EXT_meshopt_compression.js.map","import { GLTFLoader, ArrayItem } from \"../glTFLoader.js\";\nconst NAME = \"EXT_texture_webp\";\n/**\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Vendor/EXT_texture_webp/README.md)\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport class EXT_texture_webp {\n    /**\n     * @internal\n     */\n    constructor(loader) {\n        /** The name of this extension. */\n        this.name = NAME;\n        this._loader = loader;\n        this.enabled = loader.isExtensionUsed(NAME);\n    }\n    /** @internal */\n    dispose() {\n        this._loader = null;\n    }\n    /**\n     * @internal\n     */\n    _loadTextureAsync(context, texture, assign) {\n        return GLTFLoader.LoadExtensionAsync(context, texture, this.name, (extensionContext, extension) => {\n            const sampler = texture.sampler == undefined ? GLTFLoader.DefaultSampler : ArrayItem.Get(`${context}/sampler`, this._loader.gltf.samplers, texture.sampler);\n            const image = ArrayItem.Get(`${extensionContext}/source`, this._loader.gltf.images, extension.source);\n            return this._loader._createTextureAsync(context, sampler, image, (babylonTexture) => {\n                assign(babylonTexture);\n            }, undefined, !texture._textureInfo.nonColorData);\n        });\n    }\n}\nGLTFLoader.RegisterExtension(NAME, (loader) => new EXT_texture_webp(loader));\n//# sourceMappingURL=EXT_texture_webp.js.map","import { DracoCompression } from \"@babylonjs/core/Meshes/Compression/dracoCompression.js\";\nimport { VertexBuffer } from \"@babylonjs/core/Buffers/buffer.js\";\nimport { Geometry } from \"@babylonjs/core/Meshes/geometry.js\";\nimport { GLTFLoader, ArrayItem } from \"../glTFLoader.js\";\nconst NAME = \"KHR_draco_mesh_compression\";\n/**\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_draco_mesh_compression/README.md)\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport class KHR_draco_mesh_compression {\n    /**\n     * @internal\n     */\n    constructor(loader) {\n        /**\n         * The name of this extension.\n         */\n        this.name = NAME;\n        this._loader = loader;\n        this.enabled = DracoCompression.DecoderAvailable && this._loader.isExtensionUsed(NAME);\n    }\n    /** @internal */\n    dispose() {\n        delete this.dracoCompression;\n        this._loader = null;\n    }\n    /**\n     * @internal\n     */\n    _loadVertexDataAsync(context, primitive, babylonMesh) {\n        return GLTFLoader.LoadExtensionAsync(context, primitive, this.name, (extensionContext, extension) => {\n            if (primitive.mode != undefined) {\n                if (primitive.mode !== 5 /* MeshPrimitiveMode.TRIANGLE_STRIP */ && primitive.mode !== 4 /* MeshPrimitiveMode.TRIANGLES */) {\n                    throw new Error(`${context}: Unsupported mode ${primitive.mode}`);\n                }\n                // TODO: handle triangle strips\n                if (primitive.mode === 5 /* MeshPrimitiveMode.TRIANGLE_STRIP */) {\n                    throw new Error(`${context}: Mode ${primitive.mode} is not currently supported`);\n                }\n            }\n            const attributes = {};\n            const dividers = {};\n            const loadAttribute = (name, kind) => {\n                const uniqueId = extension.attributes[name];\n                if (uniqueId === undefined || primitive.attributes[name] === undefined) {\n                    return;\n                }\n                attributes[kind] = uniqueId;\n                const accessor = ArrayItem.Get(`${context}/attributes/${name}`, this._loader.gltf.accessors, primitive.attributes[name]);\n                if (accessor.normalized && accessor.componentType !== 5126 /* AccessorComponentType.FLOAT */) {\n                    let divider = 1;\n                    switch (accessor.componentType) {\n                        case 5120 /* AccessorComponentType.BYTE */:\n                            divider = 127.0;\n                            break;\n                        case 5121 /* AccessorComponentType.UNSIGNED_BYTE */:\n                            divider = 255.0;\n                            break;\n                        case 5122 /* AccessorComponentType.SHORT */:\n                            divider = 32767.0;\n                            break;\n                        case 5123 /* AccessorComponentType.UNSIGNED_SHORT */:\n                            divider = 65535.0;\n                            break;\n                    }\n                    dividers[kind] = divider;\n                }\n                babylonMesh._delayInfo = babylonMesh._delayInfo || [];\n                if (babylonMesh._delayInfo.indexOf(kind) === -1) {\n                    babylonMesh._delayInfo.push(kind);\n                }\n            };\n            loadAttribute(\"POSITION\", VertexBuffer.PositionKind);\n            loadAttribute(\"NORMAL\", VertexBuffer.NormalKind);\n            loadAttribute(\"TANGENT\", VertexBuffer.TangentKind);\n            loadAttribute(\"TEXCOORD_0\", VertexBuffer.UVKind);\n            loadAttribute(\"TEXCOORD_1\", VertexBuffer.UV2Kind);\n            loadAttribute(\"TEXCOORD_2\", VertexBuffer.UV3Kind);\n            loadAttribute(\"TEXCOORD_3\", VertexBuffer.UV4Kind);\n            loadAttribute(\"TEXCOORD_4\", VertexBuffer.UV5Kind);\n            loadAttribute(\"TEXCOORD_5\", VertexBuffer.UV6Kind);\n            loadAttribute(\"JOINTS_0\", VertexBuffer.MatricesIndicesKind);\n            loadAttribute(\"WEIGHTS_0\", VertexBuffer.MatricesWeightsKind);\n            loadAttribute(\"COLOR_0\", VertexBuffer.ColorKind);\n            const bufferView = ArrayItem.Get(extensionContext, this._loader.gltf.bufferViews, extension.bufferView);\n            if (!bufferView._dracoBabylonGeometry) {\n                bufferView._dracoBabylonGeometry = this._loader.loadBufferViewAsync(`/bufferViews/${bufferView.index}`, bufferView).then((data) => {\n                    const dracoCompression = this.dracoCompression || DracoCompression.Default;\n                    return dracoCompression\n                        .decodeMeshAsync(data, attributes, dividers)\n                        .then((babylonVertexData) => {\n                        const babylonGeometry = new Geometry(babylonMesh.name, this._loader.babylonScene);\n                        babylonVertexData.applyToGeometry(babylonGeometry);\n                        return babylonGeometry;\n                    })\n                        .catch((error) => {\n                        throw new Error(`${context}: ${error.message}`);\n                    });\n                });\n            }\n            return bufferView._dracoBabylonGeometry;\n        });\n    }\n}\nGLTFLoader.RegisterExtension(NAME, (loader) => new KHR_draco_mesh_compression(loader));\n//# sourceMappingURL=KHR_draco_mesh_compression.js.map","import { Vector3 } from \"@babylonjs/core/Maths/math.vector.js\";\nimport { Color3 } from \"@babylonjs/core/Maths/math.color.js\";\nimport { DirectionalLight } from \"@babylonjs/core/Lights/directionalLight.js\";\nimport { PointLight } from \"@babylonjs/core/Lights/pointLight.js\";\nimport { SpotLight } from \"@babylonjs/core/Lights/spotLight.js\";\nimport { Light } from \"@babylonjs/core/Lights/light.js\";\nimport { GLTFLoader, ArrayItem } from \"../glTFLoader.js\";\nconst NAME = \"KHR_lights_punctual\";\n/**\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_lights_punctual/README.md)\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport class KHR_lights {\n    /**\n     * @internal\n     */\n    constructor(loader) {\n        /**\n         * The name of this extension.\n         */\n        this.name = NAME;\n        this._loader = loader;\n        this.enabled = this._loader.isExtensionUsed(NAME);\n    }\n    /** @internal */\n    dispose() {\n        this._loader = null;\n        delete this._lights;\n    }\n    /** @internal */\n    onLoading() {\n        const extensions = this._loader.gltf.extensions;\n        if (extensions && extensions[this.name]) {\n            const extension = extensions[this.name];\n            this._lights = extension.lights;\n            ArrayItem.Assign(this._lights);\n        }\n    }\n    /**\n     * @internal\n     */\n    loadNodeAsync(context, node, assign) {\n        return GLTFLoader.LoadExtensionAsync(context, node, this.name, (extensionContext, extension) => {\n            return this._loader.loadNodeAsync(context, node, (babylonMesh) => {\n                let babylonLight;\n                const light = ArrayItem.Get(extensionContext, this._lights, extension.light);\n                const name = light.name || babylonMesh.name;\n                this._loader.babylonScene._blockEntityCollection = !!this._loader._assetContainer;\n                switch (light.type) {\n                    case \"directional\" /* KHRLightsPunctual_LightType.DIRECTIONAL */: {\n                        babylonLight = new DirectionalLight(name, Vector3.Backward(), this._loader.babylonScene);\n                        break;\n                    }\n                    case \"point\" /* KHRLightsPunctual_LightType.POINT */: {\n                        babylonLight = new PointLight(name, Vector3.Zero(), this._loader.babylonScene);\n                        break;\n                    }\n                    case \"spot\" /* KHRLightsPunctual_LightType.SPOT */: {\n                        const babylonSpotLight = new SpotLight(name, Vector3.Zero(), Vector3.Backward(), 0, 1, this._loader.babylonScene);\n                        babylonSpotLight.angle = ((light.spot && light.spot.outerConeAngle) || Math.PI / 4) * 2;\n                        babylonSpotLight.innerAngle = ((light.spot && light.spot.innerConeAngle) || 0) * 2;\n                        babylonLight = babylonSpotLight;\n                        break;\n                    }\n                    default: {\n                        this._loader.babylonScene._blockEntityCollection = false;\n                        throw new Error(`${extensionContext}: Invalid light type (${light.type})`);\n                    }\n                }\n                babylonLight._parentContainer = this._loader._assetContainer;\n                this._loader.babylonScene._blockEntityCollection = false;\n                light._babylonLight = babylonLight;\n                babylonLight.falloffType = Light.FALLOFF_GLTF;\n                babylonLight.diffuse = light.color ? Color3.FromArray(light.color) : Color3.White();\n                babylonLight.intensity = light.intensity == undefined ? 1 : light.intensity;\n                babylonLight.range = light.range == undefined ? Number.MAX_VALUE : light.range;\n                babylonLight.parent = babylonMesh;\n                this._loader._babylonLights.push(babylonLight);\n                GLTFLoader.AddPointerMetadata(babylonLight, extensionContext);\n                assign(babylonMesh);\n            });\n        });\n    }\n}\nGLTFLoader.RegisterExtension(NAME, (loader) => new KHR_lights(loader));\n//# sourceMappingURL=KHR_lights_punctual.js.map","import { Color3 } from \"@babylonjs/core/Maths/math.color.js\";\nimport { PBRMaterial } from \"@babylonjs/core/Materials/PBR/pbrMaterial.js\";\nimport { GLTFLoader } from \"../glTFLoader.js\";\nconst NAME = \"KHR_materials_pbrSpecularGlossiness\";\n/**\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Archived/KHR_materials_pbrSpecularGlossiness/README.md)\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport class KHR_materials_pbrSpecularGlossiness {\n    /**\n     * @internal\n     */\n    constructor(loader) {\n        /**\n         * The name of this extension.\n         */\n        this.name = NAME;\n        /**\n         * Defines a number that determines the order the extensions are applied.\n         */\n        this.order = 200;\n        this._loader = loader;\n        this.enabled = this._loader.isExtensionUsed(NAME);\n    }\n    /** @internal */\n    dispose() {\n        this._loader = null;\n    }\n    /**\n     * @internal\n     */\n    loadMaterialPropertiesAsync(context, material, babylonMaterial) {\n        return GLTFLoader.LoadExtensionAsync(context, material, this.name, (extensionContext, extension) => {\n            const promises = new Array();\n            promises.push(this._loader.loadMaterialBasePropertiesAsync(context, material, babylonMaterial));\n            promises.push(this._loadSpecularGlossinessPropertiesAsync(extensionContext, material, extension, babylonMaterial));\n            this._loader.loadMaterialAlphaProperties(context, material, babylonMaterial);\n            return Promise.all(promises).then(() => { });\n        });\n    }\n    _loadSpecularGlossinessPropertiesAsync(context, material, properties, babylonMaterial) {\n        if (!(babylonMaterial instanceof PBRMaterial)) {\n            throw new Error(`${context}: Material type not supported`);\n        }\n        const promises = new Array();\n        babylonMaterial.metallic = null;\n        babylonMaterial.roughness = null;\n        if (properties.diffuseFactor) {\n            babylonMaterial.albedoColor = Color3.FromArray(properties.diffuseFactor);\n            babylonMaterial.alpha = properties.diffuseFactor[3];\n        }\n        else {\n            babylonMaterial.albedoColor = Color3.White();\n        }\n        babylonMaterial.reflectivityColor = properties.specularFactor ? Color3.FromArray(properties.specularFactor) : Color3.White();\n        babylonMaterial.microSurface = properties.glossinessFactor == undefined ? 1 : properties.glossinessFactor;\n        if (properties.diffuseTexture) {\n            promises.push(this._loader.loadTextureInfoAsync(`${context}/diffuseTexture`, properties.diffuseTexture, (texture) => {\n                texture.name = `${babylonMaterial.name} (Diffuse)`;\n                babylonMaterial.albedoTexture = texture;\n            }));\n        }\n        if (properties.specularGlossinessTexture) {\n            promises.push(this._loader.loadTextureInfoAsync(`${context}/specularGlossinessTexture`, properties.specularGlossinessTexture, (texture) => {\n                texture.name = `${babylonMaterial.name} (Specular Glossiness)`;\n                babylonMaterial.reflectivityTexture = texture;\n                babylonMaterial.reflectivityTexture.hasAlpha = true;\n            }));\n            babylonMaterial.useMicroSurfaceFromReflectivityMapAlpha = true;\n        }\n        return Promise.all(promises).then(() => { });\n    }\n}\nGLTFLoader.RegisterExtension(NAME, (loader) => new KHR_materials_pbrSpecularGlossiness(loader));\n//# sourceMappingURL=KHR_materials_pbrSpecularGlossiness.js.map","import { Color3 } from \"@babylonjs/core/Maths/math.color.js\";\nimport { PBRMaterial } from \"@babylonjs/core/Materials/PBR/pbrMaterial.js\";\nimport { GLTFLoader } from \"../glTFLoader.js\";\nconst NAME = \"KHR_materials_unlit\";\n/**\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_unlit/README.md)\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport class KHR_materials_unlit {\n    /**\n     * @internal\n     */\n    constructor(loader) {\n        /**\n         * The name of this extension.\n         */\n        this.name = NAME;\n        /**\n         * Defines a number that determines the order the extensions are applied.\n         */\n        this.order = 210;\n        this._loader = loader;\n        this.enabled = this._loader.isExtensionUsed(NAME);\n    }\n    /** @internal */\n    dispose() {\n        this._loader = null;\n    }\n    /**\n     * @internal\n     */\n    loadMaterialPropertiesAsync(context, material, babylonMaterial) {\n        return GLTFLoader.LoadExtensionAsync(context, material, this.name, () => {\n            return this._loadUnlitPropertiesAsync(context, material, babylonMaterial);\n        });\n    }\n    _loadUnlitPropertiesAsync(context, material, babylonMaterial) {\n        if (!(babylonMaterial instanceof PBRMaterial)) {\n            throw new Error(`${context}: Material type not supported`);\n        }\n        const promises = new Array();\n        babylonMaterial.unlit = true;\n        const properties = material.pbrMetallicRoughness;\n        if (properties) {\n            if (properties.baseColorFactor) {\n                babylonMaterial.albedoColor = Color3.FromArray(properties.baseColorFactor);\n                babylonMaterial.alpha = properties.baseColorFactor[3];\n            }\n            else {\n                babylonMaterial.albedoColor = Color3.White();\n            }\n            if (properties.baseColorTexture) {\n                promises.push(this._loader.loadTextureInfoAsync(`${context}/baseColorTexture`, properties.baseColorTexture, (texture) => {\n                    texture.name = `${babylonMaterial.name} (Base Color)`;\n                    babylonMaterial.albedoTexture = texture;\n                }));\n            }\n        }\n        if (material.doubleSided) {\n            babylonMaterial.backFaceCulling = false;\n            babylonMaterial.twoSidedLighting = true;\n        }\n        this._loader.loadMaterialAlphaProperties(context, material, babylonMaterial);\n        return Promise.all(promises).then(() => { });\n    }\n}\nGLTFLoader.RegisterExtension(NAME, (loader) => new KHR_materials_unlit(loader));\n//# sourceMappingURL=KHR_materials_unlit.js.map","import { PBRMaterial } from \"@babylonjs/core/Materials/PBR/pbrMaterial.js\";\nimport { GLTFLoader } from \"../glTFLoader.js\";\nconst NAME = \"KHR_materials_clearcoat\";\n/**\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_clearcoat/README.md)\n * [Playground Sample](https://www.babylonjs-playground.com/frame.html#7F7PN6#8)\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport class KHR_materials_clearcoat {\n    /**\n     * @internal\n     */\n    constructor(loader) {\n        /**\n         * The name of this extension.\n         */\n        this.name = NAME;\n        /**\n         * Defines a number that determines the order the extensions are applied.\n         */\n        this.order = 190;\n        this._loader = loader;\n        this.enabled = this._loader.isExtensionUsed(NAME);\n    }\n    /** @internal */\n    dispose() {\n        this._loader = null;\n    }\n    /**\n     * @internal\n     */\n    loadMaterialPropertiesAsync(context, material, babylonMaterial) {\n        return GLTFLoader.LoadExtensionAsync(context, material, this.name, (extensionContext, extension) => {\n            const promises = new Array();\n            promises.push(this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial));\n            promises.push(this._loadClearCoatPropertiesAsync(extensionContext, extension, babylonMaterial));\n            return Promise.all(promises).then(() => { });\n        });\n    }\n    _loadClearCoatPropertiesAsync(context, properties, babylonMaterial) {\n        if (!(babylonMaterial instanceof PBRMaterial)) {\n            throw new Error(`${context}: Material type not supported`);\n        }\n        const promises = new Array();\n        babylonMaterial.clearCoat.isEnabled = true;\n        babylonMaterial.clearCoat.useRoughnessFromMainTexture = false;\n        babylonMaterial.clearCoat.remapF0OnInterfaceChange = false;\n        if (properties.clearcoatFactor != undefined) {\n            babylonMaterial.clearCoat.intensity = properties.clearcoatFactor;\n        }\n        else {\n            babylonMaterial.clearCoat.intensity = 0;\n        }\n        if (properties.clearcoatTexture) {\n            promises.push(this._loader.loadTextureInfoAsync(`${context}/clearcoatTexture`, properties.clearcoatTexture, (texture) => {\n                texture.name = `${babylonMaterial.name} (ClearCoat Intensity)`;\n                babylonMaterial.clearCoat.texture = texture;\n            }));\n        }\n        if (properties.clearcoatRoughnessFactor != undefined) {\n            babylonMaterial.clearCoat.roughness = properties.clearcoatRoughnessFactor;\n        }\n        else {\n            babylonMaterial.clearCoat.roughness = 0;\n        }\n        if (properties.clearcoatRoughnessTexture) {\n            properties.clearcoatRoughnessTexture.nonColorData = true;\n            promises.push(this._loader.loadTextureInfoAsync(`${context}/clearcoatRoughnessTexture`, properties.clearcoatRoughnessTexture, (texture) => {\n                texture.name = `${babylonMaterial.name} (ClearCoat Roughness)`;\n                babylonMaterial.clearCoat.textureRoughness = texture;\n            }));\n        }\n        if (properties.clearcoatNormalTexture) {\n            properties.clearcoatNormalTexture.nonColorData = true;\n            promises.push(this._loader.loadTextureInfoAsync(`${context}/clearcoatNormalTexture`, properties.clearcoatNormalTexture, (texture) => {\n                texture.name = `${babylonMaterial.name} (ClearCoat Normal)`;\n                babylonMaterial.clearCoat.bumpTexture = texture;\n            }));\n            babylonMaterial.invertNormalMapX = !babylonMaterial.getScene().useRightHandedSystem;\n            babylonMaterial.invertNormalMapY = babylonMaterial.getScene().useRightHandedSystem;\n            if (properties.clearcoatNormalTexture.scale != undefined) {\n                babylonMaterial.clearCoat.bumpTexture.level = properties.clearcoatNormalTexture.scale;\n            }\n        }\n        return Promise.all(promises).then(() => { });\n    }\n}\nGLTFLoader.RegisterExtension(NAME, (loader) => new KHR_materials_clearcoat(loader));\n//# sourceMappingURL=KHR_materials_clearcoat.js.map","import { PBRMaterial } from \"@babylonjs/core/Materials/PBR/pbrMaterial.js\";\nimport { GLTFLoader } from \"../glTFLoader.js\";\nconst NAME = \"KHR_materials_iridescence\";\n/**\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_iridescence/README.md)\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport class KHR_materials_iridescence {\n    /**\n     * @internal\n     */\n    constructor(loader) {\n        /**\n         * The name of this extension.\n         */\n        this.name = NAME;\n        /**\n         * Defines a number that determines the order the extensions are applied.\n         */\n        this.order = 195;\n        this._loader = loader;\n        this.enabled = this._loader.isExtensionUsed(NAME);\n    }\n    /** @internal */\n    dispose() {\n        this._loader = null;\n    }\n    /**\n     * @internal\n     */\n    loadMaterialPropertiesAsync(context, material, babylonMaterial) {\n        return GLTFLoader.LoadExtensionAsync(context, material, this.name, (extensionContext, extension) => {\n            const promises = new Array();\n            promises.push(this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial));\n            promises.push(this._loadIridescencePropertiesAsync(extensionContext, extension, babylonMaterial));\n            return Promise.all(promises).then(() => { });\n        });\n    }\n    _loadIridescencePropertiesAsync(context, properties, babylonMaterial) {\n        var _a, _b, _c, _d, _e;\n        if (!(babylonMaterial instanceof PBRMaterial)) {\n            throw new Error(`${context}: Material type not supported`);\n        }\n        const promises = new Array();\n        babylonMaterial.iridescence.isEnabled = true;\n        babylonMaterial.iridescence.intensity = (_a = properties.iridescenceFactor) !== null && _a !== void 0 ? _a : 0;\n        babylonMaterial.iridescence.indexOfRefraction = (_c = (_b = properties.iridescenceIor) !== null && _b !== void 0 ? _b : properties.iridescenceIOR) !== null && _c !== void 0 ? _c : 1.3;\n        babylonMaterial.iridescence.minimumThickness = (_d = properties.iridescenceThicknessMinimum) !== null && _d !== void 0 ? _d : 100;\n        babylonMaterial.iridescence.maximumThickness = (_e = properties.iridescenceThicknessMaximum) !== null && _e !== void 0 ? _e : 400;\n        if (properties.iridescenceTexture) {\n            promises.push(this._loader.loadTextureInfoAsync(`${context}/iridescenceTexture`, properties.iridescenceTexture, (texture) => {\n                texture.name = `${babylonMaterial.name} (Iridescence Intensity)`;\n                babylonMaterial.iridescence.texture = texture;\n            }));\n        }\n        if (properties.iridescenceThicknessTexture) {\n            promises.push(this._loader.loadTextureInfoAsync(`${context}/iridescenceThicknessTexture`, properties.iridescenceThicknessTexture, (texture) => {\n                texture.name = `${babylonMaterial.name} (Iridescence Thickness)`;\n                babylonMaterial.iridescence.thicknessTexture = texture;\n            }));\n        }\n        return Promise.all(promises).then(() => { });\n    }\n}\nGLTFLoader.RegisterExtension(NAME, (loader) => new KHR_materials_iridescence(loader));\n//# sourceMappingURL=KHR_materials_iridescence.js.map","import { PBRMaterial } from \"@babylonjs/core/Materials/PBR/pbrMaterial.js\";\nimport { GLTFLoader } from \"../glTFLoader.js\";\nconst NAME = \"KHR_materials_emissive_strength\";\n/**\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_emissive_strength/README.md)\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport class KHR_materials_emissive_strength {\n    /**\n     * @internal\n     */\n    constructor(loader) {\n        /**\n         * The name of this extension.\n         */\n        this.name = NAME;\n        /**\n         * Defines a number that determines the order the extensions are applied.\n         */\n        this.order = 170;\n        this._loader = loader;\n        this.enabled = this._loader.isExtensionUsed(NAME);\n    }\n    /** @internal */\n    dispose() {\n        this._loader = null;\n    }\n    /**\n     * @internal\n     */\n    loadMaterialPropertiesAsync(context, material, babylonMaterial) {\n        return GLTFLoader.LoadExtensionAsync(context, material, this.name, (extensionContext, extension) => {\n            return this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial).then(() => {\n                this._loadEmissiveProperties(extensionContext, extension, babylonMaterial);\n            });\n        });\n    }\n    _loadEmissiveProperties(context, properties, babylonMaterial) {\n        if (!(babylonMaterial instanceof PBRMaterial)) {\n            throw new Error(`${context}: Material type not supported`);\n        }\n        if (properties.emissiveStrength !== undefined) {\n            babylonMaterial.emissiveColor.scaleToRef(properties.emissiveStrength, babylonMaterial.emissiveColor);\n        }\n    }\n}\nGLTFLoader.RegisterExtension(NAME, (loader) => new KHR_materials_emissive_strength(loader));\n//# sourceMappingURL=KHR_materials_emissive_strength.js.map","import { PBRMaterial } from \"@babylonjs/core/Materials/PBR/pbrMaterial.js\";\nimport { GLTFLoader } from \"../glTFLoader.js\";\nimport { Color3 } from \"@babylonjs/core/Maths/math.color.js\";\nconst NAME = \"KHR_materials_sheen\";\n/**\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_sheen/README.md)\n * [Playground Sample](https://www.babylonjs-playground.com/frame.html#BNIZX6#4)\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport class KHR_materials_sheen {\n    /**\n     * @internal\n     */\n    constructor(loader) {\n        /**\n         * The name of this extension.\n         */\n        this.name = NAME;\n        /**\n         * Defines a number that determines the order the extensions are applied.\n         */\n        this.order = 190;\n        this._loader = loader;\n        this.enabled = this._loader.isExtensionUsed(NAME);\n    }\n    /** @internal */\n    dispose() {\n        this._loader = null;\n    }\n    /**\n     * @internal\n     */\n    loadMaterialPropertiesAsync(context, material, babylonMaterial) {\n        return GLTFLoader.LoadExtensionAsync(context, material, this.name, (extensionContext, extension) => {\n            const promises = new Array();\n            promises.push(this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial));\n            promises.push(this._loadSheenPropertiesAsync(extensionContext, extension, babylonMaterial));\n            return Promise.all(promises).then(() => { });\n        });\n    }\n    _loadSheenPropertiesAsync(context, properties, babylonMaterial) {\n        if (!(babylonMaterial instanceof PBRMaterial)) {\n            throw new Error(`${context}: Material type not supported`);\n        }\n        const promises = new Array();\n        babylonMaterial.sheen.isEnabled = true;\n        babylonMaterial.sheen.intensity = 1;\n        if (properties.sheenColorFactor != undefined) {\n            babylonMaterial.sheen.color = Color3.FromArray(properties.sheenColorFactor);\n        }\n        else {\n            babylonMaterial.sheen.color = Color3.Black();\n        }\n        if (properties.sheenColorTexture) {\n            promises.push(this._loader.loadTextureInfoAsync(`${context}/sheenColorTexture`, properties.sheenColorTexture, (texture) => {\n                texture.name = `${babylonMaterial.name} (Sheen Color)`;\n                babylonMaterial.sheen.texture = texture;\n            }));\n        }\n        if (properties.sheenRoughnessFactor !== undefined) {\n            babylonMaterial.sheen.roughness = properties.sheenRoughnessFactor;\n        }\n        else {\n            babylonMaterial.sheen.roughness = 0;\n        }\n        if (properties.sheenRoughnessTexture) {\n            properties.sheenRoughnessTexture.nonColorData = true;\n            promises.push(this._loader.loadTextureInfoAsync(`${context}/sheenRoughnessTexture`, properties.sheenRoughnessTexture, (texture) => {\n                texture.name = `${babylonMaterial.name} (Sheen Roughness)`;\n                babylonMaterial.sheen.textureRoughness = texture;\n            }));\n        }\n        babylonMaterial.sheen.albedoScaling = true;\n        babylonMaterial.sheen.useRoughnessFromMainTexture = false;\n        return Promise.all(promises).then(() => { });\n    }\n}\nGLTFLoader.RegisterExtension(NAME, (loader) => new KHR_materials_sheen(loader));\n//# sourceMappingURL=KHR_materials_sheen.js.map","import { PBRMaterial } from \"@babylonjs/core/Materials/PBR/pbrMaterial.js\";\nimport { GLTFLoader } from \"../glTFLoader.js\";\nimport { Color3 } from \"@babylonjs/core/Maths/math.color.js\";\nconst NAME = \"KHR_materials_specular\";\n/**\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_specular/README.md)\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport class KHR_materials_specular {\n    /**\n     * @internal\n     */\n    constructor(loader) {\n        /**\n         * The name of this extension.\n         */\n        this.name = NAME;\n        /**\n         * Defines a number that determines the order the extensions are applied.\n         */\n        this.order = 190;\n        this._loader = loader;\n        this.enabled = this._loader.isExtensionUsed(NAME);\n    }\n    /** @internal */\n    dispose() {\n        this._loader = null;\n    }\n    /**\n     * @internal\n     */\n    loadMaterialPropertiesAsync(context, material, babylonMaterial) {\n        return GLTFLoader.LoadExtensionAsync(context, material, this.name, (extensionContext, extension) => {\n            const promises = new Array();\n            promises.push(this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial));\n            promises.push(this._loadSpecularPropertiesAsync(extensionContext, extension, babylonMaterial));\n            return Promise.all(promises).then(() => { });\n        });\n    }\n    _loadSpecularPropertiesAsync(context, properties, babylonMaterial) {\n        if (!(babylonMaterial instanceof PBRMaterial)) {\n            throw new Error(`${context}: Material type not supported`);\n        }\n        const promises = new Array();\n        if (properties.specularFactor !== undefined) {\n            babylonMaterial.metallicF0Factor = properties.specularFactor;\n        }\n        if (properties.specularColorFactor !== undefined) {\n            babylonMaterial.metallicReflectanceColor = Color3.FromArray(properties.specularColorFactor);\n        }\n        if (properties.specularTexture) {\n            properties.specularTexture.nonColorData = true;\n            promises.push(this._loader.loadTextureInfoAsync(`${context}/specularTexture`, properties.specularTexture, (texture) => {\n                texture.name = `${babylonMaterial.name} (Specular F0 Strength)`;\n                babylonMaterial.metallicReflectanceTexture = texture;\n                babylonMaterial.useOnlyMetallicFromMetallicReflectanceTexture = true;\n            }));\n        }\n        if (properties.specularColorTexture) {\n            promises.push(this._loader.loadTextureInfoAsync(`${context}/specularColorTexture`, properties.specularColorTexture, (texture) => {\n                texture.name = `${babylonMaterial.name} (Specular F0 Color)`;\n                babylonMaterial.reflectanceTexture = texture;\n            }));\n        }\n        return Promise.all(promises).then(() => { });\n    }\n}\nGLTFLoader.RegisterExtension(NAME, (loader) => new KHR_materials_specular(loader));\n//# sourceMappingURL=KHR_materials_specular.js.map","import { PBRMaterial } from \"@babylonjs/core/Materials/PBR/pbrMaterial.js\";\nimport { GLTFLoader } from \"../glTFLoader.js\";\nconst NAME = \"KHR_materials_ior\";\n/**\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_ior/README.md)\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport class KHR_materials_ior {\n    /**\n     * @internal\n     */\n    constructor(loader) {\n        /**\n         * The name of this extension.\n         */\n        this.name = NAME;\n        /**\n         * Defines a number that determines the order the extensions are applied.\n         */\n        this.order = 180;\n        this._loader = loader;\n        this.enabled = this._loader.isExtensionUsed(NAME);\n    }\n    /** @internal */\n    dispose() {\n        this._loader = null;\n    }\n    /**\n     * @internal\n     */\n    loadMaterialPropertiesAsync(context, material, babylonMaterial) {\n        return GLTFLoader.LoadExtensionAsync(context, material, this.name, (extensionContext, extension) => {\n            const promises = new Array();\n            promises.push(this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial));\n            promises.push(this._loadIorPropertiesAsync(extensionContext, extension, babylonMaterial));\n            return Promise.all(promises).then(() => { });\n        });\n    }\n    _loadIorPropertiesAsync(context, properties, babylonMaterial) {\n        if (!(babylonMaterial instanceof PBRMaterial)) {\n            throw new Error(`${context}: Material type not supported`);\n        }\n        if (properties.ior !== undefined) {\n            babylonMaterial.indexOfRefraction = properties.ior;\n        }\n        else {\n            babylonMaterial.indexOfRefraction = KHR_materials_ior._DEFAULT_IOR;\n        }\n        return Promise.resolve();\n    }\n}\n/**\n * Default ior Value from the spec.\n */\nKHR_materials_ior._DEFAULT_IOR = 1.5;\nGLTFLoader.RegisterExtension(NAME, (loader) => new KHR_materials_ior(loader));\n//# sourceMappingURL=KHR_materials_ior.js.map","import { GLTFLoader, ArrayItem } from \"../glTFLoader.js\";\nimport { Mesh } from \"@babylonjs/core/Meshes/mesh.js\";\nconst NAME = \"KHR_materials_variants\";\n/**\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_variants/README.md)\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport class KHR_materials_variants {\n    /**\n     * @internal\n     */\n    constructor(loader) {\n        /**\n         * The name of this extension.\n         */\n        this.name = NAME;\n        this._loader = loader;\n        this.enabled = this._loader.isExtensionUsed(NAME);\n    }\n    /** @internal */\n    dispose() {\n        this._loader = null;\n    }\n    /**\n     * Gets the list of available variant names for this asset.\n     * @param rootMesh The glTF root mesh\n     * @returns the list of all the variant names for this model\n     */\n    static GetAvailableVariants(rootMesh) {\n        const extensionMetadata = this._GetExtensionMetadata(rootMesh);\n        if (!extensionMetadata) {\n            return [];\n        }\n        return Object.keys(extensionMetadata.variants);\n    }\n    /**\n     * Gets the list of available variant names for this asset.\n     * @param rootMesh The glTF root mesh\n     * @returns the list of all the variant names for this model\n     */\n    getAvailableVariants(rootMesh) {\n        return KHR_materials_variants.GetAvailableVariants(rootMesh);\n    }\n    /**\n     * Select a variant given a variant name or a list of variant names.\n     * @param rootMesh The glTF root mesh\n     * @param variantName The variant name(s) to select.\n     */\n    static SelectVariant(rootMesh, variantName) {\n        const extensionMetadata = this._GetExtensionMetadata(rootMesh);\n        if (!extensionMetadata) {\n            throw new Error(`Cannot select variant on a glTF mesh that does not have the ${NAME} extension`);\n        }\n        const select = (variantName) => {\n            const entries = extensionMetadata.variants[variantName];\n            if (entries) {\n                for (const entry of entries) {\n                    entry.mesh.material = entry.material;\n                }\n            }\n        };\n        if (variantName instanceof Array) {\n            for (const name of variantName) {\n                select(name);\n            }\n        }\n        else {\n            select(variantName);\n        }\n        extensionMetadata.lastSelected = variantName;\n    }\n    /**\n     * Select a variant given a variant name or a list of variant names.\n     * @param rootMesh The glTF root mesh\n     * @param variantName The variant name(s) to select.\n     */\n    selectVariant(rootMesh, variantName) {\n        return KHR_materials_variants.SelectVariant(rootMesh, variantName);\n    }\n    /**\n     * Reset back to the original before selecting a variant.\n     * @param rootMesh The glTF root mesh\n     */\n    static Reset(rootMesh) {\n        const extensionMetadata = this._GetExtensionMetadata(rootMesh);\n        if (!extensionMetadata) {\n            throw new Error(`Cannot reset on a glTF mesh that does not have the ${NAME} extension`);\n        }\n        for (const entry of extensionMetadata.original) {\n            entry.mesh.material = entry.material;\n        }\n        extensionMetadata.lastSelected = null;\n    }\n    /**\n     * Reset back to the original before selecting a variant.\n     * @param rootMesh The glTF root mesh\n     */\n    reset(rootMesh) {\n        return KHR_materials_variants.Reset(rootMesh);\n    }\n    /**\n     * Gets the last selected variant name(s) or null if original.\n     * @param rootMesh The glTF root mesh\n     * @returns The selected variant name(s).\n     */\n    static GetLastSelectedVariant(rootMesh) {\n        const extensionMetadata = this._GetExtensionMetadata(rootMesh);\n        if (!extensionMetadata) {\n            throw new Error(`Cannot get the last selected variant on a glTF mesh that does not have the ${NAME} extension`);\n        }\n        return extensionMetadata.lastSelected;\n    }\n    /**\n     * Gets the last selected variant name(s) or null if original.\n     * @param rootMesh The glTF root mesh\n     * @returns The selected variant name(s).\n     */\n    getLastSelectedVariant(rootMesh) {\n        return KHR_materials_variants.GetLastSelectedVariant(rootMesh);\n    }\n    static _GetExtensionMetadata(rootMesh) {\n        var _a, _b;\n        return ((_b = (_a = rootMesh === null || rootMesh === void 0 ? void 0 : rootMesh._internalMetadata) === null || _a === void 0 ? void 0 : _a.gltf) === null || _b === void 0 ? void 0 : _b[NAME]) || null;\n    }\n    /** @internal */\n    onLoading() {\n        const extensions = this._loader.gltf.extensions;\n        if (extensions && extensions[this.name]) {\n            const extension = extensions[this.name];\n            this._variants = extension.variants;\n        }\n    }\n    /**\n     * @internal\n     */\n    _loadMeshPrimitiveAsync(context, name, node, mesh, primitive, assign) {\n        return GLTFLoader.LoadExtensionAsync(context, primitive, this.name, (extensionContext, extension) => {\n            const promises = new Array();\n            promises.push(this._loader._loadMeshPrimitiveAsync(context, name, node, mesh, primitive, (babylonMesh) => {\n                assign(babylonMesh);\n                if (babylonMesh instanceof Mesh) {\n                    const babylonDrawMode = GLTFLoader._GetDrawMode(context, primitive.mode);\n                    const root = this._loader.rootBabylonMesh;\n                    const metadata = root ? (root._internalMetadata = root._internalMetadata || {}) : {};\n                    const gltf = (metadata.gltf = metadata.gltf || {});\n                    const extensionMetadata = (gltf[NAME] = gltf[NAME] || { lastSelected: null, original: [], variants: {} });\n                    // Store the original material.\n                    extensionMetadata.original.push({ mesh: babylonMesh, material: babylonMesh.material });\n                    // For each mapping, look at the variants and make a new entry for them.\n                    for (let mappingIndex = 0; mappingIndex < extension.mappings.length; ++mappingIndex) {\n                        const mapping = extension.mappings[mappingIndex];\n                        const material = ArrayItem.Get(`${extensionContext}/mappings/${mappingIndex}/material`, this._loader.gltf.materials, mapping.material);\n                        promises.push(this._loader._loadMaterialAsync(`#/materials/${mapping.material}`, material, babylonMesh, babylonDrawMode, (babylonMaterial) => {\n                            for (let mappingVariantIndex = 0; mappingVariantIndex < mapping.variants.length; ++mappingVariantIndex) {\n                                const variantIndex = mapping.variants[mappingVariantIndex];\n                                const variant = ArrayItem.Get(`/extensions/${NAME}/variants/${variantIndex}`, this._variants, variantIndex);\n                                extensionMetadata.variants[variant.name] = extensionMetadata.variants[variant.name] || [];\n                                extensionMetadata.variants[variant.name].push({\n                                    mesh: babylonMesh,\n                                    material: babylonMaterial,\n                                });\n                                // Replace the target when original mesh is cloned\n                                babylonMesh.onClonedObservable.add((newOne) => {\n                                    const newMesh = newOne;\n                                    let metadata = null;\n                                    let newRoot = newMesh;\n                                    // Find root to get medata\n                                    do {\n                                        newRoot = newRoot.parent;\n                                        if (!newRoot) {\n                                            return;\n                                        }\n                                        metadata = KHR_materials_variants._GetExtensionMetadata(newRoot);\n                                    } while (metadata === null);\n                                    // Need to clone the metadata on the root (first time only)\n                                    if (root && metadata === KHR_materials_variants._GetExtensionMetadata(root)) {\n                                        // Copy main metadata\n                                        newRoot._internalMetadata = {};\n                                        for (const key in root._internalMetadata) {\n                                            newRoot._internalMetadata[key] = root._internalMetadata[key];\n                                        }\n                                        // Copy the gltf metadata\n                                        newRoot._internalMetadata.gltf = [];\n                                        for (const key in root._internalMetadata.gltf) {\n                                            newRoot._internalMetadata.gltf[key] = root._internalMetadata.gltf[key];\n                                        }\n                                        // Duplicate the extension specific metadata\n                                        newRoot._internalMetadata.gltf[NAME] = { lastSelected: null, original: [], variants: {} };\n                                        for (const original of metadata.original) {\n                                            newRoot._internalMetadata.gltf[NAME].original.push({\n                                                mesh: original.mesh,\n                                                material: original.material,\n                                            });\n                                        }\n                                        for (const key in metadata.variants) {\n                                            if (Object.prototype.hasOwnProperty.call(metadata.variants, key)) {\n                                                newRoot._internalMetadata.gltf[NAME].variants[key] = [];\n                                                for (const variantEntry of metadata.variants[key]) {\n                                                    newRoot._internalMetadata.gltf[NAME].variants[key].push({\n                                                        mesh: variantEntry.mesh,\n                                                        material: variantEntry.material,\n                                                    });\n                                                }\n                                            }\n                                        }\n                                        metadata = newRoot._internalMetadata.gltf[NAME];\n                                    }\n                                    // Relocate\n                                    for (const target of metadata.original) {\n                                        if (target.mesh === babylonMesh) {\n                                            target.mesh = newMesh;\n                                        }\n                                    }\n                                    for (const target of metadata.variants[variant.name]) {\n                                        if (target.mesh === babylonMesh) {\n                                            target.mesh = newMesh;\n                                        }\n                                    }\n                                });\n                            }\n                        }));\n                    }\n                }\n            }));\n            return Promise.all(promises).then(([babylonMesh]) => {\n                return babylonMesh;\n            });\n        });\n    }\n}\nGLTFLoader.RegisterExtension(NAME, (loader) => new KHR_materials_variants(loader));\n//# sourceMappingURL=KHR_materials_variants.js.map","import { PBRMaterial } from \"@babylonjs/core/Materials/PBR/pbrMaterial.js\";\nimport { GLTFLoader } from \"../glTFLoader.js\";\nimport { RenderTargetTexture } from \"@babylonjs/core/Materials/Textures/renderTargetTexture.js\";\nimport { Observable } from \"@babylonjs/core/Misc/observable.js\";\nimport { Constants } from \"@babylonjs/core/Engines/constants.js\";\nimport { Tools } from \"@babylonjs/core/Misc/tools.js\";\n/**\n * A class to handle setting up the rendering of opaque objects to be shown through transmissive objects.\n */\nclass TransmissionHelper {\n    /**\n     * Creates the default options for the helper.\n     */\n    static _GetDefaultOptions() {\n        return {\n            renderSize: 1024,\n            samples: 4,\n            lodGenerationScale: 1,\n            lodGenerationOffset: -4,\n            renderTargetTextureType: Constants.TEXTURETYPE_HALF_FLOAT,\n            generateMipmaps: true,\n        };\n    }\n    /**\n     * constructor\n     * @param options Defines the options we want to customize the helper\n     * @param scene The scene to add the material to\n     */\n    constructor(options, scene) {\n        this._opaqueRenderTarget = null;\n        this._opaqueMeshesCache = [];\n        this._transparentMeshesCache = [];\n        this._materialObservers = {};\n        this._options = {\n            ...TransmissionHelper._GetDefaultOptions(),\n            ...options,\n        };\n        this._scene = scene;\n        this._scene._transmissionHelper = this;\n        this.onErrorObservable = new Observable();\n        this._scene.onDisposeObservable.addOnce(() => {\n            this.dispose();\n        });\n        this._parseScene();\n        this._setupRenderTargets();\n    }\n    /**\n     * Updates the background according to the new options\n     * @param options\n     */\n    updateOptions(options) {\n        // First check if any options are actually being changed. If not, exit.\n        const newValues = Object.keys(options).filter((key) => this._options[key] !== options[key]);\n        if (!newValues.length) {\n            return;\n        }\n        const newOptions = {\n            ...this._options,\n            ...options,\n        };\n        const oldOptions = this._options;\n        this._options = newOptions;\n        // If size changes, recreate everything\n        if (newOptions.renderSize !== oldOptions.renderSize ||\n            newOptions.renderTargetTextureType !== oldOptions.renderTargetTextureType ||\n            newOptions.generateMipmaps !== oldOptions.generateMipmaps ||\n            !this._opaqueRenderTarget) {\n            this._setupRenderTargets();\n        }\n        else {\n            this._opaqueRenderTarget.samples = newOptions.samples;\n            this._opaqueRenderTarget.lodGenerationScale = newOptions.lodGenerationScale;\n            this._opaqueRenderTarget.lodGenerationOffset = newOptions.lodGenerationOffset;\n        }\n    }\n    /**\n     * Gets the opaque render target texture or null if not available.\n     */\n    getOpaqueTarget() {\n        return this._opaqueRenderTarget;\n    }\n    _shouldRenderAsTransmission(material) {\n        if (!material) {\n            return false;\n        }\n        if (material instanceof PBRMaterial && material.subSurface.isRefractionEnabled) {\n            return true;\n        }\n        return false;\n    }\n    _addMesh(mesh) {\n        this._materialObservers[mesh.uniqueId] = mesh.onMaterialChangedObservable.add(this._onMeshMaterialChanged.bind(this));\n        // we need to defer the processing because _addMesh may be called as part as an instance mesh creation, in which case some\n        // internal properties are not setup yet, like _sourceMesh (needed when doing mesh.material below)\n        Tools.SetImmediate(() => {\n            if (this._shouldRenderAsTransmission(mesh.material)) {\n                mesh.material.refractionTexture = this._opaqueRenderTarget;\n                this._transparentMeshesCache.push(mesh);\n            }\n            else {\n                this._opaqueMeshesCache.push(mesh);\n            }\n        });\n    }\n    _removeMesh(mesh) {\n        mesh.onMaterialChangedObservable.remove(this._materialObservers[mesh.uniqueId]);\n        delete this._materialObservers[mesh.uniqueId];\n        let idx = this._transparentMeshesCache.indexOf(mesh);\n        if (idx !== -1) {\n            this._transparentMeshesCache.splice(idx, 1);\n        }\n        idx = this._opaqueMeshesCache.indexOf(mesh);\n        if (idx !== -1) {\n            this._opaqueMeshesCache.splice(idx, 1);\n        }\n    }\n    _parseScene() {\n        this._scene.meshes.forEach(this._addMesh.bind(this));\n        // Listen for when a mesh is added to the scene and add it to our cache lists.\n        this._scene.onNewMeshAddedObservable.add(this._addMesh.bind(this));\n        // Listen for when a mesh is removed from to the scene and remove it from our cache lists.\n        this._scene.onMeshRemovedObservable.add(this._removeMesh.bind(this));\n    }\n    // When one of the meshes in the scene has its material changed, make sure that it's in the correct cache list.\n    _onMeshMaterialChanged(mesh) {\n        const transparentIdx = this._transparentMeshesCache.indexOf(mesh);\n        const opaqueIdx = this._opaqueMeshesCache.indexOf(mesh);\n        // If the material is transparent, make sure that it's added to the transparent list and removed from the opaque list\n        const useTransmission = this._shouldRenderAsTransmission(mesh.material);\n        if (useTransmission) {\n            if (mesh.material instanceof PBRMaterial) {\n                mesh.material.subSurface.refractionTexture = this._opaqueRenderTarget;\n            }\n            if (opaqueIdx !== -1) {\n                this._opaqueMeshesCache.splice(opaqueIdx, 1);\n                this._transparentMeshesCache.push(mesh);\n            }\n            else if (transparentIdx === -1) {\n                this._transparentMeshesCache.push(mesh);\n            }\n            // If the material is opaque, make sure that it's added to the opaque list and removed from the transparent list\n        }\n        else {\n            if (transparentIdx !== -1) {\n                this._transparentMeshesCache.splice(transparentIdx, 1);\n                this._opaqueMeshesCache.push(mesh);\n            }\n            else if (opaqueIdx === -1) {\n                this._opaqueMeshesCache.push(mesh);\n            }\n        }\n    }\n    /**\n     * Setup the render targets according to the specified options.\n     */\n    _setupRenderTargets() {\n        var _a, _b;\n        if (this._opaqueRenderTarget) {\n            this._opaqueRenderTarget.dispose();\n        }\n        this._opaqueRenderTarget = new RenderTargetTexture(\"opaqueSceneTexture\", this._options.renderSize, this._scene, this._options.generateMipmaps, undefined, this._options.renderTargetTextureType);\n        this._opaqueRenderTarget.ignoreCameraViewport = true;\n        this._opaqueRenderTarget.renderList = this._opaqueMeshesCache;\n        this._opaqueRenderTarget.clearColor = (_b = (_a = this._options.clearColor) === null || _a === void 0 ? void 0 : _a.clone()) !== null && _b !== void 0 ? _b : this._scene.clearColor.clone();\n        this._opaqueRenderTarget.gammaSpace = false;\n        this._opaqueRenderTarget.lodGenerationScale = this._options.lodGenerationScale;\n        this._opaqueRenderTarget.lodGenerationOffset = this._options.lodGenerationOffset;\n        this._opaqueRenderTarget.samples = this._options.samples;\n        let sceneImageProcessingapplyByPostProcess;\n        let saveSceneEnvIntensity;\n        this._opaqueRenderTarget.onBeforeBindObservable.add((opaqueRenderTarget) => {\n            saveSceneEnvIntensity = this._scene.environmentIntensity;\n            this._scene.environmentIntensity = 1.0;\n            sceneImageProcessingapplyByPostProcess = this._scene.imageProcessingConfiguration.applyByPostProcess;\n            if (!this._options.clearColor) {\n                this._scene.clearColor.toLinearSpaceToRef(opaqueRenderTarget.clearColor);\n            }\n            else {\n                opaqueRenderTarget.clearColor.copyFrom(this._options.clearColor);\n            }\n            // we do not use the applyByPostProcess setter to avoid flagging all the materials as \"image processing dirty\"!\n            this._scene.imageProcessingConfiguration._applyByPostProcess = true;\n        });\n        this._opaqueRenderTarget.onAfterUnbindObservable.add(() => {\n            this._scene.environmentIntensity = saveSceneEnvIntensity;\n            this._scene.imageProcessingConfiguration._applyByPostProcess = sceneImageProcessingapplyByPostProcess;\n        });\n        this._transparentMeshesCache.forEach((mesh) => {\n            if (this._shouldRenderAsTransmission(mesh.material)) {\n                mesh.material.refractionTexture = this._opaqueRenderTarget;\n            }\n        });\n    }\n    /**\n     * Dispose all the elements created by the Helper.\n     */\n    dispose() {\n        this._scene._transmissionHelper = undefined;\n        if (this._opaqueRenderTarget) {\n            this._opaqueRenderTarget.dispose();\n            this._opaqueRenderTarget = null;\n        }\n        this._transparentMeshesCache = [];\n        this._opaqueMeshesCache = [];\n    }\n}\nconst NAME = \"KHR_materials_transmission\";\n/**\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_transmission/README.md)\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport class KHR_materials_transmission {\n    /**\n     * @internal\n     */\n    constructor(loader) {\n        /**\n         * The name of this extension.\n         */\n        this.name = NAME;\n        /**\n         * Defines a number that determines the order the extensions are applied.\n         */\n        this.order = 175;\n        this._loader = loader;\n        this.enabled = this._loader.isExtensionUsed(NAME);\n        if (this.enabled) {\n            loader.parent.transparencyAsCoverage = true;\n        }\n    }\n    /** @internal */\n    dispose() {\n        this._loader = null;\n    }\n    /**\n     * @internal\n     */\n    loadMaterialPropertiesAsync(context, material, babylonMaterial) {\n        return GLTFLoader.LoadExtensionAsync(context, material, this.name, (extensionContext, extension) => {\n            const promises = new Array();\n            promises.push(this._loader.loadMaterialBasePropertiesAsync(context, material, babylonMaterial));\n            promises.push(this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial));\n            promises.push(this._loadTransparentPropertiesAsync(extensionContext, material, babylonMaterial, extension));\n            return Promise.all(promises).then(() => { });\n        });\n    }\n    _loadTransparentPropertiesAsync(context, material, babylonMaterial, extension) {\n        if (!(babylonMaterial instanceof PBRMaterial)) {\n            throw new Error(`${context}: Material type not supported`);\n        }\n        const pbrMaterial = babylonMaterial;\n        // Enables \"refraction\" texture which represents transmitted light.\n        pbrMaterial.subSurface.isRefractionEnabled = true;\n        // Since this extension models thin-surface transmission only, we must make IOR = 1.0\n        pbrMaterial.subSurface.volumeIndexOfRefraction = 1.0;\n        // Albedo colour will tint transmission.\n        pbrMaterial.subSurface.useAlbedoToTintRefraction = true;\n        if (extension.transmissionFactor !== undefined) {\n            pbrMaterial.subSurface.refractionIntensity = extension.transmissionFactor;\n            const scene = pbrMaterial.getScene();\n            if (pbrMaterial.subSurface.refractionIntensity && !scene._transmissionHelper) {\n                new TransmissionHelper({}, pbrMaterial.getScene());\n            }\n        }\n        else {\n            pbrMaterial.subSurface.refractionIntensity = 0.0;\n            pbrMaterial.subSurface.isRefractionEnabled = false;\n            return Promise.resolve();\n        }\n        pbrMaterial.subSurface.minimumThickness = 0.0;\n        pbrMaterial.subSurface.maximumThickness = 0.0;\n        if (extension.transmissionTexture) {\n            extension.transmissionTexture.nonColorData = true;\n            return this._loader.loadTextureInfoAsync(`${context}/transmissionTexture`, extension.transmissionTexture, undefined).then((texture) => {\n                pbrMaterial.subSurface.refractionIntensityTexture = texture;\n                pbrMaterial.subSurface.useGltfStyleTextures = true;\n            });\n        }\n        else {\n            return Promise.resolve();\n        }\n    }\n}\nGLTFLoader.RegisterExtension(NAME, (loader) => new KHR_materials_transmission(loader));\n//# sourceMappingURL=KHR_materials_transmission.js.map","import { PBRMaterial } from \"@babylonjs/core/Materials/PBR/pbrMaterial.js\";\nimport { GLTFLoader } from \"../glTFLoader.js\";\nconst NAME = \"KHR_materials_translucency\";\n/**\n * [Proposed Specification](https://github.com/KhronosGroup/glTF/pull/1825)\n * !!! Experimental Extension Subject to Changes !!!\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport class KHR_materials_translucency {\n    /**\n     * @internal\n     */\n    constructor(loader) {\n        /**\n         * The name of this extension.\n         */\n        this.name = NAME;\n        /**\n         * Defines a number that determines the order the extensions are applied.\n         */\n        this.order = 174;\n        this._loader = loader;\n        this.enabled = this._loader.isExtensionUsed(NAME);\n        if (this.enabled) {\n            loader.parent.transparencyAsCoverage = true;\n        }\n    }\n    /** @internal */\n    dispose() {\n        this._loader = null;\n    }\n    /**\n     * @internal\n     */\n    loadMaterialPropertiesAsync(context, material, babylonMaterial) {\n        return GLTFLoader.LoadExtensionAsync(context, material, this.name, (extensionContext, extension) => {\n            const promises = new Array();\n            promises.push(this._loader.loadMaterialBasePropertiesAsync(context, material, babylonMaterial));\n            promises.push(this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial));\n            promises.push(this._loadTranslucentPropertiesAsync(extensionContext, material, babylonMaterial, extension));\n            return Promise.all(promises).then(() => { });\n        });\n    }\n    _loadTranslucentPropertiesAsync(context, material, babylonMaterial, extension) {\n        if (!(babylonMaterial instanceof PBRMaterial)) {\n            throw new Error(`${context}: Material type not supported`);\n        }\n        const pbrMaterial = babylonMaterial;\n        // Enables \"translucency\" texture which represents diffusely-transmitted light.\n        pbrMaterial.subSurface.isTranslucencyEnabled = true;\n        // Since this extension models thin-surface transmission only, we must make the\n        // internal IOR == 1.0 and set the thickness to 0.\n        pbrMaterial.subSurface.volumeIndexOfRefraction = 1.0;\n        pbrMaterial.subSurface.minimumThickness = 0.0;\n        pbrMaterial.subSurface.maximumThickness = 0.0;\n        // Albedo colour will tint transmission.\n        pbrMaterial.subSurface.useAlbedoToTintTranslucency = true;\n        if (extension.translucencyFactor !== undefined) {\n            pbrMaterial.subSurface.translucencyIntensity = extension.translucencyFactor;\n        }\n        else {\n            pbrMaterial.subSurface.translucencyIntensity = 0.0;\n            pbrMaterial.subSurface.isTranslucencyEnabled = false;\n            return Promise.resolve();\n        }\n        if (extension.translucencyTexture) {\n            extension.translucencyTexture.nonColorData = true;\n            return this._loader.loadTextureInfoAsync(`${context}/translucencyTexture`, extension.translucencyTexture).then((texture) => {\n                pbrMaterial.subSurface.translucencyIntensityTexture = texture;\n            });\n        }\n        else {\n            return Promise.resolve();\n        }\n    }\n}\nGLTFLoader.RegisterExtension(NAME, (loader) => new KHR_materials_translucency(loader));\n//# sourceMappingURL=KHR_materials_translucency.js.map","import { PBRMaterial } from \"@babylonjs/core/Materials/PBR/pbrMaterial.js\";\nimport { GLTFLoader } from \"../glTFLoader.js\";\nconst NAME = \"KHR_materials_volume\";\n/**\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_volume/README.md)\n * @since 5.0.0\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport class KHR_materials_volume {\n    /**\n     * @internal\n     */\n    constructor(loader) {\n        /**\n         * The name of this extension.\n         */\n        this.name = NAME;\n        /**\n         * Defines a number that determines the order the extensions are applied.\n         */\n        this.order = 173;\n        this._loader = loader;\n        this.enabled = this._loader.isExtensionUsed(NAME);\n        if (this.enabled) {\n            // We need to disable instance usage because the attenuation factor depends on the node scale of each individual mesh\n            this._loader._disableInstancedMesh++;\n        }\n    }\n    /** @internal */\n    dispose() {\n        if (this.enabled) {\n            this._loader._disableInstancedMesh--;\n        }\n        this._loader = null;\n    }\n    /**\n     * @internal\n     */\n    loadMaterialPropertiesAsync(context, material, babylonMaterial) {\n        return GLTFLoader.LoadExtensionAsync(context, material, this.name, (extensionContext, extension) => {\n            const promises = new Array();\n            promises.push(this._loader.loadMaterialBasePropertiesAsync(context, material, babylonMaterial));\n            promises.push(this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial));\n            promises.push(this._loadVolumePropertiesAsync(extensionContext, material, babylonMaterial, extension));\n            return Promise.all(promises).then(() => { });\n        });\n    }\n    _loadVolumePropertiesAsync(context, material, babylonMaterial, extension) {\n        if (!(babylonMaterial instanceof PBRMaterial)) {\n            throw new Error(`${context}: Material type not supported`);\n        }\n        // If transparency isn't enabled already, this extension shouldn't do anything.\n        // i.e. it requires either the KHR_materials_transmission or KHR_materials_translucency extensions.\n        if ((!babylonMaterial.subSurface.isRefractionEnabled && !babylonMaterial.subSurface.isTranslucencyEnabled) || !extension.thicknessFactor) {\n            return Promise.resolve();\n        }\n        // IOR in this extension only affects interior.\n        babylonMaterial.subSurface.volumeIndexOfRefraction = babylonMaterial.indexOfRefraction;\n        const attenuationDistance = extension.attenuationDistance !== undefined ? extension.attenuationDistance : Number.MAX_VALUE;\n        babylonMaterial.subSurface.tintColorAtDistance = attenuationDistance;\n        if (extension.attenuationColor !== undefined && extension.attenuationColor.length == 3) {\n            babylonMaterial.subSurface.tintColor.copyFromFloats(extension.attenuationColor[0], extension.attenuationColor[1], extension.attenuationColor[2]);\n        }\n        babylonMaterial.subSurface.minimumThickness = 0.0;\n        babylonMaterial.subSurface.maximumThickness = extension.thicknessFactor;\n        babylonMaterial.subSurface.useThicknessAsDepth = true;\n        if (extension.thicknessTexture) {\n            extension.thicknessTexture.nonColorData = true;\n            return this._loader.loadTextureInfoAsync(`${context}/thicknessTexture`, extension.thicknessTexture).then((texture) => {\n                babylonMaterial.subSurface.thicknessTexture = texture;\n                babylonMaterial.subSurface.useGltfStyleTextures = true;\n            });\n        }\n        else {\n            return Promise.resolve();\n        }\n    }\n}\nGLTFLoader.RegisterExtension(NAME, (loader) => new KHR_materials_volume(loader));\n//# sourceMappingURL=KHR_materials_volume.js.map","import { GLTFLoader } from \"../glTFLoader.js\";\nconst NAME = \"KHR_mesh_quantization\";\n/**\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_mesh_quantization/README.md)\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport class KHR_mesh_quantization {\n    /**\n     * @internal\n     */\n    constructor(loader) {\n        /**\n         * The name of this extension.\n         */\n        this.name = NAME;\n        this.enabled = loader.isExtensionUsed(NAME);\n    }\n    /** @internal */\n    dispose() { }\n}\nGLTFLoader.RegisterExtension(NAME, (loader) => new KHR_mesh_quantization(loader));\n//# sourceMappingURL=KHR_mesh_quantization.js.map","import { GLTFLoader, ArrayItem } from \"../glTFLoader.js\";\nconst NAME = \"KHR_texture_basisu\";\n/**\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_texture_basisu/README.md)\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport class KHR_texture_basisu {\n    /**\n     * @internal\n     */\n    constructor(loader) {\n        /** The name of this extension. */\n        this.name = NAME;\n        this._loader = loader;\n        this.enabled = loader.isExtensionUsed(NAME);\n    }\n    /** @internal */\n    dispose() {\n        this._loader = null;\n    }\n    /**\n     * @internal\n     */\n    _loadTextureAsync(context, texture, assign) {\n        return GLTFLoader.LoadExtensionAsync(context, texture, this.name, (extensionContext, extension) => {\n            const sampler = texture.sampler == undefined ? GLTFLoader.DefaultSampler : ArrayItem.Get(`${context}/sampler`, this._loader.gltf.samplers, texture.sampler);\n            const image = ArrayItem.Get(`${extensionContext}/source`, this._loader.gltf.images, extension.source);\n            return this._loader._createTextureAsync(context, sampler, image, (babylonTexture) => {\n                assign(babylonTexture);\n            }, texture._textureInfo.nonColorData ? { useRGBAIfASTCBC7NotAvailableWhenUASTC: true } : undefined, !texture._textureInfo.nonColorData);\n        });\n    }\n}\nGLTFLoader.RegisterExtension(NAME, (loader) => new KHR_texture_basisu(loader));\n//# sourceMappingURL=KHR_texture_basisu.js.map","import { Texture } from \"@babylonjs/core/Materials/Textures/texture.js\";\nimport { GLTFLoader } from \"../glTFLoader.js\";\nconst NAME = \"KHR_texture_transform\";\n/**\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_texture_transform/README.md)\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport class KHR_texture_transform {\n    /**\n     * @internal\n     */\n    constructor(loader) {\n        /**\n         * The name of this extension.\n         */\n        this.name = NAME;\n        this._loader = loader;\n        this.enabled = this._loader.isExtensionUsed(NAME);\n    }\n    /** @internal */\n    dispose() {\n        this._loader = null;\n    }\n    /**\n     * @internal\n     */\n    loadTextureInfoAsync(context, textureInfo, assign) {\n        return GLTFLoader.LoadExtensionAsync(context, textureInfo, this.name, (extensionContext, extension) => {\n            return this._loader.loadTextureInfoAsync(context, textureInfo, (babylonTexture) => {\n                if (!(babylonTexture instanceof Texture)) {\n                    throw new Error(`${extensionContext}: Texture type not supported`);\n                }\n                if (extension.offset) {\n                    babylonTexture.uOffset = extension.offset[0];\n                    babylonTexture.vOffset = extension.offset[1];\n                }\n                // Always rotate around the origin.\n                babylonTexture.uRotationCenter = 0;\n                babylonTexture.vRotationCenter = 0;\n                if (extension.rotation) {\n                    babylonTexture.wAng = -extension.rotation;\n                }\n                if (extension.scale) {\n                    babylonTexture.uScale = extension.scale[0];\n                    babylonTexture.vScale = extension.scale[1];\n                }\n                if (extension.texCoord != undefined) {\n                    babylonTexture.coordinatesIndex = extension.texCoord;\n                }\n                assign(babylonTexture);\n            });\n        });\n    }\n}\nGLTFLoader.RegisterExtension(NAME, (loader) => new KHR_texture_transform(loader));\n//# sourceMappingURL=KHR_texture_transform.js.map","import { GLTFLoader } from \"../glTFLoader.js\";\nconst NAME = \"KHR_xmp_json_ld\";\n/**\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_xmp_json_ld/README.md)\n * @since 5.0.0\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport class KHR_xmp_json_ld {\n    /**\n     * @internal\n     */\n    constructor(loader) {\n        /**\n         * The name of this extension.\n         */\n        this.name = NAME;\n        /**\n         * Defines a number that determines the order the extensions are applied.\n         */\n        this.order = 100;\n        this._loader = loader;\n        this.enabled = this._loader.isExtensionUsed(NAME);\n    }\n    /** @internal */\n    dispose() {\n        this._loader = null;\n    }\n    /**\n     * Called after the loader state changes to LOADING.\n     */\n    onLoading() {\n        var _a, _b, _c;\n        if (this._loader.rootBabylonMesh === null) {\n            return;\n        }\n        const xmp_gltf = (_a = this._loader.gltf.extensions) === null || _a === void 0 ? void 0 : _a.KHR_xmp_json_ld;\n        const xmp_node = (_c = (_b = this._loader.gltf.asset) === null || _b === void 0 ? void 0 : _b.extensions) === null || _c === void 0 ? void 0 : _c.KHR_xmp_json_ld;\n        if (xmp_gltf && xmp_node) {\n            const packet = +xmp_node.packet;\n            if (xmp_gltf.packets && packet < xmp_gltf.packets.length) {\n                this._loader.rootBabylonMesh.metadata = this._loader.rootBabylonMesh.metadata || {};\n                this._loader.rootBabylonMesh.metadata.xmp = xmp_gltf.packets[packet];\n            }\n        }\n    }\n}\nGLTFLoader.RegisterExtension(NAME, (loader) => new KHR_xmp_json_ld(loader));\n//# sourceMappingURL=KHR_xmp_json_ld.js.map","/* eslint-disable @typescript-eslint/naming-convention */\nimport { Animation } from \"@babylonjs/core/Animations/animation.js\";\nimport { AnimationPropertyInfo, nodeAnimationData } from \"../glTFLoaderAnimation.js\";\nimport { Color3 } from \"@babylonjs/core/Maths/math.color.js\";\nfunction getColor3(_target, source, offset, scale) {\n    return Color3.FromArray(source, offset).scale(scale);\n}\nfunction getAlpha(_target, source, offset, scale) {\n    return source[offset + 3] * scale;\n}\nfunction getFloat(_target, source, offset, scale) {\n    return source[offset] * scale;\n}\nfunction getMinusFloat(_target, source, offset, scale) {\n    return -source[offset] * scale;\n}\nfunction getNextFloat(_target, source, offset, scale) {\n    return source[offset + 1] * scale;\n}\nfunction getFloatBy2(_target, source, offset, scale) {\n    return source[offset] * scale * 2;\n}\nfunction getTextureTransformTree(textureName) {\n    return {\n        scale: [\n            new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, `${textureName}.uScale`, getFloat, () => 2),\n            new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, `${textureName}.vScale`, getNextFloat, () => 2),\n        ],\n        offset: [\n            new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, `${textureName}.uOffset`, getFloat, () => 2),\n            new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, `${textureName}.vOffset`, getNextFloat, () => 2),\n        ],\n        rotation: [new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, `${textureName}.wAng`, getMinusFloat, () => 1)],\n    };\n}\nclass CameraAnimationPropertyInfo extends AnimationPropertyInfo {\n    /** @internal */\n    buildAnimations(target, name, fps, keys, callback) {\n        callback(target._babylonCamera, this._buildAnimation(name, fps, keys));\n    }\n}\nclass MaterialAnimationPropertyInfo extends AnimationPropertyInfo {\n    /** @internal */\n    buildAnimations(target, name, fps, keys, callback) {\n        for (const fillMode in target._data) {\n            callback(target._data[fillMode].babylonMaterial, this._buildAnimation(name, fps, keys));\n        }\n    }\n}\nclass LightAnimationPropertyInfo extends AnimationPropertyInfo {\n    /** @internal */\n    buildAnimations(target, name, fps, keys, callback) {\n        callback(target._babylonLight, this._buildAnimation(name, fps, keys));\n    }\n}\nconst nodesTree = {\n    __array__: {\n        __target__: true,\n        ...nodeAnimationData,\n    },\n};\nconst camerasTree = {\n    __array__: {\n        __target__: true,\n        orthographic: {\n            xmag: [\n                new CameraAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"orthoLeft\", getMinusFloat, () => 1),\n                new CameraAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"orthoRight\", getNextFloat, () => 1),\n            ],\n            ymag: [\n                new CameraAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"orthoBottom\", getMinusFloat, () => 1),\n                new CameraAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"orthoTop\", getNextFloat, () => 1),\n            ],\n            zfar: [new CameraAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"maxZ\", getFloat, () => 1)],\n            znear: [new CameraAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"minZ\", getFloat, () => 1)],\n        },\n        perspective: {\n            yfov: [new CameraAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"fov\", getFloat, () => 1)],\n            zfar: [new CameraAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"maxZ\", getFloat, () => 1)],\n            znear: [new CameraAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"minZ\", getFloat, () => 1)],\n        },\n    },\n};\nconst materialsTree = {\n    __array__: {\n        __target__: true,\n        pbrMetallicRoughness: {\n            baseColorFactor: [\n                new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_COLOR3, \"albedoColor\", getColor3, () => 4),\n                new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"alpha\", getAlpha, () => 4),\n            ],\n            metallicFactor: [new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"metallic\", getFloat, () => 1)],\n            roughnessFactor: [new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"roughness\", getFloat, () => 1)],\n            baseColorTexture: {\n                extensions: {\n                    KHR_texture_transform: getTextureTransformTree(\"albedoTexture\"),\n                },\n            },\n        },\n        emissiveFactor: [new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_COLOR3, \"emissiveColor\", getColor3, () => 3)],\n        normalTexture: {\n            scale: [new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"bumpTexture.level\", getFloat, () => 1)],\n        },\n        occlusionTexture: {\n            strength: [new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"ambientTextureStrength\", getFloat, () => 1)],\n            extensions: {\n                KHR_texture_transform: getTextureTransformTree(\"ambientTexture\"),\n            },\n        },\n        emissiveTexture: {\n            extensions: {\n                KHR_texture_transform: getTextureTransformTree(\"emissiveTexture\"),\n            },\n        },\n        extensions: {\n            KHR_materials_ior: {\n                ior: [new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"indexOfRefraction\", getFloat, () => 1)],\n            },\n            KHR_materials_clearcoat: {\n                clearcoatFactor: [new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"clearCoat.intensity\", getFloat, () => 1)],\n                clearcoatRoughnessFactor: [new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"clearCoat.roughness\", getFloat, () => 1)],\n            },\n            KHR_materials_sheen: {\n                sheenColorFactor: [new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_COLOR3, \"sheen.color\", getColor3, () => 3)],\n                sheenRoughnessFactor: [new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"sheen.roughness\", getFloat, () => 1)],\n            },\n            KHR_materials_specular: {\n                specularFactor: [new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"metallicF0Factor\", getFloat, () => 1)],\n                specularColorFactor: [new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_COLOR3, \"metallicReflectanceColor\", getColor3, () => 3)],\n            },\n            KHR_materials_emissive_strength: {\n                emissiveStrength: [new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"emissiveIntensity\", getFloat, () => 1)],\n            },\n            KHR_materials_transmission: {\n                transmissionFactor: [new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"subSurface.refractionIntensity\", getFloat, () => 1)],\n            },\n            KHR_materials_volume: {\n                attenuationColor: [new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_COLOR3, \"subSurface.tintColor\", getColor3, () => 3)],\n                attenuationDistance: [new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"subSurface.tintColorAtDistance\", getFloat, () => 1)],\n                thicknessFactor: [new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"subSurface.maximumThickness\", getFloat, () => 1)],\n            },\n            KHR_materials_iridescence: {\n                iridescenceFactor: [new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"iridescence.intensity\", getFloat, () => 1)],\n                iridescenceIor: [new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"iridescence.indexOfRefraction\", getFloat, () => 1)],\n                iridescenceThicknessMinimum: [new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"iridescence.minimumThickness\", getFloat, () => 1)],\n                iridescenceThicknessMaximum: [new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"iridescence.maximumThickness\", getFloat, () => 1)],\n            },\n        },\n    },\n};\nconst extensionsTree = {\n    KHR_lights_punctual: {\n        lights: {\n            __array__: {\n                __target__: true,\n                color: [new LightAnimationPropertyInfo(Animation.ANIMATIONTYPE_COLOR3, \"diffuse\", getColor3, () => 3)],\n                intensity: [new LightAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"intensity\", getFloat, () => 1)],\n                range: [new LightAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"range\", getFloat, () => 1)],\n                spot: {\n                    innerConeAngle: [new LightAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"innerAngle\", getFloatBy2, () => 1)],\n                    outerConeAngle: [new LightAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"angle\", getFloatBy2, () => 1)],\n                },\n            },\n        },\n    },\n};\n/** @internal */\nexport const animationPointerTree = {\n    nodes: nodesTree,\n    materials: materialsTree,\n    cameras: camerasTree,\n    extensions: extensionsTree,\n};\n//# sourceMappingURL=KHR_animation_pointer.data.js.map","import { GLTFLoader } from \"../glTFLoader.js\";\nimport { Logger } from \"@babylonjs/core/Misc/logger.js\";\nimport { animationPointerTree } from \"./KHR_animation_pointer.data.js\";\nconst NAME = \"KHR_animation_pointer\";\n/**\n * [Specification PR](https://github.com/KhronosGroup/glTF/pull/2147)\n * !!! Experimental Extension Subject to Changes !!!\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport class KHR_animation_pointer {\n    /**\n     * @internal\n     */\n    constructor(loader) {\n        /**\n         * The name of this extension.\n         */\n        this.name = NAME;\n        this._loader = loader;\n    }\n    /**\n     * Defines whether this extension is enabled.\n     */\n    get enabled() {\n        return this._loader.isExtensionUsed(NAME);\n    }\n    /** @internal */\n    dispose() {\n        this._loader = null;\n    }\n    /**\n     * Loads a glTF animation channel.\n     * @param context The context when loading the asset\n     * @param animationContext The context of the animation when loading the asset\n     * @param animation The glTF animation property\n     * @param channel The glTF animation channel property\n     * @param onLoad Called for each animation loaded\n     * @returns A void promise that resolves when the load is complete or null if not handled\n     */\n    _loadAnimationChannelAsync(context, animationContext, animation, channel, onLoad) {\n        var _a;\n        const extension = (_a = channel.target.extensions) === null || _a === void 0 ? void 0 : _a.KHR_animation_pointer;\n        if (!extension) {\n            return null;\n        }\n        if (channel.target.path !== \"pointer\" /* AnimationChannelTargetPath.POINTER */) {\n            Logger.Warn(`${context}/target/path: Value (${channel.target.path}) must be (${\"pointer\" /* AnimationChannelTargetPath.POINTER */}) when using the ${this.name} extension`);\n        }\n        if (channel.target.node != undefined) {\n            Logger.Warn(`${context}/target/node: Value (${channel.target.node}) must not be present when using the ${this.name} extension`);\n        }\n        const extensionContext = `${context}/extensions/${this.name}`;\n        const pointer = extension.pointer;\n        if (!pointer) {\n            throw new Error(`${extensionContext}: Pointer is missing`);\n        }\n        const targetInfo = this._parseAnimationPointer(`${extensionContext}/pointer`, pointer);\n        if (!targetInfo) {\n            Logger.Warn(`${extensionContext}/pointer: Invalid pointer (${pointer}) skipped`);\n            return null;\n        }\n        return this._loader._loadAnimationChannelFromTargetInfoAsync(context, animationContext, animation, channel, targetInfo, onLoad);\n    }\n    /**\n     * The pointer string is represented by a [JSON pointer](https://datatracker.ietf.org/doc/html/rfc6901).\n     * <animationPointer> := /<rootNode>/<assetIndex>/<propertyPath>\n     * <rootNode> := \"nodes\" | \"materials\" | \"meshes\" | \"cameras\" | \"extensions\"\n     * <assetIndex> := <digit> | <name>\n     * <propertyPath> := <extensionPath> | <standardPath>\n     * <extensionPath> := \"extensions\"/<name>/<standardPath>\n     * <standardPath> := <name> | <name>/<standardPath>\n     * <name> := W+\n     * <digit> := D+\n     *\n     * Examples:\n     *  - \"/nodes/0/rotation\"\n     *  - \"/materials/2/emissiveFactor\"\n     *  - \"/materials/2/pbrMetallicRoughness/baseColorFactor\"\n     *  - \"/materials/2/extensions/KHR_materials_emissive_strength/emissiveStrength\"\n     */\n    _parseAnimationPointer(context, pointer) {\n        if (!pointer.startsWith(\"/\")) {\n            Logger.Warn(`${context}: Value (${pointer}) must start with a slash`);\n            return null;\n        }\n        const parts = pointer.split(\"/\");\n        // Remove the first part since it will be empty string as pointers must start with a slash.\n        parts.shift();\n        let node = animationPointerTree;\n        let gltfCurrentNode = this._loader.gltf;\n        let gltfTargetNode = undefined;\n        for (const part of parts) {\n            if (node.__array__) {\n                node = node.__array__;\n            }\n            else {\n                node = node[part];\n                if (!node) {\n                    return null;\n                }\n            }\n            gltfCurrentNode = gltfCurrentNode && gltfCurrentNode[part];\n            if (node.__target__) {\n                gltfTargetNode = gltfCurrentNode;\n            }\n        }\n        if (!gltfTargetNode || !Array.isArray(node)) {\n            return null;\n        }\n        return {\n            target: gltfTargetNode,\n            properties: node,\n        };\n    }\n}\nGLTFLoader.RegisterExtension(NAME, (loader) => new KHR_animation_pointer(loader));\n//# sourceMappingURL=KHR_animation_pointer.js.map","import { Vector3 } from \"@babylonjs/core/Maths/math.vector.js\";\nimport { Tools } from \"@babylonjs/core/Misc/tools.js\";\nimport { AnimationEvent } from \"@babylonjs/core/Animations/animationEvent.js\";\nimport { Sound } from \"@babylonjs/core/Audio/sound.js\";\nimport { WeightedSound } from \"@babylonjs/core/Audio/weightedsound.js\";\nimport { GLTFLoader, ArrayItem } from \"../glTFLoader.js\";\nconst NAME = \"MSFT_audio_emitter\";\n/**\n * [Specification](https://github.com/najadojo/glTF/blob/MSFT_audio_emitter/extensions/2.0/Vendor/MSFT_audio_emitter/README.md)\n * !!! Experimental Extension Subject to Changes !!!\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport class MSFT_audio_emitter {\n    /**\n     * @internal\n     */\n    constructor(loader) {\n        /**\n         * The name of this extension.\n         */\n        this.name = NAME;\n        this._loader = loader;\n        this.enabled = this._loader.isExtensionUsed(NAME);\n    }\n    /** @internal */\n    dispose() {\n        this._loader = null;\n        this._clips = null;\n        this._emitters = null;\n    }\n    /** @internal */\n    onLoading() {\n        const extensions = this._loader.gltf.extensions;\n        if (extensions && extensions[this.name]) {\n            const extension = extensions[this.name];\n            this._clips = extension.clips;\n            this._emitters = extension.emitters;\n            ArrayItem.Assign(this._clips);\n            ArrayItem.Assign(this._emitters);\n        }\n    }\n    /**\n     * @internal\n     */\n    loadSceneAsync(context, scene) {\n        return GLTFLoader.LoadExtensionAsync(context, scene, this.name, (extensionContext, extension) => {\n            const promises = new Array();\n            promises.push(this._loader.loadSceneAsync(context, scene));\n            for (const emitterIndex of extension.emitters) {\n                const emitter = ArrayItem.Get(`${extensionContext}/emitters`, this._emitters, emitterIndex);\n                if (emitter.refDistance != undefined ||\n                    emitter.maxDistance != undefined ||\n                    emitter.rolloffFactor != undefined ||\n                    emitter.distanceModel != undefined ||\n                    emitter.innerAngle != undefined ||\n                    emitter.outerAngle != undefined) {\n                    throw new Error(`${extensionContext}: Direction or Distance properties are not allowed on emitters attached to a scene`);\n                }\n                promises.push(this._loadEmitterAsync(`${extensionContext}/emitters/${emitter.index}`, emitter));\n            }\n            return Promise.all(promises).then(() => { });\n        });\n    }\n    /**\n     * @internal\n     */\n    loadNodeAsync(context, node, assign) {\n        return GLTFLoader.LoadExtensionAsync(context, node, this.name, (extensionContext, extension) => {\n            const promises = new Array();\n            return this._loader\n                .loadNodeAsync(extensionContext, node, (babylonMesh) => {\n                for (const emitterIndex of extension.emitters) {\n                    const emitter = ArrayItem.Get(`${extensionContext}/emitters`, this._emitters, emitterIndex);\n                    promises.push(this._loadEmitterAsync(`${extensionContext}/emitters/${emitter.index}`, emitter).then(() => {\n                        for (const sound of emitter._babylonSounds) {\n                            sound.attachToMesh(babylonMesh);\n                            if (emitter.innerAngle != undefined || emitter.outerAngle != undefined) {\n                                sound.setLocalDirectionToMesh(Vector3.Forward());\n                                sound.setDirectionalCone(2 * Tools.ToDegrees(emitter.innerAngle == undefined ? Math.PI : emitter.innerAngle), 2 * Tools.ToDegrees(emitter.outerAngle == undefined ? Math.PI : emitter.outerAngle), 0);\n                            }\n                        }\n                    }));\n                }\n                assign(babylonMesh);\n            })\n                .then((babylonMesh) => {\n                return Promise.all(promises).then(() => {\n                    return babylonMesh;\n                });\n            });\n        });\n    }\n    /**\n     * @internal\n     */\n    loadAnimationAsync(context, animation) {\n        return GLTFLoader.LoadExtensionAsync(context, animation, this.name, (extensionContext, extension) => {\n            return this._loader.loadAnimationAsync(context, animation).then((babylonAnimationGroup) => {\n                const promises = new Array();\n                ArrayItem.Assign(extension.events);\n                for (const event of extension.events) {\n                    promises.push(this._loadAnimationEventAsync(`${extensionContext}/events/${event.index}`, context, animation, event, babylonAnimationGroup));\n                }\n                return Promise.all(promises).then(() => {\n                    return babylonAnimationGroup;\n                });\n            });\n        });\n    }\n    _loadClipAsync(context, clip) {\n        if (clip._objectURL) {\n            return clip._objectURL;\n        }\n        let promise;\n        if (clip.uri) {\n            promise = this._loader.loadUriAsync(context, clip, clip.uri);\n        }\n        else {\n            const bufferView = ArrayItem.Get(`${context}/bufferView`, this._loader.gltf.bufferViews, clip.bufferView);\n            promise = this._loader.loadBufferViewAsync(`/bufferViews/${bufferView.index}`, bufferView);\n        }\n        clip._objectURL = promise.then((data) => {\n            return URL.createObjectURL(new Blob([data], { type: clip.mimeType }));\n        });\n        return clip._objectURL;\n    }\n    _loadEmitterAsync(context, emitter) {\n        emitter._babylonSounds = emitter._babylonSounds || [];\n        if (!emitter._babylonData) {\n            const clipPromises = new Array();\n            const name = emitter.name || `emitter${emitter.index}`;\n            const options = {\n                loop: false,\n                autoplay: false,\n                volume: emitter.volume == undefined ? 1 : emitter.volume,\n            };\n            for (let i = 0; i < emitter.clips.length; i++) {\n                const clipContext = `/extensions/${this.name}/clips`;\n                const clip = ArrayItem.Get(clipContext, this._clips, emitter.clips[i].clip);\n                clipPromises.push(this._loadClipAsync(`${clipContext}/${emitter.clips[i].clip}`, clip).then((objectURL) => {\n                    const sound = (emitter._babylonSounds[i] = new Sound(name, objectURL, this._loader.babylonScene, null, options));\n                    sound.refDistance = emitter.refDistance || 1;\n                    sound.maxDistance = emitter.maxDistance || 256;\n                    sound.rolloffFactor = emitter.rolloffFactor || 1;\n                    sound.distanceModel = emitter.distanceModel || \"exponential\";\n                }));\n            }\n            const promise = Promise.all(clipPromises).then(() => {\n                const weights = emitter.clips.map((clip) => {\n                    return clip.weight || 1;\n                });\n                const weightedSound = new WeightedSound(emitter.loop || false, emitter._babylonSounds, weights);\n                if (emitter.innerAngle) {\n                    weightedSound.directionalConeInnerAngle = 2 * Tools.ToDegrees(emitter.innerAngle);\n                }\n                if (emitter.outerAngle) {\n                    weightedSound.directionalConeOuterAngle = 2 * Tools.ToDegrees(emitter.outerAngle);\n                }\n                if (emitter.volume) {\n                    weightedSound.volume = emitter.volume;\n                }\n                emitter._babylonData.sound = weightedSound;\n            });\n            emitter._babylonData = {\n                loaded: promise,\n            };\n        }\n        return emitter._babylonData.loaded;\n    }\n    _getEventAction(context, sound, action, time, startOffset) {\n        switch (action) {\n            case \"play\" /* IMSFTAudioEmitter_AnimationEventAction.play */: {\n                return (currentFrame) => {\n                    const frameOffset = (startOffset || 0) + (currentFrame - time);\n                    sound.play(frameOffset);\n                };\n            }\n            case \"stop\" /* IMSFTAudioEmitter_AnimationEventAction.stop */: {\n                return () => {\n                    sound.stop();\n                };\n            }\n            case \"pause\" /* IMSFTAudioEmitter_AnimationEventAction.pause */: {\n                return () => {\n                    sound.pause();\n                };\n            }\n            default: {\n                throw new Error(`${context}: Unsupported action ${action}`);\n            }\n        }\n    }\n    _loadAnimationEventAsync(context, animationContext, animation, event, babylonAnimationGroup) {\n        if (babylonAnimationGroup.targetedAnimations.length == 0) {\n            return Promise.resolve();\n        }\n        const babylonAnimation = babylonAnimationGroup.targetedAnimations[0];\n        const emitterIndex = event.emitter;\n        const emitter = ArrayItem.Get(`/extensions/${this.name}/emitters`, this._emitters, emitterIndex);\n        return this._loadEmitterAsync(context, emitter).then(() => {\n            const sound = emitter._babylonData.sound;\n            if (sound) {\n                const babylonAnimationEvent = new AnimationEvent(event.time, this._getEventAction(context, sound, event.action, event.time, event.startOffset));\n                babylonAnimation.animation.addEvent(babylonAnimationEvent);\n                // Make sure all started audio stops when this animation is terminated.\n                babylonAnimationGroup.onAnimationGroupEndObservable.add(() => {\n                    sound.stop();\n                });\n                babylonAnimationGroup.onAnimationGroupPauseObservable.add(() => {\n                    sound.pause();\n                });\n            }\n        });\n    }\n}\nGLTFLoader.RegisterExtension(NAME, (loader) => new MSFT_audio_emitter(loader));\n//# sourceMappingURL=MSFT_audio_emitter.js.map","import { Observable } from \"@babylonjs/core/Misc/observable.js\";\nimport { Deferred } from \"@babylonjs/core/Misc/deferred.js\";\nimport { GLTFLoader, ArrayItem } from \"../glTFLoader.js\";\nconst NAME = \"MSFT_lod\";\n/**\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Vendor/MSFT_lod/README.md)\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport class MSFT_lod {\n    /**\n     * @internal\n     */\n    constructor(loader) {\n        /**\n         * The name of this extension.\n         */\n        this.name = NAME;\n        /**\n         * Defines a number that determines the order the extensions are applied.\n         */\n        this.order = 100;\n        /**\n         * Maximum number of LODs to load, starting from the lowest LOD.\n         */\n        this.maxLODsToLoad = 10;\n        /**\n         * Observable raised when all node LODs of one level are loaded.\n         * The event data is the index of the loaded LOD starting from zero.\n         * Dispose the loader to cancel the loading of the next level of LODs.\n         */\n        this.onNodeLODsLoadedObservable = new Observable();\n        /**\n         * Observable raised when all material LODs of one level are loaded.\n         * The event data is the index of the loaded LOD starting from zero.\n         * Dispose the loader to cancel the loading of the next level of LODs.\n         */\n        this.onMaterialLODsLoadedObservable = new Observable();\n        this._bufferLODs = new Array();\n        this._nodeIndexLOD = null;\n        this._nodeSignalLODs = new Array();\n        this._nodePromiseLODs = new Array();\n        this._nodeBufferLODs = new Array();\n        this._materialIndexLOD = null;\n        this._materialSignalLODs = new Array();\n        this._materialPromiseLODs = new Array();\n        this._materialBufferLODs = new Array();\n        this._loader = loader;\n        this.enabled = this._loader.isExtensionUsed(NAME);\n    }\n    /** @internal */\n    dispose() {\n        this._loader = null;\n        this._nodeIndexLOD = null;\n        this._nodeSignalLODs.length = 0;\n        this._nodePromiseLODs.length = 0;\n        this._nodeBufferLODs.length = 0;\n        this._materialIndexLOD = null;\n        this._materialSignalLODs.length = 0;\n        this._materialPromiseLODs.length = 0;\n        this._materialBufferLODs.length = 0;\n        this.onMaterialLODsLoadedObservable.clear();\n        this.onNodeLODsLoadedObservable.clear();\n    }\n    /** @internal */\n    onReady() {\n        for (let indexLOD = 0; indexLOD < this._nodePromiseLODs.length; indexLOD++) {\n            const promise = Promise.all(this._nodePromiseLODs[indexLOD]).then(() => {\n                if (indexLOD !== 0) {\n                    this._loader.endPerformanceCounter(`Node LOD ${indexLOD}`);\n                    this._loader.log(`Loaded node LOD ${indexLOD}`);\n                }\n                this.onNodeLODsLoadedObservable.notifyObservers(indexLOD);\n                if (indexLOD !== this._nodePromiseLODs.length - 1) {\n                    this._loader.startPerformanceCounter(`Node LOD ${indexLOD + 1}`);\n                    this._loadBufferLOD(this._nodeBufferLODs, indexLOD + 1);\n                    if (this._nodeSignalLODs[indexLOD]) {\n                        this._nodeSignalLODs[indexLOD].resolve();\n                    }\n                }\n            });\n            this._loader._completePromises.push(promise);\n        }\n        for (let indexLOD = 0; indexLOD < this._materialPromiseLODs.length; indexLOD++) {\n            const promise = Promise.all(this._materialPromiseLODs[indexLOD]).then(() => {\n                if (indexLOD !== 0) {\n                    this._loader.endPerformanceCounter(`Material LOD ${indexLOD}`);\n                    this._loader.log(`Loaded material LOD ${indexLOD}`);\n                }\n                this.onMaterialLODsLoadedObservable.notifyObservers(indexLOD);\n                if (indexLOD !== this._materialPromiseLODs.length - 1) {\n                    this._loader.startPerformanceCounter(`Material LOD ${indexLOD + 1}`);\n                    this._loadBufferLOD(this._materialBufferLODs, indexLOD + 1);\n                    if (this._materialSignalLODs[indexLOD]) {\n                        this._materialSignalLODs[indexLOD].resolve();\n                    }\n                }\n            });\n            this._loader._completePromises.push(promise);\n        }\n    }\n    /**\n     * @internal\n     */\n    loadSceneAsync(context, scene) {\n        const promise = this._loader.loadSceneAsync(context, scene);\n        this._loadBufferLOD(this._bufferLODs, 0);\n        return promise;\n    }\n    /**\n     * @internal\n     */\n    loadNodeAsync(context, node, assign) {\n        return GLTFLoader.LoadExtensionAsync(context, node, this.name, (extensionContext, extension) => {\n            let firstPromise;\n            const nodeLODs = this._getLODs(extensionContext, node, this._loader.gltf.nodes, extension.ids);\n            this._loader.logOpen(`${extensionContext}`);\n            for (let indexLOD = 0; indexLOD < nodeLODs.length; indexLOD++) {\n                const nodeLOD = nodeLODs[indexLOD];\n                if (indexLOD !== 0) {\n                    this._nodeIndexLOD = indexLOD;\n                    this._nodeSignalLODs[indexLOD] = this._nodeSignalLODs[indexLOD] || new Deferred();\n                }\n                const assignWrap = (babylonTransformNode) => {\n                    assign(babylonTransformNode);\n                    babylonTransformNode.setEnabled(false);\n                };\n                const promise = this._loader.loadNodeAsync(`/nodes/${nodeLOD.index}`, nodeLOD, assignWrap).then((babylonMesh) => {\n                    if (indexLOD !== 0) {\n                        // TODO: should not rely on _babylonTransformNode\n                        const previousNodeLOD = nodeLODs[indexLOD - 1];\n                        if (previousNodeLOD._babylonTransformNode) {\n                            this._disposeTransformNode(previousNodeLOD._babylonTransformNode);\n                            delete previousNodeLOD._babylonTransformNode;\n                        }\n                    }\n                    babylonMesh.setEnabled(true);\n                    return babylonMesh;\n                });\n                this._nodePromiseLODs[indexLOD] = this._nodePromiseLODs[indexLOD] || [];\n                if (indexLOD === 0) {\n                    firstPromise = promise;\n                }\n                else {\n                    this._nodeIndexLOD = null;\n                    this._nodePromiseLODs[indexLOD].push(promise);\n                }\n            }\n            this._loader.logClose();\n            return firstPromise;\n        });\n    }\n    /**\n     * @internal\n     */\n    _loadMaterialAsync(context, material, babylonMesh, babylonDrawMode, assign) {\n        // Don't load material LODs if already loading a node LOD.\n        if (this._nodeIndexLOD) {\n            return null;\n        }\n        return GLTFLoader.LoadExtensionAsync(context, material, this.name, (extensionContext, extension) => {\n            let firstPromise;\n            const materialLODs = this._getLODs(extensionContext, material, this._loader.gltf.materials, extension.ids);\n            this._loader.logOpen(`${extensionContext}`);\n            for (let indexLOD = 0; indexLOD < materialLODs.length; indexLOD++) {\n                const materialLOD = materialLODs[indexLOD];\n                if (indexLOD !== 0) {\n                    this._materialIndexLOD = indexLOD;\n                }\n                const promise = this._loader\n                    ._loadMaterialAsync(`/materials/${materialLOD.index}`, materialLOD, babylonMesh, babylonDrawMode, (babylonMaterial) => {\n                    if (indexLOD === 0) {\n                        assign(babylonMaterial);\n                    }\n                })\n                    .then((babylonMaterial) => {\n                    if (indexLOD !== 0) {\n                        assign(babylonMaterial);\n                        // TODO: should not rely on _data\n                        const previousDataLOD = materialLODs[indexLOD - 1]._data;\n                        if (previousDataLOD[babylonDrawMode]) {\n                            this._disposeMaterials([previousDataLOD[babylonDrawMode].babylonMaterial]);\n                            delete previousDataLOD[babylonDrawMode];\n                        }\n                    }\n                    return babylonMaterial;\n                });\n                this._materialPromiseLODs[indexLOD] = this._materialPromiseLODs[indexLOD] || [];\n                if (indexLOD === 0) {\n                    firstPromise = promise;\n                }\n                else {\n                    this._materialIndexLOD = null;\n                    this._materialPromiseLODs[indexLOD].push(promise);\n                }\n            }\n            this._loader.logClose();\n            return firstPromise;\n        });\n    }\n    /**\n     * @internal\n     */\n    _loadUriAsync(context, property, uri) {\n        // Defer the loading of uris if loading a node or material LOD.\n        if (this._nodeIndexLOD !== null) {\n            this._loader.log(`deferred`);\n            const previousIndexLOD = this._nodeIndexLOD - 1;\n            this._nodeSignalLODs[previousIndexLOD] = this._nodeSignalLODs[previousIndexLOD] || new Deferred();\n            return this._nodeSignalLODs[this._nodeIndexLOD - 1].promise.then(() => {\n                return this._loader.loadUriAsync(context, property, uri);\n            });\n        }\n        else if (this._materialIndexLOD !== null) {\n            this._loader.log(`deferred`);\n            const previousIndexLOD = this._materialIndexLOD - 1;\n            this._materialSignalLODs[previousIndexLOD] = this._materialSignalLODs[previousIndexLOD] || new Deferred();\n            return this._materialSignalLODs[previousIndexLOD].promise.then(() => {\n                return this._loader.loadUriAsync(context, property, uri);\n            });\n        }\n        return null;\n    }\n    /**\n     * @internal\n     */\n    loadBufferAsync(context, buffer, byteOffset, byteLength) {\n        if (this._loader.parent.useRangeRequests && !buffer.uri) {\n            if (!this._loader.bin) {\n                throw new Error(`${context}: Uri is missing or the binary glTF is missing its binary chunk`);\n            }\n            const loadAsync = (bufferLODs, indexLOD) => {\n                const start = byteOffset;\n                const end = start + byteLength - 1;\n                let bufferLOD = bufferLODs[indexLOD];\n                if (bufferLOD) {\n                    bufferLOD.start = Math.min(bufferLOD.start, start);\n                    bufferLOD.end = Math.max(bufferLOD.end, end);\n                }\n                else {\n                    bufferLOD = { start: start, end: end, loaded: new Deferred() };\n                    bufferLODs[indexLOD] = bufferLOD;\n                }\n                return bufferLOD.loaded.promise.then((data) => {\n                    return new Uint8Array(data.buffer, data.byteOffset + byteOffset - bufferLOD.start, byteLength);\n                });\n            };\n            this._loader.log(`deferred`);\n            if (this._nodeIndexLOD !== null) {\n                return loadAsync(this._nodeBufferLODs, this._nodeIndexLOD);\n            }\n            else if (this._materialIndexLOD !== null) {\n                return loadAsync(this._materialBufferLODs, this._materialIndexLOD);\n            }\n            else {\n                return loadAsync(this._bufferLODs, 0);\n            }\n        }\n        return null;\n    }\n    _loadBufferLOD(bufferLODs, indexLOD) {\n        const bufferLOD = bufferLODs[indexLOD];\n        if (bufferLOD) {\n            this._loader.log(`Loading buffer range [${bufferLOD.start}-${bufferLOD.end}]`);\n            this._loader.bin.readAsync(bufferLOD.start, bufferLOD.end - bufferLOD.start + 1).then((data) => {\n                bufferLOD.loaded.resolve(data);\n            }, (error) => {\n                bufferLOD.loaded.reject(error);\n            });\n        }\n    }\n    /**\n     * Gets an array of LOD properties from lowest to highest.\n     * @param context\n     * @param property\n     * @param array\n     * @param ids\n     */\n    _getLODs(context, property, array, ids) {\n        if (this.maxLODsToLoad <= 0) {\n            throw new Error(\"maxLODsToLoad must be greater than zero\");\n        }\n        const properties = new Array();\n        for (let i = ids.length - 1; i >= 0; i--) {\n            properties.push(ArrayItem.Get(`${context}/ids/${ids[i]}`, array, ids[i]));\n            if (properties.length === this.maxLODsToLoad) {\n                return properties;\n            }\n        }\n        properties.push(property);\n        return properties;\n    }\n    _disposeTransformNode(babylonTransformNode) {\n        const babylonMaterials = new Array();\n        const babylonMaterial = babylonTransformNode.material;\n        if (babylonMaterial) {\n            babylonMaterials.push(babylonMaterial);\n        }\n        for (const babylonMesh of babylonTransformNode.getChildMeshes()) {\n            if (babylonMesh.material) {\n                babylonMaterials.push(babylonMesh.material);\n            }\n        }\n        babylonTransformNode.dispose();\n        const babylonMaterialsToDispose = babylonMaterials.filter((babylonMaterial) => this._loader.babylonScene.meshes.every((mesh) => mesh.material != babylonMaterial));\n        this._disposeMaterials(babylonMaterialsToDispose);\n    }\n    _disposeMaterials(babylonMaterials) {\n        const babylonTextures = {};\n        for (const babylonMaterial of babylonMaterials) {\n            for (const babylonTexture of babylonMaterial.getActiveTextures()) {\n                babylonTextures[babylonTexture.uniqueId] = babylonTexture;\n            }\n            babylonMaterial.dispose();\n        }\n        for (const uniqueId in babylonTextures) {\n            for (const babylonMaterial of this._loader.babylonScene.materials) {\n                if (babylonMaterial.hasTexture(babylonTextures[uniqueId])) {\n                    delete babylonTextures[uniqueId];\n                }\n            }\n        }\n        for (const uniqueId in babylonTextures) {\n            babylonTextures[uniqueId].dispose();\n        }\n    }\n}\nGLTFLoader.RegisterExtension(NAME, (loader) => new MSFT_lod(loader));\n//# sourceMappingURL=MSFT_lod.js.map","import { PBRMaterial } from \"@babylonjs/core/Materials/PBR/pbrMaterial.js\";\nimport { GLTFLoader } from \"../glTFLoader.js\";\nconst NAME = \"MSFT_minecraftMesh\";\n/** @internal */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport class MSFT_minecraftMesh {\n    /** @internal */\n    constructor(loader) {\n        /** @internal */\n        this.name = NAME;\n        this._loader = loader;\n        this.enabled = this._loader.isExtensionUsed(NAME);\n    }\n    /** @internal */\n    dispose() {\n        this._loader = null;\n    }\n    /** @internal */\n    loadMaterialPropertiesAsync(context, material, babylonMaterial) {\n        return GLTFLoader.LoadExtraAsync(context, material, this.name, (extraContext, extra) => {\n            if (extra) {\n                if (!(babylonMaterial instanceof PBRMaterial)) {\n                    throw new Error(`${extraContext}: Material type not supported`);\n                }\n                const promise = this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial);\n                if (babylonMaterial.needAlphaBlending()) {\n                    babylonMaterial.forceDepthWrite = true;\n                    babylonMaterial.separateCullingPass = true;\n                }\n                babylonMaterial.backFaceCulling = babylonMaterial.forceDepthWrite;\n                babylonMaterial.twoSidedLighting = true;\n                return promise;\n            }\n            return null;\n        });\n    }\n}\nGLTFLoader.RegisterExtension(NAME, (loader) => new MSFT_minecraftMesh(loader));\n//# sourceMappingURL=MSFT_minecraftMesh.js.map","import { PBRMaterial } from \"@babylonjs/core/Materials/PBR/pbrMaterial.js\";\nimport { GLTFLoader } from \"../glTFLoader.js\";\nconst NAME = \"MSFT_sRGBFactors\";\n/** @internal */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport class MSFT_sRGBFactors {\n    /** @internal */\n    constructor(loader) {\n        /** @internal */\n        this.name = NAME;\n        this._loader = loader;\n        this.enabled = this._loader.isExtensionUsed(NAME);\n    }\n    /** @internal */\n    dispose() {\n        this._loader = null;\n    }\n    /** @internal */\n    loadMaterialPropertiesAsync(context, material, babylonMaterial) {\n        return GLTFLoader.LoadExtraAsync(context, material, this.name, (extraContext, extra) => {\n            if (extra) {\n                if (!(babylonMaterial instanceof PBRMaterial)) {\n                    throw new Error(`${extraContext}: Material type not supported`);\n                }\n                const promise = this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial);\n                if (!babylonMaterial.albedoTexture) {\n                    babylonMaterial.albedoColor.toLinearSpaceToRef(babylonMaterial.albedoColor);\n                }\n                if (!babylonMaterial.reflectivityTexture) {\n                    babylonMaterial.reflectivityColor.toLinearSpaceToRef(babylonMaterial.reflectivityColor);\n                }\n                return promise;\n            }\n            return null;\n        });\n    }\n}\nGLTFLoader.RegisterExtension(NAME, (loader) => new MSFT_sRGBFactors(loader));\n//# sourceMappingURL=MSFT_sRGBFactors.js.map","import { GLTFLoader } from \"../glTFLoader.js\";\nconst NAME = \"ExtrasAsMetadata\";\n/**\n * Store glTF extras (if present) in BJS objects' metadata\n */\nexport class ExtrasAsMetadata {\n    _assignExtras(babylonObject, gltfProp) {\n        if (gltfProp.extras && Object.keys(gltfProp.extras).length > 0) {\n            const metadata = (babylonObject.metadata = babylonObject.metadata || {});\n            const gltf = (metadata.gltf = metadata.gltf || {});\n            gltf.extras = gltfProp.extras;\n        }\n    }\n    /**\n     * @internal\n     */\n    constructor(loader) {\n        /**\n         * The name of this extension.\n         */\n        this.name = NAME;\n        /**\n         * Defines whether this extension is enabled.\n         */\n        this.enabled = true;\n        this._loader = loader;\n    }\n    /** @internal */\n    dispose() {\n        this._loader = null;\n    }\n    /**\n     * @internal\n     */\n    loadNodeAsync(context, node, assign) {\n        return this._loader.loadNodeAsync(context, node, (babylonTransformNode) => {\n            this._assignExtras(babylonTransformNode, node);\n            assign(babylonTransformNode);\n        });\n    }\n    /**\n     * @internal\n     */\n    loadCameraAsync(context, camera, assign) {\n        return this._loader.loadCameraAsync(context, camera, (babylonCamera) => {\n            this._assignExtras(babylonCamera, camera);\n            assign(babylonCamera);\n        });\n    }\n    /**\n     * @internal\n     */\n    createMaterial(context, material, babylonDrawMode) {\n        const babylonMaterial = this._loader.createMaterial(context, material, babylonDrawMode);\n        this._assignExtras(babylonMaterial, material);\n        return babylonMaterial;\n    }\n}\nGLTFLoader.RegisterExtension(NAME, (loader) => new ExtrasAsMetadata(loader));\n//# sourceMappingURL=ExtrasAsMetadata.js.map","import { Observable } from \"@babylonjs/core/Misc/observable.js\";\nimport { Tools } from \"@babylonjs/core/Misc/tools.js\";\nimport { SceneLoader } from \"@babylonjs/core/Loading/sceneLoader.js\";\nimport { AssetContainer } from \"@babylonjs/core/assetContainer.js\";\nimport { Logger } from \"@babylonjs/core/Misc/logger.js\";\nimport { DataReader } from \"@babylonjs/core/Misc/dataReader.js\";\nimport { GLTFValidation } from \"./glTFValidation.js\";\nimport { DecodeBase64UrlToBinary } from \"@babylonjs/core/Misc/fileTools.js\";\nimport { RuntimeError, ErrorCodes } from \"@babylonjs/core/Misc/error.js\";\nfunction readAsync(arrayBuffer, byteOffset, byteLength) {\n    try {\n        return Promise.resolve(new Uint8Array(arrayBuffer, byteOffset, byteLength));\n    }\n    catch (e) {\n        return Promise.reject(e);\n    }\n}\n/**\n * Mode that determines the coordinate system to use.\n */\nexport var GLTFLoaderCoordinateSystemMode;\n(function (GLTFLoaderCoordinateSystemMode) {\n    /**\n     * Automatically convert the glTF right-handed data to the appropriate system based on the current coordinate system mode of the scene.\n     */\n    GLTFLoaderCoordinateSystemMode[GLTFLoaderCoordinateSystemMode[\"AUTO\"] = 0] = \"AUTO\";\n    /**\n     * Sets the useRightHandedSystem flag on the scene.\n     */\n    GLTFLoaderCoordinateSystemMode[GLTFLoaderCoordinateSystemMode[\"FORCE_RIGHT_HANDED\"] = 1] = \"FORCE_RIGHT_HANDED\";\n})(GLTFLoaderCoordinateSystemMode || (GLTFLoaderCoordinateSystemMode = {}));\n/**\n * Mode that determines what animations will start.\n */\nexport var GLTFLoaderAnimationStartMode;\n(function (GLTFLoaderAnimationStartMode) {\n    /**\n     * No animation will start.\n     */\n    GLTFLoaderAnimationStartMode[GLTFLoaderAnimationStartMode[\"NONE\"] = 0] = \"NONE\";\n    /**\n     * The first animation will start.\n     */\n    GLTFLoaderAnimationStartMode[GLTFLoaderAnimationStartMode[\"FIRST\"] = 1] = \"FIRST\";\n    /**\n     * All animations will start.\n     */\n    GLTFLoaderAnimationStartMode[GLTFLoaderAnimationStartMode[\"ALL\"] = 2] = \"ALL\";\n})(GLTFLoaderAnimationStartMode || (GLTFLoaderAnimationStartMode = {}));\n/**\n * Loader state.\n */\nexport var GLTFLoaderState;\n(function (GLTFLoaderState) {\n    /**\n     * The asset is loading.\n     */\n    GLTFLoaderState[GLTFLoaderState[\"LOADING\"] = 0] = \"LOADING\";\n    /**\n     * The asset is ready for rendering.\n     */\n    GLTFLoaderState[GLTFLoaderState[\"READY\"] = 1] = \"READY\";\n    /**\n     * The asset is completely loaded.\n     */\n    GLTFLoaderState[GLTFLoaderState[\"COMPLETE\"] = 2] = \"COMPLETE\";\n})(GLTFLoaderState || (GLTFLoaderState = {}));\n/**\n * File loader for loading glTF files into a scene.\n */\nexport class GLTFFileLoader {\n    constructor() {\n        // --------------\n        // Common options\n        // --------------\n        /**\n         * Raised when the asset has been parsed\n         */\n        this.onParsedObservable = new Observable();\n        // ----------\n        // V2 options\n        // ----------\n        /**\n         * The coordinate system mode. Defaults to AUTO.\n         */\n        this.coordinateSystemMode = GLTFLoaderCoordinateSystemMode.AUTO;\n        /**\n         * The animation start mode. Defaults to FIRST.\n         */\n        this.animationStartMode = GLTFLoaderAnimationStartMode.FIRST;\n        /**\n         * Defines if the loader should compile materials before raising the success callback. Defaults to false.\n         */\n        this.compileMaterials = false;\n        /**\n         * Defines if the loader should also compile materials with clip planes. Defaults to false.\n         */\n        this.useClipPlane = false;\n        /**\n         * Defines if the loader should compile shadow generators before raising the success callback. Defaults to false.\n         */\n        this.compileShadowGenerators = false;\n        /**\n         * Defines if the Alpha blended materials are only applied as coverage.\n         * If false, (default) The luminance of each pixel will reduce its opacity to simulate the behaviour of most physical materials.\n         * If true, no extra effects are applied to transparent pixels.\n         */\n        this.transparencyAsCoverage = false;\n        /**\n         * Defines if the loader should use range requests when load binary glTF files from HTTP.\n         * Enabling will disable offline support and glTF validator.\n         * Defaults to false.\n         */\n        this.useRangeRequests = false;\n        /**\n         * Defines if the loader should create instances when multiple glTF nodes point to the same glTF mesh. Defaults to true.\n         */\n        this.createInstances = true;\n        /**\n         * Defines if the loader should always compute the bounding boxes of meshes and not use the min/max values from the position accessor. Defaults to false.\n         */\n        this.alwaysComputeBoundingBox = false;\n        /**\n         * If true, load all materials defined in the file, even if not used by any mesh. Defaults to false.\n         */\n        this.loadAllMaterials = false;\n        /**\n         * If true, load only the materials defined in the file. Defaults to false.\n         */\n        this.loadOnlyMaterials = false;\n        /**\n         * If true, do not load any materials defined in the file. Defaults to false.\n         */\n        this.skipMaterials = false;\n        /**\n         * If true, load the color (gamma encoded) textures into sRGB buffers (if supported by the GPU), which will yield more accurate results when sampling the texture. Defaults to true.\n         */\n        this.useSRGBBuffers = true;\n        /**\n         * When loading glTF animations, which are defined in seconds, target them to this FPS. Defaults to 60.\n         */\n        this.targetFps = 60;\n        /**\n         * Defines if the loader should always compute the nearest common ancestor of the skeleton joints instead of using `skin.skeleton`. Defaults to false.\n         * Set this to true if loading assets with invalid `skin.skeleton` values.\n         */\n        this.alwaysComputeSkeletonRootNode = false;\n        /**\n         * Function called before loading a url referenced by the asset.\n         * @param url\n         */\n        this.preprocessUrlAsync = (url) => Promise.resolve(url);\n        /**\n         * Observable raised when the loader creates a mesh after parsing the glTF properties of the mesh.\n         * Note that the observable is raised as soon as the mesh object is created, meaning some data may not have been setup yet for this mesh (vertex data, morph targets, material, ...)\n         */\n        this.onMeshLoadedObservable = new Observable();\n        /**\n         * Callback raised when the loader creates a skin after parsing the glTF properties of the skin node.\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/importers/glTF/glTFSkinning#ignoring-the-transform-of-the-skinned-mesh\n         * @param node - the transform node that corresponds to the original glTF skin node used for animations\n         * @param skinnedNode - the transform node that is the skinned mesh itself or the parent of the skinned meshes\n         */\n        this.onSkinLoadedObservable = new Observable();\n        /**\n         * Observable raised when the loader creates a texture after parsing the glTF properties of the texture.\n         */\n        this.onTextureLoadedObservable = new Observable();\n        /**\n         * Observable raised when the loader creates a material after parsing the glTF properties of the material.\n         */\n        this.onMaterialLoadedObservable = new Observable();\n        /**\n         * Observable raised when the loader creates a camera after parsing the glTF properties of the camera.\n         */\n        this.onCameraLoadedObservable = new Observable();\n        /**\n         * Observable raised when the asset is completely loaded, immediately before the loader is disposed.\n         * For assets with LODs, raised when all of the LODs are complete.\n         * For assets without LODs, raised when the model is complete, immediately after the loader resolves the returned promise.\n         */\n        this.onCompleteObservable = new Observable();\n        /**\n         * Observable raised when an error occurs.\n         */\n        this.onErrorObservable = new Observable();\n        /**\n         * Observable raised after the loader is disposed.\n         */\n        this.onDisposeObservable = new Observable();\n        /**\n         * Observable raised after a loader extension is created.\n         * Set additional options for a loader extension in this event.\n         */\n        this.onExtensionLoadedObservable = new Observable();\n        /**\n         * Defines if the loader should validate the asset.\n         */\n        this.validate = false;\n        /**\n         * Observable raised after validation when validate is set to true. The event data is the result of the validation.\n         */\n        this.onValidatedObservable = new Observable();\n        this._loader = null;\n        this._state = null;\n        this._requests = new Array();\n        /**\n         * Name of the loader (\"gltf\")\n         */\n        this.name = \"gltf\";\n        /** @internal */\n        this.extensions = {\n            \".gltf\": { isBinary: false },\n            \".glb\": { isBinary: true },\n        };\n        /**\n         * Observable raised when the loader state changes.\n         */\n        this.onLoaderStateChangedObservable = new Observable();\n        this._logIndentLevel = 0;\n        this._loggingEnabled = false;\n        /** @internal */\n        this._log = this._logDisabled;\n        this._capturePerformanceCounters = false;\n        /** @internal */\n        this._startPerformanceCounter = this._startPerformanceCounterDisabled;\n        /** @internal */\n        this._endPerformanceCounter = this._endPerformanceCounterDisabled;\n    }\n    /**\n     * Raised when the asset has been parsed\n     */\n    set onParsed(callback) {\n        if (this._onParsedObserver) {\n            this.onParsedObservable.remove(this._onParsedObserver);\n        }\n        this._onParsedObserver = this.onParsedObservable.add(callback);\n    }\n    /**\n     * Callback raised when the loader creates a mesh after parsing the glTF properties of the mesh.\n     * Note that the callback is called as soon as the mesh object is created, meaning some data may not have been setup yet for this mesh (vertex data, morph targets, material, ...)\n     */\n    set onMeshLoaded(callback) {\n        if (this._onMeshLoadedObserver) {\n            this.onMeshLoadedObservable.remove(this._onMeshLoadedObserver);\n        }\n        this._onMeshLoadedObserver = this.onMeshLoadedObservable.add(callback);\n    }\n    /**\n     * Callback raised when the loader creates a texture after parsing the glTF properties of the texture.\n     */\n    set onTextureLoaded(callback) {\n        if (this._onTextureLoadedObserver) {\n            this.onTextureLoadedObservable.remove(this._onTextureLoadedObserver);\n        }\n        this._onTextureLoadedObserver = this.onTextureLoadedObservable.add(callback);\n    }\n    /**\n     * Callback raised when the loader creates a material after parsing the glTF properties of the material.\n     */\n    set onMaterialLoaded(callback) {\n        if (this._onMaterialLoadedObserver) {\n            this.onMaterialLoadedObservable.remove(this._onMaterialLoadedObserver);\n        }\n        this._onMaterialLoadedObserver = this.onMaterialLoadedObservable.add(callback);\n    }\n    /**\n     * Callback raised when the loader creates a camera after parsing the glTF properties of the camera.\n     */\n    set onCameraLoaded(callback) {\n        if (this._onCameraLoadedObserver) {\n            this.onCameraLoadedObservable.remove(this._onCameraLoadedObserver);\n        }\n        this._onCameraLoadedObserver = this.onCameraLoadedObservable.add(callback);\n    }\n    /**\n     * Callback raised when the asset is completely loaded, immediately before the loader is disposed.\n     * For assets with LODs, raised when all of the LODs are complete.\n     * For assets without LODs, raised when the model is complete, immediately after the loader resolves the returned promise.\n     */\n    set onComplete(callback) {\n        if (this._onCompleteObserver) {\n            this.onCompleteObservable.remove(this._onCompleteObserver);\n        }\n        this._onCompleteObserver = this.onCompleteObservable.add(callback);\n    }\n    /**\n     * Callback raised when an error occurs.\n     */\n    set onError(callback) {\n        if (this._onErrorObserver) {\n            this.onErrorObservable.remove(this._onErrorObserver);\n        }\n        this._onErrorObserver = this.onErrorObservable.add(callback);\n    }\n    /**\n     * Callback raised after the loader is disposed.\n     */\n    set onDispose(callback) {\n        if (this._onDisposeObserver) {\n            this.onDisposeObservable.remove(this._onDisposeObserver);\n        }\n        this._onDisposeObserver = this.onDisposeObservable.add(callback);\n    }\n    /**\n     * Callback raised after a loader extension is created.\n     */\n    set onExtensionLoaded(callback) {\n        if (this._onExtensionLoadedObserver) {\n            this.onExtensionLoadedObservable.remove(this._onExtensionLoadedObserver);\n        }\n        this._onExtensionLoadedObserver = this.onExtensionLoadedObservable.add(callback);\n    }\n    /**\n     * Defines if the loader logging is enabled.\n     */\n    get loggingEnabled() {\n        return this._loggingEnabled;\n    }\n    set loggingEnabled(value) {\n        if (this._loggingEnabled === value) {\n            return;\n        }\n        this._loggingEnabled = value;\n        if (this._loggingEnabled) {\n            this._log = this._logEnabled;\n        }\n        else {\n            this._log = this._logDisabled;\n        }\n    }\n    /**\n     * Defines if the loader should capture performance counters.\n     */\n    get capturePerformanceCounters() {\n        return this._capturePerformanceCounters;\n    }\n    set capturePerformanceCounters(value) {\n        if (this._capturePerformanceCounters === value) {\n            return;\n        }\n        this._capturePerformanceCounters = value;\n        if (this._capturePerformanceCounters) {\n            this._startPerformanceCounter = this._startPerformanceCounterEnabled;\n            this._endPerformanceCounter = this._endPerformanceCounterEnabled;\n        }\n        else {\n            this._startPerformanceCounter = this._startPerformanceCounterDisabled;\n            this._endPerformanceCounter = this._endPerformanceCounterDisabled;\n        }\n    }\n    /**\n     * Callback raised after a loader extension is created.\n     */\n    set onValidated(callback) {\n        if (this._onValidatedObserver) {\n            this.onValidatedObservable.remove(this._onValidatedObserver);\n        }\n        this._onValidatedObserver = this.onValidatedObservable.add(callback);\n    }\n    /**\n     * Disposes the loader, releases resources during load, and cancels any outstanding requests.\n     */\n    dispose() {\n        if (this._loader) {\n            this._loader.dispose();\n            this._loader = null;\n        }\n        for (const request of this._requests) {\n            request.abort();\n        }\n        this._requests.length = 0;\n        delete this._progressCallback;\n        this.preprocessUrlAsync = (url) => Promise.resolve(url);\n        this.onMeshLoadedObservable.clear();\n        this.onSkinLoadedObservable.clear();\n        this.onTextureLoadedObservable.clear();\n        this.onMaterialLoadedObservable.clear();\n        this.onCameraLoadedObservable.clear();\n        this.onCompleteObservable.clear();\n        this.onExtensionLoadedObservable.clear();\n        this.onDisposeObservable.notifyObservers(undefined);\n        this.onDisposeObservable.clear();\n    }\n    /**\n     * @internal\n     */\n    loadFile(scene, fileOrUrl, onSuccess, onProgress, useArrayBuffer, onError) {\n        this._progressCallback = onProgress;\n        const rootUrl = fileOrUrl.name ? \"file:\" : Tools.GetFolderPath(fileOrUrl);\n        const fileName = fileOrUrl.name || Tools.GetFilename(fileOrUrl);\n        if (useArrayBuffer) {\n            if (this.useRangeRequests) {\n                if (this.validate) {\n                    Logger.Warn(\"glTF validation is not supported when range requests are enabled\");\n                }\n                const fileRequest = {\n                    abort: () => { },\n                    onCompleteObservable: new Observable(),\n                };\n                const dataBuffer = {\n                    readAsync: (byteOffset, byteLength) => {\n                        return new Promise((resolve, reject) => {\n                            this._loadFile(scene, fileOrUrl, (data) => {\n                                resolve(new Uint8Array(data));\n                            }, true, (error) => {\n                                reject(error);\n                            }, (webRequest) => {\n                                webRequest.setRequestHeader(\"Range\", `bytes=${byteOffset}-${byteOffset + byteLength - 1}`);\n                            });\n                        });\n                    },\n                    byteLength: 0,\n                };\n                this._unpackBinaryAsync(new DataReader(dataBuffer)).then((loaderData) => {\n                    fileRequest.onCompleteObservable.notifyObservers(fileRequest);\n                    onSuccess(loaderData);\n                }, onError ? (error) => onError(undefined, error) : undefined);\n                return fileRequest;\n            }\n            return this._loadFile(scene, fileOrUrl, (data) => {\n                this._validate(scene, data, rootUrl, fileName);\n                this._unpackBinaryAsync(new DataReader({\n                    readAsync: (byteOffset, byteLength) => readAsync(data, byteOffset, byteLength),\n                    byteLength: data.byteLength,\n                })).then((loaderData) => {\n                    onSuccess(loaderData);\n                }, onError ? (error) => onError(undefined, error) : undefined);\n            }, true, onError);\n        }\n        return this._loadFile(scene, fileOrUrl, (data) => {\n            this._validate(scene, data, rootUrl, fileName);\n            onSuccess({ json: this._parseJson(data) });\n        }, useArrayBuffer, onError);\n    }\n    /**\n     * @internal\n     */\n    importMeshAsync(meshesNames, scene, data, rootUrl, onProgress, fileName) {\n        return Promise.resolve().then(() => {\n            this.onParsedObservable.notifyObservers(data);\n            this.onParsedObservable.clear();\n            this._log(`Loading ${fileName || \"\"}`);\n            this._loader = this._getLoader(data);\n            return this._loader.importMeshAsync(meshesNames, scene, null, data, rootUrl, onProgress, fileName);\n        });\n    }\n    /**\n     * @internal\n     */\n    loadAsync(scene, data, rootUrl, onProgress, fileName) {\n        return Promise.resolve().then(() => {\n            this.onParsedObservable.notifyObservers(data);\n            this.onParsedObservable.clear();\n            this._log(`Loading ${fileName || \"\"}`);\n            this._loader = this._getLoader(data);\n            return this._loader.loadAsync(scene, data, rootUrl, onProgress, fileName);\n        });\n    }\n    /**\n     * @internal\n     */\n    loadAssetContainerAsync(scene, data, rootUrl, onProgress, fileName) {\n        return Promise.resolve().then(() => {\n            this.onParsedObservable.notifyObservers(data);\n            this.onParsedObservable.clear();\n            this._log(`Loading ${fileName || \"\"}`);\n            this._loader = this._getLoader(data);\n            // Prepare the asset container.\n            const container = new AssetContainer(scene);\n            // Get materials/textures when loading to add to container\n            const materials = [];\n            this.onMaterialLoadedObservable.add((material) => {\n                materials.push(material);\n            });\n            const textures = [];\n            this.onTextureLoadedObservable.add((texture) => {\n                textures.push(texture);\n            });\n            const cameras = [];\n            this.onCameraLoadedObservable.add((camera) => {\n                cameras.push(camera);\n            });\n            return this._loader.importMeshAsync(null, scene, container, data, rootUrl, onProgress, fileName).then((result) => {\n                Array.prototype.push.apply(container.geometries, result.geometries);\n                Array.prototype.push.apply(container.meshes, result.meshes);\n                Array.prototype.push.apply(container.particleSystems, result.particleSystems);\n                Array.prototype.push.apply(container.skeletons, result.skeletons);\n                Array.prototype.push.apply(container.animationGroups, result.animationGroups);\n                Array.prototype.push.apply(container.materials, materials);\n                Array.prototype.push.apply(container.textures, textures);\n                Array.prototype.push.apply(container.lights, result.lights);\n                Array.prototype.push.apply(container.transformNodes, result.transformNodes);\n                Array.prototype.push.apply(container.cameras, cameras);\n                return container;\n            });\n        });\n    }\n    /**\n     * @internal\n     */\n    canDirectLoad(data) {\n        return ((data.indexOf(\"asset\") !== -1 && data.indexOf(\"version\") !== -1) ||\n            data.startsWith(\"data:base64,\" + GLTFFileLoader._MagicBase64Encoded) || // this is technically incorrect, but will continue to support for backcompat.\n            data.startsWith(\"data:;base64,\" + GLTFFileLoader._MagicBase64Encoded) ||\n            data.startsWith(\"data:application/octet-stream;base64,\" + GLTFFileLoader._MagicBase64Encoded) ||\n            data.startsWith(\"data:model/gltf-binary;base64,\" + GLTFFileLoader._MagicBase64Encoded));\n    }\n    /**\n     * @internal\n     */\n    directLoad(scene, data) {\n        if (data.startsWith(\"base64,\" + GLTFFileLoader._MagicBase64Encoded) || // this is technically incorrect, but will continue to support for backcompat.\n            data.startsWith(\";base64,\" + GLTFFileLoader._MagicBase64Encoded) ||\n            data.startsWith(\"application/octet-stream;base64,\" + GLTFFileLoader._MagicBase64Encoded) ||\n            data.startsWith(\"model/gltf-binary;base64,\" + GLTFFileLoader._MagicBase64Encoded)) {\n            const arrayBuffer = DecodeBase64UrlToBinary(data);\n            this._validate(scene, arrayBuffer);\n            return this._unpackBinaryAsync(new DataReader({\n                readAsync: (byteOffset, byteLength) => readAsync(arrayBuffer, byteOffset, byteLength),\n                byteLength: arrayBuffer.byteLength,\n            }));\n        }\n        this._validate(scene, data);\n        return Promise.resolve({ json: this._parseJson(data) });\n    }\n    /** @internal */\n    createPlugin() {\n        return new GLTFFileLoader();\n    }\n    /**\n     * The loader state or null if the loader is not active.\n     */\n    get loaderState() {\n        return this._state;\n    }\n    /**\n     * Returns a promise that resolves when the asset is completely loaded.\n     * @returns a promise that resolves when the asset is completely loaded.\n     */\n    whenCompleteAsync() {\n        return new Promise((resolve, reject) => {\n            this.onCompleteObservable.addOnce(() => {\n                resolve();\n            });\n            this.onErrorObservable.addOnce((reason) => {\n                reject(reason);\n            });\n        });\n    }\n    /**\n     * @internal\n     */\n    _setState(state) {\n        if (this._state === state) {\n            return;\n        }\n        this._state = state;\n        this.onLoaderStateChangedObservable.notifyObservers(this._state);\n        this._log(GLTFLoaderState[this._state]);\n    }\n    /**\n     * @internal\n     */\n    _loadFile(scene, fileOrUrl, onSuccess, useArrayBuffer, onError, onOpened) {\n        const request = scene._loadFile(fileOrUrl, onSuccess, (event) => {\n            this._onProgress(event, request);\n        }, true, useArrayBuffer, onError, onOpened);\n        request.onCompleteObservable.add((request) => {\n            this._requests.splice(this._requests.indexOf(request), 1);\n        });\n        this._requests.push(request);\n        return request;\n    }\n    _onProgress(event, request) {\n        if (!this._progressCallback) {\n            return;\n        }\n        request._lengthComputable = event.lengthComputable;\n        request._loaded = event.loaded;\n        request._total = event.total;\n        let lengthComputable = true;\n        let loaded = 0;\n        let total = 0;\n        for (const request of this._requests) {\n            if (request._lengthComputable === undefined || request._loaded === undefined || request._total === undefined) {\n                return;\n            }\n            lengthComputable = lengthComputable && request._lengthComputable;\n            loaded += request._loaded;\n            total += request._total;\n        }\n        this._progressCallback({\n            lengthComputable: lengthComputable,\n            loaded: loaded,\n            total: lengthComputable ? total : 0,\n        });\n    }\n    _validate(scene, data, rootUrl = \"\", fileName = \"\") {\n        if (!this.validate) {\n            return;\n        }\n        this._startPerformanceCounter(\"Validate JSON\");\n        GLTFValidation.ValidateAsync(data, rootUrl, fileName, (uri) => {\n            return this.preprocessUrlAsync(rootUrl + uri).then((url) => scene._loadFileAsync(url, undefined, true, true));\n        }).then((result) => {\n            this._endPerformanceCounter(\"Validate JSON\");\n            this.onValidatedObservable.notifyObservers(result);\n            this.onValidatedObservable.clear();\n        }, (reason) => {\n            this._endPerformanceCounter(\"Validate JSON\");\n            Tools.Warn(`Failed to validate: ${reason.message}`);\n            this.onValidatedObservable.clear();\n        });\n    }\n    _getLoader(loaderData) {\n        const asset = loaderData.json.asset || {};\n        this._log(`Asset version: ${asset.version}`);\n        asset.minVersion && this._log(`Asset minimum version: ${asset.minVersion}`);\n        asset.generator && this._log(`Asset generator: ${asset.generator}`);\n        const version = GLTFFileLoader._parseVersion(asset.version);\n        if (!version) {\n            throw new Error(\"Invalid version: \" + asset.version);\n        }\n        if (asset.minVersion !== undefined) {\n            const minVersion = GLTFFileLoader._parseVersion(asset.minVersion);\n            if (!minVersion) {\n                throw new Error(\"Invalid minimum version: \" + asset.minVersion);\n            }\n            if (GLTFFileLoader._compareVersion(minVersion, { major: 2, minor: 0 }) > 0) {\n                throw new Error(\"Incompatible minimum version: \" + asset.minVersion);\n            }\n        }\n        const createLoaders = {\n            1: GLTFFileLoader._CreateGLTF1Loader,\n            2: GLTFFileLoader._CreateGLTF2Loader,\n        };\n        const createLoader = createLoaders[version.major];\n        if (!createLoader) {\n            throw new Error(\"Unsupported version: \" + asset.version);\n        }\n        return createLoader(this);\n    }\n    _parseJson(json) {\n        this._startPerformanceCounter(\"Parse JSON\");\n        this._log(`JSON length: ${json.length}`);\n        const parsed = JSON.parse(json);\n        this._endPerformanceCounter(\"Parse JSON\");\n        return parsed;\n    }\n    _unpackBinaryAsync(dataReader) {\n        this._startPerformanceCounter(\"Unpack Binary\");\n        // Read magic + version + length + json length + json format\n        return dataReader.loadAsync(20).then(() => {\n            const Binary = {\n                Magic: 0x46546c67,\n            };\n            const magic = dataReader.readUint32();\n            if (magic !== Binary.Magic) {\n                throw new RuntimeError(\"Unexpected magic: \" + magic, ErrorCodes.GLTFLoaderUnexpectedMagicError);\n            }\n            const version = dataReader.readUint32();\n            if (this.loggingEnabled) {\n                this._log(`Binary version: ${version}`);\n            }\n            const length = dataReader.readUint32();\n            if (!this.useRangeRequests && length !== dataReader.buffer.byteLength) {\n                Logger.Warn(`Length in header does not match actual data length: ${length} != ${dataReader.buffer.byteLength}`);\n            }\n            let unpacked;\n            switch (version) {\n                case 1: {\n                    unpacked = this._unpackBinaryV1Async(dataReader, length);\n                    break;\n                }\n                case 2: {\n                    unpacked = this._unpackBinaryV2Async(dataReader, length);\n                    break;\n                }\n                default: {\n                    throw new Error(\"Unsupported version: \" + version);\n                }\n            }\n            this._endPerformanceCounter(\"Unpack Binary\");\n            return unpacked;\n        });\n    }\n    _unpackBinaryV1Async(dataReader, length) {\n        const ContentFormat = {\n            JSON: 0,\n        };\n        const contentLength = dataReader.readUint32();\n        const contentFormat = dataReader.readUint32();\n        if (contentFormat !== ContentFormat.JSON) {\n            throw new Error(`Unexpected content format: ${contentFormat}`);\n        }\n        const bodyLength = length - dataReader.byteOffset;\n        const data = { json: this._parseJson(dataReader.readString(contentLength)), bin: null };\n        if (bodyLength !== 0) {\n            const startByteOffset = dataReader.byteOffset;\n            data.bin = {\n                readAsync: (byteOffset, byteLength) => dataReader.buffer.readAsync(startByteOffset + byteOffset, byteLength),\n                byteLength: bodyLength,\n            };\n        }\n        return Promise.resolve(data);\n    }\n    _unpackBinaryV2Async(dataReader, length) {\n        const ChunkFormat = {\n            JSON: 0x4e4f534a,\n            BIN: 0x004e4942,\n        };\n        // Read the JSON chunk header.\n        const chunkLength = dataReader.readUint32();\n        const chunkFormat = dataReader.readUint32();\n        if (chunkFormat !== ChunkFormat.JSON) {\n            throw new Error(\"First chunk format is not JSON\");\n        }\n        // Bail if there are no other chunks.\n        if (dataReader.byteOffset + chunkLength === length) {\n            return dataReader.loadAsync(chunkLength).then(() => {\n                return { json: this._parseJson(dataReader.readString(chunkLength)), bin: null };\n            });\n        }\n        // Read the JSON chunk and the length and type of the next chunk.\n        return dataReader.loadAsync(chunkLength + 8).then(() => {\n            const data = { json: this._parseJson(dataReader.readString(chunkLength)), bin: null };\n            const readAsync = () => {\n                const chunkLength = dataReader.readUint32();\n                const chunkFormat = dataReader.readUint32();\n                switch (chunkFormat) {\n                    case ChunkFormat.JSON: {\n                        throw new Error(\"Unexpected JSON chunk\");\n                    }\n                    case ChunkFormat.BIN: {\n                        const startByteOffset = dataReader.byteOffset;\n                        data.bin = {\n                            readAsync: (byteOffset, byteLength) => dataReader.buffer.readAsync(startByteOffset + byteOffset, byteLength),\n                            byteLength: chunkLength,\n                        };\n                        dataReader.skipBytes(chunkLength);\n                        break;\n                    }\n                    default: {\n                        // ignore unrecognized chunkFormat\n                        dataReader.skipBytes(chunkLength);\n                        break;\n                    }\n                }\n                if (dataReader.byteOffset !== length) {\n                    return dataReader.loadAsync(8).then(readAsync);\n                }\n                return Promise.resolve(data);\n            };\n            return readAsync();\n        });\n    }\n    static _parseVersion(version) {\n        if (version === \"1.0\" || version === \"1.0.1\") {\n            return {\n                major: 1,\n                minor: 0,\n            };\n        }\n        const match = (version + \"\").match(/^(\\d+)\\.(\\d+)/);\n        if (!match) {\n            return null;\n        }\n        return {\n            major: parseInt(match[1]),\n            minor: parseInt(match[2]),\n        };\n    }\n    static _compareVersion(a, b) {\n        if (a.major > b.major) {\n            return 1;\n        }\n        if (a.major < b.major) {\n            return -1;\n        }\n        if (a.minor > b.minor) {\n            return 1;\n        }\n        if (a.minor < b.minor) {\n            return -1;\n        }\n        return 0;\n    }\n    /**\n     * @internal\n     */\n    _logOpen(message) {\n        this._log(message);\n        this._logIndentLevel++;\n    }\n    /** @internal */\n    _logClose() {\n        --this._logIndentLevel;\n    }\n    _logEnabled(message) {\n        const spaces = GLTFFileLoader._logSpaces.substr(0, this._logIndentLevel * 2);\n        Logger.Log(`${spaces}${message}`);\n    }\n    _logDisabled(message) { }\n    _startPerformanceCounterEnabled(counterName) {\n        Tools.StartPerformanceCounter(counterName);\n    }\n    _startPerformanceCounterDisabled(counterName) { }\n    _endPerformanceCounterEnabled(counterName) {\n        Tools.EndPerformanceCounter(counterName);\n    }\n    _endPerformanceCounterDisabled(counterName) { }\n}\n// ----------\n// V1 options\n// ----------\n/**\n * Set this property to false to disable incremental loading which delays the loader from calling the success callback until after loading the meshes and shaders.\n * Textures always loads asynchronously. For example, the success callback can compute the bounding information of the loaded meshes when incremental loading is disabled.\n * Defaults to true.\n * @internal\n */\nGLTFFileLoader.IncrementalLoading = true;\n/**\n * Set this property to true in order to work with homogeneous coordinates, available with some converters and exporters.\n * Defaults to false. See https://en.wikipedia.org/wiki/Homogeneous_coordinates.\n * @internal\n */\nGLTFFileLoader.HomogeneousCoordinates = false;\nGLTFFileLoader._MagicBase64Encoded = \"Z2xURg\"; // \"glTF\" base64 encoded (without the quotes!)\nGLTFFileLoader._logSpaces = \"                                \";\nif (SceneLoader) {\n    SceneLoader.RegisterPlugin(new GLTFFileLoader());\n}\n//# sourceMappingURL=glTFFileLoader.js.map","import { Tools } from \"@babylonjs/core/Misc/tools.js\";\nfunction validateAsync(data, rootUrl, fileName, getExternalResource) {\n    const options = {\n        externalResourceFunction: (uri) => getExternalResource(uri).then((value) => new Uint8Array(value)),\n    };\n    if (fileName) {\n        options.uri = rootUrl === \"file:\" ? fileName : rootUrl + fileName;\n    }\n    return data instanceof ArrayBuffer ? GLTFValidator.validateBytes(new Uint8Array(data), options) : GLTFValidator.validateString(data, options);\n}\n/**\n * The worker function that gets converted to a blob url to pass into a worker.\n */\nfunction workerFunc() {\n    const pendingExternalResources = [];\n    onmessage = (message) => {\n        const data = message.data;\n        switch (data.id) {\n            case \"init\": {\n                importScripts(data.url);\n                break;\n            }\n            case \"validate\": {\n                validateAsync(data.data, data.rootUrl, data.fileName, (uri) => new Promise((resolve, reject) => {\n                    const index = pendingExternalResources.length;\n                    pendingExternalResources.push({ resolve, reject });\n                    postMessage({ id: \"getExternalResource\", index: index, uri: uri });\n                })).then((value) => {\n                    postMessage({ id: \"validate.resolve\", value: value });\n                }, (reason) => {\n                    postMessage({ id: \"validate.reject\", reason: reason });\n                });\n                break;\n            }\n            case \"getExternalResource.resolve\": {\n                pendingExternalResources[data.index].resolve(data.value);\n                break;\n            }\n            case \"getExternalResource.reject\": {\n                pendingExternalResources[data.index].reject(data.reason);\n                break;\n            }\n        }\n    };\n}\n/**\n * glTF validation\n */\nexport class GLTFValidation {\n    /**\n     * Validate a glTF asset using the glTF-Validator.\n     * @param data The JSON of a glTF or the array buffer of a binary glTF\n     * @param rootUrl The root url for the glTF\n     * @param fileName The file name for the glTF\n     * @param getExternalResource The callback to get external resources for the glTF validator\n     * @returns A promise that resolves with the glTF validation results once complete\n     */\n    static ValidateAsync(data, rootUrl, fileName, getExternalResource) {\n        if (typeof Worker === \"function\") {\n            return new Promise((resolve, reject) => {\n                const workerContent = `${validateAsync}(${workerFunc})()`;\n                const workerBlobUrl = URL.createObjectURL(new Blob([workerContent], { type: \"application/javascript\" }));\n                const worker = new Worker(workerBlobUrl);\n                const onError = (error) => {\n                    worker.removeEventListener(\"error\", onError);\n                    worker.removeEventListener(\"message\", onMessage);\n                    reject(error);\n                };\n                const onMessage = (message) => {\n                    const data = message.data;\n                    switch (data.id) {\n                        case \"getExternalResource\": {\n                            getExternalResource(data.uri).then((value) => {\n                                worker.postMessage({ id: \"getExternalResource.resolve\", index: data.index, value: value }, [value]);\n                            }, (reason) => {\n                                worker.postMessage({ id: \"getExternalResource.reject\", index: data.index, reason: reason });\n                            });\n                            break;\n                        }\n                        case \"validate.resolve\": {\n                            worker.removeEventListener(\"error\", onError);\n                            worker.removeEventListener(\"message\", onMessage);\n                            resolve(data.value);\n                            worker.terminate();\n                            break;\n                        }\n                        case \"validate.reject\": {\n                            worker.removeEventListener(\"error\", onError);\n                            worker.removeEventListener(\"message\", onMessage);\n                            reject(data.reason);\n                            worker.terminate();\n                        }\n                    }\n                };\n                worker.addEventListener(\"error\", onError);\n                worker.addEventListener(\"message\", onMessage);\n                worker.postMessage({ id: \"init\", url: this.Configuration.url });\n                worker.postMessage({ id: \"validate\", data: data, rootUrl: rootUrl, fileName: fileName });\n            });\n        }\n        else {\n            if (!this._LoadScriptPromise) {\n                this._LoadScriptPromise = Tools.LoadScriptAsync(this.Configuration.url);\n            }\n            return this._LoadScriptPromise.then(() => {\n                return validateAsync(data, rootUrl, fileName, getExternalResource);\n            });\n        }\n    }\n}\n/**\n * The configuration. Defaults to `{ url: \"https://preview.babylonjs.com/gltf_validator.js\" }`.\n */\nGLTFValidation.Configuration = {\n    url: \"https://preview.babylonjs.com/gltf_validator.js\",\n};\n//# sourceMappingURL=glTFValidation.js.map","/**\n * Enums\n * @internal\n */\nexport var EComponentType;\n(function (EComponentType) {\n    EComponentType[EComponentType[\"BYTE\"] = 5120] = \"BYTE\";\n    EComponentType[EComponentType[\"UNSIGNED_BYTE\"] = 5121] = \"UNSIGNED_BYTE\";\n    EComponentType[EComponentType[\"SHORT\"] = 5122] = \"SHORT\";\n    EComponentType[EComponentType[\"UNSIGNED_SHORT\"] = 5123] = \"UNSIGNED_SHORT\";\n    EComponentType[EComponentType[\"FLOAT\"] = 5126] = \"FLOAT\";\n})(EComponentType || (EComponentType = {}));\n/** @internal */\nexport var EShaderType;\n(function (EShaderType) {\n    EShaderType[EShaderType[\"FRAGMENT\"] = 35632] = \"FRAGMENT\";\n    EShaderType[EShaderType[\"VERTEX\"] = 35633] = \"VERTEX\";\n})(EShaderType || (EShaderType = {}));\n/** @internal */\nexport var EParameterType;\n(function (EParameterType) {\n    EParameterType[EParameterType[\"BYTE\"] = 5120] = \"BYTE\";\n    EParameterType[EParameterType[\"UNSIGNED_BYTE\"] = 5121] = \"UNSIGNED_BYTE\";\n    EParameterType[EParameterType[\"SHORT\"] = 5122] = \"SHORT\";\n    EParameterType[EParameterType[\"UNSIGNED_SHORT\"] = 5123] = \"UNSIGNED_SHORT\";\n    EParameterType[EParameterType[\"INT\"] = 5124] = \"INT\";\n    EParameterType[EParameterType[\"UNSIGNED_INT\"] = 5125] = \"UNSIGNED_INT\";\n    EParameterType[EParameterType[\"FLOAT\"] = 5126] = \"FLOAT\";\n    EParameterType[EParameterType[\"FLOAT_VEC2\"] = 35664] = \"FLOAT_VEC2\";\n    EParameterType[EParameterType[\"FLOAT_VEC3\"] = 35665] = \"FLOAT_VEC3\";\n    EParameterType[EParameterType[\"FLOAT_VEC4\"] = 35666] = \"FLOAT_VEC4\";\n    EParameterType[EParameterType[\"INT_VEC2\"] = 35667] = \"INT_VEC2\";\n    EParameterType[EParameterType[\"INT_VEC3\"] = 35668] = \"INT_VEC3\";\n    EParameterType[EParameterType[\"INT_VEC4\"] = 35669] = \"INT_VEC4\";\n    EParameterType[EParameterType[\"BOOL\"] = 35670] = \"BOOL\";\n    EParameterType[EParameterType[\"BOOL_VEC2\"] = 35671] = \"BOOL_VEC2\";\n    EParameterType[EParameterType[\"BOOL_VEC3\"] = 35672] = \"BOOL_VEC3\";\n    EParameterType[EParameterType[\"BOOL_VEC4\"] = 35673] = \"BOOL_VEC4\";\n    EParameterType[EParameterType[\"FLOAT_MAT2\"] = 35674] = \"FLOAT_MAT2\";\n    EParameterType[EParameterType[\"FLOAT_MAT3\"] = 35675] = \"FLOAT_MAT3\";\n    EParameterType[EParameterType[\"FLOAT_MAT4\"] = 35676] = \"FLOAT_MAT4\";\n    EParameterType[EParameterType[\"SAMPLER_2D\"] = 35678] = \"SAMPLER_2D\";\n})(EParameterType || (EParameterType = {}));\n/** @internal */\nexport var ETextureWrapMode;\n(function (ETextureWrapMode) {\n    ETextureWrapMode[ETextureWrapMode[\"CLAMP_TO_EDGE\"] = 33071] = \"CLAMP_TO_EDGE\";\n    ETextureWrapMode[ETextureWrapMode[\"MIRRORED_REPEAT\"] = 33648] = \"MIRRORED_REPEAT\";\n    ETextureWrapMode[ETextureWrapMode[\"REPEAT\"] = 10497] = \"REPEAT\";\n})(ETextureWrapMode || (ETextureWrapMode = {}));\n/** @internal */\nexport var ETextureFilterType;\n(function (ETextureFilterType) {\n    ETextureFilterType[ETextureFilterType[\"NEAREST\"] = 9728] = \"NEAREST\";\n    ETextureFilterType[ETextureFilterType[\"LINEAR\"] = 9728] = \"LINEAR\";\n    ETextureFilterType[ETextureFilterType[\"NEAREST_MIPMAP_NEAREST\"] = 9984] = \"NEAREST_MIPMAP_NEAREST\";\n    ETextureFilterType[ETextureFilterType[\"LINEAR_MIPMAP_NEAREST\"] = 9985] = \"LINEAR_MIPMAP_NEAREST\";\n    ETextureFilterType[ETextureFilterType[\"NEAREST_MIPMAP_LINEAR\"] = 9986] = \"NEAREST_MIPMAP_LINEAR\";\n    ETextureFilterType[ETextureFilterType[\"LINEAR_MIPMAP_LINEAR\"] = 9987] = \"LINEAR_MIPMAP_LINEAR\";\n})(ETextureFilterType || (ETextureFilterType = {}));\n/** @internal */\nexport var ETextureFormat;\n(function (ETextureFormat) {\n    ETextureFormat[ETextureFormat[\"ALPHA\"] = 6406] = \"ALPHA\";\n    ETextureFormat[ETextureFormat[\"RGB\"] = 6407] = \"RGB\";\n    ETextureFormat[ETextureFormat[\"RGBA\"] = 6408] = \"RGBA\";\n    ETextureFormat[ETextureFormat[\"LUMINANCE\"] = 6409] = \"LUMINANCE\";\n    ETextureFormat[ETextureFormat[\"LUMINANCE_ALPHA\"] = 6410] = \"LUMINANCE_ALPHA\";\n})(ETextureFormat || (ETextureFormat = {}));\n/** @internal */\nexport var ECullingType;\n(function (ECullingType) {\n    ECullingType[ECullingType[\"FRONT\"] = 1028] = \"FRONT\";\n    ECullingType[ECullingType[\"BACK\"] = 1029] = \"BACK\";\n    ECullingType[ECullingType[\"FRONT_AND_BACK\"] = 1032] = \"FRONT_AND_BACK\";\n})(ECullingType || (ECullingType = {}));\n/** @internal */\nexport var EBlendingFunction;\n(function (EBlendingFunction) {\n    EBlendingFunction[EBlendingFunction[\"ZERO\"] = 0] = \"ZERO\";\n    EBlendingFunction[EBlendingFunction[\"ONE\"] = 1] = \"ONE\";\n    EBlendingFunction[EBlendingFunction[\"SRC_COLOR\"] = 768] = \"SRC_COLOR\";\n    EBlendingFunction[EBlendingFunction[\"ONE_MINUS_SRC_COLOR\"] = 769] = \"ONE_MINUS_SRC_COLOR\";\n    EBlendingFunction[EBlendingFunction[\"DST_COLOR\"] = 774] = \"DST_COLOR\";\n    EBlendingFunction[EBlendingFunction[\"ONE_MINUS_DST_COLOR\"] = 775] = \"ONE_MINUS_DST_COLOR\";\n    EBlendingFunction[EBlendingFunction[\"SRC_ALPHA\"] = 770] = \"SRC_ALPHA\";\n    EBlendingFunction[EBlendingFunction[\"ONE_MINUS_SRC_ALPHA\"] = 771] = \"ONE_MINUS_SRC_ALPHA\";\n    EBlendingFunction[EBlendingFunction[\"DST_ALPHA\"] = 772] = \"DST_ALPHA\";\n    EBlendingFunction[EBlendingFunction[\"ONE_MINUS_DST_ALPHA\"] = 773] = \"ONE_MINUS_DST_ALPHA\";\n    EBlendingFunction[EBlendingFunction[\"CONSTANT_COLOR\"] = 32769] = \"CONSTANT_COLOR\";\n    EBlendingFunction[EBlendingFunction[\"ONE_MINUS_CONSTANT_COLOR\"] = 32770] = \"ONE_MINUS_CONSTANT_COLOR\";\n    EBlendingFunction[EBlendingFunction[\"CONSTANT_ALPHA\"] = 32771] = \"CONSTANT_ALPHA\";\n    EBlendingFunction[EBlendingFunction[\"ONE_MINUS_CONSTANT_ALPHA\"] = 32772] = \"ONE_MINUS_CONSTANT_ALPHA\";\n    EBlendingFunction[EBlendingFunction[\"SRC_ALPHA_SATURATE\"] = 776] = \"SRC_ALPHA_SATURATE\";\n})(EBlendingFunction || (EBlendingFunction = {}));\n//# sourceMappingURL=glTFLoaderInterfaces.js.map","import { EParameterType, ETextureWrapMode, ETextureFilterType, EComponentType } from \"./glTFLoaderInterfaces.js\";\nimport { Vector2, Vector3, Vector4, Matrix } from \"@babylonjs/core/Maths/math.vector.js\";\nimport { Color4 } from \"@babylonjs/core/Maths/math.color.js\";\nimport { Effect } from \"@babylonjs/core/Materials/effect.js\";\nimport { ShaderMaterial } from \"@babylonjs/core/Materials/shaderMaterial.js\";\nimport { Texture } from \"@babylonjs/core/Materials/Textures/texture.js\";\n/**\n * Utils functions for GLTF\n * @internal\n * @deprecated\n */\nexport class GLTFUtils {\n    /**\n     * Sets the given \"parameter\" matrix\n     * @param scene the Scene object\n     * @param source the source node where to pick the matrix\n     * @param parameter the GLTF technique parameter\n     * @param uniformName the name of the shader's uniform\n     * @param shaderMaterial the shader material\n     */\n    static SetMatrix(scene, source, parameter, uniformName, shaderMaterial) {\n        let mat = null;\n        if (parameter.semantic === \"MODEL\") {\n            mat = source.getWorldMatrix();\n        }\n        else if (parameter.semantic === \"PROJECTION\") {\n            mat = scene.getProjectionMatrix();\n        }\n        else if (parameter.semantic === \"VIEW\") {\n            mat = scene.getViewMatrix();\n        }\n        else if (parameter.semantic === \"MODELVIEWINVERSETRANSPOSE\") {\n            mat = Matrix.Transpose(source.getWorldMatrix().multiply(scene.getViewMatrix()).invert());\n        }\n        else if (parameter.semantic === \"MODELVIEW\") {\n            mat = source.getWorldMatrix().multiply(scene.getViewMatrix());\n        }\n        else if (parameter.semantic === \"MODELVIEWPROJECTION\") {\n            mat = source.getWorldMatrix().multiply(scene.getTransformMatrix());\n        }\n        else if (parameter.semantic === \"MODELINVERSE\") {\n            mat = source.getWorldMatrix().invert();\n        }\n        else if (parameter.semantic === \"VIEWINVERSE\") {\n            mat = scene.getViewMatrix().invert();\n        }\n        else if (parameter.semantic === \"PROJECTIONINVERSE\") {\n            mat = scene.getProjectionMatrix().invert();\n        }\n        else if (parameter.semantic === \"MODELVIEWINVERSE\") {\n            mat = source.getWorldMatrix().multiply(scene.getViewMatrix()).invert();\n        }\n        else if (parameter.semantic === \"MODELVIEWPROJECTIONINVERSE\") {\n            mat = source.getWorldMatrix().multiply(scene.getTransformMatrix()).invert();\n        }\n        else if (parameter.semantic === \"MODELINVERSETRANSPOSE\") {\n            mat = Matrix.Transpose(source.getWorldMatrix().invert());\n        }\n        if (mat) {\n            switch (parameter.type) {\n                case EParameterType.FLOAT_MAT2:\n                    shaderMaterial.setMatrix2x2(uniformName, Matrix.GetAsMatrix2x2(mat));\n                    break;\n                case EParameterType.FLOAT_MAT3:\n                    shaderMaterial.setMatrix3x3(uniformName, Matrix.GetAsMatrix3x3(mat));\n                    break;\n                case EParameterType.FLOAT_MAT4:\n                    shaderMaterial.setMatrix(uniformName, mat);\n                    break;\n                default:\n                    break;\n            }\n        }\n    }\n    /**\n     * Sets the given \"parameter\" matrix\n     * @param shaderMaterial the shader material\n     * @param uniform the name of the shader's uniform\n     * @param value the value of the uniform\n     * @param type the uniform's type (EParameterType FLOAT, VEC2, VEC3 or VEC4)\n     */\n    static SetUniform(shaderMaterial, uniform, value, type) {\n        switch (type) {\n            case EParameterType.FLOAT:\n                shaderMaterial.setFloat(uniform, value);\n                return true;\n            case EParameterType.FLOAT_VEC2:\n                shaderMaterial.setVector2(uniform, Vector2.FromArray(value));\n                return true;\n            case EParameterType.FLOAT_VEC3:\n                shaderMaterial.setVector3(uniform, Vector3.FromArray(value));\n                return true;\n            case EParameterType.FLOAT_VEC4:\n                shaderMaterial.setVector4(uniform, Vector4.FromArray(value));\n                return true;\n            default:\n                return false;\n        }\n    }\n    /**\n     * Returns the wrap mode of the texture\n     * @param mode the mode value\n     */\n    static GetWrapMode(mode) {\n        switch (mode) {\n            case ETextureWrapMode.CLAMP_TO_EDGE:\n                return Texture.CLAMP_ADDRESSMODE;\n            case ETextureWrapMode.MIRRORED_REPEAT:\n                return Texture.MIRROR_ADDRESSMODE;\n            case ETextureWrapMode.REPEAT:\n                return Texture.WRAP_ADDRESSMODE;\n            default:\n                return Texture.WRAP_ADDRESSMODE;\n        }\n    }\n    /**\n     * Returns the byte stride giving an accessor\n     * @param accessor the GLTF accessor objet\n     */\n    static GetByteStrideFromType(accessor) {\n        // Needs this function since \"byteStride\" isn't requiered in glTF format\n        const type = accessor.type;\n        switch (type) {\n            case \"VEC2\":\n                return 2;\n            case \"VEC3\":\n                return 3;\n            case \"VEC4\":\n                return 4;\n            case \"MAT2\":\n                return 4;\n            case \"MAT3\":\n                return 9;\n            case \"MAT4\":\n                return 16;\n            default:\n                return 1;\n        }\n    }\n    /**\n     * Returns the texture filter mode giving a mode value\n     * @param mode the filter mode value\n     */\n    static GetTextureFilterMode(mode) {\n        switch (mode) {\n            case ETextureFilterType.LINEAR:\n            case ETextureFilterType.LINEAR_MIPMAP_NEAREST:\n            case ETextureFilterType.LINEAR_MIPMAP_LINEAR:\n                return Texture.TRILINEAR_SAMPLINGMODE;\n            case ETextureFilterType.NEAREST:\n            case ETextureFilterType.NEAREST_MIPMAP_NEAREST:\n                return Texture.NEAREST_SAMPLINGMODE;\n            default:\n                return Texture.BILINEAR_SAMPLINGMODE;\n        }\n    }\n    static GetBufferFromBufferView(gltfRuntime, bufferView, byteOffset, byteLength, componentType) {\n        byteOffset = bufferView.byteOffset + byteOffset;\n        const loadedBufferView = gltfRuntime.loadedBufferViews[bufferView.buffer];\n        if (byteOffset + byteLength > loadedBufferView.byteLength) {\n            throw new Error(\"Buffer access is out of range\");\n        }\n        const buffer = loadedBufferView.buffer;\n        byteOffset += loadedBufferView.byteOffset;\n        switch (componentType) {\n            case EComponentType.BYTE:\n                return new Int8Array(buffer, byteOffset, byteLength);\n            case EComponentType.UNSIGNED_BYTE:\n                return new Uint8Array(buffer, byteOffset, byteLength);\n            case EComponentType.SHORT:\n                return new Int16Array(buffer, byteOffset, byteLength);\n            case EComponentType.UNSIGNED_SHORT:\n                return new Uint16Array(buffer, byteOffset, byteLength);\n            default:\n                return new Float32Array(buffer, byteOffset, byteLength);\n        }\n    }\n    /**\n     * Returns a buffer from its accessor\n     * @param gltfRuntime the GLTF runtime\n     * @param accessor the GLTF accessor\n     */\n    static GetBufferFromAccessor(gltfRuntime, accessor) {\n        const bufferView = gltfRuntime.bufferViews[accessor.bufferView];\n        const byteLength = accessor.count * GLTFUtils.GetByteStrideFromType(accessor);\n        return GLTFUtils.GetBufferFromBufferView(gltfRuntime, bufferView, accessor.byteOffset, byteLength, accessor.componentType);\n    }\n    /**\n     * Decodes a buffer view into a string\n     * @param view the buffer view\n     */\n    static DecodeBufferToText(view) {\n        let result = \"\";\n        const length = view.byteLength;\n        for (let i = 0; i < length; ++i) {\n            result += String.fromCharCode(view[i]);\n        }\n        return result;\n    }\n    /**\n     * Returns the default material of gltf. Related to\n     * https://github.com/KhronosGroup/glTF/tree/master/specification/1.0#appendix-a-default-material\n     * @param scene the Babylon.js scene\n     */\n    static GetDefaultMaterial(scene) {\n        if (!GLTFUtils._DefaultMaterial) {\n            Effect.ShadersStore[\"GLTFDefaultMaterialVertexShader\"] = [\n                \"precision highp float;\",\n                \"\",\n                \"uniform mat4 worldView;\",\n                \"uniform mat4 projection;\",\n                \"\",\n                \"attribute vec3 position;\",\n                \"\",\n                \"void main(void)\",\n                \"{\",\n                \"    gl_Position = projection * worldView * vec4(position, 1.0);\",\n                \"}\",\n            ].join(\"\\n\");\n            Effect.ShadersStore[\"GLTFDefaultMaterialPixelShader\"] = [\n                \"precision highp float;\",\n                \"\",\n                \"uniform vec4 u_emission;\",\n                \"\",\n                \"void main(void)\",\n                \"{\",\n                \"    gl_FragColor = u_emission;\",\n                \"}\",\n            ].join(\"\\n\");\n            const shaderPath = {\n                vertex: \"GLTFDefaultMaterial\",\n                fragment: \"GLTFDefaultMaterial\",\n            };\n            const options = {\n                attributes: [\"position\"],\n                uniforms: [\"worldView\", \"projection\", \"u_emission\"],\n                samplers: new Array(),\n                needAlphaBlending: false,\n            };\n            GLTFUtils._DefaultMaterial = new ShaderMaterial(\"GLTFDefaultMaterial\", scene, shaderPath, options);\n            GLTFUtils._DefaultMaterial.setColor4(\"u_emission\", new Color4(0.5, 0.5, 0.5, 1.0));\n        }\n        return GLTFUtils._DefaultMaterial;\n    }\n}\n// The GLTF default material\nGLTFUtils._DefaultMaterial = null;\n//# sourceMappingURL=glTFLoaderUtils.js.map","import { EParameterType, ETextureFilterType, ECullingType, EBlendingFunction, EShaderType } from \"./glTFLoaderInterfaces.js\";\nimport { Quaternion, Vector3, Matrix } from \"@babylonjs/core/Maths/math.vector.js\";\nimport { Color3 } from \"@babylonjs/core/Maths/math.color.js\";\nimport { Tools } from \"@babylonjs/core/Misc/tools.js\";\nimport { Camera } from \"@babylonjs/core/Cameras/camera.js\";\nimport { FreeCamera } from \"@babylonjs/core/Cameras/freeCamera.js\";\nimport { Animation } from \"@babylonjs/core/Animations/animation.js\";\nimport { Bone } from \"@babylonjs/core/Bones/bone.js\";\nimport { Skeleton } from \"@babylonjs/core/Bones/skeleton.js\";\nimport { Effect } from \"@babylonjs/core/Materials/effect.js\";\nimport { Material } from \"@babylonjs/core/Materials/material.js\";\nimport { MultiMaterial } from \"@babylonjs/core/Materials/multiMaterial.js\";\nimport { StandardMaterial } from \"@babylonjs/core/Materials/standardMaterial.js\";\nimport { ShaderMaterial } from \"@babylonjs/core/Materials/shaderMaterial.js\";\nimport { Texture } from \"@babylonjs/core/Materials/Textures/texture.js\";\nimport { VertexData } from \"@babylonjs/core/Meshes/mesh.vertexData.js\";\nimport { VertexBuffer } from \"@babylonjs/core/Buffers/buffer.js\";\nimport { Geometry } from \"@babylonjs/core/Meshes/geometry.js\";\nimport { SubMesh } from \"@babylonjs/core/Meshes/subMesh.js\";\nimport { AbstractMesh } from \"@babylonjs/core/Meshes/abstractMesh.js\";\nimport { Mesh } from \"@babylonjs/core/Meshes/mesh.js\";\nimport { HemisphericLight } from \"@babylonjs/core/Lights/hemisphericLight.js\";\nimport { DirectionalLight } from \"@babylonjs/core/Lights/directionalLight.js\";\nimport { PointLight } from \"@babylonjs/core/Lights/pointLight.js\";\nimport { SpotLight } from \"@babylonjs/core/Lights/spotLight.js\";\nimport { GLTFUtils } from \"./glTFLoaderUtils.js\";\nimport { GLTFFileLoader } from \"../glTFFileLoader.js\";\nimport { Constants } from \"@babylonjs/core/Engines/constants.js\";\n/**\n * Tokenizer. Used for shaders compatibility\n * Automatically map world, view, projection, worldViewProjection, attributes and so on\n */\nvar ETokenType;\n(function (ETokenType) {\n    ETokenType[ETokenType[\"IDENTIFIER\"] = 1] = \"IDENTIFIER\";\n    ETokenType[ETokenType[\"UNKNOWN\"] = 2] = \"UNKNOWN\";\n    ETokenType[ETokenType[\"END_OF_INPUT\"] = 3] = \"END_OF_INPUT\";\n})(ETokenType || (ETokenType = {}));\nclass Tokenizer {\n    constructor(toParse) {\n        this._pos = 0;\n        this.currentToken = ETokenType.UNKNOWN;\n        this.currentIdentifier = \"\";\n        this.currentString = \"\";\n        this.isLetterOrDigitPattern = /^[a-zA-Z0-9]+$/;\n        this._toParse = toParse;\n        this._maxPos = toParse.length;\n    }\n    getNextToken() {\n        if (this.isEnd()) {\n            return ETokenType.END_OF_INPUT;\n        }\n        this.currentString = this.read();\n        this.currentToken = ETokenType.UNKNOWN;\n        if (this.currentString === \"_\" || this.isLetterOrDigitPattern.test(this.currentString)) {\n            this.currentToken = ETokenType.IDENTIFIER;\n            this.currentIdentifier = this.currentString;\n            while (!this.isEnd() && (this.isLetterOrDigitPattern.test((this.currentString = this.peek())) || this.currentString === \"_\")) {\n                this.currentIdentifier += this.currentString;\n                this.forward();\n            }\n        }\n        return this.currentToken;\n    }\n    peek() {\n        return this._toParse[this._pos];\n    }\n    read() {\n        return this._toParse[this._pos++];\n    }\n    forward() {\n        this._pos++;\n    }\n    isEnd() {\n        return this._pos >= this._maxPos;\n    }\n}\n/**\n * Values\n */\nconst glTFTransforms = [\"MODEL\", \"VIEW\", \"PROJECTION\", \"MODELVIEW\", \"MODELVIEWPROJECTION\", \"JOINTMATRIX\"];\nconst babylonTransforms = [\"world\", \"view\", \"projection\", \"worldView\", \"worldViewProjection\", \"mBones\"];\nconst glTFAnimationPaths = [\"translation\", \"rotation\", \"scale\"];\nconst babylonAnimationPaths = [\"position\", \"rotationQuaternion\", \"scaling\"];\n/**\n * Parse\n * @param parsedBuffers\n * @param gltfRuntime\n */\nconst parseBuffers = (parsedBuffers, gltfRuntime) => {\n    for (const buf in parsedBuffers) {\n        const parsedBuffer = parsedBuffers[buf];\n        gltfRuntime.buffers[buf] = parsedBuffer;\n        gltfRuntime.buffersCount++;\n    }\n};\nconst parseShaders = (parsedShaders, gltfRuntime) => {\n    for (const sha in parsedShaders) {\n        const parsedShader = parsedShaders[sha];\n        gltfRuntime.shaders[sha] = parsedShader;\n        gltfRuntime.shaderscount++;\n    }\n};\nconst parseObject = (parsedObjects, runtimeProperty, gltfRuntime) => {\n    for (const object in parsedObjects) {\n        const parsedObject = parsedObjects[object];\n        gltfRuntime[runtimeProperty][object] = parsedObject;\n    }\n};\n/**\n * Utils\n * @param buffer\n */\nconst normalizeUVs = (buffer) => {\n    if (!buffer) {\n        return;\n    }\n    for (let i = 0; i < buffer.length / 2; i++) {\n        buffer[i * 2 + 1] = 1.0 - buffer[i * 2 + 1];\n    }\n};\nconst getAttribute = (attributeParameter) => {\n    if (attributeParameter.semantic === \"NORMAL\") {\n        return \"normal\";\n    }\n    else if (attributeParameter.semantic === \"POSITION\") {\n        return \"position\";\n    }\n    else if (attributeParameter.semantic === \"JOINT\") {\n        return \"matricesIndices\";\n    }\n    else if (attributeParameter.semantic === \"WEIGHT\") {\n        return \"matricesWeights\";\n    }\n    else if (attributeParameter.semantic === \"COLOR\") {\n        return \"color\";\n    }\n    else if (attributeParameter.semantic && attributeParameter.semantic.indexOf(\"TEXCOORD_\") !== -1) {\n        const channel = Number(attributeParameter.semantic.split(\"_\")[1]);\n        return \"uv\" + (channel === 0 ? \"\" : channel + 1);\n    }\n    return null;\n};\n/**\n * Loads and creates animations\n * @param gltfRuntime\n */\nconst loadAnimations = (gltfRuntime) => {\n    for (const anim in gltfRuntime.animations) {\n        const animation = gltfRuntime.animations[anim];\n        if (!animation.channels || !animation.samplers) {\n            continue;\n        }\n        let lastAnimation = null;\n        for (let i = 0; i < animation.channels.length; i++) {\n            // Get parameters and load buffers\n            const channel = animation.channels[i];\n            const sampler = animation.samplers[channel.sampler];\n            if (!sampler) {\n                continue;\n            }\n            let inputData = null;\n            let outputData = null;\n            if (animation.parameters) {\n                inputData = animation.parameters[sampler.input];\n                outputData = animation.parameters[sampler.output];\n            }\n            else {\n                inputData = sampler.input;\n                outputData = sampler.output;\n            }\n            const bufferInput = GLTFUtils.GetBufferFromAccessor(gltfRuntime, gltfRuntime.accessors[inputData]);\n            const bufferOutput = GLTFUtils.GetBufferFromAccessor(gltfRuntime, gltfRuntime.accessors[outputData]);\n            const targetId = channel.target.id;\n            let targetNode = gltfRuntime.scene.getNodeById(targetId);\n            if (targetNode === null) {\n                targetNode = gltfRuntime.scene.getNodeByName(targetId);\n            }\n            if (targetNode === null) {\n                Tools.Warn(\"Creating animation named \" + anim + \". But cannot find node named \" + targetId + \" to attach to\");\n                continue;\n            }\n            const isBone = targetNode instanceof Bone;\n            // Get target path (position, rotation or scaling)\n            let targetPath = channel.target.path;\n            const targetPathIndex = glTFAnimationPaths.indexOf(targetPath);\n            if (targetPathIndex !== -1) {\n                targetPath = babylonAnimationPaths[targetPathIndex];\n            }\n            // Determine animation type\n            let animationType = Animation.ANIMATIONTYPE_MATRIX;\n            if (!isBone) {\n                if (targetPath === \"rotationQuaternion\") {\n                    animationType = Animation.ANIMATIONTYPE_QUATERNION;\n                    targetNode.rotationQuaternion = new Quaternion();\n                }\n                else {\n                    animationType = Animation.ANIMATIONTYPE_VECTOR3;\n                }\n            }\n            // Create animation and key frames\n            let babylonAnimation = null;\n            const keys = [];\n            let arrayOffset = 0;\n            let modifyKey = false;\n            if (isBone && lastAnimation && lastAnimation.getKeys().length === bufferInput.length) {\n                babylonAnimation = lastAnimation;\n                modifyKey = true;\n            }\n            if (!modifyKey) {\n                gltfRuntime.scene._blockEntityCollection = !!gltfRuntime.assetContainer;\n                babylonAnimation = new Animation(anim, isBone ? \"_matrix\" : targetPath, 1, animationType, Animation.ANIMATIONLOOPMODE_CYCLE);\n                gltfRuntime.scene._blockEntityCollection = false;\n            }\n            // For each frame\n            for (let j = 0; j < bufferInput.length; j++) {\n                let value = null;\n                if (targetPath === \"rotationQuaternion\") {\n                    // VEC4\n                    value = Quaternion.FromArray([bufferOutput[arrayOffset], bufferOutput[arrayOffset + 1], bufferOutput[arrayOffset + 2], bufferOutput[arrayOffset + 3]]);\n                    arrayOffset += 4;\n                }\n                else {\n                    // Position and scaling are VEC3\n                    value = Vector3.FromArray([bufferOutput[arrayOffset], bufferOutput[arrayOffset + 1], bufferOutput[arrayOffset + 2]]);\n                    arrayOffset += 3;\n                }\n                if (isBone) {\n                    const bone = targetNode;\n                    let translation = Vector3.Zero();\n                    let rotationQuaternion = new Quaternion();\n                    let scaling = Vector3.Zero();\n                    // Warning on decompose\n                    let mat = bone.getBaseMatrix();\n                    if (modifyKey && lastAnimation) {\n                        mat = lastAnimation.getKeys()[j].value;\n                    }\n                    mat.decompose(scaling, rotationQuaternion, translation);\n                    if (targetPath === \"position\") {\n                        translation = value;\n                    }\n                    else if (targetPath === \"rotationQuaternion\") {\n                        rotationQuaternion = value;\n                    }\n                    else {\n                        scaling = value;\n                    }\n                    value = Matrix.Compose(scaling, rotationQuaternion, translation);\n                }\n                if (!modifyKey) {\n                    keys.push({\n                        frame: bufferInput[j],\n                        value: value,\n                    });\n                }\n                else if (lastAnimation) {\n                    lastAnimation.getKeys()[j].value = value;\n                }\n            }\n            // Finish\n            if (!modifyKey && babylonAnimation) {\n                babylonAnimation.setKeys(keys);\n                targetNode.animations.push(babylonAnimation);\n            }\n            lastAnimation = babylonAnimation;\n            gltfRuntime.scene.stopAnimation(targetNode);\n            gltfRuntime.scene.beginAnimation(targetNode, 0, bufferInput[bufferInput.length - 1], true, 1.0);\n        }\n    }\n};\n/**\n * Returns the bones transformation matrix\n * @param node\n */\nconst configureBoneTransformation = (node) => {\n    let mat = null;\n    if (node.translation || node.rotation || node.scale) {\n        const scale = Vector3.FromArray(node.scale || [1, 1, 1]);\n        const rotation = Quaternion.FromArray(node.rotation || [0, 0, 0, 1]);\n        const position = Vector3.FromArray(node.translation || [0, 0, 0]);\n        mat = Matrix.Compose(scale, rotation, position);\n    }\n    else {\n        mat = Matrix.FromArray(node.matrix);\n    }\n    return mat;\n};\n/**\n * Returns the parent bone\n * @param gltfRuntime\n * @param skins\n * @param jointName\n * @param newSkeleton\n */\nconst getParentBone = (gltfRuntime, skins, jointName, newSkeleton) => {\n    // Try to find\n    for (let i = 0; i < newSkeleton.bones.length; i++) {\n        if (newSkeleton.bones[i].name === jointName) {\n            return newSkeleton.bones[i];\n        }\n    }\n    // Not found, search in gltf nodes\n    const nodes = gltfRuntime.nodes;\n    for (const nde in nodes) {\n        const node = nodes[nde];\n        if (!node.jointName) {\n            continue;\n        }\n        const children = node.children;\n        for (let i = 0; i < children.length; i++) {\n            const child = gltfRuntime.nodes[children[i]];\n            if (!child.jointName) {\n                continue;\n            }\n            if (child.jointName === jointName) {\n                const mat = configureBoneTransformation(node);\n                const bone = new Bone(node.name || \"\", newSkeleton, getParentBone(gltfRuntime, skins, node.jointName, newSkeleton), mat);\n                bone.id = nde;\n                return bone;\n            }\n        }\n    }\n    return null;\n};\n/**\n * Returns the appropriate root node\n * @param nodesToRoot\n * @param id\n */\nconst getNodeToRoot = (nodesToRoot, id) => {\n    for (let i = 0; i < nodesToRoot.length; i++) {\n        const nodeToRoot = nodesToRoot[i];\n        for (let j = 0; j < nodeToRoot.node.children.length; j++) {\n            const child = nodeToRoot.node.children[j];\n            if (child === id) {\n                return nodeToRoot.bone;\n            }\n        }\n    }\n    return null;\n};\n/**\n * Returns the node with the joint name\n * @param gltfRuntime\n * @param jointName\n */\nconst getJointNode = (gltfRuntime, jointName) => {\n    const nodes = gltfRuntime.nodes;\n    let node = nodes[jointName];\n    if (node) {\n        return {\n            node: node,\n            id: jointName,\n        };\n    }\n    for (const nde in nodes) {\n        node = nodes[nde];\n        if (node.jointName === jointName) {\n            return {\n                node: node,\n                id: nde,\n            };\n        }\n    }\n    return null;\n};\n/**\n * Checks if a nodes is in joints\n * @param skins\n * @param id\n */\nconst nodeIsInJoints = (skins, id) => {\n    for (let i = 0; i < skins.jointNames.length; i++) {\n        if (skins.jointNames[i] === id) {\n            return true;\n        }\n    }\n    return false;\n};\n/**\n * Fills the nodes to root for bones and builds hierarchy\n * @param gltfRuntime\n * @param newSkeleton\n * @param skins\n * @param nodesToRoot\n */\nconst getNodesToRoot = (gltfRuntime, newSkeleton, skins, nodesToRoot) => {\n    // Creates nodes for root\n    for (const nde in gltfRuntime.nodes) {\n        const node = gltfRuntime.nodes[nde];\n        const id = nde;\n        if (!node.jointName || nodeIsInJoints(skins, node.jointName)) {\n            continue;\n        }\n        // Create node to root bone\n        const mat = configureBoneTransformation(node);\n        const bone = new Bone(node.name || \"\", newSkeleton, null, mat);\n        bone.id = id;\n        nodesToRoot.push({ bone: bone, node: node, id: id });\n    }\n    // Parenting\n    for (let i = 0; i < nodesToRoot.length; i++) {\n        const nodeToRoot = nodesToRoot[i];\n        const children = nodeToRoot.node.children;\n        for (let j = 0; j < children.length; j++) {\n            let child = null;\n            for (let k = 0; k < nodesToRoot.length; k++) {\n                if (nodesToRoot[k].id === children[j]) {\n                    child = nodesToRoot[k];\n                    break;\n                }\n            }\n            if (child) {\n                child.bone._parent = nodeToRoot.bone;\n                nodeToRoot.bone.children.push(child.bone);\n            }\n        }\n    }\n};\n/**\n * Imports a skeleton\n * @param gltfRuntime\n * @param skins\n * @param mesh\n * @param newSkeleton\n */\nconst importSkeleton = (gltfRuntime, skins, mesh, newSkeleton) => {\n    if (!newSkeleton) {\n        newSkeleton = new Skeleton(skins.name || \"\", \"\", gltfRuntime.scene);\n    }\n    if (!skins.babylonSkeleton) {\n        return newSkeleton;\n    }\n    // Find the root bones\n    const nodesToRoot = [];\n    const nodesToRootToAdd = [];\n    getNodesToRoot(gltfRuntime, newSkeleton, skins, nodesToRoot);\n    newSkeleton.bones = [];\n    // Joints\n    for (let i = 0; i < skins.jointNames.length; i++) {\n        const jointNode = getJointNode(gltfRuntime, skins.jointNames[i]);\n        if (!jointNode) {\n            continue;\n        }\n        const node = jointNode.node;\n        if (!node) {\n            Tools.Warn(\"Joint named \" + skins.jointNames[i] + \" does not exist\");\n            continue;\n        }\n        const id = jointNode.id;\n        // Optimize, if the bone already exists...\n        const existingBone = gltfRuntime.scene.getBoneById(id);\n        if (existingBone) {\n            newSkeleton.bones.push(existingBone);\n            continue;\n        }\n        // Search for parent bone\n        let foundBone = false;\n        let parentBone = null;\n        for (let j = 0; j < i; j++) {\n            const jointNode = getJointNode(gltfRuntime, skins.jointNames[j]);\n            if (!jointNode) {\n                continue;\n            }\n            const joint = jointNode.node;\n            if (!joint) {\n                Tools.Warn(\"Joint named \" + skins.jointNames[j] + \" does not exist when looking for parent\");\n                continue;\n            }\n            const children = joint.children;\n            if (!children) {\n                continue;\n            }\n            foundBone = false;\n            for (let k = 0; k < children.length; k++) {\n                if (children[k] === id) {\n                    parentBone = getParentBone(gltfRuntime, skins, skins.jointNames[j], newSkeleton);\n                    foundBone = true;\n                    break;\n                }\n            }\n            if (foundBone) {\n                break;\n            }\n        }\n        // Create bone\n        const mat = configureBoneTransformation(node);\n        if (!parentBone && nodesToRoot.length > 0) {\n            parentBone = getNodeToRoot(nodesToRoot, id);\n            if (parentBone) {\n                if (nodesToRootToAdd.indexOf(parentBone) === -1) {\n                    nodesToRootToAdd.push(parentBone);\n                }\n            }\n        }\n        const bone = new Bone(node.jointName || \"\", newSkeleton, parentBone, mat);\n        bone.id = id;\n    }\n    // Polish\n    const bones = newSkeleton.bones;\n    newSkeleton.bones = [];\n    for (let i = 0; i < skins.jointNames.length; i++) {\n        const jointNode = getJointNode(gltfRuntime, skins.jointNames[i]);\n        if (!jointNode) {\n            continue;\n        }\n        for (let j = 0; j < bones.length; j++) {\n            if (bones[j].id === jointNode.id) {\n                newSkeleton.bones.push(bones[j]);\n                break;\n            }\n        }\n    }\n    newSkeleton.prepare();\n    // Finish\n    for (let i = 0; i < nodesToRootToAdd.length; i++) {\n        newSkeleton.bones.push(nodesToRootToAdd[i]);\n    }\n    return newSkeleton;\n};\n/**\n * Imports a mesh and its geometries\n * @param gltfRuntime\n * @param node\n * @param meshes\n * @param id\n * @param newMesh\n */\nconst importMesh = (gltfRuntime, node, meshes, id, newMesh) => {\n    if (!newMesh) {\n        gltfRuntime.scene._blockEntityCollection = !!gltfRuntime.assetContainer;\n        newMesh = new Mesh(node.name || \"\", gltfRuntime.scene);\n        newMesh._parentContainer = gltfRuntime.assetContainer;\n        gltfRuntime.scene._blockEntityCollection = false;\n        newMesh.id = id;\n    }\n    if (!node.babylonNode) {\n        return newMesh;\n    }\n    const subMaterials = [];\n    let vertexData = null;\n    const verticesStarts = new Array();\n    const verticesCounts = new Array();\n    const indexStarts = new Array();\n    const indexCounts = new Array();\n    for (let meshIndex = 0; meshIndex < meshes.length; meshIndex++) {\n        const meshId = meshes[meshIndex];\n        const mesh = gltfRuntime.meshes[meshId];\n        if (!mesh) {\n            continue;\n        }\n        // Positions, normals and UVs\n        for (let i = 0; i < mesh.primitives.length; i++) {\n            // Temporary vertex data\n            const tempVertexData = new VertexData();\n            const primitive = mesh.primitives[i];\n            if (primitive.mode !== 4) {\n                // continue;\n            }\n            const attributes = primitive.attributes;\n            let accessor = null;\n            let buffer = null;\n            // Set positions, normal and uvs\n            for (const semantic in attributes) {\n                // Link accessor and buffer view\n                accessor = gltfRuntime.accessors[attributes[semantic]];\n                buffer = GLTFUtils.GetBufferFromAccessor(gltfRuntime, accessor);\n                if (semantic === \"NORMAL\") {\n                    tempVertexData.normals = new Float32Array(buffer.length);\n                    tempVertexData.normals.set(buffer);\n                }\n                else if (semantic === \"POSITION\") {\n                    if (GLTFFileLoader.HomogeneousCoordinates) {\n                        tempVertexData.positions = new Float32Array(buffer.length - buffer.length / 4);\n                        for (let j = 0; j < buffer.length; j += 4) {\n                            tempVertexData.positions[j] = buffer[j];\n                            tempVertexData.positions[j + 1] = buffer[j + 1];\n                            tempVertexData.positions[j + 2] = buffer[j + 2];\n                        }\n                    }\n                    else {\n                        tempVertexData.positions = new Float32Array(buffer.length);\n                        tempVertexData.positions.set(buffer);\n                    }\n                    verticesCounts.push(tempVertexData.positions.length);\n                }\n                else if (semantic.indexOf(\"TEXCOORD_\") !== -1) {\n                    const channel = Number(semantic.split(\"_\")[1]);\n                    const uvKind = VertexBuffer.UVKind + (channel === 0 ? \"\" : channel + 1);\n                    const uvs = new Float32Array(buffer.length);\n                    uvs.set(buffer);\n                    normalizeUVs(uvs);\n                    tempVertexData.set(uvs, uvKind);\n                }\n                else if (semantic === \"JOINT\") {\n                    tempVertexData.matricesIndices = new Float32Array(buffer.length);\n                    tempVertexData.matricesIndices.set(buffer);\n                }\n                else if (semantic === \"WEIGHT\") {\n                    tempVertexData.matricesWeights = new Float32Array(buffer.length);\n                    tempVertexData.matricesWeights.set(buffer);\n                }\n                else if (semantic === \"COLOR\") {\n                    tempVertexData.colors = new Float32Array(buffer.length);\n                    tempVertexData.colors.set(buffer);\n                }\n            }\n            // Indices\n            accessor = gltfRuntime.accessors[primitive.indices];\n            if (accessor) {\n                buffer = GLTFUtils.GetBufferFromAccessor(gltfRuntime, accessor);\n                tempVertexData.indices = new Int32Array(buffer.length);\n                tempVertexData.indices.set(buffer);\n                indexCounts.push(tempVertexData.indices.length);\n            }\n            else {\n                // Set indices on the fly\n                const indices = [];\n                for (let j = 0; j < tempVertexData.positions.length / 3; j++) {\n                    indices.push(j);\n                }\n                tempVertexData.indices = new Int32Array(indices);\n                indexCounts.push(tempVertexData.indices.length);\n            }\n            if (!vertexData) {\n                vertexData = tempVertexData;\n            }\n            else {\n                vertexData.merge(tempVertexData);\n            }\n            // Sub material\n            const material = gltfRuntime.scene.getMaterialById(primitive.material);\n            subMaterials.push(material === null ? GLTFUtils.GetDefaultMaterial(gltfRuntime.scene) : material);\n            // Update vertices start and index start\n            verticesStarts.push(verticesStarts.length === 0 ? 0 : verticesStarts[verticesStarts.length - 1] + verticesCounts[verticesCounts.length - 2]);\n            indexStarts.push(indexStarts.length === 0 ? 0 : indexStarts[indexStarts.length - 1] + indexCounts[indexCounts.length - 2]);\n        }\n    }\n    let material;\n    gltfRuntime.scene._blockEntityCollection = !!gltfRuntime.assetContainer;\n    if (subMaterials.length > 1) {\n        material = new MultiMaterial(\"multimat\" + id, gltfRuntime.scene);\n        material.subMaterials = subMaterials;\n    }\n    else {\n        material = new StandardMaterial(\"multimat\" + id, gltfRuntime.scene);\n    }\n    if (subMaterials.length === 1) {\n        material = subMaterials[0];\n    }\n    material._parentContainer = gltfRuntime.assetContainer;\n    if (!newMesh.material) {\n        newMesh.material = material;\n    }\n    // Apply geometry\n    new Geometry(id, gltfRuntime.scene, vertexData, false, newMesh);\n    newMesh.computeWorldMatrix(true);\n    gltfRuntime.scene._blockEntityCollection = false;\n    // Apply submeshes\n    newMesh.subMeshes = [];\n    let index = 0;\n    for (let meshIndex = 0; meshIndex < meshes.length; meshIndex++) {\n        const meshId = meshes[meshIndex];\n        const mesh = gltfRuntime.meshes[meshId];\n        if (!mesh) {\n            continue;\n        }\n        for (let i = 0; i < mesh.primitives.length; i++) {\n            if (mesh.primitives[i].mode !== 4) {\n                //continue;\n            }\n            SubMesh.AddToMesh(index, verticesStarts[index], verticesCounts[index], indexStarts[index], indexCounts[index], newMesh, newMesh, true);\n            index++;\n        }\n    }\n    // Finish\n    return newMesh;\n};\n/**\n * Configure node transformation from position, rotation and scaling\n * @param newNode\n * @param position\n * @param rotation\n * @param scaling\n */\nconst configureNode = (newNode, position, rotation, scaling) => {\n    if (newNode.position) {\n        newNode.position = position;\n    }\n    if (newNode.rotationQuaternion || newNode.rotation) {\n        newNode.rotationQuaternion = rotation;\n    }\n    if (newNode.scaling) {\n        newNode.scaling = scaling;\n    }\n};\n/**\n * Configures node from transformation matrix\n * @param newNode\n * @param node\n */\nconst configureNodeFromMatrix = (newNode, node) => {\n    if (node.matrix) {\n        const position = new Vector3(0, 0, 0);\n        const rotation = new Quaternion();\n        const scaling = new Vector3(0, 0, 0);\n        const mat = Matrix.FromArray(node.matrix);\n        mat.decompose(scaling, rotation, position);\n        configureNode(newNode, position, rotation, scaling);\n    }\n    else if (node.translation && node.rotation && node.scale) {\n        configureNode(newNode, Vector3.FromArray(node.translation), Quaternion.FromArray(node.rotation), Vector3.FromArray(node.scale));\n    }\n    newNode.computeWorldMatrix(true);\n};\n/**\n * Imports a node\n * @param gltfRuntime\n * @param node\n * @param id\n */\nconst importNode = (gltfRuntime, node, id) => {\n    let lastNode = null;\n    if (gltfRuntime.importOnlyMeshes && (node.skin || node.meshes)) {\n        if (gltfRuntime.importMeshesNames && gltfRuntime.importMeshesNames.length > 0 && gltfRuntime.importMeshesNames.indexOf(node.name || \"\") === -1) {\n            return null;\n        }\n    }\n    // Meshes\n    if (node.skin) {\n        if (node.meshes) {\n            const skin = gltfRuntime.skins[node.skin];\n            const newMesh = importMesh(gltfRuntime, node, node.meshes, id, node.babylonNode);\n            newMesh.skeleton = gltfRuntime.scene.getLastSkeletonById(node.skin);\n            if (newMesh.skeleton === null) {\n                newMesh.skeleton = importSkeleton(gltfRuntime, skin, newMesh, skin.babylonSkeleton);\n                if (!skin.babylonSkeleton) {\n                    skin.babylonSkeleton = newMesh.skeleton;\n                }\n            }\n            lastNode = newMesh;\n        }\n    }\n    else if (node.meshes) {\n        /**\n         * Improve meshes property\n         */\n        const newMesh = importMesh(gltfRuntime, node, node.mesh ? [node.mesh] : node.meshes, id, node.babylonNode);\n        lastNode = newMesh;\n    }\n    // Lights\n    else if (node.light && !node.babylonNode && !gltfRuntime.importOnlyMeshes) {\n        const light = gltfRuntime.lights[node.light];\n        if (light) {\n            if (light.type === \"ambient\") {\n                const ambienLight = light[light.type];\n                const hemiLight = new HemisphericLight(node.light, Vector3.Zero(), gltfRuntime.scene);\n                hemiLight.name = node.name || \"\";\n                if (ambienLight.color) {\n                    hemiLight.diffuse = Color3.FromArray(ambienLight.color);\n                }\n                lastNode = hemiLight;\n            }\n            else if (light.type === \"directional\") {\n                const directionalLight = light[light.type];\n                const dirLight = new DirectionalLight(node.light, Vector3.Zero(), gltfRuntime.scene);\n                dirLight.name = node.name || \"\";\n                if (directionalLight.color) {\n                    dirLight.diffuse = Color3.FromArray(directionalLight.color);\n                }\n                lastNode = dirLight;\n            }\n            else if (light.type === \"point\") {\n                const pointLight = light[light.type];\n                const ptLight = new PointLight(node.light, Vector3.Zero(), gltfRuntime.scene);\n                ptLight.name = node.name || \"\";\n                if (pointLight.color) {\n                    ptLight.diffuse = Color3.FromArray(pointLight.color);\n                }\n                lastNode = ptLight;\n            }\n            else if (light.type === \"spot\") {\n                const spotLight = light[light.type];\n                const spLight = new SpotLight(node.light, Vector3.Zero(), Vector3.Zero(), 0, 0, gltfRuntime.scene);\n                spLight.name = node.name || \"\";\n                if (spotLight.color) {\n                    spLight.diffuse = Color3.FromArray(spotLight.color);\n                }\n                if (spotLight.fallOfAngle) {\n                    spLight.angle = spotLight.fallOfAngle;\n                }\n                if (spotLight.fallOffExponent) {\n                    spLight.exponent = spotLight.fallOffExponent;\n                }\n                lastNode = spLight;\n            }\n        }\n    }\n    // Cameras\n    else if (node.camera && !node.babylonNode && !gltfRuntime.importOnlyMeshes) {\n        const camera = gltfRuntime.cameras[node.camera];\n        if (camera) {\n            gltfRuntime.scene._blockEntityCollection = !!gltfRuntime.assetContainer;\n            if (camera.type === \"orthographic\") {\n                const orthoCamera = new FreeCamera(node.camera, Vector3.Zero(), gltfRuntime.scene, false);\n                orthoCamera.name = node.name || \"\";\n                orthoCamera.mode = Camera.ORTHOGRAPHIC_CAMERA;\n                orthoCamera.attachControl();\n                lastNode = orthoCamera;\n                orthoCamera._parentContainer = gltfRuntime.assetContainer;\n            }\n            else if (camera.type === \"perspective\") {\n                const perspectiveCamera = camera[camera.type];\n                const persCamera = new FreeCamera(node.camera, Vector3.Zero(), gltfRuntime.scene, false);\n                persCamera.name = node.name || \"\";\n                persCamera.attachControl();\n                if (!perspectiveCamera.aspectRatio) {\n                    perspectiveCamera.aspectRatio = gltfRuntime.scene.getEngine().getRenderWidth() / gltfRuntime.scene.getEngine().getRenderHeight();\n                }\n                if (perspectiveCamera.znear && perspectiveCamera.zfar) {\n                    persCamera.maxZ = perspectiveCamera.zfar;\n                    persCamera.minZ = perspectiveCamera.znear;\n                }\n                lastNode = persCamera;\n                persCamera._parentContainer = gltfRuntime.assetContainer;\n            }\n            gltfRuntime.scene._blockEntityCollection = false;\n        }\n    }\n    // Empty node\n    if (!node.jointName) {\n        if (node.babylonNode) {\n            return node.babylonNode;\n        }\n        else if (lastNode === null) {\n            gltfRuntime.scene._blockEntityCollection = !!gltfRuntime.assetContainer;\n            const dummy = new Mesh(node.name || \"\", gltfRuntime.scene);\n            dummy._parentContainer = gltfRuntime.assetContainer;\n            gltfRuntime.scene._blockEntityCollection = false;\n            node.babylonNode = dummy;\n            lastNode = dummy;\n        }\n    }\n    if (lastNode !== null) {\n        if (node.matrix && lastNode instanceof Mesh) {\n            configureNodeFromMatrix(lastNode, node);\n        }\n        else {\n            const translation = node.translation || [0, 0, 0];\n            const rotation = node.rotation || [0, 0, 0, 1];\n            const scale = node.scale || [1, 1, 1];\n            configureNode(lastNode, Vector3.FromArray(translation), Quaternion.FromArray(rotation), Vector3.FromArray(scale));\n        }\n        lastNode.updateCache(true);\n        node.babylonNode = lastNode;\n    }\n    return lastNode;\n};\n/**\n * Traverses nodes and creates them\n * @param gltfRuntime\n * @param id\n * @param parent\n * @param meshIncluded\n */\nconst traverseNodes = (gltfRuntime, id, parent, meshIncluded = false) => {\n    const node = gltfRuntime.nodes[id];\n    let newNode = null;\n    if (gltfRuntime.importOnlyMeshes && !meshIncluded && gltfRuntime.importMeshesNames) {\n        if (gltfRuntime.importMeshesNames.indexOf(node.name || \"\") !== -1 || gltfRuntime.importMeshesNames.length === 0) {\n            meshIncluded = true;\n        }\n        else {\n            meshIncluded = false;\n        }\n    }\n    else {\n        meshIncluded = true;\n    }\n    if (!node.jointName && meshIncluded) {\n        newNode = importNode(gltfRuntime, node, id);\n        if (newNode !== null) {\n            newNode.id = id;\n            newNode.parent = parent;\n        }\n    }\n    if (node.children) {\n        for (let i = 0; i < node.children.length; i++) {\n            traverseNodes(gltfRuntime, node.children[i], newNode, meshIncluded);\n        }\n    }\n};\n/**\n * do stuff after buffers, shaders are loaded (e.g. hook up materials, load animations, etc.)\n * @param gltfRuntime\n */\nconst postLoad = (gltfRuntime) => {\n    // Nodes\n    let currentScene = gltfRuntime.currentScene;\n    if (currentScene) {\n        for (let i = 0; i < currentScene.nodes.length; i++) {\n            traverseNodes(gltfRuntime, currentScene.nodes[i], null);\n        }\n    }\n    else {\n        for (const thing in gltfRuntime.scenes) {\n            currentScene = gltfRuntime.scenes[thing];\n            for (let i = 0; i < currentScene.nodes.length; i++) {\n                traverseNodes(gltfRuntime, currentScene.nodes[i], null);\n            }\n        }\n    }\n    // Set animations\n    loadAnimations(gltfRuntime);\n    for (let i = 0; i < gltfRuntime.scene.skeletons.length; i++) {\n        const skeleton = gltfRuntime.scene.skeletons[i];\n        gltfRuntime.scene.beginAnimation(skeleton, 0, Number.MAX_VALUE, true, 1.0);\n    }\n};\n/**\n * onBind shaderrs callback to set uniforms and matrices\n * @param mesh\n * @param gltfRuntime\n * @param unTreatedUniforms\n * @param shaderMaterial\n * @param technique\n * @param material\n * @param onSuccess\n */\nconst onBindShaderMaterial = (mesh, gltfRuntime, unTreatedUniforms, shaderMaterial, technique, material, onSuccess) => {\n    const materialValues = material.values || technique.parameters;\n    for (const unif in unTreatedUniforms) {\n        const uniform = unTreatedUniforms[unif];\n        const type = uniform.type;\n        if (type === EParameterType.FLOAT_MAT2 || type === EParameterType.FLOAT_MAT3 || type === EParameterType.FLOAT_MAT4) {\n            if (uniform.semantic && !uniform.source && !uniform.node) {\n                GLTFUtils.SetMatrix(gltfRuntime.scene, mesh, uniform, unif, shaderMaterial.getEffect());\n            }\n            else if (uniform.semantic && (uniform.source || uniform.node)) {\n                let source = gltfRuntime.scene.getNodeByName(uniform.source || uniform.node || \"\");\n                if (source === null) {\n                    source = gltfRuntime.scene.getNodeById(uniform.source || uniform.node || \"\");\n                }\n                if (source === null) {\n                    continue;\n                }\n                GLTFUtils.SetMatrix(gltfRuntime.scene, source, uniform, unif, shaderMaterial.getEffect());\n            }\n        }\n        else {\n            const value = materialValues[technique.uniforms[unif]];\n            if (!value) {\n                continue;\n            }\n            if (type === EParameterType.SAMPLER_2D) {\n                const texture = gltfRuntime.textures[material.values ? value : uniform.value].babylonTexture;\n                if (texture === null || texture === undefined) {\n                    continue;\n                }\n                shaderMaterial.getEffect().setTexture(unif, texture);\n            }\n            else {\n                GLTFUtils.SetUniform(shaderMaterial.getEffect(), unif, value, type);\n            }\n        }\n    }\n    onSuccess(shaderMaterial);\n};\n/**\n * Prepare uniforms to send the only one time\n * Loads the appropriate textures\n * @param gltfRuntime\n * @param shaderMaterial\n * @param technique\n * @param material\n */\nconst prepareShaderMaterialUniforms = (gltfRuntime, shaderMaterial, technique, material, unTreatedUniforms) => {\n    const materialValues = material.values || technique.parameters;\n    const techniqueUniforms = technique.uniforms;\n    /**\n     * Prepare values here (not matrices)\n     */\n    for (const unif in unTreatedUniforms) {\n        const uniform = unTreatedUniforms[unif];\n        const type = uniform.type;\n        let value = materialValues[techniqueUniforms[unif]];\n        if (value === undefined) {\n            // In case the value is the same for all materials\n            value = uniform.value;\n        }\n        if (!value) {\n            continue;\n        }\n        const onLoadTexture = (uniformName) => {\n            return (texture) => {\n                if (uniform.value && uniformName) {\n                    // Static uniform\n                    shaderMaterial.setTexture(uniformName, texture);\n                    delete unTreatedUniforms[uniformName];\n                }\n            };\n        };\n        // Texture (sampler2D)\n        if (type === EParameterType.SAMPLER_2D) {\n            GLTFLoaderExtension.LoadTextureAsync(gltfRuntime, material.values ? value : uniform.value, onLoadTexture(unif), () => onLoadTexture(null));\n        }\n        // Others\n        else {\n            if (uniform.value && GLTFUtils.SetUniform(shaderMaterial, unif, material.values ? value : uniform.value, type)) {\n                // Static uniform\n                delete unTreatedUniforms[unif];\n            }\n        }\n    }\n};\n/**\n * Shader compilation failed\n * @param program\n * @param shaderMaterial\n * @param onError\n */\nconst onShaderCompileError = (program, shaderMaterial, onError) => {\n    return (effect, error) => {\n        shaderMaterial.dispose(true);\n        onError(\"Cannot compile program named \" + program.name + \". Error: \" + error + \". Default material will be applied\");\n    };\n};\n/**\n * Shader compilation success\n * @param gltfRuntime\n * @param shaderMaterial\n * @param technique\n * @param material\n * @param unTreatedUniforms\n * @param onSuccess\n */\nconst onShaderCompileSuccess = (gltfRuntime, shaderMaterial, technique, material, unTreatedUniforms, onSuccess) => {\n    return (_) => {\n        prepareShaderMaterialUniforms(gltfRuntime, shaderMaterial, technique, material, unTreatedUniforms);\n        shaderMaterial.onBind = (mesh) => {\n            onBindShaderMaterial(mesh, gltfRuntime, unTreatedUniforms, shaderMaterial, technique, material, onSuccess);\n        };\n    };\n};\n/**\n * Returns the appropriate uniform if already handled by babylon\n * @param tokenizer\n * @param technique\n */\nconst parseShaderUniforms = (tokenizer, technique, unTreatedUniforms) => {\n    for (const unif in technique.uniforms) {\n        const uniform = technique.uniforms[unif];\n        const uniformParameter = technique.parameters[uniform];\n        if (tokenizer.currentIdentifier === unif) {\n            if (uniformParameter.semantic && !uniformParameter.source && !uniformParameter.node) {\n                const transformIndex = glTFTransforms.indexOf(uniformParameter.semantic);\n                if (transformIndex !== -1) {\n                    delete unTreatedUniforms[unif];\n                    return babylonTransforms[transformIndex];\n                }\n            }\n        }\n    }\n    return tokenizer.currentIdentifier;\n};\n/**\n * All shaders loaded. Create materials one by one\n * @param gltfRuntime\n */\nconst importMaterials = (gltfRuntime) => {\n    // Create materials\n    for (const mat in gltfRuntime.materials) {\n        GLTFLoaderExtension.LoadMaterialAsync(gltfRuntime, mat, () => { }, () => { });\n    }\n};\n/**\n * Implementation of the base glTF spec\n * @internal\n */\nexport class GLTFLoaderBase {\n    static CreateRuntime(parsedData, scene, rootUrl) {\n        const gltfRuntime = {\n            extensions: {},\n            accessors: {},\n            buffers: {},\n            bufferViews: {},\n            meshes: {},\n            lights: {},\n            cameras: {},\n            nodes: {},\n            images: {},\n            textures: {},\n            shaders: {},\n            programs: {},\n            samplers: {},\n            techniques: {},\n            materials: {},\n            animations: {},\n            skins: {},\n            extensionsUsed: [],\n            scenes: {},\n            buffersCount: 0,\n            shaderscount: 0,\n            scene: scene,\n            rootUrl: rootUrl,\n            loadedBufferCount: 0,\n            loadedBufferViews: {},\n            loadedShaderCount: 0,\n            importOnlyMeshes: false,\n            dummyNodes: [],\n            assetContainer: null,\n        };\n        // Parse\n        if (parsedData.extensions) {\n            parseObject(parsedData.extensions, \"extensions\", gltfRuntime);\n        }\n        if (parsedData.extensionsUsed) {\n            parseObject(parsedData.extensionsUsed, \"extensionsUsed\", gltfRuntime);\n        }\n        if (parsedData.buffers) {\n            parseBuffers(parsedData.buffers, gltfRuntime);\n        }\n        if (parsedData.bufferViews) {\n            parseObject(parsedData.bufferViews, \"bufferViews\", gltfRuntime);\n        }\n        if (parsedData.accessors) {\n            parseObject(parsedData.accessors, \"accessors\", gltfRuntime);\n        }\n        if (parsedData.meshes) {\n            parseObject(parsedData.meshes, \"meshes\", gltfRuntime);\n        }\n        if (parsedData.lights) {\n            parseObject(parsedData.lights, \"lights\", gltfRuntime);\n        }\n        if (parsedData.cameras) {\n            parseObject(parsedData.cameras, \"cameras\", gltfRuntime);\n        }\n        if (parsedData.nodes) {\n            parseObject(parsedData.nodes, \"nodes\", gltfRuntime);\n        }\n        if (parsedData.images) {\n            parseObject(parsedData.images, \"images\", gltfRuntime);\n        }\n        if (parsedData.textures) {\n            parseObject(parsedData.textures, \"textures\", gltfRuntime);\n        }\n        if (parsedData.shaders) {\n            parseShaders(parsedData.shaders, gltfRuntime);\n        }\n        if (parsedData.programs) {\n            parseObject(parsedData.programs, \"programs\", gltfRuntime);\n        }\n        if (parsedData.samplers) {\n            parseObject(parsedData.samplers, \"samplers\", gltfRuntime);\n        }\n        if (parsedData.techniques) {\n            parseObject(parsedData.techniques, \"techniques\", gltfRuntime);\n        }\n        if (parsedData.materials) {\n            parseObject(parsedData.materials, \"materials\", gltfRuntime);\n        }\n        if (parsedData.animations) {\n            parseObject(parsedData.animations, \"animations\", gltfRuntime);\n        }\n        if (parsedData.skins) {\n            parseObject(parsedData.skins, \"skins\", gltfRuntime);\n        }\n        if (parsedData.scenes) {\n            gltfRuntime.scenes = parsedData.scenes;\n        }\n        if (parsedData.scene && parsedData.scenes) {\n            gltfRuntime.currentScene = parsedData.scenes[parsedData.scene];\n        }\n        return gltfRuntime;\n    }\n    static LoadBufferAsync(gltfRuntime, id, onSuccess, onError, onProgress) {\n        const buffer = gltfRuntime.buffers[id];\n        if (Tools.IsBase64(buffer.uri)) {\n            setTimeout(() => onSuccess(new Uint8Array(Tools.DecodeBase64(buffer.uri))));\n        }\n        else {\n            Tools.LoadFile(gltfRuntime.rootUrl + buffer.uri, (data) => onSuccess(new Uint8Array(data)), onProgress, undefined, true, (request) => {\n                if (request) {\n                    onError(request.status + \" \" + request.statusText);\n                }\n            });\n        }\n    }\n    static LoadTextureBufferAsync(gltfRuntime, id, onSuccess, onError) {\n        const texture = gltfRuntime.textures[id];\n        if (!texture || !texture.source) {\n            onError(\"\");\n            return;\n        }\n        if (texture.babylonTexture) {\n            onSuccess(null);\n            return;\n        }\n        const source = gltfRuntime.images[texture.source];\n        if (Tools.IsBase64(source.uri)) {\n            setTimeout(() => onSuccess(new Uint8Array(Tools.DecodeBase64(source.uri))));\n        }\n        else {\n            Tools.LoadFile(gltfRuntime.rootUrl + source.uri, (data) => onSuccess(new Uint8Array(data)), undefined, undefined, true, (request) => {\n                if (request) {\n                    onError(request.status + \" \" + request.statusText);\n                }\n            });\n        }\n    }\n    static CreateTextureAsync(gltfRuntime, id, buffer, onSuccess) {\n        const texture = gltfRuntime.textures[id];\n        if (texture.babylonTexture) {\n            onSuccess(texture.babylonTexture);\n            return;\n        }\n        const sampler = gltfRuntime.samplers[texture.sampler];\n        const createMipMaps = sampler.minFilter === ETextureFilterType.NEAREST_MIPMAP_NEAREST ||\n            sampler.minFilter === ETextureFilterType.NEAREST_MIPMAP_LINEAR ||\n            sampler.minFilter === ETextureFilterType.LINEAR_MIPMAP_NEAREST ||\n            sampler.minFilter === ETextureFilterType.LINEAR_MIPMAP_LINEAR;\n        const samplingMode = Texture.BILINEAR_SAMPLINGMODE;\n        const blob = buffer == null ? new Blob() : new Blob([buffer]);\n        const blobURL = URL.createObjectURL(blob);\n        const revokeBlobURL = () => URL.revokeObjectURL(blobURL);\n        const newTexture = new Texture(blobURL, gltfRuntime.scene, !createMipMaps, true, samplingMode, revokeBlobURL, revokeBlobURL);\n        if (sampler.wrapS !== undefined) {\n            newTexture.wrapU = GLTFUtils.GetWrapMode(sampler.wrapS);\n        }\n        if (sampler.wrapT !== undefined) {\n            newTexture.wrapV = GLTFUtils.GetWrapMode(sampler.wrapT);\n        }\n        newTexture.name = id;\n        texture.babylonTexture = newTexture;\n        onSuccess(newTexture);\n    }\n    static LoadShaderStringAsync(gltfRuntime, id, onSuccess, onError) {\n        const shader = gltfRuntime.shaders[id];\n        if (Tools.IsBase64(shader.uri)) {\n            const shaderString = atob(shader.uri.split(\",\")[1]);\n            if (onSuccess) {\n                onSuccess(shaderString);\n            }\n        }\n        else {\n            Tools.LoadFile(gltfRuntime.rootUrl + shader.uri, onSuccess, undefined, undefined, false, (request) => {\n                if (request && onError) {\n                    onError(request.status + \" \" + request.statusText);\n                }\n            });\n        }\n    }\n    static LoadMaterialAsync(gltfRuntime, id, onSuccess, onError) {\n        const material = gltfRuntime.materials[id];\n        if (!material.technique) {\n            if (onError) {\n                onError(\"No technique found.\");\n            }\n            return;\n        }\n        const technique = gltfRuntime.techniques[material.technique];\n        if (!technique) {\n            gltfRuntime.scene._blockEntityCollection = !!gltfRuntime.assetContainer;\n            const defaultMaterial = new StandardMaterial(id, gltfRuntime.scene);\n            defaultMaterial._parentContainer = gltfRuntime.assetContainer;\n            gltfRuntime.scene._blockEntityCollection = false;\n            defaultMaterial.diffuseColor = new Color3(0.5, 0.5, 0.5);\n            defaultMaterial.sideOrientation = Material.CounterClockWiseSideOrientation;\n            onSuccess(defaultMaterial);\n            return;\n        }\n        const program = gltfRuntime.programs[technique.program];\n        const states = technique.states;\n        const vertexShader = Effect.ShadersStore[program.vertexShader + \"VertexShader\"];\n        const pixelShader = Effect.ShadersStore[program.fragmentShader + \"PixelShader\"];\n        let newVertexShader = \"\";\n        let newPixelShader = \"\";\n        const vertexTokenizer = new Tokenizer(vertexShader);\n        const pixelTokenizer = new Tokenizer(pixelShader);\n        const unTreatedUniforms = {};\n        const uniforms = [];\n        const attributes = [];\n        const samplers = [];\n        // Fill uniform, sampler2D and attributes\n        for (const unif in technique.uniforms) {\n            const uniform = technique.uniforms[unif];\n            const uniformParameter = technique.parameters[uniform];\n            unTreatedUniforms[unif] = uniformParameter;\n            if (uniformParameter.semantic && !uniformParameter.node && !uniformParameter.source) {\n                const transformIndex = glTFTransforms.indexOf(uniformParameter.semantic);\n                if (transformIndex !== -1) {\n                    uniforms.push(babylonTransforms[transformIndex]);\n                    delete unTreatedUniforms[unif];\n                }\n                else {\n                    uniforms.push(unif);\n                }\n            }\n            else if (uniformParameter.type === EParameterType.SAMPLER_2D) {\n                samplers.push(unif);\n            }\n            else {\n                uniforms.push(unif);\n            }\n        }\n        for (const attr in technique.attributes) {\n            const attribute = technique.attributes[attr];\n            const attributeParameter = technique.parameters[attribute];\n            if (attributeParameter.semantic) {\n                const name = getAttribute(attributeParameter);\n                if (name) {\n                    attributes.push(name);\n                }\n            }\n        }\n        // Configure vertex shader\n        while (!vertexTokenizer.isEnd() && vertexTokenizer.getNextToken()) {\n            const tokenType = vertexTokenizer.currentToken;\n            if (tokenType !== ETokenType.IDENTIFIER) {\n                newVertexShader += vertexTokenizer.currentString;\n                continue;\n            }\n            let foundAttribute = false;\n            for (const attr in technique.attributes) {\n                const attribute = technique.attributes[attr];\n                const attributeParameter = technique.parameters[attribute];\n                if (vertexTokenizer.currentIdentifier === attr && attributeParameter.semantic) {\n                    newVertexShader += getAttribute(attributeParameter);\n                    foundAttribute = true;\n                    break;\n                }\n            }\n            if (foundAttribute) {\n                continue;\n            }\n            newVertexShader += parseShaderUniforms(vertexTokenizer, technique, unTreatedUniforms);\n        }\n        // Configure pixel shader\n        while (!pixelTokenizer.isEnd() && pixelTokenizer.getNextToken()) {\n            const tokenType = pixelTokenizer.currentToken;\n            if (tokenType !== ETokenType.IDENTIFIER) {\n                newPixelShader += pixelTokenizer.currentString;\n                continue;\n            }\n            newPixelShader += parseShaderUniforms(pixelTokenizer, technique, unTreatedUniforms);\n        }\n        // Create shader material\n        const shaderPath = {\n            vertex: program.vertexShader + id,\n            fragment: program.fragmentShader + id,\n        };\n        const options = {\n            attributes: attributes,\n            uniforms: uniforms,\n            samplers: samplers,\n            needAlphaBlending: states && states.enable && states.enable.indexOf(3042) !== -1,\n        };\n        Effect.ShadersStore[program.vertexShader + id + \"VertexShader\"] = newVertexShader;\n        Effect.ShadersStore[program.fragmentShader + id + \"PixelShader\"] = newPixelShader;\n        const shaderMaterial = new ShaderMaterial(id, gltfRuntime.scene, shaderPath, options);\n        shaderMaterial.onError = onShaderCompileError(program, shaderMaterial, onError);\n        shaderMaterial.onCompiled = onShaderCompileSuccess(gltfRuntime, shaderMaterial, technique, material, unTreatedUniforms, onSuccess);\n        shaderMaterial.sideOrientation = Material.CounterClockWiseSideOrientation;\n        if (states && states.functions) {\n            const functions = states.functions;\n            if (functions.cullFace && functions.cullFace[0] !== ECullingType.BACK) {\n                shaderMaterial.backFaceCulling = false;\n            }\n            const blendFunc = functions.blendFuncSeparate;\n            if (blendFunc) {\n                if (blendFunc[0] === EBlendingFunction.SRC_ALPHA &&\n                    blendFunc[1] === EBlendingFunction.ONE_MINUS_SRC_ALPHA &&\n                    blendFunc[2] === EBlendingFunction.ONE &&\n                    blendFunc[3] === EBlendingFunction.ONE) {\n                    shaderMaterial.alphaMode = Constants.ALPHA_COMBINE;\n                }\n                else if (blendFunc[0] === EBlendingFunction.ONE &&\n                    blendFunc[1] === EBlendingFunction.ONE &&\n                    blendFunc[2] === EBlendingFunction.ZERO &&\n                    blendFunc[3] === EBlendingFunction.ONE) {\n                    shaderMaterial.alphaMode = Constants.ALPHA_ONEONE;\n                }\n                else if (blendFunc[0] === EBlendingFunction.SRC_ALPHA &&\n                    blendFunc[1] === EBlendingFunction.ONE &&\n                    blendFunc[2] === EBlendingFunction.ZERO &&\n                    blendFunc[3] === EBlendingFunction.ONE) {\n                    shaderMaterial.alphaMode = Constants.ALPHA_ADD;\n                }\n                else if (blendFunc[0] === EBlendingFunction.ZERO &&\n                    blendFunc[1] === EBlendingFunction.ONE_MINUS_SRC_COLOR &&\n                    blendFunc[2] === EBlendingFunction.ONE &&\n                    blendFunc[3] === EBlendingFunction.ONE) {\n                    shaderMaterial.alphaMode = Constants.ALPHA_SUBTRACT;\n                }\n                else if (blendFunc[0] === EBlendingFunction.DST_COLOR &&\n                    blendFunc[1] === EBlendingFunction.ZERO &&\n                    blendFunc[2] === EBlendingFunction.ONE &&\n                    blendFunc[3] === EBlendingFunction.ONE) {\n                    shaderMaterial.alphaMode = Constants.ALPHA_MULTIPLY;\n                }\n                else if (blendFunc[0] === EBlendingFunction.SRC_ALPHA &&\n                    blendFunc[1] === EBlendingFunction.ONE_MINUS_SRC_COLOR &&\n                    blendFunc[2] === EBlendingFunction.ONE &&\n                    blendFunc[3] === EBlendingFunction.ONE) {\n                    shaderMaterial.alphaMode = Constants.ALPHA_MAXIMIZED;\n                }\n            }\n        }\n    }\n}\n/**\n * glTF V1 Loader\n * @internal\n * @deprecated\n */\nexport class GLTFLoader {\n    static RegisterExtension(extension) {\n        if (GLTFLoader.Extensions[extension.name]) {\n            Tools.Error('Tool with the same name \"' + extension.name + '\" already exists');\n            return;\n        }\n        GLTFLoader.Extensions[extension.name] = extension;\n    }\n    dispose() {\n        // do nothing\n    }\n    _importMeshAsync(meshesNames, scene, data, rootUrl, assetContainer, onSuccess, onProgress, onError) {\n        scene.useRightHandedSystem = true;\n        GLTFLoaderExtension.LoadRuntimeAsync(scene, data, rootUrl, (gltfRuntime) => {\n            gltfRuntime.assetContainer = assetContainer;\n            gltfRuntime.importOnlyMeshes = true;\n            if (meshesNames === \"\") {\n                gltfRuntime.importMeshesNames = [];\n            }\n            else if (typeof meshesNames === \"string\") {\n                gltfRuntime.importMeshesNames = [meshesNames];\n            }\n            else if (meshesNames && !(meshesNames instanceof Array)) {\n                gltfRuntime.importMeshesNames = [meshesNames];\n            }\n            else {\n                gltfRuntime.importMeshesNames = [];\n                Tools.Warn(\"Argument meshesNames must be of type string or string[]\");\n            }\n            // Create nodes\n            this._createNodes(gltfRuntime);\n            const meshes = new Array();\n            const skeletons = new Array();\n            // Fill arrays of meshes and skeletons\n            for (const nde in gltfRuntime.nodes) {\n                const node = gltfRuntime.nodes[nde];\n                if (node.babylonNode instanceof AbstractMesh) {\n                    meshes.push(node.babylonNode);\n                }\n            }\n            for (const skl in gltfRuntime.skins) {\n                const skin = gltfRuntime.skins[skl];\n                if (skin.babylonSkeleton instanceof Skeleton) {\n                    skeletons.push(skin.babylonSkeleton);\n                }\n            }\n            // Load buffers, shaders, materials, etc.\n            this._loadBuffersAsync(gltfRuntime, () => {\n                this._loadShadersAsync(gltfRuntime, () => {\n                    importMaterials(gltfRuntime);\n                    postLoad(gltfRuntime);\n                    if (!GLTFFileLoader.IncrementalLoading && onSuccess) {\n                        onSuccess(meshes, skeletons);\n                    }\n                });\n            });\n            if (GLTFFileLoader.IncrementalLoading && onSuccess) {\n                onSuccess(meshes, skeletons);\n            }\n        }, onError);\n        return true;\n    }\n    /**\n     * Imports one or more meshes from a loaded gltf file and adds them to the scene\n     * @param meshesNames a string or array of strings of the mesh names that should be loaded from the file\n     * @param scene the scene the meshes should be added to\n     * @param assetContainer defines the asset container to use (can be null)\n     * @param data gltf data containing information of the meshes in a loaded file\n     * @param rootUrl root url to load from\n     * @param onProgress event that fires when loading progress has occured\n     * @returns a promise containg the loaded meshes, particles, skeletons and animations\n     */\n    importMeshAsync(meshesNames, scene, assetContainer, data, rootUrl, onProgress) {\n        return new Promise((resolve, reject) => {\n            this._importMeshAsync(meshesNames, scene, data, rootUrl, assetContainer, (meshes, skeletons) => {\n                resolve({\n                    meshes: meshes,\n                    particleSystems: [],\n                    skeletons: skeletons,\n                    animationGroups: [],\n                    lights: [],\n                    transformNodes: [],\n                    geometries: [],\n                });\n            }, onProgress, (message) => {\n                reject(new Error(message));\n            });\n        });\n    }\n    _loadAsync(scene, data, rootUrl, onSuccess, onProgress, onError) {\n        scene.useRightHandedSystem = true;\n        GLTFLoaderExtension.LoadRuntimeAsync(scene, data, rootUrl, (gltfRuntime) => {\n            // Load runtime extensios\n            GLTFLoaderExtension.LoadRuntimeExtensionsAsync(gltfRuntime, () => {\n                // Create nodes\n                this._createNodes(gltfRuntime);\n                // Load buffers, shaders, materials, etc.\n                this._loadBuffersAsync(gltfRuntime, () => {\n                    this._loadShadersAsync(gltfRuntime, () => {\n                        importMaterials(gltfRuntime);\n                        postLoad(gltfRuntime);\n                        if (!GLTFFileLoader.IncrementalLoading) {\n                            onSuccess();\n                        }\n                    });\n                });\n                if (GLTFFileLoader.IncrementalLoading) {\n                    onSuccess();\n                }\n            }, onError);\n        }, onError);\n    }\n    /**\n     * Imports all objects from a loaded gltf file and adds them to the scene\n     * @param scene the scene the objects should be added to\n     * @param data gltf data containing information of the meshes in a loaded file\n     * @param rootUrl root url to load from\n     * @param onProgress event that fires when loading progress has occured\n     * @returns a promise which completes when objects have been loaded to the scene\n     */\n    loadAsync(scene, data, rootUrl, onProgress) {\n        return new Promise((resolve, reject) => {\n            this._loadAsync(scene, data, rootUrl, () => {\n                resolve();\n            }, onProgress, (message) => {\n                reject(new Error(message));\n            });\n        });\n    }\n    _loadShadersAsync(gltfRuntime, onload) {\n        let hasShaders = false;\n        const processShader = (sha, shader) => {\n            GLTFLoaderExtension.LoadShaderStringAsync(gltfRuntime, sha, (shaderString) => {\n                if (shaderString instanceof ArrayBuffer) {\n                    return;\n                }\n                gltfRuntime.loadedShaderCount++;\n                if (shaderString) {\n                    Effect.ShadersStore[sha + (shader.type === EShaderType.VERTEX ? \"VertexShader\" : \"PixelShader\")] = shaderString;\n                }\n                if (gltfRuntime.loadedShaderCount === gltfRuntime.shaderscount) {\n                    onload();\n                }\n            }, () => {\n                Tools.Error(\"Error when loading shader program named \" + sha + \" located at \" + shader.uri);\n            });\n        };\n        for (const sha in gltfRuntime.shaders) {\n            hasShaders = true;\n            const shader = gltfRuntime.shaders[sha];\n            if (shader) {\n                processShader.bind(this, sha, shader)();\n            }\n            else {\n                Tools.Error(\"No shader named: \" + sha);\n            }\n        }\n        if (!hasShaders) {\n            onload();\n        }\n    }\n    _loadBuffersAsync(gltfRuntime, onLoad) {\n        let hasBuffers = false;\n        const processBuffer = (buf, buffer) => {\n            GLTFLoaderExtension.LoadBufferAsync(gltfRuntime, buf, (bufferView) => {\n                gltfRuntime.loadedBufferCount++;\n                if (bufferView) {\n                    if (bufferView.byteLength != gltfRuntime.buffers[buf].byteLength) {\n                        Tools.Error(\"Buffer named \" + buf + \" is length \" + bufferView.byteLength + \". Expected: \" + buffer.byteLength); // Improve error message\n                    }\n                    gltfRuntime.loadedBufferViews[buf] = bufferView;\n                }\n                if (gltfRuntime.loadedBufferCount === gltfRuntime.buffersCount) {\n                    onLoad();\n                }\n            }, () => {\n                Tools.Error(\"Error when loading buffer named \" + buf + \" located at \" + buffer.uri);\n            });\n        };\n        for (const buf in gltfRuntime.buffers) {\n            hasBuffers = true;\n            const buffer = gltfRuntime.buffers[buf];\n            if (buffer) {\n                processBuffer.bind(this, buf, buffer)();\n            }\n            else {\n                Tools.Error(\"No buffer named: \" + buf);\n            }\n        }\n        if (!hasBuffers) {\n            onLoad();\n        }\n    }\n    _createNodes(gltfRuntime) {\n        let currentScene = gltfRuntime.currentScene;\n        if (currentScene) {\n            // Only one scene even if multiple scenes are defined\n            for (let i = 0; i < currentScene.nodes.length; i++) {\n                traverseNodes(gltfRuntime, currentScene.nodes[i], null);\n            }\n        }\n        else {\n            // Load all scenes\n            for (const thing in gltfRuntime.scenes) {\n                currentScene = gltfRuntime.scenes[thing];\n                for (let i = 0; i < currentScene.nodes.length; i++) {\n                    traverseNodes(gltfRuntime, currentScene.nodes[i], null);\n                }\n            }\n        }\n    }\n}\nGLTFLoader.Extensions = {};\n/** @internal */\nexport class GLTFLoaderExtension {\n    constructor(name) {\n        this._name = name;\n    }\n    get name() {\n        return this._name;\n    }\n    /**\n     * Defines an override for loading the runtime\n     * Return true to stop further extensions from loading the runtime\n     * @param scene\n     * @param data\n     * @param rootUrl\n     * @param onSuccess\n     * @param onError\n     */\n    loadRuntimeAsync(scene, data, rootUrl, onSuccess, onError) {\n        return false;\n    }\n    /**\n     * Defines an onverride for creating gltf runtime\n     * Return true to stop further extensions from creating the runtime\n     * @param gltfRuntime\n     * @param onSuccess\n     * @param onError\n     */\n    loadRuntimeExtensionsAsync(gltfRuntime, onSuccess, onError) {\n        return false;\n    }\n    /**\n     * Defines an override for loading buffers\n     * Return true to stop further extensions from loading this buffer\n     * @param gltfRuntime\n     * @param id\n     * @param onSuccess\n     * @param onError\n     * @param onProgress\n     */\n    loadBufferAsync(gltfRuntime, id, onSuccess, onError, onProgress) {\n        return false;\n    }\n    /**\n     * Defines an override for loading texture buffers\n     * Return true to stop further extensions from loading this texture data\n     * @param gltfRuntime\n     * @param id\n     * @param onSuccess\n     * @param onError\n     */\n    loadTextureBufferAsync(gltfRuntime, id, onSuccess, onError) {\n        return false;\n    }\n    /**\n     * Defines an override for creating textures\n     * Return true to stop further extensions from loading this texture\n     * @param gltfRuntime\n     * @param id\n     * @param buffer\n     * @param onSuccess\n     * @param onError\n     */\n    createTextureAsync(gltfRuntime, id, buffer, onSuccess, onError) {\n        return false;\n    }\n    /**\n     * Defines an override for loading shader strings\n     * Return true to stop further extensions from loading this shader data\n     * @param gltfRuntime\n     * @param id\n     * @param onSuccess\n     * @param onError\n     */\n    loadShaderStringAsync(gltfRuntime, id, onSuccess, onError) {\n        return false;\n    }\n    /**\n     * Defines an override for loading materials\n     * Return true to stop further extensions from loading this material\n     * @param gltfRuntime\n     * @param id\n     * @param onSuccess\n     * @param onError\n     */\n    loadMaterialAsync(gltfRuntime, id, onSuccess, onError) {\n        return false;\n    }\n    // ---------\n    // Utilities\n    // ---------\n    static LoadRuntimeAsync(scene, data, rootUrl, onSuccess, onError) {\n        GLTFLoaderExtension._ApplyExtensions((loaderExtension) => {\n            return loaderExtension.loadRuntimeAsync(scene, data, rootUrl, onSuccess, onError);\n        }, () => {\n            setTimeout(() => {\n                if (!onSuccess) {\n                    return;\n                }\n                onSuccess(GLTFLoaderBase.CreateRuntime(data.json, scene, rootUrl));\n            });\n        });\n    }\n    static LoadRuntimeExtensionsAsync(gltfRuntime, onSuccess, onError) {\n        GLTFLoaderExtension._ApplyExtensions((loaderExtension) => {\n            return loaderExtension.loadRuntimeExtensionsAsync(gltfRuntime, onSuccess, onError);\n        }, () => {\n            setTimeout(() => {\n                onSuccess();\n            });\n        });\n    }\n    static LoadBufferAsync(gltfRuntime, id, onSuccess, onError, onProgress) {\n        GLTFLoaderExtension._ApplyExtensions((loaderExtension) => {\n            return loaderExtension.loadBufferAsync(gltfRuntime, id, onSuccess, onError, onProgress);\n        }, () => {\n            GLTFLoaderBase.LoadBufferAsync(gltfRuntime, id, onSuccess, onError, onProgress);\n        });\n    }\n    static LoadTextureAsync(gltfRuntime, id, onSuccess, onError) {\n        GLTFLoaderExtension._LoadTextureBufferAsync(gltfRuntime, id, (buffer) => {\n            if (buffer) {\n                GLTFLoaderExtension._CreateTextureAsync(gltfRuntime, id, buffer, onSuccess, onError);\n            }\n        }, onError);\n    }\n    static LoadShaderStringAsync(gltfRuntime, id, onSuccess, onError) {\n        GLTFLoaderExtension._ApplyExtensions((loaderExtension) => {\n            return loaderExtension.loadShaderStringAsync(gltfRuntime, id, onSuccess, onError);\n        }, () => {\n            GLTFLoaderBase.LoadShaderStringAsync(gltfRuntime, id, onSuccess, onError);\n        });\n    }\n    static LoadMaterialAsync(gltfRuntime, id, onSuccess, onError) {\n        GLTFLoaderExtension._ApplyExtensions((loaderExtension) => {\n            return loaderExtension.loadMaterialAsync(gltfRuntime, id, onSuccess, onError);\n        }, () => {\n            GLTFLoaderBase.LoadMaterialAsync(gltfRuntime, id, onSuccess, onError);\n        });\n    }\n    static _LoadTextureBufferAsync(gltfRuntime, id, onSuccess, onError) {\n        GLTFLoaderExtension._ApplyExtensions((loaderExtension) => {\n            return loaderExtension.loadTextureBufferAsync(gltfRuntime, id, onSuccess, onError);\n        }, () => {\n            GLTFLoaderBase.LoadTextureBufferAsync(gltfRuntime, id, onSuccess, onError);\n        });\n    }\n    static _CreateTextureAsync(gltfRuntime, id, buffer, onSuccess, onError) {\n        GLTFLoaderExtension._ApplyExtensions((loaderExtension) => {\n            return loaderExtension.createTextureAsync(gltfRuntime, id, buffer, onSuccess, onError);\n        }, () => {\n            GLTFLoaderBase.CreateTextureAsync(gltfRuntime, id, buffer, onSuccess);\n        });\n    }\n    static _ApplyExtensions(func, defaultFunc) {\n        for (const extensionName in GLTFLoader.Extensions) {\n            const loaderExtension = GLTFLoader.Extensions[extensionName];\n            if (func(loaderExtension)) {\n                return;\n            }\n        }\n        defaultFunc();\n    }\n}\nGLTFFileLoader._CreateGLTF1Loader = () => new GLTFLoader();\n//# sourceMappingURL=glTFLoader.js.map","import { GLTFLoaderExtension, GLTFLoader, GLTFLoaderBase } from \"./glTFLoader.js\";\nimport { GLTFUtils } from \"./glTFLoaderUtils.js\";\nimport { EComponentType } from \"./glTFLoaderInterfaces.js\";\nconst BinaryExtensionBufferName = \"binary_glTF\";\n/**\n * @internal\n * @deprecated\n */\nexport class GLTFBinaryExtension extends GLTFLoaderExtension {\n    constructor() {\n        super(\"KHR_binary_glTF\");\n    }\n    loadRuntimeAsync(scene, data, rootUrl, onSuccess) {\n        const extensionsUsed = data.json.extensionsUsed;\n        if (!extensionsUsed || extensionsUsed.indexOf(this.name) === -1 || !data.bin) {\n            return false;\n        }\n        this._bin = data.bin;\n        onSuccess(GLTFLoaderBase.CreateRuntime(data.json, scene, rootUrl));\n        return true;\n    }\n    loadBufferAsync(gltfRuntime, id, onSuccess, onError) {\n        if (gltfRuntime.extensionsUsed.indexOf(this.name) === -1) {\n            return false;\n        }\n        if (id !== BinaryExtensionBufferName) {\n            return false;\n        }\n        this._bin.readAsync(0, this._bin.byteLength).then(onSuccess, (error) => onError(error.message));\n        return true;\n    }\n    loadTextureBufferAsync(gltfRuntime, id, onSuccess) {\n        const texture = gltfRuntime.textures[id];\n        const source = gltfRuntime.images[texture.source];\n        if (!source.extensions || !(this.name in source.extensions)) {\n            return false;\n        }\n        const sourceExt = source.extensions[this.name];\n        const bufferView = gltfRuntime.bufferViews[sourceExt.bufferView];\n        const buffer = GLTFUtils.GetBufferFromBufferView(gltfRuntime, bufferView, 0, bufferView.byteLength, EComponentType.UNSIGNED_BYTE);\n        onSuccess(buffer);\n        return true;\n    }\n    loadShaderStringAsync(gltfRuntime, id, onSuccess) {\n        const shader = gltfRuntime.shaders[id];\n        if (!shader.extensions || !(this.name in shader.extensions)) {\n            return false;\n        }\n        const binaryExtensionShader = shader.extensions[this.name];\n        const bufferView = gltfRuntime.bufferViews[binaryExtensionShader.bufferView];\n        const shaderBytes = GLTFUtils.GetBufferFromBufferView(gltfRuntime, bufferView, 0, bufferView.byteLength, EComponentType.UNSIGNED_BYTE);\n        setTimeout(() => {\n            const shaderString = GLTFUtils.DecodeBufferToText(shaderBytes);\n            onSuccess(shaderString);\n        });\n        return true;\n    }\n}\nGLTFLoader.RegisterExtension(new GLTFBinaryExtension());\n//# sourceMappingURL=glTFBinaryExtension.js.map","import { GLTFLoaderExtension, GLTFLoaderBase, GLTFLoader } from \"./glTFLoader.js\";\nimport { Vector3 } from \"@babylonjs/core/Maths/math.vector.js\";\nimport { Color3 } from \"@babylonjs/core/Maths/math.color.js\";\nimport { Tools } from \"@babylonjs/core/Misc/tools.js\";\nimport { Material } from \"@babylonjs/core/Materials/material.js\";\nimport { StandardMaterial } from \"@babylonjs/core/Materials/standardMaterial.js\";\nimport { HemisphericLight } from \"@babylonjs/core/Lights/hemisphericLight.js\";\nimport { DirectionalLight } from \"@babylonjs/core/Lights/directionalLight.js\";\nimport { PointLight } from \"@babylonjs/core/Lights/pointLight.js\";\nimport { SpotLight } from \"@babylonjs/core/Lights/spotLight.js\";\n/**\n * @internal\n * @deprecated\n */\nexport class GLTFMaterialsCommonExtension extends GLTFLoaderExtension {\n    constructor() {\n        super(\"KHR_materials_common\");\n    }\n    loadRuntimeExtensionsAsync(gltfRuntime) {\n        if (!gltfRuntime.extensions) {\n            return false;\n        }\n        const extension = gltfRuntime.extensions[this.name];\n        if (!extension) {\n            return false;\n        }\n        // Create lights\n        const lights = extension.lights;\n        if (lights) {\n            for (const thing in lights) {\n                const light = lights[thing];\n                switch (light.type) {\n                    case \"ambient\": {\n                        const ambientLight = new HemisphericLight(light.name, new Vector3(0, 1, 0), gltfRuntime.scene);\n                        const ambient = light.ambient;\n                        if (ambient) {\n                            ambientLight.diffuse = Color3.FromArray(ambient.color || [1, 1, 1]);\n                        }\n                        break;\n                    }\n                    case \"point\": {\n                        const pointLight = new PointLight(light.name, new Vector3(10, 10, 10), gltfRuntime.scene);\n                        const point = light.point;\n                        if (point) {\n                            pointLight.diffuse = Color3.FromArray(point.color || [1, 1, 1]);\n                        }\n                        break;\n                    }\n                    case \"directional\": {\n                        const dirLight = new DirectionalLight(light.name, new Vector3(0, -1, 0), gltfRuntime.scene);\n                        const directional = light.directional;\n                        if (directional) {\n                            dirLight.diffuse = Color3.FromArray(directional.color || [1, 1, 1]);\n                        }\n                        break;\n                    }\n                    case \"spot\": {\n                        const spot = light.spot;\n                        if (spot) {\n                            const spotLight = new SpotLight(light.name, new Vector3(0, 10, 0), new Vector3(0, -1, 0), spot.fallOffAngle || Math.PI, spot.fallOffExponent || 0.0, gltfRuntime.scene);\n                            spotLight.diffuse = Color3.FromArray(spot.color || [1, 1, 1]);\n                        }\n                        break;\n                    }\n                    default:\n                        Tools.Warn('GLTF Material Common extension: light type \"' + light.type + \" not supported\");\n                        break;\n                }\n            }\n        }\n        return false;\n    }\n    loadMaterialAsync(gltfRuntime, id, onSuccess, onError) {\n        const material = gltfRuntime.materials[id];\n        if (!material || !material.extensions) {\n            return false;\n        }\n        const extension = material.extensions[this.name];\n        if (!extension) {\n            return false;\n        }\n        const standardMaterial = new StandardMaterial(id, gltfRuntime.scene);\n        standardMaterial.sideOrientation = Material.CounterClockWiseSideOrientation;\n        if (extension.technique === \"CONSTANT\") {\n            standardMaterial.disableLighting = true;\n        }\n        standardMaterial.backFaceCulling = extension.doubleSided === undefined ? false : !extension.doubleSided;\n        standardMaterial.alpha = extension.values.transparency === undefined ? 1.0 : extension.values.transparency;\n        standardMaterial.specularPower = extension.values.shininess === undefined ? 0.0 : extension.values.shininess;\n        // Ambient\n        if (typeof extension.values.ambient === \"string\") {\n            this._loadTexture(gltfRuntime, extension.values.ambient, standardMaterial, \"ambientTexture\", onError);\n        }\n        else {\n            standardMaterial.ambientColor = Color3.FromArray(extension.values.ambient || [0, 0, 0]);\n        }\n        // Diffuse\n        if (typeof extension.values.diffuse === \"string\") {\n            this._loadTexture(gltfRuntime, extension.values.diffuse, standardMaterial, \"diffuseTexture\", onError);\n        }\n        else {\n            standardMaterial.diffuseColor = Color3.FromArray(extension.values.diffuse || [0, 0, 0]);\n        }\n        // Emission\n        if (typeof extension.values.emission === \"string\") {\n            this._loadTexture(gltfRuntime, extension.values.emission, standardMaterial, \"emissiveTexture\", onError);\n        }\n        else {\n            standardMaterial.emissiveColor = Color3.FromArray(extension.values.emission || [0, 0, 0]);\n        }\n        // Specular\n        if (typeof extension.values.specular === \"string\") {\n            this._loadTexture(gltfRuntime, extension.values.specular, standardMaterial, \"specularTexture\", onError);\n        }\n        else {\n            standardMaterial.specularColor = Color3.FromArray(extension.values.specular || [0, 0, 0]);\n        }\n        return true;\n    }\n    _loadTexture(gltfRuntime, id, material, propertyPath, onError) {\n        // Create buffer from texture url\n        GLTFLoaderBase.LoadTextureBufferAsync(gltfRuntime, id, (buffer) => {\n            // Create texture from buffer\n            GLTFLoaderBase.CreateTextureAsync(gltfRuntime, id, buffer, (texture) => (material[propertyPath] = texture));\n        }, onError);\n    }\n}\nGLTFLoader.RegisterExtension(new GLTFMaterialsCommonExtension());\n//# sourceMappingURL=glTFMaterialsCommonExtension.js.map","// Do not edit.\nimport { ShaderStore } from \"@babylonjs/core/Engines/shaderStore.js\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/fogFragmentDeclaration.js\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/fogFragment.js\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/imageProcessingCompatibility.js\";\nconst name = \"gridPixelShader\";\nconst shader = `#extension GL_OES_standard_derivatives : enable\n#define SQRT2 1.41421356\n#define PI 3.14159\nprecision highp float;\runiform float visibility;\runiform vec3 mainColor;\runiform vec3 lineColor;\runiform vec4 gridControl;\runiform vec3 gridOffset;\rvarying vec3 vPosition;\rvarying vec3 vNormal;\r#include<fogFragmentDeclaration>\n#ifdef OPACITY\nvarying vec2 vOpacityUV;\runiform sampler2D opacitySampler;\runiform vec2 vOpacityInfos;\r#endif\nfloat getDynamicVisibility(float position) {\rfloat majorGridFrequency=gridControl.y;\rif (floor(position+0.5)==floor(position/majorGridFrequency+0.5)*majorGridFrequency)\r{\rreturn 1.0;\r} \rreturn gridControl.z;\r}\rfloat getAnisotropicAttenuation(float differentialLength) {\rconst float maxNumberOfLines=10.0;\rreturn clamp(1.0/(differentialLength+1.0)-1.0/maxNumberOfLines,0.0,1.0);\r}\rfloat isPointOnLine(float position,float differentialLength) {\rfloat fractionPartOfPosition=position-floor(position+0.5); \rfractionPartOfPosition/=differentialLength; \rfractionPartOfPosition=clamp(fractionPartOfPosition,-1.,1.);\rfloat result=0.5+0.5*cos(fractionPartOfPosition*PI); \rreturn result; \r}\rfloat contributionOnAxis(float position) {\rfloat differentialLength=length(vec2(dFdx(position),dFdy(position)));\rdifferentialLength*=SQRT2; \rfloat result=isPointOnLine(position,differentialLength);\rfloat dynamicVisibility=getDynamicVisibility(position);\rresult*=dynamicVisibility;\rfloat anisotropicAttenuation=getAnisotropicAttenuation(differentialLength);\rresult*=anisotropicAttenuation;\rreturn result;\r}\rfloat normalImpactOnAxis(float x) {\rfloat normalImpact=clamp(1.0-3.0*abs(x*x*x),0.0,1.0);\rreturn normalImpact;\r}\r#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) {\r#define CUSTOM_FRAGMENT_MAIN_BEGIN\nfloat gridRatio=gridControl.x;\rvec3 gridPos=(vPosition+gridOffset.xyz)/gridRatio;\rfloat x=contributionOnAxis(gridPos.x);\rfloat y=contributionOnAxis(gridPos.y);\rfloat z=contributionOnAxis(gridPos.z);\rvec3 normal=normalize(vNormal);\rx*=normalImpactOnAxis(normal.x);\ry*=normalImpactOnAxis(normal.y);\rz*=normalImpactOnAxis(normal.z);\r#ifdef MAX_LINE \nfloat grid=clamp(max(max(x,y),z),0.,1.);\r#else\nfloat grid=clamp(x+y+z,0.,1.);\r#endif\nvec3 color=mix(mainColor,lineColor,grid);\r#ifdef FOG\n#include<fogFragment>\n#endif\nfloat opacity=1.0;\r#ifdef TRANSPARENT\nopacity=clamp(grid,0.08,gridControl.w*grid);\r#endif \n#ifdef OPACITY\nopacity*=texture2D(opacitySampler,vOpacityUV).a;\r#endif \ngl_FragColor=vec4(color.rgb,opacity*visibility);\r#ifdef TRANSPARENT\n#ifdef PREMULTIPLYALPHA\ngl_FragColor.rgb*=opacity;\r#endif\n#else \n#endif\n#include<imageProcessingCompatibility>\n#define CUSTOM_FRAGMENT_MAIN_END\n}\r`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const gridPixelShader = { name, shader };\n//# sourceMappingURL=grid.fragment.js.map","import { __decorate } from \"@babylonjs/core/tslib.es6.js\";\n/* eslint-disable @typescript-eslint/naming-convention */\nimport { serializeAsTexture, serialize, expandToProperty, serializeAsColor3, SerializationHelper, serializeAsVector3 } from \"@babylonjs/core/Misc/decorators.js\";\nimport { Vector4, Vector3 } from \"@babylonjs/core/Maths/math.vector.js\";\nimport { Color3 } from \"@babylonjs/core/Maths/math.color.js\";\nimport { MaterialDefines } from \"@babylonjs/core/Materials/materialDefines.js\";\nimport { MaterialHelper } from \"@babylonjs/core/Materials/materialHelper.js\";\nimport { PushMaterial } from \"@babylonjs/core/Materials/pushMaterial.js\";\nimport { MaterialFlags } from \"@babylonjs/core/Materials/materialFlags.js\";\nimport { VertexBuffer } from \"@babylonjs/core/Buffers/buffer.js\";\nimport { RegisterClass } from \"@babylonjs/core/Misc/typeStore.js\";\nimport \"./grid.fragment.js\";\nimport \"./grid.vertex.js\";\nclass GridMaterialDefines extends MaterialDefines {\n    constructor() {\n        super();\n        this.OPACITY = false;\n        this.TRANSPARENT = false;\n        this.FOG = false;\n        this.PREMULTIPLYALPHA = false;\n        this.MAX_LINE = false;\n        this.UV1 = false;\n        this.UV2 = false;\n        this.INSTANCES = false;\n        this.THIN_INSTANCES = false;\n        this.IMAGEPROCESSINGPOSTPROCESS = false;\n        this.SKIPFINALCOLORCLAMP = false;\n        this.rebuild();\n    }\n}\n/**\n * The grid materials allows you to wrap any shape with a grid.\n * Colors are customizable.\n */\nexport class GridMaterial extends PushMaterial {\n    /**\n     * constructor\n     * @param name The name given to the material in order to identify it afterwards.\n     * @param scene The scene the material is used in.\n     */\n    constructor(name, scene) {\n        super(name, scene);\n        /**\n         * Main color of the grid (e.g. between lines)\n         */\n        this.mainColor = Color3.Black();\n        /**\n         * Color of the grid lines.\n         */\n        this.lineColor = Color3.Teal();\n        /**\n         * The scale of the grid compared to unit.\n         */\n        this.gridRatio = 1.0;\n        /**\n         * Allows setting an offset for the grid lines.\n         */\n        this.gridOffset = Vector3.Zero();\n        /**\n         * The frequency of thicker lines.\n         */\n        this.majorUnitFrequency = 10;\n        /**\n         * The visibility of minor units in the grid.\n         */\n        this.minorUnitVisibility = 0.33;\n        /**\n         * The grid opacity outside of the lines.\n         */\n        this.opacity = 1.0;\n        /**\n         * Determine RBG output is premultiplied by alpha value.\n         */\n        this.preMultiplyAlpha = false;\n        /**\n         * Determines if the max line value will be used instead of the sum wherever grid lines intersect.\n         */\n        this.useMaxLine = false;\n        this._gridControl = new Vector4(this.gridRatio, this.majorUnitFrequency, this.minorUnitVisibility, this.opacity);\n    }\n    /**\n     * Returns whether or not the grid requires alpha blending.\n     */\n    needAlphaBlending() {\n        return this.opacity < 1.0 || (this._opacityTexture && this._opacityTexture.isReady());\n    }\n    needAlphaBlendingForMesh(mesh) {\n        return mesh.visibility < 1.0 || this.needAlphaBlending();\n    }\n    isReadyForSubMesh(mesh, subMesh, useInstances) {\n        if (this.isFrozen) {\n            if (subMesh.effect && subMesh.effect._wasPreviouslyReady && subMesh.effect._wasPreviouslyUsingInstances === useInstances) {\n                return true;\n            }\n        }\n        if (!subMesh.materialDefines) {\n            subMesh.materialDefines = new GridMaterialDefines();\n        }\n        const defines = subMesh.materialDefines;\n        const scene = this.getScene();\n        if (this._isReadyForSubMesh(subMesh)) {\n            return true;\n        }\n        if (defines.TRANSPARENT !== this.opacity < 1.0) {\n            defines.TRANSPARENT = !defines.TRANSPARENT;\n            defines.markAsUnprocessed();\n        }\n        if (defines.PREMULTIPLYALPHA != this.preMultiplyAlpha) {\n            defines.PREMULTIPLYALPHA = !defines.PREMULTIPLYALPHA;\n            defines.markAsUnprocessed();\n        }\n        if (defines.MAX_LINE !== this.useMaxLine) {\n            defines.MAX_LINE = !defines.MAX_LINE;\n            defines.markAsUnprocessed();\n        }\n        // Textures\n        if (defines._areTexturesDirty) {\n            defines._needUVs = false;\n            if (scene.texturesEnabled) {\n                if (this._opacityTexture && MaterialFlags.OpacityTextureEnabled) {\n                    if (!this._opacityTexture.isReady()) {\n                        return false;\n                    }\n                    else {\n                        defines._needUVs = true;\n                        defines.OPACITY = true;\n                    }\n                }\n            }\n        }\n        MaterialHelper.PrepareDefinesForMisc(mesh, scene, false, false, this.fogEnabled, false, defines);\n        // Values that need to be evaluated on every frame\n        MaterialHelper.PrepareDefinesForFrameBoundValues(scene, scene.getEngine(), this, defines, !!useInstances);\n        // Get correct effect\n        if (defines.isDirty) {\n            defines.markAsProcessed();\n            scene.resetCachedMaterial();\n            // Attributes\n            MaterialHelper.PrepareDefinesForAttributes(mesh, defines, false, false);\n            const attribs = [VertexBuffer.PositionKind, VertexBuffer.NormalKind];\n            if (defines.UV1) {\n                attribs.push(VertexBuffer.UVKind);\n            }\n            if (defines.UV2) {\n                attribs.push(VertexBuffer.UV2Kind);\n            }\n            defines.IMAGEPROCESSINGPOSTPROCESS = scene.imageProcessingConfiguration.applyByPostProcess;\n            MaterialHelper.PrepareAttributesForInstances(attribs, defines);\n            // Defines\n            const join = defines.toString();\n            subMesh.setEffect(scene\n                .getEngine()\n                .createEffect(\"grid\", attribs, [\n                \"projection\",\n                \"mainColor\",\n                \"lineColor\",\n                \"gridControl\",\n                \"gridOffset\",\n                \"vFogInfos\",\n                \"vFogColor\",\n                \"world\",\n                \"view\",\n                \"opacityMatrix\",\n                \"vOpacityInfos\",\n                \"visibility\",\n            ], [\"opacitySampler\"], join, undefined, this.onCompiled, this.onError), defines, this._materialContext);\n        }\n        if (!subMesh.effect || !subMesh.effect.isReady()) {\n            return false;\n        }\n        defines._renderId = scene.getRenderId();\n        subMesh.effect._wasPreviouslyReady = true;\n        subMesh.effect._wasPreviouslyUsingInstances = !!useInstances;\n        return true;\n    }\n    bindForSubMesh(world, mesh, subMesh) {\n        const scene = this.getScene();\n        const defines = subMesh.materialDefines;\n        if (!defines) {\n            return;\n        }\n        const effect = subMesh.effect;\n        if (!effect) {\n            return;\n        }\n        this._activeEffect = effect;\n        this._activeEffect.setFloat(\"visibility\", mesh.visibility);\n        // Matrices\n        if (!defines.INSTANCES || defines.THIN_INSTANCE) {\n            this.bindOnlyWorldMatrix(world);\n        }\n        this._activeEffect.setMatrix(\"view\", scene.getViewMatrix());\n        this._activeEffect.setMatrix(\"projection\", scene.getProjectionMatrix());\n        // Uniforms\n        if (this._mustRebind(scene, effect)) {\n            this._activeEffect.setColor3(\"mainColor\", this.mainColor);\n            this._activeEffect.setColor3(\"lineColor\", this.lineColor);\n            this._activeEffect.setVector3(\"gridOffset\", this.gridOffset);\n            this._gridControl.x = this.gridRatio;\n            this._gridControl.y = Math.round(this.majorUnitFrequency);\n            this._gridControl.z = this.minorUnitVisibility;\n            this._gridControl.w = this.opacity;\n            this._activeEffect.setVector4(\"gridControl\", this._gridControl);\n            if (this._opacityTexture && MaterialFlags.OpacityTextureEnabled) {\n                this._activeEffect.setTexture(\"opacitySampler\", this._opacityTexture);\n                this._activeEffect.setFloat2(\"vOpacityInfos\", this._opacityTexture.coordinatesIndex, this._opacityTexture.level);\n                this._activeEffect.setMatrix(\"opacityMatrix\", this._opacityTexture.getTextureMatrix());\n            }\n        }\n        // Fog\n        MaterialHelper.BindFogParameters(scene, mesh, this._activeEffect);\n        this._afterBind(mesh, this._activeEffect);\n    }\n    /**\n     * Dispose the material and its associated resources.\n     * @param forceDisposeEffect will also dispose the used effect when true\n     */\n    dispose(forceDisposeEffect) {\n        super.dispose(forceDisposeEffect);\n    }\n    clone(name) {\n        return SerializationHelper.Clone(() => new GridMaterial(name, this.getScene()), this);\n    }\n    serialize() {\n        const serializationObject = super.serialize();\n        serializationObject.customType = \"BABYLON.GridMaterial\";\n        return serializationObject;\n    }\n    getClassName() {\n        return \"GridMaterial\";\n    }\n    static Parse(source, scene, rootUrl) {\n        return SerializationHelper.Parse(() => new GridMaterial(source.name, scene), source, scene, rootUrl);\n    }\n}\n__decorate([\n    serializeAsColor3()\n], GridMaterial.prototype, \"mainColor\", void 0);\n__decorate([\n    serializeAsColor3()\n], GridMaterial.prototype, \"lineColor\", void 0);\n__decorate([\n    serialize()\n], GridMaterial.prototype, \"gridRatio\", void 0);\n__decorate([\n    serializeAsVector3()\n], GridMaterial.prototype, \"gridOffset\", void 0);\n__decorate([\n    serialize()\n], GridMaterial.prototype, \"majorUnitFrequency\", void 0);\n__decorate([\n    serialize()\n], GridMaterial.prototype, \"minorUnitVisibility\", void 0);\n__decorate([\n    serialize()\n], GridMaterial.prototype, \"opacity\", void 0);\n__decorate([\n    serialize()\n], GridMaterial.prototype, \"preMultiplyAlpha\", void 0);\n__decorate([\n    serialize()\n], GridMaterial.prototype, \"useMaxLine\", void 0);\n__decorate([\n    serializeAsTexture(\"opacityTexture\")\n], GridMaterial.prototype, \"_opacityTexture\", void 0);\n__decorate([\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], GridMaterial.prototype, \"opacityTexture\", void 0);\nRegisterClass(\"BABYLON.GridMaterial\", GridMaterial);\n//# sourceMappingURL=gridMaterial.js.map","// Do not edit.\nimport { ShaderStore } from \"@babylonjs/core/Engines/shaderStore.js\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/clipPlaneFragmentDeclaration.js\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/fogFragmentDeclaration.js\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/helperFunctions.js\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/clipPlaneFragment.js\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/fogFragment.js\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/imageProcessingCompatibility.js\";\nconst name = \"skyPixelShader\";\nconst shader = `precision highp float;\rvarying vec3 vPositionW;\r#ifdef VERTEXCOLOR\nvarying vec4 vColor;\r#endif\n#include<clipPlaneFragmentDeclaration>\nuniform vec3 cameraPosition;\runiform vec3 cameraOffset;\runiform vec3 up;\runiform float luminance;\runiform float turbidity;\runiform float rayleigh;\runiform float mieCoefficient;\runiform float mieDirectionalG;\runiform vec3 sunPosition;\r#include<fogFragmentDeclaration>\nconst float e=2.71828182845904523536028747135266249775724709369995957;\rconst float pi=3.141592653589793238462643383279502884197169;\rconst float n=1.0003;\rconst float N=2.545E25;\rconst float pn=0.035;\rconst vec3 lambda=vec3(680E-9,550E-9,450E-9);\rconst vec3 K=vec3(0.686,0.678,0.666);\rconst float v=4.0;\rconst float rayleighZenithLength=8.4E3;\rconst float mieZenithLength=1.25E3;\rconst float EE=1000.0;\rconst float sunAngularDiameterCos=0.999956676946448443553574619906976478926848692873900859324;\rconst float cutoffAngle=pi/1.95;\rconst float steepness=1.5;\rvec3 totalRayleigh(vec3 lambda)\r{\rreturn (8.0*pow(pi,3.0)*pow(pow(n,2.0)-1.0,2.0)*(6.0+3.0*pn))/(3.0*N*pow(lambda,vec3(4.0))*(6.0-7.0*pn));\r}\rvec3 simplifiedRayleigh()\r{\rreturn 0.0005/vec3(94,40,18);\r}\rfloat rayleighPhase(float cosTheta)\r{ \rreturn (3.0/(16.0*pi))*(1.0+pow(cosTheta,2.0));\r}\rvec3 totalMie(vec3 lambda,vec3 K,float T)\r{\rfloat c=(0.2*T )*10E-18;\rreturn 0.434*c*pi*pow((2.0*pi)/lambda,vec3(v-2.0))*K;\r}\rfloat hgPhase(float cosTheta,float g)\r{\rreturn (1.0/(4.0*pi))*((1.0-pow(g,2.0))/pow(1.0-2.0*g*cosTheta+pow(g,2.0),1.5));\r}\rfloat sunIntensity(float zenithAngleCos)\r{\rreturn EE*max(0.0,1.0-exp((-(cutoffAngle-acos(zenithAngleCos))/steepness)));\r}\rfloat A=0.15;\rfloat B=0.50;\rfloat C=0.10;\rfloat D=0.20;\rfloat EEE=0.02;\rfloat F=0.30;\rfloat W=1000.0;\rvec3 Uncharted2Tonemap(vec3 x)\r{\rreturn ((x*(A*x+C*B)+D*EEE)/(x*(A*x+B)+D*F))-EEE/F;\r}\r#if DITHER\n#include<helperFunctions>\n#endif\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) {\r#define CUSTOM_FRAGMENT_MAIN_BEGIN\n#include<clipPlaneFragment>\n/**\r*--------------------------------------------------------------------------------------------------\r* Sky Color\r*--------------------------------------------------------------------------------------------------\r*/\rfloat sunfade=1.0-clamp(1.0-exp((sunPosition.y/450000.0)),0.0,1.0);\rfloat rayleighCoefficient=rayleigh-(1.0*(1.0-sunfade));\rvec3 sunDirection=normalize(sunPosition);\rfloat sunE=sunIntensity(dot(sunDirection,up));\rvec3 betaR=simplifiedRayleigh()*rayleighCoefficient;\rvec3 betaM=totalMie(lambda,K,turbidity)*mieCoefficient;\rfloat zenithAngle=acos(max(0.0,dot(up,normalize(vPositionW-cameraPosition+cameraOffset))));\rfloat sR=rayleighZenithLength/(cos(zenithAngle)+0.15*pow(93.885-((zenithAngle*180.0)/pi),-1.253));\rfloat sM=mieZenithLength/(cos(zenithAngle)+0.15*pow(93.885-((zenithAngle*180.0)/pi),-1.253));\rvec3 Fex=exp(-(betaR*sR+betaM*sM));\rfloat cosTheta=dot(normalize(vPositionW-cameraPosition),sunDirection);\rfloat rPhase=rayleighPhase(cosTheta*0.5+0.5);\rvec3 betaRTheta=betaR*rPhase;\rfloat mPhase=hgPhase(cosTheta,mieDirectionalG);\rvec3 betaMTheta=betaM*mPhase;\rvec3 Lin=pow(sunE*((betaRTheta+betaMTheta)/(betaR+betaM))*(1.0-Fex),vec3(1.5));\rLin*=mix(vec3(1.0),pow(sunE*((betaRTheta+betaMTheta)/(betaR+betaM))*Fex,vec3(1.0/2.0)),clamp(pow(1.0-dot(up,sunDirection),5.0),0.0,1.0));\rvec3 direction=normalize(vPositionW-cameraPosition);\rfloat theta=acos(direction.y);\rfloat phi=atan(direction.z,direction.x);\rvec2 uv=vec2(phi,theta)/vec2(2.0*pi,pi)+vec2(0.5,0.0);\rvec3 L0=vec3(0.1)*Fex;\rfloat sundisk=smoothstep(sunAngularDiameterCos,sunAngularDiameterCos+0.00002,cosTheta);\rL0+=(sunE*19000.0*Fex)*sundisk;\rvec3 whiteScale=1.0/Uncharted2Tonemap(vec3(W));\rvec3 texColor=(Lin+L0);\rtexColor*=0.04 ;\rtexColor+=vec3(0.0,0.001,0.0025)*0.3;\rfloat g_fMaxLuminance=1.0;\rfloat fLumScaled=0.1/luminance; \rfloat fLumCompressed=(fLumScaled*(1.0+(fLumScaled/(g_fMaxLuminance*g_fMaxLuminance))))/(1.0+fLumScaled); \rfloat ExposureBias=fLumCompressed;\rvec3 curr=Uncharted2Tonemap((log2(2.0/pow(luminance,4.0)))*texColor);\rvec3 retColor=curr*whiteScale;\r/**\r*--------------------------------------------------------------------------------------------------\r* Sky Color\r*--------------------------------------------------------------------------------------------------\r*/\rfloat alpha=1.0;\r#ifdef VERTEXCOLOR\nretColor.rgb*=vColor.rgb;\r#endif\n#if defined(VERTEXALPHA) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nalpha*=vColor.a;\r#endif\n#if DITHER\nretColor.rgb+=dither(gl_FragCoord.xy,0.5);\r#endif\nvec4 color=clamp(vec4(retColor.rgb,alpha),0.0,1.0);\r#include<fogFragment>\ngl_FragColor=color;\r#include<imageProcessingCompatibility>\n#define CUSTOM_FRAGMENT_MAIN_END\n}\r`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const skyPixelShader = { name, shader };\n//# sourceMappingURL=sky.fragment.js.map","// Do not edit.\nimport { ShaderStore } from \"@babylonjs/core/Engines/shaderStore.js\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/clipPlaneVertexDeclaration.js\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/fogVertexDeclaration.js\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/clipPlaneVertex.js\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/fogVertex.js\";\nconst name = \"skyVertexShader\";\nconst shader = `precision highp float;\rattribute vec3 position;\r#ifdef VERTEXCOLOR\nattribute vec4 color;\r#endif\nuniform mat4 world;\runiform mat4 view;\runiform mat4 viewProjection;\r#ifdef POINTSIZE\nuniform float pointSize;\r#endif\nvarying vec3 vPositionW;\r#ifdef VERTEXCOLOR\nvarying vec4 vColor;\r#endif\n#include<clipPlaneVertexDeclaration>\n#include<fogVertexDeclaration>\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void) {\r#define CUSTOM_VERTEX_MAIN_BEGIN\ngl_Position=viewProjection*world*vec4(position,1.0);\rvec4 worldPos=world*vec4(position,1.0);\rvPositionW=vec3(worldPos);\r#include<clipPlaneVertex>\n#include<fogVertex>\n#ifdef VERTEXCOLOR\nvColor=color;\r#endif\n#if defined(POINTSIZE) && !defined(WEBGPU)\ngl_PointSize=pointSize;\r#endif\n#define CUSTOM_VERTEX_MAIN_END\n}\r`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const skyVertexShader = { name, shader };\n//# sourceMappingURL=sky.vertex.js.map","import { __decorate } from \"@babylonjs/core/tslib.es6.js\";\nimport { serializeAsVector3, serialize, SerializationHelper } from \"@babylonjs/core/Misc/decorators.js\";\nimport { Vector3, Quaternion } from \"@babylonjs/core/Maths/math.vector.js\";\nimport { MaterialDefines } from \"@babylonjs/core/Materials/materialDefines.js\";\nimport { MaterialHelper } from \"@babylonjs/core/Materials/materialHelper.js\";\nimport { PushMaterial } from \"@babylonjs/core/Materials/pushMaterial.js\";\nimport { VertexBuffer } from \"@babylonjs/core/Buffers/buffer.js\";\nimport { Scene } from \"@babylonjs/core/scene.js\";\nimport { RegisterClass } from \"@babylonjs/core/Misc/typeStore.js\";\nimport \"./sky.fragment.js\";\nimport \"./sky.vertex.js\";\nimport { EffectFallbacks } from \"@babylonjs/core/Materials/effectFallbacks.js\";\nimport { addClipPlaneUniforms, bindClipPlane } from \"@babylonjs/core/Materials/clipPlaneMaterialHelper.js\";\n/** @internal */\nclass SkyMaterialDefines extends MaterialDefines {\n    constructor() {\n        super();\n        this.CLIPPLANE = false;\n        this.CLIPPLANE2 = false;\n        this.CLIPPLANE3 = false;\n        this.CLIPPLANE4 = false;\n        this.CLIPPLANE5 = false;\n        this.CLIPPLANE6 = false;\n        this.POINTSIZE = false;\n        this.FOG = false;\n        this.VERTEXCOLOR = false;\n        this.VERTEXALPHA = false;\n        this.IMAGEPROCESSINGPOSTPROCESS = false;\n        this.SKIPFINALCOLORCLAMP = false;\n        this.DITHER = false;\n        this.rebuild();\n    }\n}\n/**\n * This is the sky material which allows to create dynamic and texture free effects for skyboxes.\n * @see https://doc.babylonjs.com/toolsAndResources/assetLibraries/materialsLibrary/skyMat\n */\nexport class SkyMaterial extends PushMaterial {\n    /**\n     * Instantiates a new sky material.\n     * This material allows to create dynamic and texture free\n     * effects for skyboxes by taking care of the atmosphere state.\n     * @see https://doc.babylonjs.com/toolsAndResources/assetLibraries/materialsLibrary/skyMat\n     * @param name Define the name of the material in the scene\n     * @param scene Define the scene the material belong to\n     */\n    constructor(name, scene) {\n        super(name, scene);\n        /**\n         * Defines the overall luminance of sky in interval ]0, 1[.\n         */\n        this.luminance = 1.0;\n        /**\n         * Defines the amount (scattering) of haze as opposed to molecules in atmosphere.\n         */\n        this.turbidity = 10.0;\n        /**\n         * Defines the sky appearance (light intensity).\n         */\n        this.rayleigh = 2.0;\n        /**\n         * Defines the mieCoefficient in interval [0, 0.1] which affects the property .mieDirectionalG.\n         */\n        this.mieCoefficient = 0.005;\n        /**\n         * Defines the amount of haze particles following the Mie scattering theory.\n         */\n        this.mieDirectionalG = 0.8;\n        /**\n         * Defines the distance of the sun according to the active scene camera.\n         */\n        this.distance = 500;\n        /**\n         * Defines the sun inclination, in interval [-0.5, 0.5]. When the inclination is not 0, the sun is said\n         * \"inclined\".\n         */\n        this.inclination = 0.49;\n        /**\n         * Defines the solar azimuth in interval [0, 1]. The azimuth is the angle in the horizontal plan between\n         * an object direction and a reference direction.\n         */\n        this.azimuth = 0.25;\n        /**\n         * Defines the sun position in the sky on (x,y,z). If the property .useSunPosition is set to false, then\n         * the property is overridden by the inclination and the azimuth and can be read at any moment.\n         */\n        this.sunPosition = new Vector3(0, 100, 0);\n        /**\n         * Defines if the sun position should be computed (inclination and azimuth) according to the given\n         * .sunPosition property.\n         */\n        this.useSunPosition = false;\n        /**\n         * Defines an offset vector used to get a horizon offset.\n         * @example skyMaterial.cameraOffset.y = camera.globalPosition.y // Set horizon relative to 0 on the Y axis\n         */\n        this.cameraOffset = Vector3.Zero();\n        /**\n         * Defines the vector the skyMaterial should consider as up. (default is Vector3(0, 1, 0) as returned by Vector3.Up())\n         */\n        this.up = Vector3.Up();\n        /**\n         * Defines if sky should be dithered.\n         */\n        this.dithering = false;\n        // Private members\n        this._cameraPosition = Vector3.Zero();\n        this._skyOrientation = new Quaternion();\n    }\n    /**\n     * Specifies if the material will require alpha blending\n     * @returns a boolean specifying if alpha blending is needed\n     */\n    needAlphaBlending() {\n        return this.alpha < 1.0;\n    }\n    /**\n     * Specifies if this material should be rendered in alpha test mode\n     * @returns false as the sky material doesn't need alpha testing.\n     */\n    needAlphaTesting() {\n        return false;\n    }\n    /**\n     * Get the texture used for alpha test purpose.\n     * @returns null as the sky material has no texture.\n     */\n    getAlphaTestTexture() {\n        return null;\n    }\n    /**\n     * Get if the submesh is ready to be used and all its information available.\n     * Child classes can use it to update shaders\n     * @param mesh defines the mesh to check\n     * @param subMesh defines which submesh to check\n     * @returns a boolean indicating that the submesh is ready or not\n     */\n    isReadyForSubMesh(mesh, subMesh) {\n        if (this.isFrozen) {\n            if (subMesh.effect && subMesh.effect._wasPreviouslyReady) {\n                return true;\n            }\n        }\n        if (!subMesh.materialDefines) {\n            subMesh.materialDefines = new SkyMaterialDefines();\n        }\n        const defines = subMesh.materialDefines;\n        const scene = this.getScene();\n        if (this._isReadyForSubMesh(subMesh)) {\n            return true;\n        }\n        MaterialHelper.PrepareDefinesForMisc(mesh, scene, false, this.pointsCloud, this.fogEnabled, false, defines);\n        // Attribs\n        MaterialHelper.PrepareDefinesForAttributes(mesh, defines, true, false);\n        if (defines.IMAGEPROCESSINGPOSTPROCESS !== scene.imageProcessingConfiguration.applyByPostProcess) {\n            defines.markAsMiscDirty();\n        }\n        if (defines.DITHER !== this.dithering) {\n            defines.markAsMiscDirty();\n        }\n        // Get correct effect\n        if (defines.isDirty) {\n            defines.markAsProcessed();\n            scene.resetCachedMaterial();\n            // Fallbacks\n            const fallbacks = new EffectFallbacks();\n            if (defines.FOG) {\n                fallbacks.addFallback(1, \"FOG\");\n            }\n            defines.IMAGEPROCESSINGPOSTPROCESS = scene.imageProcessingConfiguration.applyByPostProcess;\n            defines.DITHER = this.dithering;\n            //Attributes\n            const attribs = [VertexBuffer.PositionKind];\n            if (defines.VERTEXCOLOR) {\n                attribs.push(VertexBuffer.ColorKind);\n            }\n            const shaderName = \"sky\";\n            const uniforms = [\n                \"world\",\n                \"viewProjection\",\n                \"view\",\n                \"vFogInfos\",\n                \"vFogColor\",\n                \"pointSize\",\n                \"luminance\",\n                \"turbidity\",\n                \"rayleigh\",\n                \"mieCoefficient\",\n                \"mieDirectionalG\",\n                \"sunPosition\",\n                \"cameraPosition\",\n                \"cameraOffset\",\n                \"up\",\n            ];\n            addClipPlaneUniforms(uniforms);\n            const join = defines.toString();\n            subMesh.setEffect(scene.getEngine().createEffect(shaderName, attribs, uniforms, [], join, fallbacks, this.onCompiled, this.onError), defines, this._materialContext);\n        }\n        if (!subMesh.effect || !subMesh.effect.isReady()) {\n            return false;\n        }\n        defines._renderId = scene.getRenderId();\n        subMesh.effect._wasPreviouslyReady = true;\n        return true;\n    }\n    /**\n     * Binds the submesh to this material by preparing the effect and shader to draw\n     * @param world defines the world transformation matrix\n     * @param mesh defines the mesh containing the submesh\n     * @param subMesh defines the submesh to bind the material to\n     */\n    bindForSubMesh(world, mesh, subMesh) {\n        const scene = this.getScene();\n        const defines = subMesh.materialDefines;\n        if (!defines) {\n            return;\n        }\n        const effect = subMesh.effect;\n        if (!effect) {\n            return;\n        }\n        this._activeEffect = effect;\n        // Matrices\n        this.bindOnlyWorldMatrix(world);\n        this._activeEffect.setMatrix(\"viewProjection\", scene.getTransformMatrix());\n        if (this._mustRebind(scene, effect)) {\n            bindClipPlane(effect, this, scene);\n            // Point size\n            if (this.pointsCloud) {\n                this._activeEffect.setFloat(\"pointSize\", this.pointSize);\n            }\n        }\n        // View\n        if (scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE) {\n            this._activeEffect.setMatrix(\"view\", scene.getViewMatrix());\n        }\n        // Fog\n        MaterialHelper.BindFogParameters(scene, mesh, this._activeEffect);\n        // Sky\n        const camera = scene.activeCamera;\n        if (camera) {\n            const cameraWorldMatrix = camera.getWorldMatrix();\n            this._cameraPosition.x = cameraWorldMatrix.m[12];\n            this._cameraPosition.y = cameraWorldMatrix.m[13];\n            this._cameraPosition.z = cameraWorldMatrix.m[14];\n            this._activeEffect.setVector3(\"cameraPosition\", this._cameraPosition);\n        }\n        this._activeEffect.setVector3(\"cameraOffset\", this.cameraOffset);\n        this._activeEffect.setVector3(\"up\", this.up);\n        if (this.luminance > 0) {\n            this._activeEffect.setFloat(\"luminance\", this.luminance);\n        }\n        this._activeEffect.setFloat(\"turbidity\", this.turbidity);\n        this._activeEffect.setFloat(\"rayleigh\", this.rayleigh);\n        this._activeEffect.setFloat(\"mieCoefficient\", this.mieCoefficient);\n        this._activeEffect.setFloat(\"mieDirectionalG\", this.mieDirectionalG);\n        if (!this.useSunPosition) {\n            const theta = Math.PI * (this.inclination - 0.5);\n            const phi = 2 * Math.PI * (this.azimuth - 0.5);\n            this.sunPosition.x = this.distance * Math.cos(phi) * Math.cos(theta);\n            this.sunPosition.y = this.distance * Math.sin(-theta);\n            this.sunPosition.z = this.distance * Math.sin(phi) * Math.cos(theta);\n            Quaternion.FromUnitVectorsToRef(Vector3.UpReadOnly, this.up, this._skyOrientation);\n            this.sunPosition.rotateByQuaternionToRef(this._skyOrientation, this.sunPosition);\n        }\n        this._activeEffect.setVector3(\"sunPosition\", this.sunPosition);\n        this._afterBind(mesh, this._activeEffect);\n    }\n    /**\n     * Get the list of animatables in the material.\n     * @returns the list of animatables object used in the material\n     */\n    getAnimatables() {\n        return [];\n    }\n    /**\n     * Disposes the material\n     * @param forceDisposeEffect specifies if effects should be forcefully disposed\n     */\n    dispose(forceDisposeEffect) {\n        super.dispose(forceDisposeEffect);\n    }\n    /**\n     * Makes a duplicate of the material, and gives it a new name\n     * @param name defines the new name for the duplicated material\n     * @returns the cloned material\n     */\n    clone(name) {\n        return SerializationHelper.Clone(() => new SkyMaterial(name, this.getScene()), this);\n    }\n    /**\n     * Serializes this material in a JSON representation\n     * @returns the serialized material object\n     */\n    serialize() {\n        const serializationObject = super.serialize();\n        serializationObject.customType = \"BABYLON.SkyMaterial\";\n        return serializationObject;\n    }\n    /**\n     * Gets the current class name of the material e.g. \"SkyMaterial\"\n     * Mainly use in serialization.\n     * @returns the class name\n     */\n    getClassName() {\n        return \"SkyMaterial\";\n    }\n    /**\n     * Creates a sky material from parsed material data\n     * @param source defines the JSON representation of the material\n     * @param scene defines the hosting scene\n     * @param rootUrl defines the root URL to use to load textures and relative dependencies\n     * @returns a new sky material\n     */\n    static Parse(source, scene, rootUrl) {\n        return SerializationHelper.Parse(() => new SkyMaterial(source.name, scene), source, scene, rootUrl);\n    }\n}\n__decorate([\n    serialize()\n], SkyMaterial.prototype, \"luminance\", void 0);\n__decorate([\n    serialize()\n], SkyMaterial.prototype, \"turbidity\", void 0);\n__decorate([\n    serialize()\n], SkyMaterial.prototype, \"rayleigh\", void 0);\n__decorate([\n    serialize()\n], SkyMaterial.prototype, \"mieCoefficient\", void 0);\n__decorate([\n    serialize()\n], SkyMaterial.prototype, \"mieDirectionalG\", void 0);\n__decorate([\n    serialize()\n], SkyMaterial.prototype, \"distance\", void 0);\n__decorate([\n    serialize()\n], SkyMaterial.prototype, \"inclination\", void 0);\n__decorate([\n    serialize()\n], SkyMaterial.prototype, \"azimuth\", void 0);\n__decorate([\n    serializeAsVector3()\n], SkyMaterial.prototype, \"sunPosition\", void 0);\n__decorate([\n    serialize()\n], SkyMaterial.prototype, \"useSunPosition\", void 0);\n__decorate([\n    serializeAsVector3()\n], SkyMaterial.prototype, \"cameraOffset\", void 0);\n__decorate([\n    serializeAsVector3()\n], SkyMaterial.prototype, \"up\", void 0);\n__decorate([\n    serialize()\n], SkyMaterial.prototype, \"dithering\", void 0);\nRegisterClass(\"BABYLON.SkyMaterial\", SkyMaterial);\n//# sourceMappingURL=skyMaterial.js.map","// Do not edit.\nimport { ShaderStore } from \"@babylonjs/core/Engines/shaderStore.js\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/helperFunctions.js\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/imageProcessingDeclaration.js\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/imageProcessingFunctions.js\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/lightFragmentDeclaration.js\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/lightUboDeclaration.js\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/lightsFragmentFunctions.js\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/shadowsFragmentFunctions.js\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/clipPlaneFragmentDeclaration.js\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/logDepthDeclaration.js\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/fogFragmentDeclaration.js\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/clipPlaneFragment.js\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/lightFragment.js\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/logDepthFragment.js\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/fogFragment.js\";\nconst name = \"waterPixelShader\";\nconst shader = `#ifdef LOGARITHMICDEPTH\n#extension GL_EXT_frag_depth : enable\n#endif\nprecision highp float;\runiform vec4 vEyePosition;\runiform vec4 vDiffuseColor;\r#ifdef SPECULARTERM\nuniform vec4 vSpecularColor;\r#endif\nvarying vec3 vPositionW;\r#ifdef NORMAL\nvarying vec3 vNormalW;\r#endif\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nvarying vec4 vColor;\r#endif\n#include<helperFunctions>\n#include<imageProcessingDeclaration>\n#include<imageProcessingFunctions>\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\n#include<lightsFragmentFunctions>\n#include<shadowsFragmentFunctions>\n#ifdef BUMP\nvarying vec2 vNormalUV;\r#ifdef BUMPSUPERIMPOSE\nvarying vec2 vNormalUV2;\r#endif\nuniform sampler2D normalSampler;\runiform vec2 vNormalInfos;\r#endif\nuniform sampler2D refractionSampler;\runiform sampler2D reflectionSampler;\rconst float LOG2=1.442695;\runiform vec3 cameraPosition;\runiform vec4 waterColor;\runiform float colorBlendFactor;\runiform vec4 waterColor2;\runiform float colorBlendFactor2;\runiform float bumpHeight;\runiform float time;\rvarying vec3 vRefractionMapTexCoord;\rvarying vec3 vReflectionMapTexCoord;\rvarying vec3 vPosition;\r#include<clipPlaneFragmentDeclaration>\n#include<logDepthDeclaration>\n#include<fogFragmentDeclaration>\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) {\r#define CUSTOM_FRAGMENT_MAIN_BEGIN\n#include<clipPlaneFragment>\nvec3 viewDirectionW=normalize(vEyePosition.xyz-vPositionW);\rvec4 baseColor=vec4(1.,1.,1.,1.);\rvec3 diffuseColor=vDiffuseColor.rgb;\rfloat alpha=vDiffuseColor.a;\r#ifdef BUMP\n#ifdef BUMPSUPERIMPOSE\nbaseColor=0.6*texture2D(normalSampler,vNormalUV)+0.4*texture2D(normalSampler,vec2(vNormalUV2.x,vNormalUV2.y));\r#else\nbaseColor=texture2D(normalSampler,vNormalUV);\r#endif\nvec3 bumpColor=baseColor.rgb;\r#ifdef ALPHATEST\nif (baseColor.a<0.4)\rdiscard;\r#endif\nbaseColor.rgb*=vNormalInfos.y;\r#else\nvec3 bumpColor=vec3(1.0);\r#endif\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nbaseColor.rgb*=vColor.rgb;\r#endif\n#ifdef NORMAL\nvec2 perturbation=bumpHeight*(baseColor.rg-0.5);\r#ifdef BUMPAFFECTSREFLECTION\nvec3 normalW=normalize(vNormalW+vec3(perturbation.x*8.0,0.0,perturbation.y*8.0));\rif (normalW.y<0.0) {\rnormalW.y=-normalW.y;\r}\r#else\nvec3 normalW=normalize(vNormalW);\r#endif\n#else\nvec3 normalW=vec3(1.0,1.0,1.0);\rvec2 perturbation=bumpHeight*(vec2(1.0,1.0)-0.5);\r#endif\n#ifdef FRESNELSEPARATE\n#ifdef REFLECTION\nvec2 projectedRefractionTexCoords=clamp(vRefractionMapTexCoord.xy/vRefractionMapTexCoord.z+perturbation*0.5,0.0,1.0);\rvec4 refractiveColor=texture2D(refractionSampler,projectedRefractionTexCoords);\r#ifdef IS_REFRACTION_LINEAR\nrefractiveColor.rgb=toGammaSpace(refractiveColor.rgb);\r#endif\nvec2 projectedReflectionTexCoords=clamp(vec2(\rvReflectionMapTexCoord.x/vReflectionMapTexCoord.z+perturbation.x*0.3,\rvReflectionMapTexCoord.y/vReflectionMapTexCoord.z+perturbation.y\r),0.0,1.0);\rvec4 reflectiveColor=texture2D(reflectionSampler,projectedReflectionTexCoords);\r#ifdef IS_REFLECTION_LINEAR\nreflectiveColor.rgb=toGammaSpace(reflectiveColor.rgb);\r#endif\nvec3 upVector=vec3(0.0,1.0,0.0);\rfloat fresnelTerm=clamp(abs(pow(dot(viewDirectionW,upVector),3.0)),0.05,0.65);\rfloat IfresnelTerm=1.0-fresnelTerm;\rrefractiveColor=colorBlendFactor*waterColor+(1.0-colorBlendFactor)*refractiveColor;\rreflectiveColor=IfresnelTerm*colorBlendFactor2*waterColor+(1.0-colorBlendFactor2*IfresnelTerm)*reflectiveColor;\rvec4 combinedColor=refractiveColor*fresnelTerm+reflectiveColor*IfresnelTerm;\rbaseColor=combinedColor;\r#endif\nvec3 diffuseBase=vec3(0.,0.,0.);\rlightingInfo info;\rfloat shadow=1.;\r#ifdef SPECULARTERM\nfloat glossiness=vSpecularColor.a;\rvec3 specularBase=vec3(0.,0.,0.);\rvec3 specularColor=vSpecularColor.rgb;\r#else\nfloat glossiness=0.;\r#endif\n#include<lightFragment>[0..maxSimultaneousLights]\nvec3 finalDiffuse=clamp(baseColor.rgb,0.0,1.0);\r#if defined(VERTEXALPHA) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nalpha*=vColor.a;\r#endif\n#ifdef SPECULARTERM\nvec3 finalSpecular=specularBase*specularColor;\r#else\nvec3 finalSpecular=vec3(0.0);\r#endif\n#else \n#ifdef REFLECTION\nvec2 projectedRefractionTexCoords=clamp(vRefractionMapTexCoord.xy/vRefractionMapTexCoord.z+perturbation,0.0,1.0);\rvec4 refractiveColor=texture2D(refractionSampler,projectedRefractionTexCoords);\r#ifdef IS_REFRACTION_LINEAR\nrefractiveColor.rgb=toGammaSpace(refractiveColor.rgb);\r#endif\nvec2 projectedReflectionTexCoords=clamp(vReflectionMapTexCoord.xy/vReflectionMapTexCoord.z+perturbation,0.0,1.0);\rvec4 reflectiveColor=texture2D(reflectionSampler,projectedReflectionTexCoords);\r#ifdef IS_REFLECTION_LINEAR\nreflectiveColor.rgb=toGammaSpace(reflectiveColor.rgb);\r#endif\nvec3 upVector=vec3(0.0,1.0,0.0);\rfloat fresnelTerm=max(dot(viewDirectionW,upVector),0.0);\rvec4 combinedColor=refractiveColor*fresnelTerm+reflectiveColor*(1.0-fresnelTerm);\rbaseColor=colorBlendFactor*waterColor+(1.0-colorBlendFactor)*combinedColor;\r#endif\nvec3 diffuseBase=vec3(0.,0.,0.);\rlightingInfo info;\rfloat shadow=1.;\r#ifdef SPECULARTERM\nfloat glossiness=vSpecularColor.a;\rvec3 specularBase=vec3(0.,0.,0.);\rvec3 specularColor=vSpecularColor.rgb;\r#else\nfloat glossiness=0.;\r#endif\n#include<lightFragment>[0..maxSimultaneousLights]\nvec3 finalDiffuse=clamp(baseColor.rgb,0.0,1.0);\r#if defined(VERTEXALPHA) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nalpha*=vColor.a;\r#endif\n#ifdef SPECULARTERM\nvec3 finalSpecular=specularBase*specularColor;\r#else\nvec3 finalSpecular=vec3(0.0);\r#endif\n#endif\nvec4 color=vec4(finalDiffuse+finalSpecular,alpha);\r#include<logDepthFragment>\n#include<fogFragment>\n#ifdef IMAGEPROCESSINGPOSTPROCESS\ncolor.rgb=toLinearSpace(color.rgb);\r#elif defined(IMAGEPROCESSING)\ncolor.rgb=toLinearSpace(color.rgb);\rcolor=applyImageProcessing(color);\r#endif\ngl_FragColor=color;\r#define CUSTOM_FRAGMENT_MAIN_END\n}\r`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const waterPixelShader = { name, shader };\n//# sourceMappingURL=water.fragment.js.map","// Do not edit.\nimport { ShaderStore } from \"@babylonjs/core/Engines/shaderStore.js\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/bonesDeclaration.js\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/bakedVertexAnimationDeclaration.js\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/instancesDeclaration.js\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/clipPlaneVertexDeclaration.js\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/fogVertexDeclaration.js\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/lightFragmentDeclaration.js\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/lightUboDeclaration.js\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/logDepthDeclaration.js\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/instancesVertex.js\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/bonesVertex.js\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/bakedVertexAnimation.js\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/clipPlaneVertex.js\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/fogVertex.js\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/shadowsVertex.js\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/vertexColorMixing.js\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/logDepthVertex.js\";\nconst name = \"waterVertexShader\";\nconst shader = `precision highp float;\rattribute vec3 position;\r#ifdef NORMAL\nattribute vec3 normal;\r#endif\n#ifdef UV1\nattribute vec2 uv;\r#endif\n#ifdef UV2\nattribute vec2 uv2;\r#endif\n#ifdef VERTEXCOLOR\nattribute vec4 color;\r#endif\n#include<bonesDeclaration>\n#include<bakedVertexAnimationDeclaration>\n#include<instancesDeclaration>\nuniform mat4 view;\runiform mat4 viewProjection;\r#ifdef BUMP\nvarying vec2 vNormalUV;\r#ifdef BUMPSUPERIMPOSE\nvarying vec2 vNormalUV2;\r#endif\nuniform mat4 normalMatrix;\runiform vec2 vNormalInfos;\r#endif\n#ifdef POINTSIZE\nuniform float pointSize;\r#endif\nvarying vec3 vPositionW;\r#ifdef NORMAL\nvarying vec3 vNormalW;\r#endif\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nvarying vec4 vColor;\r#endif\n#include<clipPlaneVertexDeclaration>\n#include<fogVertexDeclaration>\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\n#include<logDepthDeclaration>\nuniform mat4 worldReflectionViewProjection;\runiform vec2 windDirection;\runiform float waveLength;\runiform float time;\runiform float windForce;\runiform float waveHeight;\runiform float waveSpeed;\runiform float waveCount;\rvarying vec3 vPosition;\rvarying vec3 vRefractionMapTexCoord;\rvarying vec3 vReflectionMapTexCoord;\r#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void) {\r#define CUSTOM_VERTEX_MAIN_BEGIN\n#include<instancesVertex>\n#include<bonesVertex>\n#include<bakedVertexAnimation>\nvec4 worldPos=finalWorld*vec4(position,1.0);\rvPositionW=vec3(worldPos);\r#ifdef NORMAL\nvNormalW=normalize(vec3(finalWorld*vec4(normal,0.0)));\r#endif\n#ifndef UV1\nvec2 uv=vec2(0.,0.);\r#endif\n#ifndef UV2\nvec2 uv2=vec2(0.,0.);\r#endif\n#ifdef BUMP\nif (vNormalInfos.x==0.)\r{\rvNormalUV=vec2(normalMatrix*vec4((uv*1.0)/waveLength+time*windForce*windDirection,1.0,0.0));\r#ifdef BUMPSUPERIMPOSE\nvNormalUV2=vec2(normalMatrix*vec4((uv*0.721)/waveLength+time*1.2*windForce*windDirection,1.0,0.0));\r#endif\n}\relse\r{\rvNormalUV=vec2(normalMatrix*vec4((uv2*1.0)/waveLength+time*windForce*windDirection ,1.0,0.0));\r#ifdef BUMPSUPERIMPOSE\nvNormalUV2=vec2(normalMatrix*vec4((uv2*0.721)/waveLength+time*1.2*windForce*windDirection ,1.0,0.0));\r#endif\n}\r#endif\n#include<clipPlaneVertex>\n#include<fogVertex>\n#include<shadowsVertex>[0..maxSimultaneousLights]\n#include<vertexColorMixing>\n#if defined(POINTSIZE) && !defined(WEBGPU)\ngl_PointSize=pointSize;\r#endif\nfloat finalWaveCount=1.0/(waveCount*0.5);\rvec3 p=position;\rfloat newY=(sin(((p.x/finalWaveCount)+time*waveSpeed))*waveHeight*windDirection.x*5.0)\r+ (cos(((p.z/finalWaveCount)+ time*waveSpeed))*waveHeight*windDirection.y*5.0);\rp.y+=abs(newY);\rgl_Position=viewProjection*finalWorld*vec4(p,1.0);\r#ifdef REFLECTION\nworldPos=viewProjection*finalWorld*vec4(p,1.0);\rvPosition=position;\rvRefractionMapTexCoord.x=0.5*(worldPos.w+worldPos.x);\rvRefractionMapTexCoord.y=0.5*(worldPos.w+worldPos.y);\rvRefractionMapTexCoord.z=worldPos.w;\rworldPos=worldReflectionViewProjection*vec4(position,1.0);\rvReflectionMapTexCoord.x=0.5*(worldPos.w+worldPos.x);\rvReflectionMapTexCoord.y=0.5*(worldPos.w+worldPos.y);\rvReflectionMapTexCoord.z=worldPos.w;\r#endif\n#include<logDepthVertex>\n#define CUSTOM_VERTEX_MAIN_END\n}\r`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const waterVertexShader = { name, shader };\n//# sourceMappingURL=water.vertex.js.map","import { __decorate } from \"@babylonjs/core/tslib.es6.js\";\nimport { serializeAsVector2, serializeAsTexture, serialize, expandToProperty, serializeAsColor3, SerializationHelper } from \"@babylonjs/core/Misc/decorators.js\";\nimport { Matrix, Vector2, Vector3 } from \"@babylonjs/core/Maths/math.vector.js\";\nimport { Color3 } from \"@babylonjs/core/Maths/math.color.js\";\nimport { Plane } from \"@babylonjs/core/Maths/math.plane.js\";\nimport { Constants } from \"@babylonjs/core/Engines/constants.js\";\nimport { SmartArray } from \"@babylonjs/core/Misc/smartArray.js\";\nimport { RenderTargetTexture } from \"@babylonjs/core/Materials/Textures/renderTargetTexture.js\";\nimport { MaterialDefines } from \"@babylonjs/core/Materials/materialDefines.js\";\nimport { ImageProcessingConfiguration } from \"@babylonjs/core/Materials/imageProcessingConfiguration.js\";\nimport { MaterialHelper } from \"@babylonjs/core/Materials/materialHelper.js\";\nimport { PushMaterial } from \"@babylonjs/core/Materials/pushMaterial.js\";\nimport { MaterialFlags } from \"@babylonjs/core/Materials/materialFlags.js\";\nimport { VertexBuffer } from \"@babylonjs/core/Buffers/buffer.js\";\nimport { Scene } from \"@babylonjs/core/scene.js\";\nimport { RegisterClass } from \"@babylonjs/core/Misc/typeStore.js\";\nimport \"./water.fragment.js\";\nimport \"./water.vertex.js\";\nimport { EffectFallbacks } from \"@babylonjs/core/Materials/effectFallbacks.js\";\nimport { CreateGround } from \"@babylonjs/core/Meshes/Builders/groundBuilder.js\";\nimport { addClipPlaneUniforms, bindClipPlane } from \"@babylonjs/core/Materials/clipPlaneMaterialHelper.js\";\nclass WaterMaterialDefines extends MaterialDefines {\n    constructor() {\n        super();\n        this.BUMP = false;\n        this.REFLECTION = false;\n        this.CLIPPLANE = false;\n        this.CLIPPLANE2 = false;\n        this.CLIPPLANE3 = false;\n        this.CLIPPLANE4 = false;\n        this.CLIPPLANE5 = false;\n        this.CLIPPLANE6 = false;\n        this.ALPHATEST = false;\n        this.DEPTHPREPASS = false;\n        this.POINTSIZE = false;\n        this.FOG = false;\n        this.NORMAL = false;\n        this.UV1 = false;\n        this.UV2 = false;\n        this.VERTEXCOLOR = false;\n        this.VERTEXALPHA = false;\n        this.NUM_BONE_INFLUENCERS = 0;\n        this.BonesPerMesh = 0;\n        this.INSTANCES = false;\n        this.INSTANCESCOLOR = false;\n        this.SPECULARTERM = false;\n        this.LOGARITHMICDEPTH = false;\n        this.USE_REVERSE_DEPTHBUFFER = false;\n        this.FRESNELSEPARATE = false;\n        this.BUMPSUPERIMPOSE = false;\n        this.BUMPAFFECTSREFLECTION = false;\n        this.IMAGEPROCESSING = false;\n        this.VIGNETTE = false;\n        this.VIGNETTEBLENDMODEMULTIPLY = false;\n        this.VIGNETTEBLENDMODEOPAQUE = false;\n        this.TONEMAPPING = false;\n        this.TONEMAPPING_ACES = false;\n        this.CONTRAST = false;\n        this.EXPOSURE = false;\n        this.COLORCURVES = false;\n        this.COLORGRADING = false;\n        this.COLORGRADING3D = false;\n        this.SAMPLER3DGREENDEPTH = false;\n        this.SAMPLER3DBGRMAP = false;\n        this.DITHER = false;\n        this.IMAGEPROCESSINGPOSTPROCESS = false;\n        this.SKIPFINALCOLORCLAMP = false;\n        this.rebuild();\n    }\n}\nexport class WaterMaterial extends PushMaterial {\n    /**\n     * Gets a boolean indicating that current material needs to register RTT\n     */\n    get hasRenderTargetTextures() {\n        return true;\n    }\n    /**\n     * Constructor\n     * @param name\n     * @param scene\n     * @param renderTargetSize\n     */\n    constructor(name, scene, renderTargetSize = new Vector2(512, 512)) {\n        super(name, scene);\n        this.renderTargetSize = renderTargetSize;\n        this.diffuseColor = new Color3(1, 1, 1);\n        this.specularColor = new Color3(0, 0, 0);\n        this.specularPower = 64;\n        this._disableLighting = false;\n        this._maxSimultaneousLights = 4;\n        /**\n         * Defines the wind force.\n         */\n        this.windForce = 6;\n        /**\n         * Defines the direction of the wind in the plane (X, Z).\n         */\n        this.windDirection = new Vector2(0, 1);\n        /**\n         * Defines the height of the waves.\n         */\n        this.waveHeight = 0.4;\n        /**\n         * Defines the bump height related to the bump map.\n         */\n        this.bumpHeight = 0.4;\n        /**\n         * Defines wether or not: to add a smaller moving bump to less steady waves.\n         */\n        this._bumpSuperimpose = false;\n        /**\n         * Defines wether or not color refraction and reflection differently with .waterColor2 and .colorBlendFactor2. Non-linear (physically correct) fresnel.\n         */\n        this._fresnelSeparate = false;\n        /**\n         * Defines wether or not bump Wwves modify the reflection.\n         */\n        this._bumpAffectsReflection = false;\n        /**\n         * Defines the water color blended with the refraction (near).\n         */\n        this.waterColor = new Color3(0.1, 0.1, 0.6);\n        /**\n         * Defines the blend factor related to the water color.\n         */\n        this.colorBlendFactor = 0.2;\n        /**\n         * Defines the water color blended with the reflection (far).\n         */\n        this.waterColor2 = new Color3(0.1, 0.1, 0.6);\n        /**\n         * Defines the blend factor related to the water color (reflection, far).\n         */\n        this.colorBlendFactor2 = 0.2;\n        /**\n         * Defines the maximum length of a wave.\n         */\n        this.waveLength = 0.1;\n        /**\n         * Defines the waves speed.\n         */\n        this.waveSpeed = 1.0;\n        /**\n         * Defines the number of times waves are repeated. This is typically used to adjust waves count according to the ground's size where the material is applied on.\n         */\n        this.waveCount = 20;\n        /**\n         * Sets or gets whether or not automatic clipping should be enabled or not. Setting to true will save performances and\n         * will avoid calculating useless pixels in the pixel shader of the water material.\n         */\n        this.disableClipPlane = false;\n        this._renderTargets = new SmartArray(16);\n        /*\n         * Private members\n         */\n        this._mesh = null;\n        this._reflectionTransform = Matrix.Zero();\n        this._lastTime = 0;\n        this._lastDeltaTime = 0;\n        this._createRenderTargets(this.getScene(), renderTargetSize);\n        // Create render targets\n        this.getRenderTargetTextures = () => {\n            this._renderTargets.reset();\n            this._renderTargets.push(this._reflectionRTT);\n            this._renderTargets.push(this._refractionRTT);\n            return this._renderTargets;\n        };\n        this._imageProcessingConfiguration = this.getScene().imageProcessingConfiguration;\n        if (this._imageProcessingConfiguration) {\n            this._imageProcessingObserver = this._imageProcessingConfiguration.onUpdateParameters.add(() => {\n                this._markAllSubMeshesAsImageProcessingDirty();\n            });\n        }\n    }\n    get useLogarithmicDepth() {\n        return this._useLogarithmicDepth;\n    }\n    set useLogarithmicDepth(value) {\n        this._useLogarithmicDepth = value && this.getScene().getEngine().getCaps().fragmentDepthSupported;\n        this._markAllSubMeshesAsMiscDirty();\n    }\n    // Get / Set\n    get refractionTexture() {\n        return this._refractionRTT;\n    }\n    get reflectionTexture() {\n        return this._reflectionRTT;\n    }\n    // Methods\n    addToRenderList(node) {\n        if (this._refractionRTT && this._refractionRTT.renderList) {\n            this._refractionRTT.renderList.push(node);\n        }\n        if (this._reflectionRTT && this._reflectionRTT.renderList) {\n            this._reflectionRTT.renderList.push(node);\n        }\n    }\n    enableRenderTargets(enable) {\n        const refreshRate = enable ? 1 : 0;\n        if (this._refractionRTT) {\n            this._refractionRTT.refreshRate = refreshRate;\n        }\n        if (this._reflectionRTT) {\n            this._reflectionRTT.refreshRate = refreshRate;\n        }\n    }\n    getRenderList() {\n        return this._refractionRTT ? this._refractionRTT.renderList : [];\n    }\n    get renderTargetsEnabled() {\n        return !(this._refractionRTT && this._refractionRTT.refreshRate === 0);\n    }\n    needAlphaBlending() {\n        return this.alpha < 1.0;\n    }\n    needAlphaTesting() {\n        return false;\n    }\n    getAlphaTestTexture() {\n        return null;\n    }\n    isReadyForSubMesh(mesh, subMesh, useInstances) {\n        if (this.isFrozen) {\n            if (subMesh.effect && subMesh.effect._wasPreviouslyReady && subMesh.effect._wasPreviouslyUsingInstances === useInstances) {\n                return true;\n            }\n        }\n        if (!subMesh.materialDefines) {\n            subMesh.materialDefines = new WaterMaterialDefines();\n        }\n        const defines = subMesh.materialDefines;\n        const scene = this.getScene();\n        if (this._isReadyForSubMesh(subMesh)) {\n            return true;\n        }\n        const engine = scene.getEngine();\n        // Textures\n        if (defines._areTexturesDirty) {\n            defines._needUVs = false;\n            if (scene.texturesEnabled) {\n                if (this.bumpTexture && MaterialFlags.BumpTextureEnabled) {\n                    if (!this.bumpTexture.isReady()) {\n                        return false;\n                    }\n                    else {\n                        defines._needUVs = true;\n                        defines.BUMP = true;\n                    }\n                }\n                if (MaterialFlags.ReflectionTextureEnabled) {\n                    defines.REFLECTION = true;\n                }\n            }\n        }\n        MaterialHelper.PrepareDefinesForFrameBoundValues(scene, engine, this, defines, useInstances ? true : false);\n        MaterialHelper.PrepareDefinesForMisc(mesh, scene, this._useLogarithmicDepth, this.pointsCloud, this.fogEnabled, this._shouldTurnAlphaTestOn(mesh), defines);\n        if (defines._areMiscDirty) {\n            if (this._fresnelSeparate) {\n                defines.FRESNELSEPARATE = true;\n            }\n            if (this._bumpSuperimpose) {\n                defines.BUMPSUPERIMPOSE = true;\n            }\n            if (this._bumpAffectsReflection) {\n                defines.BUMPAFFECTSREFLECTION = true;\n            }\n        }\n        // Lights\n        defines._needNormals = MaterialHelper.PrepareDefinesForLights(scene, mesh, defines, true, this._maxSimultaneousLights, this._disableLighting);\n        // Image processing\n        if (defines._areImageProcessingDirty && this._imageProcessingConfiguration) {\n            if (!this._imageProcessingConfiguration.isReady()) {\n                return false;\n            }\n            this._imageProcessingConfiguration.prepareDefines(defines);\n            defines.IS_REFLECTION_LINEAR = this.reflectionTexture != null && !this.reflectionTexture.gammaSpace;\n            defines.IS_REFRACTION_LINEAR = this.refractionTexture != null && !this.refractionTexture.gammaSpace;\n        }\n        // Attribs\n        MaterialHelper.PrepareDefinesForAttributes(mesh, defines, true, true);\n        // Configure this\n        this._mesh = mesh;\n        if (this._waitingRenderList) {\n            for (let i = 0; i < this._waitingRenderList.length; i++) {\n                this.addToRenderList(scene.getNodeById(this._waitingRenderList[i]));\n            }\n            this._waitingRenderList = null;\n        }\n        // Get correct effect\n        if (defines.isDirty) {\n            defines.markAsProcessed();\n            scene.resetCachedMaterial();\n            // Fallbacks\n            const fallbacks = new EffectFallbacks();\n            if (defines.FOG) {\n                fallbacks.addFallback(1, \"FOG\");\n            }\n            if (defines.LOGARITHMICDEPTH) {\n                fallbacks.addFallback(0, \"LOGARITHMICDEPTH\");\n            }\n            MaterialHelper.HandleFallbacksForShadows(defines, fallbacks, this.maxSimultaneousLights);\n            if (defines.NUM_BONE_INFLUENCERS > 0) {\n                fallbacks.addCPUSkinningFallback(0, mesh);\n            }\n            //Attributes\n            const attribs = [VertexBuffer.PositionKind];\n            if (defines.NORMAL) {\n                attribs.push(VertexBuffer.NormalKind);\n            }\n            if (defines.UV1) {\n                attribs.push(VertexBuffer.UVKind);\n            }\n            if (defines.UV2) {\n                attribs.push(VertexBuffer.UV2Kind);\n            }\n            if (defines.VERTEXCOLOR) {\n                attribs.push(VertexBuffer.ColorKind);\n            }\n            MaterialHelper.PrepareAttributesForBones(attribs, mesh, defines, fallbacks);\n            MaterialHelper.PrepareAttributesForInstances(attribs, defines);\n            // Legacy browser patch\n            const shaderName = \"water\";\n            const join = defines.toString();\n            const uniforms = [\n                \"world\",\n                \"view\",\n                \"viewProjection\",\n                \"vEyePosition\",\n                \"vLightsType\",\n                \"vDiffuseColor\",\n                \"vSpecularColor\",\n                \"vFogInfos\",\n                \"vFogColor\",\n                \"pointSize\",\n                \"vNormalInfos\",\n                \"mBones\",\n                \"normalMatrix\",\n                \"logarithmicDepthConstant\",\n                // Water\n                \"worldReflectionViewProjection\",\n                \"windDirection\",\n                \"waveLength\",\n                \"time\",\n                \"windForce\",\n                \"cameraPosition\",\n                \"bumpHeight\",\n                \"waveHeight\",\n                \"waterColor\",\n                \"waterColor2\",\n                \"colorBlendFactor\",\n                \"colorBlendFactor2\",\n                \"waveSpeed\",\n                \"waveCount\",\n            ];\n            const samplers = [\n                \"normalSampler\",\n                // Water\n                \"refractionSampler\",\n                \"reflectionSampler\",\n            ];\n            const uniformBuffers = new Array();\n            if (ImageProcessingConfiguration) {\n                ImageProcessingConfiguration.PrepareUniforms(uniforms, defines);\n                ImageProcessingConfiguration.PrepareSamplers(samplers, defines);\n            }\n            addClipPlaneUniforms(uniforms);\n            MaterialHelper.PrepareUniformsAndSamplersList({\n                uniformsNames: uniforms,\n                uniformBuffersNames: uniformBuffers,\n                samplers: samplers,\n                defines: defines,\n                maxSimultaneousLights: this.maxSimultaneousLights,\n            });\n            subMesh.setEffect(scene.getEngine().createEffect(shaderName, {\n                attributes: attribs,\n                uniformsNames: uniforms,\n                uniformBuffersNames: uniformBuffers,\n                samplers: samplers,\n                defines: join,\n                fallbacks: fallbacks,\n                onCompiled: this.onCompiled,\n                onError: this.onError,\n                indexParameters: { maxSimultaneousLights: this._maxSimultaneousLights },\n            }, engine), defines, this._materialContext);\n        }\n        if (!subMesh.effect || !subMesh.effect.isReady()) {\n            return false;\n        }\n        defines._renderId = scene.getRenderId();\n        subMesh.effect._wasPreviouslyReady = true;\n        subMesh.effect._wasPreviouslyUsingInstances = !!useInstances;\n        return true;\n    }\n    bindForSubMesh(world, mesh, subMesh) {\n        const scene = this.getScene();\n        const defines = subMesh.materialDefines;\n        if (!defines) {\n            return;\n        }\n        const effect = subMesh.effect;\n        if (!effect || !this._mesh) {\n            return;\n        }\n        this._activeEffect = effect;\n        // Matrices\n        this.bindOnlyWorldMatrix(world);\n        this._activeEffect.setMatrix(\"viewProjection\", scene.getTransformMatrix());\n        // Bones\n        MaterialHelper.BindBonesParameters(mesh, this._activeEffect);\n        if (this._mustRebind(scene, effect)) {\n            // Textures\n            if (this.bumpTexture && MaterialFlags.BumpTextureEnabled) {\n                this._activeEffect.setTexture(\"normalSampler\", this.bumpTexture);\n                this._activeEffect.setFloat2(\"vNormalInfos\", this.bumpTexture.coordinatesIndex, this.bumpTexture.level);\n                this._activeEffect.setMatrix(\"normalMatrix\", this.bumpTexture.getTextureMatrix());\n            }\n            // Clip plane\n            bindClipPlane(effect, this, scene);\n            // Point size\n            if (this.pointsCloud) {\n                this._activeEffect.setFloat(\"pointSize\", this.pointSize);\n            }\n            scene.bindEyePosition(effect);\n        }\n        this._activeEffect.setColor4(\"vDiffuseColor\", this.diffuseColor, this.alpha * mesh.visibility);\n        if (defines.SPECULARTERM) {\n            this._activeEffect.setColor4(\"vSpecularColor\", this.specularColor, this.specularPower);\n        }\n        if (scene.lightsEnabled && !this.disableLighting) {\n            MaterialHelper.BindLights(scene, mesh, this._activeEffect, defines, this.maxSimultaneousLights);\n        }\n        // View\n        if (scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE) {\n            this._activeEffect.setMatrix(\"view\", scene.getViewMatrix());\n        }\n        // Fog\n        MaterialHelper.BindFogParameters(scene, mesh, this._activeEffect);\n        // Log. depth\n        MaterialHelper.BindLogDepth(defines, this._activeEffect, scene);\n        // Water\n        if (MaterialFlags.ReflectionTextureEnabled) {\n            this._activeEffect.setTexture(\"refractionSampler\", this._refractionRTT);\n            this._activeEffect.setTexture(\"reflectionSampler\", this._reflectionRTT);\n        }\n        const wrvp = this._mesh.getWorldMatrix().multiply(this._reflectionTransform).multiply(scene.getProjectionMatrix());\n        // Add delta time. Prevent adding delta time if it hasn't changed.\n        const deltaTime = scene.getEngine().getDeltaTime();\n        if (deltaTime !== this._lastDeltaTime) {\n            this._lastDeltaTime = deltaTime;\n            this._lastTime += this._lastDeltaTime;\n        }\n        this._activeEffect.setMatrix(\"worldReflectionViewProjection\", wrvp);\n        this._activeEffect.setVector2(\"windDirection\", this.windDirection);\n        this._activeEffect.setFloat(\"waveLength\", this.waveLength);\n        this._activeEffect.setFloat(\"time\", this._lastTime / 100000);\n        this._activeEffect.setFloat(\"windForce\", this.windForce);\n        this._activeEffect.setFloat(\"waveHeight\", this.waveHeight);\n        this._activeEffect.setFloat(\"bumpHeight\", this.bumpHeight);\n        this._activeEffect.setColor4(\"waterColor\", this.waterColor, 1.0);\n        this._activeEffect.setFloat(\"colorBlendFactor\", this.colorBlendFactor);\n        this._activeEffect.setColor4(\"waterColor2\", this.waterColor2, 1.0);\n        this._activeEffect.setFloat(\"colorBlendFactor2\", this.colorBlendFactor2);\n        this._activeEffect.setFloat(\"waveSpeed\", this.waveSpeed);\n        this._activeEffect.setFloat(\"waveCount\", this.waveCount);\n        // image processing\n        if (this._imageProcessingConfiguration && !this._imageProcessingConfiguration.applyByPostProcess) {\n            this._imageProcessingConfiguration.bind(this._activeEffect);\n        }\n        this._afterBind(mesh, this._activeEffect);\n    }\n    _createRenderTargets(scene, renderTargetSize) {\n        // Render targets\n        this._refractionRTT = new RenderTargetTexture(name + \"_refraction\", { width: renderTargetSize.x, height: renderTargetSize.y }, scene, false, true);\n        this._refractionRTT.wrapU = Constants.TEXTURE_MIRROR_ADDRESSMODE;\n        this._refractionRTT.wrapV = Constants.TEXTURE_MIRROR_ADDRESSMODE;\n        this._refractionRTT.ignoreCameraViewport = true;\n        this._reflectionRTT = new RenderTargetTexture(name + \"_reflection\", { width: renderTargetSize.x, height: renderTargetSize.y }, scene, false, true);\n        this._reflectionRTT.wrapU = Constants.TEXTURE_MIRROR_ADDRESSMODE;\n        this._reflectionRTT.wrapV = Constants.TEXTURE_MIRROR_ADDRESSMODE;\n        this._reflectionRTT.ignoreCameraViewport = true;\n        let isVisible;\n        let clipPlane = null;\n        let savedViewMatrix;\n        const mirrorMatrix = Matrix.Zero();\n        this._refractionRTT.onBeforeRender = () => {\n            if (this._mesh) {\n                isVisible = this._mesh.isVisible;\n                this._mesh.isVisible = false;\n            }\n            // Clip plane\n            if (!this.disableClipPlane) {\n                clipPlane = scene.clipPlane;\n                const positiony = this._mesh ? this._mesh.absolutePosition.y : 0.0;\n                scene.clipPlane = Plane.FromPositionAndNormal(new Vector3(0, positiony + 0.05, 0), new Vector3(0, 1, 0));\n            }\n        };\n        this._refractionRTT.onAfterRender = () => {\n            if (this._mesh) {\n                this._mesh.isVisible = isVisible;\n            }\n            // Clip plane\n            if (!this.disableClipPlane) {\n                scene.clipPlane = clipPlane;\n            }\n        };\n        this._reflectionRTT.onBeforeRender = () => {\n            if (this._mesh) {\n                isVisible = this._mesh.isVisible;\n                this._mesh.isVisible = false;\n            }\n            // Clip plane\n            if (!this.disableClipPlane) {\n                clipPlane = scene.clipPlane;\n                const positiony = this._mesh ? this._mesh.absolutePosition.y : 0.0;\n                scene.clipPlane = Plane.FromPositionAndNormal(new Vector3(0, positiony - 0.05, 0), new Vector3(0, -1, 0));\n                Matrix.ReflectionToRef(scene.clipPlane, mirrorMatrix);\n            }\n            // Transform\n            savedViewMatrix = scene.getViewMatrix();\n            mirrorMatrix.multiplyToRef(savedViewMatrix, this._reflectionTransform);\n            scene.setTransformMatrix(this._reflectionTransform, scene.getProjectionMatrix());\n            scene._mirroredCameraPosition = Vector3.TransformCoordinates(scene.activeCamera.position, mirrorMatrix);\n        };\n        this._reflectionRTT.onAfterRender = () => {\n            if (this._mesh) {\n                this._mesh.isVisible = isVisible;\n            }\n            // Clip plane\n            scene.clipPlane = clipPlane;\n            // Transform\n            scene.setTransformMatrix(savedViewMatrix, scene.getProjectionMatrix());\n            scene._mirroredCameraPosition = null;\n        };\n    }\n    getAnimatables() {\n        const results = [];\n        if (this.bumpTexture && this.bumpTexture.animations && this.bumpTexture.animations.length > 0) {\n            results.push(this.bumpTexture);\n        }\n        if (this._reflectionRTT && this._reflectionRTT.animations && this._reflectionRTT.animations.length > 0) {\n            results.push(this._reflectionRTT);\n        }\n        if (this._refractionRTT && this._refractionRTT.animations && this._refractionRTT.animations.length > 0) {\n            results.push(this._refractionRTT);\n        }\n        return results;\n    }\n    getActiveTextures() {\n        const activeTextures = super.getActiveTextures();\n        if (this._bumpTexture) {\n            activeTextures.push(this._bumpTexture);\n        }\n        return activeTextures;\n    }\n    hasTexture(texture) {\n        if (super.hasTexture(texture)) {\n            return true;\n        }\n        if (this._bumpTexture === texture) {\n            return true;\n        }\n        return false;\n    }\n    dispose(forceDisposeEffect) {\n        if (this.bumpTexture) {\n            this.bumpTexture.dispose();\n        }\n        let index = this.getScene().customRenderTargets.indexOf(this._refractionRTT);\n        if (index != -1) {\n            this.getScene().customRenderTargets.splice(index, 1);\n        }\n        index = -1;\n        index = this.getScene().customRenderTargets.indexOf(this._reflectionRTT);\n        if (index != -1) {\n            this.getScene().customRenderTargets.splice(index, 1);\n        }\n        if (this._reflectionRTT) {\n            this._reflectionRTT.dispose();\n        }\n        if (this._refractionRTT) {\n            this._refractionRTT.dispose();\n        }\n        // Remove image-processing observer\n        if (this._imageProcessingConfiguration && this._imageProcessingObserver) {\n            this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);\n        }\n        super.dispose(forceDisposeEffect);\n    }\n    clone(name) {\n        return SerializationHelper.Clone(() => new WaterMaterial(name, this.getScene()), this);\n    }\n    serialize() {\n        const serializationObject = super.serialize();\n        serializationObject.customType = \"BABYLON.WaterMaterial\";\n        serializationObject.renderList = [];\n        if (this._refractionRTT && this._refractionRTT.renderList) {\n            for (let i = 0; i < this._refractionRTT.renderList.length; i++) {\n                serializationObject.renderList.push(this._refractionRTT.renderList[i].id);\n            }\n        }\n        return serializationObject;\n    }\n    getClassName() {\n        return \"WaterMaterial\";\n    }\n    // Statics\n    static Parse(source, scene, rootUrl) {\n        const mat = SerializationHelper.Parse(() => new WaterMaterial(source.name, scene), source, scene, rootUrl);\n        mat._waitingRenderList = source.renderList;\n        return mat;\n    }\n    static CreateDefaultMesh(name, scene) {\n        const mesh = CreateGround(name, { width: 512, height: 512, subdivisions: 32, updatable: false }, scene);\n        return mesh;\n    }\n}\n__decorate([\n    serializeAsTexture(\"bumpTexture\")\n], WaterMaterial.prototype, \"_bumpTexture\", void 0);\n__decorate([\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], WaterMaterial.prototype, \"bumpTexture\", void 0);\n__decorate([\n    serializeAsColor3()\n], WaterMaterial.prototype, \"diffuseColor\", void 0);\n__decorate([\n    serializeAsColor3()\n], WaterMaterial.prototype, \"specularColor\", void 0);\n__decorate([\n    serialize()\n], WaterMaterial.prototype, \"specularPower\", void 0);\n__decorate([\n    serialize(\"disableLighting\")\n], WaterMaterial.prototype, \"_disableLighting\", void 0);\n__decorate([\n    expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\n], WaterMaterial.prototype, \"disableLighting\", void 0);\n__decorate([\n    serialize(\"maxSimultaneousLights\")\n], WaterMaterial.prototype, \"_maxSimultaneousLights\", void 0);\n__decorate([\n    expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\n], WaterMaterial.prototype, \"maxSimultaneousLights\", void 0);\n__decorate([\n    serialize()\n], WaterMaterial.prototype, \"windForce\", void 0);\n__decorate([\n    serializeAsVector2()\n], WaterMaterial.prototype, \"windDirection\", void 0);\n__decorate([\n    serialize()\n], WaterMaterial.prototype, \"waveHeight\", void 0);\n__decorate([\n    serialize()\n], WaterMaterial.prototype, \"bumpHeight\", void 0);\n__decorate([\n    serialize(\"bumpSuperimpose\")\n], WaterMaterial.prototype, \"_bumpSuperimpose\", void 0);\n__decorate([\n    expandToProperty(\"_markAllSubMeshesAsMiscDirty\")\n], WaterMaterial.prototype, \"bumpSuperimpose\", void 0);\n__decorate([\n    serialize(\"fresnelSeparate\")\n], WaterMaterial.prototype, \"_fresnelSeparate\", void 0);\n__decorate([\n    expandToProperty(\"_markAllSubMeshesAsMiscDirty\")\n], WaterMaterial.prototype, \"fresnelSeparate\", void 0);\n__decorate([\n    serialize(\"bumpAffectsReflection\")\n], WaterMaterial.prototype, \"_bumpAffectsReflection\", void 0);\n__decorate([\n    expandToProperty(\"_markAllSubMeshesAsMiscDirty\")\n], WaterMaterial.prototype, \"bumpAffectsReflection\", void 0);\n__decorate([\n    serializeAsColor3()\n], WaterMaterial.prototype, \"waterColor\", void 0);\n__decorate([\n    serialize()\n], WaterMaterial.prototype, \"colorBlendFactor\", void 0);\n__decorate([\n    serializeAsColor3()\n], WaterMaterial.prototype, \"waterColor2\", void 0);\n__decorate([\n    serialize()\n], WaterMaterial.prototype, \"colorBlendFactor2\", void 0);\n__decorate([\n    serialize()\n], WaterMaterial.prototype, \"waveLength\", void 0);\n__decorate([\n    serialize()\n], WaterMaterial.prototype, \"waveSpeed\", void 0);\n__decorate([\n    serialize()\n], WaterMaterial.prototype, \"waveCount\", void 0);\n__decorate([\n    serialize()\n], WaterMaterial.prototype, \"disableClipPlane\", void 0);\n__decorate([\n    serialize()\n], WaterMaterial.prototype, \"useLogarithmicDepth\", null);\nRegisterClass(\"BABYLON.WaterMaterial\", WaterMaterial);\n//# sourceMappingURL=waterMaterial.js.map"],"names":["exports","byteLength","b64","lens","getLens","validLen","placeHoldersLen","toByteArray","tmp","i","arr","Arr","_byteLength","curByte","len","revLookup","charCodeAt","fromByteArray","uint8","length","extraBytes","parts","maxChunkLength","len2","push","encodeChunk","lookup","join","Uint8Array","Array","code","Error","indexOf","start","end","num","output","base64","ieee754","customInspectSymbol","Symbol","Buffer","K_MAX_LENGTH","createBuffer","RangeError","buf","Object","setPrototypeOf","prototype","arg","encodingOrOffset","TypeError","allocUnsafe","from","value","string","encoding","isEncoding","actual","write","slice","fromString","ArrayBuffer","isView","arrayView","isInstance","copy","fromArrayBuffer","buffer","byteOffset","fromArrayLike","fromArrayView","SharedArrayBuffer","valueOf","b","obj","isBuffer","checked","undefined","numberIsNaN","type","isArray","data","fromObject","toPrimitive","assertSize","size","array","toString","mustMatch","arguments","loweredCase","utf8ToBytes","base64ToBytes","toLowerCase","slowToString","this","hexSlice","utf8Slice","asciiSlice","latin1Slice","base64Slice","utf16leSlice","swap","n","m","bidirectionalIndexOf","val","dir","arrayIndexOf","call","lastIndexOf","indexSize","arrLength","valLength","String","read","readUInt16BE","foundIndex","found","j","hexWrite","offset","Number","remaining","strLen","parsed","parseInt","substr","utf8Write","blitBuffer","asciiWrite","str","byteArray","asciiToBytes","base64Write","ucs2Write","units","c","hi","lo","utf16leToBytes","Math","min","res","firstByte","codePoint","bytesPerSequence","secondByte","thirdByte","fourthByte","tempCodePoint","codePoints","MAX_ARGUMENTS_LENGTH","fromCharCode","apply","decodeCodePointsArray","TYPED_ARRAY_SUPPORT","proto","foo","e","typedArraySupport","console","error","defineProperty","enumerable","get","poolSize","alloc","fill","allocUnsafeSlow","_isBuffer","compare","a","x","y","concat","list","pos","set","swap16","swap32","swap64","toLocaleString","equals","inspect","max","replace","trim","target","thisStart","thisEnd","thisCopy","targetCopy","includes","isFinite","toJSON","_arr","ret","out","hexSliceLookupTable","bytes","checkOffset","ext","checkInt","wrtBigUInt64LE","checkIntBI","BigInt","wrtBigUInt64BE","checkIEEE754","writeFloat","littleEndian","noAssert","writeDouble","newBuf","subarray","readUintLE","readUIntLE","mul","readUintBE","readUIntBE","readUint8","readUInt8","readUint16LE","readUInt16LE","readUint16BE","readUint32LE","readUInt32LE","readUint32BE","readUInt32BE","readBigUInt64LE","defineBigIntMethod","validateNumber","first","last","boundsError","readBigUInt64BE","readIntLE","pow","readIntBE","readInt8","readInt16LE","readInt16BE","readInt32LE","readInt32BE","readBigInt64LE","readBigInt64BE","readFloatLE","readFloatBE","readDoubleLE","readDoubleBE","writeUintLE","writeUIntLE","writeUintBE","writeUIntBE","writeUint8","writeUInt8","writeUint16LE","writeUInt16LE","writeUint16BE","writeUInt16BE","writeUint32LE","writeUInt32LE","writeUint32BE","writeUInt32BE","writeBigUInt64LE","writeBigUInt64BE","writeIntLE","limit","sub","writeIntBE","writeInt8","writeInt16LE","writeInt16BE","writeInt32LE","writeInt32BE","writeBigInt64LE","writeBigInt64BE","writeFloatLE","writeFloatBE","writeDoubleLE","writeDoubleBE","targetStart","copyWithin","errors","E","sym","getMessage","Base","constructor","super","writable","configurable","name","stack","message","addNumericalSeparator","range","ERR_OUT_OF_RANGE","checkBounds","ERR_INVALID_ARG_TYPE","floor","ERR_BUFFER_OUT_OF_BOUNDS","input","msg","received","isInteger","abs","INVALID_BASE64_RE","Infinity","leadSurrogate","split","base64clean","src","dst","alphabet","table","i16","fn","BufferBigIntNotDefined","MTLFileLoader","materials","parseMTL","scene","rootUrl","assetContainer","lines","delimiter_pattern","color","material","line","charAt","key","substring","_blockEntityCollection","_parentContainer","map","parseFloat","diffuseColor","ambientColor","specularColor","emissiveColor","specularPower","alpha","ambientTexture","_GetTexture","diffuseTexture","specularTexture","values","bumpMultiplierIndex","bumpMultiplier","splice","bumpTexture","level","opacityTexture","static","url","lastDelimiter","INVERT_TEXTURE_Y","SolidParser","materialToUse","babylonMeshesArray","loadingOptions","_positions","_normals","_uvs","_colors","_meshesFromObj","_indicesForBabylon","_wrappedPositionForBabylon","_wrappedUvsForBabylon","_wrappedColorsForBabylon","_wrappedNormalsForBabylon","_tuplePosNorm","_curPositionInIndices","_hasMeshes","_unwrappedPositionsForBabylon","_unwrappedColorsForBabylon","_unwrappedNormalsForBabylon","_unwrappedUVForBabylon","_triangles","_materialNameFromObj","_objMeshName","_increment","_isFirstMaterial","_grayColor","_materialToUse","_babylonMeshesArray","_loadingOptions","_isInArray","normals","idx","_isInArrayUV","uv","_setData","indicePositionFromObj","indiceUvsFromObj","indiceNormalFromObj","positionVectorFromOBJ","textureVectorFromOBJ","normalsVectorFromOBJ","positionColorsFromOBJ","_index","optimizeWithUV","_unwrapData","l","z","importVertexColors","r","g","_getTriangles","faces","v","faceIndex","_setDataForCurrentFaceWithPattern1","face","k","_setDataForCurrentFaceWithPattern2","point","_setDataForCurrentFaceWithPattern3","_setDataForCurrentFaceWithPattern4","_setDataForCurrentFaceWithPattern5","_addPreviousObjMesh","_handledMesh","reverse","indices","positions","uvs","colors","_optimizeNormals","mesh","getVerticesData","mapVertices","lst","normal","v0Idx","vIdx","copyFromFloats","normalize","setVerticesData","parse","meshesNames","onFileToLoadFound","_a","result","VertexPattern","test","match","NormalPattern","exec","UVPattern","UVScaling","FacePattern3","FacePattern4","FacePattern5","FacePattern2","FacePattern1","GroupDescriptor","ObjectDescriptor","objMesh","materialName","UseMtlDescriptor","MtlLibGroupDescriptor","SmoothDescriptor","newMaterial","pointsCloud","disableLighting","directMaterial","babylonMesh","vertexData","computeNormals","applyToMesh","invertY","scaling","optimizeNormals","OBJFileLoader","extensions","_assetContainer","_DefaultLoadingOptions","COMPUTE_NORMALS","OPTIMIZE_NORMALS","IMPORT_VERTEX_COLORS","INVERT_Y","invertTextureY","UV_SCALING","materialLoadingFailsSilently","MATERIAL_LOADING_FAILS_SILENTLY","OPTIMIZE_WITH_UV","skipMaterials","SKIP_MATERIALS","_loadMTL","onSuccess","onFailure","pathOfFile","request","exception","createPlugin","canDirectLoad","importMeshAsync","_parseSolid","then","meshes","particleSystems","skeletons","animationGroups","transformNodes","geometries","lights","loadAsync","loadAssetContainerAsync","container","forEach","getActiveTextures","t","textures","catch","ex","fileToLoad","materialsFromMTLFile","fileName","mtlPromises","Promise","resolve","reject","dataLoaded","startIndex","_indices","dispose","o","getTotalIndices","all","STLFileLoader","solidPattern","facetsPattern","normalPattern","vertexPattern","isBinary","importMesh","matches","_isBinary","_parseBinary","array_buffer","meshName","_parseASCII","load","loadAssetContainer","reader","DataView","getUint32","ascii","off","getUint8","Float32Array","Uint32Array","indicesCount","normalX","getFloat32","normalY","normalZ","vertexstart","DO_NOT_ALTER_FILE_COORDINATES","setIndices","computeWorldMatrix","solidData","facet","normalMatches","lastIndex","vertexMatch","getVector3","_target","source","scale","scaleInPlace","AnimationPropertyInfo","getValue","getStride","_buildAnimation","fps","keys","babylonAnimation","setKeys","TransformNodeAnimationPropertyInfo","buildAnimations","callback","_babylonTransformNode","nodeAnimationData","translation","rotation","weights","_numMorphTargets","targetIndex","frame","inTangent","outTangent","interpolation","_primitiveBabylonMeshes","morphTargetManager","morphTarget","getTarget","babylonAnimationClone","clone","animations","mergeDeep","objects","isObject","reduce","prev","pVal","oVal","ArrayItem","context","index","GLTFLoader","factory","UnregisterExtension","_RegisteredExtensions","gltf","_gltf","bin","_bin","parent","_parent","babylonScene","_babylonScene","rootBabylonMesh","_rootBabylonMesh","_completePromises","_babylonLights","_disableInstancedMesh","_extensions","_disposed","_rootUrl","_fileName","_uniqueRootUrl","_defaultBabylonMaterialData","_postSceneLoadActions","extension","onProgress","_loadData","nodes","nodeMap","node","_loadAsync","_getMeshes","_getSkeletons","_getAnimationGroups","_getTransformNodes","_getGeometries","resultFunc","startsWith","Date","now","_loadExtensions","_checkExtensions","loadingToReadyCounterName","loadingToCompleteCounterName","_startPerformanceCounter","_setState","_extensionsOnLoading","promises","oldBlockMaterialDirtyMechanism","blockMaterialDirtyMechanism","loadOnlyMaterials","loadSceneAsync","scenes","Get","loadAllMaterials","babylonDrawMode","_loadMaterialAsync","compileMaterials","_compileMaterialsAsync","compileShadowGenerators","_compileShadowGeneratorsAsync","setEnabled","_extensionsOnReady","_startAnimations","_endPerformanceCounter","onCompleteObservable","notifyObservers","clear","onErrorObservable","json","_setupData","buffers","uri","binaryBuffer","Assign","accessors","bufferViews","cameras","images","samplers","skins","nodeParents","children","rootNode","_createRootNode","parentIndex","onExtensionLoadedObservable","sort","order","MAX_VALUE","extensionsRequired","some","enabled","coordinateSystemMode","useRightHandedSystem","_LoadTransform","onMeshLoadedObservable","extensionPromise","_extensionsLoadSceneAsync","logOpen","loadNodeAsync","action","_loadAnimationsAsync","logClose","_forEachPrimitive","geometry","getClassName","_babylonTransformNodeForSkin","skin","_data","babylonSkeleton","animation","_babylonAnimationGroup","animationStartMode","babylonAnimationGroups","babylonAnimationGroup","assign","_extensionsLoadNodeAsync","loadNode","babylonTransformNode","AddPointerMetadata","camera","loadCameraAsync","babylonCamera","childNode","childBabylonMesh","nodeName","transformNode","_loadMeshAsync","babylonTransformNodeForSkin","metadata","_loadSkinAsync","skeleton","parentNode","onSkinLoadedObservable","skinnedNode","useBoundingInfoFromGeometry","_updateBoundingInfo","refreshBoundingInfo","primitives","primitive","_loadMeshPrimitiveAsync","_extensionsLoadMeshPrimitiveAsync","shouldInstance","createInstances","targets","babylonAbstractMesh","promise","_instanceData","babylonSourceMesh","createInstance","overrideMaterialSideOrientation","_createMorphTargets","_loadVertexDataAsync","babylonGeometry","_loadMorphTargetsAsync","_GetDrawMode","mode","babylonMaterial","_createDefaultMaterial","onMaterialLoadedObservable","_extensionsLoadVertexDataAsync","attributes","isUnIndexed","accessor","_loadIndicesAccessorAsync","loadAttribute","attribute","kind","_delayInfo","_loadVertexAccessorAsync","babylonVertexBuffer","getKind","alwaysComputeBoundingBox","mmin","mmax","normalized","componentType","divider","_boundingInfo","setVerticesBuffer","count","numBoneInfluencers","hasVertexAlpha","targetNames","extras","getScene","areUpdatesFrozen","weight","addTarget","numTargets","babylonMorphTarget","_loadMorphTargetVertexDataAsync","setData","getVertexBuffer","_loadFloatAccessorAsync","setPositions","setNormals","tangents","dataIndex","setTangents","babylonNode","position","matrix","decompose","rotationQuaternion","_extensionsLoadSkinAsync","skeletonId","_loadBones","_loadSkinInverseBindMatricesDataAsync","inverseBindMatricesData","_updateBoneMatrices","alwaysComputeSkeletonRootNode","_findSkeletonRootNode","joints","isParent","skeletonNode","babylonBones","_loadBone","paths","path","unshift","babylonBone","parentBabylonBone","boneIndex","_getNodeMatrix","linkTransformNode","inverseBindMatrices","bones","baseMatrix","invertToRef","babylonParentBone","getParent","multiplyToRef","getInvertedAbsoluteTransform","updateMatrix","_updateDifferenceMatrix","_extensionsLoadCameraAsync","ignoreParentScaling","_babylonCamera","PI","perspective","fov","yfov","minZ","znear","maxZ","zfar","orthographic","orthoLeft","xmag","orthoRight","orthoBottom","ymag","orthoTop","onCameraLoadedObservable","loadAnimationAsync","animationGroup","targetedAnimations","_extensionsLoadAnimationAsync","channels","channel","_loadAnimationChannelAsync","babylonTarget","addTargetedAnimation","animationContext","onLoad","_extensionsLoadAnimationChannelAsync","targetNode","properties","targetInfo","_loadAnimationChannelFromTargetInfoAsync","targetFps","invfps","sampler","_loadAnimationSamplerAsync","numAnimations","property","stride","outputOffset","babylonAnimatable","inputAccessor","outputAccessor","inputData","outputData","loadBufferAsync","_extensionsLoadBufferAsync","loadUriAsync","readAsync","loadBufferViewAsync","bufferView","_extensionsLoadBufferViewAsync","_loadAccessorAsync","numComponents","_GetNumComponents","byteStride","typedArray","_GetTypedArray","sparse","indicesBufferView","valuesBufferView","indicesData","valuesData","sparseLength","sparseData","valuesIndex","indicesIndex","componentIndex","_GetTypedArrayConstructor","_loadVertexBufferViewAsync","_babylonBuffer","engine","getEngine","_babylonVertexBuffer","babylonBuffer","_loadMaterialMetallicRoughnessPropertiesAsync","baseColorFactor","albedoColor","metallic","metallicFactor","roughness","roughnessFactor","baseColorTexture","loadTextureInfoAsync","texture","albedoTexture","metallicRoughnessTexture","nonColorData","metallicTexture","useMetallnessFromMetallicTextureBlue","useRoughnessFromMetallicTextureGreen","useRoughnessFromMetallicTextureAlpha","_extensionsLoadMaterialAsync","babylonData","createMaterial","babylonMeshes","loadMaterialPropertiesAsync","onDisposeObservable","addOnce","fillMode","enableSpecularAntiAliasing","useRadianceOverAlpha","transparencyAsCoverage","useSpecularOverAlpha","transparencyMode","_extensionsCreateMaterial","_extensionsLoadMaterialPropertiesAsync","loadMaterialBasePropertiesAsync","pbrMetallicRoughness","loadMaterialAlphaProperties","emissiveFactor","doubleSided","backFaceCulling","twoSidedLighting","normalTexture","invertNormalMapX","invertNormalMapY","forceIrradianceInFragment","occlusionTexture","useAmbientInGrayScale","strength","ambientTextureStrength","emissiveTexture","alphaMode","alphaCutOff","alphaCutoff","hasAlpha","useAlphaFromAlbedoTexture","textureInfo","_extensionsLoadTextureInfoAsync","texCoord","_textureInfo","_loadTextureAsync","babylonTexture","coordinatesIndex","onTextureLoadedObservable","_extensionsLoadTextureAsync","DefaultSampler","image","_createTextureAsync","textureLoaderOptions","useSRGBBuffer","samplerData","_loadSampler","deferred","textureCreationOptions","noMipmap","noMipMaps","samplingMode","onError","mimeType","loaderOptions","useSRGBBuffers","loadImageAsync","dataUrl","updateURL","wrapU","wrapV","minFilter","_GetTextureSamplingMode","_GetTextureWrapMode","wrapS","wrapT","_extensionsLoadUriAsync","_ValidateUri","log","preprocessUrlAsync","_loadFile","status","statusText","babylonObject","pointer","_internalMetadata","pointers","magFilter","Int8Array","Int16Array","Uint16Array","componentTypeLength","forceCompilationAsync","useInstances","useClipPlane","clipPlane","light","generator","getShadowGenerator","_forEachExtensions","_applyExtensions","functionName","actionAsync","id","loaderProperty","_activeLoaderExtensionFunctions","activeLoaderExtensionFunctions","onLoading","onReady","_loadUriAsync","extensionName","extra","isExtensionUsed","extensionsUsed","_logOpen","_logClose","_log","startPerformanceCounter","counterName","endPerformanceCounter","NAME","EXT_lights_image_based","loader","_loader","_lights","LoadExtensionAsync","extensionContext","_loadLightAsync","environmentTexture","_loaded","imageData","specularImages","mipmap","specularImageContext","specularImageSize","_babylonTexture","intensity","getReflectionTextureMatrix","irradianceCoefficients","sphericalHarmonics","convertIrradianceToLambertianRadiance","sphericalPolynomial","lodGenerationScale","updateRGBDAsync","RegisterExtension","EXT_mesh_gpu_instancing","instanceCount","translationBuffer","rotationBuffer","scaleBuffer","matrices","thinInstanceSetBuffer","EXT_meshopt_compression","bufferViewMeshopt","_meshOptData","filter","EXT_texture_webp","KHR_draco_mesh_compression","dracoCompression","dividers","uniqueId","_dracoBabylonGeometry","decodeMeshAsync","babylonVertexData","applyToGeometry","KHR_lights","babylonLight","babylonSpotLight","angle","spot","outerConeAngle","innerAngle","innerConeAngle","_babylonLight","falloffType","diffuse","KHR_materials_pbrSpecularGlossiness","_loadSpecularGlossinessPropertiesAsync","diffuseFactor","reflectivityColor","specularFactor","microSurface","glossinessFactor","specularGlossinessTexture","reflectivityTexture","useMicroSurfaceFromReflectivityMapAlpha","KHR_materials_unlit","_loadUnlitPropertiesAsync","unlit","KHR_materials_clearcoat","_loadClearCoatPropertiesAsync","clearCoat","isEnabled","useRoughnessFromMainTexture","remapF0OnInterfaceChange","clearcoatFactor","clearcoatTexture","clearcoatRoughnessFactor","clearcoatRoughnessTexture","textureRoughness","clearcoatNormalTexture","KHR_materials_iridescence","_loadIridescencePropertiesAsync","_b","_c","_d","_e","iridescence","iridescenceFactor","indexOfRefraction","iridescenceIor","iridescenceIOR","minimumThickness","iridescenceThicknessMinimum","maximumThickness","iridescenceThicknessMaximum","iridescenceTexture","iridescenceThicknessTexture","thicknessTexture","KHR_materials_emissive_strength","_loadEmissiveProperties","emissiveStrength","scaleToRef","KHR_materials_sheen","_loadSheenPropertiesAsync","sheen","sheenColorFactor","sheenColorTexture","sheenRoughnessFactor","sheenRoughnessTexture","albedoScaling","KHR_materials_specular","_loadSpecularPropertiesAsync","metallicF0Factor","specularColorFactor","metallicReflectanceColor","metallicReflectanceTexture","useOnlyMetallicFromMetallicReflectanceTexture","specularColorTexture","reflectanceTexture","KHR_materials_ior","_loadIorPropertiesAsync","ior","_DEFAULT_IOR","KHR_materials_variants","rootMesh","extensionMetadata","_GetExtensionMetadata","variants","getAvailableVariants","GetAvailableVariants","variantName","select","entries","entry","lastSelected","selectVariant","SelectVariant","original","reset","Reset","getLastSelectedVariant","GetLastSelectedVariant","_variants","root","mappingIndex","mappings","mapping","mappingVariantIndex","variantIndex","variant","onClonedObservable","add","newOne","newMesh","newRoot","hasOwnProperty","variantEntry","TransmissionHelper","renderSize","samples","lodGenerationOffset","renderTargetTextureType","generateMipmaps","options","_opaqueRenderTarget","_opaqueMeshesCache","_transparentMeshesCache","_materialObservers","_options","_GetDefaultOptions","_scene","_transmissionHelper","_parseScene","_setupRenderTargets","updateOptions","newOptions","oldOptions","getOpaqueTarget","_shouldRenderAsTransmission","subSurface","isRefractionEnabled","_addMesh","onMaterialChangedObservable","_onMeshMaterialChanged","bind","refractionTexture","_removeMesh","remove","onNewMeshAddedObservable","onMeshRemovedObservable","transparentIdx","opaqueIdx","sceneImageProcessingapplyByPostProcess","saveSceneEnvIntensity","ignoreCameraViewport","renderList","clearColor","gammaSpace","onBeforeBindObservable","opaqueRenderTarget","environmentIntensity","imageProcessingConfiguration","applyByPostProcess","copyFrom","toLinearSpaceToRef","_applyByPostProcess","onAfterUnbindObservable","KHR_materials_transmission","_loadTransparentPropertiesAsync","pbrMaterial","volumeIndexOfRefraction","useAlbedoToTintRefraction","transmissionFactor","refractionIntensity","transmissionTexture","refractionIntensityTexture","useGltfStyleTextures","KHR_materials_translucency","_loadTranslucentPropertiesAsync","isTranslucencyEnabled","useAlbedoToTintTranslucency","translucencyFactor","translucencyIntensity","translucencyTexture","translucencyIntensityTexture","KHR_materials_volume","_loadVolumePropertiesAsync","thicknessFactor","attenuationDistance","tintColorAtDistance","attenuationColor","tintColor","useThicknessAsDepth","KHR_mesh_quantization","KHR_texture_basisu","useRGBAIfASTCBC7NotAvailableWhenUASTC","KHR_texture_transform","uOffset","vOffset","uRotationCenter","vRotationCenter","wAng","uScale","vScale","KHR_xmp_json_ld","xmp_gltf","xmp_node","asset","packet","packets","xmp","getColor3","getFloat","getMinusFloat","getNextFloat","getFloatBy2","getTextureTransformTree","textureName","MaterialAnimationPropertyInfo","CameraAnimationPropertyInfo","LightAnimationPropertyInfo","nodesTree","__array__","__target__","camerasTree","animationPointerTree","KHR_lights_punctual","KHR_animation_pointer","_parseAnimationPointer","shift","gltfTargetNode","gltfCurrentNode","part","MSFT_audio_emitter","_clips","_emitters","clips","emitters","emitterIndex","emitter","refDistance","maxDistance","rolloffFactor","distanceModel","outerAngle","_loadEmitterAsync","sound","_babylonSounds","attachToMesh","setLocalDirectionToMesh","setDirectionalCone","events","event","_loadAnimationEventAsync","_loadClipAsync","clip","_objectURL","URL","createObjectURL","Blob","_babylonData","clipPromises","loop","autoplay","volume","clipContext","objectURL","weightedSound","directionalConeInnerAngle","directionalConeOuterAngle","loaded","_getEventAction","time","startOffset","currentFrame","frameOffset","play","stop","pause","babylonAnimationEvent","addEvent","onAnimationGroupEndObservable","onAnimationGroupPauseObservable","MSFT_lod","maxLODsToLoad","onNodeLODsLoadedObservable","onMaterialLODsLoadedObservable","_bufferLODs","_nodeIndexLOD","_nodeSignalLODs","_nodePromiseLODs","_nodeBufferLODs","_materialIndexLOD","_materialSignalLODs","_materialPromiseLODs","_materialBufferLODs","indexLOD","_loadBufferLOD","firstPromise","nodeLODs","_getLODs","ids","nodeLOD","assignWrap","previousNodeLOD","_disposeTransformNode","materialLODs","materialLOD","previousDataLOD","_disposeMaterials","previousIndexLOD","useRangeRequests","bufferLODs","bufferLOD","babylonMaterials","getChildMeshes","babylonMaterialsToDispose","every","babylonTextures","hasTexture","MSFT_minecraftMesh","LoadExtraAsync","extraContext","needAlphaBlending","forceDepthWrite","separateCullingPass","MSFT_sRGBFactors","ExtrasAsMetadata","_assignExtras","gltfProp","GLTFLoaderCoordinateSystemMode","GLTFLoaderAnimationStartMode","GLTFLoaderState","arrayBuffer","GLTFFileLoader","onParsedObservable","AUTO","FIRST","validate","onValidatedObservable","_state","_requests","onLoaderStateChangedObservable","_logIndentLevel","_loggingEnabled","_logDisabled","_capturePerformanceCounters","_startPerformanceCounterDisabled","_endPerformanceCounterDisabled","onParsed","_onParsedObserver","onMeshLoaded","_onMeshLoadedObserver","onTextureLoaded","_onTextureLoadedObserver","onMaterialLoaded","_onMaterialLoadedObserver","onCameraLoaded","_onCameraLoadedObserver","onComplete","_onCompleteObserver","_onErrorObserver","onDispose","_onDisposeObserver","onExtensionLoaded","_onExtensionLoadedObserver","loggingEnabled","_logEnabled","capturePerformanceCounters","_startPerformanceCounterEnabled","_endPerformanceCounterEnabled","onValidated","_onValidatedObserver","abort","_progressCallback","loadFile","fileOrUrl","useArrayBuffer","fileRequest","dataBuffer","webRequest","setRequestHeader","_unpackBinaryAsync","loaderData","_validate","_parseJson","_getLoader","_MagicBase64Encoded","directLoad","loaderState","whenCompleteAsync","reason","state","onOpened","_onProgress","_lengthComputable","lengthComputable","_total","total","_loadFileAsync","version","minVersion","_parseVersion","_compareVersion","major","minor","createLoader","_CreateGLTF1Loader","_CreateGLTF2Loader","JSON","dataReader","magic","readUint32","unpacked","_unpackBinaryV1Async","_unpackBinaryV2Async","contentLength","contentFormat","bodyLength","readString","startByteOffset","ChunkFormat","chunkLength","skipBytes","spaces","_logSpaces","Log","IncrementalLoading","HomogeneousCoordinates","validateAsync","getExternalResource","externalResourceFunction","GLTFValidator","validateBytes","validateString","workerFunc","pendingExternalResources","onmessage","importScripts","postMessage","GLTFValidation","Worker","workerContent","workerBlobUrl","worker","removeEventListener","onMessage","terminate","addEventListener","Configuration","_LoadScriptPromise","EComponentType","EShaderType","EParameterType","ETextureWrapMode","ETextureFilterType","ETextureFormat","ECullingType","EBlendingFunction","GLTFUtils","parameter","uniformName","shaderMaterial","mat","semantic","getWorldMatrix","getProjectionMatrix","getViewMatrix","multiply","invert","getTransformMatrix","FLOAT_MAT2","setMatrix2x2","FLOAT_MAT3","setMatrix3x3","FLOAT_MAT4","setMatrix","uniform","FLOAT","setFloat","FLOAT_VEC2","setVector2","FLOAT_VEC3","setVector3","FLOAT_VEC4","setVector4","CLAMP_TO_EDGE","MIRRORED_REPEAT","REPEAT","LINEAR","LINEAR_MIPMAP_NEAREST","LINEAR_MIPMAP_LINEAR","NEAREST","NEAREST_MIPMAP_NEAREST","gltfRuntime","loadedBufferView","loadedBufferViews","BYTE","UNSIGNED_BYTE","SHORT","UNSIGNED_SHORT","GetByteStrideFromType","GetBufferFromBufferView","view","_DefaultMaterial","shaderPath","vertex","fragment","uniforms","setColor4","ETokenType","Tokenizer","toParse","_pos","currentToken","UNKNOWN","currentIdentifier","currentString","isLetterOrDigitPattern","_toParse","_maxPos","getNextToken","isEnd","END_OF_INPUT","IDENTIFIER","peek","forward","glTFTransforms","babylonTransforms","glTFAnimationPaths","babylonAnimationPaths","parseObject","parsedObjects","runtimeProperty","object","parsedObject","normalizeUVs","getAttribute","attributeParameter","configureBoneTransformation","getParentBone","jointName","newSkeleton","nde","child","bone","getNodeToRoot","nodesToRoot","nodeToRoot","getJointNode","nodeIsInJoints","jointNames","importSkeleton","nodesToRootToAdd","getNodesToRoot","jointNode","existingBone","getBoneById","foundBone","parentBone","joint","prepare","subMaterials","verticesStarts","verticesCounts","indexStarts","indexCounts","meshIndex","meshId","tempVertexData","GetBufferFromAccessor","uvKind","matricesIndices","matricesWeights","Int32Array","merge","getMaterialById","GetDefaultMaterial","subMeshes","configureNode","newNode","importNode","lastNode","importOnlyMeshes","importMeshesNames","getLastSkeletonById","orthoCamera","attachControl","perspectiveCamera","persCamera","aspectRatio","getRenderWidth","getRenderHeight","ambienLight","hemiLight","directionalLight","dirLight","pointLight","ptLight","spotLight","spLight","fallOfAngle","fallOffExponent","exponent","dummy","configureNodeFromMatrix","updateCache","traverseNodes","meshIncluded","postLoad","currentScene","thing","anim","lastAnimation","parameters","bufferInput","bufferOutput","targetId","getNodeById","getNodeByName","isBone","targetPath","targetPathIndex","animationType","arrayOffset","modifyKey","getKeys","getBaseMatrix","stopAnimation","beginAnimation","loadAnimations","onShaderCompileSuccess","technique","unTreatedUniforms","_","materialValues","techniqueUniforms","unif","onLoadTexture","setTexture","SAMPLER_2D","GLTFLoaderExtension","LoadTextureAsync","SetUniform","prepareShaderMaterialUniforms","onBind","SetMatrix","getEffect","onBindShaderMaterial","parseShaderUniforms","tokenizer","uniformParameter","transformIndex","importMaterials","LoadMaterialAsync","GLTFLoaderBase","parsedData","shaders","programs","techniques","buffersCount","shaderscount","loadedBufferCount","loadedShaderCount","dummyNodes","parsedBuffers","parsedBuffer","parseBuffers","parsedShaders","sha","parsedShader","parseShaders","setTimeout","createMipMaps","NEAREST_MIPMAP_LINEAR","blob","blobURL","revokeBlobURL","revokeObjectURL","newTexture","GetWrapMode","shader","shaderString","atob","defaultMaterial","sideOrientation","program","states","vertexShader","pixelShader","fragmentShader","newVertexShader","newPixelShader","vertexTokenizer","pixelTokenizer","attr","foundAttribute","enable","effect","onShaderCompileError","onCompiled","functions","cullFace","BACK","blendFunc","blendFuncSeparate","SRC_ALPHA","ONE_MINUS_SRC_ALPHA","ONE","ZERO","ONE_MINUS_SRC_COLOR","DST_COLOR","Extensions","_importMeshAsync","LoadRuntimeAsync","_createNodes","skl","_loadBuffersAsync","_loadShadersAsync","LoadRuntimeExtensionsAsync","onload","hasShaders","processShader","LoadShaderStringAsync","VERTEX","hasBuffers","processBuffer","LoadBufferAsync","_name","loadRuntimeAsync","loadRuntimeExtensionsAsync","loadTextureBufferAsync","createTextureAsync","loadShaderStringAsync","loadMaterialAsync","_ApplyExtensions","loaderExtension","CreateRuntime","_LoadTextureBufferAsync","_CreateTextureAsync","LoadTextureBufferAsync","CreateTextureAsync","func","defaultFunc","sourceExt","binaryExtensionShader","shaderBytes","DecodeBufferToText","ambientLight","ambient","directional","fallOffAngle","standardMaterial","transparency","shininess","_loadTexture","emission","specular","propertyPath","_refractionRTT"],"sourceRoot":""}